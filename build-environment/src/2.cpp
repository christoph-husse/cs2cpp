#include "stdafx_mscorlib.hpp"

namespace System {
    
    
    void AppDomainManager::constructor() {
        this->_flags = AppDomainManagerInitializationOptions::None;
    }
    
    AppDomain* AppDomainManager::CreateDomain_e0cc55be844f0adc(String* friendlyName, Security::Policy::Evidence* securityInfo, AppDomainSetup* appDomainInfo) {
        InitializeNewDomain_e52e2ebfedaaf98d(appDomainInfo);
        AppDomain *ad = CreateDomainHelper(friendlyName, securityInfo, appDomainInfo);
        if(((int32_t)(((int32_t)(this->get_HostSecurityManager_78a0d9527aa5ded3()->get_Flags_b631cff0eaaa13d7()) & 2)) ==  2)) 
        {
            Security::Policy::PolicyLevel *pl = this->get_HostSecurityManager_78a0d9527aa5ded3()->get_DomainPolicy_4232e39de784c0b3();
            if((pl != nullptr)) 
            {
                ad->SetAppDomainPolicy(pl);
            }
        }
        return ad;
    }
    
    void AppDomainManager::InitializeNewDomain_e52e2ebfedaaf98d(AppDomainSetup* appDomainInfo) {
    }
    
    bool AppDomainManager::CheckSecuritySettings_2015fecad7c95253(Security::SecurityState* state) {
        return false;
    }
    
    AppDomain* AppDomainManager::CreateDomainHelper(String* friendlyName, Security::Policy::Evidence* securityInfo, AppDomainSetup* appDomainInfo) {
        return AppDomain::CreateDomain3(friendlyName, securityInfo, appDomainInfo);
    }
    
    Runtime::Hosting::ApplicationActivator* AppDomainManager::get_ApplicationActivator_128e5f63aa18eebc() {
        if((this->_activator ==  nullptr)) 
        {
            this->_activator = cli::gcnew<Runtime::Hosting::ApplicationActivator>();
        }
        return this->_activator;
    }
    
    Reflection::Assembly* AppDomainManager::get_EntryAssembly_1ba7bde2af04ce13() {
        return Reflection::Assembly::GetEntryAssembly();
    }
    
    Threading::HostExecutionContextManager* AppDomainManager::get_HostExecutionContextManager_acf5ce766691b961() {
        throw cli::gcnew<NotImplementedException>();
    }
    
    Security::HostSecurityManager* AppDomainManager::get_HostSecurityManager_78a0d9527aa5ded3() {
        return nullptr;
    }
    
    AppDomainManagerInitializationOptions AppDomainManager::get_InitializationFlags() {
        return this->_flags;
    }
    
    AppDomainManagerInitializationOptions AppDomainManager::set_InitializationFlags(AppDomainManagerInitializationOptions value) {
        this->_flags = value;
        return get_InitializationFlags();
    }
    
}
namespace System {
    
    
    void AppDomainSetup::constructor() {
    }
    
    void AppDomainSetup::constructor(AppDomainSetup* setup) {
        this->application_base = setup->application_base;
        this->application_name = setup->application_name;
        this->cache_path = setup->cache_path;
        this->configuration_file = setup->configuration_file;
        this->dynamic_base = setup->dynamic_base;
        this->license_file = setup->license_file;
        this->private_bin_path = setup->private_bin_path;
        this->private_bin_path_probe = setup->private_bin_path_probe;
        this->shadow_copy_directories = setup->shadow_copy_directories;
        this->shadow_copy_files = setup->shadow_copy_files;
        this->publisher_policy = setup->publisher_policy;
        this->path_changed = setup->path_changed;
        this->loader_optimization = setup->loader_optimization;
        this->disallow_binding_redirects = setup->disallow_binding_redirects;
        this->disallow_code_downloads = setup->disallow_code_downloads;
        this->_activationArguments = setup->_activationArguments;
        this->domain_initializer = setup->domain_initializer;
        this->application_trust = setup->application_trust;
        this->domain_initializer_args = setup->domain_initializer_args;
        this->disallow_appbase_probe = setup->disallow_appbase_probe;
        this->configuration_bytes = setup->configuration_bytes;
    }
    
    void AppDomainSetup::constructor(Runtime::Hosting::ActivationArguments* activationArguments) {
        this->_activationArguments = activationArguments;
    }
    
    void AppDomainSetup::constructor(ActivationContext* activationContext) {
        this->_activationArguments = cli::gcnew<Runtime::Hosting::ActivationArguments>(activationContext);
    }
    
    String* AppDomainSetup::GetAppBase(String* appBase) {
        if((appBase ==  nullptr)) 
        {
            return nullptr;
        }
        int32_t len = appBase->get_Length();
        if(((len >= 8) && appBase->ToLower()->StartsWith(_T("file://")))) 
        {
            appBase = appBase->Substring(7);
            if(((int32_t)(IO::Path::DirectorySeparatorChar) != 47)) 
            {
                appBase = appBase->Replace(u'/', IO::Path::DirectorySeparatorChar);
            }
            if(Environment::get_IsRunningOnWindows()) 
            {
                appBase = cli::concat(_T("//"), appBase);
            }
        }
         else 
        {
            appBase = IO::Path::GetFullPath(appBase);
        }
        return appBase;
    }
    
    cli::array<unsigned char>* AppDomainSetup::GetConfigurationBytes() {
        return (this->configuration_bytes != nullptr) ? cli::as<cli::array<unsigned char>*>(cli::import(this->configuration_bytes)->Clone()) : nullptr;
    }
    
    void AppDomainSetup::SetConfigurationBytes(cli::array<unsigned char>* value) {
        this->configuration_bytes = value;
    }
    
    void AppDomainSetup::DeserializeNonPrimitives() {
        {
            cli::lock_guard{this};
            if((this->serialized_non_primitives ==  nullptr)) 
            {
                return;
            }
            Runtime::Serialization::Formatters::Binary::BinaryFormatter *bf = cli::gcnew<Runtime::Serialization::Formatters::Binary::BinaryFormatter>();
            IO::MemoryStream *ms = cli::gcnew<IO::MemoryStream>(this->serialized_non_primitives);
            cli::array<Object*> *arr = cli::cast<cli::array<Object*>*>(bf->Deserialize(ms));
            this->_activationArguments = cli::cast<Runtime::Hosting::ActivationArguments*>(arr->at(0));
            this->domain_initializer = cli::cast<AppDomainInitializer*>(arr->at(1));
            this->application_trust = cli::cast<Security::Policy::ApplicationTrust*>(arr->at(2));
            this->serialized_non_primitives = nullptr;
        }
    }
    
    void AppDomainSetup::SerializeNonPrimitives() {
        cli::array<Object*> *arr = (new cli::array<Object*>(3));
        arr->at(0) = this->_activationArguments;
        arr->at(1) = this->domain_initializer;
        arr->at(2) = this->application_trust;
        Runtime::Serialization::Formatters::Binary::BinaryFormatter *bf = cli::gcnew<Runtime::Serialization::Formatters::Binary::BinaryFormatter>();
        IO::MemoryStream *ms = cli::gcnew<IO::MemoryStream>();
        bf->Serialize(ms, arr);
        this->serialized_non_primitives = ms->ToArray_ebf8bde16e9d2ad6();
    }
    
    void AppDomainSetup::SetCompatibilitySwitches(Collections::Generic::IEnumerable2<String*>* switches) {
    }
    
    String* AppDomainSetup::get_ApplicationBase() {
        return GetAppBase(this->application_base);
    }
    
    String* AppDomainSetup::set_ApplicationBase(String* value) {
        this->application_base = value;
        return get_ApplicationBase();
    }
    
    String* AppDomainSetup::get_ApplicationName() {
        return this->application_name;
    }
    
    String* AppDomainSetup::set_ApplicationName(String* value) {
        this->application_name = value;
        return get_ApplicationName();
    }
    
    String* AppDomainSetup::get_CachePath() {
        return this->cache_path;
    }
    
    String* AppDomainSetup::set_CachePath(String* value) {
        this->cache_path = value;
        return get_CachePath();
    }
    
    String* AppDomainSetup::get_ConfigurationFile() {
        if((this->configuration_file ==  nullptr)) 
        {
            return nullptr;
        }
        if(IO::Path::IsPathRooted(this->configuration_file)) 
        {
            return this->configuration_file;
        }
        if((this->get_ApplicationBase() ==  nullptr)) 
        {
            throw cli::gcnew<MemberAccessException>(_T("The ApplicationBase must be set before retrieving this property."));
        }
        return IO::Path::Combine(this->get_ApplicationBase(), this->configuration_file);
    }
    
    String* AppDomainSetup::set_ConfigurationFile(String* value) {
        this->configuration_file = value;
        return get_ConfigurationFile();
    }
    
    bool AppDomainSetup::get_DisallowPublisherPolicy() {
        return this->publisher_policy;
    }
    
    bool AppDomainSetup::set_DisallowPublisherPolicy(bool value) {
        this->publisher_policy = value;
        return get_DisallowPublisherPolicy();
    }
    
    String* AppDomainSetup::get_DynamicBase() {
        if((this->dynamic_base ==  nullptr)) 
        {
            return nullptr;
        }
        if(IO::Path::IsPathRooted(this->dynamic_base)) 
        {
            return this->dynamic_base;
        }
        if((this->get_ApplicationBase() ==  nullptr)) 
        {
            throw cli::gcnew<MemberAccessException>(_T("The ApplicationBase must be set before retrieving this property."));
        }
        return IO::Path::Combine(this->get_ApplicationBase(), this->dynamic_base);
    }
    
    String* AppDomainSetup::set_DynamicBase(String* value) {
        if((this->application_name ==  nullptr)) 
        {
            throw cli::gcnew<MemberAccessException>(_T("ApplicationName must be set before the DynamicBase can be set."));
        }
        uint32_t id = (uint32_t)this->application_name->GetHashCode_6648aef0f235ee6c();
        this->dynamic_base = IO::Path::Combine(value, cli::import(id)->ToString4(_T("x")));
        return get_DynamicBase();
    }
    
    String* AppDomainSetup::get_LicenseFile() {
        return this->license_file;
    }
    
    String* AppDomainSetup::set_LicenseFile(String* value) {
        this->license_file = value;
        return get_LicenseFile();
    }
    
    LoaderOptimization AppDomainSetup::get_LoaderOptimization() {
        return this->loader_optimization;
    }
    
    LoaderOptimization AppDomainSetup::set_LoaderOptimization(LoaderOptimization value) {
        this->loader_optimization = value;
        return get_LoaderOptimization();
    }
    
    String* AppDomainSetup::get_PrivateBinPath() {
        return this->private_bin_path;
    }
    
    String* AppDomainSetup::set_PrivateBinPath(String* value) {
        this->private_bin_path = value;
        this->path_changed = true;
        return get_PrivateBinPath();
    }
    
    String* AppDomainSetup::get_PrivateBinPathProbe() {
        return this->private_bin_path_probe;
    }
    
    String* AppDomainSetup::set_PrivateBinPathProbe(String* value) {
        this->private_bin_path_probe = value;
        this->path_changed = true;
        return get_PrivateBinPathProbe();
    }
    
    String* AppDomainSetup::get_ShadowCopyDirectories() {
        return this->shadow_copy_directories;
    }
    
    String* AppDomainSetup::set_ShadowCopyDirectories(String* value) {
        this->shadow_copy_directories = value;
        return get_ShadowCopyDirectories();
    }
    
    String* AppDomainSetup::get_ShadowCopyFiles() {
        return this->shadow_copy_files;
    }
    
    String* AppDomainSetup::set_ShadowCopyFiles(String* value) {
        this->shadow_copy_files = value;
        return get_ShadowCopyFiles();
    }
    
    bool AppDomainSetup::get_DisallowBindingRedirects() {
        return this->disallow_binding_redirects;
    }
    
    bool AppDomainSetup::set_DisallowBindingRedirects(bool value) {
        this->disallow_binding_redirects = value;
        return get_DisallowBindingRedirects();
    }
    
    bool AppDomainSetup::get_DisallowCodeDownload() {
        return this->disallow_code_downloads;
    }
    
    bool AppDomainSetup::set_DisallowCodeDownload(bool value) {
        this->disallow_code_downloads = value;
        return get_DisallowCodeDownload();
    }
    
    Runtime::Hosting::ActivationArguments* AppDomainSetup::get_ActivationArguments() {
        if((this->_activationArguments != nullptr)) 
        {
            return this->_activationArguments;
        }
        DeserializeNonPrimitives();
        return this->_activationArguments;
    }
    
    Runtime::Hosting::ActivationArguments* AppDomainSetup::set_ActivationArguments(Runtime::Hosting::ActivationArguments* value) {
        this->_activationArguments = value;
        return get_ActivationArguments();
    }
    
    AppDomainInitializer* AppDomainSetup::get_AppDomainInitializer() {
        if((this->domain_initializer != nullptr)) 
        {
            return this->domain_initializer;
        }
        DeserializeNonPrimitives();
        return this->domain_initializer;
    }
    
    AppDomainInitializer* AppDomainSetup::set_AppDomainInitializer(AppDomainInitializer* value) {
        this->domain_initializer = value;
        return get_AppDomainInitializer();
    }
    
    cli::array<String*>* AppDomainSetup::get_AppDomainInitializerArguments() {
        return this->domain_initializer_args;
    }
    
    cli::array<String*>* AppDomainSetup::set_AppDomainInitializerArguments(cli::array<String*>* value) {
        this->domain_initializer_args = value;
        return get_AppDomainInitializerArguments();
    }
    
    Security::Policy::ApplicationTrust* AppDomainSetup::get_ApplicationTrust() {
        if((this->application_trust != nullptr)) 
        {
            return this->application_trust;
        }
        DeserializeNonPrimitives();
        if((this->application_trust ==  nullptr)) 
        {
            this->application_trust = cli::gcnew<Security::Policy::ApplicationTrust>();
        }
        return this->application_trust;
    }
    
    Security::Policy::ApplicationTrust* AppDomainSetup::set_ApplicationTrust(Security::Policy::ApplicationTrust* value) {
        this->application_trust = value;
        return get_ApplicationTrust();
    }
    
    bool AppDomainSetup::get_DisallowApplicationBaseProbing() {
        return this->disallow_appbase_probe;
    }
    
    bool AppDomainSetup::set_DisallowApplicationBaseProbing(bool value) {
        this->disallow_appbase_probe = value;
        return get_DisallowApplicationBaseProbing();
    }
    
}
namespace System {
    
    
    void AppDomainUnloadedException::constructor() {
        this->set_HResult(-2146234348);
    }
    
    void AppDomainUnloadedException::constructor(String* message) {
        this->set_HResult(-2146234348);
    }
    
    void AppDomainUnloadedException::constructor(String* message, Exception* innerException) {
        this->set_HResult(-2146234348);
    }
    
    void AppDomainUnloadedException::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
    }
    
}
namespace System {
    
    
    void ApplicationException::constructor() {
        this->set_HResult(-2146232832);
    }
    
    void ApplicationException::constructor(String* message) {
        this->set_HResult(-2146232832);
    }
    
    void ApplicationException::constructor(String* message, Exception* innerException) {
        this->set_HResult(-2146232832);
    }
    
    void ApplicationException::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
    }
    
}
namespace System {
    
    
    void ApplicationId::constructor(cli::array<unsigned char>* publicKeyToken, String* name, Version* version, String* processorArchitecture, String* culture) {
        if((publicKeyToken ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("publicKeyToken"));
        }
        if((name ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("name"));
        }
        if(Version::op_Equality(version, nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("version"));
        }
        this->_token = cli::cast<cli::array<unsigned char>*>(cli::import(publicKeyToken)->Clone());
        this->_name = name;
        this->_version = version;
        this->_proc = processorArchitecture;
        this->_culture = culture;
    }
    
    ApplicationId* ApplicationId::Copy() {
        return cli::gcnew<ApplicationId>(this->_token, this->_name, this->_version, this->_proc, this->_culture);
    }
    
    bool ApplicationId::Equals_ed975d2f4a7d193e(Object* o) {
        if((o ==  nullptr)) 
        {
            return false;
        }
        ApplicationId *appid = cli::as<ApplicationId*>(o);
        if((appid ==  nullptr)) 
        {
            return false;
        }
        if(String::op_Inequality(this->_name, appid->_name)) 
        {
            return false;
        }
        if(String::op_Inequality(this->_proc, appid->_proc)) 
        {
            return false;
        }
        if(String::op_Inequality(this->_culture, appid->_culture)) 
        {
            return false;
        }
        if(!(this->_version->Equals4(appid->_version))) 
        {
            return false;
        }
        if((this->_token->get_Length() != appid->_token->get_Length())) 
        {
            return false;
        }
        for(int32_t i = 0; (i < this->_token->get_Length()); i++) {
            if(((int32_t)(this->_token->at(i)) != (int32_t)(appid->_token->at(i)))) 
            {
                return false;
            }
        }
        return true;
    }
    
    int32_t ApplicationId::GetHashCode_6648aef0f235ee6c() {
        int32_t code = (this->_name->GetHashCode_6648aef0f235ee6c() ^ this->_version->GetHashCode_6648aef0f235ee6c());
        for(int32_t i = 0; (i < this->_token->get_Length()); i++) {
            (code = code ^ (int32_t)(this->_token->at(i)));
        }
        return code;
    }
    
    String* ApplicationId::ToString_1636a0751cb9ac11() {
        Text::StringBuilder *sb = cli::gcnew<Text::StringBuilder>();
        sb->Append2(this->_name);
        if((this->_culture != nullptr)) 
        {
            sb->AppendFormat3(_T(", culture=\"{0}\""), this->_culture);
        }
        sb->AppendFormat3(_T(", version=\"{0}\", publicKeyToken=\""), this->_version);
        for(int32_t i = 0; (i < this->_token->get_Length()); i++) {
            sb->Append2(cli::import(this->_token->at(i))->ToString3(_T("X2")));
        }
        if((this->_proc != nullptr)) 
        {
            sb->AppendFormat3(_T("\", processorArchitecture =\"{0}\""), this->_proc);
        }
         else 
        {
            sb->Append2(_T("\""));
        }
        return sb->ToString_1636a0751cb9ac11();
    }
    
    String* ApplicationId::get_Culture() {
        return this->_culture;
    }
    
    String* ApplicationId::get_Name() {
        return this->_name;
    }
    
    String* ApplicationId::get_ProcessorArchitecture() {
        return this->_proc;
    }
    
    cli::array<unsigned char>* ApplicationId::get_PublicKeyToken() {
        return cli::cast<cli::array<unsigned char>*>(cli::import(this->_token)->Clone());
    }
    
    Version* ApplicationId::get_Version() {
        return this->_version;
    }
    
}
namespace System {
    
    
    void ApplicationIdentity::constructor(String* applicationIdentityFullName) {
        if((applicationIdentityFullName ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("applicationIdentityFullName"));
        }
        if((applicationIdentityFullName->IndexOf7(_T(", Culture=")) ==  -1)) 
        {
            this->_fullName = cli::concat(applicationIdentityFullName, _T(", Culture=neutral"));
        }
         else 
        {
            this->_fullName = applicationIdentityFullName;
        }
    }
    
    String* ApplicationIdentity::ToString_1636a0751cb9ac11() {
        return this->_fullName;
    }
    
    void ApplicationIdentity::GetObjectData(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        if((info ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("info"));
        }
    }
    
    String* ApplicationIdentity::get_CodeBase() {
        return this->_codeBase;
    }
    
    String* ApplicationIdentity::get_FullName() {
        return this->_fullName;
    }
    
}
namespace System {
    
    
    void ArgumentException::constructor() {
        this->set_HResult(-2147024809);
    }
    
    void ArgumentException::constructor(String* message) {
        this->set_HResult(-2147024809);
    }
    
    void ArgumentException::constructor(String* message, Exception* innerException) {
        this->set_HResult(-2147024809);
    }
    
    void ArgumentException::constructor(String* message, String* paramName) {
        this->param_name = paramName;
        this->set_HResult(-2147024809);
    }
    
    void ArgumentException::constructor(String* message, String* paramName, Exception* innerException) {
        this->param_name = paramName;
        this->set_HResult(-2147024809);
    }
    
    void ArgumentException::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        this->param_name = info->GetString(_T("ParamName"));
    }
    
    void ArgumentException::GetObjectData_bc9b88d7eb43b6d8(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        SystemException::GetObjectData_bc9b88d7eb43b6d8(info, context);
        info->AddValue16(_T("ParamName"), this->get_ParamName_299aa21f59781bb8());
    }
    
    String* ArgumentException::get_ParamName_299aa21f59781bb8() {
        return this->param_name;
    }
    
    String* ArgumentException::get_Message_d211df4045b57cbf() {
        if(((this->get_ParamName_299aa21f59781bb8() != nullptr) && (this->get_ParamName_299aa21f59781bb8()->get_Length() != 0))) 
        {
            return cli::concat(SystemException::get_Message_d211df4045b57cbf(), Environment::get_NewLine());
        }
        return SystemException::get_Message_d211df4045b57cbf();
    }
    
}
namespace System {
    
    
    void ArgumentNullException::constructor() {
        this->set_HResult(-2147467261);
    }
    
    void ArgumentNullException::constructor(String* paramName) {
        this->set_HResult(-2147467261);
    }
    
    void ArgumentNullException::constructor(String* paramName, String* message) {
        this->set_HResult(-2147467261);
    }
    
    void ArgumentNullException::constructor(String* message, Exception* innerException) {
        this->set_HResult(-2147467261);
    }
    
    void ArgumentNullException::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
    }
    
}
namespace System {
    
    
    void ArgumentOutOfRangeException::constructor() {
        this->set_HResult(-2146233086);
    }
    
    void ArgumentOutOfRangeException::constructor(String* paramName) {
        this->set_HResult(-2146233086);
    }
    
    void ArgumentOutOfRangeException::constructor(String* paramName, String* message) {
        this->set_HResult(-2146233086);
    }
    
    void ArgumentOutOfRangeException::constructor(String* paramName, Object* actualValue, String* message) {
        this->actual_value = actualValue;
        this->set_HResult(-2146233086);
    }
    
    void ArgumentOutOfRangeException::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        this->actual_value = info->GetString(_T("ActualValue"));
    }
    
    void ArgumentOutOfRangeException::constructor(String* message, Exception* innerException) {
        this->set_HResult(-2146233086);
    }
    
    void ArgumentOutOfRangeException::GetObjectData_bc9b88d7eb43b6d8(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        ArgumentException::GetObjectData_bc9b88d7eb43b6d8(info, context);
        info->AddValue16(_T("ActualValue"), this->actual_value);
    }
    
    Object* ArgumentOutOfRangeException::get_ActualValue_aa5ed9bfb68c696f() {
        return this->actual_value;
    }
    
    String* ArgumentOutOfRangeException::get_Message_d211df4045b57cbf() {
        String *basemsg = ArgumentException::get_Message_d211df4045b57cbf();
        if((this->actual_value ==  nullptr)) 
        {
            return basemsg;
        }
        return cli::concat(basemsg, Environment::get_NewLine());
    }
    
}
namespace System {
    
    
    void ArithmeticException::constructor() {
        this->set_HResult(-2147024362);
    }
    
    void ArithmeticException::constructor(String* message) {
        this->set_HResult(-2147024362);
    }
    
    void ArithmeticException::constructor(String* message, Exception* innerException) {
        this->set_HResult(-2147024362);
    }
    
    void ArithmeticException::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
    }
    
}
namespace System {
    
    
    void SimpleEnumerator::constructor(Array* arrayToEnumerate) {
        this->enumeratee = arrayToEnumerate;
        this->currentpos = -1;
        this->length = arrayToEnumerate->get_Length();
    }
    
    bool SimpleEnumerator::MoveNext() {
        if((this->currentpos < this->length)) 
        {
            this->currentpos++;
        }
        if((this->currentpos < this->length)) 
        {
            return true;
        }
         else 
        {
            return false;
        }
    }
    
    void SimpleEnumerator::Reset() {
        this->currentpos = -1;
    }
    
    Object* SimpleEnumerator::Clone() {
        return Object::MemberwiseClone();
    }
    
    Object* SimpleEnumerator::get_Current() {
        if((this->currentpos < 0)) 
        {
            throw cli::gcnew<InvalidOperationException>(Locale::GetText(_T("Enumeration has not started.")));
        }
        if((this->currentpos >= this->length)) 
        {
            throw cli::gcnew<InvalidOperationException>(Locale::GetText(_T("Enumeration has already ended")));
        }
        return this->enumeratee->GetValueImpl(this->currentpos);
    }
    
}
namespace System {
    
    
    void Array::constructor() {
    }
    
    int32_t Array::InternalArray__ICollection_get_Count() {
        return this->get_Length();
    }
    
    bool Array::InternalArray__ICollection_get_IsReadOnly() {
        return true;
    }
    
    void Array::InternalArray__ICollection_Clear() {
        throw cli::gcnew<NotSupportedException>(_T("Collection is read-only"));
    }
    
    void Array::InternalArray__RemoveAt(int32_t index) {
        throw cli::gcnew<NotSupportedException>(_T("Collection is of a fixed size"));
    }
    
    int32_t Array::Add(Object* value) {
        throw cli::gcnew<NotSupportedException>();
    }
    
    void Array::Clear() {
        Array::Clear2(this, this->GetLowerBound(0), this->get_Length());
    }
    
    bool Array::Contains(Object* value) {
        if((this->get_Rank() > 1)) 
        {
            throw cli::gcnew<RankException>(Locale::GetText(_T("Only single dimension arrays are supported.")));
        }
        int32_t length = this->get_Length();
        for(int32_t i = 0; (i < length); i++){
            if(Object::Equals2(this->GetValueImpl(i), value)) 
            {
                return true;
            }
        }
        return false;
    }
    
    int32_t Array::IndexOf(Object* value) {
        if((this->get_Rank() > 1)) 
        {
            throw cli::gcnew<RankException>(Locale::GetText(_T("Only single dimension arrays are supported.")));
        }
        int32_t length = this->get_Length();
        for(int32_t i = 0; (i < length); i++){
            if(Object::Equals2(this->GetValueImpl(i), value)) 
            {
                return (i + this->GetLowerBound(0));
            }
        }
        /*unchecked*/ {
            return (this->GetLowerBound(0) - 1);
        }
    }
    
    void Array::Insert(int32_t index, Object* value) {
        throw cli::gcnew<NotSupportedException>();
    }
    
    void Array::Remove(Object* value) {
        throw cli::gcnew<NotSupportedException>();
    }
    
    void Array::RemoveAt(int32_t index) {
        throw cli::gcnew<NotSupportedException>();
    }
    
    int32_t Array::GetRank() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t Array::GetLength(int32_t dimension) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int64_t Array::GetLongLength(int32_t dimension) {
        return (int64_t)(GetLength(dimension));
    }
    
    int32_t Array::GetLowerBound(int32_t dimension) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    Object* Array::GetValue(cli::array<int32_t>* indices) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Array::SetValue(Object* value, cli::array<int32_t>* indices) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    Object* Array::GetValueImpl(int32_t pos) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Array::SetValueImpl(Object* value, int32_t pos) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool Array::FastCopy(Array* source, int32_t source_idx, Array* dest, int32_t dest_idx, int32_t length) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    Array* Array::CreateInstanceImpl(Type* elementType, cli::array<int32_t>* lengths, cli::array<int32_t>* bounds) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    Collections::IEnumerator* Array::GetEnumerator() {
        return cli::gcnew<SimpleEnumerator>(this);
    }
    
    int32_t Array::CompareTo(Object* other, Collections::IComparer* comparer) {
        if((other ==  nullptr)) 
        {
            return 1;
        }
        Array *arr = cli::as<Array*>(other);
        if((arr ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentException>(_T("Not an array"), _T("other"));
        }
        int32_t len = GetLength(0);
        if((len != arr->GetLength(0))) 
        {
            throw cli::gcnew<ArgumentException>(_T("Not of the same length"), _T("other"));
        }
        if((this->get_Rank() > 1)) 
        {
            throw cli::gcnew<ArgumentException>(_T("Array must be single dimensional"));
        }
        if((arr->get_Rank() > 1)) 
        {
            throw cli::gcnew<ArgumentException>(_T("Array must be single dimensional"), _T("other"));
        }
        for(int32_t i = 0; (i < len); ++i){
            Object *a = GetValue2(i);
            Object *b = arr->GetValue2(i);
            int32_t r = comparer->Compare_451fd276747b629d(a, b);
            if((r != 0)) 
            {
                return r;
            }
        }
        return 0;
    }
    
    bool Array::Equals3(Object* other, Collections::IEqualityComparer* comparer) {
        Array *o = cli::as<Array*>(other);
        if(((o ==  nullptr) || (o->get_Length() != this->get_Length()))) 
        {
            return false;
        }
        if(Object::ReferenceEquals(other, this)) 
        {
            return true;
        }
        for(int32_t i = 0; (i < this->get_Length()); i++){
            Object *this_item = this->GetValue2(i);
            Object *other_item = o->GetValue2(i);
            if(!(comparer->Equals_ad190887ea91ded(this_item, other_item))) 
            {
                return false;
            }
        }
        return true;
    }
    
    int32_t Array::GetHashCode2(Collections::IEqualityComparer* comparer) {
        if((comparer ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("comparer"));
        }
        int32_t hash = 0;
        for(int32_t i = 0; (i < this->get_Length()); i++) {
            hash = (((hash << 7) + hash) ^ GetValue2(i)->GetHashCode_6648aef0f235ee6c());
        }
        return hash;
    }
    
    int32_t Array::GetUpperBound(int32_t dimension) {
        return ((GetLowerBound(dimension) + GetLength(dimension)) - 1);
    }
    
    Object* Array::GetValue2(int32_t index) {
        if((this->get_Rank() != 1)) 
        {
            throw cli::gcnew<ArgumentException>(Locale::GetText(_T("Array was not a one-dimensional array.")));
        }
        if(((index < GetLowerBound(0)) || (index > GetUpperBound(0)))) 
        {
            throw cli::gcnew<IndexOutOfRangeException>(Locale::GetText(_T("Index has to be between upper and lower bound of the array.")));
        }
        return GetValueImpl((index - GetLowerBound(0)));
    }
    
    Object* Array::GetValue3(int32_t index1, int32_t index2) {
        cli::array<int32_t> *ind = (new cli::array<int32_t>({index1, index2}));
        return GetValue(ind);
    }
    
    Object* Array::GetValue4(int32_t index1, int32_t index2, int32_t index3) {
        cli::array<int32_t> *ind = (new cli::array<int32_t>({index1, index2, index3}));
        return GetValue(ind);
    }
    
    Object* Array::GetValue5(int64_t index) {
        if(((index < 0L) || (index > 2147483647L))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("index"), Locale::GetText(_T("Value must be >= 0 and <= Int32.MaxValue.")));
        }
        return GetValue2((int32_t)index);
    }
    
    Object* Array::GetValue6(int64_t index1, int64_t index2) {
        if(((index1 < 0L) || (index1 > 2147483647L))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("index1"), Locale::GetText(_T("Value must be >= 0 and <= Int32.MaxValue.")));
        }
        if(((index2 < 0L) || (index2 > 2147483647L))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("index2"), Locale::GetText(_T("Value must be >= 0 and <= Int32.MaxValue.")));
        }
        return GetValue3((int32_t)index1, (int32_t)index2);
    }
    
    Object* Array::GetValue7(int64_t index1, int64_t index2, int64_t index3) {
        if(((index1 < 0L) || (index1 > 2147483647L))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("index1"), Locale::GetText(_T("Value must be >= 0 and <= Int32.MaxValue.")));
        }
        if(((index2 < 0L) || (index2 > 2147483647L))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("index2"), Locale::GetText(_T("Value must be >= 0 and <= Int32.MaxValue.")));
        }
        if(((index3 < 0L) || (index3 > 2147483647L))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("index3"), Locale::GetText(_T("Value must be >= 0 and <= Int32.MaxValue.")));
        }
        return GetValue4((int32_t)index1, (int32_t)index2, (int32_t)index3);
    }
    
    void Array::SetValue2(Object* value, int64_t index) {
        if(((index < 0L) || (index > 2147483647L))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("index"), Locale::GetText(_T("Value must be >= 0 and <= Int32.MaxValue.")));
        }
        SetValue5(value, (int32_t)index);
    }
    
    void Array::SetValue3(Object* value, int64_t index1, int64_t index2) {
        if(((index1 < 0L) || (index1 > 2147483647L))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("index1"), Locale::GetText(_T("Value must be >= 0 and <= Int32.MaxValue.")));
        }
        if(((index2 < 0L) || (index2 > 2147483647L))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("index2"), Locale::GetText(_T("Value must be >= 0 and <= Int32.MaxValue.")));
        }
        cli::array<int32_t> *ind = (new cli::array<int32_t>({(Int32)index1, (Int32)index2}));
        SetValue(value, ind);
    }
    
    void Array::SetValue4(Object* value, int64_t index1, int64_t index2, int64_t index3) {
        if(((index1 < 0L) || (index1 > 2147483647L))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("index1"), Locale::GetText(_T("Value must be >= 0 and <= Int32.MaxValue.")));
        }
        if(((index2 < 0L) || (index2 > 2147483647L))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("index2"), Locale::GetText(_T("Value must be >= 0 and <= Int32.MaxValue.")));
        }
        if(((index3 < 0L) || (index3 > 2147483647L))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("index3"), Locale::GetText(_T("Value must be >= 0 and <= Int32.MaxValue.")));
        }
        cli::array<int32_t> *ind = (new cli::array<int32_t>({(Int32)index1, (Int32)index2, (Int32)index3}));
        SetValue(value, ind);
    }
    
    void Array::SetValue5(Object* value, int32_t index) {
        if((this->get_Rank() != 1)) 
        {
            throw cli::gcnew<ArgumentException>(Locale::GetText(_T("Array was not a one-dimensional array.")));
        }
        if(((index < GetLowerBound(0)) || (index > GetUpperBound(0)))) 
        {
            throw cli::gcnew<IndexOutOfRangeException>(Locale::GetText(_T("Index has to be >= lower bound and <= upper bound of the array.")));
        }
        SetValueImpl(value, (index - GetLowerBound(0)));
    }
    
    void Array::SetValue6(Object* value, int32_t index1, int32_t index2) {
        cli::array<int32_t> *ind = (new cli::array<int32_t>({index1, index2}));
        SetValue(value, ind);
    }
    
    void Array::SetValue7(Object* value, int32_t index1, int32_t index2, int32_t index3) {
        cli::array<int32_t> *ind = (new cli::array<int32_t>({index1, index2, index3}));
        SetValue(value, ind);
    }
    
    Array* Array::CreateInstance(Type* elementType, int32_t length) {
        cli::array<int32_t> *lengths = (new cli::array<int32_t>({length}));
        return CreateInstance4(elementType, lengths);
    }
    
    Array* Array::CreateInstance2(Type* elementType, int32_t length1, int32_t length2) {
        cli::array<int32_t> *lengths = (new cli::array<int32_t>({length1, length2}));
        return CreateInstance4(elementType, lengths);
    }
    
    Array* Array::CreateInstance3(Type* elementType, int32_t length1, int32_t length2, int32_t length3) {
        cli::array<int32_t> *lengths = (new cli::array<int32_t>({length1, length2, length3}));
        return CreateInstance4(elementType, lengths);
    }
    
    Array* Array::CreateInstance4(Type* elementType, cli::array<int32_t>* lengths) {
        if(Type::op_Equality2(elementType, nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("elementType"));
        }
        if((lengths ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("lengths"));
        }
        if((lengths->get_Length() > 255)) 
        {
            throw cli::gcnew<TypeLoadException>();
        }
        cli::array<int32_t> *bounds = nullptr;
        elementType = elementType->get_UnderlyingSystemType_9ccb7bb8385521f6();
        if(!(elementType->get_IsSystemType())) 
        {
            throw cli::gcnew<ArgumentException>(_T("Type must be a type provided by the runtime."), _T("elementType"));
        }
        if(elementType->Equals_f28141a5881cf9e3(cli::typeof<Type>::info)) 
        {
            throw cli::gcnew<NotSupportedException>(_T("Array type can not be void"));
        }
        if(elementType->get_ContainsGenericParameters_19598881dd690ad3()) 
        {
            throw cli::gcnew<NotSupportedException>(_T("Array type can not be an open generic type"));
        }
        if((cli::is<Reflection::Emit::TypeBuilder>(elementType) && !(cli::as<Reflection::Emit::TypeBuilder*>(elementType)->IsCreated()))) 
        {
            throw cli::gcnew<NotSupportedException>(cli::concat(_T("Can\'t create an array of the unfinished type \'"), elementType));
        }
        return CreateInstanceImpl(elementType, lengths, bounds);
    }
    
    Array* Array::CreateInstance5(Type* elementType, cli::array<int32_t>* lengths, cli::array<int32_t>* lowerBounds) {
        if(Type::op_Equality2(elementType, nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("elementType"));
        }
        if((lengths ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("lengths"));
        }
        if((lowerBounds ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("lowerBounds"));
        }
        elementType = elementType->get_UnderlyingSystemType_9ccb7bb8385521f6();
        if(!(elementType->get_IsSystemType())) 
        {
            throw cli::gcnew<ArgumentException>(_T("Type must be a type provided by the runtime."), _T("elementType"));
        }
        if(elementType->Equals_f28141a5881cf9e3(cli::typeof<Type>::info)) 
        {
            throw cli::gcnew<NotSupportedException>(_T("Array type can not be void"));
        }
        if(elementType->get_ContainsGenericParameters_19598881dd690ad3()) 
        {
            throw cli::gcnew<NotSupportedException>(_T("Array type can not be an open generic type"));
        }
        if((lengths->get_Length() < 1)) 
        {
            throw cli::gcnew<ArgumentException>(Locale::GetText(_T("Arrays must contain >= 1 elements.")));
        }
        if((lengths->get_Length() != lowerBounds->get_Length())) 
        {
            throw cli::gcnew<ArgumentException>(Locale::GetText(_T("Arrays must be of same size.")));
        }
        for(int32_t j = 0; (j < lowerBounds->get_Length()); j++){
            if((lengths->at(j) < 0)) 
            {
                throw cli::gcnew<ArgumentOutOfRangeException>(_T("lengths"), Locale::GetText(_T("Each value has to be >= 0.")));
            }
            if((((int64_t)(lowerBounds->at(j)) + (int64_t)(lengths->at(j))) > 2147483647L)) 
            {
                throw cli::gcnew<ArgumentOutOfRangeException>(_T("lengths"), Locale::GetText(_T("Length + bound must not exceed Int32.MaxValue.")));
            }
        }
        if((lengths->get_Length() > 255)) 
        {
            throw cli::gcnew<TypeLoadException>();
        }
        return CreateInstanceImpl(elementType, lengths, lowerBounds);
    }
    
    cli::array<int32_t>* Array::GetIntArray(cli::array<int64_t>* values) {
        int32_t len = values->get_Length();
        cli::array<int32_t> *ints = (new cli::array<int32_t>(len));
        for(int32_t i = 0; (i < len); i++){
            int64_t current = values->at(i);
            if(((current < 0L) || (current > 2147483647L))) 
            {
                throw cli::gcnew<ArgumentOutOfRangeException>(_T("values"), Locale::GetText(_T("Each value has to be >= 0 and <= Int32.MaxValue.")));
            }
            ints->at(i) = (int32_t)current;
        }
        return ints;
    }
    
    Array* Array::CreateInstance6(Type* elementType, cli::array<int64_t>* lengths) {
        if((lengths ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("lengths"));
        }
        return CreateInstance4(elementType, GetIntArray(lengths));
    }
    
    Object* Array::GetValue8(cli::array<int64_t>* indices) {
        if((indices ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("indices"));
        }
        return GetValue(GetIntArray(indices));
    }
    
    void Array::SetValue8(Object* value, cli::array<int64_t>* indices) {
        if((indices ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("indices"));
        }
        SetValue(value, GetIntArray(indices));
    }
    
    int32_t Array::BinarySearch(Array* array, Object* value) {
        if((array ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("array"));
        }
        if((value ==  nullptr)) 
        {
            return -1;
        }
        if((array->get_Rank() > 1)) 
        {
            throw cli::gcnew<RankException>(Locale::GetText(_T("Only single dimension arrays are supported.")));
        }
        if((array->get_Length() ==  0)) 
        {
            return -1;
        }
        if(!(cli::is<IComparable>(value))) 
        {
            throw cli::gcnew<ArgumentException>(Locale::GetText(_T("value does not support IComparable.")));
        }
        return DoBinarySearch(array, array->GetLowerBound(0), array->GetLength(0), value, nullptr);
    }
    
    int32_t Array::BinarySearch2(Array* array, Object* value, Collections::IComparer* comparer) {
        if((array ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("array"));
        }
        if((array->get_Rank() > 1)) 
        {
            throw cli::gcnew<RankException>(Locale::GetText(_T("Only single dimension arrays are supported.")));
        }
        if((array->get_Length() ==  0)) 
        {
            return -1;
        }
        if((((comparer ==  nullptr) && (value != nullptr)) && !(cli::is<IComparable>(value)))) 
        {
            throw cli::gcnew<ArgumentException>(Locale::GetText(_T("comparer is null and value does not support IComparable.")));
        }
        return DoBinarySearch(array, array->GetLowerBound(0), array->GetLength(0), value, comparer);
    }
    
    int32_t Array::BinarySearch3(Array* array, int32_t index, int32_t length, Object* value) {
        if((array ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("array"));
        }
        if((array->get_Rank() > 1)) 
        {
            throw cli::gcnew<RankException>(Locale::GetText(_T("Only single dimension arrays are supported.")));
        }
        if((index < array->GetLowerBound(0))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("index"), Locale::GetText(_T("index is less than the lower bound of array.")));
        }
        if((length < 0)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("length"), Locale::GetText(_T("Value has to be >= 0.")));
        }
        if((index > ((array->GetLowerBound(0) + array->GetLength(0)) - length))) 
        {
            throw cli::gcnew<ArgumentException>(Locale::GetText(_T("index and length do not specify a valid range in array.")));
        }
        if((array->get_Length() ==  0)) 
        {
            return -1;
        }
        if(((value != nullptr) && !(cli::is<IComparable>(value)))) 
        {
            throw cli::gcnew<ArgumentException>(Locale::GetText(_T("value does not support IComparable")));
        }
        return DoBinarySearch(array, index, length, value, nullptr);
    }
    
    int32_t Array::BinarySearch4(Array* array, int32_t index, int32_t length, Object* value, Collections::IComparer* comparer) {
        if((array ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("array"));
        }
        if((array->get_Rank() > 1)) 
        {
            throw cli::gcnew<RankException>(Locale::GetText(_T("Only single dimension arrays are supported.")));
        }
        if((index < array->GetLowerBound(0))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("index"), Locale::GetText(_T("index is less than the lower bound of array.")));
        }
        if((length < 0)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("length"), Locale::GetText(_T("Value has to be >= 0.")));
        }
        if((index > ((array->GetLowerBound(0) + array->GetLength(0)) - length))) 
        {
            throw cli::gcnew<ArgumentException>(Locale::GetText(_T("index and length do not specify a valid range in array.")));
        }
        if((array->get_Length() ==  0)) 
        {
            return -1;
        }
        if((((comparer ==  nullptr) && (value != nullptr)) && !(cli::is<IComparable>(value)))) 
        {
            throw cli::gcnew<ArgumentException>(Locale::GetText(_T("comparer is null and value does not support IComparable.")));
        }
        return DoBinarySearch(array, index, length, value, comparer);
    }
    
    int32_t Array::DoBinarySearch(Array* array, int32_t index, int32_t length, Object* value, Collections::IComparer* comparer) {
        if((comparer ==  nullptr)) 
        {
            comparer = Collections::Comparer::Default2;
        }
        int32_t iMin = index;
        int32_t iMax = ((index + length) - 1);
        int32_t iCmp = 0;
        try {
            while((iMin <= iMax)) {
                int32_t iMid = (iMin + ((iMax - iMin) / 2));
                Object *elt = array->GetValueImpl(iMid);
                iCmp = comparer->Compare_451fd276747b629d(elt, value);
                if((iCmp ==  0)) 
                {
                    return iMid;
                }
                 else 
                {
                    if((iCmp > 0)) 
                    {
                        iMax = (iMid - 1);
                    }
                     else 
                    {
                        iMin = (iMid + 1);
                    }
                }
            }
        }
        catch(Exception* e) {
            throw cli::gcnew<InvalidOperationException>(Locale::GetText(_T("Comparer threw an exception.")), e);
        }
        return ~(iMin);
    }
    
    void Array::Clear2(Array* array, int32_t index, int32_t length) {
        if((array ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("array"));
        }
        if((length < 0)) 
        {
            throw cli::gcnew<IndexOutOfRangeException>(_T("length < 0"));
        }
        int32_t low = array->GetLowerBound(0);
        if((index < low)) 
        {
            throw cli::gcnew<IndexOutOfRangeException>(_T("index < lower bound"));
        }
        index = (index - low);
        if((index > (array->get_Length() - length))) 
        {
            throw cli::gcnew<IndexOutOfRangeException>(_T("index + length > size"));
        }
        ClearInternal(array, index, length);
    }
    
    void Array::ClearInternal(Array* a, int32_t index, int32_t count) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    Object* Array::Clone() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Array::Copy(Array* sourceArray, Array* destinationArray, int32_t length) {
        if((sourceArray ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("sourceArray"));
        }
        if((destinationArray ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("destinationArray"));
        }
        Copy2(sourceArray, sourceArray->GetLowerBound(0), destinationArray, destinationArray->GetLowerBound(0), length);
    }
    
    void Array::Copy2(Array* sourceArray, int32_t sourceIndex, Array* destinationArray, int32_t destinationIndex, int32_t length) {
        if((sourceArray ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("sourceArray"));
        }
        if((destinationArray ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("destinationArray"));
        }
        if((length < 0)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("length"), Locale::GetText(_T("Value has to be >= 0.")));
        };
        if((sourceIndex < 0)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("sourceIndex"), Locale::GetText(_T("Value has to be >= 0.")));
        };
        if((destinationIndex < 0)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("destinationIndex"), Locale::GetText(_T("Value has to be >= 0.")));
        };
        if(FastCopy(sourceArray, sourceIndex, destinationArray, destinationIndex, length)) 
        {
            return;
        }
        int32_t source_pos = (sourceIndex - sourceArray->GetLowerBound(0));
        int32_t dest_pos = (destinationIndex - destinationArray->GetLowerBound(0));
        if((source_pos > (sourceArray->get_Length() - length))) 
        {
            throw cli::gcnew<ArgumentException>(_T("length"));
        }
        if((dest_pos > (destinationArray->get_Length() - length))) 
        {
            String *msg = _T("Destination array was not long enough. Check destIndex and length, and the array\'s lower bounds");
            throw cli::gcnew<ArgumentException>(msg, String::Empty);
        }
        if((sourceArray->get_Rank() != destinationArray->get_Rank())) 
        {
            throw cli::gcnew<RankException>(Locale::GetText(_T("Arrays must be of same size.")));
        }
        Type *src_type = sourceArray->GetType()->GetElementType_ab5070dbbfe66f5f();
        Type *dst_type = destinationArray->GetType()->GetElementType_ab5070dbbfe66f5f();
        if((!(Object::ReferenceEquals(sourceArray, destinationArray)) || (source_pos > dest_pos))) 
        {
            for(int32_t i = 0; (i < length); i++){
                Object *srcval = sourceArray->GetValueImpl((source_pos + i));
                try {
                    destinationArray->SetValueImpl(srcval, (dest_pos + i));
                }
                catch(...) {
                    if(src_type->Equals_f28141a5881cf9e3(cli::typeof<Type>::info)) 
                    {
                        throw cli::gcnew<InvalidCastException>();
                    }
                     else 
                    {
                        throw cli::gcnew<ArrayTypeMismatchException>(String::Format3(Locale::GetText(_T("(Types: source={0};  target={1})")), src_type->get_FullName_7e8fa72ba225e1a4(), dst_type->get_FullName_7e8fa72ba225e1a4()));
                    }
                }
            }
        }
         else 
        {
            for(int32_t i = (length - 1); (i >= 0); i--){
                Object *srcval = sourceArray->GetValueImpl((source_pos + i));
                try {
                    destinationArray->SetValueImpl(srcval, (dest_pos + i));
                }
                catch(...) {
                    if(src_type->Equals_f28141a5881cf9e3(cli::typeof<Type>::info)) 
                    {
                        throw cli::gcnew<InvalidCastException>();
                    }
                     else 
                    {
                        throw cli::gcnew<ArrayTypeMismatchException>(String::Format3(Locale::GetText(_T("(Types: source={0};  target={1})")), src_type->get_FullName_7e8fa72ba225e1a4(), dst_type->get_FullName_7e8fa72ba225e1a4()));
                    }
                }
            }
        }
    }
    
    void Array::Copy3(Array* sourceArray, int64_t sourceIndex, Array* destinationArray, int64_t destinationIndex, int64_t length) {
        if((sourceArray ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("sourceArray"));
        }
        if((destinationArray ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("destinationArray"));
        }
        if(((sourceIndex < -2147483648L) || (sourceIndex > 2147483647L))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("sourceIndex"), Locale::GetText(_T("Must be in the Int32 range.")));
        }
        if(((destinationIndex < -2147483648L) || (destinationIndex > 2147483647L))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("destinationIndex"), Locale::GetText(_T("Must be in the Int32 range.")));
        }
        if(((length < 0L) || (length > 2147483647L))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("length"), Locale::GetText(_T("Value must be >= 0 and <= Int32.MaxValue.")));
        }
        Copy2(sourceArray, (int32_t)sourceIndex, destinationArray, (int32_t)destinationIndex, (int32_t)length);
    }
    
    void Array::Copy4(Array* sourceArray, Array* destinationArray, int64_t length) {
        if(((length < 0L) || (length > 2147483647L))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("length"), Locale::GetText(_T("Value must be >= 0 and <= Int32.MaxValue.")));
        }
        Copy(sourceArray, destinationArray, (int32_t)length);
    }
    
    int32_t Array::IndexOf2(Array* array, Object* value) {
        if((array ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("array"));
        }
        return IndexOf4(array, value, 0, array->get_Length());
    }
    
    int32_t Array::IndexOf3(Array* array, Object* value, int32_t startIndex) {
        if((array ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("array"));
        }
        return IndexOf4(array, value, startIndex, (array->get_Length() - startIndex));
    }
    
    int32_t Array::IndexOf4(Array* array, Object* value, int32_t startIndex, int32_t count) {
        if((array ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("array"));
        }
        if((array->get_Rank() > 1)) 
        {
            throw cli::gcnew<RankException>(Locale::GetText(_T("Only single dimension arrays are supported.")));
        }
        if((((count < 0) || (startIndex < array->GetLowerBound(0))) || ((startIndex - 1) > (array->GetUpperBound(0) - count)))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>();
        }
        int32_t max = (startIndex + count);
        for(int32_t i = startIndex; (i < max); i++){
            if(Object::Equals2(array->GetValueImpl(i), value)) 
            {
                return i;
            }
        }
        return (array->GetLowerBound(0) - 1);
    }
    
    void Array::Initialize() {
    }
    
    int32_t Array::LastIndexOf(Array* array, Object* value) {
        if((array ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("array"));
        }
        if((array->get_Length() ==  0)) 
        {
            return (array->GetLowerBound(0) - 1);
        }
        return LastIndexOf2(array, value, (array->get_Length() - 1));
    }
    
    int32_t Array::LastIndexOf2(Array* array, Object* value, int32_t startIndex) {
        if((array ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("array"));
        }
        return LastIndexOf3(array, value, startIndex, ((startIndex - array->GetLowerBound(0)) + 1));
    }
    
    int32_t Array::LastIndexOf3(Array* array, Object* value, int32_t startIndex, int32_t count) {
        if((array ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("array"));
        }
        if((array->get_Rank() > 1)) 
        {
            throw cli::gcnew<RankException>(Locale::GetText(_T("Only single dimension arrays are supported.")));
        }
        int32_t lb = array->GetLowerBound(0);
        if((array->get_Length() ==  0)) 
        {
            return (lb - 1);
        }
        if(((((count < 0) || (startIndex < lb)) || (startIndex > array->GetUpperBound(0))) || (((startIndex - count) + 1) < lb))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>();
        }
        for(int32_t i = startIndex; (i >= ((startIndex - count) + 1)); i--){
            if(Object::Equals2(array->GetValueImpl(i), value)) 
            {
                return i;
            }
        }
        return (lb - 1);
    }
    
    Swapper* Array::get_swapper(Array* array) {
        if(cli::is<cli::array<int32_t>>(array)) 
        {
            return cli::bind(array, &Array::int_swapper);
        }
        if(cli::is<cli::array<double>>(array)) 
        {
            return cli::bind(array, &Array::double_swapper);
        }
        if(cli::is<cli::array<Object*>>(array)) 
        {
            return cli::bind(array, &Array::obj_swapper);
        }
        return cli::bind(array, &Array::slow_swapper);
    }
    
    void Array::Reverse(Array* array) {
        if((array ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("array"));
        }
        Reverse2(array, array->GetLowerBound(0), array->GetLength(0));
    }
    
    void Array::Reverse2(Array* array, int32_t index, int32_t length) {
        if((array ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("array"));
        }
        if((array->get_Rank() > 1)) 
        {
            throw cli::gcnew<RankException>(Locale::GetText(_T("Only single dimension arrays are supported.")));
        }
        if(((index < array->GetLowerBound(0)) || (length < 0))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>();
        }
        if((index > ((array->GetUpperBound(0) + 1) - length))) 
        {
            throw cli::gcnew<ArgumentException>();
        }
        int32_t end = ((index + length) - 1);
        cli::array<Object*> *oarray = cli::as<cli::array<Object*>*>(array);
        if((oarray != nullptr)) 
        {
            while((index < end)) {
                Object *tmp = oarray->at(index);
                oarray->at(index) = oarray->at(end);
                oarray->at(end) = tmp;
                ++index;
                --end;
            }
            return;
        }
        cli::array<int32_t> *iarray = cli::as<cli::array<int32_t>*>(array);
        if((iarray != nullptr)) 
        {
            while((index < end)) {
                int32_t tmp = iarray->at(index);
                iarray->at(index) = iarray->at(end);
                iarray->at(end) = tmp;
                ++index;
                --end;
            }
            return;
        }
        cli::array<double> *darray = cli::as<cli::array<double>*>(array);
        if((darray != nullptr)) 
        {
            while((index < end)) {
                double tmp = darray->at(index);
                darray->at(index) = darray->at(end);
                darray->at(end) = tmp;
                ++index;
                --end;
            }
            return;
        }
        Swapper *swapper = get_swapper(array);
        while((index < end)) {
            swapper->Invoke(index, end);
            ++index;
            --end;
        }
    }
    
    void Array::Sort(Array* array) {
        Sort3(array, nullptr);
    }
    
    void Array::Sort2(Array* keys, Array* items) {
        Sort5(keys, items, nullptr);
    }
    
    void Array::Sort3(Array* array, Collections::IComparer* comparer) {
        if((array ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("array"));
        }
        if((array->get_Rank() > 1)) 
        {
            throw cli::gcnew<RankException>(Locale::GetText(_T("Only single dimension arrays are supported.")));
        }
        SortImpl(array, nullptr, array->GetLowerBound(0), array->GetLength(0), comparer);
    }
    
    void Array::Sort4(Array* array, int32_t index, int32_t length) {
        Sort7(array, index, length, nullptr);
    }
    
    void Array::Sort5(Array* keys, Array* items, Collections::IComparer* comparer) {
        if((items ==  nullptr)) 
        {
            Sort3(keys, comparer);
            return;
        }
        if((keys ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("keys"));
        }
        if(((keys->get_Rank() > 1) || (items->get_Rank() > 1))) 
        {
            throw cli::gcnew<RankException>(Locale::GetText(_T("Only single dimension arrays are supported.")));
        }
        SortImpl(keys, items, keys->GetLowerBound(0), keys->GetLength(0), comparer);
    }
    
    void Array::Sort6(Array* keys, Array* items, int32_t index, int32_t length) {
        Sort8(keys, items, index, length, nullptr);
    }
    
    void Array::Sort7(Array* array, int32_t index, int32_t length, Collections::IComparer* comparer) {
        if((array ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("array"));
        }
        if((array->get_Rank() > 1)) 
        {
            throw cli::gcnew<RankException>(Locale::GetText(_T("Only single dimension arrays are supported.")));
        }
        if((index < array->GetLowerBound(0))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("index"));
        }
        if((length < 0)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("length"), Locale::GetText(_T("Value has to be >= 0.")));
        }
        if(((array->get_Length() - (array->GetLowerBound(0) + index)) < length)) 
        {
            throw cli::gcnew<ArgumentException>();
        }
        SortImpl(array, nullptr, index, length, comparer);
    }
    
    void Array::Sort8(Array* keys, Array* items, int32_t index, int32_t length, Collections::IComparer* comparer) {
        if((items ==  nullptr)) 
        {
            Sort7(keys, index, length, comparer);
            return;
        }
        if((keys ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("keys"));
        }
        if(((keys->get_Rank() > 1) || (items->get_Rank() > 1))) 
        {
            throw cli::gcnew<RankException>();
        }
        if((keys->GetLowerBound(0) != items->GetLowerBound(0))) 
        {
            throw cli::gcnew<ArgumentException>();
        }
        if((index < keys->GetLowerBound(0))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("index"));
        }
        if((length < 0)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("length"), Locale::GetText(_T("Value has to be >= 0.")));
        }
        if((((items->get_Length() - (index + items->GetLowerBound(0))) < length) || ((keys->get_Length() - (index + keys->GetLowerBound(0))) < length))) 
        {
            throw cli::gcnew<ArgumentException>();
        }
        SortImpl(keys, items, index, length, comparer);
    }
    
    void Array::SortImpl(Array* keys, Array* items, int32_t index, int32_t length, Collections::IComparer* comparer) {
        if((length <= 1)) 
        {
            return;
        }
        int32_t low = index;
        int32_t high = ((index + length) - 1);
        if(((comparer ==  nullptr) && cli::is<cli::array<Object*>>(items))) 
        {
            switch(Type::GetTypeCode(keys->GetType()->GetElementType_ab5070dbbfe66f5f())) {
                case TypeCode::Int322: case_556: {
                    qsort_2<int32_t, Object*>(cli::as<cli::array<int32_t>*>(keys), cli::as<cli::array<Object*>*>(items), low, high);
                    return;
                }
                case TypeCode::Int642: case_557: {
                    qsort_2<int64_t, Object*>(cli::as<cli::array<int64_t>*>(keys), cli::as<cli::array<Object*>*>(items), low, high);
                    return;
                }
                case TypeCode::Byte2: case_558: {
                    qsort_2<unsigned char, Object*>(cli::as<cli::array<unsigned char>*>(keys), cli::as<cli::array<Object*>*>(items), low, high);
                    return;
                }
                case TypeCode::Char2: case_559: {
                    qsort_2<char16_t, Object*>(cli::as<cli::array<char16_t>*>(keys), cli::as<cli::array<Object*>*>(items), low, high);
                    return;
                }
                case TypeCode::DateTime2: case_560: {
                    qsort_2<DateTime, Object*>(cli::as<cli::array<DateTime>*>(keys), cli::as<cli::array<Object*>*>(items), low, high);
                    return;
                }
                case TypeCode::Decimal2: case_561: {
                    qsort_2<Decimal, Object*>(cli::as<cli::array<Decimal>*>(keys), cli::as<cli::array<Object*>*>(items), low, high);
                    return;
                }
                case TypeCode::Double2: case_562: {
                    qsort_2<double, Object*>(cli::as<cli::array<double>*>(keys), cli::as<cli::array<Object*>*>(items), low, high);
                    return;
                }
                case TypeCode::Int162: case_563: {
                    qsort_2<int16_t, Object*>(cli::as<cli::array<int16_t>*>(keys), cli::as<cli::array<Object*>*>(items), low, high);
                    return;
                }
                case TypeCode::SByte2: case_564: {
                    qsort_2<signed char, Object*>(cli::as<cli::array<signed char>*>(keys), cli::as<cli::array<Object*>*>(items), low, high);
                    return;
                }
                case TypeCode::Single2: case_565: {
                    qsort_2<float, Object*>(cli::as<cli::array<float>*>(keys), cli::as<cli::array<Object*>*>(items), low, high);
                    return;
                }
                case TypeCode::UInt162: case_566: {
                    qsort_2<uint16_t, Object*>(cli::as<cli::array<uint16_t>*>(keys), cli::as<cli::array<Object*>*>(items), low, high);
                    return;
                }
                case TypeCode::UInt322: case_567: {
                    qsort_2<uint32_t, Object*>(cli::as<cli::array<uint32_t>*>(keys), cli::as<cli::array<Object*>*>(items), low, high);
                    return;
                }
                case TypeCode::UInt642: case_568: {
                    qsort_2<uint64_t, Object*>(cli::as<cli::array<uint64_t>*>(keys), cli::as<cli::array<Object*>*>(items), low, high);
                    return;
                }
                default: case_569: {
                    break;
                }
            }
        }
        if((comparer ==  nullptr)) 
        {
            CheckComparerAvailable(keys, low, high);
        }
        try {
            qsort(keys, items, low, high, comparer);
        }
        catch(Exception* e) {
            throw cli::gcnew<InvalidOperationException>(Locale::GetText(_T("The comparer threw an exception.")), e);
        }
    }
    
    void Array::int_swapper(int32_t i, int32_t j) {
        cli::array<int32_t> *array = cli::as<cli::array<int32_t>*>(this);
        int32_t val = array->at(i);
        array->at(i) = array->at(j);
        array->at(j) = val;
    }
    
    void Array::obj_swapper(int32_t i, int32_t j) {
        cli::array<Object*> *array = cli::as<cli::array<Object*>*>(this);
        Object *val = array->at(i);
        array->at(i) = array->at(j);
        array->at(j) = val;
    }
    
    void Array::slow_swapper(int32_t i, int32_t j) {
        Object *val = GetValueImpl(i);
        SetValueImpl(GetValue2(j), i);
        SetValueImpl(val, j);
    }
    
    void Array::double_swapper(int32_t i, int32_t j) {
        cli::array<double> *array = cli::as<cli::array<double>*>(this);
        double val = array->at(i);
        array->at(i) = array->at(j);
        array->at(j) = val;
    }
    
    bool Array::QSortArrange(Array* keys, Array* items, int32_t lo, Object* v0, int32_t hi, Object* v1, Collections::IComparer* comparer) {
        IComparable *cmp;
        Object *tmp;
        if((comparer != nullptr)) 
        {
            if((comparer->Compare_451fd276747b629d(v1, v0) < 0)) 
            {
                swap(keys, items, lo, hi);
                tmp = v0;
                v0 = v1;
                v1 = tmp;
                return true;
            }
        }
         else 
        {
            if((v0 != nullptr)) 
            {
                cmp = cli::as<IComparable*>(v1);
                if(((v1 ==  nullptr) || (cmp->CompareTo_ed9d39205b7812f0(v0) < 0))) 
                {
                    swap(keys, items, lo, hi);
                    tmp = v0;
                    v0 = v1;
                    v1 = tmp;
                    return true;
                }
            }
        }
        return false;
    }
    
    void Array::qsort(Array* keys, Array* items, int32_t low, int32_t high, Collections::IComparer* comparer) {
        Object *key, *hi, *lo;
        IComparable *cmp;
        int32_t mid, i, k;
        mid = (low + ((high - low) / 2));
        key = keys->GetValueImpl(mid);
        hi = keys->GetValueImpl(high);
        lo = keys->GetValueImpl(low);
        QSortArrange(keys, items, low, lo, mid, key, comparer);
        if(QSortArrange(keys, items, mid, key, high, hi, comparer)) 
        {
            QSortArrange(keys, items, low, lo, mid, key, comparer);
        }
        cmp = cli::as<IComparable*>(key);
        k = (high - 1);
        i = (low + 1);
        do {
            if((comparer != nullptr)) 
            {
                while(((i < k) && (comparer->Compare_451fd276747b629d(key, keys->GetValueImpl(i)) >= 0))) i++;
                while(((k >= i) && (comparer->Compare_451fd276747b629d(key, keys->GetValueImpl(k)) < 0))) k--;
            }
             else 
            {
                if((cmp != nullptr)) 
                {
                    while(((i < k) && (cmp->CompareTo_ed9d39205b7812f0(keys->GetValueImpl(i)) >= 0))) i++;
                    while(((k >= i) && (cmp->CompareTo_ed9d39205b7812f0(keys->GetValueImpl(k)) < 0))) k--;
                }
                 else 
                {
                    while(((i < k) && (keys->GetValueImpl(i) ==  nullptr))) i++;
                    while(((k >= i) && (keys->GetValueImpl(k) != nullptr))) k--;
                }
            }
            if((k <= i)) 
            {
                break;
            }
            swap(keys, items, i, k);
            if((mid ==  i)) 
            {
                mid = k;
            }
             else 
            {
                if((mid ==  k)) 
                {
                    mid = i;
                }
            }
            i++;
            k--;
        }
        while(true);
        if((k != mid)) 
        {
            swap(keys, items, mid, k);
        }
        if(((k + 1) < high)) 
        {
            qsort(keys, items, (k + 1), high, comparer);
        }
        if(((k - 1) > low)) 
        {
            qsort(keys, items, low, (k - 1), comparer);
        }
    }
    
    void Array::CheckComparerAvailable(Array* keys, int32_t low, int32_t high) {
        for(int32_t i = 0; (i < high); i++){
            Object *obj = keys->GetValueImpl(i);
            if((obj ==  nullptr)) 
            {
                continue;
            }
            if(!(cli::is<IComparable>(obj))) 
            {
                String *msg = Locale::GetText(_T("No IComparable interface found for type \'{0}\'."));
                throw cli::gcnew<InvalidOperationException>(String::Format2(msg, obj->GetType()));
            }
        }
    }
    
    void Array::swap(Array* keys, Array* items, int32_t i, int32_t j) {
        Object *tmp = keys->GetValueImpl(i);
        keys->SetValueImpl(keys->GetValueImpl(j), i);
        keys->SetValueImpl(tmp, j);
        if((items != nullptr)) 
        {
            tmp = items->GetValueImpl(i);
            items->SetValueImpl(items->GetValueImpl(j), i);
            items->SetValueImpl(tmp, j);
        }
    }
    
    void Array::CopyTo(Array* array, int32_t index) {
        if((array ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("array"));
        }
        if((this->get_Rank() > 1)) 
        {
            throw cli::gcnew<RankException>(Locale::GetText(_T("Only single dimension arrays are supported.")));
        }
        if(((index + this->GetLength(0)) > (array->GetLowerBound(0) + array->GetLength(0)))) 
        {
            throw cli::gcnew<ArgumentException>(_T("Destination array was not long enough. Check destIndex and length, and the array\'s lower bounds."));
        }
        if((array->get_Rank() > 1)) 
        {
            throw cli::gcnew<RankException>(Locale::GetText(_T("Only single dimension arrays are supported.")));
        }
        if((index < 0)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("index"), Locale::GetText(_T("Value has to be >= 0.")));
        }
        Copy2(this, this->GetLowerBound(0), array, index, this->GetLength(0));
    }
    
    void Array::CopyTo2(Array* array, int64_t index) {
        if(((index < 0L) || (index > 2147483647L))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("index"), Locale::GetText(_T("Value must be >= 0 and <= Int32.MaxValue.")));
        }
        CopyTo(array, (int32_t)index);
    }
    
    void Array::ConstrainedCopy(Array* sourceArray, int32_t sourceIndex, Array* destinationArray, int32_t destinationIndex, int32_t length) {
        Copy2(sourceArray, sourceIndex, destinationArray, destinationIndex, length);
    }
    
    int32_t Array::get_Length() {
        int32_t length = this->GetLength(0);
        for(int32_t i = 1; (i < this->get_Rank()); i++){
            (length = length * this->GetLength(i));
        }
        return length;
    }
    
    int64_t Array::get_LongLength() {
        return (int64_t)(this->get_Length());
    }
    
    int32_t Array::get_Rank() {
        return this->GetRank();
    }
    
    Object* Array::get_Item(int32_t index) {
        if((cli::unchecked((uint32_t)index) >= cli::unchecked((uint32_t)this->get_Length()))) 
        {
            throw cli::gcnew<IndexOutOfRangeException>(_T("index"));
        }
        if((this->get_Rank() > 1)) 
        {
            throw cli::gcnew<ArgumentException>(Locale::GetText(_T("Only single dimension arrays are supported.")));
        }
        return GetValueImpl(index);
    }
    
    Object* Array::set_Item(int32_t index, Object* value) {
        if((cli::unchecked((uint32_t)index) >= cli::unchecked((uint32_t)this->get_Length()))) 
        {
            throw cli::gcnew<IndexOutOfRangeException>(_T("index"));
        }
        if((this->get_Rank() > 1)) 
        {
            throw cli::gcnew<ArgumentException>(Locale::GetText(_T("Only single dimension arrays are supported.")));
        }
        SetValueImpl(value, index);
        return get_Item(index);
    }
    
    int32_t Array::get_Count() {
        return this->get_Length();
    }
    
    bool Array::get_IsSynchronized() {
        return false;
    }
    
    Object* Array::get_SyncRoot() {
        return this;
    }
    
    bool Array::get_IsFixedSize() {
        return true;
    }
    
    bool Array::get_IsReadOnly() {
        return false;
    }
    
}
namespace System {
    
    
    void ArrayTypeMismatchException::constructor() {
        this->set_HResult(-2146233085);
    }
    
    void ArrayTypeMismatchException::constructor(String* message) {
        this->set_HResult(-2146233085);
    }
    
    void ArrayTypeMismatchException::constructor(String* message, Exception* innerException) {
        this->set_HResult(-2146233085);
    }
    
    void ArrayTypeMismatchException::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
    }
    
}
namespace System {
    
    
    void AssemblyLoadEventArgs::constructor(Reflection::Assembly* loadedAssembly) {
        this->m_loadedAssembly = loadedAssembly;
    }
    
    Reflection::Assembly* AssemblyLoadEventArgs::get_LoadedAssembly() {
        return this->m_loadedAssembly;
    }
    
}
namespace System {
    
    
    void Attribute::constructor() {
    }
    
    void Attribute::CheckParameters(Object* element, Type* attributeType) {
        if((element ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("element"));
        }
        if(Type::op_Equality2(attributeType, nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("attributeType"));
        }
        if(!(cli::typeof<Type>::info->IsAssignableFrom_e3aa32d778e63a90(attributeType))) 
        {
            throw cli::gcnew<ArgumentException>(Locale::GetText(_T("Type is not derived from System.Attribute.")), _T("attributeType"));
        }
    }
    
    Attribute* Attribute::FindAttribute(cli::array<Object*>* attributes) {
        if((attributes->get_Length() > 1)) 
        {
            throw cli::gcnew<Reflection::AmbiguousMatchException>(Locale::GetText(_T("<element> has more than one attribute of type <attribute_type>")));
        }
        if((attributes->get_Length() < 1)) 
        {
            return nullptr;
        }
        return cli::cast<Attribute*>(attributes->at(0));
    }
    
    Attribute* Attribute::GetCustomAttribute(Reflection::ParameterInfo* element, Type* attributeType) {
        return GetCustomAttribute7(element, attributeType, true);
    }
    
    Attribute* Attribute::GetCustomAttribute2(Reflection::MemberInfo* element, Type* attributeType) {
        return GetCustomAttribute8(element, attributeType, true);
    }
    
    Attribute* Attribute::GetCustomAttribute3(Reflection::Assembly* element, Type* attributeType) {
        return GetCustomAttribute6(element, attributeType, true);
    }
    
    Attribute* Attribute::GetCustomAttribute4(Reflection::Module* element, Type* attributeType) {
        return GetCustomAttribute5(element, attributeType, true);
    }
    
    Attribute* Attribute::GetCustomAttribute5(Reflection::Module* element, Type* attributeType, bool inherit) {
        CheckParameters(element, attributeType);
        cli::array<Object*> *attributes = element->GetCustomAttributes_2d26f4bf11dda1f5(attributeType, inherit);
        return FindAttribute(attributes);
    }
    
    Attribute* Attribute::GetCustomAttribute6(Reflection::Assembly* element, Type* attributeType, bool inherit) {
        CheckParameters(element, attributeType);
        cli::array<Object*> *attributes = element->GetCustomAttributes_30a143c7dfd48919(attributeType, inherit);
        return FindAttribute(attributes);
    }
    
    Attribute* Attribute::GetCustomAttribute7(Reflection::ParameterInfo* element, Type* attributeType, bool inherit) {
        CheckParameters(element, attributeType);
        cli::array<Object*> *attributes = GetCustomAttributes10(element, attributeType, inherit)->template CovariantCast<Object*>();
        return FindAttribute(attributes);
    }
    
    Attribute* Attribute::GetCustomAttribute8(Reflection::MemberInfo* element, Type* attributeType, bool inherit) {
        CheckParameters(element, attributeType);
        return MonoCustomAttrs::GetCustomAttribute(element, attributeType, inherit);
    }
    
    cli::array<Attribute*>* Attribute::GetCustomAttributes(Reflection::Assembly* element) {
        return GetCustomAttributes14(element, true);
    }
    
    cli::array<Attribute*>* Attribute::GetCustomAttributes2(Reflection::ParameterInfo* element) {
        return GetCustomAttributes16(element, true);
    }
    
    cli::array<Attribute*>* Attribute::GetCustomAttributes3(Reflection::MemberInfo* element) {
        return GetCustomAttributes15(element, true);
    }
    
    cli::array<Attribute*>* Attribute::GetCustomAttributes4(Reflection::Module* element) {
        return GetCustomAttributes13(element, true);
    }
    
    cli::array<Attribute*>* Attribute::GetCustomAttributes5(Reflection::Assembly* element, Type* attributeType) {
        return GetCustomAttributes9(element, attributeType, true);
    }
    
    cli::array<Attribute*>* Attribute::GetCustomAttributes6(Reflection::Module* element, Type* attributeType) {
        return GetCustomAttributes11(element, attributeType, true);
    }
    
    cli::array<Attribute*>* Attribute::GetCustomAttributes7(Reflection::ParameterInfo* element, Type* attributeType) {
        return GetCustomAttributes10(element, attributeType, true);
    }
    
    cli::array<Attribute*>* Attribute::GetCustomAttributes8(Reflection::MemberInfo* element, Type* type) {
        return GetCustomAttributes12(element, type, true);
    }
    
    cli::array<Attribute*>* Attribute::GetCustomAttributes9(Reflection::Assembly* element, Type* attributeType, bool inherit) {
        CheckParameters(element, attributeType);
        return cli::cast<cli::array<Attribute*>*>(element->GetCustomAttributes_30a143c7dfd48919(attributeType, inherit));
    }
    
    cli::array<Attribute*>* Attribute::GetCustomAttributes10(Reflection::ParameterInfo* element, Type* attributeType, bool inherit) {
        CheckParameters(element, attributeType);
        cli::array<Attribute*> *attributes;
        if((inherit && TryGetParamCustomAttributes(element, attributeType, attributes))) 
        {
            return attributes;
        }
        return cli::cast<cli::array<Attribute*>*>(element->GetCustomAttributes_1c88eb3824a80dfa(attributeType, inherit));
    }
    
    cli::array<Attribute*>* Attribute::GetCustomAttributes11(Reflection::Module* element, Type* attributeType, bool inherit) {
        CheckParameters(element, attributeType);
        return cli::cast<cli::array<Attribute*>*>(element->GetCustomAttributes_2d26f4bf11dda1f5(attributeType, inherit));
    }
    
    cli::array<Attribute*>* Attribute::GetCustomAttributes12(Reflection::MemberInfo* element, Type* type, bool inherit) {
        CheckParameters(element, type);
        Reflection::MemberTypes mtype = element->get_MemberType_cd521d320810c98f();
        if(((int32_t)(mtype) ==  16)) 
        {
            return cli::cast<cli::array<Attribute*>*>(MonoCustomAttrs::GetCustomAttributes(element, type, inherit));
        }
        return cli::cast<cli::array<Attribute*>*>(element->GetCustomAttributes_90419687cfa65ef7(type, inherit));
    }
    
    cli::array<Attribute*>* Attribute::GetCustomAttributes13(Reflection::Module* element, bool inherit) {
        return GetCustomAttributes11(element, cli::typeof<Type>::info, inherit);
    }
    
    cli::array<Attribute*>* Attribute::GetCustomAttributes14(Reflection::Assembly* element, bool inherit) {
        return GetCustomAttributes9(element, cli::typeof<Type>::info, inherit);
    }
    
    cli::array<Attribute*>* Attribute::GetCustomAttributes15(Reflection::MemberInfo* element, bool inherit) {
        return GetCustomAttributes12(element, cli::typeof<Type>::info, inherit);
    }
    
    cli::array<Attribute*>* Attribute::GetCustomAttributes16(Reflection::ParameterInfo* element, bool inherit) {
        CheckParameters(element, cli::typeof<Type>::info);
        return GetCustomAttributes10(element, cli::typeof<Type>::info, inherit);
    }
    
    int32_t Attribute::GetHashCode_6648aef0f235ee6c() {
        int32_t result = this->get_TypeId_c2c1feb36f0c7d0()->GetHashCode_6648aef0f235ee6c();
        cli::array<Reflection::FieldInfo*> *fields = Object::GetType()->GetFields_369be5ac49d99f8((Reflection::BindingFlags)52L);
        for(auto tmp_155 : fields) {
            auto field = cli::cast<Reflection::FieldInfo*>(tmp_155);
            {
                Object *value = field->GetValue_57ad13b528e8b8a5(this);
                (result = result ^ (value ==  nullptr) ? 0 : value->GetHashCode_6648aef0f235ee6c());
            }
        }
        return result;
    }
    
    bool Attribute::IsDefaultAttribute_da53f5ba259bc222() {
        return false;
    }
    
    bool Attribute::IsDefined(Reflection::Module* element, Type* attributeType) {
        return IsDefined7(element, attributeType, false);
    }
    
    bool Attribute::IsDefined2(Reflection::ParameterInfo* element, Type* attributeType) {
        return IsDefined8(element, attributeType, true);
    }
    
    bool Attribute::IsDefined3(Reflection::MemberInfo* element, Type* attributeType) {
        return IsDefined5(element, attributeType, true);
    }
    
    bool Attribute::IsDefined4(Reflection::Assembly* element, Type* attributeType) {
        return IsDefined6(element, attributeType, true);
    }
    
    bool Attribute::IsDefined5(Reflection::MemberInfo* element, Type* attributeType, bool inherit) {
        CheckParameters(element, attributeType);
        Reflection::MemberTypes mtype = element->get_MemberType_cd521d320810c98f();
        if(((((((((int32_t)(mtype) != 1) && ((int32_t)(mtype) != 2)) && ((int32_t)(mtype) != 4)) && ((int32_t)(mtype) != 8)) && ((int32_t)(mtype) != 16)) && ((int32_t)(mtype) != 32)) && ((int32_t)(mtype) != 128))) 
        {
            throw cli::gcnew<NotSupportedException>(Locale::GetText(_T("Element is not a constructor, method, property, event, type or field.")));
        }
        if(((int32_t)(mtype) ==  16)) 
        {
            return MonoCustomAttrs::IsDefined(element, attributeType, inherit);
        }
        return cli::cast<Reflection::MemberInfo*>(element)->IsDefined_91943a8ac363f11f(attributeType, inherit);
    }
    
    bool Attribute::IsDefined6(Reflection::Assembly* element, Type* attributeType, bool inherit) {
        CheckParameters(element, attributeType);
        return element->IsDefined_42f87feac494b032(attributeType, inherit);
    }
    
    bool Attribute::IsDefined7(Reflection::Module* element, Type* attributeType, bool inherit) {
        CheckParameters(element, attributeType);
        return element->IsDefined_658453ecd0c3c72(attributeType, inherit);
    }
    
    bool Attribute::IsDefined8(Reflection::ParameterInfo* element, Type* attributeType, bool inherit) {
        CheckParameters(element, attributeType);
        if(element->IsDefined_f77a22c7742d1e97(attributeType, inherit)) 
        {
            return true;
        }
        if(inherit) 
        {
            return IsDefinedOnParameter(element, attributeType);
        }
        return false;
    }
    
    bool Attribute::IsDefinedOnParameter(Reflection::ParameterInfo* parameter, Type* attributeType) {
        Reflection::MemberInfo *member = parameter->get_Member_3718e63e31df2b4e();
        if(((int32_t)(member->get_MemberType_cd521d320810c98f()) != 8)) 
        {
            return false;
        }
        Reflection::MethodInfo *method = cli::cast<Reflection::MethodInfo*>(member)->GetBaseMethod_15ff4b8595f9b09();
        while(true) {
            Reflection::ParameterInfo *param = method->GetParameters_9d17bcb549474c9()->at(parameter->get_Position_1e6976b43412375f());
            if(param->IsDefined_f77a22c7742d1e97(attributeType, false)) 
            {
                return true;
            }
            Reflection::MethodInfo *base_method = method->GetBaseMethod_15ff4b8595f9b09();
            if(Reflection::MethodInfo::op_Equality(base_method, method)) 
            {
                break;
            }
            method = base_method;
        }
        return false;
    }
    
    bool Attribute::TryGetParamCustomAttributes(Reflection::ParameterInfo* parameter, Type* attributeType, cli::array<Attribute*>* attributes) {
        attributes = nullptr;
        if(((int32_t)(parameter->get_Member_3718e63e31df2b4e()->get_MemberType_cd521d320810c98f()) != 8)) 
        {
            return false;
        }
        Reflection::MethodInfo *method = cli::cast<Reflection::MethodInfo*>(parameter->get_Member_3718e63e31df2b4e());
        Reflection::MethodInfo *definition = method->GetBaseDefinition_b00937f21f1a7556();
        if(Reflection::MethodInfo::op_Equality(method, definition)) 
        {
            return false;
        }
        Collections::Generic::List<Type*> *types = cli::gcnew<Collections::Generic::List<Type*>>();
        Collections::Generic::List<Attribute*> *custom_attributes = cli::gcnew<Collections::Generic::List<Attribute*>>();
        while(true) {
            Reflection::ParameterInfo *param = method->GetParameters_9d17bcb549474c9()->at(parameter->get_Position_1e6976b43412375f());
            cli::array<Attribute*> *param_attributes = cli::cast<cli::array<Attribute*>*>(param->GetCustomAttributes_1c88eb3824a80dfa(attributeType, false));
            for(auto tmp_156 : param_attributes) {
                auto param_attribute = cli::cast<Attribute*>(tmp_156);
                {
                    Type *param_type = param_attribute->GetType();
                    if(types->Contains(param_type)) 
                    {
                        continue;
                    }
                    types->Add(param_type);
                    custom_attributes->Add(param_attribute);
                }
            }
            Reflection::MethodInfo *base_method = method->GetBaseMethod_15ff4b8595f9b09();
            if(Reflection::MethodInfo::op_Equality(base_method, method)) 
            {
                break;
            }
            method = base_method;
        }
        attributes = cli::cast<cli::array<Attribute*>*>(Array::CreateInstance(attributeType, custom_attributes->get_Count()));
        custom_attributes->CopyTo2(attributes, 0);
        return true;
    }
    
    bool Attribute::Match_32d8f574c7dfa9e6(Object* obj) {
        return this->Equals_ed975d2f4a7d193e(obj);
    }
    
    bool Attribute::Equals_ed975d2f4a7d193e(Object* obj) {
        if(((obj ==  nullptr) || !(cli::is<Attribute>(obj)))) 
        {
            return false;
        }
        return ValueType::DefaultEquals(this, obj);
    }
    
    void Attribute::GetIDsOfNames(Guid riid, void* rgszNames, uint32_t cNames, uint32_t lcid, void* rgDispId) {
        throw cli::gcnew<NotImplementedException>();
    }
    
    void Attribute::GetTypeInfo(uint32_t iTInfo, uint32_t lcid, void* ppTInfo) {
        throw cli::gcnew<NotImplementedException>();
    }
    
    void Attribute::GetTypeInfoCount(uint32_t pcTInfo) {
        throw cli::gcnew<NotImplementedException>();
    }
    
    void Attribute::Invoke(uint32_t dispIdMember, Guid riid, uint32_t lcid, int16_t wFlags, void* pDispParams, void* pVarResult, void* pExcepInfo, void* puArgErr) {
        throw cli::gcnew<NotImplementedException>();
    }
    
    Object* Attribute::get_TypeId_c2c1feb36f0c7d0() {
        return this->GetType();
    }
    
}
namespace System {
    
    
    void AttributeUsageAttribute::constructor(AttributeTargets validOn) {
        this->valid_on = validOn;
    }
    
    bool AttributeUsageAttribute::get_AllowMultiple() {
        return this->allow_multiple;
    }
    
    bool AttributeUsageAttribute::set_AllowMultiple(bool value) {
        this->allow_multiple = value;
        return get_AllowMultiple();
    }
    
    bool AttributeUsageAttribute::get_Inherited() {
        return this->inherited;
    }
    
    bool AttributeUsageAttribute::set_Inherited(bool value) {
        this->inherited = value;
        return get_Inherited();
    }
    
    AttributeTargets AttributeUsageAttribute::get_ValidOn() {
        return this->valid_on;
    }
    
}
namespace System {
    
    
    void BadImageFormatException::constructor() {
        this->set_HResult(-2147024885);
    }
    
    void BadImageFormatException::constructor(String* message) {
        this->set_HResult(-2147024885);
    }
    
    void BadImageFormatException::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        this->fileName = info->GetString(_T("BadImageFormat_FileName"));
        this->fusionLog = info->GetString(_T("BadImageFormat_FusionLog"));
    }
    
    void BadImageFormatException::constructor(String* message, Exception* inner) {
        this->set_HResult(-2147024885);
    }
    
    void BadImageFormatException::constructor(String* message, String* fileName) {
        this->fileName = fileName;
        this->set_HResult(-2147024885);
    }
    
    void BadImageFormatException::constructor(String* message, String* fileName, Exception* inner) {
        this->fileName = fileName;
        this->set_HResult(-2147024885);
    }
    
    void BadImageFormatException::GetObjectData_bc9b88d7eb43b6d8(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        SystemException::GetObjectData_bc9b88d7eb43b6d8(info, context);
        info->AddValue16(_T("BadImageFormat_FileName"), this->fileName);
        info->AddValue16(_T("BadImageFormat_FusionLog"), this->fusionLog);
    }
    
    String* BadImageFormatException::ToString_1636a0751cb9ac11() {
        Text::StringBuilder *sb = cli::gcnew<Text::StringBuilder>(Exception::GetType2()->get_FullName_7e8fa72ba225e1a4());
        sb->AppendFormat3(_T(": {0}"), this->get_Message_d211df4045b57cbf());
        if(((this->fileName != nullptr) && (this->fileName->get_Length() > 0))) 
        {
            sb->Append2(Environment::get_NewLine());
            sb->AppendFormat3(_T("File name: \'{0}\'"), this->fileName);
        }
        if((this->get_InnerException() != nullptr)) 
        {
            sb->AppendFormat3(_T(" ---> {0}"), this->get_InnerException());
        }
        if((this->get_StackTrace_f3fc28619b4f921() != nullptr)) 
        {
            sb->Append2(Environment::get_NewLine());
            sb->Append2(this->get_StackTrace_f3fc28619b4f921());
        }
        return sb->ToString_1636a0751cb9ac11();
    }
    
    String* BadImageFormatException::get_Message_d211df4045b57cbf() {
        if((SystemException::message ==  nullptr)) 
        {
            return String::Format6(Globalization::CultureInfo::get_CurrentCulture(), _T("Could not load file or assembly \'{0}\' or one of its dependencies. An attempt was made to load a program with an incorrect format."), (new cli::array<Object*>({this->fileName})));
        }
        return SystemException::get_Message_d211df4045b57cbf();
    }
    
    String* BadImageFormatException::get_FileName() {
        return this->fileName;
    }
    
    String* BadImageFormatException::get_FusionLog() {
        return this->fusionLog;
    }
    
}
namespace System {
    
    bool  BitConverter::SwappedWordsInDouble;
    bool  BitConverter::IsLittleEndian;
    
    BitConverter::BitConverter()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void BitConverter::static_constructor() {
    }
    
    bool BitConverter::AmILittleEndian() {
        double d = 1.;
        unsigned char *b = (unsigned char*)(&(d));
        return ((int32_t)((*(b + 0))) ==  0);
    }
    
    bool BitConverter::DoubleWordsAreSwapped() {
        double d = 1.;
        unsigned char *b = (unsigned char*)(&(d));
        return ((int32_t)((*(b + 2))) ==  240);
    }
    
    int64_t BitConverter::DoubleToInt64Bits(double value) {
        return ToInt64(GetBytes11(value), 0);
    }
    
    double BitConverter::Int64BitsToDouble(int64_t value) {
        return ToDouble(GetBytes6(value), 0);
    }
    
    double BitConverter::InternalInt64BitsToDouble(int64_t value) {
        return SwappableToDouble(GetBytes6(value), 0);
    }
    
    cli::array<unsigned char>* BitConverter::GetBytes(unsigned char* ptr, int32_t count) {
        cli::array<unsigned char> *ret = (new cli::array<unsigned char>(count));
        for(int32_t i = 0; (i < count); i++){
            ret->at(i) = (*(ptr + i));
        }
        return ret;
    }
    
    cli::array<unsigned char>* BitConverter::GetBytes2(bool value) {
        return GetBytes((unsigned char*)(&(value)), 1);
    }
    
    cli::array<unsigned char>* BitConverter::GetBytes3(char16_t value) {
        return GetBytes((unsigned char*)(&(value)), 2);
    }
    
    cli::array<unsigned char>* BitConverter::GetBytes4(int16_t value) {
        return GetBytes((unsigned char*)(&(value)), 2);
    }
    
    cli::array<unsigned char>* BitConverter::GetBytes5(int32_t value) {
        return GetBytes((unsigned char*)(&(value)), 4);
    }
    
    cli::array<unsigned char>* BitConverter::GetBytes6(int64_t value) {
        return GetBytes((unsigned char*)(&(value)), 8);
    }
    
    cli::array<unsigned char>* BitConverter::GetBytes7(uint16_t value) {
        return GetBytes((unsigned char*)(&(value)), 2);
    }
    
    cli::array<unsigned char>* BitConverter::GetBytes8(uint32_t value) {
        return GetBytes((unsigned char*)(&(value)), 4);
    }
    
    cli::array<unsigned char>* BitConverter::GetBytes9(uint64_t value) {
        return GetBytes((unsigned char*)(&(value)), 8);
    }
    
    cli::array<unsigned char>* BitConverter::GetBytes10(float value) {
        return GetBytes((unsigned char*)(&(value)), 4);
    }
    
    cli::array<unsigned char>* BitConverter::GetBytes11(double value) {
        if(SwappedWordsInDouble) 
        {
            cli::array<unsigned char> *data = (new cli::array<unsigned char>(8));
            unsigned char *p = (unsigned char*)(&(value));
            data->at(0) = (*(p + 4));
            data->at(1) = (*(p + 5));
            data->at(2) = (*(p + 6));
            data->at(3) = (*(p + 7));
            data->at(4) = (*(p + 0));
            data->at(5) = (*(p + 1));
            data->at(6) = (*(p + 2));
            data->at(7) = (*(p + 3));
            return data;
        }
         else 
        {
            return GetBytes((unsigned char*)(&(value)), 8);
        }
    }
    
    void BitConverter::PutBytes(unsigned char* dst, cli::array<unsigned char>* src, int32_t start_index, int32_t count) {
        if((src ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("value"));
        }
        if(((start_index < 0) || (start_index > (src->get_Length() - 1)))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("startIndex"), _T("Index was out of range. Must be non-negative and less than the size of the collection."));
        }
        if(((src->get_Length() - count) < start_index)) 
        {
            throw cli::gcnew<ArgumentException>(_T("Destination array is not long enough to copy all the items in the collection. Check array index and length."));
        }
        for(int32_t i = 0; (i < count); i++) {
            (*(dst + i)) = src->at((i + start_index));
        }
    }
    
    bool BitConverter::ToBoolean(cli::array<unsigned char>* value, int32_t startIndex) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("value"));
        }
        if(((startIndex < 0) || (startIndex > (value->get_Length() - 1)))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("startIndex"), _T("Index was out of range. Must be non-negative and less than the size of the collection."));
        }
        if(((int32_t)(value->at(startIndex)) != 0)) 
        {
            return true;
        }
        return false;
    }
    
    char16_t BitConverter::ToChar(cli::array<unsigned char>* value, int32_t startIndex) {
        char16_t ret;
        PutBytes((unsigned char*)(&(ret)), value, startIndex, 2);
        return ret;
    }
    
    int16_t BitConverter::ToInt16(cli::array<unsigned char>* value, int32_t startIndex) {
        int16_t ret;
        PutBytes((unsigned char*)(&(ret)), value, startIndex, 2);
        return ret;
    }
    
    int32_t BitConverter::ToInt32(cli::array<unsigned char>* value, int32_t startIndex) {
        int32_t ret;
        PutBytes((unsigned char*)(&(ret)), value, startIndex, 4);
        return ret;
    }
    
    int64_t BitConverter::ToInt64(cli::array<unsigned char>* value, int32_t startIndex) {
        int64_t ret;
        PutBytes((unsigned char*)(&(ret)), value, startIndex, 8);
        return ret;
    }
    
    uint16_t BitConverter::ToUInt16(cli::array<unsigned char>* value, int32_t startIndex) {
        uint16_t ret;
        PutBytes((unsigned char*)(&(ret)), value, startIndex, 2);
        return ret;
    }
    
    uint32_t BitConverter::ToUInt32(cli::array<unsigned char>* value, int32_t startIndex) {
        uint32_t ret;
        PutBytes((unsigned char*)(&(ret)), value, startIndex, 4);
        return ret;
    }
    
    uint64_t BitConverter::ToUInt64(cli::array<unsigned char>* value, int32_t startIndex) {
        uint64_t ret;
        PutBytes((unsigned char*)(&(ret)), value, startIndex, 8);
        return ret;
    }
    
    float BitConverter::ToSingle(cli::array<unsigned char>* value, int32_t startIndex) {
        float ret;
        PutBytes((unsigned char*)(&(ret)), value, startIndex, 4);
        return ret;
    }
    
    double BitConverter::ToDouble(cli::array<unsigned char>* value, int32_t startIndex) {
        double ret;
        if(SwappedWordsInDouble) 
        {
            unsigned char *p = (unsigned char*)(&(ret));
            if((value ==  nullptr)) 
            {
                throw cli::gcnew<ArgumentNullException>(_T("value"));
            }
            if(((startIndex < 0) || (startIndex > (value->get_Length() - 1)))) 
            {
                throw cli::gcnew<ArgumentOutOfRangeException>(_T("startIndex"), _T("Index was out of range. Must be non-negative and less than the size of the collection."));
            }
            if(((value->get_Length() - 8) < startIndex)) 
            {
                throw cli::gcnew<ArgumentException>(_T("Destination array is not long enough to copy all the items in the collection. Check array index and length."));
            }
            (*(p + 0)) = value->at((startIndex + 4));
            (*(p + 1)) = value->at((startIndex + 5));
            (*(p + 2)) = value->at((startIndex + 6));
            (*(p + 3)) = value->at((startIndex + 7));
            (*(p + 4)) = value->at(startIndex);
            (*(p + 5)) = value->at((startIndex + 1));
            (*(p + 6)) = value->at((startIndex + 2));
            (*(p + 7)) = value->at((startIndex + 3));
            return ret;
        }
        PutBytes((unsigned char*)(&(ret)), value, startIndex, 8);
        return ret;
    }
    
    double BitConverter::SwappableToDouble(cli::array<unsigned char>* value, int32_t startIndex) {
        double ret;
        if(SwappedWordsInDouble) 
        {
            unsigned char *p = (unsigned char*)(&(ret));
            if((value ==  nullptr)) 
            {
                throw cli::gcnew<ArgumentNullException>(_T("value"));
            }
            if(((startIndex < 0) || (startIndex > (value->get_Length() - 1)))) 
            {
                throw cli::gcnew<ArgumentOutOfRangeException>(_T("startIndex"), _T("Index was out of range. Must be non-negative and less than the size of the collection."));
            }
            if(((value->get_Length() - 8) < startIndex)) 
            {
                throw cli::gcnew<ArgumentException>(_T("Destination array is not long enough to copy all the items in the collection. Check array index and length."));
            }
            (*(p + 0)) = value->at((startIndex + 4));
            (*(p + 1)) = value->at((startIndex + 5));
            (*(p + 2)) = value->at((startIndex + 6));
            (*(p + 3)) = value->at((startIndex + 7));
            (*(p + 4)) = value->at(startIndex);
            (*(p + 5)) = value->at((startIndex + 1));
            (*(p + 6)) = value->at((startIndex + 2));
            (*(p + 7)) = value->at((startIndex + 3));
            return ret;
        }
         else 
        {
            if(!(IsLittleEndian)) 
            {
                unsigned char *p = (unsigned char*)(&(ret));
                if((value ==  nullptr)) 
                {
                    throw cli::gcnew<ArgumentNullException>(_T("value"));
                }
                if(((startIndex < 0) || (startIndex > (value->get_Length() - 1)))) 
                {
                    throw cli::gcnew<ArgumentOutOfRangeException>(_T("startIndex"), _T("Index was out of range. Must be non-negative and less than the size of the collection."));
                }
                if(((value->get_Length() - 8) < startIndex)) 
                {
                    throw cli::gcnew<ArgumentException>(_T("Destination array is not long enough to copy all the items in the collection. Check array index and length."));
                }
                (*(p + 0)) = value->at((startIndex + 7));
                (*(p + 1)) = value->at((startIndex + 6));
                (*(p + 2)) = value->at((startIndex + 5));
                (*(p + 3)) = value->at((startIndex + 4));
                (*(p + 4)) = value->at((startIndex + 3));
                (*(p + 5)) = value->at((startIndex + 2));
                (*(p + 6)) = value->at((startIndex + 1));
                (*(p + 7)) = value->at(startIndex);
                return ret;
            }
        }
        PutBytes((unsigned char*)(&(ret)), value, startIndex, 8);
        return ret;
    }
    
    String* BitConverter::ToString2(cli::array<unsigned char>* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("value"));
        }
        return ToString4(value, 0, value->get_Length());
    }
    
    String* BitConverter::ToString3(cli::array<unsigned char>* value, int32_t startIndex) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("value"));
        }
        return ToString4(value, startIndex, (value->get_Length() - startIndex));
    }
    
    String* BitConverter::ToString4(cli::array<unsigned char>* value, int32_t startIndex, int32_t length) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("byteArray"));
        }
        if(((startIndex < 0) || (startIndex >= value->get_Length()))) 
        {
            if(((startIndex ==  0) && (value->get_Length() ==  0))) 
            {
                return String::Empty;
            }
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("startIndex"), _T("Index was out of range. Must be non-negative and less than the size of the collection."));
        }
        if((length < 0)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("length"), _T("Value must be positive."));
        }
        if((startIndex > (value->get_Length() - length))) 
        {
            throw cli::gcnew<ArgumentException>(_T("startIndex + length > value.Length"));
        }
        if((length ==  0)) 
        {
            return String::Empty;
        }
        Text::StringBuilder *builder = cli::gcnew<Text::StringBuilder>(((length * 3) - 1));
        int32_t end = (startIndex + length);
        for(int32_t i = startIndex; (i < end); i++){
            if((i > startIndex)) 
            {
                builder->Append16(u'-');
            }
            char16_t high = (char16_t)(((int32_t)(value->at(i)) >> 4) & 15);
            char16_t low = (char16_t)((int32_t)(value->at(i)) & 15);
            if(((int32_t)(high) < 10)) 
            {
                (high = (char16_t)((int32_t)(high) + 48));
            }
             else 
            {
                (high = (char16_t)((int32_t)(high) - 10));
                (high = (char16_t)((int32_t)(high) + 65));
            }
            if(((int32_t)(low) < 10)) 
            {
                (low = (char16_t)((int32_t)(low) + 48));
            }
             else 
            {
                (low = (char16_t)((int32_t)(low) - 10));
                (low = (char16_t)((int32_t)(low) + 65));
            }
            builder->Append16(high);
            builder->Append16(low);
        }
        return builder->ToString_1636a0751cb9ac11();
    }
    
}
namespace System {
    
    
    int32_t Buffer::ByteLength(Array* array) {
        if((array ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("array"));
        }
        int32_t length = ByteLengthInternal(array);
        if((length < 0)) 
        {
            throw cli::gcnew<ArgumentException>(Locale::GetText(_T("Object must be an array of primitives.")));
        }
        return length;
    }
    
    unsigned char Buffer::GetByte(Array* array, int32_t index) {
        if(((index < 0) || (index >= ByteLength(array)))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("index"), Locale::GetText(_T("Value must be non-negative and less than the size of the collection.")));
        }
        return GetByteInternal(array, index);
    }
    
    void Buffer::SetByte(Array* array, int32_t index, unsigned char value) {
        if(((index < 0) || (index >= ByteLength(array)))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("index"), Locale::GetText(_T("Value must be non-negative and less than the size of the collection.")));
        }
        SetByteInternal(array, index, (int32_t)(value));
    }
    
    void Buffer::BlockCopy(Array* src, int32_t srcOffset, Array* dst, int32_t dstOffset, int32_t count) {
        if((src ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("src"));
        }
        if((dst ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("dst"));
        }
        if((srcOffset < 0)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("srcOffset"), Locale::GetText(_T("Non-negative number required.")));
        }
        if((dstOffset < 0)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("dstOffset"), Locale::GetText(_T("Non-negative number required.")));
        }
        if((count < 0)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("count"), Locale::GetText(_T("Non-negative number required.")));
        }
        bool res = BlockCopyInternal(src, srcOffset, dst, dstOffset, count);
        if(!(res)) 
        {
            if(((srcOffset > (ByteLength(src) - count)) || (dstOffset > (ByteLength(dst) - count)))) 
            {
                throw cli::gcnew<ArgumentException>(Locale::GetText(_T("Offset and length were out of bounds for the array or count is greater than the number of elements from index to the end of the source collection.")));
            }
        }
    }
    
    int32_t Buffer::ByteLengthInternal(Array* array) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    unsigned char Buffer::GetByteInternal(Array* array, int32_t index) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Buffer::SetByteInternal(Array* array, int32_t index, int32_t value) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool Buffer::BlockCopyInternal(Array* src, int32_t src_offset, Array* dest, int32_t dest_offset, int32_t count) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
}
namespace System {
    
    
    void CannotUnloadAppDomainException::constructor() {
        this->set_HResult(-2146234347);
    }
    
    void CannotUnloadAppDomainException::constructor(String* message) {
        this->set_HResult(-2146234347);
    }
    
    void CannotUnloadAppDomainException::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
    }
    
    void CannotUnloadAppDomainException::constructor(String* message, Exception* innerException) {
        this->set_HResult(-2146234347);
    }
    
}
namespace System {
    
    
    void CharEnumerator::constructor(String* s) {
        this->str = s;
        this->index = -1;
        this->length = s->get_Length();
    }
    
    void CharEnumerator::Dispose() {
    }
    
    Object* CharEnumerator::Clone() {
        CharEnumerator *x = cli::gcnew<CharEnumerator>(this->str);
        x->index = this->index;
        return x;
    }
    
    bool CharEnumerator::MoveNext() {
        this->index++;
        if((this->index >= this->length)) 
        {
            this->index = this->length;
            return false;
        }
         else 
        {
            return true;
        }
    }
    
    void CharEnumerator::Reset() {
        this->index = -1;
    }
    
    char16_t CharEnumerator::get_Current() {
        if(((this->index ==  -1) || (this->index >= this->length))) 
        {
            throw cli::gcnew<InvalidOperationException>(Locale::GetText(_T("The position is not valid.")));
        }
        return this->str->get_Chars(this->index);
    }
    
    Object* CharEnumerator::get_Current2() {
        return cli::box(this->get_Current());
    }
    
}
namespace System {
    
    
    void CLSCompliantAttribute::constructor(bool isCompliant) {
        this->is_compliant = isCompliant;
    }
    
    bool CLSCompliantAttribute::get_IsCompliant() {
        return this->is_compliant;
    }
    
}
namespace System {
    
    bool  WindowsConsole::ctrlHandlerAdded;
    WindowsCancelHandler*  WindowsConsole::cancelHandler;
    
    WindowsConsole::WindowsConsole()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void WindowsConsole::constructor() {
    }
    
    void WindowsConsole::static_constructor() {
    }
    
    int32_t WindowsConsole::GetConsoleCP() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t WindowsConsole::GetConsoleOutputCP() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool WindowsConsole::SetConsoleCtrlHandler(WindowsCancelHandler* handler, bool addHandler) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool WindowsConsole::DoWindowsConsoleCancelEvent(int32_t keyCode) {
        if((keyCode ==  0)) 
        {
            Console::DoConsoleCancelEvent();
        }
        return (keyCode ==  0);
    }
    
    int32_t WindowsConsole::GetInputCodePage() {
        return GetConsoleCP();
    }
    
    int32_t WindowsConsole::GetOutputCodePage() {
        return GetConsoleOutputCP();
    }
    
    void WindowsConsole::AddCtrlHandler() {
        SetConsoleCtrlHandler(cancelHandler, true);
        ctrlHandlerAdded = true;
    }
    
    void WindowsConsole::RemoveCtrlHandler() {
        SetConsoleCtrlHandler(cancelHandler, false);
        ctrlHandlerAdded = false;
    }
    
}
namespace System {
    
    IO::TextWriter*  Console::stdout_;
    IO::TextWriter*  Console::stderr_;
    IO::TextReader*  Console::stdin_;
    Text::Encoding*  Console::inputEncoding;
    Text::Encoding*  Console::outputEncoding;
    ConsoleCancelEventHandler*  Console::cancel_event;
    InternalCancelHandler*  Console::cancel_handler;
    
    Console::Console()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void Console::static_constructor() {
        if(Environment::get_IsRunningOnWindows()) 
        {
            try {
                inputEncoding = Text::Encoding::GetEncoding(WindowsConsole::GetInputCodePage());
                outputEncoding = Text::Encoding::GetEncoding(WindowsConsole::GetOutputCodePage());
            }
            catch(...) {
                inputEncoding = outputEncoding = Text::Encoding::get_Default();
            }
        }
         else 
        {
            int32_t code_page = 0;
            Text::Encoding::InternalCodePage(code_page);
            if(((code_page != -1) && (((code_page & 268435455) ==  3) || ((code_page & 268435456) != 0)))) 
            {
                inputEncoding = outputEncoding = Text::Encoding::get_UTF8Unmarked();
            }
             else 
            {
                inputEncoding = outputEncoding = Text::Encoding::get_Default();
            }
        }
        SetupStreams(inputEncoding, outputEncoding);
    }
    
    void Console::SetupStreams(Text::Encoding* inputEncoding, Text::Encoding* outputEncoding) {
        if((!(Environment::get_IsRunningOnWindows()) && ConsoleDriver::get_IsConsole())) 
        {
            IO::StreamWriter *w = cli::gcnew<IO::CStreamWriter>(OpenStandardOutput2(0), outputEncoding);
            w->set_AutoFlush_12a815ad7ffc54a(true);
            stdout_ = IO::TextWriter::Synchronized2(w, true);
            w = cli::gcnew<IO::CStreamWriter>(OpenStandardOutput2(0), outputEncoding);
            w->set_AutoFlush_12a815ad7ffc54a(true);
            stderr_ = IO::TextWriter::Synchronized2(w, true);
            stdin_ = cli::gcnew<IO::CStreamReader>(OpenStandardInput2(0), inputEncoding);
        }
         else 
        {
            stdout_ = cli::gcnew<IO::UnexceptionalStreamWriter>(OpenStandardOutput2(0), outputEncoding);
            cli::cast<IO::StreamWriter*>(stdout_)->set_AutoFlush_12a815ad7ffc54a(true);
            stdout_ = IO::TextWriter::Synchronized2(stdout_, true);
            stderr_ = cli::gcnew<IO::UnexceptionalStreamWriter>(OpenStandardError2(0), outputEncoding);
            cli::cast<IO::StreamWriter*>(stderr_)->set_AutoFlush_12a815ad7ffc54a(true);
            stderr_ = IO::TextWriter::Synchronized2(stderr_, true);
            stdin_ = cli::gcnew<IO::UnexceptionalStreamReader>(OpenStandardInput2(0), inputEncoding);
            stdin_ = IO::TextReader::Synchronized(stdin_);
        }
        GC::SuppressFinalize(stdout_);
        GC::SuppressFinalize(stderr_);
        GC::SuppressFinalize(stdin_);
    }
    
    IO::Stream* Console::Open(void* handle, IO::FileAccess access, int32_t bufferSize) {
        try {
            return cli::gcnew<IO::FileStream>(handle, access, false, bufferSize, false, (bufferSize ==  0));
        }
        catch(IO::IOException*) {
            return cli::gcnew<IO::NullStream>();
        }
    }
    
    IO::Stream* Console::OpenStandardError() {
        return OpenStandardError2(0);
    }
    
    IO::Stream* Console::OpenStandardError2(int32_t bufferSize) {
        return Open(IO::MonoIO::get_ConsoleError(), IO::FileAccess::Write, bufferSize);
    }
    
    IO::Stream* Console::OpenStandardInput() {
        return OpenStandardInput2(0);
    }
    
    IO::Stream* Console::OpenStandardInput2(int32_t bufferSize) {
        return Open(IO::MonoIO::get_ConsoleInput(), IO::FileAccess::Read, bufferSize);
    }
    
    IO::Stream* Console::OpenStandardOutput() {
        return OpenStandardOutput2(0);
    }
    
    IO::Stream* Console::OpenStandardOutput2(int32_t bufferSize) {
        return Open(IO::MonoIO::get_ConsoleOutput(), IO::FileAccess::Write, bufferSize);
    }
    
    void Console::SetError(IO::TextWriter* newError) {
        if((newError ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("newError"));
        }
        stderr_ = newError;
    }
    
    void Console::SetIn(IO::TextReader* newIn) {
        if((newIn ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("newIn"));
        }
        stdin_ = newIn;
    }
    
    void Console::SetOut(IO::TextWriter* newOut) {
        if((newOut ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("newOut"));
        }
        stdout_ = newOut;
    }
    
    void Console::Write(bool value) {
        stdout_->Write_443a7a25c054668(value);
    }
    
    void Console::Write2(char16_t value) {
        stdout_->Write_96ccae6b0b267024(value);
    }
    
    void Console::Write3(cli::array<char16_t>* buffer) {
        stdout_->Write_6d89396c0c5b77c4(buffer);
    }
    
    void Console::Write4(Decimal value) {
        stdout_->Write_222d042b1869986(value);
    }
    
    void Console::Write5(double value) {
        stdout_->Write_31466a0eb6072a4a(value);
    }
    
    void Console::Write6(int32_t value) {
        stdout_->Write_12c6f74b27421524(value);
    }
    
    void Console::Write7(int64_t value) {
        stdout_->Write_bda7727b5cfc5345(value);
    }
    
    void Console::Write8(Object* value) {
        stdout_->Write_55565de44c1e3104(value);
    }
    
    void Console::Write9(float value) {
        stdout_->Write_3945ee193bccdd42(value);
    }
    
    void Console::Write10(String* value) {
        stdout_->Write_dcf5e45abd9e11c4(value);
    }
    
    void Console::Write11(uint32_t value) {
        stdout_->Write_8d2ce38f16ef9fe3(value);
    }
    
    void Console::Write12(uint64_t value) {
        stdout_->Write_bed5c65a22d487e6(value);
    }
    
    void Console::Write13(String* format, Object* arg0) {
        stdout_->Write_f2bf6875dbaeba6a(format, arg0);
    }
    
    void Console::Write14(String* format, cli::array<Object*>* arg) {
        if((arg ==  nullptr)) 
        {
            stdout_->Write_dcf5e45abd9e11c4(format);
        }
         else 
        {
            stdout_->Write_e2bf1f4b5968ab9(format, arg);
        }
    }
    
    void Console::Write15(cli::array<char16_t>* buffer, int32_t index, int32_t count) {
        stdout_->Write_61da934607a8065a(buffer, index, count);
    }
    
    void Console::Write16(String* format, Object* arg0, Object* arg1) {
        stdout_->Write_d1ec280d8f085d73(format, arg0, arg1);
    }
    
    void Console::Write17(String* format, Object* arg0, Object* arg1, Object* arg2) {
        stdout_->Write_4d2ac9c7b9e5e3b6(format, arg0, arg1, arg2);
    }
    
    void Console::Write18(String* format, Object* arg0, Object* arg1, Object* arg2, Object* arg3) {
        ArgIterator iter = cli::ctor<ArgIterator>(__arglist);
        int32_t argCount = iter->GetRemainingCount();
        cli::array<Object*> *args = (new cli::array<Object*>((argCount + 4)));
        args->at(0) = arg0;
        args->at(1) = arg1;
        args->at(2) = arg2;
        args->at(3) = arg3;
        for(int32_t i = 0; (i < argCount); i++){
            TypedReference typedRef = iter->GetNextArg();
            args->at((i + 4)) = TypedReference::ToObject(typedRef);
        }
        stdout_->Write_dcf5e45abd9e11c4(String::Format5(format, args));
    }
    
    void Console::WriteLine() {
        stdout_->WriteLine_f0ca76dc02634177();
    }
    
    void Console::WriteLine2(bool value) {
        stdout_->WriteLine_711f0f7d57a6b9ec(value);
    }
    
    void Console::WriteLine3(char16_t value) {
        stdout_->WriteLine_5db503756aad6b7e(value);
    }
    
    void Console::WriteLine4(cli::array<char16_t>* buffer) {
        stdout_->WriteLine_4e1d057f0df9eb1f(buffer);
    }
    
    void Console::WriteLine5(Decimal value) {
        stdout_->WriteLine_7215ae0192c985c9(value);
    }
    
    void Console::WriteLine6(double value) {
        stdout_->WriteLine_e88c356ba9c2db75(value);
    }
    
    void Console::WriteLine7(int32_t value) {
        stdout_->WriteLine_4f98173db23c2ff8(value);
    }
    
    void Console::WriteLine8(int64_t value) {
        stdout_->WriteLine_79f607f527127dc5(value);
    }
    
    void Console::WriteLine9(Object* value) {
        stdout_->WriteLine_dfd9dff343620f4d(value);
    }
    
    void Console::WriteLine10(float value) {
        stdout_->WriteLine_1fcb4a3f9e16c04c(value);
    }
    
    void Console::WriteLine11(String* value) {
        stdout_->WriteLine_27fb29d2c5b390c7(value);
    }
    
    void Console::WriteLine12(uint32_t value) {
        stdout_->WriteLine_cf4ece46b08b7fc4(value);
    }
    
    void Console::WriteLine13(uint64_t value) {
        stdout_->WriteLine_ee19bfc9492f25dd(value);
    }
    
    void Console::WriteLine14(String* format, Object* arg0) {
        stdout_->WriteLine_5eb6d2f1667d4085(format, arg0);
    }
    
    void Console::WriteLine15(String* format, cli::array<Object*>* arg) {
        if((arg ==  nullptr)) 
        {
            stdout_->WriteLine_27fb29d2c5b390c7(format);
        }
         else 
        {
            stdout_->WriteLine_b743f1a08f47f965(format, arg);
        }
    }
    
    void Console::WriteLine16(cli::array<char16_t>* buffer, int32_t index, int32_t count) {
        stdout_->WriteLine_9dea657622eb9bf4(buffer, index, count);
    }
    
    void Console::WriteLine17(String* format, Object* arg0, Object* arg1) {
        stdout_->WriteLine_b33fb6632b99859a(format, arg0, arg1);
    }
    
    void Console::WriteLine18(String* format, Object* arg0, Object* arg1, Object* arg2) {
        stdout_->WriteLine_10ed8cd26a3939e1(format, arg0, arg1, arg2);
    }
    
    void Console::WriteLine19(String* format, Object* arg0, Object* arg1, Object* arg2, Object* arg3) {
        ArgIterator iter = cli::ctor<ArgIterator>(__arglist);
        int32_t argCount = iter->GetRemainingCount();
        cli::array<Object*> *args = (new cli::array<Object*>((argCount + 4)));
        args->at(0) = arg0;
        args->at(1) = arg1;
        args->at(2) = arg2;
        args->at(3) = arg3;
        for(int32_t i = 0; (i < argCount); i++){
            TypedReference typedRef = iter->GetNextArg();
            args->at((i + 4)) = TypedReference::ToObject(typedRef);
        }
        stdout_->WriteLine_27fb29d2c5b390c7(String::Format5(format, args));
    }
    
    int32_t Console::Read() {
        if((cli::is<IO::CStreamReader>(stdin_) && ConsoleDriver::get_IsConsole())) 
        {
            return ConsoleDriver::Read();
        }
         else 
        {
            return stdin_->Read_1d437d5ac2290f2b();
        }
    }
    
    String* Console::ReadLine() {
        if((cli::is<IO::CStreamReader>(stdin_) && ConsoleDriver::get_IsConsole())) 
        {
            return ConsoleDriver::ReadLine();
        }
         else 
        {
            return stdin_->ReadLine_51552a49261f929e();
        }
    }
    
    void Console::Beep() {
        Beep2(1000, 500);
    }
    
    void Console::Beep2(int32_t frequency, int32_t duration) {
        if(((frequency < 37) || (frequency > 32767))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("frequency"));
        }
        if((duration <= 0)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("duration"));
        }
        ConsoleDriver::Beep(frequency, duration);
    }
    
    void Console::Clear() {
        ConsoleDriver::Clear();
    }
    
    void Console::MoveBufferArea(int32_t sourceLeft, int32_t sourceTop, int32_t sourceWidth, int32_t sourceHeight, int32_t targetLeft, int32_t targetTop) {
        ConsoleDriver::MoveBufferArea(sourceLeft, sourceTop, sourceWidth, sourceHeight, targetLeft, targetTop);
    }
    
    void Console::MoveBufferArea2(int32_t sourceLeft, int32_t sourceTop, int32_t sourceWidth, int32_t sourceHeight, int32_t targetLeft, int32_t targetTop, char16_t sourceChar, ConsoleColor sourceForeColor, ConsoleColor sourceBackColor) {
        ConsoleDriver::MoveBufferArea2(sourceLeft, sourceTop, sourceWidth, sourceHeight, targetLeft, targetTop, sourceChar, sourceForeColor, sourceBackColor);
    }
    
    ConsoleKeyInfo Console::ReadKey() {
        return ReadKey2(false);
    }
    
    ConsoleKeyInfo Console::ReadKey2(bool intercept) {
        return ConsoleDriver::ReadKey(intercept);
    }
    
    void Console::ResetColor() {
        ConsoleDriver::ResetColor();
    }
    
    void Console::SetBufferSize(int32_t width, int32_t height) {
        ConsoleDriver::SetBufferSize(width, height);
    }
    
    void Console::SetCursorPosition(int32_t left, int32_t top) {
        ConsoleDriver::SetCursorPosition(left, top);
    }
    
    void Console::SetWindowPosition(int32_t left, int32_t top) {
        ConsoleDriver::SetWindowPosition(left, top);
    }
    
    void Console::SetWindowSize(int32_t width, int32_t height) {
        ConsoleDriver::SetWindowSize(width, height);
    }
    
    void Console::DoConsoleCancelEvent() {
        bool exit = true;
        if((cancel_event != nullptr)) 
        {
            ConsoleCancelEventArgs *args = cli::gcnew<ConsoleCancelEventArgs>(ConsoleSpecialKey::ControlC);
            cli::array<Delegate*> *delegates = cancel_event->GetInvocationList_8fef0390be027d95();
            for(auto tmp_157 : delegates) {
                auto d = cli::cast<ConsoleCancelEventHandler*>(tmp_157);
                {
                    try {
                        d->Invoke(nullptr, args);
                    }
                    catch(...) {
                    }
                }
            }
            exit = !(args->get_Cancel());
        }
        if(exit) 
        {
            Environment::Exit(58);
        }
    }
    
    IO::TextWriter* Console::get_Error() {
        return stderr_;
    }
    
    IO::TextWriter* Console::get_Out() {
        return stdout_;
    }
    
    IO::TextReader* Console::get_In() {
        return stdin_;
    }
    
    Text::Encoding* Console::get_InputEncoding() {
        return inputEncoding;
    }
    
    Text::Encoding* Console::set_InputEncoding(Text::Encoding* value) {
        inputEncoding = value;
        SetupStreams(inputEncoding, outputEncoding);
        return get_InputEncoding();
    }
    
    Text::Encoding* Console::get_OutputEncoding() {
        return outputEncoding;
    }
    
    Text::Encoding* Console::set_OutputEncoding(Text::Encoding* value) {
        outputEncoding = value;
        SetupStreams(inputEncoding, outputEncoding);
        return get_OutputEncoding();
    }
    
    ConsoleColor Console::get_BackgroundColor() {
        return ConsoleDriver::get_BackgroundColor();
    }
    
    ConsoleColor Console::set_BackgroundColor(ConsoleColor value) {
        ConsoleDriver::set_BackgroundColor(value);
        return get_BackgroundColor();
    }
    
    int32_t Console::get_BufferHeight() {
        return ConsoleDriver::get_BufferHeight();
    }
    
    int32_t Console::set_BufferHeight(int32_t value) {
        ConsoleDriver::set_BufferHeight(value);
        return get_BufferHeight();
    }
    
    int32_t Console::get_BufferWidth() {
        return ConsoleDriver::get_BufferWidth();
    }
    
    int32_t Console::set_BufferWidth(int32_t value) {
        ConsoleDriver::set_BufferWidth(value);
        return get_BufferWidth();
    }
    
    bool Console::get_CapsLock() {
        return ConsoleDriver::get_CapsLock();
    }
    
    int32_t Console::get_CursorLeft() {
        return ConsoleDriver::get_CursorLeft();
    }
    
    int32_t Console::set_CursorLeft(int32_t value) {
        ConsoleDriver::set_CursorLeft(value);
        return get_CursorLeft();
    }
    
    int32_t Console::get_CursorTop() {
        return ConsoleDriver::get_CursorTop();
    }
    
    int32_t Console::set_CursorTop(int32_t value) {
        ConsoleDriver::set_CursorTop(value);
        return get_CursorTop();
    }
    
    int32_t Console::get_CursorSize() {
        return ConsoleDriver::get_CursorSize();
    }
    
    int32_t Console::set_CursorSize(int32_t value) {
        ConsoleDriver::set_CursorSize(value);
        return get_CursorSize();
    }
    
    bool Console::get_CursorVisible() {
        return ConsoleDriver::get_CursorVisible();
    }
    
    bool Console::set_CursorVisible(bool value) {
        ConsoleDriver::set_CursorVisible(value);
        return get_CursorVisible();
    }
    
    ConsoleColor Console::get_ForegroundColor() {
        return ConsoleDriver::get_ForegroundColor();
    }
    
    ConsoleColor Console::set_ForegroundColor(ConsoleColor value) {
        ConsoleDriver::set_ForegroundColor(value);
        return get_ForegroundColor();
    }
    
    bool Console::get_KeyAvailable() {
        return ConsoleDriver::get_KeyAvailable();
    }
    
    int32_t Console::get_LargestWindowHeight() {
        return ConsoleDriver::get_LargestWindowHeight();
    }
    
    int32_t Console::get_LargestWindowWidth() {
        return ConsoleDriver::get_LargestWindowWidth();
    }
    
    bool Console::get_NumberLock() {
        return ConsoleDriver::get_NumberLock();
    }
    
    String* Console::get_Title() {
        return ConsoleDriver::get_Title();
    }
    
    String* Console::set_Title(String* value) {
        ConsoleDriver::set_Title(value);
        return get_Title();
    }
    
    bool Console::get_TreatControlCAsInput() {
        return ConsoleDriver::get_TreatControlCAsInput();
    }
    
    bool Console::set_TreatControlCAsInput(bool value) {
        ConsoleDriver::set_TreatControlCAsInput(value);
        return get_TreatControlCAsInput();
    }
    
    int32_t Console::get_WindowHeight() {
        return ConsoleDriver::get_WindowHeight();
    }
    
    int32_t Console::set_WindowHeight(int32_t value) {
        ConsoleDriver::set_WindowHeight(value);
        return get_WindowHeight();
    }
    
    int32_t Console::get_WindowLeft() {
        return ConsoleDriver::get_WindowLeft();
    }
    
    int32_t Console::set_WindowLeft(int32_t value) {
        ConsoleDriver::set_WindowLeft(value);
        return get_WindowLeft();
    }
    
    int32_t Console::get_WindowTop() {
        return ConsoleDriver::get_WindowTop();
    }
    
    int32_t Console::set_WindowTop(int32_t value) {
        ConsoleDriver::set_WindowTop(value);
        return get_WindowTop();
    }
    
    int32_t Console::get_WindowWidth() {
        return ConsoleDriver::get_WindowWidth();
    }
    
    int32_t Console::set_WindowWidth(int32_t value) {
        ConsoleDriver::set_WindowWidth(value);
        return get_WindowWidth();
    }
    
    void Console::add_CancelKeyPress(ConsoleCancelEventHandler* value) {
        if((ConsoleDriver::get_Initialized() ==  false)) 
        {
            ConsoleDriver::Init();
        }
        (cancel_event = cli::cast<ConsoleCancelEventHandler*>(Delegate::Combine(cancel_event, value)));
        if((Environment::get_IsRunningOnWindows() && !(WindowsConsole::ctrlHandlerAdded))) 
        {
            WindowsConsole::AddCtrlHandler();
        }
    }
    
    void Console::remove_CancelKeyPress(ConsoleCancelEventHandler* value) {
        if((ConsoleDriver::get_Initialized() ==  false)) 
        {
            ConsoleDriver::Init();
        }
        (cancel_event = cli::cast<ConsoleCancelEventHandler*>(Delegate::Remove(cancel_event, value)));
        if(((cancel_event ==  nullptr) && Environment::get_IsRunningOnWindows())) 
        {
            if(WindowsConsole::ctrlHandlerAdded) 
            {
                WindowsConsole::RemoveCtrlHandler();
            }
        }
    }
    
}
namespace System {
    
    
    void ConsoleCancelEventArgs::constructor(ConsoleSpecialKey key) {
        this->specialKey = key;
    }
    
    bool ConsoleCancelEventArgs::get_Cancel() {
        return this->cancel;
    }
    
    bool ConsoleCancelEventArgs::set_Cancel(bool value) {
        this->cancel = value;
        return get_Cancel();
    }
    
    ConsoleSpecialKey ConsoleCancelEventArgs::get_SpecialKey() {
        return this->specialKey;
    }
    
}
namespace System {
    
    IConsoleDriver*  ConsoleDriver::driver;
    bool  ConsoleDriver::is_console;
    bool  ConsoleDriver::called_isatty;
    
    ConsoleDriver::ConsoleDriver()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void ConsoleDriver::static_constructor() {
        if(!(ConsoleDriver::get_IsConsole())) 
        {
            driver = CreateNullConsoleDriver();
        }
         else 
        {
            if(Environment::get_IsRunningOnWindows()) 
            {
                driver = CreateWindowsConsoleDriver();
            }
             else 
            {
                String *term = Environment::GetEnvironmentVariable(_T("TERM"));
                if(String::op_Equality(term, _T("dumb"))) 
                {
                    is_console = false;
                    driver = CreateNullConsoleDriver();
                }
                 else 
                {
                    driver = CreateTermInfoDriver(term);
                }
            }
        }
    }
    
    IConsoleDriver* ConsoleDriver::CreateNullConsoleDriver() {
        return cli::gcnew<NullConsoleDriver>();
    }
    
    IConsoleDriver* ConsoleDriver::CreateWindowsConsoleDriver() {
        return cli::gcnew<WindowsConsoleDriver>();
    }
    
    IConsoleDriver* ConsoleDriver::CreateTermInfoDriver(String* term) {
        return cli::gcnew<TermInfoDriver>(term);
    }
    
    void ConsoleDriver::Beep(int32_t frequency, int32_t duration) {
        driver->Beep_1da4596cc175b056(frequency, duration);
    }
    
    void ConsoleDriver::Clear() {
        driver->Clear_f1b4f6af283cc2c9();
    }
    
    void ConsoleDriver::MoveBufferArea(int32_t sourceLeft, int32_t sourceTop, int32_t sourceWidth, int32_t sourceHeight, int32_t targetLeft, int32_t targetTop) {
        MoveBufferArea2(sourceLeft, sourceTop, sourceWidth, sourceHeight, targetLeft, targetTop, u' ', ConsoleColor::Black, ConsoleColor::Black);
    }
    
    void ConsoleDriver::MoveBufferArea2(int32_t sourceLeft, int32_t sourceTop, int32_t sourceWidth, int32_t sourceHeight, int32_t targetLeft, int32_t targetTop, char16_t sourceChar, ConsoleColor sourceForeColor, ConsoleColor sourceBackColor) {
        driver->MoveBufferArea_5b90e28706eb2f21(sourceLeft, sourceTop, sourceWidth, sourceHeight, targetLeft, targetTop, sourceChar, sourceForeColor, sourceBackColor);
    }
    
    void ConsoleDriver::Init() {
        driver->Init_c5426ee2900a294b();
    }
    
    int32_t ConsoleDriver::Read() {
        return (int32_t)(ReadKey(false)->get_KeyChar());
    }
    
    String* ConsoleDriver::ReadLine() {
        return driver->ReadLine_d9726d4d34f7f3c0();
    }
    
    ConsoleKeyInfo ConsoleDriver::ReadKey(bool intercept) {
        return driver->ReadKey_6a3b7aab317c85ed(intercept);
    }
    
    void ConsoleDriver::ResetColor() {
        driver->ResetColor_8f6250a6a6d78789();
    }
    
    void ConsoleDriver::SetBufferSize(int32_t width, int32_t height) {
        driver->SetBufferSize_343d697c2e12d0db(width, height);
    }
    
    void ConsoleDriver::SetCursorPosition(int32_t left, int32_t top) {
        driver->SetCursorPosition_1b5796b8c190ffa5(left, top);
    }
    
    void ConsoleDriver::SetWindowPosition(int32_t left, int32_t top) {
        driver->SetWindowPosition_cd2b9c3f7be414da(left, top);
    }
    
    void ConsoleDriver::SetWindowSize(int32_t width, int32_t height) {
        driver->SetWindowSize_4cfb33f333b34cf(width, height);
    }
    
    bool ConsoleDriver::Isatty(void* handle) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t ConsoleDriver::InternalKeyAvailable(int32_t ms_timeout) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool ConsoleDriver::TtySetup(String* keypadXmit, String* teardown, cli::array<unsigned char>* control_characters, int32_t* address) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool ConsoleDriver::SetEcho(bool wantEcho) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool ConsoleDriver::SetBreak(bool wantBreak) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool ConsoleDriver::get_Initialized() {
        return driver->get_Initialized_317ffc50d17896d3();
    }
    
    ConsoleColor ConsoleDriver::get_BackgroundColor() {
        return driver->get_BackgroundColor_c9fafb327ddb8be6();
    }
    
    ConsoleColor ConsoleDriver::set_BackgroundColor(ConsoleColor value) {
        if((((int32_t)(value) < 0) || ((int32_t)(value) > 15))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("value"), _T("Not a ConsoleColor value."));
        }
        driver->set_BackgroundColor_344fac019c9386b1(value);
        return get_BackgroundColor();
    }
    
    int32_t ConsoleDriver::get_BufferHeight() {
        return driver->get_BufferHeight_37934843c5ad875e();
    }
    
    int32_t ConsoleDriver::set_BufferHeight(int32_t value) {
        driver->set_BufferHeight_5d535a7eaee8afa7(value);
        return get_BufferHeight();
    }
    
    int32_t ConsoleDriver::get_BufferWidth() {
        return driver->get_BufferWidth_4e39d049ce05cb10();
    }
    
    int32_t ConsoleDriver::set_BufferWidth(int32_t value) {
        driver->set_BufferWidth_ba768a1fb5af86f3(value);
        return get_BufferWidth();
    }
    
    bool ConsoleDriver::get_CapsLock() {
        return driver->get_CapsLock_5c626ee325707d5c();
    }
    
    int32_t ConsoleDriver::get_CursorLeft() {
        return driver->get_CursorLeft_a1045160a5e0c167();
    }
    
    int32_t ConsoleDriver::set_CursorLeft(int32_t value) {
        driver->set_CursorLeft_58812b936675567d(value);
        return get_CursorLeft();
    }
    
    int32_t ConsoleDriver::get_CursorSize() {
        return driver->get_CursorSize_c23bb8efe316d434();
    }
    
    int32_t ConsoleDriver::set_CursorSize(int32_t value) {
        driver->set_CursorSize_f0834eb8266a5be6(value);
        return get_CursorSize();
    }
    
    int32_t ConsoleDriver::get_CursorTop() {
        return driver->get_CursorTop_529e091e36331015();
    }
    
    int32_t ConsoleDriver::set_CursorTop(int32_t value) {
        driver->set_CursorTop_785544d75b1c0bee(value);
        return get_CursorTop();
    }
    
    bool ConsoleDriver::get_CursorVisible() {
        return driver->get_CursorVisible_56c3cc5601135b6f();
    }
    
    bool ConsoleDriver::set_CursorVisible(bool value) {
        driver->set_CursorVisible_cf1ec653cdd99e69(value);
        return get_CursorVisible();
    }
    
    bool ConsoleDriver::get_KeyAvailable() {
        return driver->get_KeyAvailable_484cd75e08a09869();
    }
    
    ConsoleColor ConsoleDriver::get_ForegroundColor() {
        return driver->get_ForegroundColor_7612ec7b8c8aaaa5();
    }
    
    ConsoleColor ConsoleDriver::set_ForegroundColor(ConsoleColor value) {
        if((((int32_t)(value) < 0) || ((int32_t)(value) > 15))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("value"), _T("Not a ConsoleColor value."));
        }
        driver->set_ForegroundColor_940cb65e8fef1858(value);
        return get_ForegroundColor();
    }
    
    int32_t ConsoleDriver::get_LargestWindowHeight() {
        return driver->get_LargestWindowHeight_e89fef87df5ea56d();
    }
    
    int32_t ConsoleDriver::get_LargestWindowWidth() {
        return driver->get_LargestWindowWidth_6d2cf275eb651738();
    }
    
    bool ConsoleDriver::get_NumberLock() {
        return driver->get_NumberLock_9e29453ae6b2f675();
    }
    
    String* ConsoleDriver::get_Title() {
        return driver->get_Title_297f109429139f1f();
    }
    
    String* ConsoleDriver::set_Title(String* value) {
        driver->set_Title_5ffd8093a2ce14e8(value);
        return get_Title();
    }
    
    bool ConsoleDriver::get_TreatControlCAsInput() {
        return driver->get_TreatControlCAsInput_724ae746e19a1372();
    }
    
    bool ConsoleDriver::set_TreatControlCAsInput(bool value) {
        driver->set_TreatControlCAsInput_22e3ed8b8ed195e4(value);
        return get_TreatControlCAsInput();
    }
    
    int32_t ConsoleDriver::get_WindowHeight() {
        return driver->get_WindowHeight_d105cfc0640e021b();
    }
    
    int32_t ConsoleDriver::set_WindowHeight(int32_t value) {
        driver->set_WindowHeight_762a4dd6c7316c83(value);
        return get_WindowHeight();
    }
    
    int32_t ConsoleDriver::get_WindowLeft() {
        return driver->get_WindowLeft_2e939ca75d6696f7();
    }
    
    int32_t ConsoleDriver::set_WindowLeft(int32_t value) {
        driver->set_WindowLeft_6b1bb1c980db7ca6(value);
        return get_WindowLeft();
    }
    
    int32_t ConsoleDriver::get_WindowTop() {
        return driver->get_WindowTop_869e53cfc4194ff6();
    }
    
    int32_t ConsoleDriver::set_WindowTop(int32_t value) {
        driver->set_WindowTop_6ed3579f04406446(value);
        return get_WindowTop();
    }
    
    int32_t ConsoleDriver::get_WindowWidth() {
        return driver->get_WindowWidth_aaf18af655c54aa3();
    }
    
    int32_t ConsoleDriver::set_WindowWidth(int32_t value) {
        driver->set_WindowWidth_34776e6c3b72e222(value);
        return get_WindowWidth();
    }
    
    bool ConsoleDriver::get_IsErrorRedirected() {
        return !(Isatty(IO::MonoIO::get_ConsoleError()));
    }
    
    bool ConsoleDriver::get_IsOutputRedirected() {
        return !(Isatty(IO::MonoIO::get_ConsoleOutput()));
    }
    
    bool ConsoleDriver::get_IsInputRedirected() {
        return !(Isatty(IO::MonoIO::get_ConsoleInput()));
    }
    
    bool ConsoleDriver::get_IsConsole() {
        if(called_isatty) 
        {
            return is_console;
        }
        is_console = (Isatty(IO::MonoIO::get_ConsoleOutput()) && Isatty(IO::MonoIO::get_ConsoleInput()));
        called_isatty = true;
        return is_console;
    }
    
}
namespace System {
    
    
    void ContextBoundObject::constructor() {
    }
    
}
namespace System {
    
    
    void ContextMarshalException::constructor() {
        this->set_HResult(-2146233084);
    }
    
    void ContextMarshalException::constructor(String* message) {
        this->set_HResult(-2146233084);
    }
    
    void ContextMarshalException::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
    }
    
    void ContextMarshalException::constructor(String* message, Exception* inner) {
        this->set_HResult(-2146233084);
    }
    
}
namespace System {
    
    
    void ContextStaticAttribute::constructor() {
    }
    
}
namespace System {
    
    
    void ControlCharacters::constructor() {
    }
    
}
namespace System {
    
    Object*  Convert::DBNull2;
    cli::array<Type*>*  Convert::conversionTable;
    
    Convert::Convert()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void Convert::static_constructor() {
    }
    
    cli::array<unsigned char>* Convert::InternalFromBase64String(String* str, bool allowWhitespaceOnly) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    cli::array<unsigned char>* Convert::InternalFromBase64CharArray(cli::array<char16_t>* arr, int32_t offset, int32_t length) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    cli::array<unsigned char>* Convert::FromBase64CharArray(cli::array<char16_t>* inArray, int32_t offset, int32_t length) {
        if((inArray ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("inArray"));
        }
        if((offset < 0)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("offset < 0"));
        }
        if((length < 0)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("length < 0"));
        }
        if((offset > (inArray->get_Length() - length))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("offset + length > array.Length"));
        }
        return InternalFromBase64CharArray(inArray, offset, length);
    }
    
    cli::array<unsigned char>* Convert::FromBase64String(String* s) {
        if((s ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("s"));
        }
        if((s->get_Length() ==  0)) 
        {
            return (new cli::array<unsigned char>(0));
        }
        return InternalFromBase64String(s, true);
    }
    
    TypeCode Convert::GetTypeCode(Object* value) {
        if((value ==  nullptr)) 
        {
            return TypeCode::Empty;
        }
         else 
        {
            return Type::GetTypeCode(value->GetType());
        }
    }
    
    bool Convert::IsDBNull(Object* value) {
        if(cli::is<DBNull>(value)) 
        {
            return true;
        }
         else 
        {
            return false;
        }
    }
    
    int32_t Convert::ToBase64CharArray(cli::array<unsigned char>* inArray, int32_t offsetIn, int32_t length, cli::array<char16_t>* outArray, int32_t offsetOut) {
        if((inArray ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("inArray"));
        }
        if((outArray ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("outArray"));
        }
        if((((offsetIn < 0) || (length < 0)) || (offsetOut < 0))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("offsetIn, length, offsetOut < 0"));
        }
        if((offsetIn > (inArray->get_Length() - length))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("offsetIn + length > array.Length"));
        }
        cli::array<unsigned char> *outArr = Security::Cryptography::ToBase64Transform::InternalTransformFinalBlock(inArray, offsetIn, length);
        cli::array<char16_t> *cOutArr = cli::gcnew<Text::ASCIIEncoding>()->GetChars_7bd8879fade07d8e(outArr);
        if((offsetOut > (outArray->get_Length() - cOutArr->get_Length()))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("offsetOut + cOutArr.Length > outArray.Length"));
        }
        Array::Copy2(cOutArr, 0, outArray, offsetOut, cOutArr->get_Length());
        return cOutArr->get_Length();
    }
    
    String* Convert::ToBase64String(cli::array<unsigned char>* inArray) {
        if((inArray ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("inArray"));
        }
        return ToBase64String2(inArray, 0, inArray->get_Length());
    }
    
    String* Convert::ToBase64String2(cli::array<unsigned char>* inArray, int32_t offset, int32_t length) {
        if((inArray ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("inArray"));
        }
        if(((offset < 0) || (length < 0))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("offset < 0 || length < 0"));
        }
        if((offset > (inArray->get_Length() - length))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("offset + length > array.Length"));
        }
        cli::array<unsigned char> *outArr = Security::Cryptography::ToBase64Transform::InternalTransformFinalBlock(inArray, offset, length);
        return cli::gcnew<Text::ASCIIEncoding>()->GetString_12d22365648431d7(outArr);
    }
    
    String* Convert::ToBase64String3(cli::array<unsigned char>* inArray, Base64FormattingOptions options) {
        if((inArray ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("inArray"));
        }
        return ToBase64String4(inArray, 0, inArray->get_Length(), options);
    }
    
    String* Convert::ToBase64String4(cli::array<unsigned char>* inArray, int32_t offset, int32_t length, Base64FormattingOptions options) {
        if((inArray ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("inArray"));
        }
        if(((offset < 0) || (length < 0))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("offset < 0 || length < 0"));
        }
        if((offset > (inArray->get_Length() - length))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("offset + length > array.Length"));
        }
        if((length ==  0)) 
        {
            return String::Empty;
        }
        if(((int32_t)(options) ==  1)) 
        {
            return ToBase64StringBuilderWithLine(inArray, offset, length)->ToString_1636a0751cb9ac11();
        }
         else 
        {
            return Text::Encoding::get_ASCII()->GetString_12d22365648431d7(Security::Cryptography::ToBase64Transform::InternalTransformFinalBlock(inArray, offset, length));
        }
    }
    
    int32_t Convert::ToBase64CharArray2(cli::array<unsigned char>* inArray, int32_t offsetIn, int32_t length, cli::array<char16_t>* outArray, int32_t offsetOut, Base64FormattingOptions options) {
        if((inArray ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("inArray"));
        }
        if((outArray ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("outArray"));
        }
        if((((offsetIn < 0) || (length < 0)) || (offsetOut < 0))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("offsetIn, length, offsetOut < 0"));
        }
        if((offsetIn > (inArray->get_Length() - length))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("offsetIn + length > array.Length"));
        }
        if((length ==  0)) 
        {
            return 0;
        }
        if(((int32_t)(options) ==  1)) 
        {
            Text::StringBuilder *sb = ToBase64StringBuilderWithLine(inArray, offsetIn, length);
            sb->CopyTo(0, outArray, offsetOut, sb->get_Length());
            return sb->get_Length();
        }
         else 
        {
            cli::array<unsigned char> *outArr = Security::Cryptography::ToBase64Transform::InternalTransformFinalBlock(inArray, offsetIn, length);
            cli::array<char16_t> *cOutArr = Text::Encoding::get_ASCII()->GetChars_7bd8879fade07d8e(outArr);
            if((offsetOut > (outArray->get_Length() - cOutArr->get_Length()))) 
            {
                throw cli::gcnew<ArgumentOutOfRangeException>(_T("offsetOut + cOutArr.Length > outArray.Length"));
            }
            Array::Copy2(cOutArr, 0, outArray, offsetOut, cOutArr->get_Length());
            return cOutArr->get_Length();
        }
    }
    
    Text::StringBuilder* Convert::ToBase64StringBuilderWithLine(cli::array<unsigned char>* inArray, int32_t offset, int32_t length) {
        Text::StringBuilder *sb = cli::gcnew<Text::StringBuilder>();
        int32_t remainder;
        int32_t full = Math::DivRem(length, 57, remainder);
        for(int32_t i = 0; (i < full); i++){
            cli::array<unsigned char> *data = Security::Cryptography::ToBase64Transform::InternalTransformFinalBlock(inArray, offset, 57);
            sb->AppendLine2(Text::Encoding::get_ASCII()->GetString_12d22365648431d7(data));
            (offset = offset + 57);
        }
        if((remainder ==  0)) 
        {
            int32_t nll = Environment::get_NewLine()->get_Length();
            sb->Remove((sb->get_Length() - nll), nll);
        }
         else 
        {
            cli::array<unsigned char> *data = Security::Cryptography::ToBase64Transform::InternalTransformFinalBlock(inArray, offset, remainder);
            sb->Append2(Text::Encoding::get_ASCII()->GetString_12d22365648431d7(data));
        }
        return sb;
    }
    
    bool Convert::ToBoolean(bool value) {
        return value;
    }
    
    bool Convert::ToBoolean2(unsigned char value) {
        return ((int32_t)(value) != 0);
    }
    
    bool Convert::ToBoolean3(char16_t value) {
        throw cli::gcnew<InvalidCastException>(Locale::GetText(_T("Can\'t convert char to bool")));
    }
    
    bool Convert::ToBoolean4(DateTime value) {
        throw cli::gcnew<InvalidCastException>(Locale::GetText(_T("Can\'t convert date to bool")));
    }
    
    bool Convert::ToBoolean5(Decimal value) {
        return Decimal::op_Inequality(value, cli::decimal<int>("0"));
    }
    
    bool Convert::ToBoolean6(double value) {
        return (value != std::numeric_limits<double>::epsilon());
    }
    
    bool Convert::ToBoolean7(float value) {
        return (value != std::numeric_limits<float>::epsilon());
    }
    
    bool Convert::ToBoolean8(int32_t value) {
        return (value != 0);
    }
    
    bool Convert::ToBoolean9(int64_t value) {
        return (value != 0L);
    }
    
    bool Convert::ToBoolean10(signed char value) {
        return ((int32_t)(value) != 0);
    }
    
    bool Convert::ToBoolean11(int16_t value) {
        return ((int32_t)(value) != 0);
    }
    
    bool Convert::ToBoolean12(String* value) {
        if((value ==  nullptr)) 
        {
            return false;
        }
        return Boolean::Parse(value);
    }
    
    bool Convert::ToBoolean13(String* value, IFormatProvider* provider) {
        if((value ==  nullptr)) 
        {
            return false;
        }
        return Boolean::Parse(value);
    }
    
    bool Convert::ToBoolean14(uint32_t value) {
        return (value != 0U);
    }
    
    bool Convert::ToBoolean15(uint64_t value) {
        return (value != 0UL);
    }
    
    bool Convert::ToBoolean16(uint16_t value) {
        return ((int32_t)(value) != 0);
    }
    
    bool Convert::ToBoolean17(Object* value) {
        if((value ==  nullptr)) 
        {
            return false;
        }
        return ToBoolean18(value, nullptr);
    }
    
    bool Convert::ToBoolean18(Object* value, IFormatProvider* provider) {
        if((value ==  nullptr)) 
        {
            return false;
        }
        return cli::cast<IConvertible*>(value)->ToBoolean_f2ed021e3648bfba(provider);
    }
    
    unsigned char Convert::ToByte(bool value) {
        return (unsigned char)value ? 1 : 0;
    }
    
    unsigned char Convert::ToByte2(unsigned char value) {
        return value;
    }
    
    unsigned char Convert::ToByte3(char16_t value) {
        return cli::checked((unsigned char)value);
    }
    
    unsigned char Convert::ToByte4(DateTime value) {
        throw cli::gcnew<InvalidCastException>(_T("This conversion is not supported."));
    }
    
    unsigned char Convert::ToByte5(Decimal value) {
        return cli::checked(Decimal::op_Explicit(Math::Round(value)));
    }
    
    unsigned char Convert::ToByte6(double value) {
        return cli::checked((unsigned char)Math::Round5(value));
    }
    
    unsigned char Convert::ToByte7(float value) {
        return cli::checked((unsigned char)Math::Round5((double)(value)));
    }
    
    unsigned char Convert::ToByte8(int32_t value) {
        return cli::checked((unsigned char)value);
    }
    
    unsigned char Convert::ToByte9(int64_t value) {
        return cli::checked((unsigned char)value);
    }
    
    unsigned char Convert::ToByte10(signed char value) {
        return cli::checked((unsigned char)value);
    }
    
    unsigned char Convert::ToByte11(int16_t value) {
        return cli::checked((unsigned char)value);
    }
    
    unsigned char Convert::ToByte12(String* value) {
        if((value ==  nullptr)) 
        {
            return 0;
        }
        return Byte::Parse4(value);
    }
    
    unsigned char Convert::ToByte13(String* value, IFormatProvider* provider) {
        if((value ==  nullptr)) 
        {
            return 0;
        }
        return Byte::Parse(value, provider);
    }
    
    unsigned char Convert::ToByte14(String* value, int32_t fromBase) {
        int32_t retVal = ConvertFromBase(value, fromBase, true);
        return cli::checked((unsigned char)retVal);
    }
    
    unsigned char Convert::ToByte15(uint32_t value) {
        return cli::checked((unsigned char)value);
    }
    
    unsigned char Convert::ToByte16(uint64_t value) {
        return cli::checked((unsigned char)value);
    }
    
    unsigned char Convert::ToByte17(uint16_t value) {
        return cli::checked((unsigned char)value);
    }
    
    unsigned char Convert::ToByte18(Object* value) {
        if((value ==  nullptr)) 
        {
            return 0;
        }
        return ToByte19(value, nullptr);
    }
    
    unsigned char Convert::ToByte19(Object* value, IFormatProvider* provider) {
        if((value ==  nullptr)) 
        {
            return 0;
        }
        return cli::cast<IConvertible*>(value)->ToByte_ce47dcc06c443b11(provider);
    }
    
    char16_t Convert::ToChar(bool value) {
        throw cli::gcnew<InvalidCastException>(_T("This conversion is not supported."));
    }
    
    char16_t Convert::ToChar2(unsigned char value) {
        return (char16_t)value;
    }
    
    char16_t Convert::ToChar3(char16_t value) {
        return value;
    }
    
    char16_t Convert::ToChar4(DateTime value) {
        throw cli::gcnew<InvalidCastException>(_T("This conversion is not supported."));
    }
    
    char16_t Convert::ToChar5(Decimal value) {
        throw cli::gcnew<InvalidCastException>(_T("This conversion is not supported."));
    }
    
    char16_t Convert::ToChar6(double value) {
        throw cli::gcnew<InvalidCastException>(_T("This conversion is not supported."));
    }
    
    char16_t Convert::ToChar7(int32_t value) {
        return cli::checked((char16_t)value);
    }
    
    char16_t Convert::ToChar8(int64_t value) {
        return cli::checked((char16_t)value);
    }
    
    char16_t Convert::ToChar9(float value) {
        throw cli::gcnew<InvalidCastException>(_T("This conversion is not supported."));
    }
    
    char16_t Convert::ToChar10(signed char value) {
        return cli::checked((char16_t)value);
    }
    
    char16_t Convert::ToChar11(int16_t value) {
        return cli::checked((char16_t)value);
    }
    
    char16_t Convert::ToChar12(String* value) {
        return Char::Parse(value);
    }
    
    char16_t Convert::ToChar13(String* value, IFormatProvider* provider) {
        return Char::Parse(value);
    }
    
    char16_t Convert::ToChar14(uint32_t value) {
        return cli::checked((char16_t)value);
    }
    
    char16_t Convert::ToChar15(uint64_t value) {
        return cli::checked((char16_t)value);
    }
    
    char16_t Convert::ToChar16(uint16_t value) {
        return (char16_t)value;
    }
    
    char16_t Convert::ToChar17(Object* value) {
        if((value ==  nullptr)) 
        {
            return u'\x0';
        }
        return ToChar18(value, nullptr);
    }
    
    char16_t Convert::ToChar18(Object* value, IFormatProvider* provider) {
        if((value ==  nullptr)) 
        {
            return u'\x0';
        }
        return cli::cast<IConvertible*>(value)->ToChar_12adc960e23347fe(provider);
    }
    
    DateTime Convert::ToDateTime(String* value) {
        if((value ==  nullptr)) 
        {
            return (*DateTime::MinValue);
        }
        return DateTime::Parse(value);
    }
    
    DateTime Convert::ToDateTime2(String* value, IFormatProvider* provider) {
        if((value ==  nullptr)) 
        {
            return (*DateTime::MinValue);
        }
        return DateTime::Parse2(value, provider);
    }
    
    DateTime Convert::ToDateTime3(bool value) {
        throw cli::gcnew<InvalidCastException>(_T("This conversion is not supported."));
    }
    
    DateTime Convert::ToDateTime4(unsigned char value) {
        throw cli::gcnew<InvalidCastException>(_T("This conversion is not supported."));
    }
    
    DateTime Convert::ToDateTime5(char16_t value) {
        throw cli::gcnew<InvalidCastException>(_T("This conversion is not supported."));
    }
    
    DateTime Convert::ToDateTime6(DateTime value) {
        return value;
    }
    
    DateTime Convert::ToDateTime7(Decimal value) {
        throw cli::gcnew<InvalidCastException>(_T("This conversion is not supported."));
    }
    
    DateTime Convert::ToDateTime8(double value) {
        throw cli::gcnew<InvalidCastException>(_T("This conversion is not supported."));
    }
    
    DateTime Convert::ToDateTime9(int16_t value) {
        throw cli::gcnew<InvalidCastException>(_T("This conversion is not supported."));
    }
    
    DateTime Convert::ToDateTime10(int32_t value) {
        throw cli::gcnew<InvalidCastException>(_T("This conversion is not supported."));
    }
    
    DateTime Convert::ToDateTime11(int64_t value) {
        throw cli::gcnew<InvalidCastException>(_T("This conversion is not supported."));
    }
    
    DateTime Convert::ToDateTime12(float value) {
        throw cli::gcnew<InvalidCastException>(_T("This conversion is not supported."));
    }
    
    DateTime Convert::ToDateTime13(Object* value) {
        if((value ==  nullptr)) 
        {
            return (*DateTime::MinValue);
        }
        return ToDateTime14(value, nullptr);
    }
    
    DateTime Convert::ToDateTime14(Object* value, IFormatProvider* provider) {
        if((value ==  nullptr)) 
        {
            return (*DateTime::MinValue);
        }
        return cli::cast<IConvertible*>(value)->ToDateTime_86b01e143a29eff2(provider);
    }
    
    DateTime Convert::ToDateTime15(signed char value) {
        throw cli::gcnew<InvalidCastException>(_T("This conversion is not supported."));
    }
    
    DateTime Convert::ToDateTime16(uint16_t value) {
        throw cli::gcnew<InvalidCastException>(_T("This conversion is not supported."));
    }
    
    DateTime Convert::ToDateTime17(uint32_t value) {
        throw cli::gcnew<InvalidCastException>(_T("This conversion is not supported."));
    }
    
    DateTime Convert::ToDateTime18(uint64_t value) {
        throw cli::gcnew<InvalidCastException>(_T("This conversion is not supported."));
    }
    
    Decimal Convert::ToDecimal(bool value) {
        return Decimal::op_Implicit6(value ? 1 : 0);
    }
    
    Decimal Convert::ToDecimal2(unsigned char value) {
        return Decimal::op_Implicit(value);
    }
    
    Decimal Convert::ToDecimal3(char16_t value) {
        throw cli::gcnew<InvalidCastException>(_T("This conversion is not supported."));
    }
    
    Decimal Convert::ToDecimal4(DateTime value) {
        throw cli::gcnew<InvalidCastException>(_T("This conversion is not supported."));
    }
    
    Decimal Convert::ToDecimal5(Decimal value) {
        return value;
    }
    
    Decimal Convert::ToDecimal6(double value) {
        return Decimal::op_Explicit11(value);
    }
    
    Decimal Convert::ToDecimal7(float value) {
        return Decimal::op_Explicit10(value);
    }
    
    Decimal Convert::ToDecimal8(int32_t value) {
        return Decimal::op_Implicit6(value);
    }
    
    Decimal Convert::ToDecimal9(int64_t value) {
        return Decimal::op_Implicit8(value);
    }
    
    Decimal Convert::ToDecimal10(signed char value) {
        return Decimal::op_Implicit2(value);
    }
    
    Decimal Convert::ToDecimal11(int16_t value) {
        return Decimal::op_Implicit3(value);
    }
    
    Decimal Convert::ToDecimal12(String* value) {
        if((value ==  nullptr)) 
        {
            return cli::ctor<Decimal>(0);
        }
        return Decimal::Parse(value);
    }
    
    Decimal Convert::ToDecimal13(String* value, IFormatProvider* provider) {
        if((value ==  nullptr)) 
        {
            return cli::ctor<Decimal>(0);
        }
        return Decimal::Parse3(value, provider);
    }
    
    Decimal Convert::ToDecimal14(uint32_t value) {
        return Decimal::op_Implicit7(value);
    }
    
    Decimal Convert::ToDecimal15(uint64_t value) {
        return Decimal::op_Implicit9(value);
    }
    
    Decimal Convert::ToDecimal16(uint16_t value) {
        return Decimal::op_Implicit4(value);
    }
    
    Decimal Convert::ToDecimal17(Object* value) {
        if((value ==  nullptr)) 
        {
            return cli::ctor<Decimal>(0);
        }
        return ToDecimal18(value, nullptr);
    }
    
    Decimal Convert::ToDecimal18(Object* value, IFormatProvider* provider) {
        if((value ==  nullptr)) 
        {
            return cli::ctor<Decimal>(0);
        }
        return cli::cast<IConvertible*>(value)->ToDecimal_9c02fd5cdb5f6a0c(provider);
    }
    
    double Convert::ToDouble(bool value) {
        return (double)(value ? 1 : 0);
    }
    
    double Convert::ToDouble2(unsigned char value) {
        return (double)(value);
    }
    
    double Convert::ToDouble3(char16_t value) {
        throw cli::gcnew<InvalidCastException>(_T("This conversion is not supported."));
    }
    
    double Convert::ToDouble4(DateTime value) {
        throw cli::gcnew<InvalidCastException>(_T("This conversion is not supported."));
    }
    
    double Convert::ToDouble5(Decimal value) {
        return Decimal::op_Explicit13(value);
    }
    
    double Convert::ToDouble6(double value) {
        return value;
    }
    
    double Convert::ToDouble7(float value) {
        return (double)(value);
    }
    
    double Convert::ToDouble8(int32_t value) {
        return (double)(value);
    }
    
    double Convert::ToDouble9(int64_t value) {
        return (double)(value);
    }
    
    double Convert::ToDouble10(signed char value) {
        return (double)(value);
    }
    
    double Convert::ToDouble11(int16_t value) {
        return (double)(value);
    }
    
    double Convert::ToDouble12(String* value) {
        if((value ==  nullptr)) 
        {
            return std::numeric_limits<double>::epsilon();
        }
        return Double::Parse(value);
    }
    
    double Convert::ToDouble13(String* value, IFormatProvider* provider) {
        if((value ==  nullptr)) 
        {
            return std::numeric_limits<double>::epsilon();
        }
        return Double::Parse2(value, provider);
    }
    
    double Convert::ToDouble14(uint32_t value) {
        return (double)(value);
    }
    
    double Convert::ToDouble15(uint64_t value) {
        return (double)(value);
    }
    
    double Convert::ToDouble16(uint16_t value) {
        return (double)(value);
    }
    
    double Convert::ToDouble17(Object* value) {
        if((value ==  nullptr)) 
        {
            return std::numeric_limits<double>::epsilon();
        }
        return ToDouble18(value, nullptr);
    }
    
    double Convert::ToDouble18(Object* value, IFormatProvider* provider) {
        if((value ==  nullptr)) 
        {
            return std::numeric_limits<double>::epsilon();
        }
        return cli::cast<IConvertible*>(value)->ToDouble_bf8714f37f489c82(provider);
    }
    
    int16_t Convert::ToInt16(bool value) {
        return (int16_t)value ? 1 : 0;
    }
    
    int16_t Convert::ToInt162(unsigned char value) {
        return (int16_t)(value);
    }
    
    int16_t Convert::ToInt163(char16_t value) {
        return cli::checked((int16_t)value);
    }
    
    int16_t Convert::ToInt164(DateTime value) {
        throw cli::gcnew<InvalidCastException>(_T("This conversion is not supported."));
    }
    
    int16_t Convert::ToInt165(Decimal value) {
        return cli::checked(Decimal::op_Explicit4(Math::Round(value)));
    }
    
    int16_t Convert::ToInt166(double value) {
        return cli::checked((int16_t)Math::Round5(value));
    }
    
    int16_t Convert::ToInt167(float value) {
        return cli::checked((int16_t)Math::Round5((double)(value)));
    }
    
    int16_t Convert::ToInt168(int32_t value) {
        return cli::checked((int16_t)value);
    }
    
    int16_t Convert::ToInt169(int64_t value) {
        return cli::checked((int16_t)value);
    }
    
    int16_t Convert::ToInt1610(signed char value) {
        return (int16_t)(value);
    }
    
    int16_t Convert::ToInt1611(int16_t value) {
        return value;
    }
    
    int16_t Convert::ToInt1612(String* value) {
        if((value ==  nullptr)) 
        {
            return 0;
        }
        return Int16::Parse5(value);
    }
    
    int16_t Convert::ToInt1613(String* value, IFormatProvider* provider) {
        if((value ==  nullptr)) 
        {
            return 0;
        }
        return Int16::Parse2(value, provider);
    }
    
    int16_t Convert::ToInt1614(String* value, int32_t fromBase) {
        int32_t result = ConvertFromBase(value, fromBase, false);
        if((fromBase != 10)) 
        {
            if((result > 65535)) 
            {
                throw cli::gcnew<OverflowException>(_T("Value was either too large or too small for an Int16."));
            }
            if((result > 32767)) 
            {
                return Convert::ToInt168(-((65536 - result)));
            }
        }
        return Convert::ToInt168(result);
    }
    
    int16_t Convert::ToInt1615(uint32_t value) {
        return cli::checked((int16_t)value);
    }
    
    int16_t Convert::ToInt1616(uint64_t value) {
        return cli::checked((int16_t)value);
    }
    
    int16_t Convert::ToInt1617(uint16_t value) {
        return cli::checked((int16_t)value);
    }
    
    int16_t Convert::ToInt1618(Object* value) {
        if((value ==  nullptr)) 
        {
            return 0;
        }
        return ToInt1619(value, nullptr);
    }
    
    int16_t Convert::ToInt1619(Object* value, IFormatProvider* provider) {
        if((value ==  nullptr)) 
        {
            return 0;
        }
        return cli::cast<IConvertible*>(value)->ToInt16_5e1de9bafa245bf2(provider);
    }
    
    int32_t Convert::ToInt32(bool value) {
        return value ? 1 : 0;
    }
    
    int32_t Convert::ToInt322(unsigned char value) {
        return (int32_t)(value);
    }
    
    int32_t Convert::ToInt323(char16_t value) {
        return (int32_t)(value);
    }
    
    int32_t Convert::ToInt324(DateTime value) {
        throw cli::gcnew<InvalidCastException>(_T("This conversion is not supported."));
    }
    
    int32_t Convert::ToInt325(Decimal value) {
        return cli::checked(Decimal::op_Explicit6(Math::Round(value)));
    }
    
    int32_t Convert::ToInt326(double value) {
        /*checked*/ {
            return (int32_t)Math::Round5(value);
        }
    }
    
    int32_t Convert::ToInt327(float value) {
        if(((value > 2.147484E+09f) || (value < std::numeric_limits<float>::epsilon()))) 
        {
            throw cli::gcnew<OverflowException>(Locale::GetText(_T("Value is greater than Int32.MaxValue or less than Int32.MinValue")));
        }
        /*checked*/ {
            return (int32_t)Math::Round5((double)(value));
        }
    }
    
    int32_t Convert::ToInt328(int32_t value) {
        return value;
    }
    
    int32_t Convert::ToInt329(int64_t value) {
        return cli::checked((int32_t)value);
    }
    
    int32_t Convert::ToInt3210(signed char value) {
        return (int32_t)(value);
    }
    
    int32_t Convert::ToInt3211(int16_t value) {
        return (int32_t)(value);
    }
    
    int32_t Convert::ToInt3212(String* value) {
        if((value ==  nullptr)) 
        {
            return 0;
        }
        return Int32::Parse5(value);
    }
    
    int32_t Convert::ToInt3213(String* value, IFormatProvider* provider) {
        if((value ==  nullptr)) 
        {
            return 0;
        }
        return Int32::Parse2(value, provider);
    }
    
    int32_t Convert::ToInt3214(String* value, int32_t fromBase) {
        return ConvertFromBase(value, fromBase, false);
    }
    
    int32_t Convert::ToInt3215(uint32_t value) {
        return cli::checked((int32_t)value);
    }
    
    int32_t Convert::ToInt3216(uint64_t value) {
        return cli::checked((int32_t)value);
    }
    
    int32_t Convert::ToInt3217(uint16_t value) {
        return (int32_t)(value);
    }
    
    int32_t Convert::ToInt3218(Object* value) {
        if((value ==  nullptr)) 
        {
            return 0;
        }
        return ToInt3219(value, nullptr);
    }
    
    int32_t Convert::ToInt3219(Object* value, IFormatProvider* provider) {
        if((value ==  nullptr)) 
        {
            return 0;
        }
        return cli::cast<IConvertible*>(value)->ToInt32_9e7108d4c09b7e42(provider);
    }
    
    int64_t Convert::ToInt64(bool value) {
        return (int64_t)(value ? 1 : 0);
    }
    
    int64_t Convert::ToInt642(unsigned char value) {
        return (int64_t)(uint64_t)(value);
    }
    
    int64_t Convert::ToInt643(char16_t value) {
        return (int64_t)(value);
    }
    
    int64_t Convert::ToInt644(DateTime value) {
        throw cli::gcnew<InvalidCastException>(_T("This conversion is not supported."));
    }
    
    int64_t Convert::ToInt645(Decimal value) {
        return cli::checked(Decimal::op_Explicit8(Math::Round(value)));
    }
    
    int64_t Convert::ToInt646(double value) {
        return cli::checked((int64_t)Math::Round5(value));
    }
    
    int64_t Convert::ToInt647(float value) {
        return cli::checked((int64_t)Math::Round5((double)(value)));
    }
    
    int64_t Convert::ToInt648(int32_t value) {
        return (int64_t)(value);
    }
    
    int64_t Convert::ToInt649(int64_t value) {
        return value;
    }
    
    int64_t Convert::ToInt6410(signed char value) {
        return (int64_t)(value);
    }
    
    int64_t Convert::ToInt6411(int16_t value) {
        return (int64_t)(value);
    }
    
    int64_t Convert::ToInt6412(String* value) {
        if((value ==  nullptr)) 
        {
            return 0L;
        }
        return Int64::Parse5(value);
    }
    
    int64_t Convert::ToInt6413(String* value, IFormatProvider* provider) {
        if((value ==  nullptr)) 
        {
            return 0L;
        }
        return Int64::Parse2(value, provider);
    }
    
    int64_t Convert::ToInt6414(String* value, int32_t fromBase) {
        return ConvertFromBase64(value, fromBase, false);
    }
    
    int64_t Convert::ToInt6415(uint32_t value) {
        return (int64_t)(uint64_t)(value);
    }
    
    int64_t Convert::ToInt6416(uint64_t value) {
        return cli::checked((int64_t)value);
    }
    
    int64_t Convert::ToInt6417(uint16_t value) {
        return (int64_t)(uint64_t)(value);
    }
    
    int64_t Convert::ToInt6418(Object* value) {
        if((value ==  nullptr)) 
        {
            return 0L;
        }
        return ToInt6419(value, nullptr);
    }
    
    int64_t Convert::ToInt6419(Object* value, IFormatProvider* provider) {
        if((value ==  nullptr)) 
        {
            return 0L;
        }
        return cli::cast<IConvertible*>(value)->ToInt64_9801f9765e5301f6(provider);
    }
    
    signed char Convert::ToSByte(bool value) {
        return (signed char)value ? 1 : 0;
    }
    
    signed char Convert::ToSByte2(unsigned char value) {
        return cli::checked((signed char)value);
    }
    
    signed char Convert::ToSByte3(char16_t value) {
        return cli::checked((signed char)value);
    }
    
    signed char Convert::ToSByte4(DateTime value) {
        throw cli::gcnew<InvalidCastException>(_T("This conversion is not supported."));
    }
    
    signed char Convert::ToSByte5(Decimal value) {
        return cli::checked(Decimal::op_Explicit2(Math::Round(value)));
    }
    
    signed char Convert::ToSByte6(double value) {
        return cli::checked((signed char)Math::Round5(value));
    }
    
    signed char Convert::ToSByte7(float value) {
        return cli::checked((signed char)Math::Round5((double)(value)));
    }
    
    signed char Convert::ToSByte8(int32_t value) {
        return cli::checked((signed char)value);
    }
    
    signed char Convert::ToSByte9(int64_t value) {
        return cli::checked((signed char)value);
    }
    
    signed char Convert::ToSByte10(signed char value) {
        return value;
    }
    
    signed char Convert::ToSByte11(int16_t value) {
        return cli::checked((signed char)value);
    }
    
    signed char Convert::ToSByte12(String* value) {
        if((value ==  nullptr)) 
        {
            return 0;
        }
        return SByte::Parse5(value);
    }
    
    signed char Convert::ToSByte13(String* value, IFormatProvider* provider) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("value"));
        }
        return SByte::Parse2(value, provider);
    }
    
    signed char Convert::ToSByte14(String* value, int32_t fromBase) {
        int32_t result = ConvertFromBase(value, fromBase, false);
        if((fromBase != 10)) 
        {
            if((result > 127)) 
            {
                return Convert::ToSByte8(-((256 - result)));
            }
        }
        return Convert::ToSByte8(result);
    }
    
    signed char Convert::ToSByte15(uint32_t value) {
        return cli::checked((signed char)value);
    }
    
    signed char Convert::ToSByte16(uint64_t value) {
        return cli::checked((signed char)value);
    }
    
    signed char Convert::ToSByte17(uint16_t value) {
        return cli::checked((signed char)value);
    }
    
    signed char Convert::ToSByte18(Object* value) {
        if((value ==  nullptr)) 
        {
            return 0;
        }
        return ToSByte19(value, nullptr);
    }
    
    signed char Convert::ToSByte19(Object* value, IFormatProvider* provider) {
        if((value ==  nullptr)) 
        {
            return 0;
        }
        return cli::cast<IConvertible*>(value)->ToSByte_e1f09487d48936db(provider);
    }
    
    float Convert::ToSingle(bool value) {
        return (float)(value ? 1 : 0);
    }
    
    float Convert::ToSingle2(unsigned char value) {
        return (float)(value);
    }
    
    float Convert::ToSingle3(char16_t value) {
        throw cli::gcnew<InvalidCastException>(_T("This conversion is not supported."));
    }
    
    float Convert::ToSingle4(DateTime value) {
        throw cli::gcnew<InvalidCastException>(_T("This conversion is not supported."));
    }
    
    float Convert::ToSingle5(Decimal value) {
        return Decimal::op_Explicit12(value);
    }
    
    float Convert::ToSingle6(double value) {
        return (float)value;
    }
    
    float Convert::ToSingle7(float value) {
        return value;
    }
    
    float Convert::ToSingle8(int32_t value) {
        return (float)(value);
    }
    
    float Convert::ToSingle9(int64_t value) {
        return (float)(value);
    }
    
    float Convert::ToSingle10(signed char value) {
        return (float)(value);
    }
    
    float Convert::ToSingle11(int16_t value) {
        return (float)(value);
    }
    
    float Convert::ToSingle12(String* value) {
        if((value ==  nullptr)) 
        {
            return std::numeric_limits<float>::epsilon();
        }
        return Single::Parse(value);
    }
    
    float Convert::ToSingle13(String* value, IFormatProvider* provider) {
        if((value ==  nullptr)) 
        {
            return std::numeric_limits<float>::epsilon();
        }
        return Single::Parse2(value, provider);
    }
    
    float Convert::ToSingle14(uint32_t value) {
        return (float)(value);
    }
    
    float Convert::ToSingle15(uint64_t value) {
        return (float)(value);
    }
    
    float Convert::ToSingle16(uint16_t value) {
        return (float)(value);
    }
    
    float Convert::ToSingle17(Object* value) {
        if((value ==  nullptr)) 
        {
            return std::numeric_limits<float>::epsilon();
        }
        return ToSingle18(value, nullptr);
    }
    
    float Convert::ToSingle18(Object* value, IFormatProvider* provider) {
        if((value ==  nullptr)) 
        {
            return std::numeric_limits<float>::epsilon();
        }
        return cli::cast<IConvertible*>(value)->ToSingle_1cfd1ce472f9fad6(provider);
    }
    
    String* Convert::ToString2(bool value) {
        return cli::import(value)->ToString_1636a0751cb9ac11();
    }
    
    String* Convert::ToString3(bool value, IFormatProvider* provider) {
        return cli::import(value)->ToString_1636a0751cb9ac11();
    }
    
    String* Convert::ToString4(unsigned char value) {
        return cli::import(value)->ToString_1636a0751cb9ac11();
    }
    
    String* Convert::ToString5(unsigned char value, IFormatProvider* provider) {
        return cli::import(value)->ToString4(provider);
    }
    
    String* Convert::ToString6(unsigned char value, int32_t toBase) {
        if(((int32_t)(value) ==  0)) 
        {
            return _T("0");
        }
        if((toBase ==  10)) 
        {
            return cli::import(value)->ToString_1636a0751cb9ac11();
        }
        cli::array<unsigned char> *val = BitConverter::GetBytes4((int16_t)(value));
        switch(toBase) {
            case 2: case_570: {
                return ConvertToBase2(val);
            }
            case 8: case_571: {
                return ConvertToBase8(val);
            }
            case 16: case_572: {
                return ConvertToBase16(val);
            }
            default: case_573: {
                throw cli::gcnew<ArgumentException>(Locale::GetText(_T("toBase is not valid.")));
            }
        }
    }
    
    String* Convert::ToString7(char16_t value) {
        return cli::import(value)->ToString_1636a0751cb9ac11();
    }
    
    String* Convert::ToString8(char16_t value, IFormatProvider* provider) {
        return cli::import(value)->ToString_1636a0751cb9ac11();
    }
    
    String* Convert::ToString9(DateTime value) {
        return value->ToString_1636a0751cb9ac11();
    }
    
    String* Convert::ToString10(DateTime value, IFormatProvider* provider) {
        return value->ToString3(provider);
    }
    
    String* Convert::ToString11(Decimal value) {
        return value->ToString_1636a0751cb9ac11();
    }
    
    String* Convert::ToString12(Decimal value, IFormatProvider* provider) {
        return value->ToString5(provider);
    }
    
    String* Convert::ToString13(double value) {
        return cli::import(value)->ToString_1636a0751cb9ac11();
    }
    
    String* Convert::ToString14(double value, IFormatProvider* provider) {
        return cli::import(value)->ToString3(provider);
    }
    
    String* Convert::ToString15(float value) {
        return cli::import(value)->ToString_1636a0751cb9ac11();
    }
    
    String* Convert::ToString16(float value, IFormatProvider* provider) {
        return cli::import(value)->ToString3(provider);
    }
    
    String* Convert::ToString17(int32_t value) {
        return cli::import(value)->ToString_1636a0751cb9ac11();
    }
    
    String* Convert::ToString18(int32_t value, int32_t toBase) {
        if((value ==  0)) 
        {
            return _T("0");
        }
        if((toBase ==  10)) 
        {
            return cli::import(value)->ToString_1636a0751cb9ac11();
        }
        cli::array<unsigned char> *val = BitConverter::GetBytes5(value);
        switch(toBase) {
            case 2: case_574: {
                return ConvertToBase2(val);
            }
            case 8: case_575: {
                return ConvertToBase8(val);
            }
            case 16: case_576: {
                return ConvertToBase16(val);
            }
            default: case_577: {
                throw cli::gcnew<ArgumentException>(Locale::GetText(_T("toBase is not valid.")));
            }
        }
    }
    
    String* Convert::ToString19(int32_t value, IFormatProvider* provider) {
        return cli::import(value)->ToString3(provider);
    }
    
    String* Convert::ToString20(int64_t value) {
        return cli::import(value)->ToString_1636a0751cb9ac11();
    }
    
    String* Convert::ToString21(int64_t value, int32_t toBase) {
        if((value ==  0L)) 
        {
            return _T("0");
        }
        if((toBase ==  10)) 
        {
            return cli::import(value)->ToString_1636a0751cb9ac11();
        }
        cli::array<unsigned char> *val = BitConverter::GetBytes6(value);
        switch(toBase) {
            case 2: case_578: {
                return ConvertToBase2(val);
            }
            case 8: case_579: {
                return ConvertToBase8(val);
            }
            case 16: case_580: {
                return ConvertToBase16(val);
            }
            default: case_581: {
                throw cli::gcnew<ArgumentException>(Locale::GetText(_T("toBase is not valid.")));
            }
        }
    }
    
    String* Convert::ToString22(int64_t value, IFormatProvider* provider) {
        return cli::import(value)->ToString3(provider);
    }
    
    String* Convert::ToString23(Object* value) {
        return ToString24(value, nullptr);
    }
    
    String* Convert::ToString24(Object* value, IFormatProvider* provider) {
        if(cli::is<IConvertible>(value)) 
        {
            return cli::cast<IConvertible*>(value)->ToString_f121fe9e066b5628(provider);
        }
         else 
        {
            if((value != nullptr)) 
            {
                return value->ToString_1636a0751cb9ac11();
            }
        }
        return String::Empty;
    }
    
    String* Convert::ToString25(signed char value) {
        return cli::import(value)->ToString_1636a0751cb9ac11();
    }
    
    String* Convert::ToString26(signed char value, IFormatProvider* provider) {
        return cli::import(value)->ToString3(provider);
    }
    
    String* Convert::ToString27(int16_t value) {
        return cli::import(value)->ToString_1636a0751cb9ac11();
    }
    
    String* Convert::ToString28(int16_t value, int32_t toBase) {
        if(((int32_t)(value) ==  0)) 
        {
            return _T("0");
        }
        if((toBase ==  10)) 
        {
            return cli::import(value)->ToString_1636a0751cb9ac11();
        }
        cli::array<unsigned char> *val = BitConverter::GetBytes4(value);
        switch(toBase) {
            case 2: case_582: {
                return ConvertToBase2(val);
            }
            case 8: case_583: {
                return ConvertToBase8(val);
            }
            case 16: case_584: {
                return ConvertToBase16(val);
            }
            default: case_585: {
                throw cli::gcnew<ArgumentException>(Locale::GetText(_T("toBase is not valid.")));
            }
        }
    }
    
    String* Convert::ToString29(int16_t value, IFormatProvider* provider) {
        return cli::import(value)->ToString3(provider);
    }
    
    String* Convert::ToString30(String* value) {
        return value;
    }
    
    String* Convert::ToString31(String* value, IFormatProvider* provider) {
        return value;
    }
    
    String* Convert::ToString32(uint32_t value) {
        return cli::import(value)->ToString_1636a0751cb9ac11();
    }
    
    String* Convert::ToString33(uint32_t value, IFormatProvider* provider) {
        return cli::import(value)->ToString3(provider);
    }
    
    String* Convert::ToString34(uint64_t value) {
        return cli::import(value)->ToString_1636a0751cb9ac11();
    }
    
    String* Convert::ToString35(uint64_t value, IFormatProvider* provider) {
        return cli::import(value)->ToString3(provider);
    }
    
    String* Convert::ToString36(uint16_t value) {
        return cli::import(value)->ToString_1636a0751cb9ac11();
    }
    
    String* Convert::ToString37(uint16_t value, IFormatProvider* provider) {
        return cli::import(value)->ToString3(provider);
    }
    
    uint16_t Convert::ToUInt16(bool value) {
        return (uint16_t)value ? 1 : 0;
    }
    
    uint16_t Convert::ToUInt162(unsigned char value) {
        return (uint16_t)(value);
    }
    
    uint16_t Convert::ToUInt163(char16_t value) {
        return (uint16_t)(value);
    }
    
    uint16_t Convert::ToUInt164(DateTime value) {
        throw cli::gcnew<InvalidCastException>(_T("This conversion is not supported."));
    }
    
    uint16_t Convert::ToUInt165(Decimal value) {
        return cli::checked(Decimal::op_Explicit5(Math::Round(value)));
    }
    
    uint16_t Convert::ToUInt166(double value) {
        return cli::checked((uint16_t)Math::Round5(value));
    }
    
    uint16_t Convert::ToUInt167(float value) {
        return cli::checked((uint16_t)Math::Round5((double)(value)));
    }
    
    uint16_t Convert::ToUInt168(int32_t value) {
        return cli::checked((uint16_t)value);
    }
    
    uint16_t Convert::ToUInt169(int64_t value) {
        return cli::checked((uint16_t)value);
    }
    
    uint16_t Convert::ToUInt1610(signed char value) {
        return cli::checked((uint16_t)value);
    }
    
    uint16_t Convert::ToUInt1611(int16_t value) {
        return cli::checked((uint16_t)value);
    }
    
    uint16_t Convert::ToUInt1612(String* value) {
        if((value ==  nullptr)) 
        {
            return 0;
        }
        return UInt16::Parse4(value);
    }
    
    uint16_t Convert::ToUInt1613(String* value, IFormatProvider* provider) {
        if((value ==  nullptr)) 
        {
            return 0;
        }
        return UInt16::Parse(value, provider);
    }
    
    uint16_t Convert::ToUInt1614(String* value, int32_t fromBase) {
        return ToUInt168(ConvertFromBase(value, fromBase, true));
    }
    
    uint16_t Convert::ToUInt1615(uint32_t value) {
        return cli::checked((uint16_t)value);
    }
    
    uint16_t Convert::ToUInt1616(uint64_t value) {
        return cli::checked((uint16_t)value);
    }
    
    uint16_t Convert::ToUInt1617(uint16_t value) {
        return value;
    }
    
    uint16_t Convert::ToUInt1618(Object* value) {
        if((value ==  nullptr)) 
        {
            return 0;
        }
        return ToUInt1619(value, nullptr);
    }
    
    uint16_t Convert::ToUInt1619(Object* value, IFormatProvider* provider) {
        if((value ==  nullptr)) 
        {
            return 0;
        }
        return cli::cast<IConvertible*>(value)->ToUInt16_1e02ae7e2827241a(provider);
    }
    
    uint32_t Convert::ToUInt32(bool value) {
        return (uint32_t)value ? 1 : 0;
    }
    
    uint32_t Convert::ToUInt322(unsigned char value) {
        return (uint32_t)(value);
    }
    
    uint32_t Convert::ToUInt323(char16_t value) {
        return (uint32_t)(value);
    }
    
    uint32_t Convert::ToUInt324(DateTime value) {
        throw cli::gcnew<InvalidCastException>(_T("This conversion is not supported."));
    }
    
    uint32_t Convert::ToUInt325(Decimal value) {
        return cli::checked(Decimal::op_Explicit7(Math::Round(value)));
    }
    
    uint32_t Convert::ToUInt326(double value) {
        return cli::checked((uint32_t)Math::Round5(value));
    }
    
    uint32_t Convert::ToUInt327(float value) {
        return cli::checked((uint32_t)Math::Round5((double)(value)));
    }
    
    uint32_t Convert::ToUInt328(int32_t value) {
        return cli::checked((uint32_t)value);
    }
    
    uint32_t Convert::ToUInt329(int64_t value) {
        return cli::checked((uint32_t)value);
    }
    
    uint32_t Convert::ToUInt3210(signed char value) {
        return cli::checked((uint32_t)value);
    }
    
    uint32_t Convert::ToUInt3211(int16_t value) {
        return cli::checked((uint32_t)value);
    }
    
    uint32_t Convert::ToUInt3212(String* value) {
        if((value ==  nullptr)) 
        {
            return 0U;
        }
        return UInt32::Parse3(value);
    }
    
    uint32_t Convert::ToUInt3213(String* value, IFormatProvider* provider) {
        if((value ==  nullptr)) 
        {
            return 0U;
        }
        return UInt32::Parse5(value, provider);
    }
    
    uint32_t Convert::ToUInt3214(String* value, int32_t fromBase) {
        return (uint32_t)ConvertFromBase(value, fromBase, true);
    }
    
    uint32_t Convert::ToUInt3215(uint32_t value) {
        return value;
    }
    
    uint32_t Convert::ToUInt3216(uint64_t value) {
        return cli::checked((uint32_t)value);
    }
    
    uint32_t Convert::ToUInt3217(uint16_t value) {
        return (uint32_t)(value);
    }
    
    uint32_t Convert::ToUInt3218(Object* value) {
        if((value ==  nullptr)) 
        {
            return 0U;
        }
        return ToUInt3219(value, nullptr);
    }
    
    uint32_t Convert::ToUInt3219(Object* value, IFormatProvider* provider) {
        if((value ==  nullptr)) 
        {
            return 0U;
        }
        return cli::cast<IConvertible*>(value)->ToUInt32_9a72f29c26115cfd(provider);
    }
    
    uint64_t Convert::ToUInt64(bool value) {
        return (uint64_t)value ? 1 : 0;
    }
    
    uint64_t Convert::ToUInt642(unsigned char value) {
        return (uint64_t)(value);
    }
    
    uint64_t Convert::ToUInt643(char16_t value) {
        return (uint64_t)(value);
    }
    
    uint64_t Convert::ToUInt644(DateTime value) {
        throw cli::gcnew<InvalidCastException>(_T("The conversion is not supported."));
    }
    
    uint64_t Convert::ToUInt645(Decimal value) {
        return cli::checked(Decimal::op_Explicit9(Math::Round(value)));
    }
    
    uint64_t Convert::ToUInt646(double value) {
        return cli::checked((uint64_t)Math::Round5(value));
    }
    
    uint64_t Convert::ToUInt647(float value) {
        return cli::checked((uint64_t)Math::Round5((double)(value)));
    }
    
    uint64_t Convert::ToUInt648(int32_t value) {
        return cli::checked((uint64_t)value);
    }
    
    uint64_t Convert::ToUInt649(int64_t value) {
        return cli::checked((uint64_t)value);
    }
    
    uint64_t Convert::ToUInt6410(signed char value) {
        return cli::checked((uint64_t)value);
    }
    
    uint64_t Convert::ToUInt6411(int16_t value) {
        return cli::checked((uint64_t)value);
    }
    
    uint64_t Convert::ToUInt6412(String* value) {
        if((value ==  nullptr)) 
        {
            return 0UL;
        }
        return UInt64::Parse(value);
    }
    
    uint64_t Convert::ToUInt6413(String* value, IFormatProvider* provider) {
        if((value ==  nullptr)) 
        {
            return 0UL;
        }
        return UInt64::Parse3(value, provider);
    }
    
    uint64_t Convert::ToUInt6414(String* value, int32_t fromBase) {
        return (uint64_t)ConvertFromBase64(value, fromBase, true);
    }
    
    uint64_t Convert::ToUInt6415(uint32_t value) {
        return (uint64_t)(value);
    }
    
    uint64_t Convert::ToUInt6416(uint64_t value) {
        return value;
    }
    
    uint64_t Convert::ToUInt6417(uint16_t value) {
        return (uint64_t)(value);
    }
    
    uint64_t Convert::ToUInt6418(Object* value) {
        if((value ==  nullptr)) 
        {
            return 0UL;
        }
        return ToUInt6419(value, nullptr);
    }
    
    uint64_t Convert::ToUInt6419(Object* value, IFormatProvider* provider) {
        if((value ==  nullptr)) 
        {
            return 0UL;
        }
        return cli::cast<IConvertible*>(value)->ToUInt64_fe563f2a802e4265(provider);
    }
    
    Object* Convert::ChangeType(Object* value, Type* conversionType) {
        if(((value != nullptr) && Type::op_Equality2(conversionType, nullptr))) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("conversionType"));
        }
        Globalization::CultureInfo *ci = Globalization::CultureInfo::get_CurrentCulture();
        IFormatProvider *provider;
        if(Type::op_Equality2(conversionType, cli::typeof<Type>::info)) 
        {
            provider = ci->get_DateTimeFormat_cb96d9a9bbedcdf2();
        }
         else 
        {
            provider = ci->get_NumberFormat_56b6d54c07628932();
        }
        return ToType(value, conversionType, provider, true);
    }
    
    Object* Convert::ChangeType2(Object* value, TypeCode typeCode) {
        Globalization::CultureInfo *ci = Globalization::CultureInfo::get_CurrentCulture();
        Type *conversionType = conversionTable->at((int32_t)(typeCode));
        IFormatProvider *provider;
        if(Type::op_Equality2(conversionType, cli::typeof<Type>::info)) 
        {
            provider = ci->get_DateTimeFormat_cb96d9a9bbedcdf2();
        }
         else 
        {
            provider = ci->get_NumberFormat_56b6d54c07628932();
        }
        return ToType(value, conversionType, provider, true);
    }
    
    Object* Convert::ChangeType3(Object* value, Type* conversionType, IFormatProvider* provider) {
        if(((value != nullptr) && Type::op_Equality2(conversionType, nullptr))) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("conversionType"));
        }
        return ToType(value, conversionType, provider, true);
    }
    
    Object* Convert::ChangeType4(Object* value, TypeCode typeCode, IFormatProvider* provider) {
        Type *conversionType = conversionTable->at((int32_t)(typeCode));
        return ToType(value, conversionType, provider, true);
    }
    
    bool Convert::NotValidBase(int32_t value) {
        if(((((value ==  2) || (value ==  8)) || (value ==  10)) || (value ==  16))) 
        {
            return false;
        }
        return true;
    }
    
    int32_t Convert::ConvertFromBase(String* value, int32_t fromBase, bool unsigned_) {
        if(NotValidBase(fromBase)) 
        {
            throw cli::gcnew<ArgumentException>(_T("fromBase is not valid."));
        }
        if((value ==  nullptr)) 
        {
            return 0;
        }
        int32_t chars = 0;
        int32_t result = 0;
        int32_t digitValue;
        int32_t i = 0;
        int32_t len = value->get_Length();
        bool negative = false;
        switch(fromBase) {
            case 10: case_586: {
                if(String::op_Equality(value->Substring2(i, 1), _T("-"))) 
                {
                    if(unsigned_) 
                    {
                        throw cli::gcnew<OverflowException>(Locale::GetText(_T("The string was being parsed as an unsigned number and could not have a negative sign.")));
                    }
                    negative = true;
                    i++;
                }
                break;
            }
            case 16: case_587: {
                if(String::op_Equality(value->Substring2(i, 1), _T("-"))) 
                {
                    throw cli::gcnew<ArgumentException>(_T("String cannot contain a minus sign if the base is not 10."));
                }
                if((len >= (i + 2))) 
                {
                    if((((int32_t)(value->get_Chars(i)) ==  48) && (((int32_t)(value->get_Chars((i + 1))) ==  120) || ((int32_t)(value->get_Chars((i + 1))) ==  88)))) 
                    {
                        (i = i + 2);
                    }
                }
                break;
            }
            default: case_588: {
                if(String::op_Equality(value->Substring2(i, 1), _T("-"))) 
                {
                    throw cli::gcnew<ArgumentException>(_T("String cannot contain a minus sign if the base is not 10."));
                }
                break;
            }
        }
        if((len ==  i)) 
        {
            throw cli::gcnew<FormatException>(_T("Could not find any parsable digits."));
        }
        if(((int32_t)(value->get_Chars(i)) ==  43)) 
        {
            i++;
        }
        while((i < len)) {
            char16_t c = value->get_Chars(i++);
            if(Char::IsNumber(c)) 
            {
                digitValue = ((int32_t)(c) - 48);
            }
             else 
            {
                if(Char::IsLetter(c)) 
                {
                    digitValue = (((int32_t)(Char::ToLowerInvariant(c)) - 97) + 10);
                }
                 else 
                {
                    if((chars > 0)) 
                    {
                        throw cli::gcnew<FormatException>(_T("Additional unparsable characters are at the end of the string."));
                    }
                     else 
                    {
                        throw cli::gcnew<FormatException>(_T("Could not find any parsable digits."));
                    }
                }
            }
            if((digitValue >= fromBase)) 
            {
                if((chars > 0)) 
                {
                    throw cli::gcnew<FormatException>(_T("Additional unparsable characters are at the end of the string."));
                }
                 else 
                {
                    throw cli::gcnew<FormatException>(_T("Could not find any parsable digits."));
                }
            }
            result = ((fromBase * result) + digitValue);
            chars++;
        }
        if((chars ==  0)) 
        {
            throw cli::gcnew<FormatException>(_T("Could not find any parsable digits."));
        }
        if(negative) 
        {
            return -(result);
        }
         else 
        {
            return result;
        }
    }
    
    int64_t Convert::ConvertFromBase64(String* value, int32_t fromBase, bool unsigned_) {
        if(NotValidBase(fromBase)) 
        {
            throw cli::gcnew<ArgumentException>(_T("fromBase is not valid."));
        }
        if((value ==  nullptr)) 
        {
            return 0L;
        }
        int32_t chars = 0;
        int32_t digitValue = -1;
        int64_t result = 0L;
        bool negative = false;
        int32_t i = 0;
        int32_t len = value->get_Length();
        switch(fromBase) {
            case 10: case_589: {
                if(String::op_Equality(value->Substring2(i, 1), _T("-"))) 
                {
                    if(unsigned_) 
                    {
                        throw cli::gcnew<OverflowException>(Locale::GetText(_T("The string was being parsed as an unsigned number and could not have a negative sign.")));
                    }
                    negative = true;
                    i++;
                }
                break;
            }
            case 16: case_590: {
                if(String::op_Equality(value->Substring2(i, 1), _T("-"))) 
                {
                    throw cli::gcnew<ArgumentException>(_T("String cannot contain a minus sign if the base is not 10."));
                }
                if((len >= (i + 2))) 
                {
                    if((((int32_t)(value->get_Chars(i)) ==  48) && (((int32_t)(value->get_Chars((i + 1))) ==  120) || ((int32_t)(value->get_Chars((i + 1))) ==  88)))) 
                    {
                        (i = i + 2);
                    }
                }
                break;
            }
            default: case_591: {
                if(String::op_Equality(value->Substring2(i, 1), _T("-"))) 
                {
                    throw cli::gcnew<ArgumentException>(_T("String cannot contain a minus sign if the base is not 10."));
                }
                break;
            }
        }
        if((len ==  i)) 
        {
            throw cli::gcnew<FormatException>(_T("Could not find any parsable digits."));
        }
        if(((int32_t)(value->get_Chars(i)) ==  43)) 
        {
            i++;
        }
        while((i < len)) {
            char16_t c = value->get_Chars(i++);
            if(Char::IsNumber(c)) 
            {
                digitValue = ((int32_t)(c) - 48);
            }
             else 
            {
                if(Char::IsLetter(c)) 
                {
                    digitValue = (((int32_t)(Char::ToLowerInvariant(c)) - 97) + 10);
                }
                 else 
                {
                    if((chars > 0)) 
                    {
                        throw cli::gcnew<FormatException>(_T("Additional unparsable characters are at the end of the string."));
                    }
                     else 
                    {
                        throw cli::gcnew<FormatException>(_T("Could not find any parsable digits."));
                    }
                }
            }
            if((digitValue >= fromBase)) 
            {
                if((chars > 0)) 
                {
                    throw cli::gcnew<FormatException>(_T("Additional unparsable characters are at the end of the string."));
                }
                 else 
                {
                    throw cli::gcnew<FormatException>(_T("Could not find any parsable digits."));
                }
            }
            result = (((int64_t)(fromBase) * result) + (int64_t)(digitValue));
            chars++;
        }
        if((chars ==  0)) 
        {
            throw cli::gcnew<FormatException>(_T("Could not find any parsable digits."));
        }
        if(negative) 
        {
            return (-1L * result);
        }
         else 
        {
            return result;
        }
    }
    
    void Convert::EndianSwap(cli::array<unsigned char>* value) {
        cli::array<unsigned char> *buf = (new cli::array<unsigned char>(value->get_Length()));
        for(int32_t i = 0; (i < value->get_Length()); i++) {
            buf->at(i) = value->at(((value->get_Length() - 1) - i));
        }
        value = buf;
    }
    
    String* Convert::ConvertToBase2(cli::array<unsigned char>* value) {
        if(!(BitConverter::IsLittleEndian)) 
        {
            EndianSwap(value);
        }
        Text::StringBuilder *sb = cli::gcnew<Text::StringBuilder>();
        for(int32_t i = (value->get_Length() - 1); (i >= 0); i--){
            unsigned char b = value->at(i);
            for(int32_t j = 0; (j < 8); j++){
                if((((int32_t)(b) & 128) ==  128)) 
                {
                    sb->Append16(u'1');
                }
                 else 
                {
                    if((sb->get_Length() > 0)) 
                    {
                        sb->Append16(u'0');
                    }
                }
                (b = (unsigned char)((int32_t)(b) << 1));
            }
        }
        return sb->ToString_1636a0751cb9ac11();
    }
    
    String* Convert::ConvertToBase8(cli::array<unsigned char>* value) {
        uint64_t l = 0UL;
        switch(value->get_Length()) {
            case 1: case_592: {
                l = (uint64_t)(value->at(0));
                break;
            }
            case 2: case_593: {
                l = (uint64_t)(BitConverter::ToUInt16(value, 0));
                break;
            }
            case 4: case_594: {
                l = (uint64_t)(BitConverter::ToUInt32(value, 0));
                break;
            }
            case 8: case_595: {
                l = BitConverter::ToUInt64(value, 0);
                break;
            }
            default: case_596: {
                throw cli::gcnew<ArgumentException>(_T("value"));
            }
        }
        Text::StringBuilder *sb = cli::gcnew<Text::StringBuilder>();
        for(int32_t i = 21; (i >= 0); i--){
            char16_t val = (char16_t)((l >> ((i * 3) & 63)) & 7UL);
            if((((int32_t)(val) != 0) || (sb->get_Length() > 0))) 
            {
                (val = (char16_t)((int32_t)(val) + 48));
                sb->Append16(val);
            }
        }
        return sb->ToString_1636a0751cb9ac11();
    }
    
    String* Convert::ConvertToBase16(cli::array<unsigned char>* value) {
        if(!(BitConverter::IsLittleEndian)) 
        {
            EndianSwap(value);
        }
        Text::StringBuilder *sb = cli::gcnew<Text::StringBuilder>();
        for(int32_t i = (value->get_Length() - 1); (i >= 0); i--){
            char16_t high = (char16_t)(((int32_t)(value->at(i)) >> 4) & 15);
            if((((int32_t)(high) != 0) || (sb->get_Length() > 0))) 
            {
                if(((int32_t)(high) < 10)) 
                {
                    (high = (char16_t)((int32_t)(high) + 48));
                }
                 else 
                {
                    (high = (char16_t)((int32_t)(high) - 10));
                    (high = (char16_t)((int32_t)(high) + 97));
                }
                sb->Append16(high);
            }
            char16_t low = (char16_t)((int32_t)(value->at(i)) & 15);
            if((((int32_t)(low) != 0) || (sb->get_Length() > 0))) 
            {
                if(((int32_t)(low) < 10)) 
                {
                    (low = (char16_t)((int32_t)(low) + 48));
                }
                 else 
                {
                    (low = (char16_t)((int32_t)(low) - 10));
                    (low = (char16_t)((int32_t)(low) + 97));
                }
                sb->Append16(low);
            }
        }
        return sb->ToString_1636a0751cb9ac11();
    }
    
    Object* Convert::ToType(Object* value, Type* conversionType, IFormatProvider* provider, bool try_target_to_type) {
        if((value ==  nullptr)) 
        {
            if((Type::op_Inequality2(conversionType, nullptr) && conversionType->get_IsValueType())) 
            {
                throw cli::gcnew<InvalidCastException>(_T("Null object can not be converted to a value type."));
            }
             else 
            {
                return nullptr;
            }
        }
        if(Type::op_Equality2(conversionType, nullptr)) 
        {
            throw cli::gcnew<InvalidCastException>(_T("Cannot cast to destination type."));
        }
        if(Type::op_Equality2(value->GetType(), conversionType)) 
        {
            return value;
        }
        if(cli::is<IConvertible>(value)) 
        {
            IConvertible *convertValue = cli::cast<IConvertible*>(value);
            if(Type::op_Equality2(conversionType, conversionTable->at(0))) 
            {
                throw cli::gcnew<ArgumentNullException>();
            }
             else 
            {
                if(Type::op_Equality2(conversionType, conversionTable->at(1))) 
                {
                    return cli::cast<Object*>(value);
                }
                 else 
                {
                    if(Type::op_Equality2(conversionType, conversionTable->at(2))) 
                    {
                        throw cli::gcnew<InvalidCastException>(_T("Cannot cast to DBNull, it\'s not IConvertible"));
                    }
                     else 
                    {
                        if(Type::op_Equality2(conversionType, conversionTable->at(3))) 
                        {
                            return cli::box(convertValue->ToBoolean_f2ed021e3648bfba(provider));
                        }
                         else 
                        {
                            if(Type::op_Equality2(conversionType, conversionTable->at(4))) 
                            {
                                return cli::box(convertValue->ToChar_12adc960e23347fe(provider));
                            }
                             else 
                            {
                                if(Type::op_Equality2(conversionType, conversionTable->at(5))) 
                                {
                                    return cli::box(convertValue->ToSByte_e1f09487d48936db(provider));
                                }
                                 else 
                                {
                                    if(Type::op_Equality2(conversionType, conversionTable->at(6))) 
                                    {
                                        return cli::box(convertValue->ToByte_ce47dcc06c443b11(provider));
                                    }
                                     else 
                                    {
                                        if(Type::op_Equality2(conversionType, conversionTable->at(7))) 
                                        {
                                            return cli::box(convertValue->ToInt16_5e1de9bafa245bf2(provider));
                                        }
                                         else 
                                        {
                                            if(Type::op_Equality2(conversionType, conversionTable->at(8))) 
                                            {
                                                return cli::box(convertValue->ToUInt16_1e02ae7e2827241a(provider));
                                            }
                                             else 
                                            {
                                                if(Type::op_Equality2(conversionType, conversionTable->at(9))) 
                                                {
                                                    return cli::box(convertValue->ToInt32_9e7108d4c09b7e42(provider));
                                                }
                                                 else 
                                                {
                                                    if(Type::op_Equality2(conversionType, conversionTable->at(10))) 
                                                    {
                                                        return cli::box(convertValue->ToUInt32_9a72f29c26115cfd(provider));
                                                    }
                                                     else 
                                                    {
                                                        if(Type::op_Equality2(conversionType, conversionTable->at(11))) 
                                                        {
                                                            return cli::box(convertValue->ToInt64_9801f9765e5301f6(provider));
                                                        }
                                                         else 
                                                        {
                                                            if(Type::op_Equality2(conversionType, conversionTable->at(12))) 
                                                            {
                                                                return cli::box(convertValue->ToUInt64_fe563f2a802e4265(provider));
                                                            }
                                                             else 
                                                            {
                                                                if(Type::op_Equality2(conversionType, conversionTable->at(13))) 
                                                                {
                                                                    return cli::box(convertValue->ToSingle_1cfd1ce472f9fad6(provider));
                                                                }
                                                                 else 
                                                                {
                                                                    if(Type::op_Equality2(conversionType, conversionTable->at(14))) 
                                                                    {
                                                                        return cli::box(convertValue->ToDouble_bf8714f37f489c82(provider));
                                                                    }
                                                                     else 
                                                                    {
                                                                        if(Type::op_Equality2(conversionType, conversionTable->at(15))) 
                                                                        {
                                                                            return cli::box(convertValue->ToDecimal_9c02fd5cdb5f6a0c(provider));
                                                                        }
                                                                         else 
                                                                        {
                                                                            if(Type::op_Equality2(conversionType, conversionTable->at(16))) 
                                                                            {
                                                                                return cli::box(convertValue->ToDateTime_86b01e143a29eff2(provider));
                                                                            }
                                                                             else 
                                                                            {
                                                                                if(Type::op_Equality2(conversionType, conversionTable->at(18))) 
                                                                                {
                                                                                    return cli::cast<Object*>(convertValue->ToString_f121fe9e066b5628(provider));
                                                                                }
                                                                                 else 
                                                                                {
                                                                                    if(try_target_to_type) 
                                                                                    {
                                                                                        return convertValue->ToType_bf083accfb52550a(conversionType, provider);
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        throw cli::gcnew<InvalidCastException>(Locale::GetText(cli::concat(_T("Value is not a convertible object: "), value->GetType()->ToString_1636a0751cb9ac11())));
    }
    
}
namespace System { namespace IO {
    
    
    void CStreamReader::constructor(Stream* stream, System::Text::Encoding* encoding) {
        this->driver = cli::cast<System::TermInfoDriver*>(System::ConsoleDriver::driver);
    }
    
    int32_t CStreamReader::Peek_82f04bf3cd196dfd() {
        try {
            return StreamReader::Peek_82f04bf3cd196dfd();
        }
        catch(IOException*) {
        }
        return -1;
    }
    
    int32_t CStreamReader::Read_1d437d5ac2290f2b() {
        try {
            System::ConsoleKeyInfo key = System::Console::ReadKey();
            return (int32_t)(key->get_KeyChar());
        }
        catch(IOException*) {
        }
        return -1;
    }
    
    int32_t CStreamReader::Read_24d2c98803d927e8(cli::array<char16_t>* dest, int32_t index, int32_t count) {
        if((dest ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("dest"));
        }
        if((index < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("index"), _T("< 0"));
        }
        if((count < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("count"), _T("< 0"));
        }
        if((index > (dest->get_Length() - count))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("index + count > dest.Length"));
        }
        try {
            return this->driver->Read(dest, index, count);
        }
        catch(IOException*) {
        }
        return 0;
    }
    
    System::String* CStreamReader::ReadLine_51552a49261f929e() {
        try {
            return this->driver->ReadLine();
        }
        catch(IOException*) {
        }
        return nullptr;
    }
    
    System::String* CStreamReader::ReadToEnd_f683943dd5002e1e() {
        try {
            return StreamReader::ReadToEnd_f683943dd5002e1e();
        }
        catch(IOException*) {
        }
        return nullptr;
    }
    
}}
namespace System { namespace IO {
    
    
    void CStreamWriter::constructor(Stream* stream, System::Text::Encoding* encoding) {
        this->driver = cli::cast<System::TermInfoDriver*>(System::ConsoleDriver::driver);
    }
    
    void CStreamWriter::Write_61da934607a8065a(cli::array<char16_t>* buffer, int32_t index, int32_t count) {
        if((count <= 0)) 
        {
            return;
        }
        if(!(this->driver->get_Initialized())) 
        {
            try {
                StreamWriter::Write_61da934607a8065a(buffer, index, count);
            }
            catch(IOException*) {
            }
            return;
        }
        {
            cli::lock_guard{this};
            int32_t last = (index + count);
            int32_t i = index;
            int32_t n = 0;
            char16_t c;
            do {
                c = buffer->at(i++);
                if(this->driver->IsSpecialKey2(c)) 
                {
                    if((n > 0)) 
                    {
                        try {
                            StreamWriter::Write_61da934607a8065a(buffer, index, n);
                        }
                        catch(IOException*) {
                        }
                        n = 0;
                    }
                    this->driver->WriteSpecialKey2(c);
                    index = i;
                }
                 else 
                {
                    n++;
                }
            }
            while((i < last));
            if((n > 0)) 
            {
                try {
                    StreamWriter::Write_61da934607a8065a(buffer, index, n);
                }
                catch(IOException*) {
                }
            }
        }
    }
    
    void CStreamWriter::Write_96ccae6b0b267024(char16_t val) {
        {
            cli::lock_guard{this};
            try {
                if(this->driver->IsSpecialKey2(val)) 
                {
                    this->driver->WriteSpecialKey2(val);
                }
                 else 
                {
                    InternalWriteChar(val);
                }
            }
            catch(IOException*) {
            }
        }
    }
    
    void CStreamWriter::InternalWriteString(System::String* val) {
        try {
            StreamWriter::Write_dcf5e45abd9e11c4(val);
        }
        catch(IOException*) {
        }
    }
    
    void CStreamWriter::InternalWriteChar(char16_t val) {
        try {
            StreamWriter::Write_96ccae6b0b267024(val);
        }
        catch(IOException*) {
        }
    }
    
    void CStreamWriter::InternalWriteChars(cli::array<char16_t>* buffer, int32_t n) {
        try {
            StreamWriter::Write_61da934607a8065a(buffer, 0, n);
        }
        catch(IOException*) {
        }
    }
    
    void CStreamWriter::Write_6d89396c0c5b77c4(cli::array<char16_t>* val) {
        TextWriter::Write_61da934607a8065a(val, 0, val->get_Length());
    }
    
    void CStreamWriter::Write_dcf5e45abd9e11c4(System::String* val) {
        if((val ==  nullptr)) 
        {
            return;
        }
        if(this->driver->get_Initialized()) 
        {
            TextWriter::Write_6d89396c0c5b77c4(val->ToCharArray());
        }
         else 
        {
            try {
                StreamWriter::Write_dcf5e45abd9e11c4(val);
            }
            catch(IOException*) {
            }
        }
    }
    
}}
namespace System {
    
    
    void DataMisalignedException::constructor() {
        this->set_HResult(-2146233023);
    }
    
    void DataMisalignedException::constructor(String* message) {
        this->set_HResult(-2146233023);
    }
    
    void DataMisalignedException::constructor(String* message, Exception* innerException) {
        this->set_HResult(-2146233023);
    }
    
}
namespace System {
    
    
    int32_t DateTimeUtils::CountRepeat(String* fmt, int32_t p, char16_t c) {
        int32_t l = fmt->get_Length();
        int32_t i = (p + 1);
        while(((i < l) && ((int32_t)(fmt->get_Chars(i)) ==  (int32_t)(c)))) i++;
        return (i - p);
    }
    
    void DateTimeUtils::ZeroPad(Text::StringBuilder* output, int32_t digits, int32_t len) {
        char16_t buffer[16];
        int32_t pos = 16;
        do {
            (*(buffer + --pos)) = (char16_t)(48 + (digits % 10));
            (digits = digits / 10);
            len--;
        }
        while((digits > 0));
        while((len-- > 0)) (*(buffer + --pos)) = u'0';
        output->Append2(cli::gcnew<String>(buffer, pos, (16 - pos)));
    }
    
    int32_t DateTimeUtils::ParseQuotedString(String* fmt, int32_t pos, Text::StringBuilder* output) {
        int32_t len = fmt->get_Length();
        int32_t start = pos;
        char16_t quoteChar = fmt->get_Chars(pos++);
        while((pos < len)) {
            char16_t ch = fmt->get_Chars(pos++);
            if(((int32_t)(ch) ==  (int32_t)(quoteChar))) 
            {
                return (pos - start);
            }
            if(((int32_t)(ch) ==  92)) 
            {
                if((pos >= len)) 
                {
                    throw cli::gcnew<FormatException>(_T("Un-ended quote"));
                }
                output->Append16(fmt->get_Chars(pos++));
            }
             else 
            {
                output->Append16(ch);
            }
        }
        throw cli::gcnew<FormatException>(_T("Un-ended quote"));
    }
    
    String* DateTimeUtils::GetStandardPattern(char16_t format, Globalization::DateTimeFormatInfo* dfi, bool useutc, bool use_invariant) {
        return GetStandardPattern2(format, dfi, useutc, use_invariant, false);
    }
    
    String* DateTimeUtils::GetStandardPattern2(char16_t format, Globalization::DateTimeFormatInfo* dfi, bool useutc, bool use_invariant, bool date_time_offset) {
        String *pattern;
        useutc = false;
        use_invariant = false;
        switch(format) {
            case u'd': case_597: {
                pattern = dfi->get_ShortDatePattern();
                break;
            }
            case u'D': case_598: {
                pattern = dfi->get_LongDatePattern();
                break;
            }
            case u'f': case_599: {
                pattern = cli::concat(dfi->get_LongDatePattern(), _T(" "));
                break;
            }
            case u'F': case_600: {
                pattern = dfi->get_FullDateTimePattern();
                break;
            }
            case u'g': case_601: {
                pattern = cli::concat(dfi->get_ShortDatePattern(), _T(" "));
                break;
            }
            case u'G': case_602: {
                pattern = cli::concat(dfi->get_ShortDatePattern(), _T(" "));
                break;
            }
            case u'm': case u'M': case_603: {
                pattern = dfi->get_MonthDayPattern();
                break;
            }
            case u'o': case u'O': case_604: {
                pattern = dfi->get_RoundtripPattern();
                use_invariant = true;
                break;
            }
            case u'r': case u'R': case_605: {
                pattern = dfi->get_RFC1123Pattern();
                if(date_time_offset) 
                {
                    useutc = true;
                }
                use_invariant = true;
                break;
            }
            case u's': case_606: {
                pattern = dfi->get_SortableDateTimePattern();
                use_invariant = true;
                break;
            }
            case u't': case_607: {
                pattern = dfi->get_ShortTimePattern();
                break;
            }
            case u'T': case_608: {
                pattern = dfi->get_LongTimePattern();
                break;
            }
            case u'u': case_609: {
                pattern = dfi->get_UniversalSortableDateTimePattern();
                if(date_time_offset) 
                {
                    useutc = true;
                }
                use_invariant = true;
                break;
            }
            case u'U': case_610: {
                if(date_time_offset) 
                {
                    pattern = nullptr;
                }
                 else 
                {
                    pattern = dfi->get_FullDateTimePattern();
                    useutc = true;
                }
                break;
            }
            case u'y': case u'Y': case_611: {
                pattern = dfi->get_YearMonthPattern();
                break;
            }
            default: case_612: {
                pattern = nullptr;
                break;
            }
        }
        return pattern;
    }
    
    String* DateTimeUtils::ToString2(DateTime dt, String* format, Globalization::DateTimeFormatInfo* dfi) {
        return ToString3(dt, nullptr, format, dfi);
    }
    
    String* DateTimeUtils::ToString3(DateTime dt, Nullable2<TimeSpan> utc_offset, String* format, Globalization::DateTimeFormatInfo* dfi) {
        Text::StringBuilder *result = cli::gcnew<Text::StringBuilder>((format->get_Length() + 10));
        Globalization::DateTimeFormatInfo *inv = Globalization::DateTimeFormatInfo::get_InvariantInfo();
        if(String::op_Equality(format, inv->get_RFC1123Pattern())) 
        {
            dfi = inv;
        }
         else 
        {
            if(String::op_Equality(format, inv->get_UniversalSortableDateTimePattern())) 
            {
                dfi = inv;
            }
        }
        int32_t i = 0;
        while((i < format->get_Length())) {
            int32_t tokLen;
            bool omitZeros = false;
            char16_t ch = format->get_Chars(i);
            switch(ch) {
                case u'h': case_613: {
                    tokLen = DateTimeUtils::CountRepeat(format, i, ch);
                    int32_t hr = (dt->get_Hour() % 12);
                    if((hr ==  0)) 
                    {
                        hr = 12;
                    }
                    DateTimeUtils::ZeroPad(result, hr, (tokLen ==  1) ? 1 : 2);
                    break;
                }
                case u'H': case_614: {
                    tokLen = DateTimeUtils::CountRepeat(format, i, ch);
                    DateTimeUtils::ZeroPad(result, dt->get_Hour(), (tokLen ==  1) ? 1 : 2);
                    break;
                }
                case u'm': case_615: {
                    tokLen = DateTimeUtils::CountRepeat(format, i, ch);
                    DateTimeUtils::ZeroPad(result, dt->get_Minute(), (tokLen ==  1) ? 1 : 2);
                    break;
                }
                case u's': case_616: {
                    tokLen = DateTimeUtils::CountRepeat(format, i, ch);
                    DateTimeUtils::ZeroPad(result, dt->get_Second(), (tokLen ==  1) ? 1 : 2);
                    break;
                }
                case u'F': case_617: {
                    omitZeros = true;
                    goto case_618;
                }
                case u'f': case_618: {
                    tokLen = DateTimeUtils::CountRepeat(format, i, ch);
                    if((tokLen > 7)) 
                    {
                        throw cli::gcnew<FormatException>(_T("Invalid Format String"));
                    }
                    int32_t dec = (int32_t)((int64_t)((dt->get_Ticks() % 10000000L)) / (int64_t)Math::Pow(10., (double)((7 - tokLen))));
                    int32_t startLen = result->get_Length();
                    DateTimeUtils::ZeroPad(result, dec, tokLen);
                    if(omitZeros) 
                    {
                        while(((result->get_Length() > startLen) && ((int32_t)(result->get_Chars((result->get_Length() - 1))) ==  48))) [&]() { auto tmp_158 = result->get_Length(); result->set_Length(tmp_158 - 1); return tmp_158; }();
                        if((((dec ==  0) && (startLen > 0)) && ((int32_t)(result->get_Chars((startLen - 1))) ==  46))) 
                        {
                            [&]() { auto tmp_159 = result->get_Length(); result->set_Length(tmp_159 - 1); return tmp_159; }();
                        }
                    }
                    break;
                }
                case u't': case_619: {
                    tokLen = DateTimeUtils::CountRepeat(format, i, ch);
                    String *desig = (dt->get_Hour() < 12) ? dfi->get_AMDesignator() : dfi->get_PMDesignator();
                    if((tokLen ==  1)) 
                    {
                        if((desig->get_Length() >= 1)) 
                        {
                            result->Append16(desig->get_Chars(0));
                        }
                    }
                     else 
                    {
                        result->Append2(desig);
                    }
                    break;
                }
                case u'z': case_620: {
                    {
                        tokLen = DateTimeUtils::CountRepeat(format, i, ch);
                        TimeSpan offset = ([&]() {
                            Nullable2<TimeSpan> tmp_160 = utc_offset;
                            if(tmp_160.get_HasValue()) {
                                return TimeZone::get_CurrentTimeZone()->GetUtcOffset_7ede31ceb7855151(dt);
                            } else
                                return tmp_160.get_Value();
                        })();
                        if((offset->get_Ticks() >= 0L)) 
                        {
                            result->Append16(u'+');
                        }
                         else 
                        {
                            result->Append16(u'-');
                        }
                        switch(tokLen) {
                            case 1: case_632: {
                                result->Append8(Math::Abs4(offset->get_Hours()));
                                break;
                            }
                            case 2: case_633: {
                                result->Append2(cli::import(Math::Abs4(offset->get_Hours()))->ToString4(_T("00")));
                                break;
                            }
                            default: case_634: {
                                result->Append2(cli::import(Math::Abs4(offset->get_Hours()))->ToString4(_T("00")));
                                result->Append16(u':');
                                result->Append2(cli::import(Math::Abs4(offset->get_Minutes()))->ToString4(_T("00")));
                                break;
                            }
                        }
                    }
                    break;
                }
                case u'K': case_621: {
                    tokLen = 1;
                    if((((Nullable2<TimeSpan>)(cli::unwrap_nullable(utc_offset)) != nullptr) || ((int32_t)(dt->get_Kind()) ==  2))) 
                    {
                        TimeSpan offset = ([&]() {
                            Nullable2<TimeSpan> tmp_161 = utc_offset;
                            if(tmp_161.get_HasValue()) {
                                return TimeZone::get_CurrentTimeZone()->GetUtcOffset_7ede31ceb7855151(dt);
                            } else
                                return tmp_161.get_Value();
                        })();
                        if((offset->get_Ticks() >= 0L)) 
                        {
                            result->Append16(u'+');
                        }
                         else 
                        {
                            result->Append16(u'-');
                        }
                        result->Append2(cli::import(Math::Abs4(offset->get_Hours()))->ToString4(_T("00")));
                        result->Append16(u':');
                        result->Append2(cli::import(Math::Abs4(offset->get_Minutes()))->ToString4(_T("00")));
                    }
                     else 
                    {
                        if(((int32_t)(dt->get_Kind()) ==  1)) 
                        {
                            result->Append16(u'Z');
                        }
                    }
                    break;
                }
                case u'd': case_622: {
                    tokLen = DateTimeUtils::CountRepeat(format, i, ch);
                    if((tokLen <= 2)) 
                    {
                        DateTimeUtils::ZeroPad(result, dfi->get_Calendar()->GetDayOfMonth_7da4e9f8c6f0dece(dt), (tokLen ==  1) ? 1 : 2);
                    }
                     else 
                    {
                        if((tokLen ==  3)) 
                        {
                            result->Append2(dfi->GetAbbreviatedDayName(dfi->get_Calendar()->GetDayOfWeek_4c0b69c7bb83520e(dt)));
                        }
                         else 
                        {
                            result->Append2(dfi->GetDayName(dfi->get_Calendar()->GetDayOfWeek_4c0b69c7bb83520e(dt)));
                        }
                    }
                    break;
                }
                case u'M': case_623: {
                    tokLen = DateTimeUtils::CountRepeat(format, i, ch);
                    int32_t month = dfi->get_Calendar()->GetMonth_66424683b988a96b(dt);
                    if((tokLen <= 2)) 
                    {
                        DateTimeUtils::ZeroPad(result, month, tokLen);
                    }
                     else 
                    {
                        if((tokLen ==  3)) 
                        {
                            result->Append2(dfi->GetAbbreviatedMonthName(month));
                        }
                         else 
                        {
                            result->Append2(dfi->GetMonthName(month));
                        }
                    }
                    break;
                }
                case u'y': case_624: {
                    tokLen = DateTimeUtils::CountRepeat(format, i, ch);
                    if((tokLen <= 2)) 
                    {
                        DateTimeUtils::ZeroPad(result, (dfi->get_Calendar()->GetYear_75c1b17aa90af360(dt) % 100), tokLen);
                    }
                     else 
                    {
                        DateTimeUtils::ZeroPad(result, dfi->get_Calendar()->GetYear_75c1b17aa90af360(dt), tokLen);
                    }
                    break;
                }
                case u'g': case_625: {
                    tokLen = DateTimeUtils::CountRepeat(format, i, ch);
                    result->Append2(dfi->GetEraName(dfi->get_Calendar()->GetEra_1d16c3456dce785e(dt)));
                    break;
                }
                case u':': case_626: {
                    result->Append2(dfi->get_TimeSeparator());
                    tokLen = 1;
                    break;
                }
                case u'/': case_627: {
                    result->Append2(dfi->get_DateSeparator());
                    tokLen = 1;
                    break;
                }
                case u'\'': case u'"': case_628: {
                    tokLen = DateTimeUtils::ParseQuotedString(format, i, result);
                    break;
                }
                case u'%': case_629: {
                    if((i >= (format->get_Length() - 1))) 
                    {
                        throw cli::gcnew<FormatException>(_T("% at end of date time string"));
                    }
                    if(((int32_t)(format->get_Chars((i + 1))) ==  37)) 
                    {
                        throw cli::gcnew<FormatException>(_T("%% in date string"));
                    }
                    tokLen = 1;
                    break;
                }
                case u'\\': case_630: {
                    if((i >= (format->get_Length() - 1))) 
                    {
                        throw cli::gcnew<FormatException>(_T("\\ at end of date time string"));
                    }
                    result->Append16(format->get_Chars((i + 1)));
                    tokLen = 2;
                    break;
                }
                default: case_631: {
                    result->Append16(ch);
                    tokLen = 1;
                    break;
                }
            }
            (i = i + tokLen);
        }
        return result->ToString_1636a0751cb9ac11();
    }
    
}
namespace System {
    
    DBNull*  DBNull::Value;
    
    DBNull::DBNull()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void DBNull::constructor() {
    }
    
    void DBNull::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        throw cli::gcnew<NotSupportedException>();
    }
    
    void DBNull::static_constructor() {
    }
    
    void DBNull::GetObjectData(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        UnitySerializationHolder::GetDBNullData(this, info, context);
    }
    
    TypeCode DBNull::GetTypeCode() {
        return TypeCode::DBNull2;
    }
    
    bool DBNull::ToBoolean(IFormatProvider* provider) {
        throw cli::gcnew<InvalidCastException>();
    }
    
    unsigned char DBNull::ToByte(IFormatProvider* provider) {
        throw cli::gcnew<InvalidCastException>();
    }
    
    char16_t DBNull::ToChar(IFormatProvider* provider) {
        throw cli::gcnew<InvalidCastException>();
    }
    
    DateTime DBNull::ToDateTime(IFormatProvider* provider) {
        throw cli::gcnew<InvalidCastException>();
    }
    
    Decimal DBNull::ToDecimal(IFormatProvider* provider) {
        throw cli::gcnew<InvalidCastException>();
    }
    
    double DBNull::ToDouble(IFormatProvider* provider) {
        throw cli::gcnew<InvalidCastException>();
    }
    
    int16_t DBNull::ToInt16(IFormatProvider* provider) {
        throw cli::gcnew<InvalidCastException>();
    }
    
    int32_t DBNull::ToInt32(IFormatProvider* provider) {
        throw cli::gcnew<InvalidCastException>();
    }
    
    int64_t DBNull::ToInt64(IFormatProvider* provider) {
        throw cli::gcnew<InvalidCastException>();
    }
    
    signed char DBNull::ToSByte(IFormatProvider* provider) {
        throw cli::gcnew<InvalidCastException>();
    }
    
    float DBNull::ToSingle(IFormatProvider* provider) {
        throw cli::gcnew<InvalidCastException>();
    }
    
    Object* DBNull::ToType(Type* targetType, IFormatProvider* provider) {
        if(Type::op_Equality2(targetType, cli::typeof<Type>::info)) 
        {
            return String::Empty;
        }
        if(Type::op_Equality2(targetType, cli::typeof<Type>::info)) 
        {
            return this;
        }
        throw cli::gcnew<InvalidCastException>();
    }
    
    uint16_t DBNull::ToUInt16(IFormatProvider* provider) {
        throw cli::gcnew<InvalidCastException>();
    }
    
    uint32_t DBNull::ToUInt32(IFormatProvider* provider) {
        throw cli::gcnew<InvalidCastException>();
    }
    
    uint64_t DBNull::ToUInt64(IFormatProvider* provider) {
        throw cli::gcnew<InvalidCastException>();
    }
    
    String* DBNull::ToString_1636a0751cb9ac11() {
        return String::Empty;
    }
    
    String* DBNull::ToString3(IFormatProvider* provider) {
        return String::Empty;
    }
    
}
namespace System {
    
    
    void DelegateData::constructor() {
    }
    
}
namespace System {
    
    
    void Delegate::constructor(Object* target, String* method) {
        if((target ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("target"));
        }
        if((method ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("method"));
        }
        this->m_target = target;
        this->data = cli::gcnew<DelegateData>();
        this->data->method_name = method;
    }
    
    void Delegate::constructor(Type* target, String* method) {
        if(Type::op_Equality2(target, nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("target"));
        }
        if((method ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("method"));
        }
        this->data = cli::gcnew<DelegateData>();
        this->data->method_name = method;
        this->data->target_type = target;
    }
    
    Delegate* Delegate::CreateDelegate_internal(Type* type, Object* target, Reflection::MethodInfo* info, bool throwOnBindFailure) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Delegate::SetMulticastInvoke() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool Delegate::arg_type_match(Type* delArgType, Type* argType) {
        bool match = Type::op_Equality2(delArgType, argType);
        if(!(match)) 
        {
            if((!(argType->get_IsValueType()) && argType->IsAssignableFrom_e3aa32d778e63a90(delArgType))) 
            {
                match = true;
            }
        }
        if(!(match)) 
        {
            if((delArgType->get_IsEnum_bc85ea7b0a749db() && Type::op_Equality2(Enum::GetUnderlyingType(delArgType), argType))) 
            {
                match = true;
            }
        }
        return match;
    }
    
    bool Delegate::arg_type_match_this(Type* delArgType, Type* argType, bool boxedThis) {
        bool match;
        if(argType->get_IsValueType()) 
        {
            match = ((delArgType->get_IsByRef() && Type::op_Equality2(delArgType->GetElementType_ab5070dbbfe66f5f(), argType)) || (boxedThis && Type::op_Equality2(delArgType, argType)));
        }
         else 
        {
            match = (Type::op_Equality2(delArgType, argType) || argType->IsAssignableFrom_e3aa32d778e63a90(delArgType));
        }
        return match;
    }
    
    bool Delegate::return_type_match(Type* delReturnType, Type* returnType) {
        bool returnMatch = Type::op_Equality2(returnType, delReturnType);
        if(!(returnMatch)) 
        {
            if((!(returnType->get_IsValueType()) && delReturnType->IsAssignableFrom_e3aa32d778e63a90(returnType))) 
            {
                returnMatch = true;
            }
        }
        return returnMatch;
    }
    
    Delegate* Delegate::CreateDelegate(Type* type, Object* firstArgument, Reflection::MethodInfo* method, bool throwOnBindFailure) {
        return CreateDelegate2(type, firstArgument, method, throwOnBindFailure, true);
    }
    
    Delegate* Delegate::CreateDelegate2(Type* type, Object* firstArgument, Reflection::MethodInfo* method, bool throwOnBindFailure, bool allowClosed) {
        Object *target = firstArgument;
        if(Type::op_Equality2(type, nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("type"));
        }
        if(Reflection::MethodInfo::op_Equality(method, nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("method"));
        }
        if(!(type->IsSubclassOf_5d7dbe0215a30fda(cli::typeof<Type>::info))) 
        {
            throw cli::gcnew<ArgumentException>(_T("type is not a subclass of Multicastdelegate"));
        }
        Reflection::MethodInfo *invoke = type->GetMethod(_T("Invoke"));
        if(!(return_type_match(invoke->get_ReturnType_832339e848f448fe(), method->get_ReturnType_832339e848f448fe()))) 
        {
            if(throwOnBindFailure) 
            {
                throw cli::gcnew<ArgumentException>(_T("method return type is incompatible"));
            }
             else 
            {
                return nullptr;
            }
        }
        cli::array<Reflection::ParameterInfo*> *delargs = invoke->GetParameters_9d17bcb549474c9();
        cli::array<Reflection::ParameterInfo*> *args = method->GetParameters_9d17bcb549474c9();
        bool argLengthMatch;
        if((target != nullptr)) 
        {
            if(!(method->get_IsStatic())) 
            {
                argLengthMatch = (args->get_Length() ==  delargs->get_Length());
            }
             else 
            {
                argLengthMatch = (args->get_Length() ==  (delargs->get_Length() + 1));
            }
        }
         else 
        {
            if(!(method->get_IsStatic())) 
            {
                argLengthMatch = ((args->get_Length() + 1) ==  delargs->get_Length());
                if(!(argLengthMatch)) 
                {
                    argLengthMatch = (args->get_Length() ==  delargs->get_Length());
                }
            }
             else 
            {
                argLengthMatch = (args->get_Length() ==  delargs->get_Length());
                if(!(argLengthMatch)) 
                {
                    argLengthMatch = (args->get_Length() ==  (delargs->get_Length() + 1));
                }
            }
        }
        if(!(argLengthMatch)) 
        {
            if(throwOnBindFailure) 
            {
                throw cli::gcnew<ArgumentException>(_T("method argument length mismatch"));
            }
             else 
            {
                return nullptr;
            }
        }
        bool argsMatch;
        if((target != nullptr)) 
        {
            if(!(method->get_IsStatic())) 
            {
                argsMatch = arg_type_match_this(target->GetType(), method->get_DeclaringType_6121cd6a84393166(), true);
                for(int32_t i = 0; (i < args->get_Length()); i++) {
                    (argsMatch = argsMatch & arg_type_match(delargs->at(i)->get_ParameterType_97c5fa09a0b988d(), args->at(i)->get_ParameterType_97c5fa09a0b988d()));
                }
            }
             else 
            {
                argsMatch = arg_type_match(target->GetType(), args->at(0)->get_ParameterType_97c5fa09a0b988d());
                for(int32_t i = 1; (i < args->get_Length()); i++) {
                    (argsMatch = argsMatch & arg_type_match(delargs->at((i - 1))->get_ParameterType_97c5fa09a0b988d(), args->at(i)->get_ParameterType_97c5fa09a0b988d()));
                }
            }
        }
         else 
        {
            if(!(method->get_IsStatic())) 
            {
                if(((args->get_Length() + 1) ==  delargs->get_Length())) 
                {
                    argsMatch = arg_type_match_this(delargs->at(0)->get_ParameterType_97c5fa09a0b988d(), method->get_DeclaringType_6121cd6a84393166(), false);
                    for(int32_t i = 0; (i < args->get_Length()); i++) {
                        (argsMatch = argsMatch & arg_type_match(delargs->at((i + 1))->get_ParameterType_97c5fa09a0b988d(), args->at(i)->get_ParameterType_97c5fa09a0b988d()));
                    }
                }
                 else 
                {
                    argsMatch = allowClosed;
                    for(int32_t i = 0; (i < args->get_Length()); i++) {
                        (argsMatch = argsMatch & arg_type_match(delargs->at(i)->get_ParameterType_97c5fa09a0b988d(), args->at(i)->get_ParameterType_97c5fa09a0b988d()));
                    }
                }
            }
             else 
            {
                if(((delargs->get_Length() + 1) ==  args->get_Length())) 
                {
                    argsMatch = (!((args->at(0)->get_ParameterType_97c5fa09a0b988d()->get_IsValueType() || args->at(0)->get_ParameterType_97c5fa09a0b988d()->get_IsByRef())) && allowClosed);
                    for(int32_t i = 0; (i < delargs->get_Length()); i++) {
                        (argsMatch = argsMatch & arg_type_match(delargs->at(i)->get_ParameterType_97c5fa09a0b988d(), args->at((i + 1))->get_ParameterType_97c5fa09a0b988d()));
                    }
                }
                 else 
                {
                    argsMatch = true;
                    for(int32_t i = 0; (i < args->get_Length()); i++) {
                        (argsMatch = argsMatch & arg_type_match(delargs->at(i)->get_ParameterType_97c5fa09a0b988d(), args->at(i)->get_ParameterType_97c5fa09a0b988d()));
                    }
                }
            }
        }
        if(!(argsMatch)) 
        {
            if(throwOnBindFailure) 
            {
                throw cli::gcnew<ArgumentException>(_T("method arguments are incompatible"));
            }
             else 
            {
                return nullptr;
            }
        }
        Delegate *d = CreateDelegate_internal(type, target, method, throwOnBindFailure);
        if((d != nullptr)) 
        {
            d->original_method_info = method;
        }
        return d;
    }
    
    Delegate* Delegate::CreateDelegate3(Type* type, Object* firstArgument, Reflection::MethodInfo* method) {
        return CreateDelegate2(type, firstArgument, method, true, true);
    }
    
    Delegate* Delegate::CreateDelegate4(Type* type, Reflection::MethodInfo* method, bool throwOnBindFailure) {
        return CreateDelegate2(type, nullptr, method, throwOnBindFailure, false);
    }
    
    Delegate* Delegate::CreateDelegate5(Type* type, Reflection::MethodInfo* method) {
        return CreateDelegate4(type, method, true);
    }
    
    Delegate* Delegate::CreateDelegate6(Type* type, Object* target, String* method) {
        return CreateDelegate11(type, target, method, false);
    }
    
    Reflection::MethodInfo* Delegate::GetCandidateMethod(Type* type, Type* target, String* method, Reflection::BindingFlags bflags, bool ignoreCase, bool throwOnBindFailure) {
        if(Type::op_Equality2(type, nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("type"));
        }
        if((method ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("method"));
        }
        if(!(type->IsSubclassOf_5d7dbe0215a30fda(cli::typeof<Type>::info))) 
        {
            throw cli::gcnew<ArgumentException>(_T("type is not subclass of MulticastDelegate."));
        }
        Reflection::MethodInfo *invoke = type->GetMethod(_T("Invoke"));
        cli::array<Reflection::ParameterInfo*> *delargs = invoke->GetParameters_9d17bcb549474c9();
        cli::array<Type*> *delargtypes = (new cli::array<Type*>(delargs->get_Length()));
        for(int32_t i = 0; (i < delargs->get_Length()); i++) {
            delargtypes->at(i) = delargs->at(i)->get_ParameterType_97c5fa09a0b988d();
        }
        Reflection::BindingFlags flags = (Reflection::BindingFlags)((65586 | (int32_t)(bflags)));
        if(ignoreCase) 
        {
            (flags = (Reflection::BindingFlags)(((int32_t)(flags) | 1)));
        }
        Reflection::MethodInfo *info = nullptr;
        for(Type *targetType = target; Type::op_Inequality2(targetType, nullptr); targetType = targetType->get_BaseType_6a0646ae880055f6()){
            Reflection::MethodInfo *mi = targetType->GetMethod5(method, flags, nullptr, delargtypes, (new cli::array<Reflection::ParameterModifier>(0)));
            if((Reflection::MethodInfo::op_Inequality(mi, nullptr) && return_type_match(invoke->get_ReturnType_832339e848f448fe(), mi->get_ReturnType_832339e848f448fe()))) 
            {
                info = mi;
                break;
            }
        }
        if(Reflection::MethodInfo::op_Equality(info, nullptr)) 
        {
            if(throwOnBindFailure) 
            {
                throw cli::gcnew<ArgumentException>(cli::concat(_T("Couldn\'t bind to method \'"), method));
            }
             else 
            {
                return nullptr;
            }
        }
        return info;
    }
    
    Delegate* Delegate::CreateDelegate7(Type* type, Type* target, String* method, bool ignoreCase, bool throwOnBindFailure) {
        if(Type::op_Equality2(target, nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("target"));
        }
        Reflection::MethodInfo *info = GetCandidateMethod(type, target, method, Reflection::BindingFlags::Static, ignoreCase, throwOnBindFailure);
        if(Reflection::MethodInfo::op_Equality(info, nullptr)) 
        {
            return nullptr;
        }
        return CreateDelegate_internal(type, nullptr, info, throwOnBindFailure);
    }
    
    Delegate* Delegate::CreateDelegate8(Type* type, Type* target, String* method) {
        return CreateDelegate7(type, target, method, false, true);
    }
    
    Delegate* Delegate::CreateDelegate9(Type* type, Type* target, String* method, bool ignoreCase) {
        return CreateDelegate7(type, target, method, ignoreCase, true);
    }
    
    Delegate* Delegate::CreateDelegate10(Type* type, Object* target, String* method, bool ignoreCase, bool throwOnBindFailure) {
        if((target ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("target"));
        }
        Reflection::MethodInfo *info = GetCandidateMethod(type, target->GetType(), method, Reflection::BindingFlags::Instance, ignoreCase, throwOnBindFailure);
        if(Reflection::MethodInfo::op_Equality(info, nullptr)) 
        {
            return nullptr;
        }
        return CreateDelegate_internal(type, target, info, throwOnBindFailure);
    }
    
    Delegate* Delegate::CreateDelegate11(Type* type, Object* target, String* method, bool ignoreCase) {
        return CreateDelegate10(type, target, method, ignoreCase, true);
    }
    
    Object* Delegate::DynamicInvoke(cli::array<Object*>* args) {
        return DynamicInvokeImpl_929f0cf2f6cc1bc9(args);
    }
    
    Object* Delegate::DynamicInvokeImpl_929f0cf2f6cc1bc9(cli::array<Object*>* args) {
        if(Reflection::MethodInfo::op_Equality(this->get_Method(), nullptr)) 
        {
            cli::array<Type*> *mtypes = (new cli::array<Type*>(args->get_Length()));
            for(int32_t i = 0; (i < args->get_Length()); ++i){
                mtypes->at(i) = args->at(i)->GetType();
            }
            this->method_info = this->m_target->GetType()->GetMethod3(this->data->method_name, mtypes);
        }
        if((this->get_Method()->get_IsStatic() && ((args != nullptr) ? args->get_Length() : 0 ==  (this->get_Method()->GetParameters_9d17bcb549474c9()->get_Length() - 1)))) 
        {
            if((args != nullptr)) 
            {
                cli::array<Object*> *newArgs = (new cli::array<Object*>((args->get_Length() + 1)));
                cli::import(args)->CopyTo(newArgs, 1);
                newArgs->at(0) = this->m_target;
                args = newArgs;
            }
             else 
            {
                args = (new cli::array<Object*>({m_target}));
            }
            return this->get_Method()->Invoke2(nullptr, args);
        }
        return this->get_Method()->Invoke2(this->m_target, args);
    }
    
    Object* Delegate::Clone_ea12f3f395dbfa01() {
        return Object::MemberwiseClone();
    }
    
    bool Delegate::Equals_ed975d2f4a7d193e(Object* obj) {
        Delegate *d = cli::as<Delegate*>(obj);
        if((d ==  nullptr)) 
        {
            return false;
        }
        if(((d->m_target ==  this->m_target) && ::System::IntPtr::op_Equality(d->method, this->method))) 
        {
            if(((d->data != nullptr) || (this->data != nullptr))) 
            {
                if(((d->data != nullptr) && (this->data != nullptr))) 
                {
                    return (Type::op_Equality2(d->data->target_type, this->data->target_type) && String::op_Equality(d->data->method_name, this->data->method_name));
                }
                 else 
                {
                    return false;
                }
            }
            return true;
        }
        return false;
    }
    
    int32_t Delegate::GetHashCode_6648aef0f235ee6c() {
        return (cli::import(this->method)->GetHashCode_6648aef0f235ee6c() ^ (this->m_target != nullptr) ? this->m_target->GetHashCode_6648aef0f235ee6c() : 0);
    }
    
    Reflection::MethodInfo* Delegate::GetMethodImpl_6cc946ae8113eac0() {
        return this->get_Method();
    }
    
    void Delegate::GetObjectData_e87c6354ab1f5b0(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        DelegateSerializationHolder::GetDelegateData(this, info, context);
    }
    
    cli::array<Delegate*>* Delegate::GetInvocationList_8fef0390be027d95() {
        return (new cli::array<Delegate*>({this}));
    }
    
    Delegate* Delegate::Combine(Delegate* a, Delegate* b) {
        if((a ==  nullptr)) 
        {
            if((b ==  nullptr)) 
            {
                return nullptr;
            }
            return b;
        }
         else 
        {
            if((b ==  nullptr)) 
            {
                return a;
            }
        }
        if(Type::op_Inequality2(a->GetType(), b->GetType())) 
        {
            throw cli::gcnew<ArgumentException>(Locale::GetText(_T("Incompatible Delegate Types.")));
        }
        return a->CombineImpl_1d822eded1f305a6(b);
    }
    
    Delegate* Delegate::Combine2(cli::array<Delegate*>* delegates) {
        if((delegates ==  nullptr)) 
        {
            return nullptr;
        }
        Delegate *retval = nullptr;
        for(auto tmp_162 : delegates) {
            auto next = cli::cast<Delegate*>(tmp_162);
            retval = Combine(retval, next);
        }
        return retval;
    }
    
    Delegate* Delegate::CombineImpl_1d822eded1f305a6(Delegate* d) {
        throw cli::gcnew<MulticastNotSupportedException>(String::Empty);
    }
    
    Delegate* Delegate::Remove(Delegate* source, Delegate* value) {
        if((source ==  nullptr)) 
        {
            return nullptr;
        }
        if((value ==  nullptr)) 
        {
            return source;
        }
        if(Type::op_Inequality2(source->GetType(), value->GetType())) 
        {
            throw cli::gcnew<ArgumentException>(_T("Delegate type mismatch"));
        }
        return source->RemoveImpl_683e7d1a8f792013(value);
    }
    
    Delegate* Delegate::RemoveImpl_683e7d1a8f792013(Delegate* d) {
        if(this->Equals_ed975d2f4a7d193e(d)) 
        {
            return nullptr;
        }
        return this;
    }
    
    Delegate* Delegate::RemoveAll(Delegate* source, Delegate* value) {
        Delegate *tmp = source;
        while(op_Inequality(source = Delegate::Remove(source, value), tmp)) tmp = source;
        return tmp;
    }
    
    bool Delegate::IsTransparentProxy() {
        return Runtime::Remoting::RemotingServices::IsTransparentProxy(this->m_target);
    }
    
    bool Delegate::op_Equality(Delegate* d1, Delegate* d2) {
        if((cli::cast<Object*>(d1) ==  nullptr)) 
        {
            if((cli::cast<Object*>(d2) ==  nullptr)) 
            {
                return true;
            }
            return false;
        }
         else 
        {
            if((cli::cast<Object*>(d2) ==  nullptr)) 
            {
                return false;
            }
        }
        return d1->Equals_ed975d2f4a7d193e(d2);
    }
    
    bool Delegate::op_Inequality(Delegate* d1, Delegate* d2) {
        return !(op_Equality(d1, d2));
    }
    
    Reflection::MethodInfo* Delegate::get_Method() {
        if(Reflection::MethodInfo::op_Inequality(this->method_info, nullptr)) 
        {
            return this->method_info;
        }
         else 
        {
            if(::System::IntPtr::op_Inequality(this->method, (*::System::IntPtr::Zero))) 
            {
                this->method_info = cli::cast<Reflection::MethodInfo*>(Reflection::MethodBase::GetMethodFromHandleNoGenericCheck(cli::ctor<RuntimeMethodHandle>(this->method)));
            }
            return this->method_info;
        }
    }
    
    Object* Delegate::get_Target() {
        return this->m_target;
    }
    
}
namespace System {
    
    
    void DelegateEntry::constructor(Delegate* del, String* targetLabel) {
        this->type = del->GetType()->get_FullName_7e8fa72ba225e1a4();
        this->assembly = del->GetType()->get_Assembly_3aae0acbf2a6d696()->get_FullName_abd52da7f47cce07();
        this->target = targetLabel;
        this->targetTypeAssembly = del->get_Method()->get_DeclaringType_6121cd6a84393166()->get_Assembly_3aae0acbf2a6d696()->get_FullName_abd52da7f47cce07();
        this->targetTypeName = del->get_Method()->get_DeclaringType_6121cd6a84393166()->get_FullName_7e8fa72ba225e1a4();
        this->methodName = del->get_Method()->get_Name_50fad5fa936c3ae2();
    }
    
    Delegate* DelegateEntry::DeserializeDelegate(Runtime::Serialization::SerializationInfo* info) {
        Object *realTarget = nullptr;
        if((this->target != nullptr)) 
        {
            realTarget = info->GetValue(this->target->ToString_1636a0751cb9ac11(), cli::typeof<Type>::info);
        }
        Reflection::Assembly *dasm = Reflection::Assembly::Load(this->assembly);
        Type *dt = dasm->GetType_99cbfcc4e094eb08(this->type);
        Delegate *del;
        if((realTarget != nullptr)) 
        {
            if(Runtime::Remoting::RemotingServices::IsTransparentProxy(realTarget)) 
            {
                Reflection::Assembly *tasm = Reflection::Assembly::Load(this->targetTypeAssembly);
                Type *tt = tasm->GetType_99cbfcc4e094eb08(this->targetTypeName);
                if(!(tt->IsInstanceOfType_bd709d8c55b4333d(realTarget))) 
                {
                    throw cli::gcnew<Runtime::Remoting::RemotingException>(_T("Unexpected proxy type."));
                }
            }
            del = Delegate::CreateDelegate6(dt, realTarget, this->methodName);
        }
         else 
        {
            Reflection::Assembly *tasm = Reflection::Assembly::Load(this->targetTypeAssembly);
            Type *tt = tasm->GetType_99cbfcc4e094eb08(this->targetTypeName);
            del = Delegate::CreateDelegate8(dt, tt, this->methodName);
        }
        return del;
    }
    
}
namespace System {
    
    
    void DelegateSerializationHolder::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext ctx) {
        DelegateEntry *entryChain = cli::cast<DelegateEntry*>(info->GetValue(_T("Delegate"), cli::typeof<Type>::info));
        int32_t count = 0;
        DelegateEntry *entry = entryChain;
        while((entry != nullptr)) {
            entry = entry->delegateEntry;
            count++;
        }
        if((count ==  1)) 
        {
            this->_delegate = entryChain->DeserializeDelegate(info);
        }
         else 
        {
            cli::array<Delegate*> *delegates = (new cli::array<Delegate*>(count));
            entry = entryChain;
            for(int32_t n = 0; (n < count); n++){
                delegates->at(n) = entry->DeserializeDelegate(info);
                entry = entry->delegateEntry;
            }
            this->_delegate = Delegate::Combine2(delegates);
        }
    }
    
    void DelegateSerializationHolder::GetDelegateData(Delegate* instance, Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext ctx) {
        cli::array<Delegate*> *delegates = instance->GetInvocationList_8fef0390be027d95();
        DelegateEntry *lastEntry = nullptr;
        for(int32_t n = 0; (n < delegates->get_Length()); n++){
            Delegate *del = delegates->at(n);
            String *targetLabel = (del->get_Target() != nullptr) ? cli::concat(_T("target"), cli::box(n)) : nullptr;
            DelegateEntry *entry = cli::gcnew<DelegateEntry>(del, targetLabel);
            if((lastEntry ==  nullptr)) 
            {
                info->AddValue16(_T("Delegate"), entry);
            }
             else 
            {
                lastEntry->delegateEntry = entry;
            }
            lastEntry = entry;
            if((del->get_Target() != nullptr)) 
            {
                info->AddValue16(targetLabel, del->get_Target());
            }
        }
        info->SetType(cli::typeof<Type>::info);
    }
    
    void DelegateSerializationHolder::GetObjectData(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        throw cli::gcnew<NotSupportedException>();
    }
    
    Object* DelegateSerializationHolder::GetRealObject(Runtime::Serialization::StreamingContext context) {
        return this->_delegate;
    }
    
}
namespace System {
    
    
    void DivideByZeroException::constructor() {
        this->set_HResult(-2147352558);
    }
    
    void DivideByZeroException::constructor(String* message) {
        this->set_HResult(-2147352558);
    }
    
    void DivideByZeroException::constructor(String* message, Exception* innerException) {
        this->set_HResult(-2147352558);
    }
    
    void DivideByZeroException::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
    }
    
}
namespace System {
    
    
    void DllNotFoundException::constructor() {
        this->set_HResult(-2146233052);
    }
    
    void DllNotFoundException::constructor(String* message) {
        this->set_HResult(-2146233052);
    }
    
    void DllNotFoundException::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
    }
    
    void DllNotFoundException::constructor(String* message, Exception* inner) {
        this->set_HResult(-2146233052);
    }
    
}
namespace System {
    
    
    void DuplicateWaitObjectException::constructor() {
        this->set_HResult(-2146233047);
    }
    
    void DuplicateWaitObjectException::constructor(String* parameterName) {
        this->set_HResult(-2146233047);
    }
    
    void DuplicateWaitObjectException::constructor(String* parameterName, String* message) {
        this->set_HResult(-2146233047);
    }
    
    void DuplicateWaitObjectException::constructor(String* message, Exception* innerException) {
        this->set_HResult(-2146233047);
    }
    
    void DuplicateWaitObjectException::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
    }
    
}
namespace System {
    
    
    void EntryPointNotFoundException::constructor() {
        this->set_HResult(-2146233053);
    }
    
    void EntryPointNotFoundException::constructor(String* message) {
        this->set_HResult(-2146233053);
    }
    
    void EntryPointNotFoundException::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
    }
    
    void EntryPointNotFoundException::constructor(String* message, Exception* inner) {
        this->set_HResult(-2146233053);
    }
    
}
namespace System {
    
    
    void SByteComparer::constructor() {
    }
    
    int32_t SByteComparer::Compare(Object* x, Object* y) {
        signed char ix = cli::unbox<signed char>(x);
        signed char iy = cli::unbox<signed char>(y);
        return ((int32_t)((unsigned char)ix) - (int32_t)((unsigned char)iy));
    }
    
    int32_t SByteComparer::Compare2(signed char ix, signed char iy) {
        return ((int32_t)((unsigned char)ix) - (int32_t)((unsigned char)iy));
    }
    
}
namespace System {
    
    
    void ShortComparer::constructor() {
    }
    
    int32_t ShortComparer::Compare(Object* x, Object* y) {
        int16_t ix = cli::unbox<int16_t>(x);
        int16_t iy = cli::unbox<int16_t>(y);
        return ((int32_t)((uint16_t)ix) - (int32_t)((uint16_t)iy));
    }
    
    int32_t ShortComparer::Compare2(int16_t ix, int16_t iy) {
        return ((int32_t)((uint16_t)ix) - (int32_t)((uint16_t)iy));
    }
    
}
namespace System {
    
    
    void IntComparer::constructor() {
    }
    
    int32_t IntComparer::Compare(Object* x, Object* y) {
        int32_t ix = cli::unbox<int32_t>(x);
        int32_t iy = cli::unbox<int32_t>(y);
        if((ix ==  iy)) 
        {
            return 0;
        }
        if(((uint32_t)ix < (uint32_t)iy)) 
        {
            return -1;
        }
        return 1;
    }
    
    int32_t IntComparer::Compare2(int32_t ix, int32_t iy) {
        if((ix ==  iy)) 
        {
            return 0;
        }
        if(((uint32_t)ix < (uint32_t)iy)) 
        {
            return -1;
        }
        return 1;
    }
    
}
namespace System {
    
    
    void LongComparer::constructor() {
    }
    
    int32_t LongComparer::Compare(Object* x, Object* y) {
        int64_t ix = cli::unbox<int64_t>(x);
        int64_t iy = cli::unbox<int64_t>(y);
        if((ix ==  iy)) 
        {
            return 0;
        }
        if(((uint64_t)ix < (uint64_t)iy)) 
        {
            return -1;
        }
        return 1;
    }
    
    int32_t LongComparer::Compare2(int64_t ix, int64_t iy) {
        if((ix ==  iy)) 
        {
            return 0;
        }
        if(((uint64_t)ix < (uint64_t)iy)) 
        {
            return -1;
        }
        return 1;
    }
    
}
namespace System {
    
    cli::array<char16_t>*  Enum::split_char;
    
    Enum::Enum()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void Enum::constructor() {
    }
    
    void Enum::static_constructor() {
    }
    
    TypeCode Enum::GetTypeCode() {
        return Type::GetTypeCode(GetUnderlyingType(this->GetType()));
    }
    
    bool Enum::ToBoolean(IFormatProvider* provider) {
        return Convert::ToBoolean18(this->get_Value(), provider);
    }
    
    unsigned char Enum::ToByte(IFormatProvider* provider) {
        return Convert::ToByte19(this->get_Value(), provider);
    }
    
    char16_t Enum::ToChar(IFormatProvider* provider) {
        return Convert::ToChar18(this->get_Value(), provider);
    }
    
    DateTime Enum::ToDateTime(IFormatProvider* provider) {
        return Convert::ToDateTime14(this->get_Value(), provider);
    }
    
    Decimal Enum::ToDecimal(IFormatProvider* provider) {
        return Convert::ToDecimal18(this->get_Value(), provider);
    }
    
    double Enum::ToDouble(IFormatProvider* provider) {
        return Convert::ToDouble18(this->get_Value(), provider);
    }
    
    int16_t Enum::ToInt16(IFormatProvider* provider) {
        return Convert::ToInt1619(this->get_Value(), provider);
    }
    
    int32_t Enum::ToInt32(IFormatProvider* provider) {
        return Convert::ToInt3219(this->get_Value(), provider);
    }
    
    int64_t Enum::ToInt64(IFormatProvider* provider) {
        return Convert::ToInt6419(this->get_Value(), provider);
    }
    
    signed char Enum::ToSByte(IFormatProvider* provider) {
        return Convert::ToSByte19(this->get_Value(), provider);
    }
    
    float Enum::ToSingle(IFormatProvider* provider) {
        return Convert::ToSingle18(this->get_Value(), provider);
    }
    
    Object* Enum::ToType(Type* targetType, IFormatProvider* provider) {
        if(Type::op_Equality2(targetType, nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("targetType"));
        }
        if(Type::op_Equality2(targetType, cli::typeof<Type>::info)) 
        {
            return ToString3(provider);
        }
        return Convert::ToType(this->get_Value(), targetType, provider, false);
    }
    
    uint16_t Enum::ToUInt16(IFormatProvider* provider) {
        return Convert::ToUInt1619(this->get_Value(), provider);
    }
    
    uint32_t Enum::ToUInt32(IFormatProvider* provider) {
        return Convert::ToUInt3219(this->get_Value(), provider);
    }
    
    uint64_t Enum::ToUInt64(IFormatProvider* provider) {
        return Convert::ToUInt6419(this->get_Value(), provider);
    }
    
    Object* Enum::get_value() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    Array* Enum::GetValues(Type* enumType) {
        if(Type::op_Equality2(enumType, nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("enumType"));
        }
        if(!(enumType->get_IsEnum_bc85ea7b0a749db())) 
        {
            throw cli::gcnew<ArgumentException>(_T("enumType is not an Enum type."), _T("enumType"));
        }
        MonoEnumInfo info;
        MonoEnumInfo::GetInfo(enumType, info);
        return cli::cast<Array*>(info->values->Clone());
    }
    
    cli::array<String*>* Enum::GetNames(Type* enumType) {
        if(Type::op_Equality2(enumType, nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("enumType"));
        }
        if(!(enumType->get_IsEnum_bc85ea7b0a749db())) 
        {
            throw cli::gcnew<ArgumentException>(_T("enumType is not an Enum type."));
        }
        MonoEnumInfo info;
        MonoEnumInfo::GetInfo(enumType, info);
        return cli::cast<cli::array<String*>*>(cli::import(info->names)->Clone());
    }
    
    int32_t Enum::FindPosition(Type* enumType, Object* value, Array* values) {
        switch(Type::GetTypeCode(GetUnderlyingType(enumType))) {
            case TypeCode::SByte2: case_635: {
                cli::array<signed char> *sbyte_array = cli::as<cli::array<signed char>*>(values);
                return Array::template BinarySearch_12<signed char>(sbyte_array, cli::unbox<signed char>(value), MonoEnumInfo::sbyte_comparer);
            }
            case TypeCode::Byte2: case_636: {
                cli::array<unsigned char> *byte_array = cli::as<cli::array<unsigned char>*>(values);
                return Array::template BinarySearch_1<unsigned char>(byte_array, cli::unbox<unsigned char>(value));
            }
            case TypeCode::Int162: case_637: {
                cli::array<int16_t> *short_array = cli::as<cli::array<int16_t>*>(values);
                return Array::template BinarySearch_12<int16_t>(short_array, cli::unbox<int16_t>(value), MonoEnumInfo::short_comparer);
            }
            case TypeCode::UInt162: case_638: {
                cli::array<uint16_t> *ushort_array = cli::as<cli::array<uint16_t>*>(values);
                return Array::template BinarySearch_1<uint16_t>(ushort_array, cli::unbox<uint16_t>(value));
            }
            case TypeCode::Int322: case_639: {
                cli::array<int32_t> *int_array = cli::as<cli::array<int32_t>*>(values);
                return Array::template BinarySearch_12<int32_t>(int_array, cli::unbox<int32_t>(value), MonoEnumInfo::int_comparer);
            }
            case TypeCode::UInt322: case_640: {
                cli::array<uint32_t> *uint_array = cli::as<cli::array<uint32_t>*>(values);
                return Array::template BinarySearch_1<uint32_t>(uint_array, cli::unbox<uint32_t>(value));
            }
            case TypeCode::Int642: case_641: {
                cli::array<int64_t> *long_array = cli::as<cli::array<int64_t>*>(values);
                return Array::template BinarySearch_12<int64_t>(long_array, cli::unbox<int64_t>(value), MonoEnumInfo::long_comparer);
            }
            case TypeCode::UInt642: case_642: {
                cli::array<uint64_t> *ulong_array = cli::as<cli::array<uint64_t>*>(values);
                return Array::template BinarySearch_1<uint64_t>(ulong_array, cli::unbox<uint64_t>(value));
            }
            default: case_643: {
                return Array::BinarySearch(values, value);
            }
        }
    }
    
    String* Enum::GetName(Type* enumType, Object* value) {
        if(Type::op_Equality2(enumType, nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("enumType"));
        }
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("value"));
        }
        if(!(enumType->get_IsEnum_bc85ea7b0a749db())) 
        {
            throw cli::gcnew<ArgumentException>(_T("enumType is not an Enum type."), _T("enumType"));
        }
        MonoEnumInfo info;
        value = ToObject5(enumType, value);
        MonoEnumInfo::GetInfo(enumType, info);
        int32_t i = FindPosition(enumType, value, info->values);
        return (i >= 0) ? info->names->at(i) : nullptr;
    }
    
    bool Enum::IsDefined(Type* enumType, Object* value) {
        if(Type::op_Equality2(enumType, nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("enumType"));
        }
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("value"));
        }
        if(!(enumType->get_IsEnum_bc85ea7b0a749db())) 
        {
            throw cli::gcnew<ArgumentException>(_T("enumType is not an Enum type."), _T("enumType"));
        }
        MonoEnumInfo info;
        MonoEnumInfo::GetInfo(enumType, info);
        Type *vType = value->GetType();
        if(Type::op_Equality2(vType, cli::typeof<Type>::info)) 
        {
            return cli::cast<Collections::IList*>(info->names)->Contains_2a2192a595869f4e(value);
        }
         else 
        {
            if((Type::op_Equality2(vType, info->utype) || Type::op_Equality2(vType, enumType))) 
            {
                value = ToObject5(enumType, value);
                MonoEnumInfo::GetInfo(enumType, info);
                return (FindPosition(enumType, value, info->values) >= 0);
            }
             else 
            {
                throw cli::gcnew<ArgumentException>(_T("The value parameter is not the correct type. It must be type String or the same type as the underlying type of the Enum."));
            }
        }
    }
    
    Type* Enum::get_underlying_type(Type* enumType) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    Type* Enum::GetUnderlyingType(Type* enumType) {
        if(Type::op_Equality2(enumType, nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("enumType"));
        }
        if(!(enumType->get_IsEnum_bc85ea7b0a749db())) 
        {
            throw cli::gcnew<ArgumentException>(_T("enumType is not an Enum type."), _T("enumType"));
        }
        return get_underlying_type(enumType);
    }
    
    Object* Enum::Parse(Type* enumType, String* value) {
        return Parse2(enumType, value, false);
    }
    
    int32_t Enum::FindName(Collections::Hashtable* name_hash, cli::array<String*>* names, String* name, bool ignoreCase) {
        if(!(ignoreCase)) 
        {
            if((name_hash != nullptr)) 
            {
                Object *val = name_hash->get_Item_d75c6e706b965758(name);
                if((val != nullptr)) 
                {
                    return cli::unbox<int32_t>(val);
                }
            }
             else 
            {
                for(int32_t i = 0; (i < names->get_Length()); ++i){
                    if(String::op_Equality(name, names->at(i))) 
                    {
                        return i;
                    }
                }
            }
        }
         else 
        {
            for(int32_t i = 0; (i < names->get_Length()); ++i){
                if((String::Compare3(name, names->at(i), ignoreCase, Globalization::CultureInfo::get_InvariantCulture()) ==  0)) 
                {
                    return i;
                }
            }
        }
        return -1;
    }
    
    uint64_t Enum::GetValue(Object* value, TypeCode typeCode) {
        switch(typeCode) {
            case TypeCode::Byte2: case_644: {
                return (uint64_t)(cli::unbox<unsigned char>(value));
            }
            case TypeCode::SByte2: case_645: {
                return (uint64_t)((unsigned char)cli::unbox<signed char>(value));
            }
            case TypeCode::Int162: case_646: {
                return (uint64_t)((uint16_t)cli::unbox<int16_t>(value));
            }
            case TypeCode::Int322: case_647: {
                return (uint64_t)((uint32_t)cli::unbox<int32_t>(value));
            }
            case TypeCode::Int642: case_648: {
                return (uint64_t)cli::unbox<int64_t>(value);
            }
            case TypeCode::UInt162: case_649: {
                return (uint64_t)(cli::unbox<uint16_t>(value));
            }
            case TypeCode::UInt322: case_650: {
                return (uint64_t)(cli::unbox<uint32_t>(value));
            }
            case TypeCode::UInt642: case_651: {
                return cli::unbox<uint64_t>(value);
            }
        }
        throw cli::gcnew<ArgumentException>(_T("typeCode is not a valid type code for an Enum"));
    }
    
    Object* Enum::Parse2(Type* enumType, String* value, bool ignoreCase) {
        if(Type::op_Equality2(enumType, nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("enumType"));
        }
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("value"));
        }
        if(!(enumType->get_IsEnum_bc85ea7b0a749db())) 
        {
            throw cli::gcnew<ArgumentException>(_T("enumType is not an Enum type."), _T("enumType"));
        }
        value = value->Trim();
        if((value->get_Length() ==  0)) 
        {
            throw cli::gcnew<ArgumentException>(_T("An empty string is not considered a valid value."));
        }
        Object *result;
        if(!(Parse_1<Object*>(enumType, value, ignoreCase, result))) 
        {
            throw cli::gcnew<ArgumentException>(String::Format2(_T("The requested value \'{0}\' was not found."), value));
        }
        return result;
    }
    
    int32_t Enum::compare_value_to(Object* other) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t Enum::CompareTo(Object* target) {
        Type *thisType;
        if((target ==  nullptr)) 
        {
            return 1;
        }
        thisType = this->GetType();
        if(Type::op_Inequality2(target->GetType(), thisType)) 
        {
            throw cli::gcnew<ArgumentException>(String::Format3(_T("Object must be the same type as the enum. The type passed in was {0}; the enum type was {1}."), target->GetType(), thisType));
        }
        return compare_value_to(target);
    }
    
    String* Enum::ToString_1636a0751cb9ac11() {
        return ToString4(_T("G"));
    }
    
    String* Enum::ToString3(IFormatProvider* provider) {
        return ToString5(_T("G"), provider);
    }
    
    String* Enum::ToString4(String* format) {
        if((String::op_Equality(format, String::Empty) || (format ==  nullptr))) 
        {
            format = _T("G");
        }
        return Format2(this->GetType(), this->get_Value(), format);
    }
    
    String* Enum::ToString5(String* format, IFormatProvider* provider) {
        if((String::op_Equality(format, String::Empty) || (format ==  nullptr))) 
        {
            format = _T("G");
        }
        return Format2(this->GetType(), this->get_Value(), format);
    }
    
    Object* Enum::ToObject(Type* enumType, unsigned char value) {
        return ToObject5(enumType, cli::box(value));
    }
    
    Object* Enum::ToObject2(Type* enumType, int16_t value) {
        return ToObject5(enumType, cli::box(value));
    }
    
    Object* Enum::ToObject3(Type* enumType, int32_t value) {
        return ToObject5(enumType, cli::box(value));
    }
    
    Object* Enum::ToObject4(Type* enumType, int64_t value) {
        return ToObject5(enumType, cli::box(value));
    }
    
    Object* Enum::ToObject5(Type* enumType, Object* value) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    Object* Enum::ToObject6(Type* enumType, signed char value) {
        return ToObject5(enumType, cli::box(value));
    }
    
    Object* Enum::ToObject7(Type* enumType, uint16_t value) {
        return ToObject5(enumType, cli::box(value));
    }
    
    Object* Enum::ToObject8(Type* enumType, uint32_t value) {
        return ToObject5(enumType, cli::box(value));
    }
    
    Object* Enum::ToObject9(Type* enumType, uint64_t value) {
        return ToObject5(enumType, cli::box(value));
    }
    
    bool Enum::Equals_ed975d2f4a7d193e(Object* obj) {
        return ValueType::DefaultEquals(this, obj);
    }
    
    int32_t Enum::get_hashcode() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t Enum::GetHashCode_6648aef0f235ee6c() {
        return get_hashcode();
    }
    
    String* Enum::FormatSpecifier_X(Type* enumType, Object* value, bool upper) {
        switch(Type::GetTypeCode(enumType)) {
            case TypeCode::SByte2: case_652: {
                return cli::import(cli::unbox<signed char>(value))->ToString4(upper ? _T("X2") : _T("x2"));
            }
            case TypeCode::Byte2: case_653: {
                return cli::import(cli::unbox<unsigned char>(value))->ToString3(upper ? _T("X2") : _T("x2"));
            }
            case TypeCode::Int162: case_654: {
                return cli::import(cli::unbox<int16_t>(value))->ToString4(upper ? _T("X4") : _T("x4"));
            }
            case TypeCode::UInt162: case_655: {
                return cli::import(cli::unbox<uint16_t>(value))->ToString4(upper ? _T("X4") : _T("x4"));
            }
            case TypeCode::Int322: case_656: {
                return cli::import(cli::unbox<int32_t>(value))->ToString4(upper ? _T("X8") : _T("x8"));
            }
            case TypeCode::UInt322: case_657: {
                return cli::import(cli::unbox<uint32_t>(value))->ToString4(upper ? _T("X8") : _T("x8"));
            }
            case TypeCode::Int642: case_658: {
                return cli::import(cli::unbox<int64_t>(value))->ToString4(upper ? _T("X16") : _T("x16"));
            }
            case TypeCode::UInt642: case_659: {
                return cli::import(cli::unbox<uint64_t>(value))->ToString4(upper ? _T("X16") : _T("x16"));
            }
            default: case_660: {
                throw cli::gcnew<Exception>(_T("Invalid type code for enumeration."));
            }
        }
    }
    
    String* Enum::FormatFlags(Type* enumType, Object* value) {
        String *retVal = String::Empty;
        MonoEnumInfo info;
        MonoEnumInfo::GetInfo(enumType, info);
        String *asString = value->ToString_1636a0751cb9ac11();
        if(String::op_Equality(asString, _T("0"))) 
        {
            retVal = GetName(enumType, value);
            if((retVal ==  nullptr)) 
            {
                retVal = asString;
            }
            return retVal;
        }
        switch(cli::cast<Enum*>(info->values->GetValue2(0))->GetTypeCode()) {
            case TypeCode::SByte2: case_661: {
                {
                    signed char flags = cli::unbox<signed char>(value);
                    signed char enumValue;
                    for(int32_t i = (info->values->get_Length() - 1); (i >= 0); i--){
                        enumValue = cli::unbox<signed char>(info->values->GetValue2(i));
                        if(((int32_t)(enumValue) ==  0)) 
                        {
                            continue;
                        }
                        if((((int32_t)(flags) & (int32_t)(enumValue)) ==  (int32_t)(enumValue))) 
                        {
                            retVal = cli::concat(info->names->at(i), String::op_Equality(retVal, String::Empty) ? String::Empty : _T(", "));
                            (flags = (signed char)((int32_t)(flags) - (int32_t)(enumValue)));
                        }
                    }
                    if(((int32_t)(flags) != 0)) 
                    {
                        return asString;
                    }
                }
                break;
            }
            case TypeCode::Byte2: case_662: {
                {
                    unsigned char flags = cli::unbox<unsigned char>(value);
                    unsigned char enumValue;
                    for(int32_t i = (info->values->get_Length() - 1); (i >= 0); i--){
                        enumValue = cli::unbox<unsigned char>(info->values->GetValue2(i));
                        if(((int32_t)(enumValue) ==  0)) 
                        {
                            continue;
                        }
                        if((((int32_t)(flags) & (int32_t)(enumValue)) ==  (int32_t)(enumValue))) 
                        {
                            retVal = cli::concat(info->names->at(i), String::op_Equality(retVal, String::Empty) ? String::Empty : _T(", "));
                            (flags = (unsigned char)((int32_t)(flags) - (int32_t)(enumValue)));
                        }
                    }
                    if(((int32_t)(flags) != 0)) 
                    {
                        return asString;
                    }
                }
                break;
            }
            case TypeCode::Int162: case_663: {
                {
                    int16_t flags = cli::unbox<int16_t>(value);
                    int16_t enumValue;
                    for(int32_t i = (info->values->get_Length() - 1); (i >= 0); i--){
                        enumValue = cli::unbox<int16_t>(info->values->GetValue2(i));
                        if(((int32_t)(enumValue) ==  0)) 
                        {
                            continue;
                        }
                        if((((int32_t)(flags) & (int32_t)(enumValue)) ==  (int32_t)(enumValue))) 
                        {
                            retVal = cli::concat(info->names->at(i), String::op_Equality(retVal, String::Empty) ? String::Empty : _T(", "));
                            (flags = (int16_t)((int32_t)(flags) - (int32_t)(enumValue)));
                        }
                    }
                    if(((int32_t)(flags) != 0)) 
                    {
                        return asString;
                    }
                }
                break;
            }
            case TypeCode::Int322: case_664: {
                {
                    int32_t flags = cli::unbox<int32_t>(value);
                    int32_t enumValue;
                    for(int32_t i = (info->values->get_Length() - 1); (i >= 0); i--){
                        enumValue = cli::unbox<int32_t>(info->values->GetValue2(i));
                        if((enumValue ==  0)) 
                        {
                            continue;
                        }
                        if(((flags & enumValue) ==  enumValue)) 
                        {
                            retVal = cli::concat(info->names->at(i), String::op_Equality(retVal, String::Empty) ? String::Empty : _T(", "));
                            (flags = flags - enumValue);
                        }
                    }
                    if((flags != 0)) 
                    {
                        return asString;
                    }
                }
                break;
            }
            case TypeCode::UInt162: case_665: {
                {
                    uint16_t flags = cli::unbox<uint16_t>(value);
                    uint16_t enumValue;
                    for(int32_t i = (info->values->get_Length() - 1); (i >= 0); i--){
                        enumValue = cli::unbox<uint16_t>(info->values->GetValue2(i));
                        if(((int32_t)(enumValue) ==  0)) 
                        {
                            continue;
                        }
                        if((((int32_t)(flags) & (int32_t)(enumValue)) ==  (int32_t)(enumValue))) 
                        {
                            retVal = cli::concat(info->names->at(i), String::op_Equality(retVal, String::Empty) ? String::Empty : _T(", "));
                            (flags = (uint16_t)((int32_t)(flags) - (int32_t)(enumValue)));
                        }
                    }
                    if(((int32_t)(flags) != 0)) 
                    {
                        return asString;
                    }
                }
                break;
            }
            case TypeCode::UInt322: case_666: {
                {
                    uint32_t flags = cli::unbox<uint32_t>(value);
                    uint32_t enumValue;
                    for(int32_t i = (info->values->get_Length() - 1); (i >= 0); i--){
                        enumValue = cli::unbox<uint32_t>(info->values->GetValue2(i));
                        if((enumValue ==  0U)) 
                        {
                            continue;
                        }
                        if(((flags & enumValue) ==  enumValue)) 
                        {
                            retVal = cli::concat(info->names->at(i), String::op_Equality(retVal, String::Empty) ? String::Empty : _T(", "));
                            (flags = flags - enumValue);
                        }
                    }
                    if((flags != 0U)) 
                    {
                        return asString;
                    }
                }
                break;
            }
            case TypeCode::Int642: case_667: {
                {
                    int64_t flags = cli::unbox<int64_t>(value);
                    int64_t enumValue;
                    for(int32_t i = (info->values->get_Length() - 1); (i >= 0); i--){
                        enumValue = cli::unbox<int64_t>(info->values->GetValue2(i));
                        if((enumValue ==  0L)) 
                        {
                            continue;
                        }
                        if(((flags & enumValue) ==  enumValue)) 
                        {
                            retVal = cli::concat(info->names->at(i), String::op_Equality(retVal, String::Empty) ? String::Empty : _T(", "));
                            (flags = flags - enumValue);
                        }
                    }
                    if((flags != 0L)) 
                    {
                        return asString;
                    }
                }
                break;
            }
            case TypeCode::UInt642: case_668: {
                {
                    uint64_t flags = cli::unbox<uint64_t>(value);
                    uint64_t enumValue;
                    for(int32_t i = (info->values->get_Length() - 1); (i >= 0); i--){
                        enumValue = cli::unbox<uint64_t>(info->values->GetValue2(i));
                        if((enumValue ==  0UL)) 
                        {
                            continue;
                        }
                        if(((flags & enumValue) ==  enumValue)) 
                        {
                            retVal = cli::concat(info->names->at(i), String::op_Equality(retVal, String::Empty) ? String::Empty : _T(", "));
                            (flags = flags - enumValue);
                        }
                    }
                    if((flags != 0UL)) 
                    {
                        return asString;
                    }
                }
                break;
            }
        }
        if(String::op_Equality(retVal, String::Empty)) 
        {
            return asString;
        }
        return retVal;
    }
    
    String* Enum::Format2(Type* enumType, Object* value, String* format) {
        if(Type::op_Equality2(enumType, nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("enumType"));
        }
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("value"));
        }
        if((format ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("format"));
        }
        if(!(enumType->get_IsEnum_bc85ea7b0a749db())) 
        {
            throw cli::gcnew<ArgumentException>(_T("enumType is not an Enum type."), _T("enumType"));
        }
        Type *vType = value->GetType();
        Type *underlyingType = Enum::GetUnderlyingType(enumType);
        if(vType->get_IsEnum_bc85ea7b0a749db()) 
        {
            if(Type::op_Inequality2(vType, enumType)) 
            {
                throw cli::gcnew<ArgumentException>(String::Format6(Globalization::CultureInfo::get_InvariantCulture(), _T("Object must be the same type as the enum. The type passed in was {0}; the enum type was {1}."), (new cli::array<Object*>({vType->get_FullName_7e8fa72ba225e1a4(), enumType->get_FullName_7e8fa72ba225e1a4()}))));
            }
        }
         else 
        {
            if(Type::op_Inequality2(vType, underlyingType)) 
            {
                throw cli::gcnew<ArgumentException>(String::Format6(Globalization::CultureInfo::get_InvariantCulture(), _T("Enum underlying type and the object must be the same type or object. Type passed in was {0}; the enum underlying type was {1}."), (new cli::array<Object*>({vType->get_FullName_7e8fa72ba225e1a4(), underlyingType->get_FullName_7e8fa72ba225e1a4()}))));
            }
        }
        if((format->get_Length() != 1)) 
        {
            throw cli::gcnew<FormatException>(_T("Format String can be only \"G\",\"g\",\"X\",\"x\",\"F\",\"f\",\"D\" or \"d\"."));
        }
        char16_t formatChar = format->get_Chars(0);
        String *retVal;
        if((((int32_t)(formatChar) ==  71) || ((int32_t)(formatChar) ==  103))) 
        {
            if(!(enumType->IsDefined_91943a8ac363f11f(cli::typeof<Type>::info, false))) 
            {
                retVal = GetName(enumType, value);
                if((retVal ==  nullptr)) 
                {
                    retVal = value->ToString_1636a0751cb9ac11();
                }
                return retVal;
            }
            formatChar = u'f';
        }
        if((((int32_t)(formatChar) ==  102) || ((int32_t)(formatChar) ==  70))) 
        {
            return FormatFlags(enumType, value);
        }
        retVal = String::Empty;
        switch(formatChar) {
            case u'X': case_669: {
                retVal = FormatSpecifier_X(enumType, value, true);
                break;
            }
            case u'x': case_670: {
                retVal = FormatSpecifier_X(enumType, value, false);
                break;
            }
            case u'D': case u'd': case_671: {
                if(Type::op_Equality2(underlyingType, cli::typeof<Type>::info)) 
                {
                    uint64_t ulongValue = Convert::ToUInt6418(value);
                    retVal = cli::import(ulongValue)->ToString_1636a0751cb9ac11();
                }
                 else 
                {
                    int64_t longValue = Convert::ToInt6418(value);
                    retVal = cli::import(longValue)->ToString_1636a0751cb9ac11();
                }
                break;
            }
            default: case_672: {
                throw cli::gcnew<FormatException>(_T("Format String can be only \"G\",\"g\",\"X\",\"x\",\"F\",\"f\",\"D\" or \"d\"."));
            }
        }
        return retVal;
    }
    
    bool Enum::HasFlag(Enum* flag) {
        Object *val = get_value();
        uint64_t mvalue = GetValue(val, Type::GetTypeCode(val->GetType()));
        uint64_t fvalue = GetValue(flag, Type::GetTypeCode(flag->GetType()));
        return ((mvalue & fvalue) ==  fvalue);
    }
    
    Object* Enum::get_Value() {
        return get_value();
    }
    
}
namespace System {
    
    String*  Environment::nl;
    OperatingSystem*  Environment::os;
    
    String* Environment::GetNewLine() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    String* Environment::GetOSVersionString() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Environment::Exit(int32_t exitCode) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    String* Environment::ExpandEnvironmentVariables(String* name) {
        if((name ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("name"));
        }
        int32_t off1 = name->IndexOf4(u'%');
        if((off1 ==  -1)) 
        {
            return name;
        }
        int32_t len = name->get_Length();
        int32_t off2 = 0;
        if(((off1 ==  (len - 1)) || ((off2 = name->IndexOf5(u'%', (off1 + 1))) ==  (-1)))) 
        {
            return name;
        }
        Text::StringBuilder *result = cli::gcnew<Text::StringBuilder>();
        result->Append19(name, 0, off1);
        Collections::Hashtable *tbl = nullptr;
        do {
            String *var = name->Substring2((off1 + 1), ((off2 - off1) - 1));
            String *value = GetEnvironmentVariable(var);
            if(((value ==  nullptr) && Environment::get_IsRunningOnWindows())) 
            {
                if((tbl ==  nullptr)) 
                {
                    tbl = GetEnvironmentVariablesNoCase();
                }
                value = cli::as<String*>(tbl->get_Item_d75c6e706b965758(var));
            }
            if((value ==  nullptr)) 
            {
                result->Append16(u'%');
                result->Append2(var);
                off2--;
            }
             else 
            {
                result->Append2(value);
            }
            int32_t oldOff2 = off2;
            off1 = name->IndexOf5(u'%', (off2 + 1));
            off2 = ((off1 ==  -1) || (off2 > (len - 1))) ? -1 : name->IndexOf5(u'%', (off1 + 1));
            int32_t textLen;
            if(((off1 ==  -1) || (off2 ==  -1))) 
            {
                textLen = ((len - oldOff2) - 1);
            }
             else 
            {
                if((value != nullptr)) 
                {
                    textLen = ((off1 - oldOff2) - 1);
                }
                 else 
                {
                    textLen = (off1 - oldOff2);
                }
            }
            if(((off1 >= oldOff2) || (off1 ==  -1))) 
            {
                result->Append19(name, (oldOff2 + 1), textLen);
            }
        }
        while(((off2 > -1) && (off2 < len)));
        return result->ToString_1636a0751cb9ac11();
    }
    
    cli::array<String*>* Environment::GetCommandLineArgs() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    String* Environment::internalGetEnvironmentVariable(String* variable) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    String* Environment::GetEnvironmentVariable(String* variable) {
        if(Security::SecurityManager::get_SecurityEnabled()) 
        {
            cli::gcnew<Security::Permissions::EnvironmentPermission>(Security::Permissions::EnvironmentPermissionAccess::Read, variable)->Demand();
        }
        return internalGetEnvironmentVariable(variable);
    }
    
    Collections::Hashtable* Environment::GetEnvironmentVariablesNoCase() {
        Collections::Hashtable *vars = cli::gcnew<Collections::Hashtable>(Collections::CaseInsensitiveHashCodeProvider::get_Default(), Collections::CaseInsensitiveComparer::get_Default());
        for(auto tmp_163 : GetEnvironmentVariableNames()) {
            auto name = cli::cast<String*>(tmp_163);
            {
                vars->set_Item_84c7e24d9caa09(name, internalGetEnvironmentVariable(name));
            }
        }
        return vars;
    }
    
    Collections::IDictionary* Environment::GetEnvironmentVariables() {
        Text::StringBuilder *sb = nullptr;
        if(Security::SecurityManager::get_SecurityEnabled()) 
        {
            sb = cli::gcnew<Text::StringBuilder>();
        }
        Collections::Hashtable *vars = cli::gcnew<Collections::Hashtable>();
        for(auto tmp_164 : GetEnvironmentVariableNames()) {
            auto name = cli::cast<String*>(tmp_164);
            {
                vars->set_Item_84c7e24d9caa09(name, internalGetEnvironmentVariable(name));
                if((sb != nullptr)) 
                {
                    sb->Append2(name);
                    sb->Append2(_T(";"));
                }
            }
        }
        if((sb != nullptr)) 
        {
            cli::gcnew<Security::Permissions::EnvironmentPermission>(Security::Permissions::EnvironmentPermissionAccess::Read, sb->ToString_1636a0751cb9ac11())->Demand();
        }
        return vars;
    }
    
    String* Environment::GetWindowsFolderPath(int32_t folder) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    String* Environment::GetFolderPath(SpecialFolder folder) {
        return GetFolderPath2(folder, SpecialFolderOption::None);
    }
    
    String* Environment::GetFolderPath2(SpecialFolder folder, SpecialFolderOption option) {
        Security::SecurityManager::EnsureElevatedPermissions();
        String *dir = nullptr;
        if(Environment::get_IsRunningOnWindows()) 
        {
            dir = GetWindowsFolderPath((int32_t)(folder));
        }
         else 
        {
            dir = UnixGetFolderPath(folder, option);
        }
        if((((dir != nullptr) && (dir->get_Length() > 0)) && Security::SecurityManager::get_SecurityEnabled())) 
        {
            cli::gcnew<Security::Permissions::FileIOPermission>(Security::Permissions::FileIOPermissionAccess::PathDiscovery, dir)->Demand();
        }
        return dir;
    }
    
    String* Environment::ReadXdgUserDir(String* config_dir, String* home_dir, String* key, String* fallback) {
        String *env_path = internalGetEnvironmentVariable(key);
        if(((env_path != nullptr) && String::op_Inequality(env_path, String::Empty))) 
        {
            return env_path;
        }
        String *user_dirs_path = IO::Path::Combine(config_dir, _T("user-dirs.dirs"));
        if(!(IO::File::Exists(user_dirs_path))) 
        {
            return IO::Path::Combine(home_dir, fallback);
        }
        try {
            {
                /* USING - BLOCK */
                auto reader = cli::gcnew<IO::StreamReader>(user_dirs_path);
                cli::using_guard{reader};
                String *line;
                while(((line = reader->ReadLine_51552a49261f929e()) != (nullptr))) {
                    line = line->Trim();
                    int32_t delim_index = line->IndexOf4(u'=');
                    if(((delim_index > 8) && String::op_Equality(line->Substring2(0, delim_index), key))) 
                    {
                        String *path = line->Substring((delim_index + 1))->Trim2((new cli::array<char16_t>({u'"'})));
                        bool relative = false;
                        if(path->StartsWith(_T("$HOME/"))) 
                        {
                            relative = true;
                            path = path->Substring(6);
                        }
                         else 
                        {
                            if(!(path->StartsWith(_T("/")))) 
                            {
                                relative = true;
                            }
                        }
                        return relative ? IO::Path::Combine(home_dir, path) : path;
                    }
                }
            }
        }
        catch(IO::FileNotFoundException*) {
        }
        return IO::Path::Combine(home_dir, fallback);
    }
    
    String* Environment::UnixGetFolderPath(SpecialFolder folder, SpecialFolderOption option) {
        String *home = internalGetHome();
        String *data = internalGetEnvironmentVariable(_T("XDG_DATA_HOME"));
        if(((data ==  nullptr) || String::op_Equality(data, String::Empty))) 
        {
            data = IO::Path::Combine(home, _T(".local"));
            data = IO::Path::Combine(data, _T("share"));
        }
        String *config = internalGetEnvironmentVariable(_T("XDG_CONFIG_HOME"));
        if(((config ==  nullptr) || String::op_Equality(config, String::Empty))) 
        {
            config = IO::Path::Combine(home, _T(".config"));
        }
        switch(folder) {
            case SpecialFolder::MyComputer: case_673: {
                return String::Empty;
            }
            case SpecialFolder::MyDocuments: case_674: {
                return home;
            }
            case SpecialFolder::ApplicationData: case_675: {
                return config;
            }
            case SpecialFolder::LocalApplicationData: case_676: {
                return data;
            }
            case SpecialFolder::Desktop: case SpecialFolder::DesktopDirectory: case_677: {
                return ReadXdgUserDir(config, home, _T("XDG_DESKTOP_DIR"), _T("Desktop"));
            }
            case SpecialFolder::MyMusic: case_678: {
                if(((int32_t)(Environment::get_Platform()) ==  6)) 
                {
                    return IO::Path::Combine(home, _T("Music"));
                }
                 else 
                {
                    return ReadXdgUserDir(config, home, _T("XDG_MUSIC_DIR"), _T("Music"));
                }
            }
            case SpecialFolder::MyPictures: case_679: {
                if(((int32_t)(Environment::get_Platform()) ==  6)) 
                {
                    return IO::Path::Combine(home, _T("Pictures"));
                }
                 else 
                {
                    return ReadXdgUserDir(config, home, _T("XDG_PICTURES_DIR"), _T("Pictures"));
                }
            }
            case SpecialFolder::Templates: case_680: {
                return ReadXdgUserDir(config, home, _T("XDG_TEMPLATES_DIR"), _T("Templates"));
            }
            case SpecialFolder::MyVideos: case_681: {
                return ReadXdgUserDir(config, home, _T("XDG_VIDEOS_DIR"), _T("Videos"));
            }
            case SpecialFolder::CommonTemplates: case_682: {
                return _T("/usr/share/templates");
            }
            case SpecialFolder::Fonts: case_683: {
                if(((int32_t)(Environment::get_Platform()) ==  6)) 
                {
                    return IO::Path::Combine3(home, _T("Library"), _T("Fonts"));
                }
                return IO::Path::Combine(home, _T(".fonts"));
            }
            case SpecialFolder::Favorites: case_684: {
                if(((int32_t)(Environment::get_Platform()) ==  6)) 
                {
                    return IO::Path::Combine3(home, _T("Library"), _T("Favorites"));
                }
                 else 
                {
                    return String::Empty;
                }
            }
            case SpecialFolder::ProgramFiles: case_685: {
                if(((int32_t)(Environment::get_Platform()) ==  6)) 
                {
                    return _T("/Applications");
                }
                 else 
                {
                    return String::Empty;
                }
            }
            case SpecialFolder::InternetCache: case_686: {
                if(((int32_t)(Environment::get_Platform()) ==  6)) 
                {
                    return IO::Path::Combine3(home, _T("Library"), _T("Caches"));
                }
                 else 
                {
                    return String::Empty;
                }
            }
            case SpecialFolder::UserProfile: case_687: {
                return home;
            }
            case SpecialFolder::Programs: case SpecialFolder::SendTo: case SpecialFolder::StartMenu: case SpecialFolder::Startup: case SpecialFolder::Cookies: case SpecialFolder::History: case SpecialFolder::Recent: case SpecialFolder::CommonProgramFiles: case SpecialFolder::System: case SpecialFolder::NetworkShortcuts: case SpecialFolder::CommonStartMenu: case SpecialFolder::CommonPrograms: case SpecialFolder::CommonStartup: case SpecialFolder::CommonDesktopDirectory: case SpecialFolder::PrinterShortcuts: case SpecialFolder::Windows: case SpecialFolder::SystemX86: case SpecialFolder::ProgramFilesX86: case SpecialFolder::CommonProgramFilesX86: case SpecialFolder::CommonDocuments: case SpecialFolder::CommonAdminTools: case SpecialFolder::AdminTools: case SpecialFolder::CommonMusic: case SpecialFolder::CommonPictures: case SpecialFolder::CommonVideos: case SpecialFolder::Resources: case SpecialFolder::LocalizedResources: case SpecialFolder::CommonOemLinks: case SpecialFolder::CDBurning: case_688: {
                return String::Empty;
            }
            case SpecialFolder::CommonApplicationData: case_689: {
                return _T("/usr/share");
            }
            default: case_690: {
                throw cli::gcnew<ArgumentException>(_T("Invalid SpecialFolder"));
            }
        }
    }
    
    cli::array<String*>* Environment::GetLogicalDrives() {
        return GetLogicalDrivesInternal();
    }
    
    void Environment::internalBroadcastSettingChange() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    String* Environment::GetEnvironmentVariable2(String* variable, EnvironmentVariableTarget target) {
        switch(target) {
            case EnvironmentVariableTarget::Process: case_691: {
                return GetEnvironmentVariable(variable);
            }
            case EnvironmentVariableTarget::Machine: case_692: {
                cli::gcnew<Security::Permissions::EnvironmentPermission>(Security::Permissions::PermissionState::Unrestricted)->Demand();
                if(!(Environment::get_IsRunningOnWindows())) 
                {
                    return nullptr;
                }
                {
                    /* USING - BLOCK */
                    auto env = Microsoft::Win32::Registry::LocalMachine->OpenSubKey(_T("SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment"));
                    cli::using_guard{env};
                    Object *regvalue = env->GetValue(variable);
                    return (regvalue ==  nullptr) ? nullptr : regvalue->ToString_1636a0751cb9ac11();
                }
            }
            case EnvironmentVariableTarget::User: case_693: {
                cli::gcnew<Security::Permissions::EnvironmentPermission>(Security::Permissions::PermissionState::Unrestricted)->Demand();
                if(!(Environment::get_IsRunningOnWindows())) 
                {
                    return nullptr;
                }
                {
                    /* USING - BLOCK */
                    auto env = Microsoft::Win32::Registry::CurrentUser->OpenSubKey2(_T("Environment"), false);
                    cli::using_guard{env};
                    Object *regvalue = env->GetValue(variable);
                    return (regvalue ==  nullptr) ? nullptr : regvalue->ToString_1636a0751cb9ac11();
                }
            }
            default: case_694: {
                throw cli::gcnew<ArgumentException>(_T("target"));
            }
        }
    }
    
    Collections::IDictionary* Environment::GetEnvironmentVariables2(EnvironmentVariableTarget target) {
        Collections::IDictionary *variables = cli::cast<Collections::IDictionary*>(cli::gcnew<Collections::Hashtable>());
        switch(target) {
            case EnvironmentVariableTarget::Process: case_695: {
                variables = GetEnvironmentVariables();
                break;
            }
            case EnvironmentVariableTarget::Machine: case_696: {
                cli::gcnew<Security::Permissions::EnvironmentPermission>(Security::Permissions::PermissionState::Unrestricted)->Demand();
                if(Environment::get_IsRunningOnWindows()) 
                {
                    {
                        /* USING - BLOCK */
                        auto env = Microsoft::Win32::Registry::LocalMachine->OpenSubKey(_T("SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment"));
                        cli::using_guard{env};
                        cli::array<String*> *value_names = env->GetValueNames();
                        for(auto tmp_165 : value_names) {
                            auto value_name = cli::cast<String*>(tmp_165);
                            variables->Add_642542cf7a4cae38(value_name, env->GetValue(value_name));
                        }
                    }
                }
                break;
            }
            case EnvironmentVariableTarget::User: case_697: {
                cli::gcnew<Security::Permissions::EnvironmentPermission>(Security::Permissions::PermissionState::Unrestricted)->Demand();
                if(Environment::get_IsRunningOnWindows()) 
                {
                    {
                        /* USING - BLOCK */
                        auto env = Microsoft::Win32::Registry::CurrentUser->OpenSubKey(_T("Environment"));
                        cli::using_guard{env};
                        cli::array<String*> *value_names = env->GetValueNames();
                        for(auto tmp_166 : value_names) {
                            auto value_name = cli::cast<String*>(tmp_166);
                            variables->Add_642542cf7a4cae38(value_name, env->GetValue(value_name));
                        }
                    }
                }
                break;
            }
            default: case_698: {
                throw cli::gcnew<ArgumentException>(_T("target"));
            }
        }
        return variables;
    }
    
    void Environment::SetEnvironmentVariable(String* variable, String* value) {
        SetEnvironmentVariable2(variable, value, EnvironmentVariableTarget::Process);
    }
    
    void Environment::SetEnvironmentVariable2(String* variable, String* value, EnvironmentVariableTarget target) {
        if((variable ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("variable"));
        }
        if(String::op_Equality(variable, String::Empty)) 
        {
            throw cli::gcnew<ArgumentException>(_T("String cannot be of zero length."), _T("variable"));
        }
        if((variable->IndexOf4(u'=') != -1)) 
        {
            throw cli::gcnew<ArgumentException>(_T("Environment variable name cannot contain an equal character."), _T("variable"));
        }
        if(((int32_t)(variable->get_Chars(0)) ==  0)) 
        {
            throw cli::gcnew<ArgumentException>(_T("The first char in the string is the null character."), _T("variable"));
        }
        switch(target) {
            case EnvironmentVariableTarget::Process: case_699: {
                InternalSetEnvironmentVariable(variable, value);
                break;
            }
            case EnvironmentVariableTarget::Machine: case_700: {
                if(!(Environment::get_IsRunningOnWindows())) 
                {
                    return;
                }
                {
                    /* USING - BLOCK */
                    auto env = Microsoft::Win32::Registry::LocalMachine->OpenSubKey2(_T("SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment"), true);
                    cli::using_guard{env};
                    if(String::IsNullOrEmpty(value)) 
                    {
                        env->DeleteValue2(variable, false);
                    }
                     else 
                    {
                        env->SetValue(variable, value);
                    }
                    internalBroadcastSettingChange();
                }
                break;
            }
            case EnvironmentVariableTarget::User: case_701: {
                if(!(Environment::get_IsRunningOnWindows())) 
                {
                    return;
                }
                {
                    /* USING - BLOCK */
                    auto env = Microsoft::Win32::Registry::CurrentUser->OpenSubKey2(_T("Environment"), true);
                    cli::using_guard{env};
                    if(String::IsNullOrEmpty(value)) 
                    {
                        env->DeleteValue2(variable, false);
                    }
                     else 
                    {
                        env->SetValue(variable, value);
                    }
                    internalBroadcastSettingChange();
                }
                break;
            }
            default: case_702: {
                throw cli::gcnew<ArgumentException>(_T("target"));
            }
        }
    }
    
    void Environment::InternalSetEnvironmentVariable(String* variable, String* value) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Environment::FailFast(String* message) {
        throw cli::gcnew<NotImplementedException>();
    }
    
    void Environment::FailFast2(String* message, Exception* exception) {
        throw cli::gcnew<NotImplementedException>();
    }
    
    String* Environment::internalGetGacPath() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    cli::array<String*>* Environment::GetLogicalDrivesInternal() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    cli::array<String*>* Environment::GetEnvironmentVariableNames() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    String* Environment::GetMachineConfigPath() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    String* Environment::internalGetHome() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t Environment::GetPageSize() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    String* Environment::get_CommandLine() {
        Text::StringBuilder *sb = cli::gcnew<Text::StringBuilder>();
        for(auto tmp_167 : GetCommandLineArgs()) {
            auto str = cli::cast<String*>(tmp_167);
            {
                bool escape = false;
                String *quote = _T("");
                String *s = str;
                for(int32_t i = 0; (i < s->get_Length()); i++){
                    if(((quote->get_Length() ==  0) && Char::IsWhiteSpace(s->get_Chars(i)))) 
                    {
                        quote = _T("\"");
                    }
                     else 
                    {
                        if(((int32_t)(s->get_Chars(i)) ==  34)) 
                        {
                            escape = true;
                        }
                    }
                }
                if((escape && (quote->get_Length() != 0))) 
                {
                    s = s->Replace2(_T("\""), _T("\\\""));
                }
                sb->AppendFormat4(_T("{0}{1}{0} "), quote, s);
            }
        }
        if((sb->get_Length() > 0)) 
        {
            [&]() { auto tmp_168 = sb->get_Length(); sb->set_Length(tmp_168 - 1); return tmp_168; }();
        }
        return sb->ToString_1636a0751cb9ac11();
    }
    
    String* Environment::get_CurrentDirectory() {
        return IO::Directory::GetCurrentDirectory();
    }
    
    String* Environment::set_CurrentDirectory(String* value) {
        IO::Directory::SetCurrentDirectory(value);
        return get_CurrentDirectory();
    }
    
    int32_t Environment::get_ExitCode() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t Environment::set_ExitCode(int32_t value) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool Environment::get_HasShutdownStarted() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    String* Environment::get_MachineName() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    String* Environment::get_NewLine() {
        if((nl != nullptr)) 
        {
            return nl;
        }
        nl = GetNewLine();
        return nl;
    }
    
    PlatformID Environment::get_Platform() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    OperatingSystem* Environment::get_OSVersion() {
        if((os ==  nullptr)) 
        {
            Version *v = Version::CreateFromString(GetOSVersionString());
            PlatformID p = get_Platform();
            if(((int32_t)(p) ==  6)) 
            {
                p = PlatformID::Unix;
            }
            os = cli::gcnew<OperatingSystem>(p, v);
        }
        return os;
    }
    
    String* Environment::get_StackTrace() {
        Diagnostics::StackTrace *trace = cli::gcnew<Diagnostics::StackTrace>(0, true);
        return trace->ToString_1636a0751cb9ac11();
    }
    
    String* Environment::get_SystemDirectory() {
        return GetFolderPath(SpecialFolder::System);
    }
    
    int32_t Environment::get_TickCount() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    String* Environment::get_UserDomainName() {
        return Environment::get_MachineName();
    }
    
    bool Environment::get_UserInteractive() {
        return false;
    }
    
    String* Environment::get_UserName() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    Version* Environment::get_Version() {
        return cli::gcnew<Version>(_T("4.0.30319.1"));
    }
    
    int64_t Environment::get_WorkingSet() {
        return 0L;
    }
    
    bool Environment::get_Is64BitOperatingSystem() {
        return (::System::IntPtr::get_Size() ==  8);
    }
    
    bool Environment::get_Is64BitProcess() {
        return Environment::get_Is64BitOperatingSystem();
    }
    
    int32_t Environment::get_SystemPageSize() {
        return GetPageSize();
    }
    
    int32_t Environment::get_ProcessorCount() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool Environment::get_IsRunningOnWindows() {
        return ((int32_t)(Environment::get_Platform()) < 4);
    }
    
    String* Environment::get_GacPath() {
        if(Environment::get_IsRunningOnWindows()) 
        {
            String *corlibDir = cli::gcnew<IO::DirectoryInfo>(IO::Path::GetDirectoryName(cli::typeof<Type>::info->get_Assembly_3aae0acbf2a6d696()->get_Location_3a7779d7eb72fa50()))->get_Parent()->get_Parent()->get_FullName_3d8989b544082b48();
            return IO::Path::Combine(IO::Path::Combine(corlibDir, _T("mono")), _T("gac"));
        }
        return IO::Path::Combine(IO::Path::Combine(internalGetGacPath(), _T("mono")), _T("gac"));
    }
    
    bool Environment::get_IsUnix() {
        int32_t platform = (int32_t)(Environment::get_Platform());
        return (((platform ==  4) || (platform ==  128)) || (platform ==  6));
    }
    
    bool Environment::get_IsMacOS() {
        return ((int32_t)(Environment::get_Platform()) ==  6);
    }
    
}
namespace System {
    
    EventArgs*  EventArgs::Empty;
    
    EventArgs::EventArgs()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void EventArgs::constructor() {
    }
    
    void EventArgs::static_constructor() {
    }
    
}
namespace System {
    
    
    void Exception::constructor() {
    }
    
    void Exception::constructor(String* message) {
        this->message = message;
    }
    
    void Exception::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        if((info ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("info"));
        }
        this->class_name = info->GetString(_T("ClassName"));
        this->message = info->GetString(_T("Message"));
        this->help_link = info->GetString(_T("HelpURL"));
        this->stack_trace = info->GetString(_T("StackTraceString"));
        this->_remoteStackTraceString = info->GetString(_T("RemoteStackTraceString"));
        this->remote_stack_index = info->GetInt32(_T("RemoteStackIndex"));
        this->hresult = info->GetInt32(_T("HResult"));
        this->source = info->GetString(_T("Source"));
        this->inner_exception = cli::cast<Exception*>(info->GetValue(_T("InnerException"), cli::typeof<Type>::info));
        try {
            this->_data = cli::cast<Collections::IDictionary*>(info->GetValue(_T("Data"), cli::typeof<Type>::info));
        }
        catch(Runtime::Serialization::SerializationException*) {
        }
    }
    
    void Exception::constructor(String* message, Exception* innerException) {
        this->inner_exception = innerException;
        this->message = message;
    }
    
    void Exception::SetMessage(String* s) {
        this->message = s;
    }
    
    void Exception::SetStackTrace(String* s) {
        this->stack_trace = s;
    }
    
    void Exception::AddFrames(Text::StringBuilder* sb, String* newline, String* unknown, Diagnostics::StackTrace* st) {
        for(int32_t i = 0; (i < st->get_FrameCount_3360fc636a0e470d()); i++){
            Diagnostics::StackFrame *frame = st->GetFrame_e0dab4b211315370(i);
            if((i ==  0)) 
            {
                sb->AppendFormat3(_T("  {0} "), Locale::GetText(_T("at")));
            }
             else 
            {
                sb->Append2(newline);
            }
            if(Reflection::MethodBase::op_Equality2(frame->GetMethod_c520bf4862e6a796(), nullptr)) 
            {
                String *internal_name = frame->GetInternalMethodName();
                if((internal_name != nullptr)) 
                {
                    sb->Append2(internal_name);
                }
                 else 
                {
                    sb->AppendFormat4(_T("<0x{0:x5}> {1}"), cli::box(frame->GetNativeOffset_bd54530a35fdb2cf()), unknown);
                }
            }
             else 
            {
                GetFullNameForStackTrace(sb, frame->GetMethod_c520bf4862e6a796());
                if((frame->GetILOffset_3f696258d4f94ef6() ==  -1)) 
                {
                    sb->AppendFormat3(_T(" <0x{0:x5}> "), cli::box(frame->GetNativeOffset_bd54530a35fdb2cf()));
                }
                 else 
                {
                    sb->AppendFormat3(_T(" [0x{0:x5}] "), cli::box(frame->GetILOffset_3f696258d4f94ef6()));
                }
                sb->AppendFormat4(_T("in {0}:{1} "), frame->GetSecureFileName(), cli::box(frame->GetFileLineNumber_55fe214715732be8()));
            }
        }
    }
    
    Exception* Exception::GetBaseException_3c80088934e2347b() {
        Exception *inner = this->inner_exception;
        while((inner != nullptr)) {
            if((inner->get_InnerException() != nullptr)) 
            {
                inner = inner->get_InnerException();
            }
             else 
            {
                return inner;
            }
        }
        return this;
    }
    
    void Exception::GetObjectData_bc9b88d7eb43b6d8(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        if((info ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("info"));
        }
        info->AddValue16(_T("ClassName"), this->get_ClassName());
        info->AddValue16(_T("Message"), this->message);
        info->AddValue16(_T("InnerException"), this->inner_exception);
        info->AddValue16(_T("HelpURL"), this->help_link);
        info->AddValue16(_T("StackTraceString"), this->get_StackTrace_f3fc28619b4f921());
        info->AddValue16(_T("RemoteStackTraceString"), this->_remoteStackTraceString);
        info->AddValue4(_T("RemoteStackIndex"), this->remote_stack_index);
        info->AddValue4(_T("HResult"), this->hresult);
        info->AddValue16(_T("Source"), this->get_Source_fe63b25bfdf963b9());
        info->AddValue16(_T("ExceptionMethod"), nullptr);
        info->AddValue(_T("Data"), this->_data, cli::typeof<Type>::info);
    }
    
    String* Exception::ToString_1636a0751cb9ac11() {
        Text::StringBuilder *result = cli::gcnew<Text::StringBuilder>(this->get_ClassName());
        result->Append2(_T(": "))->Append2(this->get_Message_d211df4045b57cbf());
        if((this->_remoteStackTraceString != nullptr)) 
        {
            result->Append2(this->_remoteStackTraceString);
        }
        if((this->inner_exception != nullptr)) 
        {
            result->Append2(_T(" ---> "))->Append2(this->inner_exception->ToString_1636a0751cb9ac11());
            result->Append2(Environment::get_NewLine());
            result->Append2(Locale::GetText(_T("  --- End of inner exception stack trace ---")));
        }
        if((this->get_StackTrace_f3fc28619b4f921() != nullptr)) 
        {
            result->Append2(Environment::get_NewLine())->Append2(this->get_StackTrace_f3fc28619b4f921());
        }
        return result->ToString_1636a0751cb9ac11();
    }
    
    Exception* Exception::FixRemotingException() {
        String *message = (this->remote_stack_index ==  0) ? Locale::GetText(_T("{0}{0}Server stack trace: {0}{1}{0}{0}Exception rethrown at [{2}]: {0}")) : Locale::GetText(_T("{1}{0}{0}Exception rethrown at [{2}]: {0}"));
        String *tmp = String::Format4(message, Environment::get_NewLine(), this->get_StackTrace_f3fc28619b4f921(), cli::box(this->remote_stack_index));
        this->_remoteStackTraceString = tmp;
        this->remote_stack_index++;
        this->stack_trace = nullptr;
        return this;
    }
    
    void Exception::GetFullNameForStackTrace(Text::StringBuilder* sb, Reflection::MethodBase* mi) {
        cli::array<Reflection::ParameterInfo*> *p = mi->GetParameters_9d17bcb549474c9();
        sb->Append2(mi->get_DeclaringType_6121cd6a84393166()->ToString_1636a0751cb9ac11());
        sb->Append2(_T("."));
        sb->Append2(mi->get_Name_50fad5fa936c3ae2());
        if(mi->get_IsGenericMethod_7e509e51546ea990()) 
        {
            cli::array<Type*> *gen_params = mi->GetGenericArguments_77cf5f406b341958();
            sb->Append2(_T("["));
            for(int32_t j = 0; (j < gen_params->get_Length()); j++){
                if((j > 0)) 
                {
                    sb->Append2(_T(","));
                }
                sb->Append2(gen_params->at(j)->get_Name_50fad5fa936c3ae2());
            }
            sb->Append2(_T("]"));
        }
        sb->Append2(_T(" ("));
        for(int32_t i = 0; (i < p->get_Length()); ++i){
            if((i > 0)) 
            {
                sb->Append2(_T(", "));
            }
            Type *pt = p->at(i)->get_ParameterType_97c5fa09a0b988d();
            if((pt->get_IsClass() && String::op_Inequality(pt->get_Namespace_cb4ed37007083e7f(), String::Empty))) 
            {
                sb->Append2(pt->get_Namespace_cb4ed37007083e7f());
                sb->Append2(_T("."));
            }
            sb->Append2(pt->get_Name_50fad5fa936c3ae2());
            if((p->at(i)->get_Name_1ad7a68577256740() != nullptr)) 
            {
                sb->Append2(_T(" "));
                sb->Append2(p->at(i)->get_Name_1ad7a68577256740());
            }
        }
        sb->Append2(_T(")"));
    }
    
    void Exception::CaptureTrace() {
        if((this->captured_traces != nullptr)) 
        {
            cli::array<Diagnostics::StackTrace*> *new_traces = (new cli::array<Diagnostics::StackTrace*>((this->captured_traces->get_Length() + 1)));
            Array::Copy(this->captured_traces, new_traces, this->captured_traces->get_Length());
            this->captured_traces = new_traces;
        }
         else 
        {
            this->captured_traces = (new cli::array<Diagnostics::StackTrace*>(1));
        }
        this->captured_traces->at((this->captured_traces->get_Length() - 1)) = cli::gcnew<Diagnostics::StackTrace>(this, 0, true, true);
        this->trace_ips = nullptr;
    }
    
    Type* Exception::GetType2() {
        return Object::GetType();
    }
    
    Exception* Exception::get_InnerException() {
        return this->inner_exception;
    }
    
    String* Exception::get_HelpLink_523fb8e8db786972() {
        return this->help_link;
    }
    
    String* Exception::set_HelpLink_dc2ca9999b121201(String* value) {
        this->help_link = value;
        return get_HelpLink_523fb8e8db786972();
    }
    
    int32_t Exception::get_HResult() {
        return this->hresult;
    }
    
    int32_t Exception::set_HResult(int32_t value) {
        this->hresult = value;
        return get_HResult();
    }
    
    String* Exception::get_ClassName() {
        if((this->class_name ==  nullptr)) 
        {
            this->class_name = GetType2()->ToString_1636a0751cb9ac11();
        }
        return this->class_name;
    }
    
    String* Exception::get_Message_d211df4045b57cbf() {
        if((this->message ==  nullptr)) 
        {
            this->message = String::Format2(Locale::GetText(_T("Exception of type \'{0}\' was thrown.")), this->get_ClassName());
        }
        return this->message;
    }
    
    String* Exception::get_Source_fe63b25bfdf963b9() {
        if((this->source ==  nullptr)) 
        {
            Diagnostics::StackTrace *st = cli::gcnew<Diagnostics::StackTrace>(this, true);
            if((st->get_FrameCount_3360fc636a0e470d() > 0)) 
            {
                Diagnostics::StackFrame *sf = st->GetFrame_e0dab4b211315370(0);
                if((st != nullptr)) 
                {
                    Reflection::MethodBase *method = sf->GetMethod_c520bf4862e6a796();
                    if(Reflection::MethodBase::op_Inequality2(method, nullptr)) 
                    {
                        this->source = method->get_DeclaringType_6121cd6a84393166()->get_Assembly_3aae0acbf2a6d696()->UnprotectedGetName_b11b135b2412c023()->get_Name();
                    }
                }
            }
        }
        return this->source;
    }
    
    String* Exception::set_Source_4a11d6bd5ca37e45(String* value) {
        this->source = value;
        return get_Source_fe63b25bfdf963b9();
    }
    
    String* Exception::get_StackTrace_f3fc28619b4f921() {
        if((this->stack_trace != nullptr)) 
        {
            return this->stack_trace;
        }
        if((this->trace_ips ==  nullptr)) 
        {
            return nullptr;
        }
        Text::StringBuilder *sb = cli::gcnew<Text::StringBuilder>();
        String *newline = String::Format3(_T("{0}  {1} "), Environment::get_NewLine(), Locale::GetText(_T("at")));
        String *unknown = Locale::GetText(_T("<unknown method>"));
        if((this->captured_traces != nullptr)) 
        {
            for(auto tmp_169 : this->captured_traces) {
                auto t = cli::cast<Diagnostics::StackTrace*>(tmp_169);
                {
                    AddFrames(sb, newline, unknown, t);
                    sb->Append2(Environment::get_NewLine());
                    sb->Append2(_T("--- End of stack trace from previous location where exception was thrown ---"));
                    sb->Append2(Environment::get_NewLine());
                }
            }
        }
        Diagnostics::StackTrace *st = cli::gcnew<Diagnostics::StackTrace>(this, 0, true, true);
        AddFrames(sb, newline, unknown, st);
        this->stack_trace = sb->ToString_1636a0751cb9ac11();
        return this->stack_trace;
    }
    
    Reflection::MethodBase* Exception::get_TargetSite() {
        Diagnostics::StackTrace *st = cli::gcnew<Diagnostics::StackTrace>(this, true);
        if((st->get_FrameCount_3360fc636a0e470d() > 0)) 
        {
            return st->GetFrame_e0dab4b211315370(0)->GetMethod_c520bf4862e6a796();
        }
        return nullptr;
    }
    
    Collections::IDictionary* Exception::get_Data_6dba6d3fc94b4ca2() {
        if((this->_data ==  nullptr)) 
        {
            this->_data = cli::cast<Collections::IDictionary*>(cli::gcnew<Collections::Hashtable>());
        }
        return this->_data;
    }
    
    void Exception::add_SerializeObjectState(EventHandler2<Runtime::Serialization::SafeSerializationEventArgs*>* value) {
    }
    
    void Exception::remove_SerializeObjectState(EventHandler2<Runtime::Serialization::SafeSerializationEventArgs*>* value) {
    }
    
}
namespace System {
    
    
    void ExecutionEngineException::constructor() {
    }
    
    void ExecutionEngineException::constructor(String* message) {
    }
    
    void ExecutionEngineException::constructor(String* message, Exception* innerException) {
    }
    
    void ExecutionEngineException::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
    }
    
}
namespace System {
    
    
    void FieldAccessException::constructor() {
        this->set_HResult(-2146233081);
    }
    
    void FieldAccessException::constructor(String* message) {
        this->set_HResult(-2146233081);
    }
    
    void FieldAccessException::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
    }
    
    void FieldAccessException::constructor(String* message, Exception* inner) {
        this->set_HResult(-2146233081);
    }
    
}
namespace System {
    
    
    void FlagsAttribute::constructor() {
    }
    
}
namespace System {
    
    
    void FormatException::constructor() {
        this->set_HResult(-2146233033);
    }
    
    void FormatException::constructor(String* message) {
        this->set_HResult(-2146233033);
    }
    
    void FormatException::constructor(String* message, Exception* innerException) {
        this->set_HResult(-2146233033);
    }
    
    void FormatException::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
    }
    
}
namespace System {
    
    Object*  GC::EPHEMERON_TOMBSTONE;
    
    GC::GC()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void GC::static_constructor() {
    }
    
    void GC::InternalCollect(int32_t generation) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void GC::Collect() {
        InternalCollect(GC::get_MaxGeneration());
    }
    
    void GC::Collect2(int32_t generation) {
        if((generation < 0)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("generation"));
        }
        InternalCollect(generation);
    }
    
    void GC::Collect3(int32_t generation, GCCollectionMode mode) {
        Collect2(generation);
    }
    
    int32_t GC::GetGeneration(Object* obj) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t GC::GetGeneration2(WeakReference* wo) {
        Object *obj = wo->get_Target_4c75add6ace39d1f();
        if((obj ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentException>();
        }
        return GetGeneration(obj);
    }
    
    int64_t GC::GetTotalMemory(bool forceFullCollection) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void GC::KeepAlive(Object* obj) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void GC::ReRegisterForFinalize(Object* obj) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void GC::SuppressFinalize(Object* obj) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void GC::WaitForPendingFinalizers() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t GC::CollectionCount(int32_t generation) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void GC::RecordPressure(int64_t bytesAllocated) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void GC::AddMemoryPressure(int64_t bytesAllocated) {
        RecordPressure(bytesAllocated);
    }
    
    void GC::RemoveMemoryPressure(int64_t bytesAllocated) {
        RecordPressure(-(bytesAllocated));
    }
    
    GCNotificationStatus GC::WaitForFullGCApproach() {
        throw cli::gcnew<NotImplementedException>();
    }
    
    GCNotificationStatus GC::WaitForFullGCApproach2(int32_t millisecondsTimeout) {
        throw cli::gcnew<NotImplementedException>();
    }
    
    GCNotificationStatus GC::WaitForFullGCComplete() {
        throw cli::gcnew<NotImplementedException>();
    }
    
    GCNotificationStatus GC::WaitForFullGCComplete2(int32_t millisecondsTimeout) {
        throw cli::gcnew<NotImplementedException>();
    }
    
    void GC::RegisterForFullGCNotification(int32_t maxGenerationThreshold, int32_t largeObjectHeapThreshold) {
        if(((maxGenerationThreshold < 1) || (maxGenerationThreshold > 99))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("maxGenerationThreshold"), cli::box(maxGenerationThreshold), _T("maxGenerationThreshold must be between 1 and 99 inclusive"));
        }
        if(((largeObjectHeapThreshold < 1) || (largeObjectHeapThreshold > 99))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("largeObjectHeapThreshold"), cli::box(largeObjectHeapThreshold), _T("largeObjectHeapThreshold must be between 1 and 99 inclusive"));
        }
        throw cli::gcnew<NotImplementedException>();
    }
    
    void GC::CancelFullGCNotification() {
        throw cli::gcnew<NotImplementedException>();
    }
    
    void GC::register_ephemeron_array(cli::array<Runtime::CompilerServices::Ephemeron>* array) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    Object* GC::get_ephemeron_tombstone() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t GC::get_MaxGeneration() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
}
namespace System {
    
    
    void GuidParser::constructor(String* src) {
        this->_src = src;
        Reset();
    }
    
    void GuidParser::Reset() {
        this->_cur = 0;
        this->_length = this->_src->get_Length();
    }
    
    bool GuidParser::HasHyphen(Format format) {
        switch(format) {
            case Format::D: case Format::B: case Format::P: case_703: {
                return true;
            }
            default: case_704: {
                return false;
            }
        }
    }
    
    bool GuidParser::TryParseNDBP(Format format, Guid guid) {
        uint64_t a, b, c;
        guid = cli::ctor<Guid>();
        if((((int32_t)(format) ==  2) && !(ParseChar(u'\x7b')))) 
        {
            return false;
        }
        if((((int32_t)(format) ==  3) && !(ParseChar(u'(')))) 
        {
            return false;
        }
        if(!(ParseHex(8, true, a))) 
        {
            return false;
        }
        bool has_hyphen = HasHyphen(format);
        if((has_hyphen && !(ParseChar(u'-')))) 
        {
            return false;
        }
        if(!(ParseHex(4, true, b))) 
        {
            return false;
        }
        if((has_hyphen && !(ParseChar(u'-')))) 
        {
            return false;
        }
        if(!(ParseHex(4, true, c))) 
        {
            return false;
        }
        if((has_hyphen && !(ParseChar(u'-')))) 
        {
            return false;
        }
        cli::array<unsigned char> *d = (new cli::array<unsigned char>(8));
        for(int32_t i = 0; (i < d->get_Length()); i++){
            uint64_t dd;
            if(!(ParseHex(2, true, dd))) 
            {
                return false;
            }
            if((((i ==  1) && has_hyphen) && !(ParseChar(u'-')))) 
            {
                return false;
            }
            d->at(i) = (unsigned char)dd;
        }
        if((((int32_t)(format) ==  2) && !(ParseChar(u'\x7d')))) 
        {
            return false;
        }
        if((((int32_t)(format) ==  3) && !(ParseChar(u')')))) 
        {
            return false;
        }
        if(!(this->get_Eof())) 
        {
            return false;
        }
        guid = cli::ctor<Guid>((int32_t)a, (int16_t)b, (int16_t)c, d);
        return true;
    }
    
    bool GuidParser::TryParseX(Guid guid) {
        uint64_t a, b, c;
        guid = cli::ctor<Guid>();
        if(!(((((((((((ParseChar(u'\x7b') && ParseHexPrefix()) && ParseHex(8, false, a)) && ParseChar(u',')) && ParseHexPrefix()) && ParseHex(4, false, b)) && ParseChar(u',')) && ParseHexPrefix()) && ParseHex(4, false, c)) && ParseChar(u',')) && ParseChar(u'\x7b')))) 
        {
            return false;
        }
        cli::array<unsigned char> *d = (new cli::array<unsigned char>(8));
        for(int32_t i = 0; (i < d->get_Length()); ++i){
            uint64_t dd;
            if(!((ParseHexPrefix() && ParseHex(2, false, dd)))) 
            {
                return false;
            }
            d->at(i) = (unsigned char)dd;
            if(((i != 7) && !(ParseChar(u',')))) 
            {
                return false;
            }
        }
        if(!((ParseChar(u'\x7d') && ParseChar(u'\x7d')))) 
        {
            return false;
        }
        if(!(this->get_Eof())) 
        {
            return false;
        }
        guid = cli::ctor<Guid>((int32_t)a, (int16_t)b, (int16_t)c, d);
        return true;
    }
    
    bool GuidParser::ParseHexPrefix() {
        if(!(ParseChar(u'0'))) 
        {
            return false;
        }
        return ParseChar(u'x');
    }
    
    bool GuidParser::ParseChar(char16_t c) {
        if((!(this->get_Eof()) && ((int32_t)(this->_src->get_Chars(this->_cur)) ==  (int32_t)(c)))) 
        {
            this->_cur++;
            return true;
        }
        return false;
    }
    
    bool GuidParser::ParseHex(int32_t length, bool strict, uint64_t res) {
        res = 0UL;
        for(int32_t i = 0; (i < length); i++){
            if(this->get_Eof()) 
            {
                return !((strict && ((i + 1) != length)));
            }
            char16_t c = Char::ToLowerInvariant(this->_src->get_Chars(this->_cur));
            if(Char::IsDigit(c)) 
            {
                res = (((res * 16UL) + (uint64_t)(c)) - 48UL);
                this->_cur++;
            }
             else 
            {
                if((((int32_t)(c) >= 97) && ((int32_t)(c) <= 102))) 
                {
                    res = ((((res * 16UL) + (uint64_t)(c)) - 97UL) + 10UL);
                    this->_cur++;
                }
                 else 
                {
                    if(!(strict)) 
                    {
                        return true;
                    }
                    return !((strict && ((i + 1) != length)));
                }
            }
        }
        return true;
    }
    
    bool GuidParser::Parse(Format format, Guid guid) {
        if(((int32_t)(format) ==  4)) 
        {
            return TryParseX(guid);
        }
        return TryParseNDBP(format, guid);
    }
    
    bool GuidParser::Parse2(Guid guid) {
        if(TryParseNDBP(Format::N, guid)) 
        {
            return true;
        }
        Reset();
        if(TryParseNDBP(Format::D, guid)) 
        {
            return true;
        }
        Reset();
        if(TryParseNDBP(Format::B, guid)) 
        {
            return true;
        }
        Reset();
        if(TryParseNDBP(Format::P, guid)) 
        {
            return true;
        }
        Reset();
        return TryParseX(guid);
    }
    
    bool GuidParser::get_Eof() {
        return (this->_cur >= this->_length);
    }
    
}
namespace System {
    
    
    void IndexOutOfRangeException::constructor() {
    }
    
    void IndexOutOfRangeException::constructor(String* message) {
    }
    
    void IndexOutOfRangeException::constructor(String* message, Exception* innerException) {
    }
    
    void IndexOutOfRangeException::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
    }
    
}
namespace System {
    
    
    void InsufficientExecutionStackException::constructor() {
    }
    
    void InsufficientExecutionStackException::constructor(String* message) {
    }
    
    void InsufficientExecutionStackException::constructor(String* message, Exception* innerException) {
    }
    
}
namespace System {
    
    
    void InsufficientMemoryException::constructor() {
    }
    
    void InsufficientMemoryException::constructor(String* message) {
    }
    
    void InsufficientMemoryException::constructor(String* message, Exception* innerException) {
    }
    
}
namespace System {
    
    
    void InvalidCastException::constructor() {
        this->set_HResult(-2147467262);
    }
    
    void InvalidCastException::constructor(String* message) {
        this->set_HResult(-2147467262);
    }
    
    void InvalidCastException::constructor(String* message, Exception* innerException) {
        this->set_HResult(-2147467262);
    }
    
    void InvalidCastException::constructor(String* message, int32_t errorCode) {
        this->set_HResult(errorCode);
    }
    
    void InvalidCastException::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
    }
    
}
namespace System {
    
    
    void InvalidOperationException::constructor() {
        this->set_HResult(-2146233079);
    }
    
    void InvalidOperationException::constructor(String* message) {
        this->set_HResult(-2146233079);
    }
    
    void InvalidOperationException::constructor(String* message, Exception* innerException) {
        this->set_HResult(-2146233079);
    }
    
    void InvalidOperationException::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
    }
    
}
namespace System {
    
    
    void InvalidProgramException::constructor() {
    }
    
    void InvalidProgramException::constructor(String* message) {
    }
    
    void InvalidProgramException::constructor(String* message, Exception* inner) {
    }
    
    void InvalidProgramException::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
    }
    
}
namespace System {
    
    
    void InvalidTimeZoneException::constructor() {
    }
    
    void InvalidTimeZoneException::constructor(String* message) {
    }
    
    void InvalidTimeZoneException::constructor(String* message, Exception* innerException) {
    }
    
    void InvalidTimeZoneException::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
    }
    
}
namespace System {
    
    
    cli::array<unsigned char>* KnownTerminals::get_linux() {
        return (new cli::array<unsigned char>({26, 1, 20, 0, 29, 0, 16, 0, 125, 1, 41, 3, 108, 105, 110, 117, 120, 124, 108, 105, 110, 117, 120, 32, 99, 111, 110, 115, 111, 108, 101, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 255, 255, 8, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 8, 0, 64, 0, 18, 0, 255, 255, 0, 0, 2, 0, 4, 0, 21, 0, 26, 0, 33, 0, 37, 0, 41, 0, 255, 255, 52, 0, 69, 0, 71, 0, 75, 0, 87, 0, 255, 255, 89, 0, 101, 0, 255, 255, 105, 0, 109, 0, 121, 0, 125, 0, 255, 255, 255, 255, 129, 0, 135, 0, 140, 0, 255, 255, 255, 255, 145, 0, 150, 0, 155, 0, 255, 255, 160, 0, 165, 0, 170, 0, 175, 0, 184, 0, 190, 0, 255, 255, 255, 255, 198, 0, 203, 0, 209, 0, 215, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 233, 0, 237, 0, 255, 255, 241, 0, 255, 255, 255, 255, 255, 255, 243, 0, 255, 255, 248, 0, 255, 255, 255, 255, 255, 255, 255, 255, 252, 0, 1, 1, 7, 1, 12, 1, 17, 1, 22, 1, 27, 1, 33, 1, 39, 1, 45, 1, 51, 1, 56, 1, 255, 255, 61, 1, 255, 255, 65, 1, 70, 1, 75, 1, 255, 255, 255, 255, 255, 255, 79, 1, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 83, 1, 255, 255, 86, 1, 95, 1, 255, 255, 104, 1, 255, 255, 113, 1, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 122, 1, 255, 255, 255, 255, 255, 255, 128, 1, 131, 1, 142, 1, 145, 1, 147, 1, 150, 1, 247, 1, 255, 255, 250, 1, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 252, 1, 255, 255, 255, 255, 255, 255, 255, 255, 0, 2, 255, 255, 65, 2, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 69, 2, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 74, 2, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 76, 2, 82, 2, 88, 2, 94, 2, 100, 2, 106, 2, 112, 2, 118, 2, 124, 2, 130, 2, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 136, 2, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 141, 2, 152, 2, 157, 2, 163, 2, 167, 2, 176, 2, 180, 2, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 5, 3, 255, 255, 255, 255, 255, 255, 9, 3, 19, 3, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 29, 3, 35, 3, 7, 0, 13, 0, 27, 91, 37, 105, 37, 112, 49, 37, 100, 59, 37, 112, 50, 37, 100, 114, 0, 27, 91, 51, 103, 0, 27, 91, 72, 27, 91, 74, 0, 27, 91, 75, 0, 27, 91, 74, 0, 27, 91, 37, 105, 37, 112, 49, 37, 100, 71, 0, 27, 91, 37, 105, 37, 112, 49, 37, 100, 59, 37, 112, 50, 37, 100, 72, 0, 10, 0, 27, 91, 72, 0, 27, 91, 63, 50, 53, 108, 27, 91, 63, 49, 99, 0, 8, 0, 27, 91, 63, 50, 53, 104, 27, 91, 63, 48, 99, 0, 27, 91, 67, 0, 27, 91, 65, 0, 27, 91, 63, 50, 53, 104, 27, 91, 63, 56, 99, 0, 27, 91, 80, 0, 27, 91, 77, 0, 27, 91, 49, 49, 109, 0, 27, 91, 53, 109, 0, 27, 91, 49, 109, 0, 27, 91, 50, 109, 0, 27, 91, 52, 104, 0, 27, 91, 56, 109, 0, 27, 91, 55, 109, 0, 27, 91, 55, 109, 0, 27, 91, 52, 109, 0, 27, 91, 37, 112, 49, 37, 100, 88, 0, 27, 91, 49, 48, 109, 0, 27, 91, 48, 59, 49, 48, 109, 0, 27, 91, 52, 108, 0, 27, 91, 50, 55, 109, 0, 27, 91, 50, 52, 109, 0, 27, 91, 63, 53, 104, 27, 91, 63, 53, 108, 36, 60, 50, 48, 48, 47, 62, 0, 27, 91, 64, 0, 27, 91, 76, 0, 127, 0, 27, 91, 51, 126, 0, 27, 91, 66, 0, 27, 91, 91, 65, 0, 27, 91, 50, 49, 126, 0, 27, 91, 91, 66, 0, 27, 91, 91, 67, 0, 27, 91, 91, 68, 0, 27, 91, 91, 69, 0, 27, 91, 49, 55, 126, 0, 27, 91, 49, 56, 126, 0, 27, 91, 49, 57, 126, 0, 27, 91, 50, 48, 126, 0, 27, 91, 49, 126, 0, 27, 91, 50, 126, 0, 27, 91, 68, 0, 27, 91, 54, 126, 0, 27, 91, 53, 126, 0, 27, 91, 67, 0, 27, 91, 65, 0, 13, 10, 0, 27, 91, 37, 112, 49, 37, 100, 80, 0, 27, 91, 37, 112, 49, 37, 100, 77, 0, 27, 91, 37, 112, 49, 37, 100, 64, 0, 27, 91, 37, 112, 49, 37, 100, 76, 0, 27, 99, 27, 93, 82, 0, 27, 56, 0, 27, 91, 37, 105, 37, 112, 49, 37, 100, 100, 0, 27, 55, 0, 10, 0, 27, 77, 0, 27, 91, 48, 59, 49, 48, 37, 63, 37, 112, 49, 37, 116, 59, 55, 37, 59, 37, 63, 37, 112, 50, 37, 116, 59, 52, 37, 59, 37, 63, 37, 112, 51, 37, 116, 59, 55, 37, 59, 37, 63, 37, 112, 52, 37, 116, 59, 53, 37, 59, 37, 63, 37, 112, 53, 37, 116, 59, 50, 37, 59, 37, 63, 37, 112, 54, 37, 116, 59, 49, 37, 59, 37, 63, 37, 112, 55, 37, 116, 59, 56, 37, 59, 37, 63, 37, 112, 57, 37, 116, 59, 49, 49, 37, 59, 109, 0, 27, 72, 0, 9, 0, 27, 91, 71, 0, 43, 16, 44, 17, 45, 24, 46, 25, 48, 219, 96, 4, 97, 177, 102, 248, 103, 241, 104, 176, 105, 206, 106, 217, 107, 191, 108, 218, 109, 192, 110, 197, 111, 126, 112, 196, 113, 196, 114, 196, 115, 95, 116, 195, 117, 180, 118, 193, 119, 194, 120, 179, 121, 243, 122, 242, 123, 227, 124, 216, 125, 156, 126, 254, 0, 27, 91, 90, 0, 27, 91, 52, 126, 0, 26, 0, 27, 91, 50, 51, 126, 0, 27, 91, 50, 52, 126, 0, 27, 91, 50, 53, 126, 0, 27, 91, 50, 54, 126, 0, 27, 91, 50, 56, 126, 0, 27, 91, 50, 57, 126, 0, 27, 91, 51, 49, 126, 0, 27, 91, 51, 50, 126, 0, 27, 91, 51, 51, 126, 0, 27, 91, 51, 52, 126, 0, 27, 91, 49, 75, 0, 27, 91, 37, 105, 37, 100, 59, 37, 100, 82, 0, 27, 91, 54, 110, 0, 27, 91, 63, 54, 99, 0, 27, 91, 99, 0, 27, 91, 51, 57, 59, 52, 57, 109, 0, 27, 93, 82, 0, 27, 93, 80, 37, 112, 49, 37, 120, 37, 112, 50, 37, 123, 50, 53, 54, 125, 37, 42, 37, 123, 49, 48, 48, 48, 125, 37, 47, 37, 48, 50, 120, 37, 112, 51, 37, 123, 50, 53, 54, 125, 37, 42, 37, 123, 49, 48, 48, 48, 125, 37, 47, 37, 48, 50, 120, 37, 112, 52, 37, 123, 50, 53, 54, 125, 37, 42, 37, 123, 49, 48, 48, 48, 125, 37, 47, 37, 48, 50, 120, 0, 27, 91, 77, 0, 27, 91, 51, 37, 112, 49, 37, 100, 109, 0, 27, 91, 52, 37, 112, 49, 37, 100, 109, 0, 27, 91, 49, 49, 109, 0, 27, 91, 49, 48, 109, 0}));
    }
    
    cli::array<unsigned char>* KnownTerminals::get_xterm() {
        return (new cli::array<unsigned char>({26, 1, 28, 0, 29, 0, 15, 0, 157, 1, 150, 4, 120, 116, 101, 114, 109, 124, 88, 49, 49, 32, 116, 101, 114, 109, 105, 110, 97, 108, 32, 101, 109, 117, 108, 97, 116, 111, 114, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 80, 0, 8, 0, 24, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 8, 0, 64, 0, 0, 0, 4, 0, 6, 0, 8, 0, 25, 0, 30, 0, 38, 0, 42, 0, 46, 0, 255, 255, 57, 0, 74, 0, 76, 0, 80, 0, 87, 0, 255, 255, 89, 0, 96, 0, 255, 255, 100, 0, 255, 255, 104, 0, 108, 0, 255, 255, 255, 255, 112, 0, 114, 0, 119, 0, 124, 0, 255, 255, 255, 255, 133, 0, 138, 0, 255, 255, 143, 0, 148, 0, 153, 0, 158, 0, 167, 0, 169, 0, 174, 0, 255, 255, 183, 0, 188, 0, 194, 0, 200, 0, 255, 255, 255, 255, 255, 255, 218, 0, 255, 255, 255, 255, 255, 255, 236, 0, 255, 255, 240, 0, 255, 255, 255, 255, 255, 255, 242, 0, 255, 255, 247, 0, 255, 255, 255, 255, 255, 255, 255, 255, 251, 0, 255, 0, 5, 1, 9, 1, 13, 1, 17, 1, 23, 1, 29, 1, 35, 1, 41, 1, 47, 1, 51, 1, 255, 255, 56, 1, 255, 255, 60, 1, 65, 1, 70, 1, 255, 255, 255, 255, 255, 255, 74, 1, 78, 1, 86, 1, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 94, 1, 103, 1, 112, 1, 121, 1, 255, 255, 130, 1, 139, 1, 148, 1, 255, 255, 157, 1, 255, 255, 255, 255, 255, 255, 166, 1, 170, 1, 175, 1, 255, 255, 180, 1, 183, 1, 255, 255, 255, 255, 201, 1, 204, 1, 215, 1, 218, 1, 220, 1, 223, 1, 45, 2, 255, 255, 48, 2, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 50, 2, 255, 255, 255, 255, 255, 255, 255, 255, 54, 2, 255, 255, 107, 2, 255, 255, 255, 255, 111, 2, 117, 2, 255, 255, 255, 255, 123, 2, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 130, 2, 134, 2, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 138, 2, 255, 255, 255, 255, 145, 2, 255, 255, 255, 255, 255, 255, 255, 255, 150, 2, 155, 2, 162, 2, 255, 255, 255, 255, 167, 2, 255, 255, 174, 2, 255, 255, 255, 255, 255, 255, 181, 2, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 186, 2, 192, 2, 198, 2, 203, 2, 208, 2, 213, 2, 218, 2, 226, 2, 234, 2, 242, 2, 250, 2, 2, 3, 10, 3, 18, 3, 26, 3, 31, 3, 36, 3, 41, 3, 46, 3, 54, 3, 62, 3, 70, 3, 78, 3, 86, 3, 94, 3, 102, 3, 110, 3, 115, 3, 120, 3, 125, 3, 130, 3, 138, 3, 146, 3, 154, 3, 162, 3, 170, 3, 178, 3, 186, 3, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 194, 3, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 199, 3, 210, 3, 215, 3, 223, 3, 227, 3, 255, 255, 255, 255, 255, 255, 255, 255, 236, 3, 50, 4, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 120, 4, 255, 255, 255, 255, 255, 255, 124, 4, 134, 4, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 144, 4, 147, 4, 27, 91, 90, 0, 7, 0, 13, 0, 27, 91, 37, 105, 37, 112, 49, 37, 100, 59, 37, 112, 50, 37, 100, 114, 0, 27, 91, 51, 103, 0, 27, 91, 72, 27, 91, 50, 74, 0, 27, 91, 75, 0, 27, 91, 74, 0, 27, 91, 37, 105, 37, 112, 49, 37, 100, 71, 0, 27, 91, 37, 105, 37, 112, 49, 37, 100, 59, 37, 112, 50, 37, 100, 72, 0, 10, 0, 27, 91, 72, 0, 27, 91, 63, 50, 53, 108, 0, 8, 0, 27, 91, 63, 50, 53, 104, 0, 27, 91, 67, 0, 27, 91, 65, 0, 27, 91, 80, 0, 27, 91, 77, 0, 14, 0, 27, 91, 53, 109, 0, 27, 91, 49, 109, 0, 27, 91, 63, 49, 48, 52, 57, 104, 0, 27, 91, 52, 104, 0, 27, 91, 56, 109, 0, 27, 91, 55, 109, 0, 27, 91, 55, 109, 0, 27, 91, 52, 109, 0, 27, 91, 37, 112, 49, 37, 100, 88, 0, 15, 0, 27, 91, 109, 15, 0, 27, 91, 63, 49, 48, 52, 57, 108, 0, 27, 91, 52, 108, 0, 27, 91, 50, 55, 109, 0, 27, 91, 50, 52, 109, 0, 27, 91, 63, 53, 104, 36, 60, 49, 48, 48, 47, 62, 27, 91, 63, 53, 108, 0, 27, 91, 33, 112, 27, 91, 63, 51, 59, 52, 108, 27, 91, 52, 108, 27, 62, 0, 27, 91, 76, 0, 127, 0, 27, 91, 51, 126, 0, 27, 79, 66, 0, 27, 79, 80, 0, 27, 91, 50, 49, 126, 0, 27, 79, 81, 0, 27, 79, 82, 0, 27, 79, 83, 0, 27, 91, 49, 53, 126, 0, 27, 91, 49, 55, 126, 0, 27, 91, 49, 56, 126, 0, 27, 91, 49, 57, 126, 0, 27, 91, 50, 48, 126, 0, 27, 79, 72, 0, 27, 91, 50, 126, 0, 27, 79, 68, 0, 27, 91, 54, 126, 0, 27, 91, 53, 126, 0, 27, 79, 67, 0, 27, 79, 65, 0, 27, 91, 63, 49, 108, 27, 62, 0, 27, 91, 63, 49, 104, 27, 61, 0, 27, 91, 37, 112, 49, 37, 100, 80, 0, 27, 91, 37, 112, 49, 37, 100, 77, 0, 27, 91, 37, 112, 49, 37, 100, 66, 0, 27, 91, 37, 112, 49, 37, 100, 64, 0, 27, 91, 37, 112, 49, 37, 100, 76, 0, 27, 91, 37, 112, 49, 37, 100, 68, 0, 27, 91, 37, 112, 49, 37, 100, 67, 0, 27, 91, 37, 112, 49, 37, 100, 65, 0, 27, 91, 105, 0, 27, 91, 52, 105, 0, 27, 91, 53, 105, 0, 27, 99, 0, 27, 91, 33, 112, 27, 91, 63, 51, 59, 52, 108, 27, 91, 52, 108, 27, 62, 0, 27, 56, 0, 27, 91, 37, 105, 37, 112, 49, 37, 100, 100, 0, 27, 55, 0, 10, 0, 27, 77, 0, 27, 91, 48, 37, 63, 37, 112, 54, 37, 116, 59, 49, 37, 59, 37, 63, 37, 112, 50, 37, 116, 59, 52, 37, 59, 37, 63, 37, 112, 49, 37, 112, 51, 37, 124, 37, 116, 59, 55, 37, 59, 37, 63, 37, 112, 52, 37, 116, 59, 53, 37, 59, 37, 63, 37, 112, 55, 37, 116, 59, 56, 37, 59, 109, 37, 63, 37, 112, 57, 37, 116, 14, 37, 101, 15, 37, 59, 0, 27, 72, 0, 9, 0, 27, 79, 69, 0, 96, 96, 97, 97, 102, 102, 103, 103, 105, 105, 106, 106, 107, 107, 108, 108, 109, 109, 110, 110, 111, 111, 112, 112, 113, 113, 114, 114, 115, 115, 116, 116, 117, 117, 118, 118, 119, 119, 120, 120, 121, 121, 122, 122, 123, 123, 124, 124, 125, 125, 126, 126, 0, 27, 91, 90, 0, 27, 91, 63, 55, 104, 0, 27, 91, 63, 55, 108, 0, 27, 40, 66, 27, 41, 48, 0, 27, 79, 70, 0, 27, 79, 77, 0, 27, 91, 51, 59, 53, 126, 0, 27, 79, 53, 70, 0, 27, 79, 53, 72, 0, 27, 91, 50, 59, 53, 126, 0, 27, 79, 53, 68, 0, 27, 91, 54, 59, 53, 126, 0, 27, 91, 53, 59, 53, 126, 0, 27, 79, 53, 67, 0, 27, 91, 50, 51, 126, 0, 27, 91, 50, 52, 126, 0, 27, 79, 50, 80, 0, 27, 79, 50, 81, 0, 27, 79, 50, 82, 0, 27, 79, 50, 83, 0, 27, 91, 49, 53, 59, 50, 126, 0, 27, 91, 49, 55, 59, 50, 126, 0, 27, 91, 49, 56, 59, 50, 126, 0, 27, 91, 49, 57, 59, 50, 126, 0, 27, 91, 50, 48, 59, 50, 126, 0, 27, 91, 50, 49, 59, 50, 126, 0, 27, 91, 50, 51, 59, 50, 126, 0, 27, 91, 50, 52, 59, 50, 126, 0, 27, 79, 53, 80, 0, 27, 79, 53, 81, 0, 27, 79, 53, 82, 0, 27, 79, 53, 83, 0, 27, 91, 49, 53, 59, 53, 126, 0, 27, 91, 49, 55, 59, 53, 126, 0, 27, 91, 49, 56, 59, 53, 126, 0, 27, 91, 49, 57, 59, 53, 126, 0, 27, 91, 50, 48, 59, 53, 126, 0, 27, 91, 50, 49, 59, 53, 126, 0, 27, 91, 50, 51, 59, 53, 126, 0, 27, 91, 50, 52, 59, 53, 126, 0, 27, 79, 54, 80, 0, 27, 79, 54, 81, 0, 27, 79, 54, 82, 0, 27, 79, 54, 83, 0, 27, 91, 49, 53, 59, 54, 126, 0, 27, 91, 49, 55, 59, 54, 126, 0, 27, 91, 49, 56, 59, 54, 126, 0, 27, 91, 49, 57, 59, 54, 126, 0, 27, 91, 50, 48, 59, 54, 126, 0, 27, 91, 50, 49, 59, 54, 126, 0, 27, 91, 50, 51, 59, 54, 126, 0, 27, 91, 50, 52, 59, 54, 126, 0, 27, 91, 49, 75, 0, 27, 91, 37, 105, 37, 100, 59, 37, 100, 82, 0, 27, 91, 54, 110, 0, 27, 91, 63, 49, 59, 50, 99, 0, 27, 91, 99, 0, 27, 91, 51, 57, 59, 52, 57, 109, 0, 27, 91, 51, 37, 63, 37, 112, 49, 37, 123, 49, 125, 37, 61, 37, 116, 52, 37, 101, 37, 112, 49, 37, 123, 51, 125, 37, 61, 37, 116, 54, 37, 101, 37, 112, 49, 37, 123, 52, 125, 37, 61, 37, 116, 49, 37, 101, 37, 112, 49, 37, 123, 54, 125, 37, 61, 37, 116, 51, 37, 101, 37, 112, 49, 37, 100, 37, 59, 109, 0, 27, 91, 52, 37, 63, 37, 112, 49, 37, 123, 49, 125, 37, 61, 37, 116, 52, 37, 101, 37, 112, 49, 37, 123, 51, 125, 37, 61, 37, 116, 54, 37, 101, 37, 112, 49, 37, 123, 52, 125, 37, 61, 37, 116, 49, 37, 101, 37, 112, 49, 37, 123, 54, 125, 37, 61, 37, 116, 51, 37, 101, 37, 112, 49, 37, 100, 37, 59, 109, 0, 27, 91, 77, 0, 27, 91, 51, 37, 112, 49, 37, 100, 109, 0, 27, 91, 52, 37, 112, 49, 37, 100, 109, 0, 27, 108, 0, 27, 109, 0}));
    }
    
    cli::array<unsigned char>* KnownTerminals::get_ansi() {
        return (new cli::array<unsigned char>({26, 1, 40, 0, 23, 0, 16, 0, 125, 1, 68, 2, 97, 110, 115, 105, 124, 97, 110, 115, 105, 47, 112, 99, 45, 116, 101, 114, 109, 32, 99, 111, 109, 112, 97, 116, 105, 98, 108, 101, 32, 119, 105, 116, 104, 32, 99, 111, 108, 111, 114, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 80, 0, 8, 0, 24, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 8, 0, 64, 0, 3, 0, 0, 0, 4, 0, 6, 0, 255, 255, 8, 0, 13, 0, 20, 0, 24, 0, 28, 0, 255, 255, 39, 0, 56, 0, 60, 0, 255, 255, 64, 0, 255, 255, 255, 255, 68, 0, 255, 255, 72, 0, 255, 255, 76, 0, 80, 0, 255, 255, 255, 255, 84, 0, 90, 0, 95, 0, 255, 255, 255, 255, 255, 255, 255, 255, 100, 0, 255, 255, 105, 0, 110, 0, 115, 0, 120, 0, 129, 0, 135, 0, 255, 255, 255, 255, 255, 255, 143, 0, 147, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 151, 0, 255, 255, 155, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 157, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 161, 0, 165, 0, 255, 255, 169, 0, 255, 255, 255, 255, 255, 255, 173, 0, 255, 255, 255, 255, 255, 255, 177, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 181, 0, 255, 255, 186, 0, 195, 0, 204, 0, 213, 0, 222, 0, 231, 0, 240, 0, 249, 0, 2, 1, 11, 1, 255, 255, 255, 255, 255, 255, 255, 255, 20, 1, 25, 1, 30, 1, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 50, 1, 255, 255, 61, 1, 255, 255, 63, 1, 149, 1, 255, 255, 152, 1, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 156, 1, 255, 255, 219, 1, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 223, 1, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 228, 1, 239, 1, 244, 1, 7, 2, 11, 2, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 20, 2, 30, 2, 255, 255, 255, 255, 255, 255, 40, 2, 44, 2, 48, 2, 52, 2, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 56, 2, 62, 2, 27, 91, 90, 0, 7, 0, 13, 0, 27, 91, 50, 103, 0, 27, 91, 72, 27, 91, 74, 0, 27, 91, 75, 0, 27, 91, 74, 0, 27, 91, 37, 105, 37, 112, 49, 37, 100, 71, 0, 27, 91, 37, 105, 37, 112, 49, 37, 100, 59, 37, 112, 50, 37, 100, 72, 0, 27, 91, 66, 0, 27, 91, 72, 0, 27, 91, 68, 0, 27, 91, 67, 0, 27, 91, 65, 0, 27, 91, 80, 0, 27, 91, 77, 0, 27, 91, 49, 49, 109, 0, 27, 91, 53, 109, 0, 27, 91, 49, 109, 0, 27, 91, 56, 109, 0, 27, 91, 55, 109, 0, 27, 91, 55, 109, 0, 27, 91, 52, 109, 0, 27, 91, 37, 112, 49, 37, 100, 88, 0, 27, 91, 49, 48, 109, 0, 27, 91, 48, 59, 49, 48, 109, 0, 27, 91, 109, 0, 27, 91, 109, 0, 27, 91, 76, 0, 8, 0, 27, 91, 66, 0, 27, 91, 72, 0, 27, 91, 76, 0, 27, 91, 68, 0, 27, 91, 67, 0, 27, 91, 65, 0, 13, 27, 91, 83, 0, 27, 91, 37, 112, 49, 37, 100, 80, 0, 27, 91, 37, 112, 49, 37, 100, 77, 0, 27, 91, 37, 112, 49, 37, 100, 66, 0, 27, 91, 37, 112, 49, 37, 100, 64, 0, 27, 91, 37, 112, 49, 37, 100, 83, 0, 27, 91, 37, 112, 49, 37, 100, 76, 0, 27, 91, 37, 112, 49, 37, 100, 68, 0, 27, 91, 37, 112, 49, 37, 100, 67, 0, 27, 91, 37, 112, 49, 37, 100, 84, 0, 27, 91, 37, 112, 49, 37, 100, 65, 0, 27, 91, 52, 105, 0, 27, 91, 53, 105, 0, 37, 112, 49, 37, 99, 27, 91, 37, 112, 50, 37, 123, 49, 125, 37, 45, 37, 100, 98, 0, 27, 91, 37, 105, 37, 112, 49, 37, 100, 100, 0, 10, 0, 27, 91, 48, 59, 49, 48, 37, 63, 37, 112, 49, 37, 116, 59, 55, 37, 59, 37, 63, 37, 112, 50, 37, 116, 59, 52, 37, 59, 37, 63, 37, 112, 51, 37, 116, 59, 55, 37, 59, 37, 63, 37, 112, 52, 37, 116, 59, 53, 37, 59, 37, 63, 37, 112, 54, 37, 116, 59, 49, 37, 59, 37, 63, 37, 112, 55, 37, 116, 59, 56, 37, 59, 37, 63, 37, 112, 57, 37, 116, 59, 49, 49, 37, 59, 109, 0, 27, 72, 0, 27, 91, 73, 0, 43, 16, 44, 17, 45, 24, 46, 25, 48, 219, 96, 4, 97, 177, 102, 248, 103, 241, 104, 176, 106, 217, 107, 191, 108, 218, 109, 192, 110, 197, 111, 126, 112, 196, 113, 196, 114, 196, 115, 95, 116, 195, 117, 180, 118, 193, 119, 194, 120, 179, 121, 243, 122, 242, 123, 227, 124, 216, 125, 156, 126, 254, 0, 27, 91, 90, 0, 27, 91, 49, 75, 0, 27, 91, 37, 105, 37, 100, 59, 37, 100, 82, 0, 27, 91, 54, 110, 0, 27, 91, 63, 37, 91, 59, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 93, 99, 0, 27, 91, 99, 0, 27, 91, 51, 57, 59, 52, 57, 109, 0, 27, 91, 51, 37, 112, 49, 37, 100, 109, 0, 27, 91, 52, 37, 112, 49, 37, 100, 109, 0, 27, 40, 66, 0, 27, 41, 66, 0, 27, 42, 66, 0, 27, 43, 66, 0, 27, 91, 49, 49, 109, 0, 27, 91, 49, 48, 109, 0}));
    }
    
}
namespace System {
    
    
}
namespace System {
    
    
    void LoaderOptimizationAttribute::constructor(unsigned char value) {
        this->lo = (LoaderOptimization)(value);
    }
    
    void LoaderOptimizationAttribute::constructor(LoaderOptimization value) {
        this->lo = value;
    }
    
    LoaderOptimization LoaderOptimizationAttribute::get_Value() {
        return this->lo;
    }
    
}
namespace System {
    
    Object*  LocalDataStoreSlot::lock_obj;
    cli::array<bool>*  LocalDataStoreSlot::slot_bitmap_thread;
    cli::array<bool>*  LocalDataStoreSlot::slot_bitmap_context;
    
    LocalDataStoreSlot::LocalDataStoreSlot()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void LocalDataStoreSlot::constructor(bool in_thread) {
        this->thread_local_ = in_thread;
        {
            cli::lock_guard{lock_obj};
            int32_t i;
            cli::array<bool> *slot_bitmap;
            if(in_thread) 
            {
                slot_bitmap = slot_bitmap_thread;
            }
             else 
            {
                slot_bitmap = slot_bitmap_context;
            }
            if((slot_bitmap != nullptr)) 
            {
                for(i = 0; (i < slot_bitmap->get_Length()); ++i){
                    if(!(slot_bitmap->at(i))) 
                    {
                        this->slot = i;
                        slot_bitmap->at(i) = true;
                        return;
                    }
                }
                cli::array<bool> *new_bitmap = (new cli::array<bool>((i + 2)));
                cli::import(slot_bitmap)->CopyTo(new_bitmap, 0);
                slot_bitmap = new_bitmap;
            }
             else 
            {
                slot_bitmap = (new cli::array<bool>(2));
                i = 0;
            }
            slot_bitmap->at(i) = true;
            this->slot = i;
            if(in_thread) 
            {
                slot_bitmap_thread = slot_bitmap;
            }
             else 
            {
                slot_bitmap_context = slot_bitmap;
            }
        }
    }
    
    void LocalDataStoreSlot::static_constructor() {
    }
    
    void LocalDataStoreSlot::Finalize_e34971a3d042a046() {
        {
            cli::finally_guard([&]() {
                Finalize_b946fbc32e26afd6();
            });
            Threading::Thread::FreeLocalSlotValues(this->slot, this->thread_local_);
            {
                cli::lock_guard{lock_obj};
                if(this->thread_local_) 
                {
                    slot_bitmap_thread->at(this->slot) = false;
                }
                 else 
                {
                    slot_bitmap_context->at(this->slot) = false;
                }
            }
        }
    }
    
}
namespace System {
    
    
    void MarshalByRefObject::constructor() {
    }
    
    Runtime::Remoting::Identity* MarshalByRefObject::GetObjectIdentity(MarshalByRefObject* obj, bool IsClient) {
        IsClient = false;
        Runtime::Remoting::Identity *objId = nullptr;
        if(Runtime::Remoting::RemotingServices::IsTransparentProxy(obj)) 
        {
            objId = Runtime::Remoting::RemotingServices::GetRealProxy(obj)->get_ObjectIdentity();
            IsClient = true;
        }
         else 
        {
            objId = obj->get_ObjectIdentity();
        }
        return objId;
    }
    
    Runtime::Remoting::ObjRef* MarshalByRefObject::CreateObjRef_53237520275c27b1(Type* requestedType) {
        if((this->_identity ==  nullptr)) 
        {
            throw cli::gcnew<Runtime::Remoting::RemotingException>(Locale::GetText(_T("No remoting information was found for the object.")));
        }
        return this->_identity->CreateObjRef_366556653a47f288(requestedType);
    }
    
    Object* MarshalByRefObject::GetLifetimeService() {
        if((this->_identity ==  nullptr)) 
        {
            return nullptr;
        }
         else 
        {
            return this->_identity->get_Lease();
        }
    }
    
    Object* MarshalByRefObject::InitializeLifetimeService_8f02e9c96ffbe30f() {
        if(((this->_identity != nullptr) && (this->_identity->get_Lease() != nullptr))) 
        {
            return this->_identity->get_Lease();
        }
         else 
        {
            return cli::gcnew<Runtime::Remoting::Lifetime::Lease>();
        }
    }
    
    MarshalByRefObject* MarshalByRefObject::MemberwiseClone2(bool cloneIdentity) {
        MarshalByRefObject *mbr = cli::cast<MarshalByRefObject*>(Object::MemberwiseClone());
        if(!(cloneIdentity)) 
        {
            mbr->_identity = nullptr;
        }
        return mbr;
    }
    
    Runtime::Remoting::ServerIdentity* MarshalByRefObject::get_ObjectIdentity() {
        return this->_identity;
    }
    
    Runtime::Remoting::ServerIdentity* MarshalByRefObject::set_ObjectIdentity(Runtime::Remoting::ServerIdentity* value) {
        this->_identity = value;
        return get_ObjectIdentity();
    }
    
}
namespace System {
    
    
    Decimal Math::Abs(Decimal value) {
        return Decimal::op_LessThan(value, cli::decimal<int>("0")) ? Decimal::op_UnaryNegation(value) : value;
    }
    
    double Math::Abs2(double value) {
        return (value < std::numeric_limits<double>::epsilon()) ? -(value) : value;
    }
    
    float Math::Abs3(float value) {
        return (value < std::numeric_limits<float>::epsilon()) ? -(value) : value;
    }
    
    int32_t Math::Abs4(int32_t value) {
        if((value ==  -2147483648)) 
        {
            throw cli::gcnew<OverflowException>(Locale::GetText(_T("Value is too small.")));
        }
        return (value < 0) ? -(value) : value;
    }
    
    int64_t Math::Abs5(int64_t value) {
        if((value ==  (-9223372036854775807L - 1))) 
        {
            throw cli::gcnew<OverflowException>(Locale::GetText(_T("Value is too small.")));
        }
        return (value < 0L) ? -(value) : value;
    }
    
    signed char Math::Abs6(signed char value) {
        if(((int32_t)(value) ==  -128)) 
        {
            throw cli::gcnew<OverflowException>(Locale::GetText(_T("Value is too small.")));
        }
        return (signed char)((int32_t)(value) < 0) ? -((int32_t)(value)) : (int32_t)(value);
    }
    
    int16_t Math::Abs7(int16_t value) {
        if(((int32_t)(value) ==  -32768)) 
        {
            throw cli::gcnew<OverflowException>(Locale::GetText(_T("Value is too small.")));
        }
        return (int16_t)((int32_t)(value) < 0) ? -((int32_t)(value)) : (int32_t)(value);
    }
    
    Decimal Math::Ceiling(Decimal d) {
        Decimal result = Floor2(d);
        if(Decimal::op_Inequality(result, d)) 
        {
            [&]() { auto tmp_170 = result; Decimal::op_Increment(result); return tmp_170; }();
        }
        return result;
    }
    
    double Math::Ceiling2(double a) {
        double result = Floor(a);
        if((result != a)) 
        {
            result++;
        }
        return result;
    }
    
    int64_t Math::BigMul(int32_t a, int32_t b) {
        return ((int64_t)(a) * (int64_t)(b));
    }
    
    int32_t Math::DivRem(int32_t a, int32_t b, int32_t result) {
        result = (a % b);
        return (int32_t)((a / b));
    }
    
    int64_t Math::DivRem2(int64_t a, int64_t b, int64_t result) {
        result = (a % b);
        return (int64_t)((a / b));
    }
    
    double Math::Floor(double d) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    double Math::IEEERemainder(double x, double y) {
        double r;
        if((y ==  std::numeric_limits<double>::epsilon())) 
        {
            return std::numeric_limits<double>::quiet_NaN();
        }
        r = (x - (y * Math::Round5((x / y))));
        if((r != std::numeric_limits<double>::epsilon())) 
        {
            return r;
        }
        return (x > std::numeric_limits<double>::epsilon()) ? std::numeric_limits<double>::epsilon() : BitConverter::Int64BitsToDouble((-9223372036854775807L - 1));
    }
    
    double Math::Log(double a, double newBase) {
        if((newBase ==  1.)) 
        {
            return std::numeric_limits<double>::quiet_NaN();
        }
        double result = (Log2(a) / Log2(newBase));
        return (result ==  std::numeric_limits<double>::epsilon()) ? std::numeric_limits<double>::epsilon() : result;
    }
    
    unsigned char Math::Max(unsigned char val1, unsigned char val2) {
        return ((int32_t)(val1) > (int32_t)(val2)) ? val1 : val2;
    }
    
    Decimal Math::Max2(Decimal val1, Decimal val2) {
        return Decimal::op_GreaterThan(val1, val2) ? val1 : val2;
    }
    
    double Math::Max3(double val1, double val2) {
        if((Double::IsNaN(val1) || Double::IsNaN(val2))) 
        {
            return std::numeric_limits<double>::quiet_NaN();
        }
        return (val1 > val2) ? val1 : val2;
    }
    
    float Math::Max4(float val1, float val2) {
        if((Single::IsNaN(val1) || Single::IsNaN(val2))) 
        {
            return std::numeric_limits<float>::quiet_NaN();
        }
        return (val1 > val2) ? val1 : val2;
    }
    
    int32_t Math::Max5(int32_t val1, int32_t val2) {
        return (val1 > val2) ? val1 : val2;
    }
    
    int64_t Math::Max6(int64_t val1, int64_t val2) {
        return (val1 > val2) ? val1 : val2;
    }
    
    signed char Math::Max7(signed char val1, signed char val2) {
        return ((int32_t)(val1) > (int32_t)(val2)) ? val1 : val2;
    }
    
    int16_t Math::Max8(int16_t val1, int16_t val2) {
        return ((int32_t)(val1) > (int32_t)(val2)) ? val1 : val2;
    }
    
    uint32_t Math::Max9(uint32_t val1, uint32_t val2) {
        return (val1 > val2) ? val1 : val2;
    }
    
    uint64_t Math::Max10(uint64_t val1, uint64_t val2) {
        return (val1 > val2) ? val1 : val2;
    }
    
    uint16_t Math::Max11(uint16_t val1, uint16_t val2) {
        return ((int32_t)(val1) > (int32_t)(val2)) ? val1 : val2;
    }
    
    unsigned char Math::Min(unsigned char val1, unsigned char val2) {
        return ((int32_t)(val1) < (int32_t)(val2)) ? val1 : val2;
    }
    
    Decimal Math::Min2(Decimal val1, Decimal val2) {
        return Decimal::op_LessThan(val1, val2) ? val1 : val2;
    }
    
    double Math::Min3(double val1, double val2) {
        if((Double::IsNaN(val1) || Double::IsNaN(val2))) 
        {
            return std::numeric_limits<double>::quiet_NaN();
        }
        return (val1 < val2) ? val1 : val2;
    }
    
    float Math::Min4(float val1, float val2) {
        if((Single::IsNaN(val1) || Single::IsNaN(val2))) 
        {
            return std::numeric_limits<float>::quiet_NaN();
        }
        return (val1 < val2) ? val1 : val2;
    }
    
    int32_t Math::Min5(int32_t val1, int32_t val2) {
        return (val1 < val2) ? val1 : val2;
    }
    
    int64_t Math::Min6(int64_t val1, int64_t val2) {
        return (val1 < val2) ? val1 : val2;
    }
    
    signed char Math::Min7(signed char val1, signed char val2) {
        return ((int32_t)(val1) < (int32_t)(val2)) ? val1 : val2;
    }
    
    int16_t Math::Min8(int16_t val1, int16_t val2) {
        return ((int32_t)(val1) < (int32_t)(val2)) ? val1 : val2;
    }
    
    uint32_t Math::Min9(uint32_t val1, uint32_t val2) {
        return (val1 < val2) ? val1 : val2;
    }
    
    uint64_t Math::Min10(uint64_t val1, uint64_t val2) {
        return (val1 < val2) ? val1 : val2;
    }
    
    uint16_t Math::Min11(uint16_t val1, uint16_t val2) {
        return ((int32_t)(val1) < (int32_t)(val2)) ? val1 : val2;
    }
    
    Decimal Math::Round(Decimal d) {
        Decimal int_part = Decimal::Floor(d);
        Decimal dec_part = Decimal::op_Subtraction(d, int_part);
        if(((Decimal::op_Equality(dec_part, cli::decimal<int>("0.5")) && Decimal::op_Inequality(Decimal::op_Multiply(cli::decimal<int>("2.0"), Decimal::op_Subtraction(Decimal::op_Division(int_part, cli::decimal<int>("2.0")), Decimal::Floor(Decimal::op_Division(int_part, cli::decimal<int>("2.0"))))), cli::decimal<int>("0.0"))) || Decimal::op_GreaterThan(dec_part, cli::decimal<int>("0.5")))) 
        {
            [&]() { auto tmp_171 = int_part; Decimal::op_Increment(int_part); return tmp_171; }();
        }
        return int_part;
    }
    
    Decimal Math::Round2(Decimal d, int32_t decimals) {
        return Decimal::Round(d, decimals);
    }
    
    Decimal Math::Round3(Decimal d, MidpointRounding mode) {
        if((((int32_t)(mode) != 0) && ((int32_t)(mode) != 1))) 
        {
            throw cli::gcnew<ArgumentException>(cli::concat(_T("The value \'"), cli::box(mode)), _T("mode"));
        }
        if(((int32_t)(mode) ==  0)) 
        {
            return Round(d);
        }
         else 
        {
            return RoundAwayFromZero(d);
        }
    }
    
    Decimal Math::RoundAwayFromZero(Decimal d) {
        Decimal int_part = Decimal::Floor(d);
        Decimal dec_part = Decimal::op_Subtraction(d, int_part);
        if((Decimal::op_GreaterThanOrEqual(int_part, cli::decimal<int>("0")) && Decimal::op_GreaterThanOrEqual(dec_part, cli::decimal<int>("0.5")))) 
        {
            [&]() { auto tmp_172 = int_part; Decimal::op_Increment(int_part); return tmp_172; }();
        }
         else 
        {
            if((Decimal::op_LessThan(int_part, cli::decimal<int>("0")) && Decimal::op_GreaterThan(dec_part, cli::decimal<int>("0.5")))) 
            {
                [&]() { auto tmp_173 = int_part; Decimal::op_Increment(int_part); return tmp_173; }();
            }
        }
        return int_part;
    }
    
    Decimal Math::Round4(Decimal d, int32_t decimals, MidpointRounding mode) {
        return Decimal::Round2(d, decimals, mode);
    }
    
    double Math::Round5(double a) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    double Math::Round6(double value, int32_t digits) {
        if(((digits < 0) || (digits > 15))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(Locale::GetText(_T("Value is too small or too big.")));
        }
        if((digits ==  0)) 
        {
            return Round5(value);
        }
        return Round22(value, digits, false);
    }
    
    double Math::Round22(double value, int32_t digits, bool away_from_zero) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    double Math::Round7(double value, MidpointRounding mode) {
        if((((int32_t)(mode) != 0) && ((int32_t)(mode) != 1))) 
        {
            throw cli::gcnew<ArgumentException>(cli::concat(_T("The value \'"), cli::box(mode)), _T("mode"));
        }
        if(((int32_t)(mode) ==  0)) 
        {
            return Round5(value);
        }
        if((value > std::numeric_limits<double>::epsilon())) 
        {
            return Floor((value + 0.5));
        }
         else 
        {
            return Ceiling2((value - 0.5));
        }
    }
    
    double Math::Round8(double value, int32_t digits, MidpointRounding mode) {
        if((((int32_t)(mode) != 0) && ((int32_t)(mode) != 1))) 
        {
            throw cli::gcnew<ArgumentException>(cli::concat(_T("The value \'"), cli::box(mode)), _T("mode"));
        }
        if((digits ==  0)) 
        {
            return Round7(value, mode);
        }
        if(((int32_t)(mode) ==  0)) 
        {
            return Round6(value, digits);
        }
         else 
        {
            return Round22(value, digits, true);
        }
    }
    
    double Math::Truncate(double d) {
        if((d > std::numeric_limits<double>::epsilon())) 
        {
            return Floor(d);
        }
         else 
        {
            if((d < std::numeric_limits<double>::epsilon())) 
            {
                return Ceiling2(d);
            }
             else 
            {
                return d;
            }
        }
    }
    
    Decimal Math::Truncate2(Decimal d) {
        return Decimal::Truncate(d);
    }
    
    Decimal Math::Floor2(Decimal d) {
        return Decimal::Floor(d);
    }
    
    int32_t Math::Sign2(Decimal value) {
        if(Decimal::op_GreaterThan(value, cli::decimal<int>("0"))) 
        {
            return 1;
        }
        return Decimal::op_Equality(value, cli::decimal<int>("0")) ? 0 : -1;
    }
    
    int32_t Math::Sign3(double value) {
        if(Double::IsNaN(value)) 
        {
            throw cli::gcnew<ArithmeticException>(_T("NAN"));
        }
        if((value > std::numeric_limits<double>::epsilon())) 
        {
            return 1;
        }
        return (value ==  std::numeric_limits<double>::epsilon()) ? 0 : -1;
    }
    
    int32_t Math::Sign4(float value) {
        if(Single::IsNaN(value)) 
        {
            throw cli::gcnew<ArithmeticException>(_T("NAN"));
        }
        if((value > std::numeric_limits<float>::epsilon())) 
        {
            return 1;
        }
        return (value ==  std::numeric_limits<float>::epsilon()) ? 0 : -1;
    }
    
    int32_t Math::Sign5(int32_t value) {
        if((value > 0)) 
        {
            return 1;
        }
        return (value ==  0) ? 0 : -1;
    }
    
    int32_t Math::Sign6(int64_t value) {
        if((value > 0L)) 
        {
            return 1;
        }
        return (value ==  0L) ? 0 : -1;
    }
    
    int32_t Math::Sign7(signed char value) {
        if(((int32_t)(value) > 0)) 
        {
            return 1;
        }
        return ((int32_t)(value) ==  0) ? 0 : -1;
    }
    
    int32_t Math::Sign8(int16_t value) {
        if(((int32_t)(value) > 0)) 
        {
            return 1;
        }
        return ((int32_t)(value) ==  0) ? 0 : -1;
    }
    
    double Math::Sin(double a) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    double Math::Cos(double d) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    double Math::Tan(double a) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    double Math::Sinh(double value) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    double Math::Cosh(double value) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    double Math::Tanh(double value) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    double Math::Acos(double d) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    double Math::Asin(double d) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    double Math::Atan(double d) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    double Math::Atan2(double y, double x) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    double Math::Exp(double d) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    double Math::Log2(double d) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    double Math::Log10(double d) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    double Math::Pow(double x, double y) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    double Math::Sqrt(double d) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
}
namespace System {
    
    
    void MemberAccessException::constructor() {
        this->set_HResult(-2146233062);
    }
    
    void MemberAccessException::constructor(String* message) {
        this->set_HResult(-2146233062);
    }
    
    void MemberAccessException::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
    }
    
    void MemberAccessException::constructor(String* message, Exception* inner) {
        this->set_HResult(-2146233062);
    }
    
}
namespace System {
    
    
    void MethodAccessException::constructor() {
        this->set_HResult(-2146233072);
    }
    
    void MethodAccessException::constructor(String* message) {
        this->set_HResult(-2146233072);
    }
    
    void MethodAccessException::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
    }
    
    void MethodAccessException::constructor(String* message, Exception* inner) {
        this->set_HResult(-2146233072);
    }
    
}
namespace System {
    
    
    void MissingFieldException::constructor() {
        this->set_HResult(-2146233071);
    }
    
    void MissingFieldException::constructor(String* message) {
        this->set_HResult(-2146233071);
    }
    
    void MissingFieldException::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
    }
    
    void MissingFieldException::constructor(String* message, Exception* inner) {
        this->set_HResult(-2146233071);
    }
    
    void MissingFieldException::constructor(String* className, String* fieldName) {
        this->set_HResult(-2146233071);
    }
    
    String* MissingFieldException::get_Message_d211df4045b57cbf() {
        if((this->ClassName ==  nullptr)) 
        {
            return MissingMemberException::get_Message_d211df4045b57cbf();
        }
        String *msg = Locale::GetText(_T("Field \'{0}.{1}\' not found."));
        return String::Format3(msg, this->ClassName, this->MemberName);
    }
    
}
namespace System {
    
    
    void MissingMemberException::constructor() {
        this->set_HResult(-2146233070);
    }
    
    void MissingMemberException::constructor(String* message) {
        this->set_HResult(-2146233070);
    }
    
    void MissingMemberException::constructor(String* message, Exception* inner) {
        this->set_HResult(-2146233070);
    }
    
    void MissingMemberException::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        this->ClassName = info->GetString(_T("MMClassName"));
        this->MemberName = info->GetString(_T("MMMemberName"));
        this->Signature = cli::cast<cli::array<unsigned char>*>(info->GetValue(_T("MMSignature"), cli::typeof<Type>::info));
    }
    
    void MissingMemberException::constructor(String* className, String* memberName) {
        this->ClassName = className;
        this->MemberName = memberName;
        this->set_HResult(-2146233070);
    }
    
    void MissingMemberException::GetObjectData_bc9b88d7eb43b6d8(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        MemberAccessException::GetObjectData_bc9b88d7eb43b6d8(info, context);
        info->AddValue16(_T("MMClassName"), this->ClassName);
        info->AddValue16(_T("MMMemberName"), this->MemberName);
        info->AddValue16(_T("MMSignature"), this->Signature);
    }
    
    String* MissingMemberException::get_Message_d211df4045b57cbf() {
        if((this->ClassName ==  nullptr)) 
        {
            return MemberAccessException::get_Message_d211df4045b57cbf();
        }
        String *msg = Locale::GetText(_T("Member {0}.{1} not found."));
        return String::Format3(msg, this->ClassName, this->MemberName);
    }
    
}
namespace System {
    
    
    void MissingMethodException::constructor() {
        this->set_HResult(-2146233069);
    }
    
    void MissingMethodException::constructor(String* message) {
        this->set_HResult(-2146233069);
    }
    
    void MissingMethodException::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
    }
    
    void MissingMethodException::constructor(String* message, Exception* inner) {
        this->set_HResult(-2146233069);
    }
    
    void MissingMethodException::constructor(String* className, String* methodName) {
        this->set_HResult(-2146233069);
    }
    
    String* MissingMethodException::get_Message_d211df4045b57cbf() {
        if((this->ClassName ==  nullptr)) 
        {
            return MissingMemberException::get_Message_d211df4045b57cbf();
        }
        String *msg = Locale::GetText(_T("Method not found: \'{0}.{1}\'."));
        return String::Format3(msg, this->ClassName, this->MemberName);
    }
    
}
namespace System {
    
    
    void MonoAsyncCall::constructor() {
    }
    
}
namespace System {
    
    
    void MonoCQItem::constructor() {
    }
    
}
namespace System {
    
    
    void AttributeInfo::constructor(AttributeUsageAttribute* usage, int32_t inheritanceLevel) {
        this->_usage = usage;
        this->_inheritanceLevel = inheritanceLevel;
    }
    
    AttributeUsageAttribute* AttributeInfo::get_Usage() {
        return this->_usage;
    }
    
    int32_t AttributeInfo::get_InheritanceLevel() {
        return this->_inheritanceLevel;
    }
    
}
namespace System {
    
    Reflection::Assembly*  MonoCustomAttrs::corlib;
    Type*  MonoCustomAttrs::AttributeUsageType;
    AttributeUsageAttribute*  MonoCustomAttrs::DefaultAttributeUsage;
    
    MonoCustomAttrs::MonoCustomAttrs()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void MonoCustomAttrs::constructor() {
    }
    
    void MonoCustomAttrs::static_constructor() {
    }
    
    bool MonoCustomAttrs::IsUserCattrProvider(Object* obj) {
        Type *type = cli::as<Type*>(obj);
        if((cli::is<MonoType>(type) || cli::is<Reflection::Emit::TypeBuilder>(type))) 
        {
            return false;
        }
        if(cli::is<Type>(obj)) 
        {
            return true;
        }
        if(Reflection::Assembly::op_Equality(corlib, nullptr)) 
        {
            corlib = cli::typeof<Type>::info->get_Assembly_3aae0acbf2a6d696();
        }
        return Reflection::Assembly::op_Inequality(obj->GetType()->get_Assembly_3aae0acbf2a6d696(), corlib);
    }
    
    cli::array<Object*>* MonoCustomAttrs::GetCustomAttributesInternal(Reflection::ICustomAttributeProvider* obj, Type* attributeType, bool pseudoAttrs) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    cli::array<Object*>* MonoCustomAttrs::GetPseudoCustomAttributes(Reflection::ICustomAttributeProvider* obj, Type* attributeType) {
        cli::array<Object*> *pseudoAttrs = nullptr;
        if(cli::is<Reflection::MonoMethod>(obj)) 
        {
            pseudoAttrs = cli::cast<Reflection::MonoMethod*>(obj)->GetPseudoCustomAttributes();
        }
         else 
        {
            if(cli::is<Reflection::FieldInfo>(obj)) 
            {
                pseudoAttrs = cli::cast<Reflection::FieldInfo*>(obj)->GetPseudoCustomAttributes();
            }
             else 
            {
                if(cli::is<Reflection::ParameterInfo>(obj)) 
                {
                    pseudoAttrs = cli::cast<Reflection::ParameterInfo*>(obj)->GetPseudoCustomAttributes();
                }
                 else 
                {
                    if(cli::is<Type>(obj)) 
                    {
                        pseudoAttrs = cli::cast<Type*>(obj)->GetPseudoCustomAttributes();
                    }
                }
            }
        }
        if((Type::op_Inequality2(attributeType, nullptr) && (pseudoAttrs != nullptr))) 
        {
            for(int32_t i = 0; (i < pseudoAttrs->get_Length()); ++i) {
                if(attributeType->IsAssignableFrom_e3aa32d778e63a90(pseudoAttrs->at(i)->GetType())) 
                {
                    if((pseudoAttrs->get_Length() ==  1)) 
                    {
                        return pseudoAttrs;
                    }
                     else 
                    {
                        return (new cli::array<Object*>({pseudoAttrs->at(i)}));
                    }
                }
            }
            return (new cli::array<Object*>(0));
        }
         else 
        {
            return pseudoAttrs;
        }
    }
    
    cli::array<Object*>* MonoCustomAttrs::GetCustomAttributesBase(Reflection::ICustomAttributeProvider* obj, Type* attributeType) {
        cli::array<Object*> *attrs;
        if(IsUserCattrProvider(obj)) 
        {
            attrs = obj->GetCustomAttributes_a458b60110eb1adc(attributeType, true);
        }
         else 
        {
            attrs = GetCustomAttributesInternal(obj, attributeType, false);
        }
        cli::array<Object*> *pseudoAttrs = GetPseudoCustomAttributes(obj, attributeType);
        if((pseudoAttrs != nullptr)) 
        {
            cli::array<Object*> *res = (new cli::array<Object*>((attrs->get_Length() + pseudoAttrs->get_Length())));
            Array::Copy(attrs, res, attrs->get_Length());
            Array::Copy2(pseudoAttrs, 0, res, attrs->get_Length(), pseudoAttrs->get_Length());
            return res;
        }
         else 
        {
            return attrs;
        }
    }
    
    Attribute* MonoCustomAttrs::GetCustomAttribute(Reflection::ICustomAttributeProvider* obj, Type* attributeType, bool inherit) {
        cli::array<Object*> *res = GetCustomAttributes(obj, attributeType, inherit);
        if((res->get_Length() ==  0)) 
        {
            return nullptr;
        }
         else 
        {
            if((res->get_Length() > 1)) 
            {
                String *msg = _T("\'{0}\' has more than one attribute of type \'{1}");
                msg = String::Format3(msg, obj, attributeType);
                throw cli::gcnew<Reflection::AmbiguousMatchException>(msg);
            }
        }
        return cli::cast<Attribute*>(res->at(0));
    }
    
    cli::array<Object*>* MonoCustomAttrs::GetCustomAttributes(Reflection::ICustomAttributeProvider* obj, Type* attributeType, bool inherit) {
        if((obj ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("obj"));
        }
        if(Type::op_Equality2(attributeType, nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("attributeType"));
        }
        if(Type::op_Equality2(attributeType, cli::typeof<Type>::info)) 
        {
            attributeType = nullptr;
        }
        cli::array<Object*> *r;
        cli::array<Object*> *res = GetCustomAttributesBase(obj, attributeType);
        if((!(inherit) && (res->get_Length() ==  1))) 
        {
            if((res->at(0) ==  nullptr)) 
            {
                throw cli::gcnew<Reflection::CustomAttributeFormatException>(_T("Invalid custom attribute format"));
            }
            if(Type::op_Inequality2(attributeType, nullptr)) 
            {
                if(attributeType->IsAssignableFrom_e3aa32d778e63a90(res->at(0)->GetType())) 
                {
                    r = cli::cast<cli::array<Object*>*>(Array::CreateInstance(attributeType, 1));
                    r->at(0) = res->at(0);
                }
                 else 
                {
                    r = cli::cast<cli::array<Object*>*>(Array::CreateInstance(attributeType, 0));
                }
            }
             else 
            {
                r = cli::cast<cli::array<Object*>*>(Array::CreateInstance(res->at(0)->GetType(), 1));
                r->at(0) = res->at(0);
            }
            return r;
        }
        if(((Type::op_Inequality2(attributeType, nullptr) && attributeType->get_IsSealed()) && inherit)) 
        {
            AttributeUsageAttribute *usageAttribute = RetrieveAttributeUsage(attributeType);
            if(!(usageAttribute->get_Inherited())) 
            {
                inherit = false;
            }
        }
        int32_t initialSize = (res->get_Length() < 16) ? res->get_Length() : 16;
        Collections::Hashtable *attributeInfos = cli::gcnew<Collections::Hashtable>(initialSize);
        Collections::ArrayList *a = cli::gcnew<Collections::ArrayList>(initialSize);
        Reflection::ICustomAttributeProvider *btype = obj;
        int32_t inheritanceLevel = 0;
        do {
            for(auto tmp_174 : res) {
                auto attr = cli::cast<Object*>(tmp_174);
                {
                    AttributeUsageAttribute *usage;
                    if((attr ==  nullptr)) 
                    {
                        throw cli::gcnew<Reflection::CustomAttributeFormatException>(_T("Invalid custom attribute format"));
                    }
                    Type *attrType = attr->GetType();
                    if(Type::op_Inequality2(attributeType, nullptr)) 
                    {
                        if(!(attributeType->IsAssignableFrom_e3aa32d778e63a90(attrType))) 
                        {
                            continue;
                        }
                    }
                    AttributeInfo *firstAttribute = cli::cast<AttributeInfo*>(attributeInfos->get_Item_d75c6e706b965758(attrType));
                    if((firstAttribute != nullptr)) 
                    {
                        usage = firstAttribute->get_Usage();
                    }
                     else 
                    {
                        usage = RetrieveAttributeUsage(attrType);
                    }
                    if((((inheritanceLevel ==  0) || usage->get_Inherited()) && (usage->get_AllowMultiple() || ((firstAttribute ==  nullptr) || ((firstAttribute != nullptr) && (firstAttribute->get_InheritanceLevel() ==  inheritanceLevel)))))) 
                    {
                        a->Add_e6a92085999ce388(attr);
                    }
                    if((firstAttribute ==  nullptr)) 
                    {
                        attributeInfos->Add_3f7ab157bcb41156(attrType, cli::gcnew<AttributeInfo>(usage, inheritanceLevel));
                    }
                }
            }
            if(((btype = GetBase(btype)) != (nullptr))) 
            {
                inheritanceLevel++;
                res = GetCustomAttributesBase(btype, attributeType);
            }
        }
        while((inherit && (btype != nullptr)));
        cli::array<Object*> *array = nullptr;
        if((Type::op_Equality2(attributeType, nullptr) || attributeType->get_IsValueType())) 
        {
            array = cli::cast<cli::array<Object*>*>(Array::CreateInstance(cli::typeof<Type>::info, a->get_Count_2354963792616712()));
        }
         else 
        {
            array = cli::as<cli::array<Object*>*>(Array::CreateInstance(attributeType, a->get_Count_2354963792616712()));
        }
        a->CopyTo_2bc540dad3c25b9e(array, 0);
        return array;
    }
    
    cli::array<Object*>* MonoCustomAttrs::GetCustomAttributes2(Reflection::ICustomAttributeProvider* obj, bool inherit) {
        if((obj ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("obj"));
        }
        if(!(inherit)) 
        {
            return cli::cast<cli::array<Object*>*>(cli::import(GetCustomAttributesBase(obj, nullptr))->Clone());
        }
        return GetCustomAttributes(obj, cli::typeof<Type>::info, inherit);
    }
    
    cli::array<Reflection::CustomAttributeData*>* MonoCustomAttrs::GetCustomAttributesDataInternal(Reflection::ICustomAttributeProvider* obj) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    Collections::Generic::IList2<Reflection::CustomAttributeData*>* MonoCustomAttrs::GetCustomAttributesData(Reflection::ICustomAttributeProvider* obj) {
        if((obj ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("obj"));
        }
        cli::array<Reflection::CustomAttributeData*> *attrs = GetCustomAttributesDataInternal(obj);
        return Array::template AsReadOnly_1<Reflection::CustomAttributeData*>(attrs);
    }
    
    bool MonoCustomAttrs::IsDefined(Reflection::ICustomAttributeProvider* obj, Type* attributeType, bool inherit) {
        if(Type::op_Equality2(attributeType, nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("attributeType"));
        }
        AttributeUsageAttribute *usage = nullptr;
        do {
            if(IsUserCattrProvider(obj)) 
            {
                return obj->IsDefined_3200a5511fa7cc68(attributeType, inherit);
            }
            if(IsDefinedInternal(obj, attributeType)) 
            {
                return true;
            }
            cli::array<Object*> *pseudoAttrs = GetPseudoCustomAttributes(obj, attributeType);
            if((pseudoAttrs != nullptr)) 
            {
                for(int32_t i = 0; (i < pseudoAttrs->get_Length()); ++i) {
                    if(attributeType->IsAssignableFrom_e3aa32d778e63a90(pseudoAttrs->at(i)->GetType())) 
                    {
                        return true;
                    }
                }
            }
            if((usage ==  nullptr)) 
            {
                if(!(inherit)) 
                {
                    return false;
                }
                usage = RetrieveAttributeUsage(attributeType);
                if(!(usage->get_Inherited())) 
                {
                    return false;
                }
            }
            obj = GetBase(obj);
        }
        while((obj != nullptr));
        return false;
    }
    
    bool MonoCustomAttrs::IsDefinedInternal(Reflection::ICustomAttributeProvider* obj, Type* AttributeType) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    Reflection::PropertyInfo* MonoCustomAttrs::GetBasePropertyDefinition(Reflection::PropertyInfo* property) {
        Reflection::MethodInfo *method = property->GetGetMethod_598f563fd3755017(true);
        if((Reflection::MethodInfo::op_Equality(method, nullptr) || !(method->get_IsVirtual()))) 
        {
            method = property->GetSetMethod_8896cb22c4f8d900(true);
        }
        if((Reflection::MethodInfo::op_Equality(method, nullptr) || !(method->get_IsVirtual()))) 
        {
            return nullptr;
        }
        Reflection::MethodInfo *baseMethod = method->GetBaseMethod_15ff4b8595f9b09();
        if((Reflection::MethodInfo::op_Inequality(baseMethod, nullptr) && Reflection::MethodInfo::op_Inequality(baseMethod, method))) 
        {
            cli::array<Reflection::ParameterInfo*> *parameters = property->GetIndexParameters_66437e9b713ac629();
            if(((parameters != nullptr) && (parameters->get_Length() > 0))) 
            {
                cli::array<Type*> *paramTypes = (new cli::array<Type*>(parameters->get_Length()));
                for(int32_t i = 0; (i < paramTypes->get_Length()); i++) {
                    paramTypes->at(i) = parameters->at(i)->get_ParameterType_97c5fa09a0b988d();
                }
                return baseMethod->get_DeclaringType_6121cd6a84393166()->GetProperty5(property->get_Name_50fad5fa936c3ae2(), property->get_PropertyType_68b4b04678fe4f8a(), paramTypes);
            }
             else 
            {
                return baseMethod->get_DeclaringType_6121cd6a84393166()->GetProperty3(property->get_Name_50fad5fa936c3ae2(), property->get_PropertyType_68b4b04678fe4f8a());
            }
        }
        return nullptr;
    }
    
    Reflection::EventInfo* MonoCustomAttrs::GetBaseEventDefinition(Reflection::EventInfo* evt) {
        Reflection::MethodInfo *method = evt->GetAddMethod_e6ed2f5f0e24f59f(true);
        if((Reflection::MethodInfo::op_Equality(method, nullptr) || !(method->get_IsVirtual()))) 
        {
            method = evt->GetRaiseMethod_da2f94f17ce18705(true);
        }
        if((Reflection::MethodInfo::op_Equality(method, nullptr) || !(method->get_IsVirtual()))) 
        {
            method = evt->GetRemoveMethod_2709ba07e73fded4(true);
        }
        if((Reflection::MethodInfo::op_Equality(method, nullptr) || !(method->get_IsVirtual()))) 
        {
            return nullptr;
        }
        Reflection::MethodInfo *baseMethod = method->GetBaseMethod_15ff4b8595f9b09();
        if((Reflection::MethodInfo::op_Inequality(baseMethod, nullptr) && Reflection::MethodInfo::op_Inequality(baseMethod, method))) 
        {
            Reflection::BindingFlags flags = method->get_IsPublic() ? Reflection::BindingFlags::Public : Reflection::BindingFlags::NonPublic;
            (flags = (Reflection::BindingFlags)(((int32_t)(flags) | (int32_t)(method->get_IsStatic() ? Reflection::BindingFlags::Static : Reflection::BindingFlags::Instance))));
            return baseMethod->get_DeclaringType_6121cd6a84393166()->GetEvent_7f053fa54114e387(evt->get_Name_50fad5fa936c3ae2(), flags);
        }
        return nullptr;
    }
    
    Reflection::ICustomAttributeProvider* MonoCustomAttrs::GetBase(Reflection::ICustomAttributeProvider* obj) {
        if((obj ==  nullptr)) 
        {
            return nullptr;
        }
        if(cli::is<Type>(obj)) 
        {
            return cli::cast<Type*>(obj)->get_BaseType_6a0646ae880055f6();
        }
        Reflection::MethodInfo *method = nullptr;
        if(cli::is<Reflection::MonoProperty>(obj)) 
        {
            return GetBasePropertyDefinition(cli::cast<Reflection::MonoProperty*>(obj));
        }
         else 
        {
            if(cli::is<Reflection::MonoEvent>(obj)) 
            {
                return GetBaseEventDefinition(cli::cast<Reflection::MonoEvent*>(obj));
            }
             else 
            {
                if(cli::is<Reflection::MonoMethod>(obj)) 
                {
                    method = cli::cast<Reflection::MethodInfo*>(obj);
                }
            }
        }
        if((Reflection::MethodInfo::op_Equality(method, nullptr) || !(method->get_IsVirtual()))) 
        {
            return nullptr;
        }
        Reflection::MethodInfo *baseMethod = method->GetBaseMethod_15ff4b8595f9b09();
        if(Reflection::MethodInfo::op_Equality(baseMethod, method)) 
        {
            return nullptr;
        }
        return baseMethod;
    }
    
    AttributeUsageAttribute* MonoCustomAttrs::RetrieveAttributeUsage(Type* attributeType) {
        if(Type::op_Equality2(attributeType, cli::typeof<Type>::info)) 
        {
            return cli::gcnew<AttributeUsageAttribute>(AttributeTargets::Class);
        }
        AttributeUsageAttribute *usageAttribute = nullptr;
        cli::array<Object*> *attribs = GetCustomAttributes(attributeType, AttributeUsageType, false);
        if((attribs->get_Length() ==  0)) 
        {
            if(Type::op_Inequality2(attributeType->get_BaseType_6a0646ae880055f6(), nullptr)) 
            {
                usageAttribute = RetrieveAttributeUsage(attributeType->get_BaseType_6a0646ae880055f6());
            }
            if((usageAttribute != nullptr)) 
            {
                return usageAttribute;
            }
            return DefaultAttributeUsage;
        }
        if((attribs->get_Length() > 1)) 
        {
            throw cli::gcnew<FormatException>(_T("Duplicate AttributeUsageAttribute cannot be specified on an attribute type."));
        }
        return cli::cast<AttributeUsageAttribute*>(attribs->at(0));
    }
    
}
namespace System {
    
    
    void MonoListItem::constructor() {
    }
    
}
namespace System {
    
    
    void MonoTypeInfo::constructor() {
    }
    
}
namespace System {
    
    
    void MonoType::constructor(Object* obj) {
        type_from_obj(this, obj);
        throw cli::gcnew<NotImplementedException>();
    }
    
    void MonoType::type_from_obj(MonoType* type, Object* obj) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    Reflection::TypeAttributes MonoType::get_attributes(Type* type) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    Reflection::ConstructorInfo* MonoType::GetDefaultConstructor() {
        Reflection::ConstructorInfo *ctor = nullptr;
        if((this->type_info ==  nullptr)) 
        {
            this->type_info = cli::gcnew<MonoTypeInfo>();
        }
        if(Reflection::ConstructorInfo::op_Equality(ctor = this->type_info->default_ctor, nullptr)) 
        {
            const Reflection::BindingFlags flags = (Reflection::BindingFlags)52L;
            ctor = this->type_info->default_ctor = Type::GetConstructor4((Reflection::BindingFlags)52L, nullptr, Reflection::CallingConventions::Any, Type::EmptyTypes, nullptr);
        }
        return ctor;
    }
    
    Reflection::TypeAttributes MonoType::GetAttributeFlagsImpl_ea77781598cb234a() {
        return get_attributes(this);
    }
    
    Reflection::ConstructorInfo* MonoType::GetConstructorImpl_a21b5d13a475afe1(Reflection::BindingFlags bindingAttr, Reflection::Binder* binder, Reflection::CallingConventions callConvention, cli::array<Type*>* types, cli::array<Reflection::ParameterModifier>* modifiers) {
        cli::array<Reflection::ConstructorInfo*> *methods = GetConstructors_f24cc6cf9c6f79c6(bindingAttr);
        return GetConstructorImpl3(methods, bindingAttr, binder, callConvention, types, modifiers);
    }
    
    Reflection::ConstructorInfo* MonoType::GetConstructorImpl3(cli::array<Reflection::ConstructorInfo*>* methods, Reflection::BindingFlags bindingAttr, Reflection::Binder* binder, Reflection::CallingConventions callConvention, cli::array<Type*>* types, cli::array<Reflection::ParameterModifier>* modifiers) {
        if(((int32_t)(bindingAttr) ==  0)) 
        {
            bindingAttr = (Reflection::BindingFlags)20L;
        }
        Reflection::ConstructorInfo *found = nullptr;
        cli::array<Reflection::MethodBase*> *match;
        int32_t count = 0;
        for(auto tmp_175 : methods) {
            auto m = cli::cast<Reflection::ConstructorInfo*>(tmp_175);
            {
                if((((int32_t)(callConvention) != 3) && ((int32_t)(((int32_t)(m->get_CallingConvention_309cf574b58a053a()) & (int32_t)(callConvention))) != (int32_t)(callConvention)))) 
                {
                    continue;
                }
                found = m;
                count++;
            }
        }
        if((count ==  0)) 
        {
            return nullptr;
        }
        if((types ==  nullptr)) 
        {
            if((count > 1)) 
            {
                throw cli::gcnew<Reflection::AmbiguousMatchException>();
            }
            return cli::cast<Reflection::ConstructorInfo*>(CheckMethodSecurity(found));
        }
        match = (new cli::array<Reflection::MethodBase*>(count));
        if((count ==  1)) 
        {
            match->at(0) = found;
        }
         else 
        {
            count = 0;
            for(auto tmp_176 : methods) {
                auto m = cli::cast<Reflection::ConstructorInfo*>(tmp_176);
                {
                    if((((int32_t)(callConvention) != 3) && ((int32_t)(((int32_t)(m->get_CallingConvention_309cf574b58a053a()) & (int32_t)(callConvention))) != (int32_t)(callConvention)))) 
                    {
                        continue;
                    }
                    match->at(count++) = m;
                }
            }
        }
        if((binder ==  nullptr)) 
        {
            binder = Reflection::Binder::get_DefaultBinder();
        }
        return cli::cast<Reflection::ConstructorInfo*>(CheckMethodSecurity(binder->SelectMethod_3e1ca0f0e362534f(bindingAttr, match, types, modifiers)));
    }
    
    cli::array<Reflection::ConstructorInfo*>* MonoType::GetConstructors_internal(Reflection::BindingFlags bindingAttr, Type* reflected_type) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    cli::array<Reflection::ConstructorInfo*>* MonoType::GetConstructors_736b6e990b94b352(Reflection::BindingFlags bindingAttr) {
        return GetConstructors_internal(bindingAttr, this);
    }
    
    Reflection::EventInfo* MonoType::InternalGetEvent(String* name, Reflection::BindingFlags bindingAttr) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    Reflection::EventInfo* MonoType::GetEvent_7f053fa54114e387(String* name, Reflection::BindingFlags bindingAttr) {
        if((name ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("name"));
        }
        return InternalGetEvent(name, bindingAttr);
    }
    
    cli::array<Reflection::EventInfo*>* MonoType::GetEvents_internal(Reflection::BindingFlags bindingAttr, Type* reflected_type) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    cli::array<Reflection::EventInfo*>* MonoType::GetEvents_a960b087e4d67be2(Reflection::BindingFlags bindingAttr) {
        return GetEvents_internal(bindingAttr, this);
    }
    
    Reflection::FieldInfo* MonoType::GetField_fb08cba9d1a4bc84(String* name, Reflection::BindingFlags bindingAttr) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    cli::array<Reflection::FieldInfo*>* MonoType::GetFields_internal(Reflection::BindingFlags bindingAttr, Type* reflected_type) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    cli::array<Reflection::FieldInfo*>* MonoType::GetFields_369be5ac49d99f8(Reflection::BindingFlags bindingAttr) {
        return GetFields_internal(bindingAttr, this);
    }
    
    Type* MonoType::GetInterface_55c1d0ec3ece6104(String* name, bool ignoreCase) {
        if((name ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>();
        }
        cli::array<Type*> *interfaces = GetInterfaces_f4761baf7daf0c63();
        for(auto tmp_177 : interfaces) {
            auto type = cli::cast<Type*>(tmp_177);
            {
                Type *t = type->get_IsGenericType_4db8ddd5b97f3c14() ? type->GetGenericTypeDefinition_15f8fc7813e8e8bf() : type;
                if((String::Compare3(t->get_Name_50fad5fa936c3ae2(), name, ignoreCase, Globalization::CultureInfo::get_InvariantCulture()) ==  0)) 
                {
                    return type;
                }
                if((String::Compare3(t->get_FullName_7e8fa72ba225e1a4(), name, ignoreCase, Globalization::CultureInfo::get_InvariantCulture()) ==  0)) 
                {
                    return type;
                }
            }
        }
        return nullptr;
    }
    
    cli::array<Type*>* MonoType::GetInterfaces_52a89380e2c4a725() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    cli::array<Reflection::MemberInfo*>* MonoType::GetMembers_54432b0ff6e99174(Reflection::BindingFlags bindingAttr) {
        return Type::FindMembers_cae113425644ab26(Reflection::MemberTypes::All, bindingAttr, nullptr, nullptr);
    }
    
    cli::array<Reflection::MethodInfo*>* MonoType::GetMethodsByName(String* name, Reflection::BindingFlags bindingAttr, bool ignoreCase, Type* reflected_type) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    cli::array<Reflection::MethodInfo*>* MonoType::GetMethods_c5b4e5d4877e6672(Reflection::BindingFlags bindingAttr) {
        return GetMethodsByName(nullptr, bindingAttr, false, this);
    }
    
    Reflection::MethodInfo* MonoType::GetMethodImpl_1b221ab713bbcb85(String* name, Reflection::BindingFlags bindingAttr, Reflection::Binder* binder, Reflection::CallingConventions callConvention, cli::array<Type*>* types, cli::array<Reflection::ParameterModifier>* modifiers) {
        bool ignoreCase = ((int32_t)(((int32_t)(bindingAttr) & 1)) != 0);
        cli::array<Reflection::MethodInfo*> *methods = GetMethodsByName(name, bindingAttr, ignoreCase, this);
        Reflection::MethodInfo *found = nullptr;
        cli::array<Reflection::MethodBase*> *match;
        int32_t count = 0;
        for(auto tmp_178 : methods) {
            auto m = cli::cast<Reflection::MethodInfo*>(tmp_178);
            {
                if((((int32_t)(callConvention) != 3) && ((int32_t)(((int32_t)(m->get_CallingConvention_309cf574b58a053a()) & (int32_t)(callConvention))) != (int32_t)(callConvention)))) 
                {
                    continue;
                }
                found = m;
                count++;
            }
        }
        if((count ==  0)) 
        {
            return nullptr;
        }
        if(((count ==  1) && (types ==  nullptr))) 
        {
            return cli::cast<Reflection::MethodInfo*>(CheckMethodSecurity(found));
        }
        match = (new cli::array<Reflection::MethodBase*>(count));
        if((count ==  1)) 
        {
            match->at(0) = found;
        }
         else 
        {
            count = 0;
            for(auto tmp_179 : methods) {
                auto m = cli::cast<Reflection::MethodInfo*>(tmp_179);
                {
                    if((((int32_t)(callConvention) != 3) && ((int32_t)(((int32_t)(m->get_CallingConvention_309cf574b58a053a()) & (int32_t)(callConvention))) != (int32_t)(callConvention)))) 
                    {
                        continue;
                    }
                    match->at(count++) = m;
                }
            }
        }
        if((types ==  nullptr)) 
        {
            return cli::cast<Reflection::MethodInfo*>(CheckMethodSecurity(Reflection::Binder::FindMostDerivedMatch(match)));
        }
        if((binder ==  nullptr)) 
        {
            binder = Reflection::Binder::get_DefaultBinder();
        }
        return cli::cast<Reflection::MethodInfo*>(CheckMethodSecurity(binder->SelectMethod_3e1ca0f0e362534f(bindingAttr, match, types, modifiers)));
    }
    
    Reflection::MethodInfo* MonoType::GetCorrespondingInflatedMethod(Reflection::MethodInfo* generic) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    Reflection::ConstructorInfo* MonoType::GetCorrespondingInflatedConstructor(Reflection::ConstructorInfo* generic) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    Reflection::MethodInfo* MonoType::GetMethod_c725b8f4a943d5c8(Reflection::MethodInfo* fromNoninstanciated) {
        if(Reflection::MethodInfo::op_Equality(fromNoninstanciated, nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("fromNoninstanciated"));
        }
        return GetCorrespondingInflatedMethod(fromNoninstanciated);
    }
    
    Reflection::ConstructorInfo* MonoType::GetConstructor_1dd1da77cc4fe364(Reflection::ConstructorInfo* fromNoninstanciated) {
        if(Reflection::ConstructorInfo::op_Equality(fromNoninstanciated, nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("fromNoninstanciated"));
        }
        return GetCorrespondingInflatedConstructor(fromNoninstanciated);
    }
    
    Reflection::FieldInfo* MonoType::GetField_4da1f61e7e2a6f8c(Reflection::FieldInfo* fromNoninstanciated) {
        Reflection::BindingFlags flags = fromNoninstanciated->get_IsStatic() ? Reflection::BindingFlags::Static : Reflection::BindingFlags::Instance;
        (flags = (Reflection::BindingFlags)(((int32_t)(flags) | (int32_t)(fromNoninstanciated->get_IsPublic() ? Reflection::BindingFlags::Public : Reflection::BindingFlags::NonPublic))));
        return GetField_a38d5b9730c691a2(fromNoninstanciated->get_Name_50fad5fa936c3ae2(), flags);
    }
    
    Type* MonoType::GetNestedType_31962c16c0c85df9(String* name, Reflection::BindingFlags bindingAttr) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    cli::array<Type*>* MonoType::GetNestedTypes_bb6ee40b0fa4052d(Reflection::BindingFlags bindingAttr) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    cli::array<Reflection::PropertyInfo*>* MonoType::GetPropertiesByName(String* name, Reflection::BindingFlags bindingAttr, bool icase, Type* reflected_type) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    cli::array<Reflection::PropertyInfo*>* MonoType::GetProperties_9fb6c40e3662fdd7(Reflection::BindingFlags bindingAttr) {
        return GetPropertiesByName(nullptr, bindingAttr, false, this);
    }
    
    Reflection::PropertyInfo* MonoType::GetPropertyImpl_e2328b7ad87384ee(String* name, Reflection::BindingFlags bindingAttr, Reflection::Binder* binder, Type* returnType, cli::array<Type*>* types, cli::array<Reflection::ParameterModifier>* modifiers) {
        bool ignoreCase = ((int32_t)(((int32_t)(bindingAttr) & 1)) != 0);
        cli::array<Reflection::PropertyInfo*> *props = GetPropertiesByName(name, bindingAttr, ignoreCase, this);
        int32_t count = props->get_Length();
        if((count ==  0)) 
        {
            return nullptr;
        }
        if((((count ==  1) && ((types ==  nullptr) || (types->get_Length() ==  0))) && (Type::op_Equality2(returnType, nullptr) || Type::op_Equality2(returnType, props->at(0)->get_PropertyType_68b4b04678fe4f8a())))) 
        {
            return props->at(0);
        }
        if((binder ==  nullptr)) 
        {
            binder = Reflection::Binder::get_DefaultBinder();
        }
        return binder->SelectProperty_d299ada322143a6(bindingAttr, props, returnType, types, modifiers);
    }
    
    bool MonoType::HasElementTypeImpl_36e3ca23a6e8185() {
        return ((MonoType::IsArrayImpl_cf15f782d0773ffd() || MonoType::IsByRefImpl_a1c403acfb80fd15()) || MonoType::IsPointerImpl_86e7f94717f8b1ea());
    }
    
    bool MonoType::IsArrayImpl_cf15f782d0773ffd() {
        return Type::IsArrayImpl2(this);
    }
    
    bool MonoType::IsByRefImpl_a1c403acfb80fd15() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool MonoType::IsCOMObjectImpl_27dfb5d026264856() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool MonoType::IsPointerImpl_86e7f94717f8b1ea() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool MonoType::IsPrimitiveImpl_b5951f74b8c48703() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool MonoType::IsSubclassOf_5d7dbe0215a30fda(Type* type) {
        if(Type::op_Equality2(type, nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("type"));
        }
        return Type::IsSubclassOf_5d7dbe0215a30fda(type);
    }
    
    Object* MonoType::InvokeMember_70c4601d847070a2(String* name, Reflection::BindingFlags invokeAttr, Reflection::Binder* binder, Object* target, cli::array<Object*>* args, cli::array<Reflection::ParameterModifier>* modifiers, Globalization::CultureInfo* culture, cli::array<String*>* namedParameters) {
        const String *bindingflags_arg = _T("bindingFlags");
        if(((int32_t)(((int32_t)(invokeAttr) & 512)) != 0)) 
        {
            if(((int32_t)(((int32_t)(invokeAttr) & 13312)) != 0)) 
            {
                throw cli::gcnew<ArgumentException>(_T("bindingFlags"));
            }
        }
         else 
        {
            if((name ==  nullptr)) 
            {
                throw cli::gcnew<ArgumentNullException>(_T("name"));
            }
        }
        if((((int32_t)(((int32_t)(invokeAttr) & 1024)) != 0) && ((int32_t)(((int32_t)(invokeAttr) & 2048)) != 0))) 
        {
            throw cli::gcnew<ArgumentException>(_T("Cannot specify both Get and Set on a field."), _T("bindingFlags"));
        }
        if((((int32_t)(((int32_t)(invokeAttr) & 4096)) != 0) && ((int32_t)(((int32_t)(invokeAttr) & 8192)) != 0))) 
        {
            throw cli::gcnew<ArgumentException>(_T("Cannot specify both Get and Set on a property."), _T("bindingFlags"));
        }
        if(((int32_t)(((int32_t)(invokeAttr) & 256)) != 0)) 
        {
            if(((int32_t)(((int32_t)(invokeAttr) & 2048)) != 0)) 
            {
                throw cli::gcnew<ArgumentException>(_T("Cannot specify Set on a field and Invoke on a method."), _T("bindingFlags"));
            }
            if(((int32_t)(((int32_t)(invokeAttr) & 8192)) != 0)) 
            {
                throw cli::gcnew<ArgumentException>(_T("Cannot specify Set on a property and Invoke on a method."), _T("bindingFlags"));
            }
        }
        if(((namedParameters != nullptr) && ((args ==  nullptr) || (args->get_Length() < namedParameters->get_Length())))) 
        {
            throw cli::gcnew<ArgumentException>(_T("namedParameters cannot be more than named arguments in number"));
        }
        if(((int32_t)(((int32_t)(invokeAttr) & 16128)) ==  0)) 
        {
            throw cli::gcnew<ArgumentException>(_T("Must specify binding flags describing the invoke operation required."), _T("bindingFlags"));
        }
        if(((int32_t)(((int32_t)(invokeAttr) & 48)) ==  0)) 
        {
            (invokeAttr = (Reflection::BindingFlags)(((int32_t)(invokeAttr) | 16)));
        }
        if(((int32_t)(((int32_t)(invokeAttr) & 12)) ==  0)) 
        {
            (invokeAttr = (Reflection::BindingFlags)(((int32_t)(invokeAttr) | 12)));
        }
        if((binder ==  nullptr)) 
        {
            binder = Reflection::Binder::get_DefaultBinder();
        }
        if(((int32_t)(((int32_t)(invokeAttr) & 512)) != 0)) 
        {
            (invokeAttr = (Reflection::BindingFlags)(((int32_t)(invokeAttr) | 2)));
            cli::array<Reflection::ConstructorInfo*> *ctors = GetConstructors_f24cc6cf9c6f79c6(invokeAttr);
            Object *state = nullptr;
            Reflection::MethodBase *ctor = binder->BindToMethod_c4d067cd0e5ef7a(invokeAttr, ctors->template CovariantCast<Reflection::MethodBase*>(), args, modifiers, culture, namedParameters, state);
            if(Reflection::MethodBase::op_Equality2(ctor, nullptr)) 
            {
                if((this->get_IsValueType() && (args ==  nullptr))) 
                {
                    return Activator::CreateInstanceInternal(this);
                }
                throw cli::gcnew<MissingMethodException>(cli::concat(_T("Constructor on type \'"), this->get_FullName_7e8fa72ba225e1a4()));
            }
            Object *result = ctor->Invoke_ba5f4e14507fdb95(target, invokeAttr, binder, args, culture);
            binder->ReorderArgumentArray_b525b590b5921f82(args, state);
            return result;
        }
        if((String::op_Equality(name, String::Empty) && Attribute::IsDefined3(this, cli::typeof<Type>::info))) 
        {
            Reflection::DefaultMemberAttribute *attr = cli::cast<Reflection::DefaultMemberAttribute*>(Attribute::GetCustomAttribute2(this, cli::typeof<Type>::info));
            name = attr->get_MemberName();
        }
        bool ignoreCase = ((int32_t)(((int32_t)(invokeAttr) & 1)) != 0);
        String *throwMissingMethodDescription = nullptr;
        bool throwMissingFieldException = false;
        if(((int32_t)(((int32_t)(invokeAttr) & 256)) != 0)) 
        {
            cli::array<Reflection::MethodInfo*> *methods = GetMethodsByName(name, invokeAttr, ignoreCase, this);
            Object *state = nullptr;
            if((args ==  nullptr)) 
            {
                args = (new cli::array<Object*>(0));
            }
            Reflection::MethodBase *m = binder->BindToMethod_c4d067cd0e5ef7a(invokeAttr, methods->template CovariantCast<Reflection::MethodBase*>(), args, modifiers, culture, namedParameters, state);
            if(Reflection::MethodBase::op_Equality2(m, nullptr)) 
            {
                if((methods->get_Length() > 0)) 
                {
                    throwMissingMethodDescription = cli::concat(_T("The best match for method "), name);
                }
                 else 
                {
                    throwMissingMethodDescription = cli::concat(_T("Cannot find method "), name);
                }
            }
             else 
            {
                cli::array<Reflection::ParameterInfo*> *parameters = m->GetParameters_9d17bcb549474c9();
                for(int32_t i = 0; (i < parameters->get_Length()); ++i){
                    if(((Reflection::Missing::Value ==  args->at(i)) && ((int32_t)(((int32_t)(parameters->at(i)->get_Attributes_450c629a82b88ec3()) & 4096)) != 4096))) 
                    {
                        throw cli::gcnew<ArgumentException>(_T("Used Missing.Value for argument without default value"), _T("parameters"));
                    }
                }
                Object *result = m->Invoke_ba5f4e14507fdb95(target, invokeAttr, binder, args, culture);
                binder->ReorderArgumentArray_b525b590b5921f82(args, state);
                return result;
            }
        }
        if(((int32_t)(((int32_t)(invokeAttr) & 1024)) != 0)) 
        {
            Reflection::FieldInfo *f = GetField_a38d5b9730c691a2(name, invokeAttr);
            if(Reflection::FieldInfo::op_Inequality2(f, nullptr)) 
            {
                return f->GetValue_57ad13b528e8b8a5(target);
            }
             else 
            {
                if(((int32_t)(((int32_t)(invokeAttr) & 4096)) ==  0)) 
                {
                    throwMissingFieldException = true;
                }
            }
        }
         else 
        {
            if(((int32_t)(((int32_t)(invokeAttr) & 2048)) != 0)) 
            {
                Reflection::FieldInfo *f = GetField_a38d5b9730c691a2(name, invokeAttr);
                if(Reflection::FieldInfo::op_Inequality2(f, nullptr)) 
                {
                    if((args ==  nullptr)) 
                    {
                        throw cli::gcnew<ArgumentNullException>(_T("providedArgs"));
                    }
                    if(((args ==  nullptr) || (args->get_Length() != 1))) 
                    {
                        throw cli::gcnew<ArgumentException>(_T("Only the field value can be specified to set a field value."), _T("bindingFlags"));
                    }
                    f->SetValue2(target, args->at(0));
                    return nullptr;
                }
                 else 
                {
                    if(((int32_t)(((int32_t)(invokeAttr) & 8192)) ==  0)) 
                    {
                        throwMissingFieldException = true;
                    }
                }
            }
        }
        if(((int32_t)(((int32_t)(invokeAttr) & 4096)) != 0)) 
        {
            cli::array<Reflection::PropertyInfo*> *properties = GetPropertiesByName(name, invokeAttr, ignoreCase, this);
            Object *state = nullptr;
            int32_t i, count = 0;
            for(i = 0; (i < properties->get_Length()); ++i){
                if(Reflection::MethodInfo::op_Inequality(properties->at(i)->GetGetMethod_598f563fd3755017(true), nullptr)) 
                {
                    count++;
                }
            }
            cli::array<Reflection::MethodBase*> *smethods = (new cli::array<Reflection::MethodBase*>(count));
            count = 0;
            for(i = 0; (i < properties->get_Length()); ++i){
                Reflection::MethodBase *mb = properties->at(i)->GetGetMethod_598f563fd3755017(true);
                if(Reflection::MethodBase::op_Inequality2(mb, nullptr)) 
                {
                    smethods->at(count++) = mb;
                }
            }
            Reflection::MethodBase *m = binder->BindToMethod_c4d067cd0e5ef7a(invokeAttr, smethods, args, modifiers, culture, namedParameters, state);
            if(Reflection::MethodBase::op_Equality2(m, nullptr)) 
            {
                throwMissingFieldException = true;
            }
             else 
            {
                Object *result = m->Invoke_ba5f4e14507fdb95(target, invokeAttr, binder, args, culture);
                binder->ReorderArgumentArray_b525b590b5921f82(args, state);
                return result;
            }
        }
         else 
        {
            if(((int32_t)(((int32_t)(invokeAttr) & 8192)) != 0)) 
            {
                cli::array<Reflection::PropertyInfo*> *properties = GetPropertiesByName(name, invokeAttr, ignoreCase, this);
                Object *state = nullptr;
                int32_t i, count = 0;
                for(i = 0; (i < properties->get_Length()); ++i){
                    if(Reflection::MethodInfo::op_Inequality(properties->at(i)->GetSetMethod_8896cb22c4f8d900(true), nullptr)) 
                    {
                        count++;
                    }
                }
                cli::array<Reflection::MethodBase*> *smethods = (new cli::array<Reflection::MethodBase*>(count));
                count = 0;
                for(i = 0; (i < properties->get_Length()); ++i){
                    Reflection::MethodBase *mb = properties->at(i)->GetSetMethod_8896cb22c4f8d900(true);
                    if(Reflection::MethodBase::op_Inequality2(mb, nullptr)) 
                    {
                        smethods->at(count++) = mb;
                    }
                }
                Reflection::MethodBase *m = binder->BindToMethod_c4d067cd0e5ef7a(invokeAttr, smethods, args, modifiers, culture, namedParameters, state);
                if(Reflection::MethodBase::op_Equality2(m, nullptr)) 
                {
                    throwMissingFieldException = true;
                }
                 else 
                {
                    Object *result = m->Invoke_ba5f4e14507fdb95(target, invokeAttr, binder, args, culture);
                    binder->ReorderArgumentArray_b525b590b5921f82(args, state);
                    return result;
                }
            }
        }
        if((throwMissingMethodDescription != nullptr)) 
        {
            throw cli::gcnew<MissingMethodException>(throwMissingMethodDescription);
        }
        if(throwMissingFieldException) 
        {
            throw cli::gcnew<MissingFieldException>(cli::concat(_T("Cannot find variable "), name));
        }
        return nullptr;
    }
    
    Type* MonoType::GetElementType_ab5070dbbfe66f5f() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    String* MonoType::getFullName(bool full_name, bool assembly_qualified) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool MonoType::IsDefined_91943a8ac363f11f(Type* attributeType, bool inherit) {
        return MonoCustomAttrs::IsDefined(this, attributeType, inherit);
    }
    
    cli::array<Object*>* MonoType::GetCustomAttributes_b790992b66049291(bool inherit) {
        return MonoCustomAttrs::GetCustomAttributes2(this, inherit);
    }
    
    cli::array<Object*>* MonoType::GetCustomAttributes_90419687cfa65ef7(Type* attributeType, bool inherit) {
        if(Type::op_Equality2(attributeType, nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("attributeType"));
        }
        return MonoCustomAttrs::GetCustomAttributes(this, attributeType, inherit);
    }
    
    int32_t MonoType::GetArrayRank_fccf91da5e4acf4f() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void MonoType::GetObjectData(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        UnitySerializationHolder::GetTypeData(this, info, context);
    }
    
    String* MonoType::ToString_1636a0751cb9ac11() {
        return getFullName(false, false);
    }
    
    cli::array<Type*>* MonoType::GetGenericArguments_a7fb476275cfe9a3() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    Type* MonoType::GetGenericTypeDefinition_15f8fc7813e8e8bf() {
        Type *res = Type::GetGenericTypeDefinition_impl();
        if(Type::op_Equality2(res, nullptr)) 
        {
            throw cli::gcnew<InvalidOperationException>();
        }
        return res;
    }
    
    Collections::Generic::IList2<Reflection::CustomAttributeData*>* MonoType::GetCustomAttributesData_8a5353617f57fb2() {
        return Reflection::CustomAttributeData::GetCustomAttributes2(this);
    }
    
    Array* MonoType::GetEnumValues_bdf747371fce41cc() {
        if(!(this->get_IsEnum_bc85ea7b0a749db())) 
        {
            throw cli::gcnew<ArgumentException>(_T("Type is not an enumeration"), _T("enumType"));
        }
        return Enum::GetValues(this);
    }
    
    Reflection::MethodBase* MonoType::CheckMethodSecurity(Reflection::MethodBase* mb) {
        if((!(Security::SecurityManager::get_SecurityEnabled()) || Reflection::MethodBase::op_Equality2(mb, nullptr))) 
        {
            return mb;
        }
        return Security::SecurityManager::ReflectedLinkDemandQuery(mb) ? mb : nullptr;
    }
    
    int32_t MonoType::get_core_clr_security_level() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    Type* MonoType::get_UnderlyingSystemType_9ccb7bb8385521f6() {
        return this;
    }
    
    Reflection::Assembly* MonoType::get_Assembly_3aae0acbf2a6d696() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    String* MonoType::get_AssemblyQualifiedName_cea373c2171bd483() {
        return getFullName(true, true);
    }
    
    Type* MonoType::get_BaseType_6a0646ae880055f6() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    String* MonoType::get_FullName_7e8fa72ba225e1a4() {
        String *fullName;
        if((this->type_info ==  nullptr)) 
        {
            this->type_info = cli::gcnew<MonoTypeInfo>();
        }
        if(((fullName = this->type_info->full_name) ==  (nullptr))) 
        {
            fullName = this->type_info->full_name = getFullName(true, false);
        }
        return fullName;
    }
    
    Guid MonoType::get_GUID_bdb6b630c3237a21() {
        cli::array<Object*> *att = GetCustomAttributes_a458b60110eb1adc(cli::typeof<Type>::info, true);
        if((att->get_Length() ==  0)) 
        {
            return (*Guid::Empty);
        }
        return cli::ctor<Guid>(cli::cast<Runtime::InteropServices::GuidAttribute*>(att->at(0))->get_Value());
    }
    
    Reflection::MemberTypes MonoType::get_MemberType_cd521d320810c98f() {
        if((Type::op_Inequality2(this->get_DeclaringType_6121cd6a84393166(), nullptr) && !(this->get_IsGenericParameter_2a17c4bf67798b07()))) 
        {
            return Reflection::MemberTypes::NestedType;
        }
         else 
        {
            return Reflection::MemberTypes::TypeInfo3;
        }
    }
    
    String* MonoType::get_Name_50fad5fa936c3ae2() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    String* MonoType::get_Namespace_cb4ed37007083e7f() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    Reflection::Module* MonoType::get_Module_ea7d65dc88202263() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    Type* MonoType::get_DeclaringType_6121cd6a84393166() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    Type* MonoType::get_ReflectedType_bf4971c0f442b9dc() {
        return this->get_DeclaringType_6121cd6a84393166();
    }
    
    RuntimeTypeHandle MonoType::get_TypeHandle_a14995fa9102936b() {
        return this->_impl;
    }
    
    bool MonoType::get_ContainsGenericParameters_19598881dd690ad3() {
        if(this->get_IsGenericParameter_2a17c4bf67798b07()) 
        {
            return true;
        }
        if(this->get_IsGenericType_4db8ddd5b97f3c14()) 
        {
            for(auto tmp_180 : Type::GetGenericArguments_a7fb476275cfe9a3()) {
                auto arg = cli::cast<Type*>(tmp_180);
                if(arg->get_ContainsGenericParameters_19598881dd690ad3()) 
                {
                    return true;
                }
            }
        }
        if(this->get_HasElementType()) 
        {
            return GetElementType_7c511ae38a3cf1dd()->get_ContainsGenericParameters_19598881dd690ad3();
        }
        return false;
    }
    
    bool MonoType::get_IsGenericParameter_2a17c4bf67798b07() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    Reflection::MethodBase* MonoType::get_DeclaringMethod_6dc070d2040335e5() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool MonoType::get_IsSecurityTransparent_6da55418ab72fb10() {
        return (get_core_clr_security_level() ==  0);
    }
    
    bool MonoType::get_IsSecurityCritical_50a9063c5d34fcdb() {
        return (get_core_clr_security_level() > 0);
    }
    
    bool MonoType::get_IsSecuritySafeCritical_bcc034bfd05c04c9() {
        return (get_core_clr_security_level() ==  1);
    }
    
    Runtime::InteropServices::StructLayoutAttribute* MonoType::get_StructLayoutAttribute_c8846f98114193d0() {
        return Type::GetStructLayoutAttribute();
    }
    
}
namespace System {
    
    
    void MTAThreadAttribute::constructor() {
    }
    
}
namespace System {
    
    
    void MulticastDelegate::constructor(Object* target, String* method) {
        this->prev = nullptr;
    }
    
    void MulticastDelegate::constructor(Type* target, String* method) {
        this->prev = nullptr;
    }
    
    void MulticastDelegate::GetObjectData_e87c6354ab1f5b0(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        Delegate::GetObjectData_e87c6354ab1f5b0(info, context);
    }
    
    Object* MulticastDelegate::DynamicInvokeImpl_929f0cf2f6cc1bc9(cli::array<Object*>* args) {
        if((this->prev != nullptr)) 
        {
            this->prev->DynamicInvokeImpl_929f0cf2f6cc1bc9(args);
        }
        return Delegate::DynamicInvokeImpl_929f0cf2f6cc1bc9(args);
    }
    
    bool MulticastDelegate::Equals_ed975d2f4a7d193e(Object* obj) {
        if(!(Delegate::Equals_ed975d2f4a7d193e(obj))) 
        {
            return false;
        }
        MulticastDelegate *d = cli::as<MulticastDelegate*>(obj);
        if((d ==  nullptr)) 
        {
            return false;
        }
        if((this->prev ==  nullptr)) 
        {
            if((d->prev ==  nullptr)) 
            {
                return true;
            }
             else 
            {
                return false;
            }
        }
        return this->prev->Equals_ed975d2f4a7d193e(d->prev);
    }
    
    int32_t MulticastDelegate::GetHashCode_6648aef0f235ee6c() {
        return Delegate::GetHashCode_6648aef0f235ee6c();
    }
    
    cli::array<Delegate*>* MulticastDelegate::GetInvocationList_8fef0390be027d95() {
        MulticastDelegate *d;
        d = cli::cast<MulticastDelegate*>(this->Clone_ea12f3f395dbfa01());
        for(d->kpm_next = nullptr; (d->prev != nullptr); d = d->prev) {
            d->prev->kpm_next = d;
        }
        if((d->kpm_next ==  nullptr)) 
        {
            MulticastDelegate *other = cli::cast<MulticastDelegate*>(d->Clone_ea12f3f395dbfa01());
            other->prev = nullptr;
            other->kpm_next = nullptr;
            return (new cli::array<Delegate*>({other}));
        }
        Collections::Generic::List<Delegate*> *list = cli::gcnew<Collections::Generic::List<Delegate*>>();
        for(; (d != nullptr); d = d->kpm_next){
            MulticastDelegate *other = cli::cast<MulticastDelegate*>(d->Clone_ea12f3f395dbfa01());
            other->prev = nullptr;
            other->kpm_next = nullptr;
            list->Add(other);
        }
        return list->ToArray();
    }
    
    Delegate* MulticastDelegate::CombineImpl_1d822eded1f305a6(Delegate* follow) {
        MulticastDelegate *combined, *orig, *clone;
        if(Type::op_Inequality2(this->GetType(), follow->GetType())) 
        {
            throw cli::gcnew<ArgumentException>(Locale::GetText(_T("Incompatible Delegate Types.")));
        }
        combined = cli::cast<MulticastDelegate*>(follow->Clone_ea12f3f395dbfa01());
        combined->SetMulticastInvoke();
        for(clone = combined, orig = cli::cast<MulticastDelegate*>(follow)->prev; (orig != nullptr); orig = orig->prev){
            clone->prev = cli::cast<MulticastDelegate*>(orig->Clone_ea12f3f395dbfa01());
            clone = clone->prev;
        }
        clone->prev = cli::cast<MulticastDelegate*>(this->Clone_ea12f3f395dbfa01());
        for(clone = clone->prev, orig = this->prev; (orig != nullptr); orig = orig->prev){
            clone->prev = cli::cast<MulticastDelegate*>(orig->Clone_ea12f3f395dbfa01());
            clone = clone->prev;
        }
        return combined;
    }
    
    bool MulticastDelegate::BaseEquals(MulticastDelegate* value) {
        return Delegate::Equals_ed975d2f4a7d193e(value);
    }
    
    MulticastDelegate* MulticastDelegate::KPM(MulticastDelegate* needle, MulticastDelegate* haystack, MulticastDelegate* tail) {
        MulticastDelegate *nx, *hx;
        hx = needle;
        nx = needle->kpm_next = nullptr;
        do {
            while(((nx != nullptr) && !(nx->BaseEquals(hx)))) nx = nx->kpm_next;
            hx = hx->prev;
            if((hx ==  nullptr)) 
            {
                break;
            }
            nx = (nx ==  nullptr) ? needle : nx->prev;
            if(hx->BaseEquals(nx)) 
            {
                hx->kpm_next = nx->kpm_next;
            }
             else 
            {
                hx->kpm_next = nx;
            }
        }
        while(true);
        MulticastDelegate *match = haystack;
        nx = needle;
        hx = haystack;
        do {
            while(((nx != nullptr) && !(nx->BaseEquals(hx)))) {
                nx = nx->kpm_next;
                match = match->prev;
            }
            nx = (nx ==  nullptr) ? needle : nx->prev;
            if((nx ==  nullptr)) 
            {
                tail = hx->prev;
                return match;
            }
            hx = hx->prev;
        }
        while((hx != nullptr));
        tail = nullptr;
        return nullptr;
    }
    
    Delegate* MulticastDelegate::RemoveImpl_683e7d1a8f792013(Delegate* value) {
        if((value ==  nullptr)) 
        {
            return this;
        }
        MulticastDelegate *head, *tail;
        head = KPM(cli::cast<MulticastDelegate*>(value), this, tail);
        if((head ==  nullptr)) 
        {
            return this;
        }
        MulticastDelegate *prev = nullptr, *retval = nullptr, *orig;
        for(orig = this; (cli::cast<Object*>(orig) != cli::cast<Object*>(head)); orig = orig->prev){
            MulticastDelegate *clone = cli::cast<MulticastDelegate*>(orig->Clone_ea12f3f395dbfa01());
            if((prev != nullptr)) 
            {
                prev->prev = clone;
            }
             else 
            {
                retval = clone;
            }
            prev = clone;
        }
        for(orig = tail; (cli::cast<Object*>(orig) != nullptr); orig = orig->prev){
            MulticastDelegate *clone = cli::cast<MulticastDelegate*>(orig->Clone_ea12f3f395dbfa01());
            if((prev != nullptr)) 
            {
                prev->prev = clone;
            }
             else 
            {
                retval = clone;
            }
            prev = clone;
        }
        if((prev != nullptr)) 
        {
            prev->prev = nullptr;
        }
        return retval;
    }
    
    bool MulticastDelegate::op_Equality2(MulticastDelegate* d1, MulticastDelegate* d2) {
        if((d1 ==  nullptr)) 
        {
            return (d2 ==  nullptr);
        }
        return d1->Equals_ed975d2f4a7d193e(d2);
    }
    
    bool MulticastDelegate::op_Inequality2(MulticastDelegate* d1, MulticastDelegate* d2) {
        if((d1 ==  nullptr)) 
        {
            return (d2 != nullptr);
        }
        return !(d1->Equals_ed975d2f4a7d193e(d2));
    }
    
    bool MulticastDelegate::get_HasSingleTarget() {
        return (this->prev ==  nullptr);
    }
    
}
namespace System {
    
    
    void MulticastNotSupportedException::constructor() {
    }
    
    void MulticastNotSupportedException::constructor(String* message) {
    }
    
    void MulticastNotSupportedException::constructor(String* message, Exception* inner) {
    }
    
    void MulticastNotSupportedException::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
    }
    
}
namespace System {
    
    
    void NonSerializedAttribute::constructor() {
    }
    
}
namespace System {
    
    
    void NotCancelableException::constructor() {
        this->set_HResult(-2146233028);
    }
    
    void NotCancelableException::constructor(String* message) {
        this->set_HResult(-2146233028);
    }
    
    void NotCancelableException::constructor(String* message, Exception* innerException) {
        this->set_HResult(-2146233028);
    }
    
    void NotCancelableException::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
    }
    
}
namespace System {
    
    
    void NotFiniteNumberException::constructor() {
        this->set_HResult(-2146233048);
    }
    
    void NotFiniteNumberException::constructor(double offendingNumber) {
        this->offending_number = offendingNumber;
        this->set_HResult(-2146233048);
    }
    
    void NotFiniteNumberException::constructor(String* message) {
        this->set_HResult(-2146233048);
    }
    
    void NotFiniteNumberException::constructor(String* message, double offendingNumber) {
        this->offending_number = offendingNumber;
        this->set_HResult(-2146233048);
    }
    
    void NotFiniteNumberException::constructor(String* message, double offendingNumber, Exception* innerException) {
        this->offending_number = offendingNumber;
        this->set_HResult(-2146233048);
    }
    
    void NotFiniteNumberException::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        this->offending_number = info->GetDouble(_T("OffendingNumber"));
    }
    
    void NotFiniteNumberException::constructor(String* message, Exception* innerException) {
        this->set_HResult(-2146233048);
    }
    
    void NotFiniteNumberException::GetObjectData_bc9b88d7eb43b6d8(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        ArithmeticException::GetObjectData_bc9b88d7eb43b6d8(info, context);
        info->AddValue9(_T("OffendingNumber"), this->offending_number);
    }
    
    double NotFiniteNumberException::get_OffendingNumber() {
        return this->offending_number;
    }
    
}
namespace System {
    
    
    void NotImplementedException::constructor() {
        this->set_HResult(-2147467263);
    }
    
    void NotImplementedException::constructor(String* message) {
        this->set_HResult(-2147467263);
    }
    
    void NotImplementedException::constructor(String* message, Exception* inner) {
        this->set_HResult(-2147467263);
    }
    
    void NotImplementedException::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
    }
    
}
namespace System {
    
    
    void NotSupportedException::constructor() {
        this->set_HResult(-2146233067);
    }
    
    void NotSupportedException::constructor(String* message) {
        this->set_HResult(-2146233067);
    }
    
    void NotSupportedException::constructor(String* message, Exception* innerException) {
        this->set_HResult(-2146233067);
    }
    
    void NotSupportedException::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
    }
    
}
namespace System {
    
    
    Type* Nullable::GetUnderlyingType(Type* nullableType) {
        if(Type::op_Equality2(nullableType, nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("nullableType"));
        }
        if((nullableType->get_IsGenericType_4db8ddd5b97f3c14() && Type::op_Equality2(nullableType->GetGenericTypeDefinition_15f8fc7813e8e8bf(), cli::typeof<Type>::info))) 
        {
            return nullableType->GetGenericArguments_a7fb476275cfe9a3()->at(0);
        }
         else 
        {
            return nullptr;
        }
    }
    
}
namespace System {
    
    
    void NullConsoleDriver::constructor() {
    }
    
    void NullConsoleDriver::Beep(int32_t frequency, int32_t duration) {
    }
    
    void NullConsoleDriver::Clear() {
    }
    
    void NullConsoleDriver::MoveBufferArea(int32_t sourceLeft, int32_t sourceTop, int32_t sourceWidth, int32_t sourceHeight, int32_t targetLeft, int32_t targetTop, char16_t sourceChar, ConsoleColor sourceForeColor, ConsoleColor sourceBackColor) {
    }
    
    void NullConsoleDriver::Init() {
    }
    
    String* NullConsoleDriver::ReadLine() {
        return nullptr;
    }
    
    ConsoleKeyInfo NullConsoleDriver::ReadKey(bool intercept) {
        return (*ConsoleKeyInfo::Empty);
    }
    
    void NullConsoleDriver::ResetColor() {
    }
    
    void NullConsoleDriver::SetBufferSize(int32_t width, int32_t height) {
    }
    
    void NullConsoleDriver::SetCursorPosition(int32_t left, int32_t top) {
    }
    
    void NullConsoleDriver::SetWindowPosition(int32_t left, int32_t top) {
    }
    
    void NullConsoleDriver::SetWindowSize(int32_t width, int32_t height) {
    }
    
    ConsoleColor NullConsoleDriver::get_BackgroundColor() {
        return ConsoleColor::Black;
    }
    
    ConsoleColor NullConsoleDriver::set_BackgroundColor(ConsoleColor value) {
        return get_BackgroundColor();
    }
    
    int32_t NullConsoleDriver::get_BufferHeight() {
        return 0;
    }
    
    int32_t NullConsoleDriver::set_BufferHeight(int32_t value) {
        return get_BufferHeight();
    }
    
    int32_t NullConsoleDriver::get_BufferWidth() {
        return 0;
    }
    
    int32_t NullConsoleDriver::set_BufferWidth(int32_t value) {
        return get_BufferWidth();
    }
    
    bool NullConsoleDriver::get_CapsLock() {
        return false;
    }
    
    int32_t NullConsoleDriver::get_CursorLeft() {
        return 0;
    }
    
    int32_t NullConsoleDriver::set_CursorLeft(int32_t value) {
        return get_CursorLeft();
    }
    
    int32_t NullConsoleDriver::get_CursorSize() {
        return 0;
    }
    
    int32_t NullConsoleDriver::set_CursorSize(int32_t value) {
        return get_CursorSize();
    }
    
    int32_t NullConsoleDriver::get_CursorTop() {
        return 0;
    }
    
    int32_t NullConsoleDriver::set_CursorTop(int32_t value) {
        return get_CursorTop();
    }
    
    bool NullConsoleDriver::get_CursorVisible() {
        return false;
    }
    
    bool NullConsoleDriver::set_CursorVisible(bool value) {
        return get_CursorVisible();
    }
    
    ConsoleColor NullConsoleDriver::get_ForegroundColor() {
        return ConsoleColor::Black;
    }
    
    ConsoleColor NullConsoleDriver::set_ForegroundColor(ConsoleColor value) {
        return get_ForegroundColor();
    }
    
    bool NullConsoleDriver::get_KeyAvailable() {
        return false;
    }
    
    bool NullConsoleDriver::get_Initialized() {
        return true;
    }
    
    int32_t NullConsoleDriver::get_LargestWindowHeight() {
        return 0;
    }
    
    int32_t NullConsoleDriver::get_LargestWindowWidth() {
        return 0;
    }
    
    bool NullConsoleDriver::get_NumberLock() {
        return false;
    }
    
    String* NullConsoleDriver::get_Title() {
        return _T("");
    }
    
    String* NullConsoleDriver::set_Title(String* value) {
        return get_Title();
    }
    
    bool NullConsoleDriver::get_TreatControlCAsInput() {
        return false;
    }
    
    bool NullConsoleDriver::set_TreatControlCAsInput(bool value) {
        return get_TreatControlCAsInput();
    }
    
    int32_t NullConsoleDriver::get_WindowHeight() {
        return 0;
    }
    
    int32_t NullConsoleDriver::set_WindowHeight(int32_t value) {
        return get_WindowHeight();
    }
    
    int32_t NullConsoleDriver::get_WindowLeft() {
        return 0;
    }
    
    int32_t NullConsoleDriver::set_WindowLeft(int32_t value) {
        return get_WindowLeft();
    }
    
    int32_t NullConsoleDriver::get_WindowTop() {
        return 0;
    }
    
    int32_t NullConsoleDriver::set_WindowTop(int32_t value) {
        return get_WindowTop();
    }
    
    int32_t NullConsoleDriver::get_WindowWidth() {
        return 0;
    }
    
    int32_t NullConsoleDriver::set_WindowWidth(int32_t value) {
        return get_WindowWidth();
    }
    
}
namespace System {
    
    
    void NullReferenceException::constructor() {
        this->set_HResult(-2147467261);
    }
    
    void NullReferenceException::constructor(String* message) {
        this->set_HResult(-2147467261);
    }
    
    void NullReferenceException::constructor(String* message, Exception* innerException) {
        this->set_HResult(-2147467261);
    }
    
    void NullReferenceException::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
    }
    
}
namespace System {
    
    
    void CustomInfo::constructor() {
    }
    
    void CustomInfo::GetActiveSection(String* format, bool positive, bool zero, int32_t offset, int32_t length) {
        cli::array<int32_t> *lens = (new cli::array<int32_t>(3));
        int32_t index = 0;
        int32_t lastPos = 0;
        char16_t literal = u'\x0';
        for(int32_t i = 0; (i < format->get_Length()); i++){
            char16_t c = format->get_Chars(i);
            if((((int32_t)(c) ==  (int32_t)(literal)) || (((int32_t)(literal) ==  0) && (((int32_t)(c) ==  34) || ((int32_t)(c) ==  39))))) 
            {
                if(((int32_t)(literal) ==  0)) 
                {
                    literal = c;
                }
                 else 
                {
                    literal = u'\x0';
                }
                continue;
            }
            if(((((int32_t)(literal) ==  0) && ((int32_t)(format->get_Chars(i)) ==  59)) && ((i ==  0) || ((int32_t)(format->get_Chars((i - 1))) != 92)))) 
            {
                lens->at(index++) = (i - lastPos);
                lastPos = (i + 1);
                if((index ==  3)) 
                {
                    break;
                }
            }
        }
        if((index ==  0)) 
        {
            offset = 0;
            length = format->get_Length();
            return;
        }
        if((index ==  1)) 
        {
            if((positive || zero)) 
            {
                offset = 0;
                length = lens->at(0);
                return;
            }
            if(((lens->at(0) + 1) < format->get_Length())) 
            {
                positive = true;
                offset = (lens->at(0) + 1);
                length = (format->get_Length() - offset);
                return;
            }
             else 
            {
                offset = 0;
                length = lens->at(0);
                return;
            }
        }
        if((index ==  2)) 
        {
            if(zero) 
            {
                offset = ((lens->at(0) + lens->at(1)) + 2);
                length = (format->get_Length() - offset);
                return;
            }
            if(positive) 
            {
                offset = 0;
                length = lens->at(0);
                return;
            }
            if((lens->at(1) > 0)) 
            {
                positive = true;
                offset = (lens->at(0) + 1);
                length = lens->at(1);
                return;
            }
             else 
            {
                offset = 0;
                length = lens->at(0);
                return;
            }
        }
        if((index ==  3)) 
        {
            if(zero) 
            {
                offset = ((lens->at(0) + lens->at(1)) + 2);
                length = lens->at(2);
                return;
            }
            if(positive) 
            {
                offset = 0;
                length = lens->at(0);
                return;
            }
            if((lens->at(1) > 0)) 
            {
                positive = true;
                offset = (lens->at(0) + 1);
                length = lens->at(1);
                return;
            }
             else 
            {
                offset = 0;
                length = lens->at(0);
                return;
            }
        }
        throw cli::gcnew<ArgumentException>();
    }
    
    CustomInfo* CustomInfo::Parse(String* format, int32_t offset, int32_t length, Globalization::NumberFormatInfo* nfi) {
        char16_t literal = u'\x0';
        bool integerArea = true;
        bool decimalArea = false;
        bool exponentArea = false;
        bool sharpContinues = true;
        CustomInfo *info = cli::gcnew<CustomInfo>();
        int32_t groupSeparatorCounter = 0;
        for(int32_t i = offset; ((i - offset) < length); i++){
            char16_t c = format->get_Chars(i);
            if((((int32_t)(c) ==  (int32_t)(literal)) && ((int32_t)(c) != 0))) 
            {
                literal = u'\x0';
                continue;
            }
            if(((int32_t)(literal) != 0)) 
            {
                continue;
            }
            if((exponentArea && ((((int32_t)(c) != 0) && ((int32_t)(c) != 48)) && ((int32_t)(c) != 35)))) 
            {
                exponentArea = false;
                integerArea = (info->DecimalPointPos < 0);
                decimalArea = !(integerArea);
                i--;
                continue;
            }
            switch(c) {
                case u'\\': case_705: {
                    i++;
                    continue;
                }
                case u'\'': case u'"': case_706: {
                    if((((int32_t)(c) ==  34) || ((int32_t)(c) ==  39))) 
                    {
                        literal = c;
                    }
                    continue;
                }
                case u'#': case_707: {
                    if((sharpContinues && integerArea)) 
                    {
                        info->IntegerHeadSharpDigits++;
                    }
                     else 
                    {
                        if(decimalArea) 
                        {
                            info->DecimalTailSharpDigits++;
                        }
                         else 
                        {
                            if(exponentArea) 
                            {
                                info->ExponentTailSharpDigits++;
                            }
                        }
                    }
                    goto case_708;
                }
                case u'0': case_708: {
                    if(((int32_t)(c) != 35)) 
                    {
                        sharpContinues = false;
                        if(decimalArea) 
                        {
                            info->DecimalTailSharpDigits = 0;
                        }
                         else 
                        {
                            if(exponentArea) 
                            {
                                info->ExponentTailSharpDigits = 0;
                            }
                        }
                    }
                    if((info->IntegerHeadPos ==  -1)) 
                    {
                        info->IntegerHeadPos = i;
                    }
                    if(integerArea) 
                    {
                        info->IntegerDigits++;
                        if((groupSeparatorCounter > 0)) 
                        {
                            info->UseGroup = true;
                        }
                        groupSeparatorCounter = 0;
                    }
                     else 
                    {
                        if(decimalArea) 
                        {
                            info->DecimalDigits++;
                        }
                         else 
                        {
                            if(exponentArea) 
                            {
                                info->ExponentDigits++;
                            }
                        }
                    }
                    break;
                }
                case u'e': case u'E': case_709: {
                    if(info->UseExponent) 
                    {
                        break;
                    }
                    info->UseExponent = true;
                    integerArea = false;
                    decimalArea = false;
                    exponentArea = true;
                    if((((i + 1) - offset) < length)) 
                    {
                        char16_t nc = format->get_Chars((i + 1));
                        if(((int32_t)(nc) ==  43)) 
                        {
                            info->ExponentNegativeSignOnly = false;
                        }
                        if((((int32_t)(nc) ==  43) || ((int32_t)(nc) ==  45))) 
                        {
                            i++;
                        }
                         else 
                        {
                            if((((int32_t)(nc) != 48) && ((int32_t)(nc) != 35))) 
                            {
                                info->UseExponent = false;
                                if((info->DecimalPointPos < 0)) 
                                {
                                    integerArea = true;
                                }
                            }
                        }
                    }
                    break;
                }
                case u'.': case_710: {
                    integerArea = false;
                    decimalArea = true;
                    exponentArea = false;
                    if((info->DecimalPointPos ==  -1)) 
                    {
                        info->DecimalPointPos = i;
                    }
                    break;
                }
                case u'%': case_711: {
                    info->Percents++;
                    break;
                }
                case u'\x2030': case_712: {
                    info->Permilles++;
                    break;
                }
                case u',': case_713: {
                    if((integerArea && (info->IntegerDigits > 0))) 
                    {
                        groupSeparatorCounter++;
                    }
                    break;
                }
                default: case_714: {
                    break;
                }
            }
        }
        if((info->ExponentDigits ==  0)) 
        {
            info->UseExponent = false;
        }
         else 
        {
            info->IntegerHeadSharpDigits = 0;
        }
        if((info->DecimalDigits ==  0)) 
        {
            info->DecimalPointPos = -1;
        }
        (info->DividePlaces = info->DividePlaces + (groupSeparatorCounter * 3));
        return info;
    }
    
    String* CustomInfo::Format2(String* format, int32_t offset, int32_t length, Globalization::NumberFormatInfo* nfi, bool positive, Text::StringBuilder* sb_int, Text::StringBuilder* sb_dec, Text::StringBuilder* sb_exp) {
        Text::StringBuilder *sb = cli::gcnew<Text::StringBuilder>();
        char16_t literal = u'\x0';
        bool integerArea = true;
        bool decimalArea = false;
        int32_t intSharpCounter = 0;
        int32_t sb_int_index = 0;
        int32_t sb_dec_index = 0;
        cli::array<int32_t> *groups = nfi->get_RawNumberGroupSizes();
        String *groupSeparator = nfi->get_NumberGroupSeparator();
        int32_t intLen = 0, total = 0, groupIndex = 0, counter = 0, groupSize = 0;
        if((this->UseGroup && (groups->get_Length() > 0))) 
        {
            intLen = sb_int->get_Length();
            for(int32_t i = 0; (i < groups->get_Length()); i++){
                (total = total + groups->at(i));
                if((total <= intLen)) 
                {
                    groupIndex = i;
                }
            }
            groupSize = groups->at(groupIndex);
            int32_t fraction = (intLen > total) ? (intLen - total) : 0;
            if((groupSize ==  0)) 
            {
                while(((groupIndex >= 0) && (groups->at(groupIndex) ==  0))) groupIndex--;
                groupSize = (fraction > 0) ? fraction : groups->at(groupIndex);
            }
            if((fraction ==  0)) 
            {
                counter = groupSize;
            }
             else 
            {
                (groupIndex = groupIndex + (fraction / groupSize));
                counter = (fraction % groupSize);
                if((counter ==  0)) 
                {
                    counter = groupSize;
                }
                 else 
                {
                    groupIndex++;
                }
            }
        }
         else 
        {
            this->UseGroup = false;
        }
        for(int32_t i = offset; ((i - offset) < length); i++){
            char16_t c = format->get_Chars(i);
            if((((int32_t)(c) ==  (int32_t)(literal)) && ((int32_t)(c) != 0))) 
            {
                literal = u'\x0';
                continue;
            }
            if(((int32_t)(literal) != 0)) 
            {
                sb->Append16(c);
                continue;
            }
            switch(c) {
                case u'\\': case_715: {
                    i++;
                    if(((i - offset) < length)) 
                    {
                        sb->Append16(format->get_Chars(i));
                    }
                    continue;
                }
                case u'\'': case u'"': case_716: {
                    if((((int32_t)(c) ==  34) || ((int32_t)(c) ==  39))) 
                    {
                        literal = c;
                    }
                    continue;
                }
                case u'#': case_717: {
                    goto case_718;
                }
                case u'0': case_718: {
                    if(integerArea) 
                    {
                        intSharpCounter++;
                        if((((this->IntegerDigits - intSharpCounter) < (sb_int->get_Length() + sb_int_index)) || ((int32_t)(c) ==  48))) 
                        {
                            while((((this->IntegerDigits - intSharpCounter) + sb_int_index) < sb_int->get_Length())) {
                                sb->Append16(sb_int->get_Chars(sb_int_index++));
                                if(((this->UseGroup && (--intLen > 0)) && (--counter ==  0))) 
                                {
                                    sb->Append2(groupSeparator);
                                    if(((--groupIndex < groups->get_Length()) && (groupIndex >= 0))) 
                                    {
                                        groupSize = groups->at(groupIndex);
                                    }
                                    counter = groupSize;
                                }
                            }
                        }
                        break;
                    }
                     else 
                    {
                        if(decimalArea) 
                        {
                            if((sb_dec_index < sb_dec->get_Length())) 
                            {
                                sb->Append16(sb_dec->get_Chars(sb_dec_index++));
                            }
                            break;
                        }
                    }
                    sb->Append16(c);
                    break;
                }
                case u'e': case u'E': case_719: {
                    if(((sb_exp ==  nullptr) || !(this->UseExponent))) 
                    {
                        sb->Append16(c);
                        break;
                    }
                    bool flag1 = true;
                    bool flag2 = false;
                    int32_t q;
                    for(q = (i + 1); ((q - offset) < length); q++){
                        if(((int32_t)(format->get_Chars(q)) ==  48)) 
                        {
                            flag2 = true;
                            continue;
                        }
                        if(((q ==  (i + 1)) && (((int32_t)(format->get_Chars(q)) ==  43) || ((int32_t)(format->get_Chars(q)) ==  45)))) 
                        {
                            continue;
                        }
                        if(!(flag2)) 
                        {
                            flag1 = false;
                        }
                        break;
                    }
                    if(flag1) 
                    {
                        i = (q - 1);
                        integerArea = (this->DecimalPointPos < 0);
                        decimalArea = !(integerArea);
                        sb->Append16(c);
                        sb->Append10(sb_exp);
                        sb_exp = nullptr;
                    }
                     else 
                    {
                        sb->Append16(c);
                    }
                    break;
                }
                case u'.': case_720: {
                    if((this->DecimalPointPos ==  i)) 
                    {
                        if((this->DecimalDigits > 0)) 
                        {
                            while((sb_int_index < sb_int->get_Length())) sb->Append16(sb_int->get_Chars(sb_int_index++));
                        }
                        if((sb_dec->get_Length() > 0)) 
                        {
                            sb->Append2(nfi->get_NumberDecimalSeparator());
                        }
                    }
                    integerArea = false;
                    decimalArea = true;
                    break;
                }
                case u',': case_721: {
                    break;
                }
                case u'%': case_722: {
                    sb->Append2(nfi->get_PercentSymbol());
                    break;
                }
                case u'\x2030': case_723: {
                    sb->Append2(nfi->get_PerMilleSymbol());
                    break;
                }
                default: case_724: {
                    sb->Append16(c);
                    break;
                }
            }
        }
        if(!(positive)) 
        {
            sb->Insert2(0, nfi->get_NegativeSign());
        }
        return sb->ToString_1636a0751cb9ac11();
    }
    
}
namespace System {
    
    uint64_t*  NumberFormatter::MantissaBitsTable;
    int32_t*  NumberFormatter::TensExponentTable;
    char16_t*  NumberFormatter::DigitLowerTable;
    char16_t*  NumberFormatter::DigitUpperTable;
    int64_t*  NumberFormatter::TenPowersList;
    int32_t*  NumberFormatter::DecHexDigits;
    NumberFormatter*  NumberFormatter::threadNumberFormatter;
    
    NumberFormatter::NumberFormatter()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void NumberFormatter::static_constructor() {
        GetFormatterTables(MantissaBitsTable, TensExponentTable, DigitLowerTable, DigitUpperTable, TenPowersList, DecHexDigits);
    }
    
    void NumberFormatter::constructor(Threading::Thread* current) {
        this->_cbuf = (new cli::array<char16_t>(0));
        if((current ==  nullptr)) 
        {
            return;
        }
        this->set_CurrentCulture(current->get_CurrentCulture());
    }
    
    void NumberFormatter::GetFormatterTables(uint64_t* MantissaBitsTable, int32_t* TensExponentTable, char16_t* DigitLowerTable, char16_t* DigitUpperTable, int64_t* TenPowersList, int32_t* DecHexDigits) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int64_t NumberFormatter::GetTenPowerOf(int32_t i) {
        return (*(TenPowersList + i));
    }
    
    void NumberFormatter::InitDecHexDigits(uint32_t value) {
        if((value >= 100000000U)) 
        {
            int32_t div1 = (int32_t)(value / 100000000U);
            (value = value - (100000000U * (uint32_t)div1));
            this->_val2 = FastToDecHex(div1);
        }
        this->_val1 = ToDecHex((int32_t)value);
    }
    
    void NumberFormatter::InitDecHexDigits2(uint64_t value) {
        if((value >= 100000000UL)) 
        {
            int64_t div1 = (int64_t)(value / 100000000UL);
            (value = value - (100000000UL * (uint64_t)div1));
            if((div1 >= 100000000L)) 
            {
                int32_t div2 = (int32_t)(div1 / 100000000L);
                div1 = (div1 - ((int64_t)(div2) * 100000000L));
                this->_val3 = ToDecHex(div2);
            }
            if((div1 != 0L)) 
            {
                this->_val2 = ToDecHex((int32_t)div1);
            }
        }
        if((value != 0UL)) 
        {
            this->_val1 = ToDecHex((int32_t)value);
        }
    }
    
    void NumberFormatter::InitDecHexDigits3(uint32_t hi, uint64_t lo) {
        if((hi ==  0U)) 
        {
            InitDecHexDigits2(lo);
            return;
        }
        uint32_t divhi = (hi / 100000000U);
        uint64_t remhi = (uint64_t)((hi - (divhi * 100000000U)));
        uint64_t divlo = (lo / 100000000UL);
        uint64_t remlo = ((lo - (divlo * 100000000UL)) + (remhi * 9551616UL));
        hi = divhi;
        lo = (divlo + (remhi * 184467440737UL));
        divlo = (remlo / 100000000UL);
        (remlo = remlo - (divlo * 100000000UL));
        (lo = lo + divlo);
        this->_val1 = ToDecHex((int32_t)remlo);
        divlo = (lo / 100000000UL);
        remlo = (lo - (divlo * 100000000UL));
        lo = divlo;
        if((hi != 0U)) 
        {
            (lo = lo + ((uint64_t)(hi) * 184467440737UL));
            (remlo = remlo + ((uint64_t)(hi) * 9551616UL));
            divlo = (remlo / 100000000UL);
            (lo = lo + divlo);
            (remlo = remlo - (divlo * 100000000UL));
        }
        this->_val2 = ToDecHex((int32_t)remlo);
        if((lo >= 100000000UL)) 
        {
            divlo = (lo / 100000000UL);
            (lo = lo - (divlo * 100000000UL));
            this->_val4 = ToDecHex((int32_t)divlo);
        }
        this->_val3 = ToDecHex((int32_t)lo);
    }
    
    uint32_t NumberFormatter::FastToDecHex(int32_t val) {
        if((val < 100)) 
        {
            return (uint32_t)(*(DecHexDigits + val));
        }
        int32_t v = ((val * 5243) >> 19);
        return (uint32_t)(((*(DecHexDigits + v)) << 8) | (*(DecHexDigits + (val - (v * 100)))));
    }
    
    uint32_t NumberFormatter::ToDecHex(int32_t val) {
        uint32_t res = 0U;
        if((val >= 10000)) 
        {
            int32_t v = (val / 10000);
            (val = val - (v * 10000));
            res = (FastToDecHex(v) << 16);
        }
        return (res | FastToDecHex(val));
    }
    
    int32_t NumberFormatter::FastDecHexLen(int32_t val) {
        if((val < 256)) 
        {
            if((val < 16)) 
            {
                return 1;
            }
             else 
            {
                return 2;
            }
        }
         else 
        {
            if((val < 4096)) 
            {
                return 3;
            }
             else 
            {
                return 4;
            }
        }
    }
    
    int32_t NumberFormatter::DecHexLen(uint32_t val) {
        if((val < 65536U)) 
        {
            return FastDecHexLen((int32_t)val);
        }
        return (4 + FastDecHexLen((int32_t)(val >> 16)));
    }
    
    int32_t NumberFormatter::DecHexLen2() {
        if((this->_val4 != 0U)) 
        {
            return (DecHexLen(this->_val4) + 24);
        }
         else 
        {
            if((this->_val3 != 0U)) 
            {
                return (DecHexLen(this->_val3) + 16);
            }
             else 
            {
                if((this->_val2 != 0U)) 
                {
                    return (DecHexLen(this->_val2) + 8);
                }
                 else 
                {
                    if((this->_val1 != 0U)) 
                    {
                        return DecHexLen(this->_val1);
                    }
                     else 
                    {
                        return 0;
                    }
                }
            }
        }
    }
    
    int32_t NumberFormatter::ScaleOrder(int64_t hi) {
        for(int32_t i = 18; (i >= 0); i--) {
            if((hi >= GetTenPowerOf(i))) 
            {
                return (i + 1);
            }
        }
        return 1;
    }
    
    int32_t NumberFormatter::InitialFloatingPrecision() {
        if(((int32_t)(this->_specifier) ==  82)) 
        {
            return (this->_defPrecision + 2);
        }
        if((this->_precision < this->_defPrecision)) 
        {
            return this->_defPrecision;
        }
        if(((int32_t)(this->_specifier) ==  71)) 
        {
            return Math::Min5((this->_defPrecision + 2), this->_precision);
        }
        if(((int32_t)(this->_specifier) ==  69)) 
        {
            return Math::Min5((this->_defPrecision + 2), (this->_precision + 1));
        }
        return this->_defPrecision;
    }
    
    int32_t NumberFormatter::ParsePrecision(String* format) {
        int32_t precision = 0;
        for(int32_t i = 1; (i < format->get_Length()); i++){
            int32_t val = ((int32_t)(format->get_Chars(i)) - 48);
            precision = ((precision * 10) + val);
            if((((val < 0) || (val > 9)) || (precision > 99))) 
            {
                return -2;
            }
        }
        return precision;
    }
    
    void NumberFormatter::Init(String* format) {
        this->_val1 = this->_val2 = this->_val3 = this->_val4 = 0U;
        this->_offset = 0;
        this->_NaN = this->_infinity = false;
        this->_isCustomFormat = false;
        this->_specifierIsUpper = true;
        this->_precision = -1;
        if(((format ==  nullptr) || (format->get_Length() ==  0))) 
        {
            this->_specifier = u'G';
            return;
        }
        char16_t specifier = format->get_Chars(0);
        if((((int32_t)(specifier) >= 97) && ((int32_t)(specifier) <= 122))) 
        {
            specifier = (char16_t)(((int32_t)(specifier) - 97) + 65);
            this->_specifierIsUpper = false;
        }
         else 
        {
            if((((int32_t)(specifier) < 65) || ((int32_t)(specifier) > 90))) 
            {
                this->_isCustomFormat = true;
                this->_specifier = u'0';
                return;
            }
        }
        this->_specifier = specifier;
        if((format->get_Length() > 1)) 
        {
            this->_precision = ParsePrecision(format);
            if((this->_precision ==  -2)) 
            {
                this->_isCustomFormat = true;
                this->_specifier = u'0';
                this->_precision = -1;
            }
        }
    }
    
    void NumberFormatter::InitHex(uint64_t value) {
        switch(this->_defPrecision) {
            case 3: case_725: {
                value = (uint64_t)((unsigned char)value);
                break;
            }
            case 5: case_726: {
                value = (uint64_t)((uint16_t)value);
                break;
            }
            case 10: case_727: {
                value = (uint64_t)((uint32_t)value);
                break;
            }
        }
        this->_val1 = (uint32_t)value;
        this->_val2 = (uint32_t)(value >> 32);
        this->_decPointPos = this->_digitsLen = DecHexLen2();
        if((value ==  0UL)) 
        {
            this->_decPointPos = 1;
        }
    }
    
    void NumberFormatter::Init2(String* format, int32_t value, int32_t defPrecision) {
        Init(format);
        this->_defPrecision = defPrecision;
        this->_positive = (value >= 0);
        if(((value ==  0) || ((int32_t)(this->_specifier) ==  88))) 
        {
            InitHex((uint64_t)value);
            return;
        }
        if((value < 0)) 
        {
            value = -(value);
        }
        InitDecHexDigits((uint32_t)value);
        this->_decPointPos = this->_digitsLen = DecHexLen2();
    }
    
    void NumberFormatter::Init3(String* format, uint32_t value, int32_t defPrecision) {
        Init(format);
        this->_defPrecision = defPrecision;
        this->_positive = true;
        if(((value ==  0U) || ((int32_t)(this->_specifier) ==  88))) 
        {
            InitHex((uint64_t)(value));
            return;
        }
        InitDecHexDigits(value);
        this->_decPointPos = this->_digitsLen = DecHexLen2();
    }
    
    void NumberFormatter::Init4(String* format, int64_t value) {
        Init(format);
        this->_defPrecision = 19;
        this->_positive = (value >= 0L);
        if(((value ==  0L) || ((int32_t)(this->_specifier) ==  88))) 
        {
            InitHex((uint64_t)value);
            return;
        }
        if((value < 0L)) 
        {
            value = -(value);
        }
        InitDecHexDigits2((uint64_t)value);
        this->_decPointPos = this->_digitsLen = DecHexLen2();
    }
    
    void NumberFormatter::Init5(String* format, uint64_t value) {
        Init(format);
        this->_defPrecision = 20;
        this->_positive = true;
        if(((value ==  0UL) || ((int32_t)(this->_specifier) ==  88))) 
        {
            InitHex((uint64_t)(value));
            return;
        }
        InitDecHexDigits2(value);
        this->_decPointPos = this->_digitsLen = DecHexLen2();
    }
    
    void NumberFormatter::Init6(String* format, double value, int32_t defPrecision) {
        Init(format);
        this->_defPrecision = defPrecision;
        int64_t bits = BitConverter::DoubleToInt64Bits(value);
        this->_positive = (bits >= 0L);
        (bits = bits & 9223372036854775807L);
        if((bits ==  0L)) 
        {
            this->_decPointPos = 1;
            this->_digitsLen = 0;
            this->_positive = true;
            return;
        }
        int32_t e = (int32_t)(bits >> 52);
        int64_t m = (bits & 4503599627370495L);
        if((e ==  2047)) 
        {
            this->_NaN = (m != 0L);
            this->_infinity = (m ==  0L);
            return;
        }
        int32_t expAdjust = 0;
        if((e ==  0)) 
        {
            e = 1;
            int32_t scale = ScaleOrder(m);
            if((scale < 15)) 
            {
                expAdjust = (scale - 15);
                (m = m * GetTenPowerOf(-(expAdjust)));
            }
        }
         else 
        {
            m = (((m + 4503599627370495L) + 1L) * 10L);
            expAdjust = -1;
        }
        uint64_t lo = (uint64_t)((uint32_t)m);
        uint64_t hi = ((uint64_t)m >> 32);
        uint64_t lo2 = (*(MantissaBitsTable + e));
        uint64_t hi2 = (lo2 >> 32);
        lo2 = (uint64_t)((uint32_t)lo2);
        uint64_t mm = (((hi * lo2) + (lo * hi2)) + ((lo * lo2) >> 32));
        int64_t res = (int64_t)((hi * hi2) + (mm >> 32));
        while((res < 10000000000000000L)) {
            mm = ((mm & 4294967295UL) * 10UL);
            res = ((res * 10L) + (int64_t)(mm >> 32));
            expAdjust--;
        }
        if(((mm & 2147483648UL) != 0UL)) 
        {
            res++;
        }
        int32_t order = 17;
        this->_decPointPos = (((*(TensExponentTable + e)) + expAdjust) + order);
        int32_t initialPrecision = InitialFloatingPrecision();
        if((order > initialPrecision)) 
        {
            int64_t val = GetTenPowerOf((order - initialPrecision));
            res = ((res + (val >> 1)) / val);
            order = initialPrecision;
        }
        if((res >= GetTenPowerOf(order))) 
        {
            order++;
            this->_decPointPos++;
        }
        InitDecHexDigits2((uint64_t)res);
        this->_offset = CountTrailingZeros();
        this->_digitsLen = (order - this->_offset);
    }
    
    void NumberFormatter::Init7(String* format, Decimal value) {
        Init(format);
        this->_defPrecision = 100;
        cli::array<int32_t> *bits = Decimal::GetBits(value);
        int32_t scale = ((bits->at(3) & 2031616) >> 16);
        this->_positive = (bits->at(3) >= 0);
        if((((bits->at(0) ==  0) && (bits->at(1) ==  0)) && (bits->at(2) ==  0))) 
        {
            this->_decPointPos = -(scale);
            this->_positive = true;
            this->_digitsLen = 0;
            return;
        }
        InitDecHexDigits3((uint32_t)bits->at(2), (((uint64_t)bits->at(1) << 32) | (uint64_t)((uint32_t)bits->at(0))));
        this->_digitsLen = DecHexLen2();
        this->_decPointPos = (this->_digitsLen - scale);
        if(((this->_precision != -1) || ((int32_t)(this->_specifier) != 71))) 
        {
            this->_offset = CountTrailingZeros();
            (this->_digitsLen = this->_digitsLen - this->_offset);
        }
    }
    
    void NumberFormatter::ResetCharBuf(int32_t size) {
        this->_ind = 0;
        if((this->_cbuf->get_Length() < size)) 
        {
            this->_cbuf = (new cli::array<char16_t>(size));
        }
    }
    
    void NumberFormatter::Resize(int32_t len) {
        cli::array<char16_t> *newBuf = (new cli::array<char16_t>(len));
        Array::Copy(this->_cbuf, newBuf, this->_ind);
        this->_cbuf = newBuf;
    }
    
    void NumberFormatter::Append(char16_t c) {
        if((this->_ind ==  this->_cbuf->get_Length())) 
        {
            Resize((this->_ind + 10));
        }
        this->_cbuf->at(this->_ind++) = c;
    }
    
    void NumberFormatter::Append2(char16_t c, int32_t cnt) {
        if(((this->_ind + cnt) > this->_cbuf->get_Length())) 
        {
            Resize(((this->_ind + cnt) + 10));
        }
        while((cnt-- > 0)) this->_cbuf->at(this->_ind++) = c;
    }
    
    void NumberFormatter::Append3(String* s) {
        int32_t slen = s->get_Length();
        if(((this->_ind + slen) > this->_cbuf->get_Length())) 
        {
            Resize(((this->_ind + slen) + 10));
        }
        for(int32_t i = 0; (i < slen); i++) {
            this->_cbuf->at(this->_ind++) = s->get_Chars(i);
        }
    }
    
    Globalization::NumberFormatInfo* NumberFormatter::GetNumberFormatInstance(IFormatProvider* fp) {
        if(((this->_nfi != nullptr) && (fp ==  nullptr))) 
        {
            return this->_nfi;
        }
        return Globalization::NumberFormatInfo::GetInstance(fp);
    }
    
    void NumberFormatter::RoundPos(int32_t pos) {
        RoundBits((this->_digitsLen - pos));
    }
    
    bool NumberFormatter::RoundDecimal(int32_t decimals) {
        return RoundBits(((this->_digitsLen - this->_decPointPos) - decimals));
    }
    
    bool NumberFormatter::RoundBits(int32_t shift) {
        if((shift <= 0)) 
        {
            return false;
        }
        if((shift > this->_digitsLen)) 
        {
            this->_digitsLen = 0;
            this->_decPointPos = 1;
            this->_val1 = this->_val2 = this->_val3 = this->_val4 = 0U;
            this->_positive = true;
            return false;
        }
        (shift = shift + this->_offset);
        (this->_digitsLen = this->_digitsLen + this->_offset);
        while((shift > 8)) {
            this->_val1 = this->_val2;
            this->_val2 = this->_val3;
            this->_val3 = this->_val4;
            this->_val4 = 0U;
            (this->_digitsLen = this->_digitsLen - 8);
            (shift = shift - 8);
        }
        shift = ((shift - 1) << 2);
        uint32_t v = (this->_val1 >> (shift & 31));
        uint32_t rem16 = (v & 15U);
        this->_val1 = ((v ^ rem16) << (shift & 31));
        bool res = false;
        if((rem16 >= 5U)) 
        {
            (this->_val1 = this->_val1 | (2576980377U >> ((28 - shift) & 31)));
            AddOneToDecHex();
            int32_t newlen = DecHexLen2();
            res = (newlen != this->_digitsLen);
            this->_decPointPos = ((this->_decPointPos + newlen) - this->_digitsLen);
            this->_digitsLen = newlen;
        }
        RemoveTrailingZeros();
        return res;
    }
    
    void NumberFormatter::RemoveTrailingZeros() {
        this->_offset = CountTrailingZeros();
        (this->_digitsLen = this->_digitsLen - this->_offset);
        if((this->_digitsLen ==  0)) 
        {
            this->_offset = 0;
            this->_decPointPos = 1;
            this->_positive = true;
        }
    }
    
    void NumberFormatter::AddOneToDecHex() {
        if((this->_val1 ==  2576980377U)) 
        {
            this->_val1 = 0U;
            if((this->_val2 ==  2576980377U)) 
            {
                this->_val2 = 0U;
                if((this->_val3 ==  2576980377U)) 
                {
                    this->_val3 = 0U;
                    this->_val4 = AddOneToDecHex2(this->_val4);
                }
                 else 
                {
                    this->_val3 = AddOneToDecHex2(this->_val3);
                }
            }
             else 
            {
                this->_val2 = AddOneToDecHex2(this->_val2);
            }
        }
         else 
        {
            this->_val1 = AddOneToDecHex2(this->_val1);
        }
    }
    
    uint32_t NumberFormatter::AddOneToDecHex2(uint32_t val) {
        if(((val & 65535U) ==  39321U)) 
        {
            if(((val & 16777215U) ==  10066329U)) 
            {
                if(((val & 268435455U) ==  161061273U)) 
                {
                    return (val + 107374183U);
                }
                 else 
                {
                    return (val + 6710887U);
                }
            }
             else 
            {
                if(((val & 1048575U) ==  629145U)) 
                {
                    return (val + 419431U);
                }
                 else 
                {
                    return (val + 26215U);
                }
            }
        }
         else 
        {
            if(((val & 255U) ==  153U)) 
            {
                if(((val & 4095U) ==  2457U)) 
                {
                    return (val + 1639U);
                }
                 else 
                {
                    return (val + 103U);
                }
            }
             else 
            {
                if(((val & 15U) ==  9U)) 
                {
                    return (val + 7U);
                }
                 else 
                {
                    return (val + 1U);
                }
            }
        }
    }
    
    int32_t NumberFormatter::CountTrailingZeros() {
        if((this->_val1 != 0U)) 
        {
            return CountTrailingZeros2(this->_val1);
        }
        if((this->_val2 != 0U)) 
        {
            return (CountTrailingZeros2(this->_val2) + 8);
        }
        if((this->_val3 != 0U)) 
        {
            return (CountTrailingZeros2(this->_val3) + 16);
        }
        if((this->_val4 != 0U)) 
        {
            return (CountTrailingZeros2(this->_val4) + 24);
        }
        return this->_digitsLen;
    }
    
    int32_t NumberFormatter::CountTrailingZeros2(uint32_t val) {
        if(((val & 65535U) ==  0U)) 
        {
            if(((val & 16777215U) ==  0U)) 
            {
                if(((val & 268435455U) ==  0U)) 
                {
                    return 7;
                }
                 else 
                {
                    return 6;
                }
            }
             else 
            {
                if(((val & 1048575U) ==  0U)) 
                {
                    return 5;
                }
                 else 
                {
                    return 4;
                }
            }
        }
         else 
        {
            if(((val & 255U) ==  0U)) 
            {
                if(((val & 4095U) ==  0U)) 
                {
                    return 3;
                }
                 else 
                {
                    return 2;
                }
            }
             else 
            {
                if(((val & 15U) ==  0U)) 
                {
                    return 1;
                }
                 else 
                {
                    return 0;
                }
            }
        }
    }
    
    NumberFormatter* NumberFormatter::GetInstance() {
        NumberFormatter *res = threadNumberFormatter;
        threadNumberFormatter = nullptr;
        if((res ==  nullptr)) 
        {
            return cli::gcnew<NumberFormatter>(Threading::Thread::get_CurrentThread());
        }
        return res;
    }
    
    void NumberFormatter::Release() {
        threadNumberFormatter = this;
    }
    
    void NumberFormatter::SetThreadCurrentCulture(Globalization::CultureInfo* culture) {
        if((threadNumberFormatter != nullptr)) 
        {
            threadNumberFormatter->set_CurrentCulture(culture);
        }
    }
    
    String* NumberFormatter::NumberToString(String* format, signed char value, IFormatProvider* fp) {
        NumberFormatter *inst = GetInstance();
        inst->Init2(format, (int32_t)(value), 3);
        String *res = inst->IntegerToString(format, fp);
        inst->Release();
        return res;
    }
    
    String* NumberFormatter::NumberToString2(String* format, unsigned char value, IFormatProvider* fp) {
        NumberFormatter *inst = GetInstance();
        inst->Init2(format, (int32_t)(value), 3);
        String *res = inst->IntegerToString(format, fp);
        inst->Release();
        return res;
    }
    
    String* NumberFormatter::NumberToString3(String* format, uint16_t value, IFormatProvider* fp) {
        NumberFormatter *inst = GetInstance();
        inst->Init2(format, (int32_t)(value), 5);
        String *res = inst->IntegerToString(format, fp);
        inst->Release();
        return res;
    }
    
    String* NumberFormatter::NumberToString4(String* format, int16_t value, IFormatProvider* fp) {
        NumberFormatter *inst = GetInstance();
        inst->Init2(format, (int32_t)(value), 5);
        String *res = inst->IntegerToString(format, fp);
        inst->Release();
        return res;
    }
    
    String* NumberFormatter::NumberToString5(String* format, uint32_t value, IFormatProvider* fp) {
        NumberFormatter *inst = GetInstance();
        inst->Init3(format, value, 10);
        String *res = inst->IntegerToString(format, fp);
        inst->Release();
        return res;
    }
    
    String* NumberFormatter::NumberToString6(String* format, int32_t value, IFormatProvider* fp) {
        NumberFormatter *inst = GetInstance();
        inst->Init2(format, value, 10);
        String *res = inst->IntegerToString(format, fp);
        inst->Release();
        return res;
    }
    
    String* NumberFormatter::NumberToString7(String* format, uint64_t value, IFormatProvider* fp) {
        NumberFormatter *inst = GetInstance();
        inst->Init5(format, value);
        String *res = inst->IntegerToString(format, fp);
        inst->Release();
        return res;
    }
    
    String* NumberFormatter::NumberToString8(String* format, int64_t value, IFormatProvider* fp) {
        NumberFormatter *inst = GetInstance();
        inst->Init4(format, value);
        String *res = inst->IntegerToString(format, fp);
        inst->Release();
        return res;
    }
    
    String* NumberFormatter::NumberToString9(String* format, float value, IFormatProvider* fp) {
        NumberFormatter *inst = GetInstance();
        inst->Init6(format, (double)(value), 7);
        Globalization::NumberFormatInfo *nfi = inst->GetNumberFormatInstance(fp);
        String *res;
        if(inst->_NaN) 
        {
            res = nfi->get_NaNSymbol();
        }
         else 
        {
            if(inst->_infinity) 
            {
                if(inst->_positive) 
                {
                    res = nfi->get_PositiveInfinitySymbol();
                }
                 else 
                {
                    res = nfi->get_NegativeInfinitySymbol();
                }
            }
             else 
            {
                if(((int32_t)(inst->_specifier) ==  82)) 
                {
                    res = inst->FormatRoundtrip2(value, nfi);
                }
                 else 
                {
                    res = inst->NumberToString18(format, nfi);
                }
            }
        }
        inst->Release();
        return res;
    }
    
    String* NumberFormatter::NumberToString10(String* format, double value, IFormatProvider* fp) {
        NumberFormatter *inst = GetInstance();
        inst->Init6(format, value, 15);
        Globalization::NumberFormatInfo *nfi = inst->GetNumberFormatInstance(fp);
        String *res;
        if(inst->_NaN) 
        {
            res = nfi->get_NaNSymbol();
        }
         else 
        {
            if(inst->_infinity) 
            {
                if(inst->_positive) 
                {
                    res = nfi->get_PositiveInfinitySymbol();
                }
                 else 
                {
                    res = nfi->get_NegativeInfinitySymbol();
                }
            }
             else 
            {
                if(((int32_t)(inst->_specifier) ==  82)) 
                {
                    res = inst->FormatRoundtrip(value, nfi);
                }
                 else 
                {
                    res = inst->NumberToString18(format, nfi);
                }
            }
        }
        inst->Release();
        return res;
    }
    
    String* NumberFormatter::NumberToString11(String* format, Decimal value, IFormatProvider* fp) {
        NumberFormatter *inst = GetInstance();
        inst->Init7(format, value);
        String *res = inst->NumberToString18(format, inst->GetNumberFormatInstance(fp));
        inst->Release();
        return res;
    }
    
    String* NumberFormatter::NumberToString12(uint32_t value, IFormatProvider* fp) {
        if((value >= 100000000U)) 
        {
            return NumberToString5(nullptr, value, fp);
        }
        NumberFormatter *inst = GetInstance();
        String *res = inst->FastIntegerToString((int32_t)value, fp);
        inst->Release();
        return res;
    }
    
    String* NumberFormatter::NumberToString13(int32_t value, IFormatProvider* fp) {
        if(((value >= 100000000) || (value <= -100000000))) 
        {
            return NumberToString6(nullptr, value, fp);
        }
        NumberFormatter *inst = GetInstance();
        String *res = inst->FastIntegerToString(value, fp);
        inst->Release();
        return res;
    }
    
    String* NumberFormatter::NumberToString14(uint64_t value, IFormatProvider* fp) {
        if((value >= 100000000UL)) 
        {
            return NumberToString7(nullptr, value, fp);
        }
        NumberFormatter *inst = GetInstance();
        String *res = inst->FastIntegerToString((int32_t)value, fp);
        inst->Release();
        return res;
    }
    
    String* NumberFormatter::NumberToString15(int64_t value, IFormatProvider* fp) {
        if(((value >= 100000000L) || (value <= -100000000L))) 
        {
            return NumberToString8(nullptr, value, fp);
        }
        NumberFormatter *inst = GetInstance();
        String *res = inst->FastIntegerToString((int32_t)value, fp);
        inst->Release();
        return res;
    }
    
    String* NumberFormatter::NumberToString16(float value, IFormatProvider* fp) {
        NumberFormatter *inst = GetInstance();
        inst->Init6(nullptr, (double)(value), 7);
        Globalization::NumberFormatInfo *nfi = inst->GetNumberFormatInstance(fp);
        String *res;
        if(inst->_NaN) 
        {
            res = nfi->get_NaNSymbol();
        }
         else 
        {
            if(inst->_infinity) 
            {
                if(inst->_positive) 
                {
                    res = nfi->get_PositiveInfinitySymbol();
                }
                 else 
                {
                    res = nfi->get_NegativeInfinitySymbol();
                }
            }
             else 
            {
                res = inst->FormatGeneral(-1, nfi);
            }
        }
        inst->Release();
        return res;
    }
    
    String* NumberFormatter::NumberToString17(double value, IFormatProvider* fp) {
        NumberFormatter *inst = GetInstance();
        Globalization::NumberFormatInfo *nfi = inst->GetNumberFormatInstance(fp);
        inst->Init6(nullptr, value, 15);
        String *res;
        if(inst->_NaN) 
        {
            res = nfi->get_NaNSymbol();
        }
         else 
        {
            if(inst->_infinity) 
            {
                if(inst->_positive) 
                {
                    res = nfi->get_PositiveInfinitySymbol();
                }
                 else 
                {
                    res = nfi->get_NegativeInfinitySymbol();
                }
            }
             else 
            {
                res = inst->FormatGeneral(-1, nfi);
            }
        }
        inst->Release();
        return res;
    }
    
    String* NumberFormatter::FastIntegerToString(int32_t value, IFormatProvider* fp) {
        if((value < 0)) 
        {
            String *sign = GetNumberFormatInstance(fp)->get_NegativeSign();
            ResetCharBuf((8 + sign->get_Length()));
            value = -(value);
            Append3(sign);
        }
         else 
        {
            ResetCharBuf(8);
        }
        if((value >= 10000)) 
        {
            int32_t v = (value / 10000);
            FastAppendDigits(v, false);
            FastAppendDigits((value - (v * 10000)), true);
        }
         else 
        {
            FastAppendDigits(value, false);
        }
        return cli::gcnew<String>(this->_cbuf, 0, this->_ind);
    }
    
    String* NumberFormatter::IntegerToString(String* format, IFormatProvider* fp) {
        Globalization::NumberFormatInfo *nfi = GetNumberFormatInstance(fp);
        switch(this->_specifier) {
            case u'C': case_728: {
                return FormatCurrency(this->_precision, nfi);
            }
            case u'D': case_729: {
                return FormatDecimal(this->_precision, nfi);
            }
            case u'E': case_730: {
                return FormatExponential(this->_precision, nfi);
            }
            case u'F': case_731: {
                return FormatFixedPoint(this->_precision, nfi);
            }
            case u'G': case_732: {
                if((this->_precision <= 0)) 
                {
                    return FormatDecimal(-1, nfi);
                }
                return FormatGeneral(this->_precision, nfi);
            }
            case u'N': case_733: {
                return FormatNumber(this->_precision, nfi);
            }
            case u'P': case_734: {
                return FormatPercent(this->_precision, nfi);
            }
            case u'X': case_735: {
                return FormatHexadecimal(this->_precision);
            }
            default: case_736: {
                if(this->_isCustomFormat) 
                {
                    return FormatCustom(format, nfi);
                }
                throw cli::gcnew<FormatException>(cli::concat(_T("The specified format \'"), format));
            }
        }
    }
    
    String* NumberFormatter::NumberToString18(String* format, Globalization::NumberFormatInfo* nfi) {
        switch(this->_specifier) {
            case u'C': case_737: {
                return FormatCurrency(this->_precision, nfi);
            }
            case u'E': case_738: {
                return FormatExponential(this->_precision, nfi);
            }
            case u'F': case_739: {
                return FormatFixedPoint(this->_precision, nfi);
            }
            case u'G': case_740: {
                return FormatGeneral(this->_precision, nfi);
            }
            case u'N': case_741: {
                return FormatNumber(this->_precision, nfi);
            }
            case u'P': case_742: {
                return FormatPercent(this->_precision, nfi);
            }
            case u'X': default: case_743: {
                if(this->_isCustomFormat) 
                {
                    return FormatCustom(format, nfi);
                }
                throw cli::gcnew<FormatException>(cli::concat(_T("The specified format \'"), format));
            }
        }
    }
    
    String* NumberFormatter::FormatCurrency(int32_t precision, Globalization::NumberFormatInfo* nfi) {
        precision = (precision >= 0) ? precision : nfi->get_CurrencyDecimalDigits();
        RoundDecimal(precision);
        ResetCharBuf((((this->get_IntegerDigits() * 2) + (precision * 2)) + 16));
        if(this->_positive) 
        {
            switch(nfi->get_CurrencyPositivePattern()) {
                case 0: case_744: {
                    Append3(nfi->get_CurrencySymbol());
                    break;
                }
                case 2: case_745: {
                    Append3(nfi->get_CurrencySymbol());
                    Append(u' ');
                    break;
                }
            }
        }
         else 
        {
            switch(nfi->get_CurrencyNegativePattern()) {
                case 0: case_746: {
                    Append(u'(');
                    Append3(nfi->get_CurrencySymbol());
                    break;
                }
                case 1: case_747: {
                    Append3(nfi->get_NegativeSign());
                    Append3(nfi->get_CurrencySymbol());
                    break;
                }
                case 2: case_748: {
                    Append3(nfi->get_CurrencySymbol());
                    Append3(nfi->get_NegativeSign());
                    break;
                }
                case 3: case_749: {
                    Append3(nfi->get_CurrencySymbol());
                    break;
                }
                case 4: case_750: {
                    Append(u'(');
                    break;
                }
                case 5: case_751: {
                    Append3(nfi->get_NegativeSign());
                    break;
                }
                case 8: case_752: {
                    Append3(nfi->get_NegativeSign());
                    break;
                }
                case 9: case_753: {
                    Append3(nfi->get_NegativeSign());
                    Append3(nfi->get_CurrencySymbol());
                    Append(u' ');
                    break;
                }
                case 11: case_754: {
                    Append3(nfi->get_CurrencySymbol());
                    Append(u' ');
                    break;
                }
                case 12: case_755: {
                    Append3(nfi->get_CurrencySymbol());
                    Append(u' ');
                    Append3(nfi->get_NegativeSign());
                    break;
                }
                case 14: case_756: {
                    Append(u'(');
                    Append3(nfi->get_CurrencySymbol());
                    Append(u' ');
                    break;
                }
                case 15: case_757: {
                    Append(u'(');
                    break;
                }
            }
        }
        AppendIntegerStringWithGroupSeparator(nfi->get_RawCurrencyGroupSizes(), nfi->get_CurrencyGroupSeparator());
        if((precision > 0)) 
        {
            Append3(nfi->get_CurrencyDecimalSeparator());
            AppendDecimalString2(precision);
        }
        if(this->_positive) 
        {
            switch(nfi->get_CurrencyPositivePattern()) {
                case 1: case_758: {
                    Append3(nfi->get_CurrencySymbol());
                    break;
                }
                case 3: case_759: {
                    Append(u' ');
                    Append3(nfi->get_CurrencySymbol());
                    break;
                }
            }
        }
         else 
        {
            switch(nfi->get_CurrencyNegativePattern()) {
                case 0: case_760: {
                    Append(u')');
                    break;
                }
                case 3: case_761: {
                    Append3(nfi->get_NegativeSign());
                    break;
                }
                case 4: case_762: {
                    Append3(nfi->get_CurrencySymbol());
                    Append(u')');
                    break;
                }
                case 5: case_763: {
                    Append3(nfi->get_CurrencySymbol());
                    break;
                }
                case 6: case_764: {
                    Append3(nfi->get_NegativeSign());
                    Append3(nfi->get_CurrencySymbol());
                    break;
                }
                case 7: case_765: {
                    Append3(nfi->get_CurrencySymbol());
                    Append3(nfi->get_NegativeSign());
                    break;
                }
                case 8: case_766: {
                    Append(u' ');
                    Append3(nfi->get_CurrencySymbol());
                    break;
                }
                case 10: case_767: {
                    Append(u' ');
                    Append3(nfi->get_CurrencySymbol());
                    Append3(nfi->get_NegativeSign());
                    break;
                }
                case 11: case_768: {
                    Append3(nfi->get_NegativeSign());
                    break;
                }
                case 13: case_769: {
                    Append3(nfi->get_NegativeSign());
                    Append(u' ');
                    Append3(nfi->get_CurrencySymbol());
                    break;
                }
                case 14: case_770: {
                    Append(u')');
                    break;
                }
                case 15: case_771: {
                    Append(u' ');
                    Append3(nfi->get_CurrencySymbol());
                    Append(u')');
                    break;
                }
            }
        }
        return cli::gcnew<String>(this->_cbuf, 0, this->_ind);
    }
    
    String* NumberFormatter::FormatDecimal(int32_t precision, Globalization::NumberFormatInfo* nfi) {
        if((precision < this->_digitsLen)) 
        {
            precision = this->_digitsLen;
        }
        if((precision ==  0)) 
        {
            return _T("0");
        }
        ResetCharBuf((precision + 1));
        if(!(this->_positive)) 
        {
            Append3(nfi->get_NegativeSign());
        }
        AppendDigits(0, precision);
        return cli::gcnew<String>(this->_cbuf, 0, this->_ind);
    }
    
    String* NumberFormatter::FormatHexadecimal(int32_t precision) {
        int32_t size = Math::Max5(precision, this->_decPointPos);
        char16_t *digits = this->_specifierIsUpper ? DigitUpperTable : DigitLowerTable;
        ResetCharBuf(size);
        this->_ind = size;
        uint64_t val = ((uint64_t)(this->_val1) | ((uint64_t)(this->_val2) << 32));
        while((size > 0)) {
            this->_cbuf->at(--size) = (*(digits + (val & 15UL)));
            (val = val >> 4);
        }
        return cli::gcnew<String>(this->_cbuf, 0, this->_ind);
    }
    
    String* NumberFormatter::FormatFixedPoint(int32_t precision, Globalization::NumberFormatInfo* nfi) {
        if((precision ==  -1)) 
        {
            precision = nfi->get_NumberDecimalDigits();
        }
        RoundDecimal(precision);
        ResetCharBuf(((this->get_IntegerDigits() + precision) + 2));
        if(!(this->_positive)) 
        {
            Append3(nfi->get_NegativeSign());
        }
        AppendIntegerString2(this->get_IntegerDigits());
        if((precision > 0)) 
        {
            Append3(nfi->get_NumberDecimalSeparator());
            AppendDecimalString2(precision);
        }
        return cli::gcnew<String>(this->_cbuf, 0, this->_ind);
    }
    
    String* NumberFormatter::FormatRoundtrip(double origval, Globalization::NumberFormatInfo* nfi) {
        NumberFormatter *nfc = GetClone();
        if(((origval >= std::numeric_limits<double>::epsilon()) && (origval <= 1.79769313486231E+308))) 
        {
            String *shortRep = FormatGeneral(this->_defPrecision, nfi);
            if((origval ==  Double::Parse2(shortRep, nfi))) 
            {
                return shortRep;
            }
        }
        return nfc->FormatGeneral((this->_defPrecision + 2), nfi);
    }
    
    String* NumberFormatter::FormatRoundtrip2(float origval, Globalization::NumberFormatInfo* nfi) {
        NumberFormatter *nfc = GetClone();
        String *shortRep = FormatGeneral(this->_defPrecision, nfi);
        if((origval ==  Single::Parse2(shortRep, nfi))) 
        {
            return shortRep;
        }
        return nfc->FormatGeneral((this->_defPrecision + 2), nfi);
    }
    
    String* NumberFormatter::FormatGeneral(int32_t precision, Globalization::NumberFormatInfo* nfi) {
        bool enableExp;
        if((precision ==  -1)) 
        {
            enableExp = this->get_IsFloatingSource();
            precision = this->_defPrecision;
        }
         else 
        {
            enableExp = true;
            if((precision ==  0)) 
            {
                precision = this->_defPrecision;
            }
            RoundPos(precision);
        }
        int32_t intDigits = this->_decPointPos;
        int32_t digits = this->_digitsLen;
        int32_t decDigits = (digits - intDigits);
        if((((intDigits > precision) || (intDigits <= -4)) && enableExp)) 
        {
            return FormatExponential2((digits - 1), nfi, 2);
        }
        if((decDigits < 0)) 
        {
            decDigits = 0;
        }
        if((intDigits < 0)) 
        {
            intDigits = 0;
        }
        ResetCharBuf(((decDigits + intDigits) + 3));
        if(!(this->_positive)) 
        {
            Append3(nfi->get_NegativeSign());
        }
        if((intDigits ==  0)) 
        {
            Append(u'0');
        }
         else 
        {
            AppendDigits((digits - intDigits), digits);
        }
        if((decDigits > 0)) 
        {
            Append3(nfi->get_NumberDecimalSeparator());
            AppendDigits(0, decDigits);
        }
        return cli::gcnew<String>(this->_cbuf, 0, this->_ind);
    }
    
    String* NumberFormatter::FormatNumber(int32_t precision, Globalization::NumberFormatInfo* nfi) {
        precision = (precision >= 0) ? precision : nfi->get_NumberDecimalDigits();
        ResetCharBuf(((this->get_IntegerDigits() * 3) + precision));
        RoundDecimal(precision);
        if(!(this->_positive)) 
        {
            switch(nfi->get_NumberNegativePattern()) {
                case 0: case_772: {
                    Append(u'(');
                    break;
                }
                case 1: case_773: {
                    Append3(nfi->get_NegativeSign());
                    break;
                }
                case 2: case_774: {
                    Append3(nfi->get_NegativeSign());
                    Append(u' ');
                    break;
                }
            }
        }
        AppendIntegerStringWithGroupSeparator(nfi->get_RawNumberGroupSizes(), nfi->get_NumberGroupSeparator());
        if((precision > 0)) 
        {
            Append3(nfi->get_NumberDecimalSeparator());
            AppendDecimalString2(precision);
        }
        if(!(this->_positive)) 
        {
            switch(nfi->get_NumberNegativePattern()) {
                case 0: case_775: {
                    Append(u')');
                    break;
                }
                case 3: case_776: {
                    Append3(nfi->get_NegativeSign());
                    break;
                }
                case 4: case_777: {
                    Append(u' ');
                    Append3(nfi->get_NegativeSign());
                    break;
                }
            }
        }
        return cli::gcnew<String>(this->_cbuf, 0, this->_ind);
    }
    
    String* NumberFormatter::FormatPercent(int32_t precision, Globalization::NumberFormatInfo* nfi) {
        precision = (precision >= 0) ? precision : nfi->get_PercentDecimalDigits();
        Multiply10(2);
        RoundDecimal(precision);
        ResetCharBuf((((this->get_IntegerDigits() * 2) + precision) + 16));
        if(this->_positive) 
        {
            if((nfi->get_PercentPositivePattern() ==  2)) 
            {
                Append3(nfi->get_PercentSymbol());
            }
        }
         else 
        {
            switch(nfi->get_PercentNegativePattern()) {
                case 0: case_778: {
                    Append3(nfi->get_NegativeSign());
                    break;
                }
                case 1: case_779: {
                    Append3(nfi->get_NegativeSign());
                    break;
                }
                case 2: case_780: {
                    Append3(nfi->get_NegativeSign());
                    Append3(nfi->get_PercentSymbol());
                    break;
                }
            }
        }
        AppendIntegerStringWithGroupSeparator(nfi->get_RawPercentGroupSizes(), nfi->get_PercentGroupSeparator());
        if((precision > 0)) 
        {
            Append3(nfi->get_PercentDecimalSeparator());
            AppendDecimalString2(precision);
        }
        if(this->_positive) 
        {
            switch(nfi->get_PercentPositivePattern()) {
                case 0: case_781: {
                    Append(u' ');
                    Append3(nfi->get_PercentSymbol());
                    break;
                }
                case 1: case_782: {
                    Append3(nfi->get_PercentSymbol());
                    break;
                }
            }
        }
         else 
        {
            switch(nfi->get_PercentNegativePattern()) {
                case 0: case_783: {
                    Append(u' ');
                    Append3(nfi->get_PercentSymbol());
                    break;
                }
                case 1: case_784: {
                    Append3(nfi->get_PercentSymbol());
                    break;
                }
            }
        }
        return cli::gcnew<String>(this->_cbuf, 0, this->_ind);
    }
    
    String* NumberFormatter::FormatExponential(int32_t precision, Globalization::NumberFormatInfo* nfi) {
        if((precision ==  -1)) 
        {
            precision = 6;
        }
        RoundPos((precision + 1));
        return FormatExponential2(precision, nfi, 3);
    }
    
    String* NumberFormatter::FormatExponential2(int32_t precision, Globalization::NumberFormatInfo* nfi, int32_t expDigits) {
        int32_t decDigits = this->_decPointPos;
        int32_t digits = this->_digitsLen;
        int32_t exponent = (decDigits - 1);
        decDigits = this->_decPointPos = 1;
        ResetCharBuf((precision + 8));
        if(!(this->_positive)) 
        {
            Append3(nfi->get_NegativeSign());
        }
        AppendOneDigit((digits - 1));
        if((precision > 0)) 
        {
            Append3(nfi->get_NumberDecimalSeparator());
            AppendDigits(((digits - precision) - 1), (digits - this->_decPointPos));
        }
        AppendExponent(nfi, exponent, expDigits);
        return cli::gcnew<String>(this->_cbuf, 0, this->_ind);
    }
    
    String* NumberFormatter::FormatCustom(String* format, Globalization::NumberFormatInfo* nfi) {
        bool p = this->_positive;
        int32_t offset = 0;
        int32_t length = 0;
        CustomInfo::GetActiveSection(format, p, this->get_IsZero(), offset, length);
        if((length ==  0)) 
        {
            return this->_positive ? String::Empty : nfi->get_NegativeSign();
        }
        this->_positive = p;
        CustomInfo *info = CustomInfo::Parse(format, offset, length, nfi);
        Text::StringBuilder *sb_int = cli::gcnew<Text::StringBuilder>((info->IntegerDigits * 2));
        Text::StringBuilder *sb_dec = cli::gcnew<Text::StringBuilder>((info->DecimalDigits * 2));
        Text::StringBuilder *sb_exp = info->UseExponent ? cli::gcnew<Text::StringBuilder>((info->ExponentDigits * 2)) : nullptr;
        int32_t diff = 0;
        if((info->Percents > 0)) 
        {
            Multiply10((2 * info->Percents));
        }
        if((info->Permilles > 0)) 
        {
            Multiply10((3 * info->Permilles));
        }
        if((info->DividePlaces > 0)) 
        {
            Divide10(info->DividePlaces);
        }
        bool expPositive = true;
        if((info->UseExponent && ((info->DecimalDigits > 0) || (info->IntegerDigits > 0)))) 
        {
            if(!(this->get_IsZero())) 
            {
                RoundPos((info->DecimalDigits + info->IntegerDigits));
                (diff = diff - (this->_decPointPos - info->IntegerDigits));
                this->_decPointPos = info->IntegerDigits;
            }
            expPositive = (diff <= 0);
            AppendNonNegativeNumber(sb_exp, (diff < 0) ? -(diff) : diff);
        }
         else 
        {
            RoundDecimal(info->DecimalDigits);
        }
        if(((info->IntegerDigits != 0) || !(this->get_IsZeroInteger()))) 
        {
            AppendIntegerString(this->get_IntegerDigits(), sb_int);
        }
        AppendDecimalString(this->get_DecimalDigits(), sb_dec);
        if(info->UseExponent) 
        {
            if(((info->DecimalDigits <= 0) && (info->IntegerDigits <= 0))) 
            {
                this->_positive = true;
            }
            if((sb_int->get_Length() < info->IntegerDigits)) 
            {
                sb_int->Insert17(0, _T("0"), (info->IntegerDigits - sb_int->get_Length()));
            }
            while((sb_exp->get_Length() < (info->ExponentDigits - info->ExponentTailSharpDigits))) sb_exp->Insert5(0, u'0');
            if((expPositive && !(info->ExponentNegativeSignOnly))) 
            {
                sb_exp->Insert2(0, nfi->get_PositiveSign());
            }
             else 
            {
                if(!(expPositive)) 
                {
                    sb_exp->Insert2(0, nfi->get_NegativeSign());
                }
            }
        }
         else 
        {
            if((sb_int->get_Length() < (info->IntegerDigits - info->IntegerHeadSharpDigits))) 
            {
                sb_int->Insert17(0, _T("0"), ((info->IntegerDigits - info->IntegerHeadSharpDigits) - sb_int->get_Length()));
            }
            if(((info->IntegerDigits ==  info->IntegerHeadSharpDigits) && IsZeroOnly(sb_int))) 
            {
                sb_int->Remove(0, sb_int->get_Length());
            }
        }
        ZeroTrimEnd(sb_dec, true);
        while((sb_dec->get_Length() < (info->DecimalDigits - info->DecimalTailSharpDigits))) sb_dec->Append16(u'0');
        if((sb_dec->get_Length() > info->DecimalDigits)) 
        {
            sb_dec->Remove(info->DecimalDigits, (sb_dec->get_Length() - info->DecimalDigits));
        }
        return info->Format2(format, offset, length, nfi, this->_positive, sb_int, sb_dec, sb_exp);
    }
    
    void NumberFormatter::ZeroTrimEnd(Text::StringBuilder* sb, bool canEmpty) {
        int32_t len = 0;
        for(int32_t i = (sb->get_Length() - 1); canEmpty ? (i >= 0) : (i > 0); i--){
            if(((int32_t)(sb->get_Chars(i)) != 48)) 
            {
                break;
            }
            len++;
        }
        if((len > 0)) 
        {
            sb->Remove((sb->get_Length() - len), len);
        }
    }
    
    bool NumberFormatter::IsZeroOnly(Text::StringBuilder* sb) {
        for(int32_t i = 0; (i < sb->get_Length()); i++) {
            if((Char::IsDigit(sb->get_Chars(i)) && ((int32_t)(sb->get_Chars(i)) != 48))) 
            {
                return false;
            }
        }
        return true;
    }
    
    void NumberFormatter::AppendNonNegativeNumber(Text::StringBuilder* sb, int32_t v) {
        if((v < 0)) 
        {
            throw cli::gcnew<ArgumentException>();
        }
        int32_t i = (ScaleOrder((int64_t)(v)) - 1);
        do {
            int32_t n = (v / (int32_t)GetTenPowerOf(i));
            sb->Append16((char16_t)(48 | n));
            (v = v - ((int32_t)GetTenPowerOf(i--) * n));
        }
        while((i >= 0));
    }
    
    void NumberFormatter::AppendIntegerString(int32_t minLength, Text::StringBuilder* sb) {
        if((this->_decPointPos <= 0)) 
        {
            sb->Append17(u'0', minLength);
            return;
        }
        if((this->_decPointPos < minLength)) 
        {
            sb->Append17(u'0', (minLength - this->_decPointPos));
        }
        AppendDigits2((this->_digitsLen - this->_decPointPos), this->_digitsLen, sb);
    }
    
    void NumberFormatter::AppendIntegerString2(int32_t minLength) {
        if((this->_decPointPos <= 0)) 
        {
            Append2(u'0', minLength);
            return;
        }
        if((this->_decPointPos < minLength)) 
        {
            Append2(u'0', (minLength - this->_decPointPos));
        }
        AppendDigits((this->_digitsLen - this->_decPointPos), this->_digitsLen);
    }
    
    void NumberFormatter::AppendDecimalString(int32_t precision, Text::StringBuilder* sb) {
        AppendDigits2(((this->_digitsLen - precision) - this->_decPointPos), (this->_digitsLen - this->_decPointPos), sb);
    }
    
    void NumberFormatter::AppendDecimalString2(int32_t precision) {
        AppendDigits(((this->_digitsLen - precision) - this->_decPointPos), (this->_digitsLen - this->_decPointPos));
    }
    
    void NumberFormatter::AppendIntegerStringWithGroupSeparator(cli::array<int32_t>* groups, String* groupSeparator) {
        if(this->get_IsZeroInteger()) 
        {
            Append(u'0');
            return;
        }
        int32_t total = 0;
        int32_t groupIndex = 0;
        for(int32_t i = 0; (i < groups->get_Length()); i++){
            (total = total + groups->at(i));
            if((total <= this->_decPointPos)) 
            {
                groupIndex = i;
            }
             else 
            {
                break;
            }
        }
        if(((groups->get_Length() > 0) && (total > 0))) 
        {
            int32_t counter;
            int32_t groupSize = groups->at(groupIndex);
            int32_t fraction = (this->_decPointPos > total) ? (this->_decPointPos - total) : 0;
            if((groupSize ==  0)) 
            {
                while(((groupIndex >= 0) && (groups->at(groupIndex) ==  0))) groupIndex--;
                groupSize = (fraction > 0) ? fraction : groups->at(groupIndex);
            }
            if((fraction ==  0)) 
            {
                counter = groupSize;
            }
             else 
            {
                (groupIndex = groupIndex + (fraction / groupSize));
                counter = (fraction % groupSize);
                if((counter ==  0)) 
                {
                    counter = groupSize;
                }
                 else 
                {
                    groupIndex++;
                }
            }
            if((total >= this->_decPointPos)) 
            {
                int32_t lastGroupSize = groups->at(0);
                if((total > lastGroupSize)) 
                {
                    int32_t lastGroupDiff = -((lastGroupSize - this->_decPointPos));
                    int32_t lastGroupMod;
                    if((lastGroupDiff < lastGroupSize)) 
                    {
                        counter = lastGroupDiff;
                    }
                     else 
                    {
                        if(((lastGroupSize > 0) && ((lastGroupMod = (this->_decPointPos % lastGroupSize)) > (0)))) 
                        {
                            counter = lastGroupMod;
                        }
                    }
                }
            }
            for(int32_t i = 0; ; ){
                if((((this->_decPointPos - i) <= counter) || (counter ==  0))) 
                {
                    AppendDigits((this->_digitsLen - this->_decPointPos), (this->_digitsLen - i));
                    break;
                }
                AppendDigits(((this->_digitsLen - i) - counter), (this->_digitsLen - i));
                (i = i + counter);
                Append3(groupSeparator);
                if(((--groupIndex < groups->get_Length()) && (groupIndex >= 0))) 
                {
                    groupSize = groups->at(groupIndex);
                }
                counter = groupSize;
            }
        }
         else 
        {
            AppendDigits((this->_digitsLen - this->_decPointPos), this->_digitsLen);
        }
    }
    
    void NumberFormatter::AppendExponent(Globalization::NumberFormatInfo* nfi, int32_t exponent, int32_t minDigits) {
        if((this->_specifierIsUpper || ((int32_t)(this->_specifier) ==  82))) 
        {
            Append(u'E');
        }
         else 
        {
            Append(u'e');
        }
        if((exponent >= 0)) 
        {
            Append3(nfi->get_PositiveSign());
        }
         else 
        {
            Append3(nfi->get_NegativeSign());
            exponent = -(exponent);
        }
        if((exponent ==  0)) 
        {
            Append2(u'0', minDigits);
        }
         else 
        {
            if((exponent < 10)) 
            {
                Append2(u'0', (minDigits - 1));
                Append((char16_t)(48 | exponent));
            }
             else 
            {
                uint32_t hexDigit = FastToDecHex(exponent);
                if(((exponent >= 100) || (minDigits ==  3))) 
                {
                    Append((char16_t)(48U | (hexDigit >> 8)));
                }
                Append((char16_t)(48U | ((hexDigit >> 4) & 15U)));
                Append((char16_t)(48U | (hexDigit & 15U)));
            }
        }
    }
    
    void NumberFormatter::AppendOneDigit(int32_t start) {
        if((this->_ind ==  this->_cbuf->get_Length())) 
        {
            Resize((this->_ind + 10));
        }
        (start = start + this->_offset);
        uint32_t v;
        if((start < 0)) 
        {
            v = 0U;
        }
         else 
        {
            if((start < 8)) 
            {
                v = this->_val1;
            }
             else 
            {
                if((start < 16)) 
                {
                    v = this->_val2;
                }
                 else 
                {
                    if((start < 24)) 
                    {
                        v = this->_val3;
                    }
                     else 
                    {
                        if((start < 32)) 
                        {
                            v = this->_val4;
                        }
                         else 
                        {
                            v = 0U;
                        }
                    }
                }
            }
        }
        (v = v >> (((start & 7) << 2) & 31));
        this->_cbuf->at(this->_ind++) = (char16_t)(48U | (v & 15U));
    }
    
    void NumberFormatter::FastAppendDigits(int32_t val, bool force) {
        int32_t i = this->_ind;
        int32_t digits;
        if((force || (val >= 100))) 
        {
            int32_t v = ((val * 5243) >> 19);
            digits = (*(DecHexDigits + v));
            if((force || (val >= 1000))) 
            {
                this->_cbuf->at(i++) = (char16_t)(48 | (digits >> 4));
            }
            this->_cbuf->at(i++) = (char16_t)(48 | (digits & 15));
            digits = (*(DecHexDigits + (val - (v * 100))));
        }
         else 
        {
            digits = (*(DecHexDigits + val));
        }
        if((force || (val >= 10))) 
        {
            this->_cbuf->at(i++) = (char16_t)(48 | (digits >> 4));
        }
        this->_cbuf->at(i++) = (char16_t)(48 | (digits & 15));
        this->_ind = i;
    }
    
    void NumberFormatter::AppendDigits(int32_t start, int32_t end) {
        if((start >= end)) 
        {
            return;
        }
        int32_t i = (this->_ind + (end - start));
        if((i > this->_cbuf->get_Length())) 
        {
            Resize((i + 10));
        }
        this->_ind = i;
        (end = end + this->_offset);
        (start = start + this->_offset);
        for(int32_t next = ((start + 8) - (start & 7)); ; start = next, (next = next + 8)){
            uint32_t v;
            if((next ==  8)) 
            {
                v = this->_val1;
            }
             else 
            {
                if((next ==  16)) 
                {
                    v = this->_val2;
                }
                 else 
                {
                    if((next ==  24)) 
                    {
                        v = this->_val3;
                    }
                     else 
                    {
                        if((next ==  32)) 
                        {
                            v = this->_val4;
                        }
                         else 
                        {
                            v = 0U;
                        }
                    }
                }
            }
            (v = v >> (((start & 7) << 2) & 31));
            if((next > end)) 
            {
                next = end;
            }
            this->_cbuf->at(--i) = (char16_t)(48U | (v & 15U));
            switch((next - start)) {
                case 8: case_785: {
                    this->_cbuf->at(--i) = (char16_t)(48U | ((v = v >> 4) & 15U));
                    goto case_786;
                }
                case 7: case_786: {
                    this->_cbuf->at(--i) = (char16_t)(48U | ((v = v >> 4) & 15U));
                    goto case_787;
                }
                case 6: case_787: {
                    this->_cbuf->at(--i) = (char16_t)(48U | ((v = v >> 4) & 15U));
                    goto case_788;
                }
                case 5: case_788: {
                    this->_cbuf->at(--i) = (char16_t)(48U | ((v = v >> 4) & 15U));
                    goto case_789;
                }
                case 4: case_789: {
                    this->_cbuf->at(--i) = (char16_t)(48U | ((v = v >> 4) & 15U));
                    goto case_790;
                }
                case 3: case_790: {
                    this->_cbuf->at(--i) = (char16_t)(48U | ((v = v >> 4) & 15U));
                    goto case_791;
                }
                case 2: case_791: {
                    this->_cbuf->at(--i) = (char16_t)(48U | ((v = v >> 4) & 15U));
                    goto case_792;
                }
                case 1: case_792: {
                    if((next ==  end)) 
                    {
                        return;
                    }
                    continue;
                }
            }
        }
    }
    
    void NumberFormatter::AppendDigits2(int32_t start, int32_t end, Text::StringBuilder* sb) {
        if((start >= end)) 
        {
            return;
        }
        int32_t i = (sb->get_Length() + (end - start));
        sb->set_Length(i);
        (end = end + this->_offset);
        (start = start + this->_offset);
        for(int32_t next = ((start + 8) - (start & 7)); ; start = next, (next = next + 8)){
            uint32_t v;
            if((next ==  8)) 
            {
                v = this->_val1;
            }
             else 
            {
                if((next ==  16)) 
                {
                    v = this->_val2;
                }
                 else 
                {
                    if((next ==  24)) 
                    {
                        v = this->_val3;
                    }
                     else 
                    {
                        if((next ==  32)) 
                        {
                            v = this->_val4;
                        }
                         else 
                        {
                            v = 0U;
                        }
                    }
                }
            }
            (v = v >> (((start & 7) << 2) & 31));
            if((next > end)) 
            {
                next = end;
            }
            sb->set_Chars(--i, (char16_t)(48U | (v & 15U)));
            switch((next - start)) {
                case 8: case_793: {
                    sb->set_Chars(--i, (char16_t)(48U | ((v = v >> 4) & 15U)));
                    goto case_794;
                }
                case 7: case_794: {
                    sb->set_Chars(--i, (char16_t)(48U | ((v = v >> 4) & 15U)));
                    goto case_795;
                }
                case 6: case_795: {
                    sb->set_Chars(--i, (char16_t)(48U | ((v = v >> 4) & 15U)));
                    goto case_796;
                }
                case 5: case_796: {
                    sb->set_Chars(--i, (char16_t)(48U | ((v = v >> 4) & 15U)));
                    goto case_797;
                }
                case 4: case_797: {
                    sb->set_Chars(--i, (char16_t)(48U | ((v = v >> 4) & 15U)));
                    goto case_798;
                }
                case 3: case_798: {
                    sb->set_Chars(--i, (char16_t)(48U | ((v = v >> 4) & 15U)));
                    goto case_799;
                }
                case 2: case_799: {
                    sb->set_Chars(--i, (char16_t)(48U | ((v = v >> 4) & 15U)));
                    goto case_800;
                }
                case 1: case_800: {
                    if((next ==  end)) 
                    {
                        return;
                    }
                    continue;
                }
            }
        }
    }
    
    void NumberFormatter::Multiply10(int32_t count) {
        if(((count <= 0) || (this->_digitsLen ==  0))) 
        {
            return;
        }
        (this->_decPointPos = this->_decPointPos + count);
    }
    
    void NumberFormatter::Divide10(int32_t count) {
        if(((count <= 0) || (this->_digitsLen ==  0))) 
        {
            return;
        }
        (this->_decPointPos = this->_decPointPos - count);
    }
    
    NumberFormatter* NumberFormatter::GetClone() {
        return cli::cast<NumberFormatter*>(this->MemberwiseClone());
    }
    
    void NumberFormatter::set_CurrentCulture(Globalization::CultureInfo* value) {
        if(((value != nullptr) && value->get_IsReadOnly())) 
        {
            this->_nfi = value->get_NumberFormat_56b6d54c07628932();
        }
         else 
        {
            this->_nfi = nullptr;
        }
        return;
    }
    
    int32_t NumberFormatter::get_IntegerDigits() {
        return (this->_decPointPos > 0) ? this->_decPointPos : 1;
    }
    
    int32_t NumberFormatter::get_DecimalDigits() {
        return (this->_digitsLen > this->_decPointPos) ? (this->_digitsLen - this->_decPointPos) : 0;
    }
    
    bool NumberFormatter::get_IsFloatingSource() {
        return ((this->_defPrecision ==  15) || (this->_defPrecision ==  7));
    }
    
    bool NumberFormatter::get_IsZero() {
        return (this->_digitsLen ==  0);
    }
    
    bool NumberFormatter::get_IsZeroInteger() {
        return ((this->_digitsLen ==  0) || (this->_decPointPos <= 0));
    }
    
}
namespace System {
    
    
    void Object::constructor() {
    }
    
    void Object::Finalize_b946fbc32e26afd6() {
    }
    
    bool Object::Equals_ed975d2f4a7d193e(Object* obj) {
        return (this ==  obj);
    }
    
    bool Object::Equals2(Object* objA, Object* objB) {
        if((objA ==  objB)) 
        {
            return true;
        }
        if(((objA ==  nullptr) || (objB ==  nullptr))) 
        {
            return false;
        }
        return objA->Equals_ed975d2f4a7d193e(objB);
    }
    
    int32_t Object::GetHashCode_6648aef0f235ee6c() {
        return InternalGetHashCode(this);
    }
    
    Type* Object::GetType() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    Object* Object::MemberwiseClone() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    String* Object::ToString_1636a0751cb9ac11() {
        return GetType()->ToString_1636a0751cb9ac11();
    }
    
    bool Object::ReferenceEquals(Object* objA, Object* objB) {
        return (objA ==  objB);
    }
    
    int32_t Object::InternalGetHashCode(Object* o) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void* Object::obj_address() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Object::FieldGetter(String* typeName, String* fieldName, Object* val) {
    }
    
    void Object::FieldSetter(String* typeName, String* fieldName, Object* val) {
    }
    
}
namespace System {
    
    
    void ObjectDisposedException::constructor(String* objectName) {
        this->obj_name = objectName;
        this->msg = Locale::GetText(_T("The object was used after being disposed."));
    }
    
    void ObjectDisposedException::constructor(String* objectName, String* message) {
        this->obj_name = objectName;
        this->msg = message;
    }
    
    void ObjectDisposedException::constructor(String* message, Exception* innerException) {
    }
    
    void ObjectDisposedException::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        this->obj_name = info->GetString(_T("ObjectName"));
    }
    
    void ObjectDisposedException::GetObjectData_bc9b88d7eb43b6d8(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        InvalidOperationException::GetObjectData_bc9b88d7eb43b6d8(info, context);
        info->AddValue16(_T("ObjectName"), this->obj_name);
    }
    
    String* ObjectDisposedException::get_Message_d211df4045b57cbf() {
        return this->msg;
    }
    
    String* ObjectDisposedException::get_ObjectName() {
        return this->obj_name;
    }
    
}
namespace System {
    
    
    void ObsoleteAttribute::constructor() {
    }
    
    void ObsoleteAttribute::constructor(String* message) {
        this->_message = message;
    }
    
    void ObsoleteAttribute::constructor(String* message, bool error) {
        this->_message = message;
        this->_error = error;
    }
    
    String* ObsoleteAttribute::get_Message() {
        return this->_message;
    }
    
    bool ObsoleteAttribute::get_IsError() {
        return this->_error;
    }
    
}
namespace System {
    
    
    void OperatingSystem::constructor(PlatformID platform, Version* version) {
        if(Version::op_Equality(version, nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("version"));
        }
        this->_platform = platform;
        this->_version = version;
        if(((int32_t)(platform) ==  2)) 
        {
            if((version->get_Revision() != 0)) 
            {
                this->_servicePack = cli::concat(_T("Service Pack "), cli::box((version->get_Revision() >> 16)));
            }
        }
    }
    
    Object* OperatingSystem::Clone() {
        return cli::gcnew<OperatingSystem>(this->_platform, this->_version);
    }
    
    void OperatingSystem::GetObjectData(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        info->AddValue16(_T("_platform"), cli::box(this->_platform));
        info->AddValue16(_T("_version"), this->_version);
        info->AddValue16(_T("_servicePack"), this->_servicePack);
    }
    
    String* OperatingSystem::ToString_1636a0751cb9ac11() {
        String *str;
        switch((int32_t)(this->_platform)) {
            case 2: case_801: {
                str = _T("Microsoft Windows NT");
                break;
            }
            case 0: case_802: {
                str = _T("Microsoft Win32S");
                break;
            }
            case 1: case_803: {
                str = _T("Microsoft Windows 98");
                break;
            }
            case 3: case_804: {
                str = _T("Microsoft Windows CE");
                break;
            }
            case 4: case 128: case_805: {
                str = _T("Unix");
                break;
            }
            case 5: case_806: {
                str = _T("XBox");
                break;
            }
            case 6: case_807: {
                str = _T("OSX");
                break;
            }
            default: case_808: {
                str = Locale::GetText(_T("<unknown>"));
                break;
            }
        }
        String *sstr = _T("");
        if(String::op_Inequality(this->get_ServicePack(), String::Empty)) 
        {
            sstr = cli::concat(_T(" "), this->get_ServicePack());
        }
        return cli::concat(str, _T(" "));
    }
    
    PlatformID OperatingSystem::get_Platform() {
        return this->_platform;
    }
    
    Version* OperatingSystem::get_Version() {
        return this->_version;
    }
    
    String* OperatingSystem::get_ServicePack() {
        return this->_servicePack;
    }
    
    String* OperatingSystem::get_VersionString() {
        return Object::ToString_1636a0751cb9ac11();
    }
    
}
namespace System {
    
    
    void OperationCanceledException::constructor() {
        this->set_HResult(-2146233029);
    }
    
    void OperationCanceledException::constructor(String* message) {
        this->set_HResult(-2146233029);
    }
    
    void OperationCanceledException::constructor(String* message, Exception* innerException) {
        this->set_HResult(-2146233029);
    }
    
    void OperationCanceledException::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
    }
    
    void OperationCanceledException::constructor(Threading::CancellationToken token) {
        this->token = cli::wrap_nullable(token);
    }
    
    void OperationCanceledException::constructor(String* message, Threading::CancellationToken token) {
        this->token = cli::wrap_nullable(token);
    }
    
    void OperationCanceledException::constructor(String* message, Exception* innerException, Threading::CancellationToken token) {
        this->token = cli::wrap_nullable(token);
    }
    
    Threading::CancellationToken OperationCanceledException::get_CancellationToken() {
        if(((Nullable2<Threading::CancellationToken>)(cli::unwrap_nullable(this->token)) ==  nullptr)) 
        {
            return Threading::CancellationToken::get_None();
        }
        return this->token->get_Value();
    }
    
}
namespace System {
    
    
    void OutOfMemoryException::constructor() {
        this->set_HResult(-2147024882);
    }
    
    void OutOfMemoryException::constructor(String* message) {
        this->set_HResult(-2147024882);
    }
    
    void OutOfMemoryException::constructor(String* message, Exception* innerException) {
        this->set_HResult(-2147024882);
    }
    
    void OutOfMemoryException::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
    }
    
}
namespace System {
    
    
    void OverflowException::constructor() {
        this->set_HResult(-2146233066);
    }
    
    void OverflowException::constructor(String* message) {
        this->set_HResult(-2146233066);
    }
    
    void OverflowException::constructor(String* message, Exception* innerException) {
        this->set_HResult(-2146233066);
    }
    
    void OverflowException::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
    }
    
}
namespace System {
    
    
    void ParamArrayAttribute::constructor() {
    }
    
}
namespace System {
    
    
    void PlatformNotSupportedException::constructor() {
        this->set_HResult(-2146233031);
    }
    
    void PlatformNotSupportedException::constructor(String* message) {
        this->set_HResult(-2146233031);
    }
    
    void PlatformNotSupportedException::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
    }
    
    void PlatformNotSupportedException::constructor(String* message, Exception* inner) {
        this->set_HResult(-2146233031);
    }
    
}
namespace System {
    
    
    void Random::constructor() {
    }
    
    void Random::constructor(int32_t Seed) {
        int32_t ii;
        int32_t mj, mk;
        if((Seed ==  -2147483648)) 
        {
            mj = (161803398 - Math::Abs4(-2147483647));
        }
         else 
        {
            mj = (161803398 - Math::Abs4(Seed));
        }
        this->SeedArray->at(55) = mj;
        mk = 1;
        for(int32_t i = 1; (i < 55); i++){
            ii = ((21 * i) % 55);
            this->SeedArray->at(ii) = mk;
            mk = (mj - mk);
            if((mk < 0)) 
            {
                (mk = mk + 2147483647);
            }
            mj = this->SeedArray->at(ii);
        }
        for(int32_t k = 1; (k < 5); k++){
            for(int32_t i = 1; (i < 56); i++){
                (this->SeedArray->at(i) = this->SeedArray->at(i) - this->SeedArray->at((1 + ((i + 30) % 55))));
                if((this->SeedArray->at(i) < 0)) 
                {
                    (this->SeedArray->at(i) = this->SeedArray->at(i) + 2147483647);
                }
            }
        }
        this->inext = 0;
        this->inextp = 31;
    }
    
    double Random::Sample_30fd83eefb868e36() {
        int32_t retVal;
        if((++this->inext >= 56)) 
        {
            this->inext = 1;
        }
        if((++this->inextp >= 56)) 
        {
            this->inextp = 1;
        }
        retVal = (this->SeedArray->at(this->inext) - this->SeedArray->at(this->inextp));
        if((retVal < 0)) 
        {
            (retVal = retVal + 2147483647);
        }
        this->SeedArray->at(this->inext) = retVal;
        return ((double)(retVal) * 4.6566128752458E-10);
    }
    
    int32_t Random::Next_5d1c2ba772311adc() {
        return (int32_t)(Sample_30fd83eefb868e36() * 2147483647.);
    }
    
    int32_t Random::Next_6230398d2aa7146(int32_t maxValue) {
        if((maxValue < 0)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(Locale::GetText(_T("Max value is less than min value.")));
        }
        return (int32_t)(Sample_30fd83eefb868e36() * (double)(maxValue));
    }
    
    int32_t Random::Next_33b9d2ae4fec0c4d(int32_t minValue, int32_t maxValue) {
        if((minValue > maxValue)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(Locale::GetText(_T("Min value is greater than max value.")));
        }
        uint32_t diff = (uint32_t)(maxValue - minValue);
        if((diff <= 1U)) 
        {
            return minValue;
        }
        return (int32_t)((int64_t)((uint32_t)(Sample_30fd83eefb868e36() * (double)(diff))) + (int64_t)(minValue));
    }
    
    void Random::NextBytes_9d5391dd460375ec(cli::array<unsigned char>* buffer) {
        if((buffer ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("buffer"));
        }
        for(int32_t i = 0; (i < buffer->get_Length()); i++){
            buffer->at(i) = (unsigned char)(Sample_30fd83eefb868e36() * 256.);
        }
    }
    
    double Random::NextDouble_e02a5de50c499a05() {
        return this->Sample_30fd83eefb868e36();
    }
    
}
namespace System {
    
    
    void RankException::constructor() {
        this->set_HResult(-2146233065);
    }
    
    void RankException::constructor(String* message) {
        this->set_HResult(-2146233065);
    }
    
    void RankException::constructor(String* message, Exception* innerException) {
        this->set_HResult(-2146233065);
    }
    
    void RankException::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
    }
    
}
namespace System {
    
    
    void ResolveEventArgs::constructor(String* name) {
        this->m_Name = name;
    }
    
    void ResolveEventArgs::constructor(String* name, Reflection::Assembly* requestingAssembly) {
        this->m_Name = name;
        this->m_Requesting = requestingAssembly;
    }
    
    String* ResolveEventArgs::get_Name() {
        return this->m_Name;
    }
    
    Reflection::Assembly* ResolveEventArgs::get_RequestingAssembly() {
        return this->m_Requesting;
    }
    
}
namespace System {
    
    
    void SerializableAttribute::constructor() {
    }
    
}
namespace System {
    
    
    void StackOverflowException::constructor() {
    }
    
    void StackOverflowException::constructor(String* message) {
    }
    
    void StackOverflowException::constructor(String* message, Exception* innerException) {
    }
    
    void StackOverflowException::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
    }
    
}
namespace System {
    
    
    void STAThreadAttribute::constructor() {
    }
    
}
namespace System {
    
    String*  String::Empty;
    int32_t  String::LOS_limit;
    
    String::String()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void String::constructor(char16_t* value) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void String::constructor(char16_t* value, int32_t startIndex, int32_t length) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void String::constructor(signed char* value) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void String::constructor(signed char* value, int32_t startIndex, int32_t length) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void String::constructor(signed char* value, int32_t startIndex, int32_t length, Text::Encoding* enc) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void String::constructor(cli::array<char16_t>* value, int32_t startIndex, int32_t length) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void String::constructor(cli::array<char16_t>* value) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void String::constructor(char16_t c, int32_t count) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void String::static_constructor() {
    }
    
    bool String::Equals3(String* a, String* b) {
        if((cli::cast<Object*>(a) ==  cli::cast<Object*>(b))) 
        {
            return true;
        }
        if(((a ==  nullptr) || (b ==  nullptr))) 
        {
            return false;
        }
        int32_t len = a->length;
        if((len != b->length)) 
        {
            return false;
        }
        {
            /* FIXED - BLOCK */
            char16_t* s1 = cli::fixed_guard(&(a->start_char));
            char16_t* s2 = cli::fixed_guard(&(b->start_char));
            char16_t *s1_ptr = s1;
            char16_t *s2_ptr = s2;
            while((len >= 8)) {
                if((((((*((int32_t*)(s1_ptr) + 0)) != (*((int32_t*)(s2_ptr) + 0))) || ((*((int32_t*)(s1_ptr) + 4)) != (*((int32_t*)(s2_ptr) + 4)))) || ((*((int32_t*)(s1_ptr) + 8)) != (*((int32_t*)(s2_ptr) + 8)))) || ((*((int32_t*)(s1_ptr) + 12)) != (*((int32_t*)(s2_ptr) + 12))))) 
                {
                    return false;
                }
                (s1_ptr = (s1_ptr += 16));
                (s2_ptr = (s2_ptr += 16));
                (len = len - 8);
            }
            if((len >= 4)) 
            {
                if((((*((int32_t*)(s1_ptr) + 0)) != (*((int32_t*)(s2_ptr) + 0))) || ((*((int32_t*)(s1_ptr) + 4)) != (*((int32_t*)(s2_ptr) + 4))))) 
                {
                    return false;
                }
                (s1_ptr = (s1_ptr += 8));
                (s2_ptr = (s2_ptr += 8));
                (len = len - 4);
            }
            if((len > 1)) 
            {
                if(((*((int32_t*)(s1_ptr) + 0)) != (*((int32_t*)(s2_ptr) + 0)))) 
                {
                    return false;
                }
                (s1_ptr = (s1_ptr += 4));
                (s2_ptr = (s2_ptr += 4));
                (len = len - 2);
            }
            return ((len ==  0) || ((int32_t)((*s1_ptr)) ==  (int32_t)((*s2_ptr))));
        }
    }
    
    bool String::Equals_ed975d2f4a7d193e(Object* obj) {
        return Equals3(this, cli::as<String*>(obj));
    }
    
    bool String::Equals5(String* value) {
        return Equals3(this, value);
    }
    
    Object* String::Clone() {
        return this;
    }
    
    TypeCode String::GetTypeCode() {
        return TypeCode::String2;
    }
    
    void String::CopyTo(int32_t sourceIndex, cli::array<char16_t>* destination, int32_t destinationIndex, int32_t count) {
        if((destination ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("destination"));
        }
        if((sourceIndex < 0)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("sourceIndex"), _T("Cannot be negative"));
        }
        if((destinationIndex < 0)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("destinationIndex"), _T("Cannot be negative."));
        }
        if((count < 0)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("count"), _T("Cannot be negative."));
        }
        if((sourceIndex > (this->get_Length() - count))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("sourceIndex"), _T("sourceIndex + count > Length"));
        }
        if((destinationIndex > (destination->get_Length() - count))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("destinationIndex"), _T("destinationIndex + count > destination.Length"));
        }
        {
            /* FIXED - BLOCK */
            char16_t* dest = cli::fixed_guard(((destination ==  nullptr) || (destination->get_Length() ==  0)) ? nullptr : destination);
            char16_t* src = cli::fixed_guard(this);
            {
                CharCopy((dest + (int32_t)(destinationIndex)), (src + (int32_t)(sourceIndex)), count);
            }
        }
    }
    
    cli::array<char16_t>* String::ToCharArray() {
        return ToCharArray2(0, this->length);
    }
    
    cli::array<char16_t>* String::ToCharArray2(int32_t startIndex, int32_t length) {
        if((startIndex < 0)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("startIndex"), _T("< 0"));
        }
        if((length < 0)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("length"), _T("< 0"));
        }
        if((startIndex > (this->length - length))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("startIndex"), _T("Must be greater than the length of the string."));
        }
        cli::array<char16_t> *tmp = (new cli::array<char16_t>(length));
        {
            /* FIXED - BLOCK */
            char16_t* dest = cli::fixed_guard(((tmp ==  nullptr) || (tmp->get_Length() ==  0)) ? nullptr : tmp);
            char16_t* src = cli::fixed_guard(this);
            {
                CharCopy(dest, (src + (int32_t)(startIndex)), length);
            }
        }
        return tmp;
    }
    
    cli::array<String*>* String::Split(cli::array<char16_t>* separator) {
        return Split4(separator, 2147483647, StringSplitOptions::None);
    }
    
    cli::array<String*>* String::Split2(cli::array<char16_t>* separator, int32_t count) {
        return Split4(separator, count, StringSplitOptions::None);
    }
    
    cli::array<String*>* String::Split3(cli::array<char16_t>* separator, StringSplitOptions options) {
        return Split4(separator, 2147483647, options);
    }
    
    cli::array<String*>* String::Split4(cli::array<char16_t>* separator, int32_t count, StringSplitOptions options) {
        if((count < 0)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("count"), _T("Count cannot be less than zero."));
        }
        if((((int32_t)(options) != 0) && ((int32_t)(options) != 1))) 
        {
            throw cli::gcnew<ArgumentException>(cli::concat(_T("Illegal enum value: "), cli::box(options)));
        }
        if(((this->get_Length() ==  0) && ((int32_t)(((int32_t)(options) & 1)) != 0))) 
        {
            return (new cli::array<String*>(0));
        }
        if((count <= 1)) 
        {
            return (count ==  0) ? (new cli::array<String*>(0)) : (new cli::array<String*>({this}));
        }
        return SplitByCharacters(separator, count, ((int32_t)(options) != 0));
    }
    
    cli::array<String*>* String::Split5(cli::array<String*>* separator, StringSplitOptions options) {
        return Split6(separator, 2147483647, options);
    }
    
    cli::array<String*>* String::Split6(cli::array<String*>* separator, int32_t count, StringSplitOptions options) {
        if((count < 0)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("count"), _T("Count cannot be less than zero."));
        }
        if((((int32_t)(options) != 0) && ((int32_t)(options) != 1))) 
        {
            throw cli::gcnew<ArgumentException>(cli::concat(_T("Illegal enum value: "), cli::box(options)));
        }
        if((count <= 1)) 
        {
            return (count ==  0) ? (new cli::array<String*>(0)) : (new cli::array<String*>({this}));
        }
        bool removeEmpty = ((int32_t)(((int32_t)(options) & 1)) != 0);
        if(((separator ==  nullptr) || (separator->get_Length() ==  0))) 
        {
            return SplitByCharacters(nullptr, count, removeEmpty);
        }
        if(((this->get_Length() ==  0) && removeEmpty)) 
        {
            return (new cli::array<String*>(0));
        }
        Collections::Generic::List<String*> *arr = cli::gcnew<Collections::Generic::List<String*>>();
        int32_t pos = 0;
        int32_t matchCount = 0;
        while((pos < this->get_Length())) {
            int32_t matchIndex = -1;
            int32_t matchPos = 2147483647;
            for(int32_t i = 0; (i < separator->get_Length()); ++i){
                String *sep = separator->at(i);
                if(((sep ==  nullptr) || (sep->get_Length() ==  0))) 
                {
                    continue;
                }
                int32_t match = IndexOfOrdinalUnchecked(sep, pos, (this->length - pos));
                if(((match >= 0) && (match < matchPos))) 
                {
                    matchIndex = i;
                    matchPos = match;
                }
            }
            if((matchIndex ==  -1)) 
            {
                break;
            }
            if(!(((matchPos ==  pos) && removeEmpty))) 
            {
                if((arr->get_Count() ==  (count - 1))) 
                {
                    break;
                }
                arr->Add(this->Substring2(pos, (matchPos - pos)));
            }
            pos = (matchPos + separator->at(matchIndex)->get_Length());
            matchCount++;
        }
        if((matchCount ==  0)) 
        {
            return (new cli::array<String*>({this}));
        }
        if((((removeEmpty && (matchCount != 0)) && (pos ==  this->get_Length())) && (arr->get_Count() ==  0))) 
        {
            return (new cli::array<String*>(0));
        }
        if(!((removeEmpty && (pos ==  this->get_Length())))) 
        {
            arr->Add(this->Substring(pos));
        }
        return arr->ToArray();
    }
    
    cli::array<String*>* String::SplitByCharacters(cli::array<char16_t>* sep, int32_t count, bool removeEmpty) {
        cli::array<int32_t> *split_points = nullptr;
        int32_t total_points = 0;
        --count;
        if(((sep ==  nullptr) || (sep->get_Length() ==  0))) 
        {
            {
                /* FIXED - BLOCK */
                char16_t* src = cli::fixed_guard(this);
                char16_t *src_ptr = src;
                int32_t len = this->get_Length();
                do {
                    if(Char::IsWhiteSpace((*src_ptr++))) 
                    {
                        if((split_points ==  nullptr)) 
                        {
                            split_points = (new cli::array<int32_t>(8));
                        }
                         else 
                        {
                            if((split_points->get_Length() ==  total_points)) 
                            {
                                Array::template Resize_1<int32_t>(split_points, (split_points->get_Length() * 2));
                            }
                        }
                        split_points->at(total_points++) = (this->get_Length() - len);
                        if(((total_points ==  count) && !(removeEmpty))) 
                        {
                            break;
                        }
                    }
                }
                while((len-- != 0));
            }
        }
         else 
        {
            {
                /* FIXED - BLOCK */
                char16_t* src = cli::fixed_guard(this);
                {
                    /* FIXED - BLOCK */
                    char16_t* sep_src = cli::fixed_guard(((sep ==  nullptr) || (sep->get_Length() ==  0)) ? nullptr : sep);
                    char16_t *src_ptr = src;
                    char16_t *sep_ptr_end = (sep_src + (int32_t)(sep->get_Length()));
                    int32_t len = this->get_Length();
                    do {
                        char16_t *sep_ptr = sep_src;
                        do {
                            if(((int32_t)((*sep_ptr++)) ==  (int32_t)((*src_ptr)))) 
                            {
                                if((split_points ==  nullptr)) 
                                {
                                    split_points = (new cli::array<int32_t>(8));
                                }
                                 else 
                                {
                                    if((split_points->get_Length() ==  total_points)) 
                                    {
                                        Array::template Resize_1<int32_t>(split_points, (split_points->get_Length() * 2));
                                    }
                                }
                                split_points->at(total_points++) = (this->get_Length() - len);
                                if(((total_points ==  count) && !(removeEmpty))) 
                                {
                                    len = 0;
                                }
                                break;
                            }
                        }
                        while((sep_ptr != sep_ptr_end));
                        ++src_ptr;
                    }
                    while((len-- != 0));
                }
            }
        }
        if((total_points ==  0)) 
        {
            return (new cli::array<String*>({this}));
        }
        cli::array<String*> *res = (new cli::array<String*>((Math::Min5(total_points, count) + 1)));
        int32_t prev_index = 0;
        int32_t i = 0;
        if(!(removeEmpty)) 
        {
            for(; (i < total_points); ++i){
                int32_t start = split_points->at(i);
                res->at(i) = SubstringUnchecked(prev_index, (start - prev_index));
                prev_index = (start + 1);
            }
            res->at(i) = SubstringUnchecked(prev_index, (this->get_Length() - prev_index));
        }
         else 
        {
            int32_t used = 0;
            int32_t length;
            for(; (i < total_points); ++i){
                int32_t start = split_points->at(i);
                length = (start - prev_index);
                if((length != 0)) 
                {
                    if((used ==  count)) 
                    {
                        break;
                    }
                    res->at(used++) = SubstringUnchecked(prev_index, length);
                }
                prev_index = (start + 1);
            }
            length = (this->get_Length() - prev_index);
            if((length != 0)) 
            {
                res->at(used++) = SubstringUnchecked(prev_index, length);
            }
            if((used != res->get_Length())) 
            {
                Array::template Resize_1<String*>(res, used);
            }
        }
        return res;
    }
    
    String* String::Substring(int32_t startIndex) {
        if((startIndex ==  0)) 
        {
            return this;
        }
        if(((startIndex < 0) || (startIndex > this->length))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("startIndex"));
        }
        return SubstringUnchecked(startIndex, (this->length - startIndex));
    }
    
    String* String::Substring2(int32_t startIndex, int32_t length) {
        if((length < 0)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("length"), _T("Cannot be negative."));
        }
        if((startIndex < 0)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("startIndex"), _T("Cannot be negative."));
        }
        if((startIndex > this->length)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("startIndex"), _T("Cannot exceed length of string."));
        }
        if((startIndex > (this->length - length))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("length"), _T("startIndex + length cannot exceed length of string."));
        }
        if(((startIndex ==  0) && (length ==  this->length))) 
        {
            return this;
        }
        return SubstringUnchecked(startIndex, length);
    }
    
    String* String::SubstringUnchecked(int32_t startIndex, int32_t length) {
        if((length ==  0)) 
        {
            return Empty;
        }
        String *tmp = InternalAllocateStr(length);
        {
            /* FIXED - BLOCK */
            char16_t* dest = cli::fixed_guard(tmp);
            char16_t* src = cli::fixed_guard(this);
            CharCopy(dest, (src + (int32_t)(startIndex)), length);
        }
        return tmp;
    }
    
    String* String::Trim() {
        if((this->length ==  0)) 
        {
            return Empty;
        }
        int32_t start = FindNotWhiteSpace(0, this->length, 1);
        if((start ==  this->length)) 
        {
            return Empty;
        }
        int32_t end = FindNotWhiteSpace((this->length - 1), start, -1);
        int32_t newLength = ((end - start) + 1);
        if((newLength ==  this->length)) 
        {
            return this;
        }
        return SubstringUnchecked(start, newLength);
    }
    
    String* String::Trim2(cli::array<char16_t>* trimChars) {
        if(((trimChars ==  nullptr) || (trimChars->get_Length() ==  0))) 
        {
            return Trim();
        }
        if((this->length ==  0)) 
        {
            return Empty;
        }
        int32_t start = FindNotInTable(0, this->length, 1, trimChars);
        if((start ==  this->length)) 
        {
            return Empty;
        }
        int32_t end = FindNotInTable((this->length - 1), start, -1, trimChars);
        int32_t newLength = ((end - start) + 1);
        if((newLength ==  this->length)) 
        {
            return this;
        }
        return SubstringUnchecked(start, newLength);
    }
    
    String* String::TrimStart(cli::array<char16_t>* trimChars) {
        if((this->length ==  0)) 
        {
            return Empty;
        }
        int32_t start;
        if(((trimChars ==  nullptr) || (trimChars->get_Length() ==  0))) 
        {
            start = FindNotWhiteSpace(0, this->length, 1);
        }
         else 
        {
            start = FindNotInTable(0, this->length, 1, trimChars);
        }
        if((start ==  0)) 
        {
            return this;
        }
        return SubstringUnchecked(start, (this->length - start));
    }
    
    String* String::TrimEnd(cli::array<char16_t>* trimChars) {
        if((this->length ==  0)) 
        {
            return Empty;
        }
        int32_t end;
        if(((trimChars ==  nullptr) || (trimChars->get_Length() ==  0))) 
        {
            end = FindNotWhiteSpace((this->length - 1), -1, -1);
        }
         else 
        {
            end = FindNotInTable((this->length - 1), -1, -1, trimChars);
        }
        end++;
        if((end ==  this->length)) 
        {
            return this;
        }
        return SubstringUnchecked(0, end);
    }
    
    int32_t String::FindNotWhiteSpace(int32_t pos, int32_t target, int32_t change) {
        {
            /* FIXED - BLOCK */
            char16_t* src = cli::fixed_guard(this);
            while((pos != target)) {
                if(!(Char::IsWhiteSpace((*(src + pos))))) 
                {
                    return pos;
                }
                (pos = pos + change);
            }
        }
        return pos;
    }
    
    int32_t String::FindNotInTable(int32_t pos, int32_t target, int32_t change, cli::array<char16_t>* table) {
        {
            /* FIXED - BLOCK */
            char16_t* tablePtr = cli::fixed_guard(((table ==  nullptr) || (table->get_Length() ==  0)) ? nullptr : table);
            char16_t* thisPtr = cli::fixed_guard(this);
            while((pos != target)) {
                char16_t c = (*(thisPtr + pos));
                int32_t x = 0;
                while((x < table->get_Length())) {
                    if(((int32_t)(c) ==  (int32_t)((*(tablePtr + x))))) 
                    {
                        break;
                    }
                    x++;
                }
                if((x ==  table->get_Length())) 
                {
                    return pos;
                }
                (pos = pos + change);
            }
        }
        return pos;
    }
    
    int32_t String::Compare(String* strA, String* strB) {
        return Globalization::CultureInfo::get_CurrentCulture()->get_CompareInfo_ef6e4d0bc469f6a()->Compare_272e035d74e81a5d(strA, strB, Globalization::CompareOptions::None);
    }
    
    int32_t String::Compare2(String* strA, String* strB, bool ignoreCase) {
        return Globalization::CultureInfo::get_CurrentCulture()->get_CompareInfo_ef6e4d0bc469f6a()->Compare_272e035d74e81a5d(strA, strB, ignoreCase ? Globalization::CompareOptions::IgnoreCase : Globalization::CompareOptions::None);
    }
    
    int32_t String::Compare3(String* strA, String* strB, bool ignoreCase, Globalization::CultureInfo* culture) {
        if((culture ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("culture"));
        }
        return culture->get_CompareInfo_ef6e4d0bc469f6a()->Compare_272e035d74e81a5d(strA, strB, ignoreCase ? Globalization::CompareOptions::IgnoreCase : Globalization::CompareOptions::None);
    }
    
    int32_t String::Compare4(String* strA, int32_t indexA, String* strB, int32_t indexB, int32_t length) {
        return Compare6(strA, indexA, strB, indexB, length, false, Globalization::CultureInfo::get_CurrentCulture());
    }
    
    int32_t String::Compare5(String* strA, int32_t indexA, String* strB, int32_t indexB, int32_t length, bool ignoreCase) {
        return Compare6(strA, indexA, strB, indexB, length, ignoreCase, Globalization::CultureInfo::get_CurrentCulture());
    }
    
    int32_t String::Compare6(String* strA, int32_t indexA, String* strB, int32_t indexB, int32_t length, bool ignoreCase, Globalization::CultureInfo* culture) {
        if((culture ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("culture"));
        }
        if((((((indexA > strA->get_Length()) || (indexB > strB->get_Length())) || (indexA < 0)) || (indexB < 0)) || (length < 0))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>();
        }
        if((length ==  0)) 
        {
            return 0;
        }
        if((strA ==  nullptr)) 
        {
            if((strB ==  nullptr)) 
            {
                return 0;
            }
             else 
            {
                return -1;
            }
        }
         else 
        {
            if((strB ==  nullptr)) 
            {
                return 1;
            }
        }
        Globalization::CompareOptions compopts;
        if(ignoreCase) 
        {
            compopts = Globalization::CompareOptions::IgnoreCase;
        }
         else 
        {
            compopts = Globalization::CompareOptions::None;
        }
        int32_t len1 = length;
        int32_t len2 = length;
        if((length > (strA->get_Length() - indexA))) 
        {
            len1 = (strA->get_Length() - indexA);
        }
        if((length > (strB->get_Length() - indexB))) 
        {
            len2 = (strB->get_Length() - indexB);
        }
        return culture->get_CompareInfo_ef6e4d0bc469f6a()->Compare_cfb40aa8f022b1c6(strA, indexA, len1, strB, indexB, len2, compopts);
    }
    
    int32_t String::Compare7(String* strA, String* strB, StringComparison comparisonType) {
        switch(comparisonType) {
            case StringComparison::CurrentCulture: case_809: {
                return Compare3(strA, strB, false, Globalization::CultureInfo::get_CurrentCulture());
            }
            case StringComparison::CurrentCultureIgnoreCase: case_810: {
                return Compare3(strA, strB, true, Globalization::CultureInfo::get_CurrentCulture());
            }
            case StringComparison::InvariantCulture: case_811: {
                return Compare3(strA, strB, false, Globalization::CultureInfo::get_InvariantCulture());
            }
            case StringComparison::InvariantCultureIgnoreCase: case_812: {
                return Compare3(strA, strB, true, Globalization::CultureInfo::get_InvariantCulture());
            }
            case StringComparison::Ordinal: case_813: {
                return CompareOrdinalUnchecked(strA, 0, 2147483647, strB, 0, 2147483647);
            }
            case StringComparison::OrdinalIgnoreCase: case_814: {
                return CompareOrdinalCaseInsensitiveUnchecked(strA, 0, 2147483647, strB, 0, 2147483647);
            }
            default: case_815: {
                String *msg = Locale::GetText2(_T("Invalid value \'{0}\' for StringComparison"), (new cli::array<Object*>({cli::box(comparisonType)})));
                throw cli::gcnew<ArgumentException>(msg, _T("comparisonType"));
            }
        }
    }
    
    int32_t String::Compare8(String* strA, int32_t indexA, String* strB, int32_t indexB, int32_t length, StringComparison comparisonType) {
        switch(comparisonType) {
            case StringComparison::CurrentCulture: case_816: {
                return Compare6(strA, indexA, strB, indexB, length, false, Globalization::CultureInfo::get_CurrentCulture());
            }
            case StringComparison::CurrentCultureIgnoreCase: case_817: {
                return Compare6(strA, indexA, strB, indexB, length, true, Globalization::CultureInfo::get_CurrentCulture());
            }
            case StringComparison::InvariantCulture: case_818: {
                return Compare6(strA, indexA, strB, indexB, length, false, Globalization::CultureInfo::get_InvariantCulture());
            }
            case StringComparison::InvariantCultureIgnoreCase: case_819: {
                return Compare6(strA, indexA, strB, indexB, length, true, Globalization::CultureInfo::get_InvariantCulture());
            }
            case StringComparison::Ordinal: case_820: {
                return CompareOrdinal2(strA, indexA, strB, indexB, length);
            }
            case StringComparison::OrdinalIgnoreCase: case_821: {
                return CompareOrdinalCaseInsensitive(strA, indexA, strB, indexB, length);
            }
            default: case_822: {
                String *msg = Locale::GetText2(_T("Invalid value \'{0}\' for StringComparison"), (new cli::array<Object*>({cli::box(comparisonType)})));
                throw cli::gcnew<ArgumentException>(msg, _T("comparisonType"));
            }
        }
    }
    
    bool String::Equals6(String* a, String* b, StringComparison comparisonType) {
        return (String::Compare7(a, b, comparisonType) ==  0);
    }
    
    bool String::Equals7(String* value, StringComparison comparisonType) {
        return (String::Compare7(value, this, comparisonType) ==  0);
    }
    
    int32_t String::Compare9(String* strA, String* strB, Globalization::CultureInfo* culture, Globalization::CompareOptions options) {
        if((culture ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("culture"));
        }
        return culture->get_CompareInfo_ef6e4d0bc469f6a()->Compare_272e035d74e81a5d(strA, strB, options);
    }
    
    int32_t String::Compare10(String* strA, int32_t indexA, String* strB, int32_t indexB, int32_t length, Globalization::CultureInfo* culture, Globalization::CompareOptions options) {
        if((culture ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("culture"));
        }
        int32_t len1 = length;
        int32_t len2 = length;
        if((length > (strA->get_Length() - indexA))) 
        {
            len1 = (strA->get_Length() - indexA);
        }
        if((length > (strB->get_Length() - indexB))) 
        {
            len2 = (strB->get_Length() - indexB);
        }
        return culture->get_CompareInfo_ef6e4d0bc469f6a()->Compare_cfb40aa8f022b1c6(strA, indexA, len1, strB, indexB, len2, options);
    }
    
    int32_t String::CompareTo(Object* value) {
        if((value ==  nullptr)) 
        {
            return 1;
        }
        if(!(cli::is<String>(value))) 
        {
            throw cli::gcnew<ArgumentException>();
        }
        return String::Compare(this, cli::cast<String*>(value));
    }
    
    int32_t String::CompareTo2(String* strB) {
        if((strB ==  nullptr)) 
        {
            return 1;
        }
        return Compare(this, strB);
    }
    
    int32_t String::CompareOrdinal(String* strA, String* strB) {
        return CompareOrdinalUnchecked(strA, 0, 2147483647, strB, 0, 2147483647);
    }
    
    int32_t String::CompareOrdinal2(String* strA, int32_t indexA, String* strB, int32_t indexB, int32_t length) {
        if((((((indexA > strA->get_Length()) || (indexB > strB->get_Length())) || (indexA < 0)) || (indexB < 0)) || (length < 0))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>();
        }
        return CompareOrdinalUnchecked(strA, indexA, length, strB, indexB, length);
    }
    
    int32_t String::CompareOrdinalCaseInsensitive(String* strA, int32_t indexA, String* strB, int32_t indexB, int32_t length) {
        if((((((indexA > strA->get_Length()) || (indexB > strB->get_Length())) || (indexA < 0)) || (indexB < 0)) || (length < 0))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>();
        }
        return CompareOrdinalCaseInsensitiveUnchecked(strA, indexA, length, strB, indexB, length);
    }
    
    int32_t String::CompareOrdinalUnchecked(String* strA, int32_t indexA, int32_t lenA, String* strB, int32_t indexB, int32_t lenB) {
        if((strA ==  nullptr)) 
        {
            if((strB ==  nullptr)) 
            {
                return 0;
            }
             else 
            {
                return -1;
            }
        }
         else 
        {
            if((strB ==  nullptr)) 
            {
                return 1;
            }
        }
        int32_t lengthA = Math::Min5(lenA, (strA->get_Length() - indexA));
        int32_t lengthB = Math::Min5(lenB, (strB->get_Length() - indexB));
        if(((lengthA ==  lengthB) && Object::ReferenceEquals(strA, strB))) 
        {
            return 0;
        }
        {
            /* FIXED - BLOCK */
            char16_t* aptr = cli::fixed_guard(strA);
            char16_t* bptr = cli::fixed_guard(strB);
            char16_t *ap = (aptr + (int32_t)(indexA));
            char16_t *end = (ap + (int32_t)(Math::Min5(lengthA, lengthB)));
            char16_t *bp = (bptr + (int32_t)(indexB));
            while((ap < end)) {
                if(((int32_t)((*ap)) != (int32_t)((*bp)))) 
                {
                    return ((int32_t)((*ap)) - (int32_t)((*bp)));
                }
                ap++;
                bp++;
            }
            return (lengthA - lengthB);
        }
    }
    
    int32_t String::CompareOrdinalCaseInsensitiveUnchecked(String* strA, int32_t indexA, int32_t lenA, String* strB, int32_t indexB, int32_t lenB) {
        if((strA ==  nullptr)) 
        {
            if((strB ==  nullptr)) 
            {
                return 0;
            }
             else 
            {
                return -1;
            }
        }
         else 
        {
            if((strB ==  nullptr)) 
            {
                return 1;
            }
        }
        int32_t lengthA = Math::Min5(lenA, (strA->get_Length() - indexA));
        int32_t lengthB = Math::Min5(lenB, (strB->get_Length() - indexB));
        if(((lengthA ==  lengthB) && Object::ReferenceEquals(strA, strB))) 
        {
            return 0;
        }
        {
            /* FIXED - BLOCK */
            char16_t* aptr = cli::fixed_guard(strA);
            char16_t* bptr = cli::fixed_guard(strB);
            char16_t *ap = (aptr + (int32_t)(indexA));
            char16_t *end = (ap + (int32_t)(Math::Min5(lengthA, lengthB)));
            char16_t *bp = (bptr + (int32_t)(indexB));
            while((ap < end)) {
                if(((int32_t)((*ap)) != (int32_t)((*bp)))) 
                {
                    char16_t c1 = Char::ToUpperInvariant((*ap));
                    char16_t c2 = Char::ToUpperInvariant((*bp));
                    if(((int32_t)(c1) != (int32_t)(c2))) 
                    {
                        return ((int32_t)(c1) - (int32_t)(c2));
                    }
                }
                ap++;
                bp++;
            }
            return (lengthA - lengthB);
        }
    }
    
    bool String::EndsWith(String* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("value"));
        }
        return Globalization::CultureInfo::get_CurrentCulture()->get_CompareInfo_ef6e4d0bc469f6a()->IsSuffix_aee4ee93cc1fc6d(this, value, Globalization::CompareOptions::None);
    }
    
    bool String::EndsWith2(String* value, bool ignoreCase, Globalization::CultureInfo* culture) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("value"));
        }
        if((culture ==  nullptr)) 
        {
            culture = Globalization::CultureInfo::get_CurrentCulture();
        }
        return culture->get_CompareInfo_ef6e4d0bc469f6a()->IsSuffix_aee4ee93cc1fc6d(this, value, ignoreCase ? Globalization::CompareOptions::IgnoreCase : Globalization::CompareOptions::None);
    }
    
    int32_t String::IndexOfAny(cli::array<char16_t>* anyOf) {
        if((anyOf ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>();
        }
        if((this->length ==  0)) 
        {
            return -1;
        }
        return IndexOfAnyUnchecked(anyOf, 0, this->length);
    }
    
    int32_t String::IndexOfAny2(cli::array<char16_t>* anyOf, int32_t startIndex) {
        if((anyOf ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>();
        }
        if(((startIndex < 0) || (startIndex > this->length))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>();
        }
        return IndexOfAnyUnchecked(anyOf, startIndex, (this->length - startIndex));
    }
    
    int32_t String::IndexOfAny3(cli::array<char16_t>* anyOf, int32_t startIndex, int32_t count) {
        if((anyOf ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>();
        }
        if(((startIndex < 0) || (startIndex > this->length))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>();
        }
        if(((count < 0) || (startIndex > (this->length - count)))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("count"), _T("Count cannot be negative, and startIndex + count must be less than length of the string."));
        }
        return IndexOfAnyUnchecked(anyOf, startIndex, count);
    }
    
    int32_t String::IndexOfAnyUnchecked(cli::array<char16_t>* anyOf, int32_t startIndex, int32_t count) {
        if((anyOf->get_Length() ==  0)) 
        {
            return -1;
        }
        if((anyOf->get_Length() ==  1)) 
        {
            return IndexOfUnchecked(anyOf->at(0), startIndex, count);
        }
        {
            /* FIXED - BLOCK */
            char16_t* any = cli::fixed_guard(((anyOf ==  nullptr) || (anyOf->get_Length() ==  0)) ? nullptr : anyOf);
            int32_t highest = (int32_t)((*any));
            int32_t lowest = (int32_t)((*any));
            char16_t *end_any_ptr = (any + (int32_t)(anyOf->get_Length()));
            char16_t *any_ptr = any;
            while((++any_ptr != end_any_ptr)) {
                if(((int32_t)((*any_ptr)) > highest)) 
                {
                    highest = (int32_t)((*any_ptr));
                    continue;
                }
                if(((int32_t)((*any_ptr)) < lowest)) 
                {
                    lowest = (int32_t)((*any_ptr));
                }
            }
            {
                /* FIXED - BLOCK */
                char16_t* start = cli::fixed_guard(&(this->start_char));
                char16_t *ptr = (start + (int32_t)(startIndex));
                char16_t *end_ptr = (ptr + (int32_t)(count));
                while((ptr != end_ptr)) {
                    if((((int32_t)((*ptr)) > highest) || ((int32_t)((*ptr)) < lowest))) 
                    {
                        ptr++;
                        continue;
                    }
                    if(((int32_t)((*ptr)) ==  (int32_t)((*any)))) 
                    {
                        return (int32_t)(ptr - start);
                    }
                    any_ptr = any;
                    while((++any_ptr != end_any_ptr)) {
                        if(((int32_t)((*ptr)) ==  (int32_t)((*any_ptr)))) 
                        {
                            return (int32_t)(ptr - start);
                        }
                    }
                    ptr++;
                }
            }
        }
        return -1;
    }
    
    int32_t String::IndexOf(String* value, StringComparison comparisonType) {
        return IndexOf3(value, 0, this->get_Length(), comparisonType);
    }
    
    int32_t String::IndexOf2(String* value, int32_t startIndex, StringComparison comparisonType) {
        return IndexOf3(value, startIndex, (this->get_Length() - startIndex), comparisonType);
    }
    
    int32_t String::IndexOf3(String* value, int32_t startIndex, int32_t count, StringComparison comparisonType) {
        switch(comparisonType) {
            case StringComparison::CurrentCulture: case_823: {
                return Globalization::CultureInfo::get_CurrentCulture()->get_CompareInfo_ef6e4d0bc469f6a()->IndexOf_434caa895db2be65(this, value, startIndex, count, Globalization::CompareOptions::None);
            }
            case StringComparison::CurrentCultureIgnoreCase: case_824: {
                return Globalization::CultureInfo::get_CurrentCulture()->get_CompareInfo_ef6e4d0bc469f6a()->IndexOf_434caa895db2be65(this, value, startIndex, count, Globalization::CompareOptions::IgnoreCase);
            }
            case StringComparison::InvariantCulture: case_825: {
                return Globalization::CultureInfo::get_InvariantCulture()->get_CompareInfo_ef6e4d0bc469f6a()->IndexOf_434caa895db2be65(this, value, startIndex, count, Globalization::CompareOptions::None);
            }
            case StringComparison::InvariantCultureIgnoreCase: case_826: {
                return Globalization::CultureInfo::get_InvariantCulture()->get_CompareInfo_ef6e4d0bc469f6a()->IndexOf_434caa895db2be65(this, value, startIndex, count, Globalization::CompareOptions::IgnoreCase);
            }
            case StringComparison::Ordinal: case_827: {
                return IndexOfOrdinal(value, startIndex, count, Globalization::CompareOptions::Ordinal);
            }
            case StringComparison::OrdinalIgnoreCase: case_828: {
                return IndexOfOrdinal(value, startIndex, count, Globalization::CompareOptions::OrdinalIgnoreCase);
            }
            default: case_829: {
                String *msg = Locale::GetText2(_T("Invalid value \'{0}\' for StringComparison"), (new cli::array<Object*>({cli::box(comparisonType)})));
                throw cli::gcnew<ArgumentException>(msg, _T("comparisonType"));
            }
        }
    }
    
    int32_t String::IndexOfOrdinal(String* value, int32_t startIndex, int32_t count, Globalization::CompareOptions options) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("value"));
        }
        if((startIndex < 0)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("startIndex"));
        }
        if(((count < 0) || ((this->length - startIndex) < count))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("count"));
        }
        if(((int32_t)(options) ==  1073741824)) 
        {
            return IndexOfOrdinalUnchecked(value, startIndex, count);
        }
        return IndexOfOrdinalIgnoreCaseUnchecked(value, startIndex, count);
    }
    
    int32_t String::IndexOfOrdinalUnchecked(String* value, int32_t startIndex, int32_t count) {
        int32_t valueLen = value->get_Length();
        if((count < valueLen)) 
        {
            return -1;
        }
        if((valueLen <= 1)) 
        {
            if((valueLen ==  1)) 
            {
                return IndexOfUnchecked(value->get_Chars(0), startIndex, count);
            }
            return startIndex;
        }
        {
            /* FIXED - BLOCK */
            char16_t* thisptr = cli::fixed_guard(this);
            char16_t* valueptr = cli::fixed_guard(value);
            char16_t *ap = (thisptr + (int32_t)(startIndex));
            char16_t *thisEnd = (((ap + (int32_t)(count)) - (int32_t)(valueLen)) + 2);
            while((ap != thisEnd)) {
                if(((int32_t)((*ap)) ==  (int32_t)((*valueptr)))) 
                {
                    for(int32_t i = 1; (i < valueLen); i++){
                        if(((int32_t)((*(ap + i))) != (int32_t)((*(valueptr + i))))) 
                        {
                            goto NextVal;
                        }
                    }
                    return (int32_t)(ap - thisptr);
                }
                NextVal:
                ap++;
            }
        }
        return -1;
    }
    
    int32_t String::IndexOfOrdinalIgnoreCaseUnchecked(String* value, int32_t startIndex, int32_t count) {
        int32_t valueLen = value->get_Length();
        if((count < valueLen)) 
        {
            return -1;
        }
        if((valueLen ==  0)) 
        {
            return startIndex;
        }
        {
            /* FIXED - BLOCK */
            char16_t* thisptr = cli::fixed_guard(this);
            char16_t* valueptr = cli::fixed_guard(value);
            char16_t *ap = (thisptr + (int32_t)(startIndex));
            char16_t *thisEnd = (((ap + (int32_t)(count)) - (int32_t)(valueLen)) + 2);
            while((ap != thisEnd)) {
                for(int32_t i = 0; (i < valueLen); i++){
                    if(((int32_t)(Char::ToUpperInvariant((*(ap + i)))) != (int32_t)(Char::ToUpperInvariant((*(valueptr + i)))))) 
                    {
                        goto NextVal;
                    }
                }
                return (int32_t)(ap - thisptr);
                NextVal:
                ap++;
            }
        }
        return -1;
    }
    
    int32_t String::LastIndexOf(String* value, StringComparison comparisonType) {
        if((this->get_Length() ==  0)) 
        {
            return (value->get_Length() ==  0) ? 0 : -1;
        }
         else 
        {
            return LastIndexOf3(value, (this->get_Length() - 1), this->get_Length(), comparisonType);
        }
    }
    
    int32_t String::LastIndexOf2(String* value, int32_t startIndex, StringComparison comparisonType) {
        return LastIndexOf3(value, startIndex, (startIndex + 1), comparisonType);
    }
    
    int32_t String::LastIndexOf3(String* value, int32_t startIndex, int32_t count, StringComparison comparisonType) {
        switch(comparisonType) {
            case StringComparison::CurrentCulture: case_830: {
                return Globalization::CultureInfo::get_CurrentCulture()->get_CompareInfo_ef6e4d0bc469f6a()->LastIndexOf_dcf739de60ff316f(this, value, startIndex, count, Globalization::CompareOptions::None);
            }
            case StringComparison::CurrentCultureIgnoreCase: case_831: {
                return Globalization::CultureInfo::get_CurrentCulture()->get_CompareInfo_ef6e4d0bc469f6a()->LastIndexOf_dcf739de60ff316f(this, value, startIndex, count, Globalization::CompareOptions::IgnoreCase);
            }
            case StringComparison::InvariantCulture: case_832: {
                return Globalization::CultureInfo::get_InvariantCulture()->get_CompareInfo_ef6e4d0bc469f6a()->LastIndexOf_dcf739de60ff316f(this, value, startIndex, count, Globalization::CompareOptions::None);
            }
            case StringComparison::InvariantCultureIgnoreCase: case_833: {
                return Globalization::CultureInfo::get_InvariantCulture()->get_CompareInfo_ef6e4d0bc469f6a()->LastIndexOf_dcf739de60ff316f(this, value, startIndex, count, Globalization::CompareOptions::IgnoreCase);
            }
            case StringComparison::Ordinal: case_834: {
                return LastIndexOfOrdinal(value, startIndex, count, Globalization::CompareOptions::Ordinal);
            }
            case StringComparison::OrdinalIgnoreCase: case_835: {
                return LastIndexOfOrdinal(value, startIndex, count, Globalization::CompareOptions::OrdinalIgnoreCase);
            }
            default: case_836: {
                String *msg = Locale::GetText2(_T("Invalid value \'{0}\' for StringComparison"), (new cli::array<Object*>({cli::box(comparisonType)})));
                throw cli::gcnew<ArgumentException>(msg, _T("comparisonType"));
            }
        }
    }
    
    int32_t String::LastIndexOfOrdinal(String* value, int32_t startIndex, int32_t count, Globalization::CompareOptions options) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("value"));
        }
        if((this->get_Length() ==  0)) 
        {
            return (value->get_Length() ==  0) ? 0 : -1;
        }
        if((value->get_Length() ==  0)) 
        {
            return Math::Min5((this->get_Length() - 1), startIndex);
        }
        if(((startIndex < 0) || (startIndex > this->length))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("startIndex"));
        }
        if(((count < 0) || (startIndex < (count - 1)))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("count"));
        }
        if(((int32_t)(options) ==  1073741824)) 
        {
            return LastIndexOfOrdinalUnchecked(value, startIndex, count);
        }
        return LastIndexOfOrdinalIgnoreCaseUnchecked(value, startIndex, count);
    }
    
    int32_t String::LastIndexOfOrdinalUnchecked(String* value, int32_t startIndex, int32_t count) {
        int32_t valueLen = value->get_Length();
        if((count < valueLen)) 
        {
            return -1;
        }
        if((valueLen <= 1)) 
        {
            if((valueLen ==  1)) 
            {
                return LastIndexOfUnchecked(value->get_Chars(0), startIndex, count);
            }
            return startIndex;
        }
        {
            /* FIXED - BLOCK */
            char16_t* thisptr = cli::fixed_guard(this);
            char16_t* valueptr = cli::fixed_guard(value);
            char16_t *ap = (((thisptr + (int32_t)(startIndex)) - (int32_t)(valueLen)) + 2);
            char16_t *thisEnd = (((ap - (int32_t)(count)) + (int32_t)(valueLen)) - 2);
            while((ap != thisEnd)) {
                if(((int32_t)((*ap)) ==  (int32_t)((*valueptr)))) 
                {
                    for(int32_t i = 1; (i < valueLen); i++){
                        if(((int32_t)((*(ap + i))) != (int32_t)((*(valueptr + i))))) 
                        {
                            goto NextVal;
                        }
                    }
                    return (int32_t)(ap - thisptr);
                }
                NextVal:
                ap--;
            }
        }
        return -1;
    }
    
    int32_t String::LastIndexOfOrdinalIgnoreCaseUnchecked(String* value, int32_t startIndex, int32_t count) {
        int32_t valueLen = value->get_Length();
        if((count < valueLen)) 
        {
            return -1;
        }
        if((valueLen ==  0)) 
        {
            return startIndex;
        }
        {
            /* FIXED - BLOCK */
            char16_t* thisptr = cli::fixed_guard(this);
            char16_t* valueptr = cli::fixed_guard(value);
            char16_t *ap = (((thisptr + (int32_t)(startIndex)) - (int32_t)(valueLen)) + 2);
            char16_t *thisEnd = (((ap - (int32_t)(count)) + (int32_t)(valueLen)) - 2);
            while((ap != thisEnd)) {
                for(int32_t i = 0; (i < valueLen); i++){
                    if(((int32_t)(Char::ToUpperInvariant((*(ap + i)))) != (int32_t)(Char::ToUpperInvariant((*(valueptr + i)))))) 
                    {
                        goto NextVal;
                    }
                }
                return (int32_t)(ap - thisptr);
                NextVal:
                ap--;
            }
        }
        return -1;
    }
    
    int32_t String::IndexOf4(char16_t value) {
        if((this->length ==  0)) 
        {
            return -1;
        }
        return IndexOfUnchecked(value, 0, this->length);
    }
    
    int32_t String::IndexOf5(char16_t value, int32_t startIndex) {
        if((startIndex < 0)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("startIndex"), _T("< 0"));
        }
        if((startIndex > this->length)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("startIndex"), _T("startIndex > this.length"));
        }
        if((((startIndex ==  0) && (this->length ==  0)) || (startIndex ==  this->length))) 
        {
            return -1;
        }
        return IndexOfUnchecked(value, startIndex, (this->length - startIndex));
    }
    
    int32_t String::IndexOf6(char16_t value, int32_t startIndex, int32_t count) {
        if(((startIndex < 0) || (startIndex > this->length))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("startIndex"), _T("Cannot be negative and must be< 0"));
        }
        if((count < 0)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("count"), _T("< 0"));
        }
        if((startIndex > (this->length - count))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("count"), _T("startIndex + count > this.length"));
        }
        if(((((startIndex ==  0) && (this->length ==  0)) || (startIndex ==  this->length)) || (count ==  0))) 
        {
            return -1;
        }
        return IndexOfUnchecked(value, startIndex, count);
    }
    
    int32_t String::IndexOfUnchecked(char16_t value, int32_t startIndex, int32_t count) {
        int32_t value_32 = (int32_t)(value);
        {
            /* FIXED - BLOCK */
            char16_t* start = cli::fixed_guard(&(this->start_char));
            char16_t *ptr = (start + (int32_t)(startIndex));
            char16_t *end_ptr = (ptr + (int32_t)(((count >> 3) << 3)));
            while((ptr != end_ptr)) {
                if(((int32_t)((*ptr)) ==  value_32)) 
                {
                    return (int32_t)(ptr - start);
                }
                if(((int32_t)((*(ptr + 2))) ==  value_32)) 
                {
                    return (int32_t)((ptr - start) + 1L);
                }
                if(((int32_t)((*(ptr + 4))) ==  value_32)) 
                {
                    return (int32_t)((ptr - start) + 2L);
                }
                if(((int32_t)((*(ptr + 6))) ==  value_32)) 
                {
                    return (int32_t)((ptr - start) + 3L);
                }
                if(((int32_t)((*(ptr + 8))) ==  value_32)) 
                {
                    return (int32_t)((ptr - start) + 4L);
                }
                if(((int32_t)((*(ptr + 10))) ==  value_32)) 
                {
                    return (int32_t)((ptr - start) + 5L);
                }
                if(((int32_t)((*(ptr + 12))) ==  value_32)) 
                {
                    return (int32_t)((ptr - start) + 6L);
                }
                if(((int32_t)((*(ptr + 14))) ==  value_32)) 
                {
                    return (int32_t)((ptr - start) + 7L);
                }
                (ptr = (ptr += 16));
            }
            (end_ptr = (end_ptr += (int32_t)((count & 7))));
            while((ptr != end_ptr)) {
                if(((int32_t)((*ptr)) ==  value_32)) 
                {
                    return (int32_t)(ptr - start);
                }
                ptr++;
            }
            return -1;
        }
    }
    
    int32_t String::IndexOfOrdinalIgnoreCase(char16_t value, int32_t startIndex, int32_t count) {
        if((this->length ==  0)) 
        {
            return -1;
        }
        int32_t end = (startIndex + count);
        char16_t c = Char::ToUpperInvariant(value);
        {
            /* FIXED - BLOCK */
            char16_t* s = cli::fixed_guard(&(this->start_char));
            for(int32_t i = startIndex; (i < end); i++) {
                if(((int32_t)(Char::ToUpperInvariant((*(s + i)))) ==  (int32_t)(c))) 
                {
                    return i;
                }
            }
        }
        return -1;
    }
    
    int32_t String::IndexOf7(String* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("value"));
        }
        if((value->length ==  0)) 
        {
            return 0;
        }
        if((this->length ==  0)) 
        {
            return -1;
        }
        return Globalization::CultureInfo::get_CurrentCulture()->get_CompareInfo_ef6e4d0bc469f6a()->IndexOf_434caa895db2be65(this, value, 0, this->length, Globalization::CompareOptions::Ordinal);
    }
    
    int32_t String::IndexOf8(String* value, int32_t startIndex) {
        return IndexOf9(value, startIndex, (this->length - startIndex));
    }
    
    int32_t String::IndexOf9(String* value, int32_t startIndex, int32_t count) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("value"));
        }
        if(((startIndex < 0) || (startIndex > this->length))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("startIndex"), _T("Cannot be negative, and should not exceed length of string."));
        }
        if(((count < 0) || (startIndex > (this->length - count)))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("count"), _T("Cannot be negative, and should point to location in string."));
        }
        if((value->length ==  0)) 
        {
            return startIndex;
        }
        if(((startIndex ==  0) && (this->length ==  0))) 
        {
            return -1;
        }
        if((count ==  0)) 
        {
            return -1;
        }
        return Globalization::CultureInfo::get_CurrentCulture()->get_CompareInfo_ef6e4d0bc469f6a()->IndexOf_b74a781533c8ed6d(this, value, startIndex, count);
    }
    
    int32_t String::LastIndexOfAny(cli::array<char16_t>* anyOf) {
        if((anyOf ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>();
        }
        if((this->length ==  0)) 
        {
            return -1;
        }
        return LastIndexOfAnyUnchecked(anyOf, (this->length - 1), this->length);
    }
    
    int32_t String::LastIndexOfAny2(cli::array<char16_t>* anyOf, int32_t startIndex) {
        if((anyOf ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>();
        }
        if((this->length ==  0)) 
        {
            return -1;
        }
        if(((startIndex < 0) || (startIndex >= this->length))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("startIndex"), _T("Cannot be negative, and should be less than length of string."));
        }
        if((this->length ==  0)) 
        {
            return -1;
        }
        return LastIndexOfAnyUnchecked(anyOf, startIndex, (startIndex + 1));
    }
    
    int32_t String::LastIndexOfAny3(cli::array<char16_t>* anyOf, int32_t startIndex, int32_t count) {
        if((anyOf ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>();
        }
        if((this->length ==  0)) 
        {
            return -1;
        }
        if(((startIndex < 0) || (startIndex >= this->get_Length()))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("startIndex"), _T("< 0 || > this.Length"));
        }
        if(((count < 0) || (count > this->get_Length()))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("count"), _T("< 0 || > this.Length"));
        }
        if((((startIndex - count) + 1) < 0)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("startIndex - count + 1 < 0"));
        }
        if((this->length ==  0)) 
        {
            return -1;
        }
        return LastIndexOfAnyUnchecked(anyOf, startIndex, count);
    }
    
    int32_t String::LastIndexOfAnyUnchecked(cli::array<char16_t>* anyOf, int32_t startIndex, int32_t count) {
        if((anyOf->get_Length() ==  1)) 
        {
            return LastIndexOfUnchecked(anyOf->at(0), startIndex, count);
        }
        {
            /* FIXED - BLOCK */
            char16_t* start = cli::fixed_guard(this);
            char16_t* testStart = cli::fixed_guard(((anyOf ==  nullptr) || (anyOf->get_Length() ==  0)) ? nullptr : anyOf);
            char16_t *ptr = (start + (int32_t)(startIndex));
            char16_t *ptrEnd = (ptr - (int32_t)(count));
            char16_t *test;
            char16_t *testEnd = (testStart + (int32_t)(anyOf->get_Length()));
            while((ptr != ptrEnd)) {
                test = testStart;
                while((test != testEnd)) {
                    if(((int32_t)((*test)) ==  (int32_t)((*ptr)))) 
                    {
                        return (int32_t)(ptr - start);
                    }
                    test++;
                }
                ptr--;
            }
            return -1;
        }
    }
    
    int32_t String::LastIndexOf4(char16_t value) {
        if((this->length ==  0)) 
        {
            return -1;
        }
        return LastIndexOfUnchecked(value, (this->length - 1), this->length);
    }
    
    int32_t String::LastIndexOf5(char16_t value, int32_t startIndex) {
        return LastIndexOf6(value, startIndex, (startIndex + 1));
    }
    
    int32_t String::LastIndexOf6(char16_t value, int32_t startIndex, int32_t count) {
        if((this->length ==  0)) 
        {
            return -1;
        }
        if(((startIndex < 0) || (startIndex >= this->get_Length()))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("startIndex"), _T("< 0 || >= this.Length"));
        }
        if(((count < 0) || (count > this->get_Length()))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("count"), _T("< 0 || > this.Length"));
        }
        if((((startIndex - count) + 1) < 0)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("startIndex - count + 1 < 0"));
        }
        return LastIndexOfUnchecked(value, startIndex, count);
    }
    
    int32_t String::LastIndexOfUnchecked(char16_t value, int32_t startIndex, int32_t count) {
        int32_t value_32 = (int32_t)(value);
        {
            /* FIXED - BLOCK */
            char16_t* start = cli::fixed_guard(&(this->start_char));
            char16_t *ptr = (start + (int32_t)(startIndex));
            char16_t *end_ptr = (ptr - (int32_t)(((count >> 3) << 3)));
            while((ptr != end_ptr)) {
                if(((int32_t)((*ptr)) ==  value_32)) 
                {
                    return (int32_t)(ptr - start);
                }
                if(((int32_t)((*(ptr + -2))) ==  value_32)) 
                {
                    return ((int32_t)(ptr - start) - 1);
                }
                if(((int32_t)((*(ptr + -4))) ==  value_32)) 
                {
                    return ((int32_t)(ptr - start) - 2);
                }
                if(((int32_t)((*(ptr + -6))) ==  value_32)) 
                {
                    return ((int32_t)(ptr - start) - 3);
                }
                if(((int32_t)((*(ptr + -8))) ==  value_32)) 
                {
                    return ((int32_t)(ptr - start) - 4);
                }
                if(((int32_t)((*(ptr + -10))) ==  value_32)) 
                {
                    return ((int32_t)(ptr - start) - 5);
                }
                if(((int32_t)((*(ptr + -12))) ==  value_32)) 
                {
                    return ((int32_t)(ptr - start) - 6);
                }
                if(((int32_t)((*(ptr + -14))) ==  value_32)) 
                {
                    return ((int32_t)(ptr - start) - 7);
                }
                (ptr = (ptr -= 16));
            }
            (end_ptr = (end_ptr -= (int32_t)((count & 7))));
            while((ptr != end_ptr)) {
                if(((int32_t)((*ptr)) ==  value_32)) 
                {
                    return (int32_t)(ptr - start);
                }
                ptr--;
            }
            return -1;
        }
    }
    
    int32_t String::LastIndexOfOrdinalIgnoreCase(char16_t value, int32_t startIndex, int32_t count) {
        if((this->length ==  0)) 
        {
            return -1;
        }
        int32_t end = (startIndex - count);
        char16_t c = Char::ToUpperInvariant(value);
        {
            /* FIXED - BLOCK */
            char16_t* s = cli::fixed_guard(&(this->start_char));
            for(int32_t i = startIndex; (i > end); i--) {
                if(((int32_t)(Char::ToUpperInvariant((*(s + i)))) ==  (int32_t)(c))) 
                {
                    return i;
                }
            }
        }
        return -1;
    }
    
    int32_t String::LastIndexOf7(String* value) {
        return LastIndexOf9(value, (this->length - 1), this->length);
    }
    
    int32_t String::LastIndexOf8(String* value, int32_t startIndex) {
        int32_t max = startIndex;
        if((max < this->get_Length())) 
        {
            max++;
        }
        return LastIndexOf9(value, startIndex, max);
    }
    
    int32_t String::LastIndexOf9(String* value, int32_t startIndex, int32_t count) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("value"));
        }
        if((this->length ==  0)) 
        {
            return (value->get_Length() ==  0) ? 0 : -1;
        }
        if(((startIndex < -1) || (startIndex > this->get_Length()))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("startIndex"), _T("< 0 || > this.Length"));
        }
        if(((count < 0) || (count > this->get_Length()))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("count"), _T("< 0 || > this.Length"));
        }
        if((((startIndex - count) + 1) < 0)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("startIndex - count + 1 < 0"));
        }
        if((value->get_Length() ==  0)) 
        {
            return Math::Min5((this->get_Length() - 1), startIndex);
        }
        if(((startIndex ==  0) && (this->length ==  0))) 
        {
            return -1;
        }
        if(((this->length ==  0) && (value->length > 0))) 
        {
            return -1;
        }
        if((count ==  0)) 
        {
            return -1;
        }
        if((startIndex ==  this->get_Length())) 
        {
            startIndex--;
        }
        return Globalization::CultureInfo::get_CurrentCulture()->get_CompareInfo_ef6e4d0bc469f6a()->LastIndexOf_5c1e773a5b209242(this, value, startIndex, count);
    }
    
    bool String::Contains(String* value) {
        return (IndexOf7(value) != -1);
    }
    
    bool String::IsNullOrEmpty(String* value) {
        return ((value ==  nullptr) || (value->get_Length() ==  0));
    }
    
    String* String::Normalize() {
        return Mono::Globalization::Unicode::Normalization::Normalize(this, 0);
    }
    
    String* String::Normalize2(Text::NormalizationForm normalizationForm) {
        switch(normalizationForm) {
            default: case_837: {
                return Mono::Globalization::Unicode::Normalization::Normalize(this, 0);
            }
            case Text::NormalizationForm::FormD: case_838: {
                return Mono::Globalization::Unicode::Normalization::Normalize(this, 1);
            }
            case Text::NormalizationForm::FormKC: case_839: {
                return Mono::Globalization::Unicode::Normalization::Normalize(this, 2);
            }
            case Text::NormalizationForm::FormKD: case_840: {
                return Mono::Globalization::Unicode::Normalization::Normalize(this, 3);
            }
        }
    }
    
    bool String::IsNormalized() {
        return Mono::Globalization::Unicode::Normalization::IsNormalized(this, 0);
    }
    
    bool String::IsNormalized2(Text::NormalizationForm normalizationForm) {
        switch(normalizationForm) {
            default: case_841: {
                return Mono::Globalization::Unicode::Normalization::IsNormalized(this, 0);
            }
            case Text::NormalizationForm::FormD: case_842: {
                return Mono::Globalization::Unicode::Normalization::IsNormalized(this, 1);
            }
            case Text::NormalizationForm::FormKC: case_843: {
                return Mono::Globalization::Unicode::Normalization::IsNormalized(this, 2);
            }
            case Text::NormalizationForm::FormKD: case_844: {
                return Mono::Globalization::Unicode::Normalization::IsNormalized(this, 3);
            }
        }
    }
    
    String* String::Remove(int32_t startIndex) {
        if((startIndex < 0)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("startIndex"), _T("StartIndex can not be less than zero"));
        }
        if((startIndex >= this->length)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("startIndex"), _T("StartIndex must be less than the length of the string"));
        }
        return Remove2(startIndex, (this->length - startIndex));
    }
    
    String* String::PadLeft(int32_t totalWidth) {
        return PadLeft2(totalWidth, u' ');
    }
    
    String* String::PadLeft2(int32_t totalWidth, char16_t paddingChar) {
        if((totalWidth < 0)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("totalWidth"), _T("< 0"));
        }
        if((totalWidth < this->length)) 
        {
            return this;
        }
        if((totalWidth ==  0)) 
        {
            return Empty;
        }
        String *tmp = InternalAllocateStr(totalWidth);
        {
            /* FIXED - BLOCK */
            char16_t* dest = cli::fixed_guard(tmp);
            char16_t* src = cli::fixed_guard(this);
            char16_t *padPos = dest;
            char16_t *padTo = (dest + (int32_t)((totalWidth - this->length)));
            while((padPos != padTo)) (*padPos++) = paddingChar;
            CharCopy(padTo, src, this->length);
        }
        return tmp;
    }
    
    String* String::PadRight(int32_t totalWidth) {
        return PadRight2(totalWidth, u' ');
    }
    
    String* String::PadRight2(int32_t totalWidth, char16_t paddingChar) {
        if((totalWidth < 0)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("totalWidth"), _T("< 0"));
        }
        if((totalWidth < this->length)) 
        {
            return this;
        }
        if((totalWidth ==  0)) 
        {
            return Empty;
        }
        String *tmp = InternalAllocateStr(totalWidth);
        {
            /* FIXED - BLOCK */
            char16_t* dest = cli::fixed_guard(tmp);
            char16_t* src = cli::fixed_guard(this);
            CharCopy(dest, src, this->length);
            char16_t *padPos = (dest + (int32_t)(this->length));
            char16_t *padTo = (dest + (int32_t)(totalWidth));
            while((padPos != padTo)) (*padPos++) = paddingChar;
        }
        return tmp;
    }
    
    bool String::StartsWith(String* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("value"));
        }
        return Globalization::CultureInfo::get_CurrentCulture()->get_CompareInfo_ef6e4d0bc469f6a()->IsPrefix_5175c6f6b5c36f0a(this, value, Globalization::CompareOptions::None);
    }
    
    bool String::StartsWith2(String* value, StringComparison comparisonType) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("value"));
        }
        switch(comparisonType) {
            case StringComparison::CurrentCulture: case_845: {
                return Globalization::CultureInfo::get_CurrentCulture()->get_CompareInfo_ef6e4d0bc469f6a()->IsPrefix_5175c6f6b5c36f0a(this, value, Globalization::CompareOptions::None);
            }
            case StringComparison::CurrentCultureIgnoreCase: case_846: {
                return Globalization::CultureInfo::get_CurrentCulture()->get_CompareInfo_ef6e4d0bc469f6a()->IsPrefix_5175c6f6b5c36f0a(this, value, Globalization::CompareOptions::IgnoreCase);
            }
            case StringComparison::InvariantCulture: case_847: {
                return Globalization::CultureInfo::get_InvariantCulture()->get_CompareInfo_ef6e4d0bc469f6a()->IsPrefix_5175c6f6b5c36f0a(this, value, Globalization::CompareOptions::None);
            }
            case StringComparison::InvariantCultureIgnoreCase: case_848: {
                return Globalization::CultureInfo::get_InvariantCulture()->get_CompareInfo_ef6e4d0bc469f6a()->IsPrefix_5175c6f6b5c36f0a(this, value, Globalization::CompareOptions::IgnoreCase);
            }
            case StringComparison::Ordinal: case_849: {
                return Globalization::CultureInfo::get_CurrentCulture()->get_CompareInfo_ef6e4d0bc469f6a()->IsPrefix_5175c6f6b5c36f0a(this, value, Globalization::CompareOptions::Ordinal);
            }
            case StringComparison::OrdinalIgnoreCase: case_850: {
                return Globalization::CultureInfo::get_CurrentCulture()->get_CompareInfo_ef6e4d0bc469f6a()->IsPrefix_5175c6f6b5c36f0a(this, value, Globalization::CompareOptions::OrdinalIgnoreCase);
            }
            default: case_851: {
                String *msg = Locale::GetText2(_T("Invalid value \'{0}\' for StringComparison"), (new cli::array<Object*>({cli::box(comparisonType)})));
                throw cli::gcnew<ArgumentException>(msg, _T("comparisonType"));
            }
        }
    }
    
    bool String::EndsWith3(String* value, StringComparison comparisonType) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("value"));
        }
        switch(comparisonType) {
            case StringComparison::CurrentCulture: case_852: {
                return Globalization::CultureInfo::get_CurrentCulture()->get_CompareInfo_ef6e4d0bc469f6a()->IsSuffix_aee4ee93cc1fc6d(this, value, Globalization::CompareOptions::None);
            }
            case StringComparison::CurrentCultureIgnoreCase: case_853: {
                return Globalization::CultureInfo::get_CurrentCulture()->get_CompareInfo_ef6e4d0bc469f6a()->IsSuffix_aee4ee93cc1fc6d(this, value, Globalization::CompareOptions::IgnoreCase);
            }
            case StringComparison::InvariantCulture: case_854: {
                return Globalization::CultureInfo::get_InvariantCulture()->get_CompareInfo_ef6e4d0bc469f6a()->IsSuffix_aee4ee93cc1fc6d(this, value, Globalization::CompareOptions::None);
            }
            case StringComparison::InvariantCultureIgnoreCase: case_855: {
                return Globalization::CultureInfo::get_InvariantCulture()->get_CompareInfo_ef6e4d0bc469f6a()->IsSuffix_aee4ee93cc1fc6d(this, value, Globalization::CompareOptions::IgnoreCase);
            }
            case StringComparison::Ordinal: case_856: {
                return Globalization::CultureInfo::get_CurrentCulture()->get_CompareInfo_ef6e4d0bc469f6a()->IsSuffix_aee4ee93cc1fc6d(this, value, Globalization::CompareOptions::Ordinal);
            }
            case StringComparison::OrdinalIgnoreCase: case_857: {
                return Globalization::CultureInfo::get_CurrentCulture()->get_CompareInfo_ef6e4d0bc469f6a()->IsSuffix_aee4ee93cc1fc6d(this, value, Globalization::CompareOptions::OrdinalIgnoreCase);
            }
            default: case_858: {
                String *msg = Locale::GetText2(_T("Invalid value \'{0}\' for StringComparison"), (new cli::array<Object*>({cli::box(comparisonType)})));
                throw cli::gcnew<ArgumentException>(msg, _T("comparisonType"));
            }
        }
    }
    
    bool String::StartsWith3(String* value, bool ignoreCase, Globalization::CultureInfo* culture) {
        if((culture ==  nullptr)) 
        {
            culture = Globalization::CultureInfo::get_CurrentCulture();
        }
        return culture->get_CompareInfo_ef6e4d0bc469f6a()->IsPrefix_5175c6f6b5c36f0a(this, value, ignoreCase ? Globalization::CompareOptions::IgnoreCase : Globalization::CompareOptions::None);
    }
    
    String* String::Replace(char16_t oldChar, char16_t newChar) {
        if(((this->length ==  0) || ((int32_t)(oldChar) ==  (int32_t)(newChar)))) 
        {
            return this;
        }
        int32_t start_pos = IndexOfUnchecked(oldChar, 0, this->length);
        if((start_pos ==  -1)) 
        {
            return this;
        }
        if((start_pos < 4)) 
        {
            start_pos = 0;
        }
        String *tmp = InternalAllocateStr(this->length);
        {
            /* FIXED - BLOCK */
            char16_t* dest = cli::fixed_guard(tmp);
            char16_t* src = cli::fixed_guard(&(this->start_char));
            if((start_pos != 0)) 
            {
                CharCopy(dest, src, start_pos);
            }
            char16_t *end_ptr = (dest + (int32_t)(this->length));
            char16_t *dest_ptr = (dest + (int32_t)(start_pos));
            char16_t *src_ptr = (src + (int32_t)(start_pos));
            while((dest_ptr != end_ptr)) {
                if(((int32_t)((*src_ptr)) ==  (int32_t)(oldChar))) 
                {
                    (*dest_ptr) = newChar;
                }
                 else 
                {
                    (*dest_ptr) = (*src_ptr);
                }
                ++src_ptr;
                ++dest_ptr;
            }
        }
        return tmp;
    }
    
    String* String::Replace2(String* oldValue, String* newValue) {
        if((oldValue ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("oldValue"));
        }
        if((oldValue->get_Length() ==  0)) 
        {
            throw cli::gcnew<ArgumentException>(_T("oldValue is the empty string."));
        }
        if((this->get_Length() ==  0)) 
        {
            return this;
        }
        if((newValue ==  nullptr)) 
        {
            newValue = Empty;
        }
        return ReplaceUnchecked(oldValue, newValue);
    }
    
    String* String::ReplaceUnchecked(String* oldValue, String* newValue) {
        if((oldValue->length > this->length)) 
        {
            return this;
        }
        if(((oldValue->length ==  1) && (newValue->length ==  1))) 
        {
            return Replace(oldValue->get_Chars(0), newValue->get_Chars(0));
        }
        const int32_t maxValue = 200;
        int32_t dat[200];
        {
            /* FIXED - BLOCK */
            char16_t* source = cli::fixed_guard(this);
            char16_t* replace = cli::fixed_guard(newValue);
            int32_t i = 0, count = 0;
            while((i < this->length)) {
                int32_t found = IndexOfOrdinalUnchecked(oldValue, i, (this->length - i));
                if((found < 0)) 
                {
                    break;
                }
                 else 
                {
                    if((count < 200)) 
                    {
                        (*(dat + count++)) = found;
                    }
                     else 
                    {
                        return ReplaceFallback(oldValue, newValue, 200);
                    }
                }
                i = (found + oldValue->length);
            }
            if((count ==  0)) 
            {
                return this;
            }
            int32_t nlen = (this->length + ((newValue->length - oldValue->length) * count));
            String *tmp = InternalAllocateStr(nlen);
            int32_t curPos = 0, lastReadPos = 0;
            {
                /* FIXED - BLOCK */
                char16_t* dest = cli::fixed_guard(tmp);
                for(int32_t j = 0; (j < count); j++){
                    int32_t precopy = ((*(dat + j)) - lastReadPos);
                    CharCopy((dest + (int32_t)(curPos)), (source + (int32_t)(lastReadPos)), precopy);
                    (curPos = curPos + precopy);
                    lastReadPos = ((*(dat + j)) + oldValue->length);
                    CharCopy((dest + (int32_t)(curPos)), replace, newValue->length);
                    (curPos = curPos + newValue->length);
                }
                CharCopy((dest + (int32_t)(curPos)), (source + (int32_t)(lastReadPos)), (this->length - lastReadPos));
            }
            return tmp;
        }
    }
    
    String* String::ReplaceFallback(String* oldValue, String* newValue, int32_t testedCount) {
        int32_t lengthEstimate = (this->length + ((newValue->length - oldValue->length) * testedCount));
        Text::StringBuilder *sb = cli::gcnew<Text::StringBuilder>(lengthEstimate);
        for(int32_t i = 0; (i < this->length); ){
            int32_t found = IndexOfOrdinalUnchecked(oldValue, i, (this->length - i));
            if((found < 0)) 
            {
                sb->Append2(SubstringUnchecked(i, (this->length - i)));
                break;
            }
            sb->Append2(SubstringUnchecked(i, (found - i)));
            sb->Append2(newValue);
            i = (found + oldValue->get_Length());
        }
        return sb->ToString_1636a0751cb9ac11();
    }
    
    String* String::Remove2(int32_t startIndex, int32_t count) {
        if((startIndex < 0)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("startIndex"), _T("Cannot be negative."));
        }
        if((count < 0)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("count"), _T("Cannot be negative."));
        }
        if((startIndex > (this->length - count))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("count"), _T("startIndex + count > this.length"));
        }
        String *tmp = InternalAllocateStr((this->length - count));
        {
            /* FIXED - BLOCK */
            char16_t* dest = cli::fixed_guard(tmp);
            char16_t* src = cli::fixed_guard(this);
            char16_t *dst = dest;
            CharCopy(dst, src, startIndex);
            int32_t skip = (startIndex + count);
            (dst = (dst += (int32_t)(startIndex)));
            CharCopy(dst, (src + (int32_t)(skip)), (this->length - skip));
        }
        return tmp;
    }
    
    String* String::ToLower() {
        return ToLower2(Globalization::CultureInfo::get_CurrentCulture());
    }
    
    String* String::ToLower2(Globalization::CultureInfo* culture) {
        if((culture ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("culture"));
        }
        if((culture->get_LCID_f4b9bc9d0bf0db86() ==  127)) 
        {
            return ToLowerInvariant();
        }
        return culture->get_TextInfo_63dfa6e5f11a61f0()->ToLower_4a9626b08fd9b34f(this);
    }
    
    String* String::ToLowerInvariant() {
        if((this->length ==  0)) 
        {
            return Empty;
        }
        String *tmp = InternalAllocateStr(this->length);
        {
            /* FIXED - BLOCK */
            char16_t* source = cli::fixed_guard(&(this->start_char));
            char16_t* dest = cli::fixed_guard(tmp);
            char16_t *destPtr = (char16_t*)(dest);
            char16_t *sourcePtr = (char16_t*)(source);
            for(int32_t n = 0; (n < this->length); n++){
                (*destPtr) = Char::ToLowerInvariant((*sourcePtr));
                sourcePtr++;
                destPtr++;
            }
        }
        return tmp;
    }
    
    String* String::ToUpper() {
        return ToUpper2(Globalization::CultureInfo::get_CurrentCulture());
    }
    
    String* String::ToUpper2(Globalization::CultureInfo* culture) {
        if((culture ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("culture"));
        }
        if((culture->get_LCID_f4b9bc9d0bf0db86() ==  127)) 
        {
            return ToUpperInvariant();
        }
        return culture->get_TextInfo_63dfa6e5f11a61f0()->ToUpper_e8666e8cddf53901(this);
    }
    
    String* String::ToUpperInvariant() {
        if((this->length ==  0)) 
        {
            return Empty;
        }
        String *tmp = InternalAllocateStr(this->length);
        {
            /* FIXED - BLOCK */
            char16_t* source = cli::fixed_guard(&(this->start_char));
            char16_t* dest = cli::fixed_guard(tmp);
            char16_t *destPtr = (char16_t*)(dest);
            char16_t *sourcePtr = (char16_t*)(source);
            for(int32_t n = 0; (n < this->length); n++){
                (*destPtr) = Char::ToUpperInvariant((*sourcePtr));
                sourcePtr++;
                destPtr++;
            }
        }
        return tmp;
    }
    
    String* String::ToString_1636a0751cb9ac11() {
        return this;
    }
    
    String* String::ToString3(IFormatProvider* provider) {
        return this;
    }
    
    String* String::Format2(String* format, Object* arg0) {
        return Format6(nullptr, format, (new cli::array<Object*>({arg0})));
    }
    
    String* String::Format3(String* format, Object* arg0, Object* arg1) {
        return Format6(nullptr, format, (new cli::array<Object*>({arg0, arg1})));
    }
    
    String* String::Format4(String* format, Object* arg0, Object* arg1, Object* arg2) {
        return Format6(nullptr, format, (new cli::array<Object*>({arg0, arg1, arg2})));
    }
    
    String* String::Format5(String* format, cli::array<Object*>* args) {
        return Format6(nullptr, format, args);
    }
    
    String* String::Format6(IFormatProvider* provider, String* format, cli::array<Object*>* args) {
        Text::StringBuilder *b = FormatHelper(nullptr, provider, format, args);
        return b->ToString_1636a0751cb9ac11();
    }
    
    Text::StringBuilder* String::FormatHelper(Text::StringBuilder* result, IFormatProvider* provider, String* format, cli::array<Object*>* args) {
        if((format ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("format"));
        }
        if((args ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("args"));
        }
        if((result ==  nullptr)) 
        {
            int32_t i, len;
            len = 0;
            for(i = 0; (i < args->get_Length()); ++i){
                String *s = cli::as<String*>(args->at(i));
                if((s != nullptr)) 
                {
                    (len = len + s->length);
                }
                 else 
                {
                    break;
                }
            }
            if((i ==  args->get_Length())) 
            {
                result = cli::gcnew<Text::StringBuilder>((len + format->length));
            }
             else 
            {
                result = cli::gcnew<Text::StringBuilder>();
            }
        }
        int32_t ptr = 0;
        int32_t start = ptr;
        while((ptr < format->length)) {
            char16_t c = format->get_Chars(ptr++);
            if(((int32_t)(c) ==  123)) 
            {
                result->Append19(format, start, ((ptr - start) - 1));
                if(((int32_t)(format->get_Chars(ptr)) ==  123)) 
                {
                    start = ptr++;
                    continue;
                }
                int32_t n, width;
                bool left_align;
                String *arg_format;
                ParseFormatSpecifier(format, ptr, n, width, left_align, arg_format);
                if((n >= args->get_Length())) 
                {
                    throw cli::gcnew<FormatException>(_T("Index (zero based) must be greater than or equal to zero and less than the size of the argument list."));
                }
                Object *arg = args->at(n);
                String *str;
                ICustomFormatter *formatter = nullptr;
                if((provider != nullptr)) 
                {
                    formatter = cli::as<ICustomFormatter*>(provider->GetFormat_b67414a65453cc7e(cli::typeof<Type>::info));
                }
                if((arg ==  nullptr)) 
                {
                    str = Empty;
                }
                 else 
                {
                    if((formatter != nullptr)) 
                    {
                        str = formatter->Format_5424462033f07fdf(arg_format, arg, provider);
                    }
                     else 
                    {
                        if(cli::is<IFormattable>(arg)) 
                        {
                            str = cli::cast<IFormattable*>(arg)->ToString_91ad8e2580555a25(arg_format, provider);
                        }
                         else 
                        {
                            str = arg->ToString_1636a0751cb9ac11();
                        }
                    }
                }
                if((width > str->length)) 
                {
                    const char16_t padchar = u' ';
                    int32_t padlen = (width - str->length);
                    if(left_align) 
                    {
                        result->Append2(str);
                        result->Append17(u' ', padlen);
                    }
                     else 
                    {
                        result->Append17(u' ', padlen);
                        result->Append2(str);
                    }
                }
                 else 
                {
                    result->Append2(str);
                }
                start = ptr;
            }
             else 
            {
                if(((((int32_t)(c) ==  125) && (ptr < format->length)) && ((int32_t)(format->get_Chars(ptr)) ==  125))) 
                {
                    result->Append19(format, start, ((ptr - start) - 1));
                    start = ptr++;
                }
                 else 
                {
                    if(((int32_t)(c) ==  125)) 
                    {
                        throw cli::gcnew<FormatException>(_T("Input string was not in a correct format."));
                    }
                }
            }
        }
        if((start < format->length)) 
        {
            result->Append19(format, start, (format->get_Length() - start));
        }
        return result;
    }
    
    String* String::Copy(String* str) {
        if((str ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("str"));
        }
        int32_t length = str->length;
        String *tmp = InternalAllocateStr(length);
        if((length != 0)) 
        {
            {
                /* FIXED - BLOCK */
                char16_t* dest = cli::fixed_guard(tmp);
                char16_t* src = cli::fixed_guard(str);
                CharCopy(dest, src, length);
            }
        }
        return tmp;
    }
    
    String* String::Concat(Object* arg0) {
        if((arg0 ==  nullptr)) 
        {
            return Empty;
        }
        return arg0->ToString_1636a0751cb9ac11();
    }
    
    String* String::Concat2(Object* arg0, Object* arg1) {
        return Concat5((arg0 != nullptr) ? arg0->ToString_1636a0751cb9ac11() : nullptr, (arg1 != nullptr) ? arg1->ToString_1636a0751cb9ac11() : nullptr);
    }
    
    String* String::Concat3(Object* arg0, Object* arg1, Object* arg2) {
        String *s1, *s2, *s3;
        if((arg0 ==  nullptr)) 
        {
            s1 = Empty;
        }
         else 
        {
            s1 = arg0->ToString_1636a0751cb9ac11();
        }
        if((arg1 ==  nullptr)) 
        {
            s2 = Empty;
        }
         else 
        {
            s2 = arg1->ToString_1636a0751cb9ac11();
        }
        if((arg2 ==  nullptr)) 
        {
            s3 = Empty;
        }
         else 
        {
            s3 = arg2->ToString_1636a0751cb9ac11();
        }
        return Concat6(s1, s2, s3);
    }
    
    String* String::Concat4(Object* arg0, Object* arg1, Object* arg2, Object* arg3) {
        String *s1, *s2, *s3, *s4;
        if((arg0 ==  nullptr)) 
        {
            s1 = Empty;
        }
         else 
        {
            s1 = arg0->ToString_1636a0751cb9ac11();
        }
        if((arg1 ==  nullptr)) 
        {
            s2 = Empty;
        }
         else 
        {
            s2 = arg1->ToString_1636a0751cb9ac11();
        }
        if((arg2 ==  nullptr)) 
        {
            s3 = Empty;
        }
         else 
        {
            s3 = arg2->ToString_1636a0751cb9ac11();
        }
        ArgIterator iter = cli::ctor<ArgIterator>(__arglist);
        int32_t argCount = iter->GetRemainingCount();
        Text::StringBuilder *sb = cli::gcnew<Text::StringBuilder>();
        if((arg3 != nullptr)) 
        {
            sb->Append2(arg3->ToString_1636a0751cb9ac11());
        }
        for(int32_t i = 0; (i < argCount); i++){
            TypedReference typedRef = iter->GetNextArg();
            sb->Append10(TypedReference::ToObject(typedRef));
        }
        s4 = sb->ToString_1636a0751cb9ac11();
        return Concat7(s1, s2, s3, s4);
    }
    
    String* String::Concat5(String* str0, String* str1) {
        if(((str0 ==  nullptr) || (str0->get_Length() ==  0))) 
        {
            if(((str1 ==  nullptr) || (str1->get_Length() ==  0))) 
            {
                return Empty;
            }
            return str1;
        }
        if(((str1 ==  nullptr) || (str1->get_Length() ==  0))) 
        {
            return str0;
        }
        String *tmp = InternalAllocateStr((str0->length + str1->length));
        {
            /* FIXED - BLOCK */
            char16_t* dest = cli::fixed_guard(tmp);
            char16_t* src = cli::fixed_guard(str0);
            {
                CharCopy(dest, src, str0->length);
            }
        }
        {
            /* FIXED - BLOCK */
            char16_t* dest = cli::fixed_guard(tmp);
            char16_t* src = cli::fixed_guard(str1);
            {
                CharCopy((dest + (int32_t)(str0->get_Length())), src, str1->length);
            }
        }
        return tmp;
    }
    
    String* String::Concat6(String* str0, String* str1, String* str2) {
        if(((str0 ==  nullptr) || (str0->get_Length() ==  0))) 
        {
            if(((str1 ==  nullptr) || (str1->get_Length() ==  0))) 
            {
                if(((str2 ==  nullptr) || (str2->get_Length() ==  0))) 
                {
                    return Empty;
                }
                return str2;
            }
             else 
            {
                if(((str2 ==  nullptr) || (str2->get_Length() ==  0))) 
                {
                    return str1;
                }
            }
            str0 = Empty;
        }
         else 
        {
            if(((str1 ==  nullptr) || (str1->get_Length() ==  0))) 
            {
                if(((str2 ==  nullptr) || (str2->get_Length() ==  0))) 
                {
                    return str0;
                }
                 else 
                {
                    str1 = Empty;
                }
            }
             else 
            {
                if(((str2 ==  nullptr) || (str2->get_Length() ==  0))) 
                {
                    str2 = Empty;
                }
            }
        }
        String *tmp = InternalAllocateStr(((str0->length + str1->length) + str2->length));
        if((str0->get_Length() != 0)) 
        {
            {
                /* FIXED - BLOCK */
                char16_t* dest = cli::fixed_guard(tmp);
                char16_t* src = cli::fixed_guard(str0);
                CharCopy(dest, src, str0->length);
            }
        }
        if((str1->get_Length() != 0)) 
        {
            {
                /* FIXED - BLOCK */
                char16_t* dest = cli::fixed_guard(tmp);
                char16_t* src = cli::fixed_guard(str1);
                CharCopy((dest + (int32_t)(str0->get_Length())), src, str1->length);
            }
        }
        if((str2->get_Length() != 0)) 
        {
            {
                /* FIXED - BLOCK */
                char16_t* dest = cli::fixed_guard(tmp);
                char16_t* src = cli::fixed_guard(str2);
                CharCopy(((dest + (int32_t)(str0->get_Length())) + (int32_t)(str1->get_Length())), src, str2->length);
            }
        }
        return tmp;
    }
    
    String* String::Concat7(String* str0, String* str1, String* str2, String* str3) {
        if(((((str0 ==  nullptr) && (str1 ==  nullptr)) && (str2 ==  nullptr)) && (str3 ==  nullptr))) 
        {
            return Empty;
        }
        if((str0 ==  nullptr)) 
        {
            str0 = Empty;
        }
        if((str1 ==  nullptr)) 
        {
            str1 = Empty;
        }
        if((str2 ==  nullptr)) 
        {
            str2 = Empty;
        }
        if((str3 ==  nullptr)) 
        {
            str3 = Empty;
        }
        String *tmp = InternalAllocateStr((((str0->length + str1->length) + str2->length) + str3->length));
        if((str0->get_Length() != 0)) 
        {
            {
                /* FIXED - BLOCK */
                char16_t* dest = cli::fixed_guard(tmp);
                char16_t* src = cli::fixed_guard(str0);
                CharCopy(dest, src, str0->length);
            }
        }
        if((str1->get_Length() != 0)) 
        {
            {
                /* FIXED - BLOCK */
                char16_t* dest = cli::fixed_guard(tmp);
                char16_t* src = cli::fixed_guard(str1);
                CharCopy((dest + (int32_t)(str0->get_Length())), src, str1->length);
            }
        }
        if((str2->get_Length() != 0)) 
        {
            {
                /* FIXED - BLOCK */
                char16_t* dest = cli::fixed_guard(tmp);
                char16_t* src = cli::fixed_guard(str2);
                CharCopy(((dest + (int32_t)(str0->get_Length())) + (int32_t)(str1->get_Length())), src, str2->length);
            }
        }
        if((str3->get_Length() != 0)) 
        {
            {
                /* FIXED - BLOCK */
                char16_t* dest = cli::fixed_guard(tmp);
                char16_t* src = cli::fixed_guard(str3);
                CharCopy((((dest + (int32_t)(str0->get_Length())) + (int32_t)(str1->get_Length())) + (int32_t)(str2->get_Length())), src, str3->length);
            }
        }
        return tmp;
    }
    
    String* String::Concat8(cli::array<Object*>* args) {
        if((args ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("args"));
        }
        int32_t argLen = args->get_Length();
        if((argLen ==  0)) 
        {
            return Empty;
        }
        cli::array<String*> *strings = (new cli::array<String*>(argLen));
        int32_t len = 0;
        for(int32_t i = 0; (i < argLen); i++){
            if((args->at(i) != nullptr)) 
            {
                strings->at(i) = args->at(i)->ToString_1636a0751cb9ac11();
                (len = len + strings->at(i)->length);
            }
        }
        return ConcatInternal(strings, len);
    }
    
    String* String::Concat9(cli::array<String*>* values) {
        if((values ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("values"));
        }
        int32_t len = 0;
        for(int32_t i = 0; (i < values->get_Length()); i++){
            String *s = values->at(i);
            if((s != nullptr)) 
            {
                (len = len + s->length);
            }
        }
        return ConcatInternal(values, len);
    }
    
    String* String::ConcatInternal(cli::array<String*>* values, int32_t length) {
        if((length ==  0)) 
        {
            return Empty;
        }
        String *tmp = InternalAllocateStr(length);
        {
            /* FIXED - BLOCK */
            char16_t* dest = cli::fixed_guard(tmp);
            int32_t pos = 0;
            for(int32_t i = 0; (i < values->get_Length()); i++){
                String *source = values->at(i);
                if((source != nullptr)) 
                {
                    {
                        /* FIXED - BLOCK */
                        char16_t* src = cli::fixed_guard(source);
                        CharCopy((dest + (int32_t)(pos)), src, source->length);
                    }
                    (pos = pos + source->get_Length());
                }
            }
        }
        return tmp;
    }
    
    String* String::Insert(int32_t startIndex, String* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("value"));
        }
        if(((startIndex < 0) || (startIndex > this->length))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("startIndex"), _T("Cannot be negative and must be less than or equal to length of string."));
        }
        if((value->get_Length() ==  0)) 
        {
            return this;
        }
        if((this->get_Length() ==  0)) 
        {
            return value;
        }
        String *tmp = InternalAllocateStr((this->length + value->length));
        {
            /* FIXED - BLOCK */
            char16_t* dest = cli::fixed_guard(tmp);
            char16_t* src = cli::fixed_guard(this);
            char16_t* val = cli::fixed_guard(value);
            char16_t *dst = dest;
            CharCopy(dst, src, startIndex);
            (dst = (dst += (int32_t)(startIndex)));
            CharCopy(dst, val, value->length);
            (dst = (dst += (int32_t)(value->length)));
            CharCopy(dst, (src + (int32_t)(startIndex)), (this->length - startIndex));
        }
        return tmp;
    }
    
    String* String::Intern(String* str) {
        if((str ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("str"));
        }
        return InternalIntern(str);
    }
    
    String* String::IsInterned(String* str) {
        if((str ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("str"));
        }
        return InternalIsInterned(str);
    }
    
    String* String::Join(String* separator, cli::array<String*>* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("value"));
        }
        if((separator ==  nullptr)) 
        {
            separator = Empty;
        }
        return JoinUnchecked(separator, value, 0, value->get_Length());
    }
    
    String* String::Join2(String* separator, cli::array<String*>* value, int32_t startIndex, int32_t count) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("value"));
        }
        if((startIndex < 0)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("startIndex"), _T("< 0"));
        }
        if((count < 0)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("count"), _T("< 0"));
        }
        if((startIndex > (value->get_Length() - count))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("startIndex"), _T("startIndex + count > value.length"));
        }
        if((startIndex ==  value->get_Length())) 
        {
            return Empty;
        }
        if((separator ==  nullptr)) 
        {
            separator = Empty;
        }
        return JoinUnchecked(separator, value, startIndex, count);
    }
    
    String* String::JoinUnchecked(String* separator, cli::array<String*>* value, int32_t startIndex, int32_t count) {
        int32_t length = 0;
        int32_t maxIndex = (startIndex + count);
        for(int32_t i = startIndex; (i < maxIndex); i++){
            String *s = value->at(i);
            if((s != nullptr)) 
            {
                (length = length + s->length);
            }
        }
        (length = length + (separator->length * (count - 1)));
        if((length <= 0)) 
        {
            return Empty;
        }
        String *tmp = InternalAllocateStr(length);
        maxIndex--;
        {
            /* FIXED - BLOCK */
            char16_t* dest = cli::fixed_guard(tmp);
            char16_t* sepsrc = cli::fixed_guard(separator);
            int32_t pos = 0;
            for(int32_t i = startIndex; (i < maxIndex); i++){
                String *source = value->at(i);
                if((source != nullptr)) 
                {
                    if((source->get_Length() > 0)) 
                    {
                        {
                            /* FIXED - BLOCK */
                            char16_t* src = cli::fixed_guard(source);
                            {
                                CharCopy((dest + (int32_t)(pos)), src, source->get_Length());
                            }
                        }
                        (pos = pos + source->get_Length());
                    }
                }
                if((separator->get_Length() > 0)) 
                {
                    CharCopy((dest + (int32_t)(pos)), sepsrc, separator->get_Length());
                    (pos = pos + separator->get_Length());
                }
            }
            String *sourceLast = value->at(maxIndex);
            if((sourceLast != nullptr)) 
            {
                if((sourceLast->get_Length() > 0)) 
                {
                    {
                        /* FIXED - BLOCK */
                        char16_t* src = cli::fixed_guard(sourceLast);
                        {
                            CharCopy((dest + (int32_t)(pos)), src, sourceLast->get_Length());
                        }
                    }
                }
            }
        }
        return tmp;
    }
    
    bool String::ToBoolean(IFormatProvider* provider) {
        return Convert::ToBoolean13(this, provider);
    }
    
    unsigned char String::ToByte(IFormatProvider* provider) {
        return Convert::ToByte13(this, provider);
    }
    
    char16_t String::ToChar(IFormatProvider* provider) {
        return Convert::ToChar13(this, provider);
    }
    
    DateTime String::ToDateTime(IFormatProvider* provider) {
        return Convert::ToDateTime2(this, provider);
    }
    
    Decimal String::ToDecimal(IFormatProvider* provider) {
        return Convert::ToDecimal13(this, provider);
    }
    
    double String::ToDouble(IFormatProvider* provider) {
        return Convert::ToDouble13(this, provider);
    }
    
    int16_t String::ToInt16(IFormatProvider* provider) {
        return Convert::ToInt1613(this, provider);
    }
    
    int32_t String::ToInt32(IFormatProvider* provider) {
        return Convert::ToInt3213(this, provider);
    }
    
    int64_t String::ToInt64(IFormatProvider* provider) {
        return Convert::ToInt6413(this, provider);
    }
    
    signed char String::ToSByte(IFormatProvider* provider) {
        return Convert::ToSByte13(this, provider);
    }
    
    float String::ToSingle(IFormatProvider* provider) {
        return Convert::ToSingle13(this, provider);
    }
    
    Object* String::ToType(Type* targetType, IFormatProvider* provider) {
        if(Type::op_Equality2(targetType, nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("type"));
        }
        return Convert::ToType(this, targetType, provider, false);
    }
    
    uint16_t String::ToUInt16(IFormatProvider* provider) {
        return Convert::ToUInt1613(this, provider);
    }
    
    uint32_t String::ToUInt32(IFormatProvider* provider) {
        return Convert::ToUInt3213(this, provider);
    }
    
    uint64_t String::ToUInt64(IFormatProvider* provider) {
        return Convert::ToUInt6413(this, provider);
    }
    
    CharEnumerator* String::GetEnumerator() {
        return cli::gcnew<CharEnumerator>(this);
    }
    
    Collections::Generic::IEnumerator2<char16_t>* String::GetEnumerator2() {
        return cli::gcnew<CharEnumerator>(this);
    }
    
    Collections::IEnumerator* String::GetEnumerator3() {
        return cli::gcnew<CharEnumerator>(this);
    }
    
    void String::ParseFormatSpecifier(String* str, int32_t ptr, int32_t n, int32_t width, bool left_align, String* format) {
        int32_t max = str->get_Length();
        n = ParseDecimal(str, ptr);
        if((n < 0)) 
        {
            throw cli::gcnew<FormatException>(_T("Input string was not in a correct format."));
        }
        if(((ptr < max) && ((int32_t)(str->get_Chars(ptr)) ==  44))) 
        {
            ++ptr;
            while(((ptr < max) && Char::IsWhiteSpace(str->get_Chars(ptr)))) ++ptr;
            int32_t start = ptr;
            format = str->Substring2(start, (ptr - start));
            left_align = ((ptr < max) && ((int32_t)(str->get_Chars(ptr)) ==  45));
            if(left_align) 
            {
                ++ptr;
            }
            width = ParseDecimal(str, ptr);
            if((width < 0)) 
            {
                throw cli::gcnew<FormatException>(_T("Input string was not in a correct format."));
            }
        }
         else 
        {
            width = 0;
            left_align = false;
            format = Empty;
        }
        if(((ptr < max) && ((int32_t)(str->get_Chars(ptr)) ==  58))) 
        {
            int32_t start = ++ptr;
            while(((ptr < max) && ((int32_t)(str->get_Chars(ptr)) != 125))) ++ptr;
            (format = cli::concat(format, str->Substring2(start, (ptr - start))));
        }
         else 
        {
            format = nullptr;
        }
        if(((ptr >= max) || ((int32_t)(str->get_Chars(ptr++)) != 125))) 
        {
            throw cli::gcnew<FormatException>(_T("Input string was not in a correct format."));
        }
    }
    
    int32_t String::ParseDecimal(String* str, int32_t ptr) {
        int32_t p = ptr;
        int32_t n = 0;
        int32_t max = str->get_Length();
        while((p < max)) {
            char16_t c = str->get_Chars(p);
            if((((int32_t)(c) < 48) || (57 < (int32_t)(c)))) 
            {
                break;
            }
            n = (((n * 10) + (int32_t)(c)) - 48);
            ++p;
        }
        if(((p ==  ptr) || (p ==  max))) 
        {
            return -1;
        }
        ptr = p;
        return n;
    }
    
    void String::InternalSetChar(int32_t idx, char16_t val) {
        if(((uint32_t)idx >= (uint32_t)this->get_Length())) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("idx"));
        }
        {
            /* FIXED - BLOCK */
            char16_t* pStr = cli::fixed_guard(&(this->start_char));
            (*(pStr + idx)) = val;
        }
    }
    
    void String::InternalSetLength(int32_t newLength) {
        if((newLength > this->length)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("newLength"), _T("newLength as to be <= length"));
        }
        {
            /* FIXED - BLOCK */
            char16_t* pStr = cli::fixed_guard(&(this->start_char));
            char16_t *p = (pStr + (int32_t)(newLength));
            char16_t *end = (pStr + (int32_t)(this->length));
            while((p < end)) {
                (*(p + 0)) = u'\x0';
                p++;
            }
        }
        this->length = newLength;
    }
    
    int32_t String::GetHashCode_6648aef0f235ee6c() {
        {
            /* FIXED - BLOCK */
            char16_t* c = cli::fixed_guard(this);
            char16_t *cc = c;
            char16_t *end = ((cc + (int32_t)(this->length)) - 2);
            int32_t h = 0;
            for(; (cc < end); (cc = (cc += 4))){
                h = (((h << 5) - h) + (int32_t)((*cc)));
                h = (((h << 5) - h) + (int32_t)((*(cc + 2))));
            }
            ++end;
            if((cc < end)) 
            {
                h = (((h << 5) - h) + (int32_t)((*cc)));
            }
            return h;
        }
    }
    
    String* String::Concat10(Collections::Generic::IEnumerable2<String*>* values) {
        if((values ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("values"));
        }
        Collections::Generic::List<String*> *stringList = cli::gcnew<Collections::Generic::List<String*>>();
        int32_t len = 0;
        for(auto tmp_181 : values) {
            auto v = cli::cast<String*>(tmp_181);
            {
                if((v ==  nullptr)) 
                {
                    continue;
                }
                (len = len + v->get_Length());
                stringList->Add(v);
            }
        }
        return ConcatInternal(stringList->ToArray(), len);
    }
    
    String* String::Join3(String* separator, Collections::Generic::IEnumerable2<String*>* values) {
        if((separator ==  nullptr)) 
        {
            return Concat10(values);
        }
        if((values ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("values"));
        }
        Collections::Generic::List<String*> *stringList = cli::gcnew<Collections::Generic::List<String*>>();
        for(auto tmp_182 : values) {
            auto v = cli::cast<String*>(tmp_182);
            stringList->Add(v);
        }
        return JoinUnchecked(separator, stringList->ToArray(), 0, stringList->get_Count());
    }
    
    String* String::Join4(String* separator, cli::array<Object*>* values) {
        if((separator ==  nullptr)) 
        {
            return Concat8(values);
        }
        if((values ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("values"));
        }
        cli::array<String*> *strCopy = (new cli::array<String*>(values->get_Length()));
        int32_t i = 0;
        for(auto tmp_183 : values) {
            auto v = cli::cast<Object*>(tmp_183);
            strCopy->at(i++) = v->ToString_1636a0751cb9ac11();
        }
        return JoinUnchecked(separator, strCopy, 0, strCopy->get_Length());
    }
    
    bool String::IsNullOrWhiteSpace(String* value) {
        if(((value ==  nullptr) || (value->get_Length() ==  0))) 
        {
            return true;
        }
        for(auto tmp_184 : value) {
            auto c = cli::cast<char16_t>(tmp_184);
            if(!(Char::IsWhiteSpace(c))) 
            {
                return false;
            }
        }
        return true;
    }
    
    int32_t String::GetCaseInsensitiveHashCode() {
        {
            /* FIXED - BLOCK */
            char16_t* c = cli::fixed_guard(this);
            char16_t *cc = c;
            char16_t *end = ((cc + (int32_t)(this->length)) - 2);
            int32_t h = 0;
            for(; (cc < end); (cc = (cc += 4))){
                h = (((h << 5) - h) + (int32_t)(Char::ToUpperInvariant((*cc))));
                h = (((h << 5) - h) + (int32_t)(Char::ToUpperInvariant((*(cc + 2)))));
            }
            ++end;
            if((cc < end)) 
            {
                h = (((h << 5) - h) + (int32_t)(Char::ToUpperInvariant((*cc))));
            }
            return h;
        }
    }
    
    String* String::CreateString(signed char* value) {
        if((value ==  nullptr)) 
        {
            return Empty;
        }
        unsigned char *bytes = (unsigned char*)(value);
        int32_t length = 0;
        try {
            while(((int32_t)((*(bytes++ + 0))) != 0)) length++;
        }
        catch(NullReferenceException*) {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("ptr"), _T("Value does not refer to a valid string."));
        }
        catch(AccessViolationException*) {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("ptr"), _T("Value does not refer to a valid string."));
        }
        return CreateString3(value, 0, length, nullptr);
    }
    
    String* String::CreateString2(signed char* value, int32_t startIndex, int32_t length) {
        return CreateString3(value, startIndex, length, nullptr);
    }
    
    String* String::CreateString3(signed char* value, int32_t startIndex, int32_t length, Text::Encoding* enc) {
        if((length < 0)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("length"), _T("Non-negative number required."));
        }
        if((startIndex < 0)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("startIndex"), _T("Non-negative number required."));
        }
        if(((value + (int32_t)(startIndex)) < value)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("startIndex"), _T("Value, startIndex and length do not refer to a valid string."));
        }
        bool isDefaultEncoding;
        if(isDefaultEncoding = (enc ==  nullptr)) 
        {
            if((value ==  nullptr)) 
            {
                throw cli::gcnew<ArgumentNullException>(_T("value"));
            }
            if((length ==  0)) 
            {
                return Empty;
            }
            enc = Text::Encoding::get_Default();
        }
        cli::array<unsigned char> *bytes = (new cli::array<unsigned char>(length));
        if((length != 0)) 
        {
            /* FIXED - BLOCK */
            unsigned char* bytePtr = cli::fixed_guard(((bytes ==  nullptr) || (bytes->get_Length() ==  0)) ? nullptr : bytes);
            {
                try {
                    memcpy(bytePtr, (unsigned char*)((value + (int32_t)(startIndex))), length);
                }
                catch(NullReferenceException*) {
                    throw cli::gcnew<ArgumentOutOfRangeException>(_T("ptr"), _T("Value, startIndex and length do not refer to a valid string."));
                }
                catch(AccessViolationException*) {
                    if(!(isDefaultEncoding)) 
                    {
                        throw ;
                    }
                    throw cli::gcnew<ArgumentOutOfRangeException>(_T("value"), _T("Value, startIndex and length do not refer to a valid string."));
                }
            }
        }
        return enc->GetString_12d22365648431d7(bytes);
    }
    
    String* String::CreateString4(char16_t* value) {
        if((value ==  nullptr)) 
        {
            return Empty;
        }
        char16_t *p = value;
        int32_t i = 0;
        while(((int32_t)((*p)) != 0)) {
            ++i;
            ++p;
        }
        String *result = InternalAllocateStr(i);
        if((i != 0)) 
        {
            {
                /* FIXED - BLOCK */
                char16_t* dest = cli::fixed_guard(result);
                CharCopy(dest, value, i);
            }
        }
        return result;
    }
    
    String* String::CreateString5(char16_t* value, int32_t startIndex, int32_t length) {
        if((length ==  0)) 
        {
            return Empty;
        }
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("value"));
        }
        if((startIndex < 0)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("startIndex"));
        }
        if((length < 0)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("length"));
        }
        String *result = InternalAllocateStr(length);
        {
            /* FIXED - BLOCK */
            char16_t* dest = cli::fixed_guard(result);
            CharCopy(dest, (value + (int32_t)(startIndex)), length);
        }
        return result;
    }
    
    String* String::CreateString6(cli::array<char16_t>* val, int32_t startIndex, int32_t length) {
        if((val ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("value"));
        }
        if((startIndex < 0)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("startIndex"), _T("Cannot be negative."));
        }
        if((length < 0)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("length"), _T("Cannot be negative."));
        }
        if((startIndex > (val->get_Length() - length))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("startIndex"), _T("Cannot be negative, and should be less than length of string."));
        }
        if((length ==  0)) 
        {
            return Empty;
        }
        String *result = InternalAllocateStr(length);
        {
            /* FIXED - BLOCK */
            char16_t* dest = cli::fixed_guard(result);
            char16_t* src = cli::fixed_guard(((val ==  nullptr) || (val->get_Length() ==  0)) ? nullptr : val);
            CharCopy(dest, (src + (int32_t)(startIndex)), length);
        }
        return result;
    }
    
    String* String::CreateString7(cli::array<char16_t>* val) {
        if(((val ==  nullptr) || (val->get_Length() ==  0))) 
        {
            return Empty;
        }
        String *result = InternalAllocateStr(val->get_Length());
        {
            /* FIXED - BLOCK */
            char16_t* dest = cli::fixed_guard(result);
            char16_t* src = cli::fixed_guard(((val ==  nullptr) || (val->get_Length() ==  0)) ? nullptr : val);
            CharCopy(dest, src, val->get_Length());
        }
        return result;
    }
    
    String* String::CreateString8(char16_t c, int32_t count) {
        if((count < 0)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("count"));
        }
        if((count ==  0)) 
        {
            return Empty;
        }
        String *result = InternalAllocateStr(count);
        {
            /* FIXED - BLOCK */
            char16_t* dest = cli::fixed_guard(result);
            char16_t *p = dest;
            char16_t *end = (p + (int32_t)(count));
            while((p < end)) {
                (*p) = c;
                p++;
            }
        }
        return result;
    }
    
    void String::memset(unsigned char* dest, int32_t val, int32_t len) {
        if((len < 8)) 
        {
            while((len != 0)) {
                (*dest) = (unsigned char)val;
                ++dest;
                --len;
            }
            return;
        }
        if((val != 0)) 
        {
            val = (val | (val << 8));
            val = (val | (val << 16));
        }
        int32_t rest = (int32_t)((int64_t)dest & 3L);
        if((rest != 0)) 
        {
            rest = (4 - rest);
            (len = len - rest);
            do {
                (*dest) = (unsigned char)val;
                ++dest;
                --rest;
            }
            while((rest != 0));
        }
        while((len >= 16)) {
            (*((int32_t*)(dest) + 0)) = val;
            (*((int32_t*)(dest) + 4)) = val;
            (*((int32_t*)(dest) + 8)) = val;
            (*((int32_t*)(dest) + 12)) = val;
            (dest = (dest += 16));
            (len = len - 16);
        }
        while((len >= 4)) {
            (*((int32_t*)(dest) + 0)) = val;
            (dest = (dest += 4));
            (len = len - 4);
        }
        while((len > 0)) {
            (*dest) = (unsigned char)val;
            dest++;
            len--;
        }
    }
    
    void String::memcpy4(unsigned char* dest, unsigned char* src, int32_t size) {
        while((size >= 16)) {
            (*((int32_t*)(dest) + 0)) = (*((int32_t*)(src) + 0));
            (*((int32_t*)(dest) + 4)) = (*((int32_t*)(src) + 4));
            (*((int32_t*)(dest) + 8)) = (*((int32_t*)(src) + 8));
            (*((int32_t*)(dest) + 12)) = (*((int32_t*)(src) + 12));
            (dest = (dest += 16));
            (src = (src += 16));
            (size = size - 16);
        }
        while((size >= 4)) {
            (*((int32_t*)(dest) + 0)) = (*((int32_t*)(src) + 0));
            (dest = (dest += 4));
            (src = (src += 4));
            (size = size - 4);
        }
        while((size > 0)) {
            (*((unsigned char*)(dest) + 0)) = (*((unsigned char*)(src) + 0));
            (dest = (dest += 1));
            (src = (src += 1));
            --size;
        }
    }
    
    void String::memcpy2(unsigned char* dest, unsigned char* src, int32_t size) {
        while((size >= 8)) {
            (*((int16_t*)(dest) + 0)) = (*((int16_t*)(src) + 0));
            (*((int16_t*)(dest) + 2)) = (*((int16_t*)(src) + 2));
            (*((int16_t*)(dest) + 4)) = (*((int16_t*)(src) + 4));
            (*((int16_t*)(dest) + 6)) = (*((int16_t*)(src) + 6));
            (dest = (dest += 8));
            (src = (src += 8));
            (size = size - 8);
        }
        while((size >= 2)) {
            (*((int16_t*)(dest) + 0)) = (*((int16_t*)(src) + 0));
            (dest = (dest += 2));
            (src = (src += 2));
            (size = size - 2);
        }
        if((size > 0)) 
        {
            (*((unsigned char*)(dest) + 0)) = (*((unsigned char*)(src) + 0));
        }
    }
    
    void String::memcpy1(unsigned char* dest, unsigned char* src, int32_t size) {
        while((size >= 8)) {
            (*((unsigned char*)(dest) + 0)) = (*((unsigned char*)(src) + 0));
            (*((unsigned char*)(dest) + 1)) = (*((unsigned char*)(src) + 1));
            (*((unsigned char*)(dest) + 2)) = (*((unsigned char*)(src) + 2));
            (*((unsigned char*)(dest) + 3)) = (*((unsigned char*)(src) + 3));
            (*((unsigned char*)(dest) + 4)) = (*((unsigned char*)(src) + 4));
            (*((unsigned char*)(dest) + 5)) = (*((unsigned char*)(src) + 5));
            (*((unsigned char*)(dest) + 6)) = (*((unsigned char*)(src) + 6));
            (*((unsigned char*)(dest) + 7)) = (*((unsigned char*)(src) + 7));
            (dest = (dest += 8));
            (src = (src += 8));
            (size = size - 8);
        }
        while((size >= 2)) {
            (*((unsigned char*)(dest) + 0)) = (*((unsigned char*)(src) + 0));
            (*((unsigned char*)(dest) + 1)) = (*((unsigned char*)(src) + 1));
            (dest = (dest += 2));
            (src = (src += 2));
            (size = size - 2);
        }
        if((size > 0)) 
        {
            (*((unsigned char*)(dest) + 0)) = (*((unsigned char*)(src) + 0));
        }
    }
    
    void String::memcpy(unsigned char* dest, unsigned char* src, int32_t size) {
        if(((((int64_t)dest | (int64_t)src) & 3L) != 0L)) 
        {
            if((((((int64_t)dest & 1L) != 0L) && (((int64_t)src & 1L) != 0L)) && (size >= 1))) 
            {
                (*(dest + 0)) = (*(src + 0));
                ++dest;
                ++src;
                --size;
            }
            if((((((int64_t)dest & 2L) != 0L) && (((int64_t)src & 2L) != 0L)) && (size >= 2))) 
            {
                (*((int16_t*)(dest) + 0)) = (*((int16_t*)(src) + 0));
                (dest = (dest += 2));
                (src = (src += 2));
                (size = size - 2);
            }
            if(((((int64_t)dest | (int64_t)src) & 1L) != 0L)) 
            {
                memcpy1(dest, src, size);
                return;
            }
            if(((((int64_t)dest | (int64_t)src) & 2L) != 0L)) 
            {
                memcpy2(dest, src, size);
                return;
            }
        }
        memcpy4(dest, src, size);
    }
    
    void String::CharCopy(char16_t* dest, char16_t* src, int32_t count) {
        if(((((int64_t)(unsigned char*)(dest) | (int64_t)(unsigned char*)(src)) & 3L) != 0L)) 
        {
            if((((((int64_t)(unsigned char*)(dest) & 2L) != 0L) && (((int64_t)(unsigned char*)(src) & 2L) != 0L)) && (count > 0))) 
            {
                (*((int16_t*)(dest) + 0)) = (*((int16_t*)(src) + 0));
                dest++;
                src++;
                count--;
            }
            if(((((int64_t)(unsigned char*)(dest) | (int64_t)(unsigned char*)(src)) & 2L) != 0L)) 
            {
                memcpy2((unsigned char*)(dest), (unsigned char*)(src), (count * 2));
                return;
            }
        }
        memcpy4((unsigned char*)(dest), (unsigned char*)(src), (count * 2));
    }
    
    void String::CharCopyReverse(char16_t* dest, char16_t* src, int32_t count) {
        (dest = (dest += (int32_t)(count)));
        (src = (src += (int32_t)(count)));
        for(int32_t i = count; (i > 0); i--){
            dest--;
            src--;
            (*dest) = (*src);
        }
    }
    
    void String::CharCopy2(String* target, int32_t targetIndex, String* source, int32_t sourceIndex, int32_t count) {
        {
            /* FIXED - BLOCK */
            char16_t* dest = cli::fixed_guard(target);
            char16_t* src = cli::fixed_guard(source);
            {
                CharCopy((dest + (int32_t)(targetIndex)), (src + (int32_t)(sourceIndex)), count);
            }
        }
    }
    
    void String::CharCopy3(String* target, int32_t targetIndex, cli::array<char16_t>* source, int32_t sourceIndex, int32_t count) {
        {
            /* FIXED - BLOCK */
            char16_t* dest = cli::fixed_guard(target);
            char16_t* src = cli::fixed_guard(((source ==  nullptr) || (source->get_Length() ==  0)) ? nullptr : source);
            {
                CharCopy((dest + (int32_t)(targetIndex)), (src + (int32_t)(sourceIndex)), count);
            }
        }
    }
    
    void String::CharCopyReverse2(String* target, int32_t targetIndex, String* source, int32_t sourceIndex, int32_t count) {
        {
            /* FIXED - BLOCK */
            char16_t* dest = cli::fixed_guard(target);
            char16_t* src = cli::fixed_guard(source);
            {
                CharCopyReverse((dest + (int32_t)(targetIndex)), (src + (int32_t)(sourceIndex)), count);
            }
        }
    }
    
    String* String::InternalAllocateStr(int32_t length) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    String* String::InternalIntern(String* str) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    String* String::InternalIsInterned(String* str) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t String::GetLOSLimit() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool String::op_Equality(String* a, String* b) {
        return Equals3(a, b);
    }
    
    bool String::op_Inequality(String* a, String* b) {
        return !(Equals3(a, b));
    }
    
    char16_t String::get_Chars(int32_t index) {
        if(((index < 0) || (index >= this->length))) 
        {
            throw cli::gcnew<IndexOutOfRangeException>();
        }
        {
            /* FIXED - BLOCK */
            char16_t* c = cli::fixed_guard(&(this->start_char));
            {
                return (*(c + index));
            }
        }
    }
    
    int32_t String::get_Length() {
        return this->length;
    }
    
}
namespace System {
    
    StringComparer*  StringComparer::invariantCultureIgnoreCase;
    StringComparer*  StringComparer::invariantCulture;
    StringComparer*  StringComparer::ordinalIgnoreCase;
    StringComparer*  StringComparer::ordinal;
    
    StringComparer::StringComparer()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void StringComparer::constructor() {
    }
    
    void StringComparer::static_constructor() {
    }
    
    StringComparer* StringComparer::Create(Globalization::CultureInfo* culture, bool ignoreCase) {
        if((culture ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("culture"));
        }
        return cli::gcnew<CultureAwareComparer>(culture, ignoreCase);
    }
    
    int32_t StringComparer::Compare(Object* x, Object* y) {
        if((x ==  y)) 
        {
            return 0;
        }
        if((x ==  nullptr)) 
        {
            return -1;
        }
        if((y ==  nullptr)) 
        {
            return 1;
        }
        String *s_x = cli::as<String*>(x);
        if((s_x != nullptr)) 
        {
            String *s_y = cli::as<String*>(y);
            if((s_y != nullptr)) 
            {
                return Compare_aa3d1bf936762ace(s_x, s_y);
            }
        }
        IComparable *ic = cli::as<IComparable*>(x);
        if((ic ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentException>();
        }
        return ic->CompareTo_ed9d39205b7812f0(y);
    }
    
    bool StringComparer::Equals3(Object* x, Object* y) {
        if((x ==  y)) 
        {
            return true;
        }
        if(((x ==  nullptr) || (y ==  nullptr))) 
        {
            return false;
        }
        String *s_x = cli::as<String*>(x);
        if((s_x != nullptr)) 
        {
            String *s_y = cli::as<String*>(y);
            if((s_y != nullptr)) 
            {
                return Equals_34b0513c0e663568(s_x, s_y);
            }
        }
        return x->Equals_ed975d2f4a7d193e(y);
    }
    
    int32_t StringComparer::GetHashCode2(Object* obj) {
        if((obj ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("obj"));
        }
        String *s = cli::as<String*>(obj);
        return (s ==  nullptr) ? obj->GetHashCode_6648aef0f235ee6c() : GetHashCode_c89a0097b5036ad3(s);
    }
    
    StringComparer* StringComparer::get_CurrentCulture() {
        return cli::gcnew<CultureAwareComparer>(Globalization::CultureInfo::get_CurrentCulture(), false);
    }
    
    StringComparer* StringComparer::get_CurrentCultureIgnoreCase() {
        return cli::gcnew<CultureAwareComparer>(Globalization::CultureInfo::get_CurrentCulture(), true);
    }
    
    StringComparer* StringComparer::get_InvariantCulture() {
        return invariantCulture;
    }
    
    StringComparer* StringComparer::get_InvariantCultureIgnoreCase() {
        return invariantCultureIgnoreCase;
    }
    
    StringComparer* StringComparer::get_Ordinal() {
        return ordinal;
    }
    
    StringComparer* StringComparer::get_OrdinalIgnoreCase() {
        return ordinalIgnoreCase;
    }
    
}
namespace System {
    
    
    void CultureAwareComparer::constructor(Globalization::CultureInfo* ci, bool ignore_case) {
        this->_compareInfo = ci->get_CompareInfo_ef6e4d0bc469f6a();
        this->_ignoreCase = ignore_case;
    }
    
    int32_t CultureAwareComparer::Compare_aa3d1bf936762ace(String* x, String* y) {
        Globalization::CompareOptions co = this->_ignoreCase ? Globalization::CompareOptions::IgnoreCase : Globalization::CompareOptions::None;
        return this->_compareInfo->Compare_272e035d74e81a5d(x, y, co);
    }
    
    bool CultureAwareComparer::Equals_34b0513c0e663568(String* x, String* y) {
        return (Compare_5902559f67a8cefa(x, y) ==  0);
    }
    
    int32_t CultureAwareComparer::GetHashCode_c89a0097b5036ad3(String* s) {
        if((s ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("s"));
        }
        Globalization::CompareOptions co = this->_ignoreCase ? Globalization::CompareOptions::IgnoreCase : Globalization::CompareOptions::None;
        return this->_compareInfo->GetSortKey_250194ddfe99a207(s, co)->GetHashCode_6648aef0f235ee6c();
    }
    
}
namespace System {
    
    
    void OrdinalComparer::constructor(bool ignoreCase) {
        this->_ignoreCase = ignoreCase;
    }
    
    int32_t OrdinalComparer::Compare_aa3d1bf936762ace(String* x, String* y) {
        if(this->_ignoreCase) 
        {
            return String::CompareOrdinalCaseInsensitiveUnchecked(x, 0, 2147483647, y, 0, 2147483647);
        }
         else 
        {
            return String::CompareOrdinalUnchecked(x, 0, 2147483647, y, 0, 2147483647);
        }
    }
    
    bool OrdinalComparer::Equals_34b0513c0e663568(String* x, String* y) {
        if(this->_ignoreCase) 
        {
            return (Compare_5902559f67a8cefa(x, y) ==  0);
        }
        return String::op_Equality(x, y);
    }
    
    int32_t OrdinalComparer::GetHashCode_c89a0097b5036ad3(String* s) {
        if((s ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("s"));
        }
        if(this->_ignoreCase) 
        {
            return s->GetCaseInsensitiveHashCode();
        }
         else 
        {
            return s->GetHashCode_6648aef0f235ee6c();
        }
    }
    
}
namespace System {
    
    
    void SystemException::constructor() {
        this->set_HResult(-2146233087);
    }
    
    void SystemException::constructor(String* message) {
        this->set_HResult(-2146233087);
    }
    
    void SystemException::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
    }
    
    void SystemException::constructor(String* message, Exception* innerException) {
        this->set_HResult(-2146233087);
    }
    
}
namespace System {
    
    int32_t*  TermInfoDriver::native_terminal_size;
    int32_t  TermInfoDriver::terminal_size;
    cli::array<String*>*  TermInfoDriver::locations;
    cli::array<TermInfoStrings>*  TermInfoDriver::UsedKeys;
    
    TermInfoDriver::TermInfoDriver()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void TermInfoDriver::constructor() {
    }
    
    void TermInfoDriver::constructor(String* term) {
        this->term = term;
        if(String::op_Equality(term, _T("xterm"))) 
        {
            this->reader = cli::gcnew<TermInfoReader>(term, KnownTerminals::get_xterm());
            this->color16 = true;
        }
         else 
        {
            if(String::op_Equality(term, _T("linux"))) 
            {
                this->reader = cli::gcnew<TermInfoReader>(term, KnownTerminals::get_linux());
                this->color16 = true;
            }
             else 
            {
                String *filename = SearchTerminfo(term);
                if((filename != nullptr)) 
                {
                    this->reader = cli::gcnew<TermInfoReader>(term, filename);
                }
            }
        }
        if((this->reader ==  nullptr)) 
        {
            this->reader = cli::gcnew<TermInfoReader>(term, KnownTerminals::get_ansi());
        }
        if(!(cli::is<IO::CStreamWriter>(Console::stdout_))) 
        {
            this->stdout_ = cli::gcnew<IO::CStreamWriter>(Console::OpenStandardOutput2(0), Console::get_OutputEncoding());
            cli::cast<IO::StreamWriter*>(this->stdout_)->set_AutoFlush_12a815ad7ffc54a(true);
        }
         else 
        {
            this->stdout_ = cli::cast<IO::CStreamWriter*>(Console::stdout_);
        }
    }
    
    void TermInfoDriver::static_constructor() {
    }
    
    String* TermInfoDriver::SearchTerminfo(String* term) {
        if(((term ==  nullptr) || String::op_Equality(term, String::Empty))) 
        {
            return nullptr;
        }
        for(auto tmp_185 : locations) {
            auto dir = cli::cast<String*>(tmp_185);
            {
                if(!(IO::Directory::Exists(dir))) 
                {
                    continue;
                }
                String *path = IO::Path::Combine(dir, term->Substring2(0, 1));
                if(!(IO::Directory::Exists(dir))) 
                {
                    continue;
                }
                path = IO::Path::Combine(path, term);
                if(!(IO::File::Exists(path))) 
                {
                    continue;
                }
                return path;
            }
        }
        return nullptr;
    }
    
    void TermInfoDriver::WriteConsole(String* str) {
        if((str ==  nullptr)) 
        {
            return;
        }
        this->stdout_->InternalWriteString(str);
    }
    
    void TermInfoDriver::Init() {
        if(this->inited) 
        {
            return;
        }
        {
            cli::lock_guard{this->initLock};
            if(this->inited) 
            {
                return;
            }
            this->inited = true;
            if(!(ConsoleDriver::get_IsConsole())) 
            {
                throw cli::gcnew<IO::IOException>(_T("Not a tty."));
            }
            ConsoleDriver::SetEcho(false);
            String *endString = nullptr;
            this->keypadXmit = this->reader->Get3(TermInfoStrings::KeypadXmit);
            this->keypadLocal = this->reader->Get3(TermInfoStrings::KeypadLocal);
            if((this->keypadXmit != nullptr)) 
            {
                WriteConsole(this->keypadXmit);
                if((this->keypadLocal != nullptr)) 
                {
                    (endString = cli::concat(endString, this->keypadLocal));
                }
            }
            this->origPair = this->reader->Get3(TermInfoStrings::OrigPair);
            this->origColors = this->reader->Get3(TermInfoStrings::OrigColors);
            this->setfgcolor = MangleParameters(this->reader->Get3(TermInfoStrings::SetAForeground));
            this->setbgcolor = MangleParameters(this->reader->Get3(TermInfoStrings::SetABackground));
            this->setlfgcolor = this->color16 ? this->setfgcolor->Replace2(_T("[3"), _T("[9")) : this->setfgcolor;
            this->setlbgcolor = this->color16 ? this->setbgcolor->Replace2(_T("[4"), _T("[10")) : this->setbgcolor;
            String *resetColors = (this->origColors ==  nullptr) ? this->origPair : this->origColors;
            if((resetColors != nullptr)) 
            {
                (endString = cli::concat(endString, resetColors));
            }
            if(!(ConsoleDriver::TtySetup(this->keypadXmit, endString, this->control_characters, native_terminal_size))) 
            {
                this->control_characters = (new cli::array<unsigned char>(17));
                native_terminal_size = nullptr;
            }
            this->stdin_ = cli::gcnew<IO::StreamReader>(Console::OpenStandardInput2(0), Console::get_InputEncoding());
            this->clear = this->reader->Get3(TermInfoStrings::ClearScreen);
            this->bell = this->reader->Get3(TermInfoStrings::Bell);
            if((this->clear ==  nullptr)) 
            {
                this->clear = this->reader->Get3(TermInfoStrings::CursorHome);
                (this->clear = cli::concat(this->clear, this->reader->Get3(TermInfoStrings::ClrEos)));
            }
            this->csrVisible = this->reader->Get3(TermInfoStrings::CursorNormal);
            if((this->csrVisible ==  nullptr)) 
            {
                this->csrVisible = this->reader->Get3(TermInfoStrings::CursorVisible);
            }
            this->csrInvisible = this->reader->Get3(TermInfoStrings::CursorInvisible);
            if(((((String::op_Equality(this->term, _T("cygwin")) || String::op_Equality(this->term, _T("linux"))) || ((this->term != nullptr) && this->term->StartsWith(_T("xterm")))) || String::op_Equality(this->term, _T("rxvt"))) || String::op_Equality(this->term, _T("dtterm")))) 
            {
                this->titleFormat = _T("]0;{0}\a");
            }
             else 
            {
                if(String::op_Equality(this->term, _T("iris-ansi"))) 
                {
                    this->titleFormat = _T("P1.y{0}\\");
                }
                 else 
                {
                    if(String::op_Equality(this->term, _T("sun-cmd"))) 
                    {
                        this->titleFormat = _T("]l{0}\\");
                    }
                }
            }
            this->cursorAddress = this->reader->Get3(TermInfoStrings::CursorAddress);
            if((this->cursorAddress != nullptr)) 
            {
                String *result = this->cursorAddress->Replace2(_T("%i"), String::Empty);
                this->home_1_1 = String::op_Inequality(this->cursorAddress, result);
                this->cursorAddress = MangleParameters(result);
            }
            GetCursorPosition();
            if(this->noGetPosition) 
            {
                WriteConsole(this->clear);
                this->cursorLeft = 0;
                this->cursorTop = 0;
            }
        }
    }
    
    String* TermInfoDriver::MangleParameters(String* str) {
        if((str ==  nullptr)) 
        {
            return nullptr;
        }
        str = str->Replace2(_T("{"), _T("{{"));
        str = str->Replace2(_T("}"), _T("}}"));
        str = str->Replace2(_T("%p1%d"), _T("{0}"));
        return str->Replace2(_T("%p2%d"), _T("{1}"));
    }
    
    int32_t TermInfoDriver::TranslateColor(ConsoleColor desired, bool light) {
        switch(desired) {
            case ConsoleColor::Black: case_859: {
                light = false;
                return 0;
            }
            case ConsoleColor::DarkRed: case_860: {
                light = false;
                return 1;
            }
            case ConsoleColor::DarkGreen: case_861: {
                light = false;
                return 2;
            }
            case ConsoleColor::DarkYellow: case_862: {
                light = false;
                return 3;
            }
            case ConsoleColor::DarkBlue: case_863: {
                light = false;
                return 4;
            }
            case ConsoleColor::DarkMagenta: case_864: {
                light = false;
                return 5;
            }
            case ConsoleColor::DarkCyan: case_865: {
                light = false;
                return 6;
            }
            case ConsoleColor::Gray: case_866: {
                light = false;
                return 7;
            }
            case ConsoleColor::DarkGray: case_867: {
                light = true;
                return 0;
            }
            case ConsoleColor::Red: case_868: {
                light = true;
                return 1;
            }
            case ConsoleColor::Green: case_869: {
                light = true;
                return 2;
            }
            case ConsoleColor::Yellow: case_870: {
                light = true;
                return 3;
            }
            case ConsoleColor::Blue: case_871: {
                light = true;
                return 4;
            }
            case ConsoleColor::Magenta: case_872: {
                light = true;
                return 5;
            }
            case ConsoleColor::Cyan: case_873: {
                light = true;
                return 6;
            }
            case ConsoleColor::White: case_874: {
                light = true;
                return 7;
            }
        }
        light = false;
        return 0;
    }
    
    void TermInfoDriver::IncrementX() {
        this->cursorLeft++;
        if((this->cursorLeft >= this->get_WindowWidth())) 
        {
            this->cursorTop++;
            this->cursorLeft = 0;
            if((this->cursorTop >= this->get_WindowHeight())) 
            {
                if((this->rl_starty != -1)) 
                {
                    this->rl_starty--;
                }
                this->cursorTop--;
            }
        }
    }
    
    void TermInfoDriver::WriteSpecialKey(ConsoleKeyInfo key) {
        switch(key->get_Key()) {
            case ConsoleKey::Backspace: case_875: {
                if((this->cursorLeft > 0)) 
                {
                    if(((this->cursorLeft <= this->rl_startx) && (this->cursorTop ==  this->rl_starty))) 
                    {
                        break;
                    }
                    this->cursorLeft--;
                    SetCursorPosition(this->cursorLeft, this->cursorTop);
                    WriteConsole(_T(" "));
                    SetCursorPosition(this->cursorLeft, this->cursorTop);
                }
                break;
            }
            case ConsoleKey::Tab: case_876: {
                int32_t n = (8 - (this->cursorLeft % 8));
                for(int32_t i = 0; (i < n); i++){
                    IncrementX();
                }
                WriteConsole(_T("\t"));
                break;
            }
            case ConsoleKey::Clear: case_877: {
                WriteConsole(this->clear);
                this->cursorLeft = 0;
                this->cursorTop = 0;
                break;
            }
            case ConsoleKey::Enter: case_878: {
                break;
            }
            default: case_879: {
                break;
            }
        }
    }
    
    void TermInfoDriver::WriteSpecialKey2(char16_t c) {
        WriteSpecialKey(CreateKeyInfoFromInt((int32_t)(c), false));
    }
    
    bool TermInfoDriver::IsSpecialKey(ConsoleKeyInfo key) {
        if(!(this->inited)) 
        {
            return false;
        }
        switch(key->get_Key()) {
            case ConsoleKey::Backspace: case_880: {
                return true;
            }
            case ConsoleKey::Tab: case_881: {
                return true;
            }
            case ConsoleKey::Clear: case_882: {
                return true;
            }
            case ConsoleKey::Enter: case_883: {
                this->cursorLeft = 0;
                this->cursorTop++;
                if((this->cursorTop >= this->get_WindowHeight())) 
                {
                    this->cursorTop--;
                }
                return false;
            }
            default: case_884: {
                IncrementX();
                return false;
            }
        }
    }
    
    bool TermInfoDriver::IsSpecialKey2(char16_t c) {
        return IsSpecialKey(CreateKeyInfoFromInt((int32_t)(c), false));
    }
    
    void TermInfoDriver::GetCursorPosition() {
        int32_t row = 0, col = 0;
        int32_t b;
        int32_t inqueue = ConsoleDriver::InternalKeyAvailable(0);
        while((inqueue-- > 0)) {
            b = this->stdin_->Read_1d437d5ac2290f2b();
            AddToBuffer(b);
        }
        WriteConsole(_T("[6n"));
        if((ConsoleDriver::InternalKeyAvailable(1000) <= 0)) 
        {
            this->noGetPosition = true;
            return;
        }
        b = this->stdin_->Read_1d437d5ac2290f2b();
        while((b != 27)) {
            AddToBuffer(b);
            if((ConsoleDriver::InternalKeyAvailable(100) <= 0)) 
            {
                return;
            }
            b = this->stdin_->Read_1d437d5ac2290f2b();
        }
        b = this->stdin_->Read_1d437d5ac2290f2b();
        if((b != 91)) 
        {
            AddToBuffer(27);
            AddToBuffer(b);
            return;
        }
        b = this->stdin_->Read_1d437d5ac2290f2b();
        if((b != 59)) 
        {
            row = (b - 48);
            b = this->stdin_->Read_1d437d5ac2290f2b();
            while(((b >= 48) && (b <= 57))) {
                row = (((row * 10) + b) - 48);
                b = this->stdin_->Read_1d437d5ac2290f2b();
            }
            row--;
        }
        b = this->stdin_->Read_1d437d5ac2290f2b();
        if((b != 82)) 
        {
            col = (b - 48);
            b = this->stdin_->Read_1d437d5ac2290f2b();
            while(((b >= 48) && (b <= 57))) {
                col = (((col * 10) + b) - 48);
                b = this->stdin_->Read_1d437d5ac2290f2b();
            }
            col--;
        }
        this->cursorLeft = col;
        this->cursorTop = row;
    }
    
    void TermInfoDriver::CheckWindowDimensions() {
        if(((native_terminal_size ==  nullptr) || (terminal_size ==  (*native_terminal_size)))) 
        {
            return;
        }
        if(((*native_terminal_size) ==  -1)) 
        {
            int32_t c = this->reader->Get2(TermInfoNumbers::Columns);
            if((c != 0)) 
            {
                this->windowWidth = c;
            }
            c = this->reader->Get2(TermInfoNumbers::Lines);
            if((c != 0)) 
            {
                this->windowHeight = c;
            }
        }
         else 
        {
            terminal_size = (*native_terminal_size);
            this->windowWidth = (terminal_size >> 16);
            this->windowHeight = (terminal_size & 65535);
        }
        this->bufferHeight = this->windowHeight;
        this->bufferWidth = this->windowWidth;
    }
    
    void TermInfoDriver::Clear() {
        if(!(this->inited)) 
        {
            Init();
        }
        WriteConsole(this->clear);
        this->cursorLeft = 0;
        this->cursorTop = 0;
    }
    
    void TermInfoDriver::Beep(int32_t frequency, int32_t duration) {
        if(!(this->inited)) 
        {
            Init();
        }
        WriteConsole(this->bell);
    }
    
    void TermInfoDriver::MoveBufferArea(int32_t sourceLeft, int32_t sourceTop, int32_t sourceWidth, int32_t sourceHeight, int32_t targetLeft, int32_t targetTop, char16_t sourceChar, ConsoleColor sourceForeColor, ConsoleColor sourceBackColor) {
        if(!(this->inited)) 
        {
            Init();
        }
        throw cli::gcnew<NotImplementedException>();
    }
    
    void TermInfoDriver::AddToBuffer(int32_t b) {
        if((this->buffer ==  nullptr)) 
        {
            this->buffer = (new cli::array<char16_t>(1024));
        }
         else 
        {
            if((this->writepos >= this->buffer->get_Length())) 
            {
                cli::array<char16_t> *newbuf = (new cli::array<char16_t>((this->buffer->get_Length() * 2)));
                Buffer::BlockCopy(this->buffer, 0, newbuf, 0, this->buffer->get_Length());
                this->buffer = newbuf;
            }
        }
        this->buffer->at(this->writepos++) = (char16_t)b;
    }
    
    void TermInfoDriver::AdjustBuffer() {
        if((this->readpos >= this->writepos)) 
        {
            this->readpos = this->writepos = 0;
        }
    }
    
    ConsoleKeyInfo TermInfoDriver::CreateKeyInfoFromInt(int32_t n, bool alt) {
        char16_t c = (char16_t)n;
        ConsoleKey key = (ConsoleKey)(n);
        bool shift = false;
        bool ctrl = false;
        switch(n) {
            case 10: case_885: {
                key = ConsoleKey::Enter;
                break;
            }
            case 32: case_886: {
                key = ConsoleKey::Spacebar;
                break;
            }
            case 45: case_887: {
                key = ConsoleKey::Subtract;
                break;
            }
            case 43: case_888: {
                key = ConsoleKey::Add;
                break;
            }
            case 47: case_889: {
                key = ConsoleKey::Divide;
                break;
            }
            case 42: case_890: {
                key = ConsoleKey::Multiply;
                break;
            }
            case 8: case 9: case 12: case 13: case 19: case_891: {
                break;
            }
            case 27: case_892: {
                key = ConsoleKey::Escape2;
                break;
            }
            default: case_893: {
                if(((n >= 1) && (n <= 26))) 
                {
                    ctrl = true;
                    key = (ConsoleKey)(((int32_t)((65 + n)) - 1));
                }
                 else 
                {
                    if(((n >= 97) && (n <= 122))) 
                    {
                        key = (ConsoleKey)((-32 + n));
                    }
                     else 
                    {
                        if(((n >= 65) && (n <= 90))) 
                        {
                            shift = true;
                        }
                         else 
                        {
                            if(((n >= 48) && (n <= 57))) 
                            {
                            }
                             else 
                            {
                                key = (ConsoleKey)0L;
                            }
                        }
                    }
                }
                break;
            }
        }
        return cli::ctor<ConsoleKeyInfo>(c, key, shift, alt, ctrl);
    }
    
    Object* TermInfoDriver::GetKeyFromBuffer(bool cooked) {
        if((this->readpos >= this->writepos)) 
        {
            return nullptr;
        }
        int32_t next = (int32_t)(this->buffer->at(this->readpos));
        if((!(cooked) || !(this->rootmap->StartsWith(next)))) 
        {
            this->readpos++;
            AdjustBuffer();
            return cli::box(CreateKeyInfoFromInt(next, false));
        }
        int32_t used;
        TermInfoStrings str = this->rootmap->Match(this->buffer, this->readpos, (this->writepos - this->readpos), used);
        if(((int32_t)(str) ==  -1)) 
        {
            if((((int32_t)(this->buffer->at(this->readpos)) ==  27) && ((this->writepos - this->readpos) >= 2))) 
            {
                (this->readpos = this->readpos + 2);
                AdjustBuffer();
                if(((int32_t)(this->buffer->at((this->readpos + 1))) ==  127)) 
                {
                    return cli::box(cli::ctor<ConsoleKeyInfo>(u'\x8', ConsoleKey::Backspace, false, true, false));
                }
                return cli::box(CreateKeyInfoFromInt((int32_t)(this->buffer->at((this->readpos + 1))), true));
            }
             else 
            {
                return nullptr;
            }
        }
        ConsoleKeyInfo key;
        if((this->keymap->get_Item_d75c6e706b965758(cli::box(str)) != nullptr)) 
        {
            key = cli::unbox<ConsoleKeyInfo>(this->keymap->get_Item_d75c6e706b965758(cli::box(str)));
        }
         else 
        {
            this->readpos++;
            AdjustBuffer();
            return cli::box(CreateKeyInfoFromInt(next, false));
        }
        (this->readpos = this->readpos + used);
        AdjustBuffer();
        return cli::box(key);
    }
    
    ConsoleKeyInfo TermInfoDriver::ReadKeyInternal(bool fresh) {
        if(!(this->inited)) 
        {
            Init();
        }
        InitKeys();
        Object *o;
        if(((o = GetKeyFromBuffer(true)) ==  (nullptr))) 
        {
            do {
                if((ConsoleDriver::InternalKeyAvailable(150) > 0)) 
                {
                    do {
                        AddToBuffer(this->stdin_->Read_1d437d5ac2290f2b());
                    }
                    while((ConsoleDriver::InternalKeyAvailable(0) > 0));
                }
                 else 
                {
                    if(this->stdin_->DataAvailable()) 
                    {
                        do {
                            AddToBuffer(this->stdin_->Read_1d437d5ac2290f2b());
                        }
                        while(this->stdin_->DataAvailable());
                    }
                     else 
                    {
                        if(((o = GetKeyFromBuffer(false)) != (nullptr))) 
                        {
                            break;
                        }
                        AddToBuffer(this->stdin_->Read_1d437d5ac2290f2b());
                    }
                }
                o = GetKeyFromBuffer(true);
            }
            while((o ==  nullptr));
            fresh = true;
        }
         else 
        {
            fresh = false;
        }
        return cli::unbox<ConsoleKeyInfo>(o);
    }
    
    bool TermInfoDriver::InputPending() {
        return ((this->readpos < this->writepos) || this->stdin_->DataAvailable());
    }
    
    void TermInfoDriver::QueueEcho(char16_t c) {
        if((this->echobuf ==  nullptr)) 
        {
            this->echobuf = (new cli::array<char16_t>(1024));
        }
        this->echobuf->at(this->echon++) = c;
        if(((this->echon ==  this->echobuf->get_Length()) || !(InputPending()))) 
        {
            this->stdout_->InternalWriteChars(this->echobuf, this->echon);
            this->echon = 0;
        }
    }
    
    void TermInfoDriver::Echo(ConsoleKeyInfo key) {
        if(!(IsSpecialKey(key))) 
        {
            QueueEcho(key->get_KeyChar());
            return;
        }
        EchoFlush();
        WriteSpecialKey(key);
    }
    
    void TermInfoDriver::EchoFlush() {
        if((this->echon ==  0)) 
        {
            return;
        }
        this->stdout_->InternalWriteChars(this->echobuf, this->echon);
        this->echon = 0;
    }
    
    int32_t TermInfoDriver::Read(cli::array<char16_t>* dest, int32_t index, int32_t count) {
        bool fresh, echo = false;
        Text::StringBuilder *sbuf;
        ConsoleKeyInfo key;
        int32_t BoL = 0;
        Object *o;
        char16_t c;
        sbuf = cli::gcnew<Text::StringBuilder>();
        while(true) {
            if(((o = GetKeyFromBuffer(true)) ==  (nullptr))) 
            {
                break;
            }
            key = cli::unbox<ConsoleKeyInfo>(o);
            c = key->get_KeyChar();
            if(((int32_t)(key->get_Key()) != 8)) 
            {
                if(((int32_t)(key->get_Key()) ==  13)) 
                {
                    BoL = sbuf->get_Length();
                }
                sbuf->Append16(c);
            }
             else 
            {
                if((sbuf->get_Length() > BoL)) 
                {
                    [&]() { auto tmp_186 = sbuf->get_Length(); sbuf->set_Length(tmp_186 - 1); return tmp_186; }();
                }
            }
        }
        this->rl_startx = this->cursorLeft;
        this->rl_starty = this->cursorTop;
        do {
            key = ReadKeyInternal(fresh);
            echo = (echo || fresh);
            c = key->get_KeyChar();
            if(((int32_t)(key->get_Key()) != 8)) 
            {
                if(((int32_t)(key->get_Key()) ==  13)) 
                {
                    BoL = sbuf->get_Length();
                }
                sbuf->Append16(c);
            }
             else 
            {
                if((sbuf->get_Length() > BoL)) 
                {
                    [&]() { auto tmp_187 = sbuf->get_Length(); sbuf->set_Length(tmp_187 - 1); return tmp_187; }();
                }
                 else 
                {
                    continue;
                }
            }
            if(echo) 
            {
                Echo(key);
            }
        }
        while(((int32_t)(key->get_Key()) != 13));
        EchoFlush();
        this->rl_startx = -1;
        this->rl_starty = -1;
        int32_t nread = 0;
        while(((count > 0) && (nread < sbuf->get_Length()))) {
            dest->at((index + nread)) = sbuf->get_Chars(nread);
            nread++;
            count--;
        }
        for(int32_t i = nread; (i < sbuf->get_Length()); i++) {
            AddToBuffer((int32_t)(sbuf->get_Chars(i)));
        }
        return nread;
    }
    
    ConsoleKeyInfo TermInfoDriver::ReadKey(bool intercept) {
        bool fresh;
        ConsoleKeyInfo key = ReadKeyInternal(fresh);
        if((!(intercept) && fresh)) 
        {
            Echo(key);
            EchoFlush();
        }
        return key;
    }
    
    String* TermInfoDriver::ReadLine() {
        if(!(this->inited)) 
        {
            Init();
        }
        GetCursorPosition();
        Text::StringBuilder *builder = cli::gcnew<Text::StringBuilder>();
        bool fresh, echo = false;
        ConsoleKeyInfo key;
        char16_t c;
        this->rl_startx = this->cursorLeft;
        this->rl_starty = this->cursorTop;
        char16_t eof = (char16_t)this->control_characters->at(4);
        do {
            key = ReadKeyInternal(fresh);
            echo = (echo || fresh);
            c = key->get_KeyChar();
            if(((((int32_t)(c) ==  (int32_t)(eof)) && ((int32_t)(c) != 0)) && (builder->get_Length() ==  0))) 
            {
                return nullptr;
            }
            if(((int32_t)(key->get_Key()) != 13)) 
            {
                if(((int32_t)(key->get_Key()) != 8)) 
                {
                    builder->Append16(c);
                }
                 else 
                {
                    if((builder->get_Length() > 0)) 
                    {
                        [&]() { auto tmp_188 = builder->get_Length(); builder->set_Length(tmp_188 - 1); return tmp_188; }();
                    }
                     else 
                    {
                        continue;
                    }
                }
            }
            if(echo) 
            {
                Echo(key);
            }
        }
        while(((int32_t)(key->get_Key()) != 13));
        EchoFlush();
        this->rl_startx = -1;
        this->rl_starty = -1;
        return builder->ToString_1636a0751cb9ac11();
    }
    
    void TermInfoDriver::ResetColor() {
        if(!(this->inited)) 
        {
            Init();
        }
        String *str = (this->origPair != nullptr) ? this->origPair : this->origColors;
        WriteConsole(str);
    }
    
    void TermInfoDriver::SetBufferSize(int32_t width, int32_t height) {
        if(!(this->inited)) 
        {
            Init();
        }
        throw cli::gcnew<NotImplementedException>(String::Empty);
    }
    
    void TermInfoDriver::SetCursorPosition(int32_t left, int32_t top) {
        if(!(this->inited)) 
        {
            Init();
        }
        CheckWindowDimensions();
        if(((left < 0) || (left >= this->bufferWidth))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("left"), _T("Value must be positive and below the buffer width."));
        }
        if(((top < 0) || (top >= this->bufferHeight))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("top"), _T("Value must be positive and below the buffer height."));
        }
        if((this->cursorAddress ==  nullptr)) 
        {
            throw cli::gcnew<NotSupportedException>(_T("This terminal does not suport setting the cursor position."));
        }
        int32_t one = this->home_1_1 ? 1 : 0;
        WriteConsole(String::Format3(this->cursorAddress, cli::box((top + one)), cli::box((left + one))));
        this->cursorLeft = left;
        this->cursorTop = top;
    }
    
    void TermInfoDriver::SetWindowPosition(int32_t left, int32_t top) {
        if(!(this->inited)) 
        {
            Init();
        }
    }
    
    void TermInfoDriver::SetWindowSize(int32_t width, int32_t height) {
        if(!(this->inited)) 
        {
            Init();
        }
    }
    
    void TermInfoDriver::CreateKeyMap() {
        this->keymap = cli::gcnew<Collections::Hashtable>();
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeyBackspace), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x0', ConsoleKey::Backspace, false, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeyClear), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x0', ConsoleKey::Clear, false, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeyDown), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x0', ConsoleKey::DownArrow, false, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeyF1), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x0', ConsoleKey::F1, false, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeyF10), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x0', ConsoleKey::F10, false, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeyF2), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x0', ConsoleKey::F2, false, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeyF3), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x0', ConsoleKey::F3, false, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeyF4), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x0', ConsoleKey::F4, false, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeyF5), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x0', ConsoleKey::F5, false, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeyF6), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x0', ConsoleKey::F6, false, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeyF7), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x0', ConsoleKey::F7, false, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeyF8), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x0', ConsoleKey::F8, false, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeyF9), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x0', ConsoleKey::F9, false, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeyHome), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x0', ConsoleKey::Home, false, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeyLeft), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x0', ConsoleKey::LeftArrow, false, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeyLl), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x0', ConsoleKey::NumPad1, false, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeyNpage), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x0', ConsoleKey::PageDown, false, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeyPpage), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x0', ConsoleKey::PageUp, false, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeyRight), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x0', ConsoleKey::RightArrow, false, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeySf), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x0', ConsoleKey::PageDown, false, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeySr), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x0', ConsoleKey::PageUp, false, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeyUp), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x0', ConsoleKey::UpArrow, false, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeyA1), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x0', ConsoleKey::NumPad7, false, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeyA3), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x0', ConsoleKey::NumPad9, false, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeyB2), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x0', ConsoleKey::NumPad5, false, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeyC1), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x0', ConsoleKey::NumPad1, false, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeyC3), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x0', ConsoleKey::NumPad3, false, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeyBtab), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x0', ConsoleKey::Tab, true, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeyBeg), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x0', ConsoleKey::Home, false, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeyCopy), cli::box(cli::ctor<ConsoleKeyInfo>(u'C', ConsoleKey::C, false, true, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeyEnd), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x0', ConsoleKey::End, false, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeyEnter), cli::box(cli::ctor<ConsoleKeyInfo>(u'\xa', ConsoleKey::Enter, false, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeyHelp), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x0', ConsoleKey::Help, false, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeyPrint), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x0', ConsoleKey::Print, false, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeyUndo), cli::box(cli::ctor<ConsoleKeyInfo>(u'Z', ConsoleKey::Z, false, true, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeySbeg), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x0', ConsoleKey::Home, true, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeyScopy), cli::box(cli::ctor<ConsoleKeyInfo>(u'C', ConsoleKey::C, true, true, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeySdc), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x9', ConsoleKey::Delete, true, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeyShelp), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x0', ConsoleKey::Help, true, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeyShome), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x0', ConsoleKey::Home, true, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeySleft), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x0', ConsoleKey::LeftArrow, true, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeySprint), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x0', ConsoleKey::Print, true, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeySright), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x0', ConsoleKey::RightArrow, true, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeySundo), cli::box(cli::ctor<ConsoleKeyInfo>(u'Z', ConsoleKey::Z, true, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeyF11), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x0', ConsoleKey::F11, false, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeyF12), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x0', ConsoleKey::F12, false, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeyF13), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x0', ConsoleKey::F13, false, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeyF14), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x0', ConsoleKey::F14, false, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeyF15), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x0', ConsoleKey::F15, false, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeyF16), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x0', ConsoleKey::F16, false, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeyF17), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x0', ConsoleKey::F17, false, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeyF18), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x0', ConsoleKey::F18, false, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeyF19), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x0', ConsoleKey::F19, false, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeyF20), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x0', ConsoleKey::F20, false, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeyF21), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x0', ConsoleKey::F21, false, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeyF22), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x0', ConsoleKey::F22, false, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeyF23), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x0', ConsoleKey::F23, false, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeyF24), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x0', ConsoleKey::F24, false, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeyDc), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x0', ConsoleKey::Delete, false, false, false)));
        this->keymap->set_Item_84c7e24d9caa09(cli::box(TermInfoStrings::KeyIc), cli::box(cli::ctor<ConsoleKeyInfo>(u'\x0', ConsoleKey::Insert, false, false, false)));
    }
    
    void TermInfoDriver::InitKeys() {
        if(this->initKeys) 
        {
            return;
        }
        CreateKeyMap();
        this->rootmap = cli::gcnew<ByteMatcher>();
        for(auto tmp_189 : UsedKeys) {
            auto tis = cli::cast<TermInfoStrings>(tmp_189);
            AddStringMapping(tis);
        }
        this->rootmap->AddMapping(TermInfoStrings::KeyBackspace, (new cli::array<unsigned char>({this->control_characters->at(2)})));
        this->rootmap->Sort();
        this->initKeys = true;
    }
    
    void TermInfoDriver::AddStringMapping(TermInfoStrings s) {
        cli::array<unsigned char> *bytes = this->reader->GetStringBytes(s);
        if((bytes ==  nullptr)) 
        {
            return;
        }
        this->rootmap->AddMapping(s, bytes);
    }
    
    bool TermInfoDriver::get_Initialized() {
        return this->inited;
    }
    
    ConsoleColor TermInfoDriver::get_BackgroundColor() {
        if(!(this->inited)) 
        {
            Init();
        }
        return this->bgcolor;
    }
    
    ConsoleColor TermInfoDriver::set_BackgroundColor(ConsoleColor value) {
        if(!(this->inited)) 
        {
            Init();
        }
        this->bgcolor = value;
        bool light;
        int32_t colour = TranslateColor(value, light);
        if(light) 
        {
            WriteConsole(String::Format2(this->setlbgcolor, cli::box(colour)));
        }
         else 
        {
            WriteConsole(String::Format2(this->setbgcolor, cli::box(colour)));
        }
        return get_BackgroundColor();
    }
    
    ConsoleColor TermInfoDriver::get_ForegroundColor() {
        if(!(this->inited)) 
        {
            Init();
        }
        return this->fgcolor;
    }
    
    ConsoleColor TermInfoDriver::set_ForegroundColor(ConsoleColor value) {
        if(!(this->inited)) 
        {
            Init();
        }
        this->fgcolor = value;
        bool light;
        int32_t colour = TranslateColor(value, light);
        if(light) 
        {
            WriteConsole(String::Format2(this->setlfgcolor, cli::box(colour)));
        }
         else 
        {
            WriteConsole(String::Format2(this->setfgcolor, cli::box(colour)));
        }
        return get_ForegroundColor();
    }
    
    int32_t TermInfoDriver::get_BufferHeight() {
        if(!(this->inited)) 
        {
            Init();
        }
        CheckWindowDimensions();
        return this->bufferHeight;
    }
    
    int32_t TermInfoDriver::set_BufferHeight(int32_t value) {
        if(!(this->inited)) 
        {
            Init();
        }
        throw cli::gcnew<NotSupportedException>();
        return get_BufferHeight();
    }
    
    int32_t TermInfoDriver::get_BufferWidth() {
        if(!(this->inited)) 
        {
            Init();
        }
        CheckWindowDimensions();
        return this->bufferWidth;
    }
    
    int32_t TermInfoDriver::set_BufferWidth(int32_t value) {
        if(!(this->inited)) 
        {
            Init();
        }
        throw cli::gcnew<NotSupportedException>();
        return get_BufferWidth();
    }
    
    bool TermInfoDriver::get_CapsLock() {
        if(!(this->inited)) 
        {
            Init();
        }
        return false;
    }
    
    int32_t TermInfoDriver::get_CursorLeft() {
        if(!(this->inited)) 
        {
            Init();
        }
        return this->cursorLeft;
    }
    
    int32_t TermInfoDriver::set_CursorLeft(int32_t value) {
        if(!(this->inited)) 
        {
            Init();
        }
        SetCursorPosition(value, this->get_CursorTop());
        return get_CursorLeft();
    }
    
    int32_t TermInfoDriver::get_CursorTop() {
        if(!(this->inited)) 
        {
            Init();
        }
        return this->cursorTop;
    }
    
    int32_t TermInfoDriver::set_CursorTop(int32_t value) {
        if(!(this->inited)) 
        {
            Init();
        }
        SetCursorPosition(this->get_CursorLeft(), value);
        return get_CursorTop();
    }
    
    bool TermInfoDriver::get_CursorVisible() {
        if(!(this->inited)) 
        {
            Init();
        }
        return this->cursorVisible;
    }
    
    bool TermInfoDriver::set_CursorVisible(bool value) {
        if(!(this->inited)) 
        {
            Init();
        }
        this->cursorVisible = value;
        WriteConsole(value ? this->csrVisible : this->csrInvisible);
        return get_CursorVisible();
    }
    
    int32_t TermInfoDriver::get_CursorSize() {
        if(!(this->inited)) 
        {
            Init();
        }
        return 1;
    }
    
    int32_t TermInfoDriver::set_CursorSize(int32_t value) {
        if(!(this->inited)) 
        {
            Init();
        }
        return get_CursorSize();
    }
    
    bool TermInfoDriver::get_KeyAvailable() {
        if(!(this->inited)) 
        {
            Init();
        }
        return ((this->writepos > this->readpos) || (ConsoleDriver::InternalKeyAvailable(0) > 0));
    }
    
    int32_t TermInfoDriver::get_LargestWindowHeight() {
        return this->get_WindowHeight();
    }
    
    int32_t TermInfoDriver::get_LargestWindowWidth() {
        return this->get_WindowWidth();
    }
    
    bool TermInfoDriver::get_NumberLock() {
        if(!(this->inited)) 
        {
            Init();
        }
        return false;
    }
    
    String* TermInfoDriver::get_Title() {
        if(!(this->inited)) 
        {
            Init();
        }
        return this->title;
    }
    
    String* TermInfoDriver::set_Title(String* value) {
        if(!(this->inited)) 
        {
            Init();
        }
        this->title = value;
        WriteConsole(String::Format2(this->titleFormat, value));
        return get_Title();
    }
    
    bool TermInfoDriver::get_TreatControlCAsInput() {
        if(!(this->inited)) 
        {
            Init();
        }
        return this->controlCAsInput;
    }
    
    bool TermInfoDriver::set_TreatControlCAsInput(bool value) {
        if(!(this->inited)) 
        {
            Init();
        }
        if((this->controlCAsInput ==  value)) 
        {
            return get_TreatControlCAsInput();
        }
        ConsoleDriver::SetBreak(value);
        this->controlCAsInput = value;
        return get_TreatControlCAsInput();
    }
    
    int32_t TermInfoDriver::get_WindowHeight() {
        if(!(this->inited)) 
        {
            Init();
        }
        CheckWindowDimensions();
        return this->windowHeight;
    }
    
    int32_t TermInfoDriver::set_WindowHeight(int32_t value) {
        if(!(this->inited)) 
        {
            Init();
        }
        throw cli::gcnew<NotSupportedException>();
        return get_WindowHeight();
    }
    
    int32_t TermInfoDriver::get_WindowLeft() {
        if(!(this->inited)) 
        {
            Init();
        }
        return 0;
    }
    
    int32_t TermInfoDriver::set_WindowLeft(int32_t value) {
        if(!(this->inited)) 
        {
            Init();
        }
        throw cli::gcnew<NotSupportedException>();
        return get_WindowLeft();
    }
    
    int32_t TermInfoDriver::get_WindowTop() {
        if(!(this->inited)) 
        {
            Init();
        }
        return 0;
    }
    
    int32_t TermInfoDriver::set_WindowTop(int32_t value) {
        if(!(this->inited)) 
        {
            Init();
        }
        throw cli::gcnew<NotSupportedException>();
        return get_WindowTop();
    }
    
    int32_t TermInfoDriver::get_WindowWidth() {
        if(!(this->inited)) 
        {
            Init();
        }
        CheckWindowDimensions();
        return this->windowWidth;
    }
    
    int32_t TermInfoDriver::set_WindowWidth(int32_t value) {
        if(!(this->inited)) 
        {
            Init();
        }
        throw cli::gcnew<NotSupportedException>();
        return get_WindowWidth();
    }
    
}
namespace System {
    
    
    void ByteMatcher::constructor() {
    }
    
    void ByteMatcher::AddMapping(TermInfoStrings key, cli::array<unsigned char>* val) {
        if((val->get_Length() ==  0)) 
        {
            return;
        }
        this->map->set_Item_84c7e24d9caa09(val, cli::box(key));
        this->starts->set_Item_84c7e24d9caa09(cli::box((int32_t)(val->at(0))), cli::box(true));
    }
    
    void ByteMatcher::Sort() {
    }
    
    bool ByteMatcher::StartsWith(int32_t c) {
        return (this->starts->get_Item_d75c6e706b965758(cli::box(c)) != nullptr);
    }
    
    TermInfoStrings ByteMatcher::Match(cli::array<char16_t>* buffer, int32_t offset, int32_t length, int32_t used) {
        for(auto tmp_190 : this->map->get_Keys_8171dfd94447fa93()) {
            auto bytes = cli::cast<cli::array<unsigned char>*>(tmp_190);
            {
                for(int32_t i = 0; ((i < bytes->get_Length()) && (i < length)); i++){
                    if(((int32_t)((char16_t)bytes->at(i)) != (int32_t)(buffer->at((offset + i))))) 
                    {
                        break;
                    }
                    if(((bytes->get_Length() - 1) ==  i)) 
                    {
                        used = bytes->get_Length();
                        return cli::unbox<TermInfoStrings>(this->map->get_Item_d75c6e706b965758(bytes));
                    }
                }
            }
        }
        used = 0;
        return (TermInfoStrings)-1L;
    }
    
}
namespace System {
    
    
    void TermInfoReader::constructor(String* term, String* filename) {
        {
            /* USING - BLOCK */
            auto st = IO::File::OpenRead(filename);
            cli::using_guard{st};
            int64_t length = st->get_Length_ddb8b0d061db5350();
            if((length > 4096L)) 
            {
                throw cli::gcnew<Exception>(_T("File must be smaller than 4K"));
            }
            this->buffer = (new cli::array<unsigned char>((int32_t)length));
            if((st->Read_c0d6dde3943b413e(this->buffer, 0, this->buffer->get_Length()) != this->buffer->get_Length())) 
            {
                throw cli::gcnew<Exception>(_T("Short read"));
            }
            ReadHeader(this->buffer, this->booleansOffset);
            ReadNames(this->buffer, this->booleansOffset);
        }
    }
    
    void TermInfoReader::constructor(String* term, cli::array<unsigned char>* buffer) {
        if((buffer ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("buffer"));
        }
        this->buffer = buffer;
        ReadHeader(buffer, this->booleansOffset);
        ReadNames(buffer, this->booleansOffset);
    }
    
    void TermInfoReader::ReadHeader(cli::array<unsigned char>* buffer, int32_t position) {
        int16_t magic = GetInt16(buffer, position);
        (position = position + 2);
        if(((int32_t)(magic) != 282)) 
        {
            throw cli::gcnew<Exception>(String::Format2(_T("Magic number is wrong: {0}"), cli::box(magic)));
        }
        GetInt16(buffer, position);
        (position = position + 2);
        this->boolSize = GetInt16(buffer, position);
        (position = position + 2);
        this->numSize = GetInt16(buffer, position);
        (position = position + 2);
        this->strOffsets = GetInt16(buffer, position);
        (position = position + 2);
        GetInt16(buffer, position);
        (position = position + 2);
    }
    
    void TermInfoReader::ReadNames(cli::array<unsigned char>* buffer, int32_t position) {
        String *prev = GetString(buffer, position);
        (position = position + (prev->get_Length() + 1));
    }
    
    bool TermInfoReader::Get(TermInfoBooleans boolean) {
        int32_t x = (int32_t)(boolean);
        if((((x < 0) || ((int32_t)(boolean) >= 37)) || (x >= (int32_t)(this->boolSize)))) 
        {
            return false;
        }
        int32_t offset = this->booleansOffset;
        (offset = offset + (int32_t)(boolean));
        return ((int32_t)(this->buffer->at(offset)) != 0);
    }
    
    int32_t TermInfoReader::Get2(TermInfoNumbers number) {
        int32_t x = (int32_t)(number);
        if((((x < 0) || ((int32_t)(number) >= 33)) || (x > (int32_t)(this->numSize)))) 
        {
            return -1;
        }
        int32_t offset = (this->booleansOffset + (int32_t)(this->boolSize));
        if(((offset % 2) ==  1)) 
        {
            offset++;
        }
        (offset = offset + ((int32_t)(number) * 2));
        return (int32_t)(GetInt16(this->buffer, offset));
    }
    
    String* TermInfoReader::Get3(TermInfoStrings tstr) {
        int32_t x = (int32_t)(tstr);
        if((((x < 0) || ((int32_t)(tstr) >= 394)) || (x > (int32_t)(this->strOffsets)))) 
        {
            return nullptr;
        }
        int32_t offset = (this->booleansOffset + (int32_t)(this->boolSize));
        if(((offset % 2) ==  1)) 
        {
            offset++;
        }
        (offset = offset + ((int32_t)(this->numSize) * 2));
        int32_t off2 = (int32_t)(GetInt16(this->buffer, (offset + ((int32_t)(tstr) * 2))));
        if((off2 ==  -1)) 
        {
            return nullptr;
        }
        return GetString(this->buffer, ((offset + ((int32_t)(this->strOffsets) * 2)) + off2));
    }
    
    cli::array<unsigned char>* TermInfoReader::GetStringBytes(TermInfoStrings tstr) {
        int32_t x = (int32_t)(tstr);
        if((((x < 0) || ((int32_t)(tstr) >= 394)) || (x > (int32_t)(this->strOffsets)))) 
        {
            return nullptr;
        }
        int32_t offset = (this->booleansOffset + (int32_t)(this->boolSize));
        if(((offset % 2) ==  1)) 
        {
            offset++;
        }
        (offset = offset + ((int32_t)(this->numSize) * 2));
        int32_t off2 = (int32_t)(GetInt16(this->buffer, (offset + ((int32_t)(tstr) * 2))));
        if((off2 ==  -1)) 
        {
            return nullptr;
        }
        return GetStringBytes2(this->buffer, ((offset + ((int32_t)(this->strOffsets) * 2)) + off2));
    }
    
    int16_t TermInfoReader::GetInt16(cli::array<unsigned char>* buffer, int32_t offset) {
        int32_t uno = (int32_t)(buffer->at(offset));
        int32_t dos = (int32_t)(buffer->at((offset + 1)));
        if(((uno ==  255) && (dos ==  255))) 
        {
            return -1;
        }
        return (int16_t)(uno + (dos * 256));
    }
    
    String* TermInfoReader::GetString(cli::array<unsigned char>* buffer, int32_t offset) {
        int32_t length = 0;
        int32_t off = offset;
        while(((int32_t)(buffer->at(off++)) != 0)) length++;
        return Text::Encoding::get_ASCII()->GetString_39f4843197ddbe92(buffer, offset, length);
    }
    
    cli::array<unsigned char>* TermInfoReader::GetStringBytes2(cli::array<unsigned char>* buffer, int32_t offset) {
        int32_t length = 0;
        int32_t off = offset;
        while(((int32_t)(buffer->at(off++)) != 0)) length++;
        cli::array<unsigned char> *result = (new cli::array<unsigned char>(length));
        Buffer::BlockCopyInternal(buffer, offset, result, 0, length);
        return result;
    }
    
    String* TermInfoReader::Escape2(String* s) {
        Text::StringBuilder *sb = cli::gcnew<Text::StringBuilder>();
        for(int32_t i = 0; (i < s->get_Length()); i++){
            char16_t current = s->get_Chars(i);
            if(Char::IsControl(current)) 
            {
                sb->AppendFormat3(_T("\\x{0:X2}"), cli::box((int32_t)(current)));
            }
             else 
            {
                sb->Append16(current);
            }
        }
        return sb->ToString_1636a0751cb9ac11();
    }
    
}
namespace System {
    
    
    void ThreadStaticAttribute::constructor() {
    }
    
}
namespace System {
    
    
    void TimeoutException::constructor() {
        this->set_HResult(-2146233083);
    }
    
    void TimeoutException::constructor(String* message) {
        this->set_HResult(-2146233083);
    }
    
    void TimeoutException::constructor(String* message, Exception* innerException) {
        this->set_HResult(-2146233083);
    }
    
    void TimeoutException::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
    }
    
}
namespace System {
    
    
    void Parser::constructor(String* src) {
        this->_src = src;
        this->_length = this->_src->get_Length();
        this->number_format = GetNumberFormatInfo(nullptr);
    }
    
    void Parser::constructor(String* src, IFormatProvider* formatProvider) {
        this->number_format = GetNumberFormatInfo(formatProvider);
    }
    
    void Parser::Reset() {
        this->_cur = 0;
        this->parse_error = ParseError::None;
        this->parsed_ticks = this->parsed_days_separator = false;
        this->parsed_numbers_count = 0;
    }
    
    Globalization::NumberFormatInfo* Parser::GetNumberFormatInfo(IFormatProvider* formatProvider) {
        Globalization::NumberFormatInfo *format = nullptr;
        if((formatProvider != nullptr)) 
        {
            format = cli::cast<Globalization::NumberFormatInfo*>(formatProvider->GetFormat_b67414a65453cc7e(cli::typeof<Type>::info));
        }
        if((format ==  nullptr)) 
        {
            format = Threading::Thread::get_CurrentThread()->get_CurrentCulture()->get_NumberFormat_56b6d54c07628932();
        }
        return format;
    }
    
    void Parser::ParseWhiteSpace() {
        while((!(this->get_AtEnd()) && Char::IsWhiteSpace2(this->_src, this->_cur))) {
            this->_cur++;
        }
    }
    
    bool Parser::ParseSign() {
        bool res = false;
        if((!(this->get_AtEnd()) && ((int32_t)(this->_src->get_Chars(this->_cur)) ==  45))) 
        {
            res = true;
            this->_cur++;
        }
        return res;
    }
    
    int32_t Parser::ParseIntExact(int32_t digit_count, int32_t max_digit_count) {
        int64_t res = 0L;
        int32_t count = 0;
        while((!(this->get_AtEnd()) && Char::IsDigit2(this->_src, this->_cur))) {
            res = (((res * 10L) + (int64_t)(this->_src->get_Chars(this->_cur))) - 48L);
            if((res > 2147483647L)) 
            {
                SetParseError(ParseError::Format3);
                break;
            }
            this->_cur++;
            count++;
        }
        if((((count ==  0) || ((digit_count > 1) && (digit_count != count))) || (count > max_digit_count))) 
        {
            SetParseError(ParseError::Format3);
        }
        return (int32_t)res;
    }
    
    int32_t Parser::ParseInt(bool optional) {
        if((optional && this->get_AtEnd())) 
        {
            return 0;
        }
        int64_t res = 0L;
        int32_t count = 0;
        while((!(this->get_AtEnd()) && Char::IsDigit2(this->_src, this->_cur))) {
            res = (((res * 10L) + (int64_t)(this->_src->get_Chars(this->_cur))) - 48L);
            if((res > 2147483647L)) 
            {
                SetParseError(ParseError::Overflow);
                break;
            }
            this->_cur++;
            count++;
        }
        if((!(optional) && (count ==  0))) 
        {
            SetParseError(ParseError::Format3);
        }
        if((count > 0)) 
        {
            this->parsed_numbers_count++;
        }
        return (int32_t)res;
    }
    
    bool Parser::ParseOptDaysSeparator() {
        if(this->get_AtEnd()) 
        {
            return false;
        }
        if(((int32_t)(this->_src->get_Chars(this->_cur)) ==  46)) 
        {
            this->_cur++;
            this->parsed_days_separator = true;
            return true;
        }
        return false;
    }
    
    bool Parser::ParseOptDecimalSeparator() {
        if(this->get_AtEnd()) 
        {
            return false;
        }
        if((!(this->Exact) || !(this->CultureSensitive))) 
        {
            if(((int32_t)(this->_src->get_Chars(this->_cur)) ==  46)) 
            {
                this->_cur++;
                return true;
            }
        }
        String *decimal_separator = this->number_format->get_NumberDecimalSeparator();
        if((this->CultureSensitive && (String::Compare4(this->_src, this->_cur, decimal_separator, 0, decimal_separator->get_Length()) ==  0))) 
        {
            (this->_cur = this->_cur + decimal_separator->get_Length());
            return true;
        }
        return false;
    }
    
    bool Parser::ParseLiteral(String* value) {
        if((!(this->get_AtEnd()) && (String::Compare4(this->_src, this->_cur, value, 0, value->get_Length()) ==  0))) 
        {
            (this->_cur = this->_cur + value->get_Length());
            return true;
        }
        return false;
    }
    
    bool Parser::ParseChar(char16_t c) {
        if((!(this->get_AtEnd()) && ((int32_t)(this->_src->get_Chars(this->_cur)) ==  (int32_t)(c)))) 
        {
            this->_cur++;
            return true;
        }
        return false;
    }
    
    bool Parser::ParseOptDot() {
        if(this->get_AtEnd()) 
        {
            return false;
        }
        if(((int32_t)(this->_src->get_Chars(this->_cur)) ==  46)) 
        {
            this->_cur++;
            return true;
        }
        return false;
    }
    
    void Parser::ParseColon(bool optional) {
        if(!(this->get_AtEnd())) 
        {
            if(((int32_t)(this->_src->get_Chars(this->_cur)) ==  58)) 
            {
                this->_cur++;
            }
             else 
            {
                if(!(optional)) 
                {
                    SetParseError(ParseError::Format3);
                }
            }
        }
    }
    
    int64_t Parser::ParseTicks() {
        int64_t mag = 1000000L;
        int64_t res = 0L;
        bool digitseen = false;
        while((((mag > 0L) && !(this->get_AtEnd())) && Char::IsDigit2(this->_src, this->_cur))) {
            res = (res + ((int64_t)(((int32_t)(this->_src->get_Chars(this->_cur)) - 48)) * mag));
            this->_cur++;
            mag = (mag / 10L);
            digitseen = true;
        }
        if(!(digitseen)) 
        {
            SetParseError(ParseError::Format3);
        }
         else 
        {
            if((!(this->get_AtEnd()) && Char::IsDigit2(this->_src, this->_cur))) 
            {
                SetParseError(ParseError::Overflow);
            }
        }
        this->parsed_ticks = true;
        return res;
    }
    
    int64_t Parser::ParseTicksExact(int32_t digits_count, int32_t max_digits_count) {
        int64_t mag = 1000000L;
        int64_t res = 0L;
        int32_t count = 0;
        while((((mag > 0L) && !(this->get_AtEnd())) && Char::IsDigit2(this->_src, this->_cur))) {
            res = (res + ((int64_t)(((int32_t)(this->_src->get_Chars(this->_cur)) - 48)) * mag));
            this->_cur++;
            count++;
            mag = (mag / 10L);
        }
        if((((digits_count > 0) && (count != digits_count)) || (count > max_digits_count))) 
        {
            SetParseError(ParseError::Format3);
        }
        return res;
    }
    
    void Parser::SetParseError(ParseError error) {
        if(((int32_t)(this->parse_error) != 0)) 
        {
            return;
        }
        this->parse_error = error;
    }
    
    bool Parser::CheckParseSuccess(bool tryParse) {
        if(((int32_t)(this->parse_error) ==  2)) 
        {
            if(tryParse) 
            {
                return false;
            }
            throw cli::gcnew<OverflowException>(Locale::GetText(_T("Invalid time data.")));
        }
        if(((int32_t)(this->parse_error) ==  1)) 
        {
            if(tryParse) 
            {
                return false;
            }
            throw cli::gcnew<FormatException>(Locale::GetText(_T("Invalid format for TimeSpan.Parse.")));
        }
        return true;
    }
    
    bool Parser::Execute(bool tryParse, TimeSpan result) {
        bool sign;
        int32_t value1, value2, value3, value4;
        int32_t days, hours, minutes, seconds;
        int64_t ticks = 0L;
        result = (*TimeSpan::Zero);
        value1 = value2 = value3 = value4 = 0;
        days = hours = minutes = seconds = 0;
        Reset();
        ParseWhiteSpace();
        sign = ParseSign();
        value1 = ParseInt(false);
        if(!(ParseOptDaysSeparator())) 
        {
            ParseColon(false);
        }
        int32_t p = this->_cur;
        value2 = ParseInt(true);
        value3 = value4 = 0;
        if((p < this->_cur)) 
        {
            ParseColon(true);
            value3 = ParseInt(true);
            ParseColon(true);
            value4 = ParseInt(true);
        }
        if(ParseOptDecimalSeparator()) 
        {
            ticks = ParseTicks();
        }
        ParseWhiteSpace();
        if(!(this->get_AtEnd())) 
        {
            SetParseError(ParseError::Format3);
        }
        if(this->Exact) 
        {
            if(((this->UseColonAsDaySeparator && this->parsed_days_separator) || (this->AllMembersRequired && ((this->parsed_numbers_count < 4) || !(this->parsed_ticks))))) 
            {
                SetParseError(ParseError::Format3);
            }
        }
        switch(this->parsed_numbers_count) {
            case 1: case_894: {
                days = value1;
                break;
            }
            case 2: case_895: {
                if(this->parsed_days_separator) 
                {
                    SetParseError(ParseError::Format3);
                }
                 else 
                {
                    hours = value1;
                    minutes = value2;
                }
                break;
            }
            case 3: case_896: {
                if((this->parsed_days_separator || (value1 > 23))) 
                {
                    days = value1;
                    hours = value2;
                    minutes = value3;
                }
                 else 
                {
                    hours = value1;
                    minutes = value2;
                    seconds = value3;
                }
                break;
            }
            case 4: case_897: {
                if((!(this->UseColonAsDaySeparator) && !(this->parsed_days_separator))) 
                {
                    SetParseError(ParseError::Format3);
                }
                 else 
                {
                    days = value1;
                    hours = value2;
                    minutes = value3;
                    seconds = value4;
                }
                break;
            }
        }
        if((((hours > 23) || (minutes > 59)) || (seconds > 59))) 
        {
            SetParseError(ParseError::Overflow);
        }
        if(!(CheckParseSuccess(tryParse))) 
        {
            return false;
        }
        int64_t t;
        if(!(TimeSpan::CalculateTicks(days, hours, minutes, seconds, 0, false, t))) 
        {
            return false;
        }
        try {
            t = cli::checked(sign ? (-(t) - ticks) : (t + ticks));
        }
        catch(OverflowException*) {
            if(tryParse) 
            {
                return false;
            }
            throw ;
        }
        result = cli::ctor<TimeSpan>(t);
        return true;
    }
    
    bool Parser::ExecuteWithFormat(String* format, Globalization::TimeSpanStyles style, bool tryParse, TimeSpan result) {
        int32_t days, hours, minutes, seconds;
        int64_t ticks;
        FormatElement format_element;
        days = hours = minutes = seconds = -1;
        ticks = -1L;
        result = (*TimeSpan::Zero);
        Reset();
        FormatParser *format_parser = cli::gcnew<FormatParser>(format);
        for(; ; ){
            if(((int32_t)(this->parse_error) != 0)) 
            {
                break;
            }
            if(format_parser->get_AtEnd()) 
            {
                break;
            }
            format_element = format_parser->GetNextElement();
            switch(format_element->Type2) {
                case FormatElementType::Days: case_898: {
                    if((days != -1)) 
                    {
                        goto case_906;
                    }
                    days = ParseIntExact(format_element->IntValue, 8);
                    break;
                }
                case FormatElementType::Hours: case_899: {
                    if((hours != -1)) 
                    {
                        goto case_906;
                    }
                    hours = ParseIntExact(format_element->IntValue, 2);
                    break;
                }
                case FormatElementType::Minutes: case_900: {
                    if((minutes != -1)) 
                    {
                        goto case_906;
                    }
                    minutes = ParseIntExact(format_element->IntValue, 2);
                    break;
                }
                case FormatElementType::Seconds: case_901: {
                    if((seconds != -1)) 
                    {
                        goto case_906;
                    }
                    seconds = ParseIntExact(format_element->IntValue, 2);
                    break;
                }
                case FormatElementType::Ticks: case_902: {
                    if((ticks != -1L)) 
                    {
                        goto case_906;
                    }
                    ticks = ParseTicksExact(format_element->IntValue, format_element->IntValue);
                    break;
                }
                case FormatElementType::TicksUppercase: case_903: {
                    if((ticks != -1L)) 
                    {
                        goto case_906;
                    }
                    ticks = ParseTicksExact(0, format_element->IntValue);
                    break;
                }
                case FormatElementType::Literal: case_904: {
                    if(!(ParseLiteral(format_element->StringValue))) 
                    {
                        SetParseError(ParseError::Format3);
                    }
                    break;
                }
                case FormatElementType::EscapedChar: case_905: {
                    if(!(ParseChar(format_element->CharValue))) 
                    {
                        SetParseError(ParseError::Format3);
                    }
                    break;
                }
                case FormatElementType::Error: case_906: {
                    SetParseError(ParseError::Format3);
                    break;
                }
            }
        }
        if((days ==  -1)) 
        {
            days = 0;
        }
        if((hours ==  -1)) 
        {
            hours = 0;
        }
        if((minutes ==  -1)) 
        {
            minutes = 0;
        }
        if((seconds ==  -1)) 
        {
            seconds = 0;
        }
        if((ticks ==  -1L)) 
        {
            ticks = 0L;
        }
        if((!(this->get_AtEnd()) || !(format_parser->get_AtEnd()))) 
        {
            SetParseError(ParseError::Format3);
        }
        if((((hours > 23) || (minutes > 59)) || (seconds > 59))) 
        {
            SetParseError(ParseError::Format3);
        }
        if(!(CheckParseSuccess(tryParse))) 
        {
            return false;
        }
        int64_t t;
        if(!(TimeSpan::CalculateTicks(days, hours, minutes, seconds, 0, false, t))) 
        {
            return false;
        }
        try {
            t = cli::checked(((int32_t)(style) ==  1) ? (-(t) - ticks) : (t + ticks));
        }
        catch(OverflowException*) {
            if(tryParse) 
            {
                return false;
            }
            throw ;
        }
        result = cli::ctor<TimeSpan>(t);
        return true;
    }
    
    bool Parser::get_AtEnd() {
        return (this->_cur >= this->_length);
    }
    
}
namespace System {
    
    
    void FormatParser::constructor(String* format) {
        this->format = format;
    }
    
    FormatElement FormatParser::GetNextElement() {
        FormatElement element = cli::ctor<FormatElement>();
        if(this->get_AtEnd()) 
        {
            return cli::ctor<FormatElement>(FormatElementType::End);
        }
        int32_t count = 0;
        switch(this->format->get_Chars(this->cur)) {
            case u'd': case_907: {
                count = ParseChar(u'd');
                if((count > 8)) 
                {
                    return cli::ctor<FormatElement>(FormatElementType::Error);
                }
                element->Type2 = FormatElementType::Days;
                element->IntValue = count;
                break;
            }
            case u'h': case_908: {
                count = ParseChar(u'h');
                if((count > 2)) 
                {
                    return cli::ctor<FormatElement>(FormatElementType::Error);
                }
                element->Type2 = FormatElementType::Hours;
                element->IntValue = count;
                break;
            }
            case u'm': case_909: {
                count = ParseChar(u'm');
                if((count > 2)) 
                {
                    return cli::ctor<FormatElement>(FormatElementType::Error);
                }
                element->Type2 = FormatElementType::Minutes;
                element->IntValue = count;
                break;
            }
            case u's': case_910: {
                count = ParseChar(u's');
                if((count > 2)) 
                {
                    return cli::ctor<FormatElement>(FormatElementType::Error);
                }
                element->Type2 = FormatElementType::Seconds;
                element->IntValue = count;
                break;
            }
            case u'f': case_911: {
                count = ParseChar(u'f');
                if((count > 7)) 
                {
                    return cli::ctor<FormatElement>(FormatElementType::Error);
                }
                element->Type2 = FormatElementType::Ticks;
                element->IntValue = count;
                break;
            }
            case u'F': case_912: {
                count = ParseChar(u'F');
                if((count > 7)) 
                {
                    return cli::ctor<FormatElement>(FormatElementType::Error);
                }
                element->Type2 = FormatElementType::TicksUppercase;
                element->IntValue = count;
                break;
            }
            case u'%': case_913: {
                this->cur++;
                if(this->get_AtEnd()) 
                {
                    return cli::ctor<FormatElement>(FormatElementType::Error);
                }
                if(((int32_t)(this->format->get_Chars(this->cur)) ==  100)) 
                {
                    goto case_907;
                }
                 else 
                {
                    if(((int32_t)(this->format->get_Chars(this->cur)) ==  104)) 
                    {
                        goto case_908;
                    }
                     else 
                    {
                        if(((int32_t)(this->format->get_Chars(this->cur)) ==  109)) 
                        {
                            goto case_909;
                        }
                         else 
                        {
                            if(((int32_t)(this->format->get_Chars(this->cur)) ==  115)) 
                            {
                                goto case_910;
                            }
                             else 
                            {
                                if(((int32_t)(this->format->get_Chars(this->cur)) ==  102)) 
                                {
                                    goto case_911;
                                }
                                 else 
                                {
                                    if(((int32_t)(this->format->get_Chars(this->cur)) ==  70)) 
                                    {
                                        goto case_912;
                                    }
                                }
                            }
                        }
                    }
                }
                return cli::ctor<FormatElement>(FormatElementType::Error);
            }
            case u'\'': case_914: {
                String *literal = ParseLiteral();
                if((literal ==  nullptr)) 
                {
                    return cli::ctor<FormatElement>(FormatElementType::Error);
                }
                element->Type2 = FormatElementType::Literal;
                element->StringValue = literal;
                break;
            }
            case u'\\': case_915: {
                char16_t escaped_char = ParseEscapedChar();
                if(((int32_t)(escaped_char) ==  0)) 
                {
                    return cli::ctor<FormatElement>(FormatElementType::Error);
                }
                element->Type2 = FormatElementType::EscapedChar;
                element->CharValue = escaped_char;
                break;
            }
            default: case_916: {
                return cli::ctor<FormatElement>(FormatElementType::Error);
            }
        }
        return element;
    }
    
    int32_t FormatParser::ParseChar(char16_t c) {
        int32_t count = 0;
        while((!(this->get_AtEnd()) && ((int32_t)(this->format->get_Chars(this->cur)) ==  (int32_t)(c)))) {
            this->cur++;
            count++;
        }
        return count;
    }
    
    char16_t FormatParser::ParseEscapedChar() {
        if((this->get_AtEnd() || ((int32_t)(this->format->get_Chars(this->cur)) != 92))) 
        {
            return u'\x0';
        }
        this->cur++;
        if(this->get_AtEnd()) 
        {
            return u'\x0';
        }
        return this->format->get_Chars(this->cur++);
    }
    
    String* FormatParser::ParseLiteral() {
        int32_t start;
        int32_t count = 0;
        if((this->get_AtEnd() || ((int32_t)(this->format->get_Chars(this->cur)) != 39))) 
        {
            return nullptr;
        }
        start = ++this->cur;
        while((!(this->get_AtEnd()) && ((int32_t)(this->format->get_Chars(this->cur)) != 39))) {
            this->cur++;
            count++;
        }
        if((!(this->get_AtEnd()) && ((int32_t)(this->format->get_Chars(this->cur)) ==  39))) 
        {
            this->cur++;
            return this->format->Substring2(start, count);
        }
        return nullptr;
    }
    
    bool FormatParser::get_AtEnd() {
        return (this->cur >= this->format->get_Length());
    }
    
}
namespace System {
    
    TimeZone*  TimeZone::currentTimeZone;
    Object*  TimeZone::tz_lock;
    int64_t  TimeZone::timezone_check;
    
    TimeZone::TimeZone()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void TimeZone::constructor() {
    }
    
    void TimeZone::static_constructor() {
    }
    
    bool TimeZone::IsDaylightSavingTime_3bdf7ceedb2508ce(DateTime time) {
        return IsDaylightSavingTime2(time, GetDaylightChanges_7aec528d6e066e(time->get_Year()));
    }
    
    bool TimeZone::IsDaylightSavingTime2(DateTime time, Globalization::DaylightTime* daylightTimes) {
        if((daylightTimes ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("daylightTimes"));
        }
        if((daylightTimes->get_Start()->get_Ticks() ==  daylightTimes->get_End()->get_Ticks())) 
        {
            return false;
        }
        if((daylightTimes->get_Start()->get_Ticks() < daylightTimes->get_End()->get_Ticks())) 
        {
            if(((daylightTimes->get_Start()->get_Ticks() < time->get_Ticks()) && (daylightTimes->get_End()->get_Ticks() > time->get_Ticks()))) 
            {
                return true;
            }
        }
         else 
        {
            if(((time->get_Year() ==  daylightTimes->get_Start()->get_Year()) && (time->get_Year() ==  daylightTimes->get_End()->get_Year()))) 
            {
                if(((time->get_Ticks() < daylightTimes->get_End()->get_Ticks()) || (time->get_Ticks() > daylightTimes->get_Start()->get_Ticks()))) 
                {
                    return true;
                }
            }
        }
        return false;
    }
    
    DateTime TimeZone::ToLocalTime_727a1d453c597b66(DateTime time) {
        if(((int32_t)(time->get_Kind()) ==  2)) 
        {
            return time;
        }
        TimeSpan utcOffset = GetUtcOffset_7ede31ceb7855151(time);
        if((utcOffset->get_Ticks() > 0L)) 
        {
            if(DateTime::op_LessThan(DateTime::op_Subtraction2((*DateTime::MaxValue), utcOffset), time)) 
            {
                return DateTime::SpecifyKind((*DateTime::MaxValue), DateTimeKind::Local);
            }
        }
         else 
        {
            if((utcOffset->get_Ticks() < 0L)) 
            {
                if(((time->get_Ticks() + utcOffset->get_Ticks()) < (*DateTime::MinValue)->get_Ticks())) 
                {
                    return DateTime::SpecifyKind((*DateTime::MinValue), DateTimeKind::Local);
                }
            }
        }
        DateTime local = time->Add(utcOffset);
        Globalization::DaylightTime *dlt = GetDaylightChanges_7aec528d6e066e(time->get_Year());
        if((dlt->get_Delta()->get_Ticks() ==  0L)) 
        {
            return DateTime::SpecifyKind(local, DateTimeKind::Local);
        }
        if((DateTime::op_LessThan(local, dlt->get_End()) && DateTime::op_LessThanOrEqual(dlt->get_End()->Subtract2(dlt->get_Delta()), local))) 
        {
            return DateTime::SpecifyKind(local, DateTimeKind::Local);
        }
        TimeSpan localOffset = GetUtcOffset_7ede31ceb7855151(local);
        return DateTime::SpecifyKind(time->Add(localOffset), DateTimeKind::Local);
    }
    
    DateTime TimeZone::ToUniversalTime_a2fdcc18b24d9d81(DateTime time) {
        if(((int32_t)(time->get_Kind()) ==  1)) 
        {
            return time;
        }
        TimeSpan offset = GetUtcOffset_7ede31ceb7855151(time);
        if((offset->get_Ticks() < 0L)) 
        {
            if(DateTime::op_LessThan(DateTime::op_Addition((*DateTime::MaxValue), offset), time)) 
            {
                return DateTime::SpecifyKind((*DateTime::MaxValue), DateTimeKind::Utc);
            }
        }
         else 
        {
            if((offset->get_Ticks() > 0L)) 
            {
                if(DateTime::op_GreaterThan(DateTime::op_Addition((*DateTime::MinValue), offset), time)) 
                {
                    return DateTime::SpecifyKind((*DateTime::MinValue), DateTimeKind::Utc);
                }
            }
        }
        return DateTime::SpecifyKind(cli::ctor<DateTime>((time->get_Ticks() - offset->get_Ticks())), DateTimeKind::Utc);
    }
    
    TimeSpan TimeZone::GetLocalTimeDiff(DateTime time) {
        return GetLocalTimeDiff2(time, GetUtcOffset_7ede31ceb7855151(time));
    }
    
    TimeSpan TimeZone::GetLocalTimeDiff2(DateTime time, TimeSpan utc_offset) {
        Globalization::DaylightTime *dlt = GetDaylightChanges_7aec528d6e066e(time->get_Year());
        if((dlt->get_Delta()->get_Ticks() ==  0L)) 
        {
            return utc_offset;
        }
        DateTime local = time->Add(utc_offset);
        if((DateTime::op_LessThan(local, dlt->get_End()) && DateTime::op_LessThanOrEqual(dlt->get_End()->Subtract2(dlt->get_Delta()), local))) 
        {
            return utc_offset;
        }
        if((DateTime::op_GreaterThanOrEqual(local, dlt->get_Start()) && DateTime::op_GreaterThan(dlt->get_Start()->Add(dlt->get_Delta()), local))) 
        {
            return TimeSpan::op_Subtraction(utc_offset, dlt->get_Delta());
        }
        return GetUtcOffset_7ede31ceb7855151(local);
    }
    
    TimeZone* TimeZone::get_CurrentTimeZone() {
        int64_t now = DateTime::GetNow();
        TimeZone *tz;
        {
            cli::lock_guard{tz_lock};
            if(((currentTimeZone ==  nullptr) || ((now - timezone_check) > 600000000L))) 
            {
                currentTimeZone = cli::gcnew<CurrentSystemTimeZone>(now);
                timezone_check = now;
            }
            tz = currentTimeZone;
        }
        return tz;
    }
    
}
namespace System {
    
    int32_t  CurrentSystemTimeZone::this_year;
    Globalization::DaylightTime*  CurrentSystemTimeZone::this_year_dlt;
    
    void CurrentSystemTimeZone::constructor() {
    }
    
    void CurrentSystemTimeZone::constructor(int64_t lnow) {
        cli::array<int64_t> *data;
        cli::array<String*> *names;
        DateTime now = cli::ctor<DateTime>(lnow);
        if(!(GetTimeZoneData(now->get_Year(), data, names))) 
        {
            throw cli::gcnew<NotSupportedException>(Locale::GetText(_T("Can\'t get timezone name.")));
        }
        this->m_standardName = Locale::GetText(names->at(0));
        this->m_daylightName = Locale::GetText(names->at(1));
        this->m_ticksOffset = data->at(2);
        Globalization::DaylightTime *dlt = GetDaylightTimeFromData(data);
        this->m_CachedDaylightChanges->Add_3f7ab157bcb41156(cli::box(now->get_Year()), dlt);
        OnDeserialization2(dlt);
    }
    
    bool CurrentSystemTimeZone::GetTimeZoneData(int32_t year, cli::array<int64_t>* data, cli::array<String*>* names) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    Globalization::DaylightTime* CurrentSystemTimeZone::GetDaylightChanges_7aec528d6e066e(int32_t year) {
        if(((year < 1) || (year > 9999))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("year"), cli::concat(cli::box(year), Locale::GetText(_T(" is not in a range between 1 and 9999."))));
        }
        if((year ==  this_year)) 
        {
            return this_year_dlt;
        }
        {
            cli::lock_guard{this->m_CachedDaylightChanges};
            Globalization::DaylightTime *dlt = cli::cast<Globalization::DaylightTime*>(this->m_CachedDaylightChanges->get_Item_d75c6e706b965758(cli::box(year)));
            if((dlt ==  nullptr)) 
            {
                cli::array<int64_t> *data;
                cli::array<String*> *names;
                if(!(GetTimeZoneData(year, data, names))) 
                {
                    throw cli::gcnew<ArgumentException>(Locale::GetText(cli::concat(_T("Can\'t get timezone data for "), cli::box(year))));
                }
                dlt = GetDaylightTimeFromData(data);
                this->m_CachedDaylightChanges->Add_3f7ab157bcb41156(cli::box(year), dlt);
            }
            return dlt;
        }
    }
    
    TimeSpan CurrentSystemTimeZone::GetUtcOffset_7ede31ceb7855151(DateTime time) {
        if(TimeZone::IsDaylightSavingTime_3bdf7ceedb2508ce(time)) 
        {
            return this->utcOffsetWithDLS;
        }
        return this->utcOffsetWithOutDLS;
    }
    
    void CurrentSystemTimeZone::OnDeserialization(Object* sender) {
        OnDeserialization2(nullptr);
    }
    
    void CurrentSystemTimeZone::OnDeserialization2(Globalization::DaylightTime* dlt) {
        if((dlt ==  nullptr)) 
        {
            cli::array<int64_t> *data;
            cli::array<String*> *names;
            this_year = DateTime::get_Now()->get_Year();
            if(!(GetTimeZoneData(this_year, data, names))) 
            {
                throw cli::gcnew<ArgumentException>(Locale::GetText(cli::concat(_T("Can\'t get timezone data for "), cli::box(this_year))));
            }
            dlt = GetDaylightTimeFromData(data);
        }
         else 
        {
            this_year = dlt->get_Start()->get_Year();
        }
        this->utcOffsetWithOutDLS = cli::ctor<TimeSpan>(this->m_ticksOffset);
        this->utcOffsetWithDLS = cli::ctor<TimeSpan>((this->m_ticksOffset + dlt->get_Delta()->get_Ticks()));
        this_year_dlt = dlt;
    }
    
    Globalization::DaylightTime* CurrentSystemTimeZone::GetDaylightTimeFromData(cli::array<int64_t>* data) {
        return cli::gcnew<Globalization::DaylightTime>(cli::ctor<DateTime>(data->at(0)), cli::ctor<DateTime>(data->at(1)), cli::ctor<TimeSpan>(data->at(3)));
    }
    
    String* CurrentSystemTimeZone::get_DaylightName_2eca7f1486446145() {
        return this->m_daylightName;
    }
    
    String* CurrentSystemTimeZone::get_StandardName_2e2b3e3d784ffee2() {
        return this->m_standardName;
    }
    
}
namespace System {
    
    
    void TimeZoneNotFoundException::constructor() {
    }
    
    void TimeZoneNotFoundException::constructor(String* message) {
    }
    
    void TimeZoneNotFoundException::constructor(String* message, Exception* innerException) {
    }
    
    void TimeZoneNotFoundException::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
    }
    
}
namespace System {
    
    
}
namespace System {
    
    
}
namespace System {
    
    
}
namespace System {
    
    
}
namespace System {
    
    
}
namespace System {
    
    
}
namespace System {
    
    
}
namespace System {
    
    
}
namespace System {
    
    
}
namespace System {
    
    char16_t  Type::Delimiter;
    cli::array<Type*>*  Type::EmptyTypes;
    Reflection::MemberFilter*  Type::FilterAttribute;
    Reflection::MemberFilter*  Type::FilterName;
    Reflection::MemberFilter*  Type::FilterNameIgnoreCase;
    Object*  Type::Missing2;
    
    Type::Type()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void Type::constructor() {
    }
    
    void Type::static_constructor() {
    }
    
    bool Type::FilterName_impl(Reflection::MemberInfo* m, Object* filterCriteria) {
        String *name = cli::cast<String*>(filterCriteria);
        if(((name ==  nullptr) || (name->get_Length() ==  0))) 
        {
            return false;
        }
        if(((int32_t)(name->get_Chars((name->get_Length() - 1))) ==  42)) 
        {
            return (String::CompareOrdinal2(name, 0, m->get_Name_50fad5fa936c3ae2(), 0, (name->get_Length() - 1)) ==  0);
        }
        return name->Equals5(m->get_Name_50fad5fa936c3ae2());
    }
    
    bool Type::FilterNameIgnoreCase_impl(Reflection::MemberInfo* m, Object* filterCriteria) {
        String *name = cli::cast<String*>(filterCriteria);
        if(((name ==  nullptr) || (name->get_Length() ==  0))) 
        {
            return false;
        }
        if(((int32_t)(name->get_Chars((name->get_Length() - 1))) ==  42)) 
        {
            return (String::Compare8(name, 0, m->get_Name_50fad5fa936c3ae2(), 0, (name->get_Length() - 1), StringComparison::OrdinalIgnoreCase) ==  0);
        }
        return String::Equals6(name, m->get_Name_50fad5fa936c3ae2(), StringComparison::OrdinalIgnoreCase);
    }
    
    bool Type::FilterAttribute_impl(Reflection::MemberInfo* m, Object* filterCriteria) {
        int32_t flags = cli::cast<IConvertible*>(filterCriteria)->ToInt32_9e7108d4c09b7e42(nullptr);
        if(cli::is<Reflection::MethodInfo>(m)) 
        {
            return (((int32_t)(cli::cast<Reflection::MethodInfo*>(m)->get_Attributes_b3976e6a55c088be()) & flags) != 0);
        }
        if(cli::is<Reflection::FieldInfo>(m)) 
        {
            return (((int32_t)(cli::cast<Reflection::FieldInfo*>(m)->get_Attributes_ecc2fe2071b9c047()) & flags) != 0);
        }
        if(cli::is<Reflection::PropertyInfo>(m)) 
        {
            return (((int32_t)(cli::cast<Reflection::PropertyInfo*>(m)->get_Attributes_44d275d722218b81()) & flags) != 0);
        }
        if(cli::is<Reflection::EventInfo>(m)) 
        {
            return (((int32_t)(cli::cast<Reflection::EventInfo*>(m)->get_Attributes_3412d62533ff880()) & flags) != 0);
        }
        return false;
    }
    
    bool Type::Equals_ed975d2f4a7d193e(Object* o) {
        return Equals_f28141a5881cf9e3(cli::as<Type*>(o));
    }
    
    bool Type::Equals_f28141a5881cf9e3(Type* o) {
        if((cli::cast<Object*>(o) ==  cli::cast<Object*>(this))) 
        {
            return true;
        }
        if((cli::cast<Object*>(o) ==  nullptr)) 
        {
            return false;
        }
        Type *me = this->get_UnderlyingSystemType_9ccb7bb8385521f6();
        if((cli::cast<Object*>(me) ==  nullptr)) 
        {
            return false;
        }
        o = o->get_UnderlyingSystemType_9ccb7bb8385521f6();
        if((cli::cast<Object*>(o) ==  nullptr)) 
        {
            return false;
        }
        if((cli::cast<Object*>(o) ==  cli::cast<Object*>(this))) 
        {
            return true;
        }
        return me->EqualsInternal(o);
    }
    
    Type* Type::GetEnumUnderlyingType_54ea3579073894ef() {
        if(!(this->get_IsEnum_bc85ea7b0a749db())) 
        {
            throw cli::gcnew<ArgumentException>(_T("Type is not an enumeration"), _T("enumType"));
        }
        cli::array<Reflection::FieldInfo*> *fields = GetFields_369be5ac49d99f8((Reflection::BindingFlags)52L);
        if(((fields ==  nullptr) || (fields->get_Length() != 1))) 
        {
            throw cli::gcnew<ArgumentException>(_T("An enum must have exactly one instance field"), _T("enumType"));
        }
        return fields->at(0)->get_FieldType_1dab4079098d7fff();
    }
    
    cli::array<String*>* Type::GetEnumNames_1cca76c1dc3e4732() {
        if(!(this->get_IsEnum_bc85ea7b0a749db())) 
        {
            throw cli::gcnew<ArgumentException>(_T("Type is not an enumeration"), _T("enumType"));
        }
        cli::array<Reflection::FieldInfo*> *fields = GetFields_369be5ac49d99f8((Reflection::BindingFlags)56L);
        cli::array<String*> *result = (new cli::array<String*>(fields->get_Length()));
        for(int32_t i = 0; (i < fields->get_Length()); ++i) {
            result->at(i) = fields->at(i)->get_Name_50fad5fa936c3ae2();
        }
        return result;
    }
    
    NotImplementedException* Type::CreateNIE() {
        return cli::gcnew<NotImplementedException>();
    }
    
    Array* Type::GetEnumValues_bdf747371fce41cc() {
        if(!(this->get_IsEnum_bc85ea7b0a749db())) 
        {
            throw cli::gcnew<ArgumentException>(_T("Type is not an enumeration"), _T("enumType"));
        }
        throw CreateNIE();
    }
    
    bool Type::IsValidEnumType(Type* type) {
        return ((((type->get_IsPrimitive() && op_Inequality2(type, cli::typeof<Type>::info)) && op_Inequality2(type, cli::typeof<Type>::info)) && op_Inequality2(type, cli::typeof<Type>::info)) || type->get_IsEnum_bc85ea7b0a749db());
    }
    
    String* Type::GetEnumName_f9c4e9ff4bd1a988(Object* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentException>(_T("Value is null"), _T("value"));
        }
        if(!(IsValidEnumType(value->GetType()))) 
        {
            throw cli::gcnew<ArgumentException>(_T("Value is not the enum or a valid enum underlying type"), _T("value"));
        }
        if(!(this->get_IsEnum_bc85ea7b0a749db())) 
        {
            throw cli::gcnew<ArgumentException>(_T("Type is not an enumeration"), _T("enumType"));
        }
        Object *obj = nullptr;
        cli::array<Reflection::FieldInfo*> *fields = GetFields_369be5ac49d99f8((Reflection::BindingFlags)56L);
        for(int32_t i = 0; (i < fields->get_Length()); ++i){
            Object *fv = fields->at(i)->GetValue_57ad13b528e8b8a5(nullptr);
            if((obj ==  nullptr)) 
            {
                try {
                    obj = Enum::ToObject5(fv->GetType(), value);
                }
                catch(OverflowException*) {
                    return nullptr;
                }
                catch(InvalidCastException*) {
                    throw cli::gcnew<ArgumentException>(_T("Value is not valid"), _T("value"));
                }
            }
            if(fv->Equals_ed975d2f4a7d193e(obj)) 
            {
                return fields->at(i)->get_Name_50fad5fa936c3ae2();
            }
        }
        return nullptr;
    }
    
    bool Type::IsEnumDefined_28980f0c7a4454f(Object* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentException>(_T("Value is null"), _T("value"));
        }
        if(!(this->get_IsEnum_bc85ea7b0a749db())) 
        {
            throw cli::gcnew<ArgumentException>(_T("Type is not an enumeration"), _T("enumType"));
        }
        Type *vt = value->GetType();
        if((!(IsValidEnumType(vt)) && op_Inequality2(vt, cli::typeof<Type>::info))) 
        {
            throw cli::gcnew<InvalidOperationException>(_T("Value is not the enum or a valid enum underlying type"));
        }
        cli::array<Reflection::FieldInfo*> *fields = GetFields_369be5ac49d99f8((Reflection::BindingFlags)56L);
        if(cli::is<String>(value)) 
        {
            for(int32_t i = 0; (i < fields->get_Length()); ++i){
                if(fields->at(i)->get_Name_50fad5fa936c3ae2()->Equals_ed975d2f4a7d193e(value)) 
                {
                    return true;
                }
            }
        }
         else 
        {
            if((op_Inequality2(vt, this) && op_Inequality2(vt, GetEnumUnderlyingType_54ea3579073894ef()))) 
            {
                throw cli::gcnew<ArgumentException>(_T("Value is not the enum or a valid enum underlying type"), _T("value"));
            }
            Object *obj = nullptr;
            for(int32_t i = 0; (i < fields->get_Length()); ++i){
                Object *fv = fields->at(i)->GetValue_57ad13b528e8b8a5(nullptr);
                if((obj ==  nullptr)) 
                {
                    try {
                        obj = Enum::ToObject5(fv->GetType(), value);
                    }
                    catch(OverflowException*) {
                        return false;
                    }
                    catch(InvalidCastException*) {
                        throw cli::gcnew<ArgumentException>(_T("Value is not valid"), _T("value"));
                    }
                }
                if(fv->Equals_ed975d2f4a7d193e(obj)) 
                {
                    return true;
                }
            }
        }
        return false;
    }
    
    Type* Type::GetType(String* typeName, Func2<Reflection::AssemblyName*, Reflection::Assembly*>* assemblyResolver, Func3<Reflection::Assembly*, String*, bool, Type*>* typeResolver) {
        return GetType3(typeName, assemblyResolver, typeResolver, false, false);
    }
    
    Type* Type::GetType2(String* typeName, Func2<Reflection::AssemblyName*, Reflection::Assembly*>* assemblyResolver, Func3<Reflection::Assembly*, String*, bool, Type*>* typeResolver, bool throwOnError) {
        return GetType3(typeName, assemblyResolver, typeResolver, throwOnError, false);
    }
    
    Type* Type::GetType3(String* typeName, Func2<Reflection::AssemblyName*, Reflection::Assembly*>* assemblyResolver, Func3<Reflection::Assembly*, String*, bool, Type*>* typeResolver, bool throwOnError, bool ignoreCase) {
        TypeSpec *spec = TypeSpec::Parse(typeName);
        return spec->Resolve(assemblyResolver, typeResolver, throwOnError, ignoreCase);
    }
    
    bool Type::EqualsInternal(Type* type) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    Type* Type::internal_from_handle(void* handle) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    Type* Type::internal_from_name(String* name, bool throwOnError, bool ignoreCase) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    Type* Type::GetType4(String* typeName) {
        if((typeName ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("TypeName"));
        }
        return internal_from_name(typeName, false, false);
    }
    
    Type* Type::GetType5(String* typeName, bool throwOnError) {
        if((typeName ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("TypeName"));
        }
        Type *type = internal_from_name(typeName, throwOnError, false);
        if((throwOnError && op_Equality2(type, nullptr))) 
        {
            throw cli::gcnew<TypeLoadException>(cli::concat(_T("Error loading \'"), typeName));
        }
        return type;
    }
    
    Type* Type::GetType6(String* typeName, bool throwOnError, bool ignoreCase) {
        if((typeName ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("TypeName"));
        }
        Type *t = internal_from_name(typeName, throwOnError, ignoreCase);
        if((throwOnError && op_Equality2(t, nullptr))) 
        {
            throw cli::gcnew<TypeLoadException>(cli::concat(_T("Error loading \'"), typeName));
        }
        return t;
    }
    
    cli::array<Type*>* Type::GetTypeArray(cli::array<Object*>* args) {
        if((args ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("args"));
        }
        cli::array<Type*> *ret;
        ret = (new cli::array<Type*>(args->get_Length()));
        for(int32_t i = 0; (i < args->get_Length()); ++i) {
            ret->at(i) = args->at(i)->GetType();
        }
        return ret;
    }
    
    TypeCode Type::GetTypeCodeInternal(Type* type) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    TypeCode Type::GetTypeCodeImpl_20721b259890e678() {
        Type *type = this;
        if(cli::is<MonoType>(type)) 
        {
            return GetTypeCodeInternal(type);
        }
        if(cli::is<Reflection::Emit::TypeBuilder>(type)) 
        {
            return cli::cast<Reflection::Emit::TypeBuilder*>(type)->GetTypeCodeInternal2();
        }
        type = type->get_UnderlyingSystemType_9ccb7bb8385521f6();
        if(!(type->get_IsSystemType())) 
        {
            return TypeCode::Object2;
        }
         else 
        {
            return GetTypeCodeInternal(type);
        }
    }
    
    TypeCode Type::GetTypeCode(Type* type) {
        if(op_Equality2(type, nullptr)) 
        {
            return TypeCode::Empty;
        }
        return type->GetTypeCodeImpl_20721b259890e678();
    }
    
    Type* Type::GetTypeFromCLSID(Guid clsid) {
        throw cli::gcnew<NotImplementedException>();
    }
    
    Type* Type::GetTypeFromCLSID2(Guid clsid, bool throwOnError) {
        throw cli::gcnew<NotImplementedException>();
    }
    
    Type* Type::GetTypeFromCLSID3(Guid clsid, String* server) {
        throw cli::gcnew<NotImplementedException>();
    }
    
    Type* Type::GetTypeFromCLSID4(Guid clsid, String* server, bool throwOnError) {
        throw cli::gcnew<NotImplementedException>();
    }
    
    Type* Type::GetTypeFromHandle(RuntimeTypeHandle handle) {
        if(::System::IntPtr::op_Equality(handle->get_Value(), (*::System::IntPtr::Zero))) 
        {
            return nullptr;
        }
        return internal_from_handle(handle->get_Value());
    }
    
    Type* Type::GetTypeFromProgID(String* progID) {
        throw cli::gcnew<NotImplementedException>();
    }
    
    Type* Type::GetTypeFromProgID2(String* progID, bool throwOnError) {
        throw cli::gcnew<NotImplementedException>();
    }
    
    Type* Type::GetTypeFromProgID3(String* progID, String* server) {
        throw cli::gcnew<NotImplementedException>();
    }
    
    Type* Type::GetTypeFromProgID4(String* progID, String* server, bool throwOnError) {
        throw cli::gcnew<NotImplementedException>();
    }
    
    RuntimeTypeHandle Type::GetTypeHandle(Object* o) {
        if((o ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>();
        }
        return o->GetType()->get_TypeHandle_a14995fa9102936b();
    }
    
    bool Type::type_is_subtype_of(Type* a, Type* b, bool check_interfaces) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool Type::type_is_assignable_from(Type* a, Type* b) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    Type* Type::GetType7() {
        return Reflection::MemberInfo::GetType();
    }
    
    bool Type::IsSubclassOf_5d7dbe0215a30fda(Type* c) {
        if((op_Equality2(c, nullptr) || op_Equality2(c, this))) 
        {
            return false;
        }
        if(this->get_IsSystemType()) 
        {
            return (c->get_IsSystemType() && type_is_subtype_of(this, c, false));
        }
        for(Type *type = this->get_BaseType_6a0646ae880055f6(); op_Inequality2(type, nullptr); type = type->get_BaseType_6a0646ae880055f6()) {
            if(op_Equality2(type, c)) 
            {
                return true;
            }
        }
        return false;
    }
    
    cli::array<Type*>* Type::FindInterfaces_7c9fc57cf4c9255f(Reflection::TypeFilter* filter, Object* filterCriteria) {
        if((filter ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("filter"));
        }
        Collections::Generic::List<Type*> *ifaces = cli::gcnew<Collections::Generic::List<Type*>>();
        for(auto tmp_191 : GetInterfaces_52a89380e2c4a725()) {
            auto iface = cli::cast<Type*>(tmp_191);
            {
                if(filter->Invoke(iface, filterCriteria)) 
                {
                    ifaces->Add(iface);
                }
            }
        }
        return ifaces->ToArray();
    }
    
    Type* Type::GetInterface(String* name) {
        return GetInterface_55c1d0ec3ece6104(name, false);
    }
    
    void Type::GetInterfaceMapData(Type* t, Type* iface, cli::array<Reflection::MethodInfo*>* targets, cli::array<Reflection::MethodInfo*>* methods) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    Reflection::InterfaceMapping Type::GetInterfaceMap_26193b1c1167fea4(Type* interfaceType) {
        if(!(this->get_IsSystemType())) 
        {
            throw cli::gcnew<NotSupportedException>(_T("Derived classes must provide an implementation."));
        }
        if(op_Equality2(interfaceType, nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("interfaceType"));
        }
        if(!(interfaceType->get_IsSystemType())) 
        {
            throw cli::gcnew<ArgumentException>(_T("interfaceType"), _T("Type is an user type"));
        }
        Reflection::InterfaceMapping res;
        if(!(interfaceType->get_IsInterface())) 
        {
            throw cli::gcnew<ArgumentException>(Locale::GetText(_T("Argument must be an interface.")), _T("interfaceType"));
        }
        if(this->get_IsInterface()) 
        {
            throw cli::gcnew<ArgumentException>(_T("\'this\' type cannot be an interface itself"));
        }
        res->TargetType = this;
        res->InterfaceType = interfaceType;
        GetInterfaceMapData(this, interfaceType, res->TargetMethods, res->InterfaceMethods);
        if((res->TargetMethods ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentException>(Locale::GetText(_T("Interface not found")), _T("interfaceType"));
        }
        return res;
    }
    
    bool Type::IsAssignableFrom_e3aa32d778e63a90(Type* c) {
        if(op_Equality2(c, nullptr)) 
        {
            return false;
        }
        if(Equals_f28141a5881cf9e3(c)) 
        {
            return true;
        }
        if(cli::is<Reflection::Emit::TypeBuilder>(c)) 
        {
            return cli::cast<Reflection::Emit::TypeBuilder*>(c)->IsAssignableTo(this);
        }
        if(!(this->get_IsSystemType())) 
        {
            Type *systemType = this->get_UnderlyingSystemType_9ccb7bb8385521f6();
            if(!(systemType->get_IsSystemType())) 
            {
                return false;
            }
            Type *other = c->get_UnderlyingSystemType_9ccb7bb8385521f6();
            if(!(other->get_IsSystemType())) 
            {
                return false;
            }
            return systemType->IsAssignableFrom_e3aa32d778e63a90(other);
        }
        if(!(c->get_IsSystemType())) 
        {
            Type *underlyingType = c->get_UnderlyingSystemType_9ccb7bb8385521f6();
            if(!(underlyingType->get_IsSystemType())) 
            {
                return false;
            }
            return IsAssignableFrom_e3aa32d778e63a90(underlyingType);
        }
        return type_is_assignable_from(this, c);
    }
    
    bool Type::IsInstanceOfType(Type* type, Object* o) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool Type::IsInstanceOfType_bd709d8c55b4333d(Object* o) {
        Type *type = this->get_UnderlyingSystemType_9ccb7bb8385521f6();
        if(!(type->get_IsSystemType())) 
        {
            return false;
        }
        return IsInstanceOfType(type, o);
    }
    
    int32_t Type::GetArrayRank_fccf91da5e4acf4f() {
        throw cli::gcnew<NotSupportedException>();
    }
    
    Reflection::EventInfo* Type::GetEvent(String* name) {
        return GetEvent_7f053fa54114e387(name, (Reflection::BindingFlags)28L);
    }
    
    cli::array<Reflection::EventInfo*>* Type::GetEvents_e6858c959b77de38() {
        return GetEvents_a960b087e4d67be2((Reflection::BindingFlags)28L);
    }
    
    Reflection::FieldInfo* Type::GetField(String* name) {
        return GetField_fb08cba9d1a4bc84(name, (Reflection::BindingFlags)28L);
    }
    
    cli::array<Reflection::FieldInfo*>* Type::GetFields() {
        return GetFields_369be5ac49d99f8((Reflection::BindingFlags)28L);
    }
    
    int32_t Type::GetHashCode_6648aef0f235ee6c() {
        Type *t = this->get_UnderlyingSystemType_9ccb7bb8385521f6();
        if((op_Inequality2(t, nullptr) && op_Inequality2(t, this))) 
        {
            return t->GetHashCode_6648aef0f235ee6c();
        }
        return (int32_t)this->_impl->get_Value();
    }
    
    cli::array<Reflection::MemberInfo*>* Type::GetMember(String* name) {
        return GetMember_9c934e7384b805e1(name, Reflection::MemberTypes::All, (Reflection::BindingFlags)28L);
    }
    
    cli::array<Reflection::MemberInfo*>* Type::GetMember_1a3f3c5f72801016(String* name, Reflection::BindingFlags bindingAttr) {
        return GetMember_9c934e7384b805e1(name, Reflection::MemberTypes::All, bindingAttr);
    }
    
    cli::array<Reflection::MemberInfo*>* Type::GetMember_9c934e7384b805e1(String* name, Reflection::MemberTypes type, Reflection::BindingFlags bindingAttr) {
        if((name ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("name"));
        }
        if(((int32_t)(((int32_t)(bindingAttr) & 1)) != 0)) 
        {
            return FindMembers_cae113425644ab26(type, bindingAttr, FilterNameIgnoreCase, name);
        }
         else 
        {
            return FindMembers_cae113425644ab26(type, bindingAttr, FilterName, name);
        }
    }
    
    cli::array<Reflection::MemberInfo*>* Type::GetMembers() {
        return GetMembers_54432b0ff6e99174((Reflection::BindingFlags)28L);
    }
    
    Reflection::MethodInfo* Type::GetMethod(String* name) {
        if((name ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("name"));
        }
        return GetMethodImpl_1b221ab713bbcb85(name, (Reflection::BindingFlags)28L, nullptr, Reflection::CallingConventions::Any, nullptr, nullptr);
    }
    
    Reflection::MethodInfo* Type::GetMethod2(String* name, Reflection::BindingFlags bindingAttr) {
        if((name ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("name"));
        }
        return GetMethodImpl_1b221ab713bbcb85(name, bindingAttr, nullptr, Reflection::CallingConventions::Any, nullptr, nullptr);
    }
    
    Reflection::MethodInfo* Type::GetMethod3(String* name, cli::array<Type*>* types) {
        return GetMethod6(name, (Reflection::BindingFlags)28L, nullptr, Reflection::CallingConventions::Any, types, nullptr);
    }
    
    Reflection::MethodInfo* Type::GetMethod4(String* name, cli::array<Type*>* types, cli::array<Reflection::ParameterModifier>* modifiers) {
        return GetMethod6(name, (Reflection::BindingFlags)28L, nullptr, Reflection::CallingConventions::Any, types, modifiers);
    }
    
    Reflection::MethodInfo* Type::GetMethod5(String* name, Reflection::BindingFlags bindingAttr, Reflection::Binder* binder, cli::array<Type*>* types, cli::array<Reflection::ParameterModifier>* modifiers) {
        return GetMethod6(name, bindingAttr, binder, Reflection::CallingConventions::Any, types, modifiers);
    }
    
    Reflection::MethodInfo* Type::GetMethod6(String* name, Reflection::BindingFlags bindingAttr, Reflection::Binder* binder, Reflection::CallingConventions callConvention, cli::array<Type*>* types, cli::array<Reflection::ParameterModifier>* modifiers) {
        if((name ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("name"));
        }
        if((types ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("types"));
        }
        for(int32_t i = 0; (i < types->get_Length()); i++) {
            if(op_Equality2(types->at(i), nullptr)) 
            {
                throw cli::gcnew<ArgumentNullException>(_T("types"));
            }
        }
        return GetMethodImpl_1b221ab713bbcb85(name, bindingAttr, binder, callConvention, types, modifiers);
    }
    
    Reflection::MethodInfo* Type::GetMethodImplInternal(String* name, Reflection::BindingFlags bindingAttr, Reflection::Binder* binder, Reflection::CallingConventions callConvention, cli::array<Type*>* types, cli::array<Reflection::ParameterModifier>* modifiers) {
        return GetMethodImpl_1b221ab713bbcb85(name, bindingAttr, binder, callConvention, types, modifiers);
    }
    
    Reflection::MethodInfo* Type::GetMethod_c725b8f4a943d5c8(Reflection::MethodInfo* fromNoninstanciated) {
        throw cli::gcnew<InvalidOperationException>(_T("can only be called in generic type"));
    }
    
    Reflection::ConstructorInfo* Type::GetConstructor_1dd1da77cc4fe364(Reflection::ConstructorInfo* fromNoninstanciated) {
        throw cli::gcnew<InvalidOperationException>(_T("can only be called in generic type"));
    }
    
    Reflection::FieldInfo* Type::GetField_4da1f61e7e2a6f8c(Reflection::FieldInfo* fromNoninstanciated) {
        throw cli::gcnew<InvalidOperationException>(_T("can only be called in generic type"));
    }
    
    cli::array<Reflection::MethodInfo*>* Type::GetMethods() {
        return GetMethods_c5b4e5d4877e6672((Reflection::BindingFlags)28L);
    }
    
    Type* Type::GetNestedType(String* name) {
        return GetNestedType_31962c16c0c85df9(name, (Reflection::BindingFlags)28L);
    }
    
    cli::array<Type*>* Type::GetNestedTypes() {
        return GetNestedTypes_bb6ee40b0fa4052d((Reflection::BindingFlags)28L);
    }
    
    cli::array<Reflection::PropertyInfo*>* Type::GetProperties() {
        return GetProperties_9fb6c40e3662fdd7((Reflection::BindingFlags)28L);
    }
    
    Reflection::PropertyInfo* Type::GetProperty(String* name) {
        if((name ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("name"));
        }
        return GetPropertyImpl_e2328b7ad87384ee(name, (Reflection::BindingFlags)28L, nullptr, nullptr, nullptr, nullptr);
    }
    
    Reflection::PropertyInfo* Type::GetProperty2(String* name, Reflection::BindingFlags bindingAttr) {
        if((name ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("name"));
        }
        return GetPropertyImpl_e2328b7ad87384ee(name, bindingAttr, nullptr, nullptr, nullptr, nullptr);
    }
    
    Reflection::PropertyInfo* Type::GetProperty3(String* name, Type* returnType) {
        if((name ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("name"));
        }
        return GetPropertyImpl_e2328b7ad87384ee(name, (Reflection::BindingFlags)28L, nullptr, returnType, nullptr, nullptr);
    }
    
    Reflection::PropertyInfo* Type::GetProperty4(String* name, cli::array<Type*>* types) {
        return GetProperty7(name, (Reflection::BindingFlags)28L, nullptr, nullptr, types, nullptr);
    }
    
    Reflection::PropertyInfo* Type::GetProperty5(String* name, Type* returnType, cli::array<Type*>* types) {
        return GetProperty7(name, (Reflection::BindingFlags)28L, nullptr, returnType, types, nullptr);
    }
    
    Reflection::PropertyInfo* Type::GetProperty6(String* name, Type* returnType, cli::array<Type*>* types, cli::array<Reflection::ParameterModifier>* modifiers) {
        return GetProperty7(name, (Reflection::BindingFlags)28L, nullptr, returnType, types, modifiers);
    }
    
    Reflection::PropertyInfo* Type::GetProperty7(String* name, Reflection::BindingFlags bindingAttr, Reflection::Binder* binder, Type* returnType, cli::array<Type*>* types, cli::array<Reflection::ParameterModifier>* modifiers) {
        if((name ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("name"));
        }
        if((types ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("types"));
        }
        for(auto tmp_192 : types) {
            auto t = cli::cast<Type*>(tmp_192);
            {
                if(op_Equality2(t, nullptr)) 
                {
                    throw cli::gcnew<ArgumentNullException>(_T("types"));
                }
            }
        }
        return GetPropertyImpl_e2328b7ad87384ee(name, bindingAttr, binder, returnType, types, modifiers);
    }
    
    Reflection::PropertyInfo* Type::GetPropertyImplInternal(String* name, Reflection::BindingFlags bindingAttr, Reflection::Binder* binder, Type* returnType, cli::array<Type*>* types, cli::array<Reflection::ParameterModifier>* modifiers) {
        return GetPropertyImpl_e2328b7ad87384ee(name, bindingAttr, binder, returnType, types, modifiers);
    }
    
    bool Type::IsArrayImpl2(Type* type) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool Type::IsValueTypeImpl_fe1651255927f3c6() {
        if((op_Equality2(this, cli::typeof<Type>::info) || op_Equality2(this, cli::typeof<Type>::info))) 
        {
            return false;
        }
        return IsSubclassOf_5d7dbe0215a30fda(cli::typeof<Type>::info);
    }
    
    bool Type::IsContextfulImpl_dd45484bf0f79262() {
        return cli::typeof<Type>::info->IsAssignableFrom_e3aa32d778e63a90(this);
    }
    
    bool Type::IsMarshalByRefImpl_75471fe14264cd54() {
        return cli::typeof<Type>::info->IsAssignableFrom_e3aa32d778e63a90(this);
    }
    
    Reflection::ConstructorInfo* Type::GetConstructor2(cli::array<Type*>* types) {
        return GetConstructor4((Reflection::BindingFlags)20L, nullptr, Reflection::CallingConventions::Any, types, nullptr);
    }
    
    Reflection::ConstructorInfo* Type::GetConstructor3(Reflection::BindingFlags bindingAttr, Reflection::Binder* binder, cli::array<Type*>* types, cli::array<Reflection::ParameterModifier>* modifiers) {
        return GetConstructor4(bindingAttr, binder, Reflection::CallingConventions::Any, types, modifiers);
    }
    
    Reflection::ConstructorInfo* Type::GetConstructor4(Reflection::BindingFlags bindingAttr, Reflection::Binder* binder, Reflection::CallingConventions callConvention, cli::array<Type*>* types, cli::array<Reflection::ParameterModifier>* modifiers) {
        if((types ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("types"));
        }
        for(auto tmp_193 : types) {
            auto t = cli::cast<Type*>(tmp_193);
            {
                if(op_Equality2(t, nullptr)) 
                {
                    throw cli::gcnew<ArgumentNullException>(_T("types"));
                }
            }
        }
        return GetConstructorImpl_a21b5d13a475afe1(bindingAttr, binder, callConvention, types, modifiers);
    }
    
    cli::array<Reflection::ConstructorInfo*>* Type::GetConstructors() {
        return GetConstructors_736b6e990b94b352((Reflection::BindingFlags)20L);
    }
    
    cli::array<Reflection::MemberInfo*>* Type::GetDefaultMembers_d0a4a4222b9683ff() {
        cli::array<Object*> *att = GetCustomAttributes_a458b60110eb1adc(cli::typeof<Type>::info, true);
        if((att->get_Length() ==  0)) 
        {
            return (new cli::array<Reflection::MemberInfo*>(0));
        }
        cli::array<Reflection::MemberInfo*> *member = GetMember(cli::cast<Reflection::DefaultMemberAttribute*>(att->at(0))->get_MemberName());
        return (member != nullptr) ? member : (new cli::array<Reflection::MemberInfo*>(0));
    }
    
    cli::array<Reflection::MemberInfo*>* Type::FindMembers_cae113425644ab26(Reflection::MemberTypes memberType, Reflection::BindingFlags bindingAttr, Reflection::MemberFilter* filter, Object* filterCriteria) {
        cli::array<Reflection::MemberInfo*> *result;
        Collections::ArrayList *l = cli::gcnew<Collections::ArrayList>();
        if(((int32_t)(((int32_t)(memberType) & 8)) != 0)) 
        {
            cli::array<Reflection::MethodInfo*> *c = GetMethods_c5b4e5d4877e6672(bindingAttr);
            if((filter != nullptr)) 
            {
                for(auto tmp_194 : c) {
                    auto m = cli::cast<Reflection::MemberInfo*>(tmp_194);
                    {
                        if(filter->Invoke(m, filterCriteria)) 
                        {
                            l->Add_e6a92085999ce388(m);
                        }
                    }
                }
            }
             else 
            {
                l->AddRange_a8bb4db32a72ffe(c);
            }
        }
        if(((int32_t)(((int32_t)(memberType) & 1)) != 0)) 
        {
            cli::array<Reflection::ConstructorInfo*> *c = GetConstructors_736b6e990b94b352(bindingAttr);
            if((filter != nullptr)) 
            {
                for(auto tmp_195 : c) {
                    auto m = cli::cast<Reflection::MemberInfo*>(tmp_195);
                    {
                        if(filter->Invoke(m, filterCriteria)) 
                        {
                            l->Add_e6a92085999ce388(m);
                        }
                    }
                }
            }
             else 
            {
                l->AddRange_a8bb4db32a72ffe(c);
            }
        }
        if(((int32_t)(((int32_t)(memberType) & 16)) != 0)) 
        {
            cli::array<Reflection::PropertyInfo*> *c = GetProperties_9fb6c40e3662fdd7(bindingAttr);
            if((filter != nullptr)) 
            {
                for(auto tmp_196 : c) {
                    auto m = cli::cast<Reflection::MemberInfo*>(tmp_196);
                    {
                        if(filter->Invoke(m, filterCriteria)) 
                        {
                            l->Add_e6a92085999ce388(m);
                        }
                    }
                }
            }
             else 
            {
                l->AddRange_a8bb4db32a72ffe(c);
            }
        }
        if(((int32_t)(((int32_t)(memberType) & 2)) != 0)) 
        {
            cli::array<Reflection::EventInfo*> *c = GetEvents_a960b087e4d67be2(bindingAttr);
            if((filter != nullptr)) 
            {
                for(auto tmp_197 : c) {
                    auto m = cli::cast<Reflection::MemberInfo*>(tmp_197);
                    {
                        if(filter->Invoke(m, filterCriteria)) 
                        {
                            l->Add_e6a92085999ce388(m);
                        }
                    }
                }
            }
             else 
            {
                l->AddRange_a8bb4db32a72ffe(c);
            }
        }
        if(((int32_t)(((int32_t)(memberType) & 4)) != 0)) 
        {
            cli::array<Reflection::FieldInfo*> *c = GetFields_369be5ac49d99f8(bindingAttr);
            if((filter != nullptr)) 
            {
                for(auto tmp_198 : c) {
                    auto m = cli::cast<Reflection::MemberInfo*>(tmp_198);
                    {
                        if(filter->Invoke(m, filterCriteria)) 
                        {
                            l->Add_e6a92085999ce388(m);
                        }
                    }
                }
            }
             else 
            {
                l->AddRange_a8bb4db32a72ffe(c);
            }
        }
        if(((int32_t)(((int32_t)(memberType) & 128)) != 0)) 
        {
            cli::array<Type*> *c = GetNestedTypes_bb6ee40b0fa4052d(bindingAttr);
            if((filter != nullptr)) 
            {
                for(auto tmp_199 : c) {
                    auto m = cli::cast<Reflection::MemberInfo*>(tmp_199);
                    {
                        if(filter->Invoke(m, filterCriteria)) 
                        {
                            l->Add_e6a92085999ce388(m);
                        }
                    }
                }
            }
             else 
            {
                l->AddRange_a8bb4db32a72ffe(c);
            }
        }
        switch(memberType) {
            case Reflection::MemberTypes::Constructor: case_917: {
                result = (new cli::array<Reflection::ConstructorInfo*>(l->get_Count_2354963792616712()))->template CovariantCast<Reflection::MemberInfo*>();
                break;
            }
            case Reflection::MemberTypes::Event: case_918: {
                result = (new cli::array<Reflection::EventInfo*>(l->get_Count_2354963792616712()))->template CovariantCast<Reflection::MemberInfo*>();
                break;
            }
            case Reflection::MemberTypes::Field: case_919: {
                result = (new cli::array<Reflection::FieldInfo*>(l->get_Count_2354963792616712()))->template CovariantCast<Reflection::MemberInfo*>();
                break;
            }
            case Reflection::MemberTypes::Method: case_920: {
                result = (new cli::array<Reflection::MethodInfo*>(l->get_Count_2354963792616712()))->template CovariantCast<Reflection::MemberInfo*>();
                break;
            }
            case Reflection::MemberTypes::NestedType: case Reflection::MemberTypes::TypeInfo3: case_921: {
                result = (new cli::array<Type*>(l->get_Count_2354963792616712()))->template CovariantCast<Reflection::MemberInfo*>();
                break;
            }
            case Reflection::MemberTypes::Property: case_922: {
                result = (new cli::array<Reflection::PropertyInfo*>(l->get_Count_2354963792616712()))->template CovariantCast<Reflection::MemberInfo*>();
                break;
            }
            default: case_923: {
                result = (new cli::array<Reflection::MemberInfo*>(l->get_Count_2354963792616712()));
                break;
            }
        }
        l->CopyTo_c634d425a65b1fc3(result);
        return result;
    }
    
    Object* Type::InvokeMember(String* name, Reflection::BindingFlags invokeAttr, Reflection::Binder* binder, Object* target, cli::array<Object*>* args) {
        return InvokeMember_70c4601d847070a2(name, invokeAttr, binder, target, args, nullptr, nullptr, nullptr);
    }
    
    Object* Type::InvokeMember2(String* name, Reflection::BindingFlags invokeAttr, Reflection::Binder* binder, Object* target, cli::array<Object*>* args, Globalization::CultureInfo* culture) {
        return InvokeMember_70c4601d847070a2(name, invokeAttr, binder, target, args, nullptr, culture, nullptr);
    }
    
    String* Type::ToString_1636a0751cb9ac11() {
        return this->get_FullName_7e8fa72ba225e1a4();
    }
    
    Type* Type::InternalResolve_ba2e81f73f0d7994() {
        return this->get_UnderlyingSystemType_9ccb7bb8385521f6();
    }
    
    cli::array<Type*>* Type::GetGenericArguments_a7fb476275cfe9a3() {
        throw cli::gcnew<NotSupportedException>();
    }
    
    Type* Type::GetGenericTypeDefinition_impl() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    Type* Type::GetGenericTypeDefinition_15f8fc7813e8e8bf() {
        throw cli::gcnew<NotSupportedException>(_T("Derived classes must provide an implementation."));
    }
    
    Type* Type::MakeGenericType(Type* gt, cli::array<Type*>* types) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    Reflection::Emit::AssemblyBuilder* Type::PeelAssemblyBuilder(Type* type) {
        if(cli::is<Reflection::Emit::AssemblyBuilder>(type->get_Assembly_3aae0acbf2a6d696())) 
        {
            return cli::cast<Reflection::Emit::AssemblyBuilder*>(type->get_Assembly_3aae0acbf2a6d696());
        }
        if(type->get_HasElementType()) 
        {
            return PeelAssemblyBuilder(type->GetElementType_ab5070dbbfe66f5f());
        }
        if(((!(type->get_IsGenericType_4db8ddd5b97f3c14()) || type->get_IsGenericParameter_2a17c4bf67798b07()) || type->get_IsGenericTypeDefinition_8008dd501dc43926())) 
        {
            return nullptr;
        }
        for(auto tmp_200 : type->GetGenericArguments_a7fb476275cfe9a3()) {
            auto arg = cli::cast<Type*>(tmp_200);
            {
                Reflection::Emit::AssemblyBuilder *ab = PeelAssemblyBuilder(arg);
                if(Reflection::Assembly::op_Inequality(ab, nullptr)) 
                {
                    return ab;
                }
            }
        }
        return nullptr;
    }
    
    Type* Type::MakeGenericType_da11ef776ac96678(cli::array<Type*>* typeArguments) {
        if(this->get_IsUserType()) 
        {
            throw cli::gcnew<NotSupportedException>();
        }
        if(!(this->get_IsGenericTypeDefinition_8008dd501dc43926())) 
        {
            throw cli::gcnew<InvalidOperationException>(_T("not a generic type definition"));
        }
        if((typeArguments ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("typeArguments"));
        }
        if((GetGenericArguments_a7fb476275cfe9a3()->get_Length() != typeArguments->get_Length())) 
        {
            throw cli::gcnew<ArgumentException>(String::Format3(_T("The type or method has {0} generic parameter(s) but {1} generic argument(s) where provided. A generic argument must be provided for each generic parameter."), cli::box(GetGenericArguments_a7fb476275cfe9a3()->get_Length()), cli::box(typeArguments->get_Length())), _T("typeArguments"));
        }
        bool hasUserType = false;
        cli::array<Type*> *systemTypes = (new cli::array<Type*>(typeArguments->get_Length()));
        for(int32_t i = 0; (i < typeArguments->get_Length()); ++i){
            Type *t = typeArguments->at(i);
            if(op_Equality2(t, nullptr)) 
            {
                throw cli::gcnew<ArgumentNullException>(_T("typeArguments"));
            }
            if(!(cli::is<MonoType>(t))) 
            {
                hasUserType = true;
            }
            systemTypes->at(i) = t;
        }
        if(hasUserType) 
        {
            return cli::gcnew<Reflection::MonoGenericClass>(this, typeArguments);
        }
        Type *res = MakeGenericType(this, systemTypes);
        if(op_Equality2(res, nullptr)) 
        {
            throw cli::gcnew<TypeLoadException>();
        }
        return res;
    }
    
    int32_t Type::GetGenericParameterPosition() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    Reflection::GenericParameterAttributes Type::GetGenericParameterAttributes() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    cli::array<Type*>* Type::GetGenericParameterConstraints_impl() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    cli::array<Type*>* Type::GetGenericParameterConstraints_d29c24f34391020e() {
        if(!(this->get_IsSystemType())) 
        {
            throw cli::gcnew<InvalidOperationException>();
        }
        if(!(this->get_IsGenericParameter_2a17c4bf67798b07())) 
        {
            throw cli::gcnew<InvalidOperationException>();
        }
        return GetGenericParameterConstraints_impl();
    }
    
    Type* Type::make_array_type(int32_t rank) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    Type* Type::MakeArrayType_9ec2b26036f00b30() {
        if(!(this->get_IsSystemType())) 
        {
            throw cli::gcnew<NotSupportedException>(_T("Derived classes must provide an implementation."));
        }
        return make_array_type(0);
    }
    
    Type* Type::MakeArrayType_b5bc09824bbbb104(int32_t rank) {
        if(!(this->get_IsSystemType())) 
        {
            throw cli::gcnew<NotSupportedException>(_T("Derived classes must provide an implementation."));
        }
        if(((rank < 1) || (rank > 255))) 
        {
            throw cli::gcnew<IndexOutOfRangeException>();
        }
        return make_array_type(rank);
    }
    
    Type* Type::make_byref_type() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    Type* Type::MakeByRefType_fc54947a1bb074be() {
        if(!(this->get_IsSystemType())) 
        {
            throw cli::gcnew<NotSupportedException>(_T("Derived classes must provide an implementation."));
        }
        if(this->get_IsByRef()) 
        {
            throw cli::gcnew<TypeLoadException>(_T("Can not call MakeByRefType on a ByRef type"));
        }
        return make_byref_type();
    }
    
    Type* Type::MakePointerType(Type* type) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    Type* Type::MakePointerType_f23f3b9330ac63da() {
        if(!(this->get_IsSystemType())) 
        {
            throw cli::gcnew<NotSupportedException>(_T("Derived classes must provide an implementation."));
        }
        return MakePointerType(this);
    }
    
    Type* Type::ReflectionOnlyGetType(String* typeName, bool throwIfNotFound, bool ignoreCase) {
        if((typeName ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("typeName"));
        }
        int32_t idx = typeName->IndexOf4(u',');
        if((((idx < 0) || (idx ==  0)) || (idx ==  (typeName->get_Length() - 1)))) 
        {
            throw cli::gcnew<ArgumentException>(_T("Assembly qualifed type name is required"), _T("typeName"));
        }
        String *an = typeName->Substring((idx + 1));
        Reflection::Assembly *a;
        try {
            a = Reflection::Assembly::ReflectionOnlyLoad2(an);
        }
        catch(...) {
            if(throwIfNotFound) 
            {
                throw ;
            }
            return nullptr;
        }
        return a->GetType_30e9b2dcc4956479(typeName->Substring2(0, idx), throwIfNotFound, ignoreCase);
    }
    
    void Type::GetPacking(int32_t packing, int32_t size) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    Runtime::InteropServices::StructLayoutAttribute* Type::GetStructLayoutAttribute() {
        Runtime::InteropServices::LayoutKind kind;
        if(this->get_IsLayoutSequential()) 
        {
            kind = Runtime::InteropServices::LayoutKind::Sequential;
        }
         else 
        {
            if(this->get_IsExplicitLayout()) 
            {
                kind = Runtime::InteropServices::LayoutKind::Explicit;
            }
             else 
            {
                kind = Runtime::InteropServices::LayoutKind::Auto;
            }
        }
        Runtime::InteropServices::StructLayoutAttribute *attr = cli::gcnew<Runtime::InteropServices::StructLayoutAttribute>(kind);
        if(this->get_IsUnicodeClass()) 
        {
            attr->CharSet2 = Runtime::InteropServices::CharSet::Unicode;
        }
         else 
        {
            if(this->get_IsAnsiClass()) 
            {
                attr->CharSet2 = Runtime::InteropServices::CharSet::Ansi;
            }
             else 
            {
                attr->CharSet2 = Runtime::InteropServices::CharSet::Auto;
            }
        }
        if(((int32_t)(kind) != 3)) 
        {
            int32_t packing;
            GetPacking(packing, attr->Size);
            if((packing != 0)) 
            {
                attr->Pack = packing;
            }
        }
        return attr;
    }
    
    cli::array<Object*>* Type::GetPseudoCustomAttributes() {
        int32_t count = 0;
        if(((int32_t)(((int32_t)(this->get_Attributes()) & 8192)) != 0)) 
        {
            count++;
        }
        if(((int32_t)(((int32_t)(this->get_Attributes()) & 4096)) != 0)) 
        {
            count++;
        }
        if((count ==  0)) 
        {
            return nullptr;
        }
        cli::array<Object*> *attrs = (new cli::array<Object*>(count));
        count = 0;
        if(((int32_t)(((int32_t)(this->get_Attributes()) & 8192)) != 0)) 
        {
            attrs->at(count++) = cli::gcnew<SerializableAttribute>();
        }
        if(((int32_t)(((int32_t)(this->get_Attributes()) & 4096)) != 0)) 
        {
            attrs->at(count++) = cli::gcnew<Runtime::InteropServices::ComImportAttribute>();
        }
        return attrs;
    }
    
    bool Type::IsEquivalentTo_493c500dff75ad86(Type* other) {
        return op_Equality2(this, other);
    }
    
    void Type::GetIDsOfNames2(Guid riid, void* rgszNames, uint32_t cNames, uint32_t lcid, void* rgDispId) {
        throw cli::gcnew<NotImplementedException>();
    }
    
    void Type::GetTypeInfo2(uint32_t iTInfo, uint32_t lcid, void* ppTInfo) {
        throw cli::gcnew<NotImplementedException>();
    }
    
    void Type::GetTypeInfoCount2(uint32_t pcTInfo) {
        throw cli::gcnew<NotImplementedException>();
    }
    
    void Type::Invoke2(uint32_t dispIdMember, Guid riid, uint32_t lcid, int16_t wFlags, void* pDispParams, void* pVarResult, void* pExcepInfo, void* puArgErr) {
        throw cli::gcnew<NotImplementedException>();
    }
    
    bool Type::op_Equality2(Type* left, Type* right) {
        return Object::ReferenceEquals(left, right);
    }
    
    bool Type::op_Inequality2(Type* left, Type* right) {
        return !(Object::ReferenceEquals(left, right));
    }
    
    Reflection::TypeAttributes Type::get_Attributes() {
        return GetAttributeFlagsImpl_ea77781598cb234a();
    }
    
    Type* Type::get_DeclaringType_6121cd6a84393166() {
        return nullptr;
    }
    
    Reflection::Binder* Type::get_DefaultBinder() {
        return Reflection::Binder::get_DefaultBinder();
    }
    
    bool Type::get_HasElementType() {
        return HasElementTypeImpl_36e3ca23a6e8185();
    }
    
    bool Type::get_IsAbstract() {
        return ((int32_t)(((int32_t)(this->get_Attributes()) & 128)) != 0);
    }
    
    bool Type::get_IsAnsiClass() {
        return ((int32_t)(((int32_t)(this->get_Attributes()) & 196608)) ==  0);
    }
    
    bool Type::get_IsArray() {
        return IsArrayImpl_cf15f782d0773ffd();
    }
    
    bool Type::get_IsAutoClass() {
        return ((int32_t)(((int32_t)(this->get_Attributes()) & 196608)) ==  131072);
    }
    
    bool Type::get_IsAutoLayout() {
        return ((int32_t)(((int32_t)(this->get_Attributes()) & 24)) ==  0);
    }
    
    bool Type::get_IsByRef() {
        return IsByRefImpl_a1c403acfb80fd15();
    }
    
    bool Type::get_IsClass() {
        if(this->get_IsInterface()) 
        {
            return false;
        }
        return !(this->get_IsValueType());
    }
    
    bool Type::get_IsCOMObject() {
        return IsCOMObjectImpl_27dfb5d026264856();
    }
    
    bool Type::get_IsContextful() {
        return IsContextfulImpl_dd45484bf0f79262();
    }
    
    bool Type::get_IsEnum_bc85ea7b0a749db() {
        return IsSubclassOf_5d7dbe0215a30fda(cli::typeof<Type>::info);
    }
    
    bool Type::get_IsExplicitLayout() {
        return ((int32_t)(((int32_t)(this->get_Attributes()) & 24)) ==  16);
    }
    
    bool Type::get_IsImport() {
        return ((int32_t)(((int32_t)(this->get_Attributes()) & 4096)) != 0);
    }
    
    bool Type::get_IsInterface() {
        return ((int32_t)(((int32_t)(this->get_Attributes()) & 32)) ==  32);
    }
    
    bool Type::get_IsLayoutSequential() {
        return ((int32_t)(((int32_t)(this->get_Attributes()) & 24)) ==  8);
    }
    
    bool Type::get_IsMarshalByRef() {
        return IsMarshalByRefImpl_75471fe14264cd54();
    }
    
    bool Type::get_IsNestedAssembly() {
        return ((int32_t)(((int32_t)(this->get_Attributes()) & 7)) ==  5);
    }
    
    bool Type::get_IsNestedFamANDAssem() {
        return ((int32_t)(((int32_t)(this->get_Attributes()) & 7)) ==  6);
    }
    
    bool Type::get_IsNestedFamily() {
        return ((int32_t)(((int32_t)(this->get_Attributes()) & 7)) ==  4);
    }
    
    bool Type::get_IsNestedFamORAssem() {
        return ((int32_t)(((int32_t)(this->get_Attributes()) & 7)) ==  7);
    }
    
    bool Type::get_IsNestedPrivate() {
        return ((int32_t)(((int32_t)(this->get_Attributes()) & 7)) ==  3);
    }
    
    bool Type::get_IsNestedPublic() {
        return ((int32_t)(((int32_t)(this->get_Attributes()) & 7)) ==  2);
    }
    
    bool Type::get_IsNotPublic() {
        return ((int32_t)(((int32_t)(this->get_Attributes()) & 7)) ==  0);
    }
    
    bool Type::get_IsPointer() {
        return IsPointerImpl_86e7f94717f8b1ea();
    }
    
    bool Type::get_IsPrimitive() {
        return IsPrimitiveImpl_b5951f74b8c48703();
    }
    
    bool Type::get_IsPublic() {
        return ((int32_t)(((int32_t)(this->get_Attributes()) & 7)) ==  1);
    }
    
    bool Type::get_IsSealed() {
        return ((int32_t)(((int32_t)(this->get_Attributes()) & 256)) != 0);
    }
    
    bool Type::get_IsSerializable_54e7f398ebfc9468() {
        if(((int32_t)(((int32_t)(this->get_Attributes()) & 8192)) != 0)) 
        {
            return true;
        }
        Type *type = this->get_UnderlyingSystemType_9ccb7bb8385521f6();
        if(op_Equality2(type, nullptr)) 
        {
            return false;
        }
        if(type->get_IsSystemType()) 
        {
            return (type_is_subtype_of(type, cli::typeof<Type>::info, false) || type_is_subtype_of(type, cli::typeof<Type>::info, false));
        }
        do {
            if((op_Equality2(type, cli::typeof<Type>::info) || op_Equality2(type, cli::typeof<Type>::info))) 
            {
                return true;
            }
            type = type->get_BaseType_6a0646ae880055f6();
        }
        while(op_Inequality2(type, nullptr));
        return false;
    }
    
    bool Type::get_IsSpecialName() {
        return ((int32_t)(((int32_t)(this->get_Attributes()) & 1024)) != 0);
    }
    
    bool Type::get_IsUnicodeClass() {
        return ((int32_t)(((int32_t)(this->get_Attributes()) & 196608)) ==  65536);
    }
    
    bool Type::get_IsValueType() {
        return IsValueTypeImpl_fe1651255927f3c6();
    }
    
    Reflection::MemberTypes Type::get_MemberType_cd521d320810c98f() {
        return Reflection::MemberTypes::TypeInfo3;
    }
    
    Type* Type::get_ReflectedType_bf4971c0f442b9dc() {
        return nullptr;
    }
    
    RuntimeTypeHandle Type::get_TypeHandle_a14995fa9102936b() {
        throw cli::gcnew<ArgumentException>(_T("Derived class must provide implementation."));
    }
    
    Reflection::ConstructorInfo* Type::get_TypeInitializer() {
        return GetConstructorImpl_a21b5d13a475afe1((Reflection::BindingFlags)56L, nullptr, Reflection::CallingConventions::Any, EmptyTypes, nullptr);
    }
    
    bool Type::get_IsSecurityTransparent_6da55418ab72fb10() {
        throw CreateNIE();
    }
    
    bool Type::get_IsSecurityCritical_50a9063c5d34fcdb() {
        throw CreateNIE();
    }
    
    bool Type::get_IsSecuritySafeCritical_bcc034bfd05c04c9() {
        throw CreateNIE();
    }
    
    bool Type::get_IsSystemType() {
        return ::System::IntPtr::op_Inequality(this->_impl->get_Value(), (*::System::IntPtr::Zero));
    }
    
    bool Type::get_ContainsGenericParameters_19598881dd690ad3() {
        return false;
    }
    
    bool Type::get_IsGenericTypeDefinition_8008dd501dc43926() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool Type::get_IsGenericType_4db8ddd5b97f3c14() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool Type::get_IsGenericParameter_2a17c4bf67798b07() {
        return false;
    }
    
    bool Type::get_IsNested() {
        return op_Inequality2(this->get_DeclaringType_6121cd6a84393166(), nullptr);
    }
    
    bool Type::get_IsVisible() {
        if(this->get_IsNestedPublic()) 
        {
            return this->get_DeclaringType_6121cd6a84393166()->get_IsVisible();
        }
        return this->get_IsPublic();
    }
    
    int32_t Type::get_GenericParameterPosition_ae331bf96a7667b1() {
        int32_t res = GetGenericParameterPosition();
        if((res < 0)) 
        {
            throw cli::gcnew<InvalidOperationException>();
        }
        return res;
    }
    
    Reflection::GenericParameterAttributes Type::get_GenericParameterAttributes_b31b8b8f1d79d815() {
        if(!(this->get_IsSystemType())) 
        {
            throw cli::gcnew<NotSupportedException>(_T("Derived classes must provide an implementation."));
        }
        if(!(this->get_IsGenericParameter_2a17c4bf67798b07())) 
        {
            throw cli::gcnew<InvalidOperationException>();
        }
        return GetGenericParameterAttributes();
    }
    
    Reflection::MethodBase* Type::get_DeclaringMethod_6dc070d2040335e5() {
        return nullptr;
    }
    
    Runtime::InteropServices::StructLayoutAttribute* Type::get_StructLayoutAttribute_c8846f98114193d0() {
        throw cli::gcnew<NotSupportedException>();
    }
    
    bool Type::get_IsUserType() {
        return (::System::IntPtr::op_Equality(this->_impl->get_Value(), (*::System::IntPtr::Zero)) && (Reflection::Assembly::op_Inequality(GetType7()->get_Assembly_3aae0acbf2a6d696(), cli::typeof<Type>::info->get_Assembly_3aae0acbf2a6d696()) || op_Equality2(GetType7(), cli::typeof<Type>::info)));
    }
    
}
namespace System {
    
    
    void TypeAccessException::constructor() {
        this->set_HResult(-2146233054);
    }
    
    void TypeAccessException::constructor(String* message) {
        this->set_HResult(-2146233054);
    }
    
    void TypeAccessException::constructor(String* message, Exception* inner) {
        this->set_HResult(-2146233054);
    }
    
    void TypeAccessException::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
    }
    
}
namespace System {
    
    
    void TypeInitializationException::constructor(String* fullTypeName, Exception* innerException) {
        this->type_name = fullTypeName;
    }
    
    void TypeInitializationException::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        this->type_name = info->GetString(_T("TypeName"));
    }
    
    void TypeInitializationException::GetObjectData_bc9b88d7eb43b6d8(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        SystemException::GetObjectData_bc9b88d7eb43b6d8(info, context);
        info->AddValue16(_T("TypeName"), this->type_name);
    }
    
    String* TypeInitializationException::get_TypeName() {
        return this->type_name;
    }
    
}
namespace System {
    
    
    void TypeLoadException::constructor() {
        this->set_HResult(-2146233054);
    }
    
    void TypeLoadException::constructor(String* message) {
        this->set_HResult(-2146233054);
    }
    
    void TypeLoadException::constructor(String* message, Exception* inner) {
        this->set_HResult(-2146233054);
    }
    
    void TypeLoadException::constructor(String* className, String* assemblyName) {
        this->className = className;
        this->assemblyName = assemblyName;
    }
    
    void TypeLoadException::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        if((info ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("info"));
        }
        this->className = info->GetString(_T("TypeLoadClassName"));
        this->assemblyName = info->GetString(_T("TypeLoadAssemblyName"));
    }
    
    void TypeLoadException::GetObjectData_bc9b88d7eb43b6d8(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        if((info ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("info"));
        }
        SystemException::GetObjectData_bc9b88d7eb43b6d8(info, context);
        info->AddValue(_T("TypeLoadClassName"), this->className, cli::typeof<Type>::info);
        info->AddValue(_T("TypeLoadAssemblyName"), this->assemblyName, cli::typeof<Type>::info);
        info->AddValue(_T("TypeLoadMessageArg"), _T(""), cli::typeof<Type>::info);
        info->AddValue(_T("TypeLoadResourceID"), cli::box(0), cli::typeof<Type>::info);
    }
    
    String* TypeLoadException::get_Message_d211df4045b57cbf() {
        if((this->className != nullptr)) 
        {
            if(((this->assemblyName != nullptr) && String::op_Inequality(this->assemblyName, String::Empty))) 
            {
                return String::Format3(_T("Could not load type \'{0}\' from assembly \'{1}\'."), this->className, this->assemblyName);
            }
             else 
            {
                return String::Format2(_T("Could not load type \'{0}\'."), this->className);
            }
        }
         else 
        {
            return SystemException::get_Message_d211df4045b57cbf();
        }
    }
    
    String* TypeLoadException::get_TypeName() {
        if((this->className ==  nullptr)) 
        {
            return String::Empty;
        }
         else 
        {
            return this->className;
        }
    }
    
}
namespace System {
    
    
    void ArraySpec::constructor(int32_t dimensions, bool bound) {
        this->dimensions = dimensions;
        this->bound = bound;
    }
    
    Type* ArraySpec::Resolve(Type* type) {
        if(this->bound) 
        {
            return type->MakeArrayType_b5bc09824bbbb104(1);
        }
         else 
        {
            if((this->dimensions ==  1)) 
            {
                return type->MakeArrayType_9ec2b26036f00b30();
            }
        }
        return type->MakeArrayType_b5bc09824bbbb104(this->dimensions);
    }
    
}
namespace System {
    
    
    void TypeSpec::constructor() {
    }
    
    TypeSpec* TypeSpec::Parse(String* typeName) {
        int32_t pos = 0;
        if((typeName ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("typeName"));
        }
        TypeSpec *res = Parse2(typeName, pos, false, false);
        if((pos < typeName->get_Length())) 
        {
            throw cli::gcnew<ArgumentException>(_T("Count not parse the whole type name"), _T("typeName"));
        }
        return res;
    }
    
    Type* TypeSpec::Resolve(Func2<Reflection::AssemblyName*, Reflection::Assembly*>* assemblyResolver, Func3<Reflection::Assembly*, String*, bool, Type*>* typeResolver, bool throwOnError, bool ignoreCase) {
        Reflection::Assembly *asm_ = nullptr;
        if(((assemblyResolver ==  nullptr) && (typeResolver ==  nullptr))) 
        {
            return Type::GetType6(this->name, throwOnError, ignoreCase);
        }
        if((this->assembly_name != nullptr)) 
        {
            if((assemblyResolver != nullptr)) 
            {
                asm_ = assemblyResolver->Invoke(cli::gcnew<Reflection::AssemblyName>(this->assembly_name));
            }
             else 
            {
                asm_ = Reflection::Assembly::Load(this->assembly_name);
            }
            if(Reflection::Assembly::op_Equality(asm_, nullptr)) 
            {
                if(throwOnError) 
                {
                    throw cli::gcnew<IO::FileNotFoundException>(cli::concat(_T("Could not resolve assembly \'"), this->assembly_name));
                }
                return nullptr;
            }
        }
        Type *type = nullptr;
        if((typeResolver != nullptr)) 
        {
            type = typeResolver->Invoke(asm_, this->name, ignoreCase);
        }
         else 
        {
            type = asm_->GetType_30e9b2dcc4956479(this->name, false, ignoreCase);
        }
        if(Type::op_Equality2(type, nullptr)) 
        {
            if(throwOnError) 
            {
                throw cli::gcnew<TypeLoadException>(cli::concat(_T("Could not resolve type \'"), this->name));
            }
            return nullptr;
        }
        if((this->nested != nullptr)) 
        {
            for(auto tmp_201 : this->nested) {
                auto n = cli::cast<String*>(tmp_201);
                {
                    Type *tmp = type->GetNestedType_31962c16c0c85df9(n, (Reflection::BindingFlags)48L);
                    if(Type::op_Equality2(tmp, nullptr)) 
                    {
                        if(throwOnError) 
                        {
                            throw cli::gcnew<TypeLoadException>(cli::concat(_T("Could not resolve type \'"), n));
                        }
                        return nullptr;
                    }
                    type = tmp;
                }
            }
        }
        if((this->generic_params != nullptr)) 
        {
            cli::array<Type*> *args = (new cli::array<Type*>(this->generic_params->get_Count()));
            for(int32_t i = 0; (i < args->get_Length()); ++i){
                Type *tmp = this->generic_params->get_Item(i)->Resolve(assemblyResolver, typeResolver, throwOnError, ignoreCase);
                if(Type::op_Equality2(tmp, nullptr)) 
                {
                    if(throwOnError) 
                    {
                        throw cli::gcnew<TypeLoadException>(cli::concat(_T("Could not resolve type \'"), this->generic_params->get_Item(i)->name));
                    }
                    return nullptr;
                }
                args->at(i) = tmp;
            }
            type = type->MakeGenericType_da11ef776ac96678(args);
        }
        if((this->array_spec != nullptr)) 
        {
            for(auto tmp_202 : this->array_spec) {
                auto arr = cli::cast<ArraySpec*>(tmp_202);
                type = arr->Resolve(type);
            }
        }
        for(int32_t i = 0; (i < this->pointer_level); ++i) {
            type = type->MakePointerType_f23f3b9330ac63da();
        }
        if(this->is_byref) 
        {
            type = type->MakeByRefType_fc54947a1bb074be();
        }
        return type;
    }
    
    void TypeSpec::AddName(String* type_name) {
        if((this->name ==  nullptr)) 
        {
            this->name = type_name;
        }
         else 
        {
            if((this->nested ==  nullptr)) 
            {
                this->nested = cli::gcnew<Collections::Generic::List<String*>>();
            }
            this->nested->Add(type_name);
        }
    }
    
    void TypeSpec::AddArray(ArraySpec* array) {
        if((this->array_spec ==  nullptr)) 
        {
            this->array_spec = cli::gcnew<Collections::Generic::List<ArraySpec*>>();
        }
        this->array_spec->Add(array);
    }
    
    void TypeSpec::SkipSpace(String* name, int32_t pos) {
        int32_t p = pos;
        while(((p < name->get_Length()) && Char::IsWhiteSpace(name->get_Chars(p)))) ++p;
        pos = p;
    }
    
    TypeSpec* TypeSpec::Parse2(String* name, int32_t p, bool is_recurse, bool allow_aqn) {
        int32_t pos = p;
        int32_t name_start;
        bool in_modifiers = false;
        TypeSpec *data = cli::gcnew<TypeSpec>();
        SkipSpace(name, pos);
        name_start = pos;
        for(; (pos < name->get_Length()); ++pos){
            switch(name->get_Chars(pos)) {
                case u'+': case_924: {
                    data->AddName(name->Substring2(name_start, (pos - name_start)));
                    name_start = (pos + 1);
                    break;
                }
                case u',': case u']': case_925: {
                    data->AddName(name->Substring2(name_start, (pos - name_start)));
                    name_start = (pos + 1);
                    in_modifiers = true;
                    if((is_recurse && !(allow_aqn))) 
                    {
                        p = pos;
                        return data;
                    }
                    break;
                }
                case u'&': case u'*': case u'[': case_926: {
                    if((((int32_t)(name->get_Chars(pos)) != 91) && is_recurse)) 
                    {
                        throw cli::gcnew<ArgumentException>(_T("Generic argument can\'t be byref or pointer type"), _T("typeName"));
                    }
                    data->AddName(name->Substring2(name_start, (pos - name_start)));
                    name_start = (pos + 1);
                    in_modifiers = true;
                    break;
                }
            }
            if(in_modifiers) 
            {
                break;
            }
        }
        if((name_start < pos)) 
        {
            data->AddName(name->Substring2(name_start, (pos - name_start)));
        }
        if(in_modifiers) 
        {
            for(; (pos < name->get_Length()); ++pos){
                switch(name->get_Chars(pos)) {
                    case u'&': case_927: {
                        if(data->is_byref) 
                        {
                            throw cli::gcnew<ArgumentException>(_T("Can\'t have a byref of a byref"), _T("typeName"));
                        }
                        data->is_byref = true;
                        break;
                    }
                    case u'*': case_928: {
                        if(data->is_byref) 
                        {
                            throw cli::gcnew<ArgumentException>(_T("Can\'t have a pointer to a byref type"), _T("typeName"));
                        }
                        ++data->pointer_level;
                        break;
                    }
                    case u',': case_929: {
                        if(is_recurse) 
                        {
                            int32_t end = pos;
                            while(((end < name->get_Length()) && ((int32_t)(name->get_Chars(end)) != 93))) ++end;
                            if((end >= name->get_Length())) 
                            {
                                throw cli::gcnew<ArgumentException>(_T("Unmatched \']\' while parsing generic argument assembly name"));
                            }
                            data->assembly_name = name->Substring2((pos + 1), ((end - pos) - 1))->Trim();
                            p = (end + 1);
                            return data;
                        }
                        data->assembly_name = name->Substring((pos + 1))->Trim();
                        pos = name->get_Length();
                        break;
                    }
                    case u'[': case_930: {
                        if(data->is_byref) 
                        {
                            throw cli::gcnew<ArgumentException>(_T("Byref qualifier must be the last one of a type"), _T("typeName"));
                        }
                        ++pos;
                        if((pos >= name->get_Length())) 
                        {
                            throw cli::gcnew<ArgumentException>(_T("Invalid array/generic spec"), _T("typeName"));
                        }
                        SkipSpace(name, pos);
                        if(((((int32_t)(name->get_Chars(pos)) != 44) && ((int32_t)(name->get_Chars(pos)) != 42)) && ((int32_t)(name->get_Chars(pos)) != 93))) 
                        {
                            Collections::Generic::List<TypeSpec*> *args = cli::gcnew<Collections::Generic::List<TypeSpec*>>();
                            if(data->get_IsArray()) 
                            {
                                throw cli::gcnew<ArgumentException>(_T("generic args after array spec"), _T("typeName"));
                            }
                            while((pos < name->get_Length())) {
                                SkipSpace(name, pos);
                                bool aqn = ((int32_t)(name->get_Chars(pos)) ==  91);
                                if(aqn) 
                                {
                                    ++pos;
                                }
                                args->Add(Parse2(name, pos, true, aqn));
                                if((pos >= name->get_Length())) 
                                {
                                    throw cli::gcnew<ArgumentException>(_T("Invalid generic arguments spec"), _T("typeName"));
                                }
                                if(((int32_t)(name->get_Chars(pos)) ==  93)) 
                                {
                                    break;
                                }
                                if(((int32_t)(name->get_Chars(pos)) ==  44)) 
                                {
                                    ++pos;
                                }
                                 else 
                                {
                                    throw cli::gcnew<ArgumentException>(cli::concat(_T("Invalid generic arguments separator "), cli::box(name->get_Chars(pos))), _T("typeName"));
                                }
                            }
                            if(((pos >= name->get_Length()) || ((int32_t)(name->get_Chars(pos)) != 93))) 
                            {
                                throw cli::gcnew<ArgumentException>(_T("Error parsing generic params spec"), _T("typeName"));
                            }
                            data->generic_params = args;
                        }
                         else 
                        {
                            int32_t dimensions = 1;
                            bool bound = false;
                            while(((pos < name->get_Length()) && ((int32_t)(name->get_Chars(pos)) != 93))) {
                                if(((int32_t)(name->get_Chars(pos)) ==  42)) 
                                {
                                    if(bound) 
                                    {
                                        throw cli::gcnew<ArgumentException>(_T("Array spec cannot have 2 bound dimensions"), _T("typeName"));
                                    }
                                    bound = true;
                                }
                                 else 
                                {
                                    if(((int32_t)(name->get_Chars(pos)) != 44)) 
                                    {
                                        throw cli::gcnew<ArgumentException>(cli::concat(_T("Invalid character in array spec "), cli::box(name->get_Chars(pos))), _T("typeName"));
                                    }
                                     else 
                                    {
                                        ++dimensions;
                                    }
                                }
                                ++pos;
                                SkipSpace(name, pos);
                            }
                            if(((int32_t)(name->get_Chars(pos)) != 93)) 
                            {
                                throw cli::gcnew<ArgumentException>(_T("Error parsing array spec"), _T("typeName"));
                            }
                            if(((dimensions > 1) && bound)) 
                            {
                                throw cli::gcnew<ArgumentException>(_T("Invalid array spec, multi-dimensional array cannot be bound"), _T("typeName"));
                            }
                            data->AddArray(cli::gcnew<ArraySpec>(dimensions, bound));
                        }
                        break;
                    }
                    case u']': case_931: {
                        if(is_recurse) 
                        {
                            p = (pos + 1);
                            return data;
                        }
                        throw cli::gcnew<ArgumentException>(_T("Unmatched \']\'"), _T("typeName"));
                    }
                    default: case_932: {
                        throw cli::gcnew<ArgumentException>(cli::concat(_T("Bad type def, can\'t handle \'"), cli::box(name->get_Chars(pos)), _T("\' at "), cli::box(pos)), _T("typeName"));
                    }
                }
            }
        }
        p = pos;
        return data;
    }
    
    bool TypeSpec::get_IsArray() {
        return (this->array_spec != nullptr);
    }
    
}
namespace System {
    
    
    void TypeUnloadedException::constructor() {
    }
    
    void TypeUnloadedException::constructor(String* message) {
    }
    
    void TypeUnloadedException::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
    }
    
    void TypeUnloadedException::constructor(String* message, Exception* innerException) {
    }
    
}
namespace System {
    
    
    void UnauthorizedAccessException::constructor() {
        this->set_HResult(-2146233088);
    }
    
    void UnauthorizedAccessException::constructor(String* message) {
        this->set_HResult(-2146233088);
    }
    
    void UnauthorizedAccessException::constructor(String* message, Exception* inner) {
        this->set_HResult(-2146233088);
    }
    
    void UnauthorizedAccessException::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
    }
    
}
namespace System {
    
    
    void UnhandledExceptionEventArgs::constructor(Object* exception, bool isTerminating) {
        this->exception = exception;
        this->m_isTerminating = isTerminating;
    }
    
    Object* UnhandledExceptionEventArgs::get_ExceptionObject() {
        return this->exception;
    }
    
    bool UnhandledExceptionEventArgs::get_IsTerminating() {
        return this->m_isTerminating;
    }
    
}
namespace System {
    
    
    void UnitySerializationHolder::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext ctx) {
        this->_data = info->GetString(_T("Data"));
        this->_unityType = (UnityType)((unsigned char)info->GetInt32(_T("UnityType")));
        this->_assemblyName = info->GetString(_T("AssemblyName"));
    }
    
    void UnitySerializationHolder::GetTypeData(Type* instance, Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext ctx) {
        info->AddValue16(_T("Data"), instance->get_FullName_7e8fa72ba225e1a4());
        info->AddValue4(_T("UnityType"), 4);
        info->AddValue16(_T("AssemblyName"), instance->get_Assembly_3aae0acbf2a6d696()->get_FullName_abd52da7f47cce07());
        info->SetType(cli::typeof<Type>::info);
    }
    
    void UnitySerializationHolder::GetDBNullData(DBNull* instance, Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext ctx) {
        info->AddValue16(_T("Data"), nullptr);
        info->AddValue4(_T("UnityType"), 2);
        info->AddValue16(_T("AssemblyName"), instance->GetType()->get_Assembly_3aae0acbf2a6d696()->get_FullName_abd52da7f47cce07());
        info->SetType(cli::typeof<Type>::info);
    }
    
    void UnitySerializationHolder::GetAssemblyData(Reflection::Assembly* instance, Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext ctx) {
        info->AddValue16(_T("Data"), instance->get_FullName_abd52da7f47cce07());
        info->AddValue4(_T("UnityType"), 6);
        info->AddValue16(_T("AssemblyName"), instance->get_FullName_abd52da7f47cce07());
        info->SetType(cli::typeof<Type>::info);
    }
    
    void UnitySerializationHolder::GetModuleData(Reflection::Module* instance, Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext ctx) {
        info->AddValue16(_T("Data"), instance->get_ScopeName_da7d7aa6d0cd103f());
        info->AddValue4(_T("UnityType"), 5);
        info->AddValue16(_T("AssemblyName"), instance->get_Assembly_dbea84123403c0aa()->get_FullName_abd52da7f47cce07());
        info->SetType(cli::typeof<Type>::info);
    }
    
    void UnitySerializationHolder::GetObjectData_e37fac8b2d7c8b4f(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        throw cli::gcnew<NotSupportedException>();
    }
    
    Object* UnitySerializationHolder::GetRealObject_81b2ad0a9e261bd8(Runtime::Serialization::StreamingContext context) {
        switch(this->_unityType) {
            case UnityType::Type2: case_933: {
                {
                    Reflection::Assembly *assembly = Reflection::Assembly::Load(this->_assemblyName);
                    return assembly->GetType_99cbfcc4e094eb08(this->_data);
                }
            }
            case UnityType::DBNull2: case_934: {
                return DBNull::Value;
            }
            case UnityType::Module2: case_935: {
                {
                    Reflection::Assembly *assembly = Reflection::Assembly::Load(this->_assemblyName);
                    return assembly->GetModule_d3e09c815c6ebd46(this->_data);
                }
            }
            case UnityType::Assembly2: case_936: {
                return Reflection::Assembly::Load(this->_data);
            }
            default: case_937: {
                throw cli::gcnew<NotSupportedException>(Locale::GetText(_T("UnitySerializationHolder does not support this type.")));
            }
        }
    }
    
}
namespace System {
    
    
    void ValueType::constructor() {
    }
    
    bool ValueType::InternalEquals(Object* o1, Object* o2, cli::array<Object*>* fields) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool ValueType::DefaultEquals(Object* o1, Object* o2) {
        cli::array<Object*> *fields;
        if((o2 ==  nullptr)) 
        {
            return false;
        }
        bool res = InternalEquals(o1, o2, fields);
        if((fields ==  nullptr)) 
        {
            return res;
        }
        for(int32_t i = 0; (i < fields->get_Length()); (i = i + 2)){
            Object *meVal = fields->at(i);
            Object *youVal = fields->at((i + 1));
            if((meVal ==  nullptr)) 
            {
                if((youVal ==  nullptr)) 
                {
                    continue;
                }
                return false;
            }
            if(!(meVal->Equals_ed975d2f4a7d193e(youVal))) 
            {
                return false;
            }
        }
        return true;
    }
    
    bool ValueType::Equals_ed975d2f4a7d193e(Object* obj) {
        return DefaultEquals(this, obj);
    }
    
    int32_t ValueType::InternalGetHashCode2(Object* o, cli::array<Object*>* fields) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t ValueType::GetHashCode_6648aef0f235ee6c() {
        cli::array<Object*> *fields;
        int32_t result = InternalGetHashCode2(this, fields);
        if((fields != nullptr)) 
        for(int32_t i = 0; (i < fields->get_Length()); ++i) {
            if((fields->at(i) != nullptr)) 
            {
                (result = result ^ fields->at(i)->GetHashCode_6648aef0f235ee6c());
            }
        }
        return result;
    }
    
    String* ValueType::ToString_1636a0751cb9ac11() {
        return Object::GetType()->get_FullName_7e8fa72ba225e1a4();
    }
    
}
namespace System {
    
    
    void Version::constructor() {
        CheckedSet(2, 0, 0, -1, -1);
    }
    
    void Version::constructor(String* version) {
        int32_t n;
        cli::array<String*> *vals;
        int32_t major = -1, minor = -1, build = -1, revision = -1;
        if((version ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("version"));
        }
        vals = version->Split((new cli::array<char16_t>({u'.'})));
        n = vals->get_Length();
        if(((n < 2) || (n > 4))) 
        {
            throw cli::gcnew<ArgumentException>(Locale::GetText(_T("There must be 2, 3 or 4 components in the version string.")));
        }
        if((n > 0)) 
        {
            major = Int32::Parse5(vals->at(0));
        }
        if((n > 1)) 
        {
            minor = Int32::Parse5(vals->at(1));
        }
        if((n > 2)) 
        {
            build = Int32::Parse5(vals->at(2));
        }
        if((n > 3)) 
        {
            revision = Int32::Parse5(vals->at(3));
        }
        CheckedSet(n, major, minor, build, revision);
    }
    
    void Version::constructor(int32_t major, int32_t minor) {
        CheckedSet(2, major, minor, 0, 0);
    }
    
    void Version::constructor(int32_t major, int32_t minor, int32_t build) {
        CheckedSet(3, major, minor, build, 0);
    }
    
    void Version::constructor(int32_t major, int32_t minor, int32_t build, int32_t revision) {
        CheckedSet(4, major, minor, build, revision);
    }
    
    void Version::CheckedSet(int32_t defined, int32_t major, int32_t minor, int32_t build, int32_t revision) {
        if((major < 0)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("major"));
        }
        this->_Major = major;
        if((minor < 0)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("minor"));
        }
        this->_Minor = minor;
        if((defined ==  2)) 
        {
            this->_Build = -1;
            this->_Revision = -1;
            return;
        }
        if((build < 0)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("build"));
        }
        this->_Build = build;
        if((defined ==  3)) 
        {
            this->_Revision = -1;
            return;
        }
        if((revision < 0)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("revision"));
        }
        this->_Revision = revision;
    }
    
    Object* Version::Clone() {
        if((this->_Build ==  -1)) 
        {
            return cli::gcnew<Version>(this->_Major, this->_Minor);
        }
         else 
        {
            if((this->_Revision ==  -1)) 
            {
                return cli::gcnew<Version>(this->_Major, this->_Minor, this->_Build);
            }
             else 
            {
                return cli::gcnew<Version>(this->_Major, this->_Minor, this->_Build, this->_Revision);
            }
        }
    }
    
    int32_t Version::CompareTo(Object* version) {
        if((version ==  nullptr)) 
        {
            return 1;
        }
        if(!(cli::is<Version>(version))) 
        {
            throw cli::gcnew<ArgumentException>(Locale::GetText(_T("Argument to Version.CompareTo must be a Version.")));
        }
        return this->CompareTo2(cli::cast<Version*>(version));
    }
    
    bool Version::Equals_ed975d2f4a7d193e(Object* obj) {
        return this->Equals4(cli::as<Version*>(obj));
    }
    
    int32_t Version::CompareTo2(Version* value) {
        if(op_Equality(value, nullptr)) 
        {
            return 1;
        }
        if((this->_Major > value->_Major)) 
        {
            return 1;
        }
         else 
        {
            if((this->_Major < value->_Major)) 
            {
                return -1;
            }
        }
        if((this->_Minor > value->_Minor)) 
        {
            return 1;
        }
         else 
        {
            if((this->_Minor < value->_Minor)) 
            {
                return -1;
            }
        }
        if((this->_Build > value->_Build)) 
        {
            return 1;
        }
         else 
        {
            if((this->_Build < value->_Build)) 
            {
                return -1;
            }
        }
        if((this->_Revision > value->_Revision)) 
        {
            return 1;
        }
         else 
        {
            if((this->_Revision < value->_Revision)) 
            {
                return -1;
            }
        }
        return 0;
    }
    
    bool Version::Equals4(Version* obj) {
        return ((((op_Inequality(obj, nullptr) && (obj->_Major ==  this->_Major)) && (obj->_Minor ==  this->_Minor)) && (obj->_Build ==  this->_Build)) && (obj->_Revision ==  this->_Revision));
    }
    
    int32_t Version::GetHashCode_6648aef0f235ee6c() {
        return ((((this->_Revision << 24) | (this->_Build << 16)) | (this->_Minor << 8)) | this->_Major);
    }
    
    String* Version::ToString_1636a0751cb9ac11() {
        String *mm = cli::concat(cli::import(this->_Major)->ToString_1636a0751cb9ac11(), _T("."));
        if((this->_Build != -1)) 
        {
            mm = cli::concat(mm, _T("."));
        }
        if((this->_Revision != -1)) 
        {
            mm = cli::concat(mm, _T("."));
        }
        return mm;
    }
    
    String* Version::ToString3(int32_t fieldCount) {
        if((fieldCount ==  0)) 
        {
            return String::Empty;
        }
        if((fieldCount ==  1)) 
        {
            return cli::import(this->_Major)->ToString_1636a0751cb9ac11();
        }
        if((fieldCount ==  2)) 
        {
            return cli::concat(cli::import(this->_Major)->ToString_1636a0751cb9ac11(), _T("."));
        }
        if((fieldCount ==  3)) 
        {
            if((this->_Build ==  -1)) 
            {
                throw cli::gcnew<ArgumentException>(Locale::GetText(_T("fieldCount is larger than the number of components defined in this instance.")));
            }
            return cli::concat(cli::import(this->_Major)->ToString_1636a0751cb9ac11(), _T("."), cli::import(this->_Minor)->ToString_1636a0751cb9ac11(), _T("."), cli::import(this->_Build)->ToString_1636a0751cb9ac11());
        }
        if((fieldCount ==  4)) 
        {
            if(((this->_Build ==  -1) || (this->_Revision ==  -1))) 
            {
                throw cli::gcnew<ArgumentException>(Locale::GetText(_T("fieldCount is larger than the number of components defined in this instance.")));
            }
            return cli::concat(cli::import(this->_Major)->ToString_1636a0751cb9ac11(), _T("."), cli::import(this->_Minor)->ToString_1636a0751cb9ac11(), _T("."), cli::import(this->_Build)->ToString_1636a0751cb9ac11(), _T("."), cli::import(this->_Revision)->ToString_1636a0751cb9ac11());
        }
        throw cli::gcnew<ArgumentException>(cli::concat(Locale::GetText(_T("Invalid fieldCount parameter: ")), cli::import(fieldCount)->ToString_1636a0751cb9ac11()));
    }
    
    Version* Version::Parse(String* input) {
        return cli::gcnew<Version>(input);
    }
    
    bool Version::TryParse(String* input, Version* result) {
        int32_t n;
        cli::array<String*> *vals;
        cli::array<int32_t> *values;
        result = nullptr;
        if((input ==  nullptr)) 
        {
            return false;
        }
        vals = input->Split((new cli::array<char16_t>({u'.'})));
        n = vals->get_Length();
        if(((n < 2) || (n > 4))) 
        {
            return false;
        }
        values = (new cli::array<int32_t>(n));
        for(int32_t i = 0; (i < n); i++){
            int32_t part;
            if((!(Int32::TryParse(vals->at(i), part)) || (part < 0))) 
            {
                return false;
            }
            values->at(i) = part;
        }
        result = cli::gcnew<Version>();
        if((n > 0)) 
        {
            result->_Major = values->at(0);
        }
        if((n > 1)) 
        {
            result->_Minor = values->at(1);
        }
        if((n > 2)) 
        {
            result->_Build = values->at(2);
        }
        if((n > 3)) 
        {
            result->_Revision = values->at(3);
        }
        return true;
    }
    
    Version* Version::CreateFromString(String* info) {
        int32_t major = 0;
        int32_t minor = 0;
        int32_t build = 0;
        int32_t revision = 0;
        int32_t state = 1;
        int32_t number = -1;
        if((info ==  nullptr)) 
        {
            return cli::gcnew<Version>(0, 0, 0, 0);
        }
        for(int32_t i = 0; (i < info->get_Length()); i++){
            char16_t c = info->get_Chars(i);
            if(Char::IsDigit(c)) 
            {
                if((number < 0)) 
                {
                    number = ((int32_t)(c) - 48);
                }
                 else 
                {
                    number = ((number * 10) + ((int32_t)(c) - 48));
                }
            }
             else 
            {
                if((number >= 0)) 
                {
                    switch(state) {
                        case 1: case_938: {
                            major = number;
                            break;
                        }
                        case 2: case_939: {
                            minor = number;
                            break;
                        }
                        case 3: case_940: {
                            build = number;
                            break;
                        }
                        case 4: case_941: {
                            revision = number;
                            break;
                        }
                    }
                    number = -1;
                    state++;
                }
            }
            if((state ==  5)) 
            {
                break;
            }
        }
        if((number >= 0)) 
        {
            switch(state) {
                case 1: case_942: {
                    major = number;
                    break;
                }
                case 2: case_943: {
                    minor = number;
                    break;
                }
                case 3: case_944: {
                    build = number;
                    break;
                }
                case 4: case_945: {
                    revision = number;
                    break;
                }
            }
        }
        return cli::gcnew<Version>(major, minor, build, revision);
    }
    
    bool Version::op_Equality(Version* v1, Version* v2) {
        return Object::Equals2(v1, v2);
    }
    
    bool Version::op_Inequality(Version* v1, Version* v2) {
        return !(Object::Equals2(v1, v2));
    }
    
    bool Version::op_GreaterThan(Version* v1, Version* v2) {
        return (v1->CompareTo2(v2) > 0);
    }
    
    bool Version::op_GreaterThanOrEqual(Version* v1, Version* v2) {
        return (v1->CompareTo2(v2) >= 0);
    }
    
    bool Version::op_LessThan(Version* v1, Version* v2) {
        return (v1->CompareTo2(v2) < 0);
    }
    
    bool Version::op_LessThanOrEqual(Version* v1, Version* v2) {
        return (v1->CompareTo2(v2) <= 0);
    }
    
    int32_t Version::get_Build() {
        return this->_Build;
    }
    
    int32_t Version::get_Major() {
        return this->_Major;
    }
    
    int32_t Version::get_Minor() {
        return this->_Minor;
    }
    
    int32_t Version::get_Revision() {
        return this->_Revision;
    }
    
    int16_t Version::get_MajorRevision() {
        return (int16_t)(this->_Revision >> 16);
    }
    
    int16_t Version::get_MinorRevision() {
        return (int16_t)this->_Revision;
    }
    
}
namespace System {
    
    
    void WeakReference::constructor(Object* target) {
    }
    
    void WeakReference::constructor(Object* target, bool trackResurrection) {
        this->isLongReference = trackResurrection;
        AllocateHandle(target);
    }
    
    void WeakReference::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        if((info ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("info"));
        }
        this->isLongReference = info->GetBoolean(_T("TrackResurrection"));
        Object *target = info->GetValue(_T("TrackedObject"), cli::typeof<Type>::info);
        AllocateHandle(target);
    }
    
    void WeakReference::Finalize_ff598d82cfedbf51() {
        {
            cli::finally_guard([&]() {
                Finalize_b946fbc32e26afd6();
            });
            this->gcHandle->Free();
        }
    }
    
    void WeakReference::AllocateHandle(Object* target) {
        if(this->isLongReference) 
        {
            this->gcHandle = Runtime::InteropServices::GCHandle::Alloc2(target, Runtime::InteropServices::GCHandleType::WeakTrackResurrection);
        }
         else 
        {
            this->gcHandle = Runtime::InteropServices::GCHandle::Alloc2(target, Runtime::InteropServices::GCHandleType::Weak);
        }
    }
    
    void WeakReference::GetObjectData_d18af1d641fa5d4e(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        if((info ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("info"));
        }
        info->AddValue6(_T("TrackResurrection"), this->get_TrackResurrection_2c0ad7d726fd0373());
        try {
            info->AddValue16(_T("TrackedObject"), this->get_Target_4c75add6ace39d1f());
        }
        catch(Exception*) {
            info->AddValue16(_T("TrackedObject"), nullptr);
        }
    }
    
    bool WeakReference::get_IsAlive_a17364112f61bda0() {
        return (this->get_Target_4c75add6ace39d1f() != nullptr);
    }
    
    Object* WeakReference::get_Target_4c75add6ace39d1f() {
        return this->gcHandle->get_Target();
    }
    
    Object* WeakReference::set_Target_620f6f0fddcc5c17(Object* value) {
        this->gcHandle->set_Target(value);
        return get_Target_4c75add6ace39d1f();
    }
    
    bool WeakReference::get_TrackResurrection_2c0ad7d726fd0373() {
        return this->isLongReference;
    }
    
}
namespace System {
    
    
    void WindowsConsoleDriver::constructor() {
        this->outputHandle = GetStdHandle(Handles::STD_OUTPUT);
        this->inputHandle = GetStdHandle(Handles::STD_INPUT);
        ConsoleScreenBufferInfo info = cli::ctor<ConsoleScreenBufferInfo>();
        GetConsoleScreenBufferInfo(this->outputHandle, info);
        this->defaultAttribute = info->Attribute2;
    }
    
    ConsoleColor WindowsConsoleDriver::GetForeground(int16_t attr) {
        (attr = (int16_t)((int32_t)(attr) & 15));
        return (ConsoleColor)(attr);
    }
    
    ConsoleColor WindowsConsoleDriver::GetBackground(int16_t attr) {
        (attr = (int16_t)((int32_t)(attr) & 240));
        (attr = (int16_t)((int32_t)(attr) >> 4));
        return (ConsoleColor)(attr);
    }
    
    int16_t WindowsConsoleDriver::GetAttrForeground(int32_t attr, ConsoleColor color) {
        (attr = attr & -16);
        return (int16_t)(attr | (int32_t)(color));
    }
    
    int16_t WindowsConsoleDriver::GetAttrBackground(int32_t attr, ConsoleColor color) {
        (attr = attr & -241);
        int32_t c = ((int32_t)(color) << 4);
        return (int16_t)(attr | c);
    }
    
    void WindowsConsoleDriver::Beep(int32_t frequency, int32_t duration) {
        _Beep(frequency, duration);
    }
    
    void WindowsConsoleDriver::Clear() {
        Coord coord = cli::ctor<Coord>();
        ConsoleScreenBufferInfo info = cli::ctor<ConsoleScreenBufferInfo>();
        GetConsoleScreenBufferInfo(this->outputHandle, info);
        int32_t size = ((int32_t)(info->Size->X) * (int32_t)(info->Size->Y));
        int32_t written;
        FillConsoleOutputCharacter(this->outputHandle, u' ', size, coord, written);
        GetConsoleScreenBufferInfo(this->outputHandle, info);
        FillConsoleOutputAttribute(this->outputHandle, info->Attribute2, size, coord, written);
        SetConsoleCursorPosition(this->outputHandle, coord);
    }
    
    void WindowsConsoleDriver::MoveBufferArea(int32_t sourceLeft, int32_t sourceTop, int32_t sourceWidth, int32_t sourceHeight, int32_t targetLeft, int32_t targetTop, char16_t sourceChar, ConsoleColor sourceForeColor, ConsoleColor sourceBackColor) {
        if(((int32_t)(sourceForeColor) < 0)) 
        {
            throw cli::gcnew<ArgumentException>(_T("Cannot be less than 0."), _T("sourceForeColor"));
        }
        if(((int32_t)(sourceBackColor) < 0)) 
        {
            throw cli::gcnew<ArgumentException>(_T("Cannot be less than 0."), _T("sourceBackColor"));
        }
        if(((sourceWidth ==  0) || (sourceHeight ==  0))) 
        {
            return;
        }
        ConsoleScreenBufferInfo info = cli::ctor<ConsoleScreenBufferInfo>();
        GetConsoleScreenBufferInfo(this->outputHandle, info);
        cli::array<CharInfo> *buffer = (new cli::array<CharInfo>((sourceWidth * sourceHeight)));
        Coord bsize = cli::ctor<Coord>(sourceWidth, sourceHeight);
        Coord bpos = cli::ctor<Coord>(0, 0);
        SmallRect region = cli::ctor<SmallRect>(sourceLeft, sourceTop, ((sourceLeft + sourceWidth) - 1), ((sourceTop + sourceHeight) - 1));
        {
            /* FIXED - BLOCK */
            void* ptr = cli::fixed_guard((void*)(&(buffer->at(0))));
            if(!(ReadConsoleOutput(this->outputHandle, ptr, bsize, bpos, region))) 
            {
                throw cli::gcnew<ArgumentException>(String::Empty, _T("Cannot read from the specified coordinates."));
            }
        }
        int32_t written;
        int16_t attr = GetAttrForeground(0, sourceForeColor);
        attr = GetAttrBackground((int32_t)(attr), sourceBackColor);
        bpos = cli::ctor<Coord>(sourceLeft, sourceTop);
        for(int32_t i = 0; (i < sourceHeight); i++, bpos->Y++){
            FillConsoleOutputCharacter(this->outputHandle, sourceChar, sourceWidth, bpos, written);
            FillConsoleOutputAttribute(this->outputHandle, attr, sourceWidth, bpos, written);
        }
        bpos = cli::ctor<Coord>(0, 0);
        region = cli::ctor<SmallRect>(targetLeft, targetTop, ((targetLeft + sourceWidth) - 1), ((targetTop + sourceHeight) - 1));
        if(!(WriteConsoleOutput(this->outputHandle, buffer, bsize, bpos, region))) 
        {
            throw cli::gcnew<ArgumentException>(String::Empty, _T("Cannot write to the specified coordinates."));
        }
    }
    
    void WindowsConsoleDriver::Init() {
    }
    
    String* WindowsConsoleDriver::ReadLine() {
        Text::StringBuilder *builder = cli::gcnew<Text::StringBuilder>();
        bool exit = false;
        do {
            ConsoleKeyInfo key = ReadKey(false);
            char16_t c = key->get_KeyChar();
            exit = ((int32_t)(c) ==  10);
            if(!(exit)) 
            {
                builder->Append16(key->get_KeyChar());
            }
        }
        while(!(exit));
        return builder->ToString_1636a0751cb9ac11();
    }
    
    ConsoleKeyInfo WindowsConsoleDriver::ReadKey(bool intercept) {
        int32_t eventsRead;
        InputRecord record = cli::ctor<InputRecord>();
        for(; ; ){
            if(!(ReadConsoleInput(this->inputHandle, record, 1, eventsRead))) 
            {
                throw cli::gcnew<InvalidOperationException>(cli::concat(_T("Error in ReadConsoleInput "), cli::box(Runtime::InteropServices::Marshal::GetLastWin32Error())));
            }
            if(((record->KeyDown && ((int32_t)(record->EventType) ==  1)) && !(IsModifierKey(record->VirtualKeyCode)))) 
            {
                break;
            }
        }
        bool alt = ((record->ControlKeyState & 3) != 0);
        bool ctrl = ((record->ControlKeyState & 12) != 0);
        bool shift = ((record->ControlKeyState & 16) != 0);
        return cli::ctor<ConsoleKeyInfo>(record->Character, (ConsoleKey)(record->VirtualKeyCode), shift, alt, ctrl);
    }
    
    void WindowsConsoleDriver::ResetColor() {
        SetConsoleTextAttribute(this->outputHandle, this->defaultAttribute);
    }
    
    void WindowsConsoleDriver::SetBufferSize(int32_t width, int32_t height) {
        ConsoleScreenBufferInfo info = cli::ctor<ConsoleScreenBufferInfo>();
        GetConsoleScreenBufferInfo(this->outputHandle, info);
        if(((width - 1) > (int32_t)(info->Window->Right))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("width"));
        }
        if(((height - 1) > (int32_t)(info->Window->Bottom))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("height"));
        }
        Coord coord = cli::ctor<Coord>(width, height);
        if(!(SetConsoleScreenBufferSize(this->outputHandle, coord))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("height/width"), _T("Cannot be smaller than the window size."));
        }
    }
    
    void WindowsConsoleDriver::SetCursorPosition(int32_t left, int32_t top) {
        Coord coord = cli::ctor<Coord>(left, top);
        SetConsoleCursorPosition(this->outputHandle, coord);
    }
    
    void WindowsConsoleDriver::SetWindowPosition(int32_t left, int32_t top) {
        ConsoleScreenBufferInfo info = cli::ctor<ConsoleScreenBufferInfo>();
        GetConsoleScreenBufferInfo(this->outputHandle, info);
        SmallRect rect = info->Window;
        rect->Left = (int16_t)left;
        rect->Top = (int16_t)top;
        if(!(SetConsoleWindowInfo(this->outputHandle, true, rect))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("left/top"), cli::concat(_T("Windows error "), cli::box(Runtime::InteropServices::Marshal::GetLastWin32Error())));
        }
    }
    
    void WindowsConsoleDriver::SetWindowSize(int32_t width, int32_t height) {
        ConsoleScreenBufferInfo info = cli::ctor<ConsoleScreenBufferInfo>();
        GetConsoleScreenBufferInfo(this->outputHandle, info);
        SmallRect rect = info->Window;
        rect->Right = (int16_t)(((int32_t)(rect->Left) + width) - 1);
        rect->Bottom = (int16_t)(((int32_t)(rect->Top) + height) - 1);
        if(!(SetConsoleWindowInfo(this->outputHandle, true, rect))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("left/top"), cli::concat(_T("Windows error "), cli::box(Runtime::InteropServices::Marshal::GetLastWin32Error())));
        }
    }
    
    bool WindowsConsoleDriver::IsModifierKey(int16_t virtualKeyCode) {
        switch(virtualKeyCode) {
            case 16: case 17: case 18: case 19: case 20: case_946: {
                return true;
            }
            case 44: case 144: case 145: case_947: {
                return true;
            }
            default: case_948: {
                return false;
            }
        }
    }
    
    void* WindowsConsoleDriver::GetStdHandle(Handles handle) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void WindowsConsoleDriver::_Beep(int32_t frequency, int32_t duration) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool WindowsConsoleDriver::GetConsoleScreenBufferInfo(void* handle, ConsoleScreenBufferInfo info) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool WindowsConsoleDriver::FillConsoleOutputCharacter(void* handle, char16_t c, int32_t size, Coord coord, int32_t written) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool WindowsConsoleDriver::FillConsoleOutputAttribute(void* handle, int16_t c, int32_t size, Coord coord, int32_t written) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool WindowsConsoleDriver::SetConsoleCursorPosition(void* handle, Coord coord) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool WindowsConsoleDriver::SetConsoleTextAttribute(void* handle, int16_t attribute) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool WindowsConsoleDriver::SetConsoleScreenBufferSize(void* handle, Coord newSize) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool WindowsConsoleDriver::SetConsoleWindowInfo(void* handle, bool absolute, SmallRect rect) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t WindowsConsoleDriver::GetConsoleTitle(Text::StringBuilder* sb, int32_t size) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool WindowsConsoleDriver::SetConsoleTitle(String* title) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool WindowsConsoleDriver::GetConsoleCursorInfo(void* handle, ConsoleCursorInfo info) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool WindowsConsoleDriver::SetConsoleCursorInfo(void* handle, ConsoleCursorInfo info) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int16_t WindowsConsoleDriver::GetKeyState(int32_t virtKey) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool WindowsConsoleDriver::GetConsoleMode(void* handle, int32_t mode) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool WindowsConsoleDriver::SetConsoleMode(void* handle, int32_t mode) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool WindowsConsoleDriver::PeekConsoleInput(void* handle, InputRecord record, int32_t length, int32_t eventsRead) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool WindowsConsoleDriver::ReadConsoleInput(void* handle, InputRecord record, int32_t length, int32_t nread) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    Coord WindowsConsoleDriver::GetLargestConsoleWindowSize(void* handle) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool WindowsConsoleDriver::ReadConsoleOutput(void* handle, void* buffer, Coord bsize, Coord bpos, SmallRect region) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool WindowsConsoleDriver::WriteConsoleOutput(void* handle, cli::array<CharInfo>* buffer, Coord bsize, Coord bpos, SmallRect region) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    ConsoleColor WindowsConsoleDriver::get_BackgroundColor() {
        ConsoleScreenBufferInfo info = cli::ctor<ConsoleScreenBufferInfo>();
        GetConsoleScreenBufferInfo(this->outputHandle, info);
        return GetBackground(info->Attribute2);
    }
    
    ConsoleColor WindowsConsoleDriver::set_BackgroundColor(ConsoleColor value) {
        ConsoleScreenBufferInfo info = cli::ctor<ConsoleScreenBufferInfo>();
        GetConsoleScreenBufferInfo(this->outputHandle, info);
        int16_t attr = GetAttrBackground((int32_t)(info->Attribute2), value);
        SetConsoleTextAttribute(this->outputHandle, attr);
        return get_BackgroundColor();
    }
    
    int32_t WindowsConsoleDriver::get_BufferHeight() {
        ConsoleScreenBufferInfo info = cli::ctor<ConsoleScreenBufferInfo>();
        GetConsoleScreenBufferInfo(this->outputHandle, info);
        return (int32_t)(info->Size->Y);
    }
    
    int32_t WindowsConsoleDriver::set_BufferHeight(int32_t value) {
        SetBufferSize(this->get_BufferWidth(), value);
        return get_BufferHeight();
    }
    
    int32_t WindowsConsoleDriver::get_BufferWidth() {
        ConsoleScreenBufferInfo info = cli::ctor<ConsoleScreenBufferInfo>();
        GetConsoleScreenBufferInfo(this->outputHandle, info);
        return (int32_t)(info->Size->X);
    }
    
    int32_t WindowsConsoleDriver::set_BufferWidth(int32_t value) {
        SetBufferSize(value, this->get_BufferHeight());
        return get_BufferWidth();
    }
    
    bool WindowsConsoleDriver::get_CapsLock() {
        int16_t state = GetKeyState(20);
        return (((int32_t)(state) & 1) ==  1);
    }
    
    int32_t WindowsConsoleDriver::get_CursorLeft() {
        ConsoleScreenBufferInfo info = cli::ctor<ConsoleScreenBufferInfo>();
        GetConsoleScreenBufferInfo(this->outputHandle, info);
        return (int32_t)(info->CursorPosition->X);
    }
    
    int32_t WindowsConsoleDriver::set_CursorLeft(int32_t value) {
        SetCursorPosition(value, this->get_CursorTop());
        return get_CursorLeft();
    }
    
    int32_t WindowsConsoleDriver::get_CursorSize() {
        ConsoleCursorInfo info = cli::ctor<ConsoleCursorInfo>();
        GetConsoleCursorInfo(this->outputHandle, info);
        return info->Size;
    }
    
    int32_t WindowsConsoleDriver::set_CursorSize(int32_t value) {
        if(((value < 1) || (value > 100))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("value"));
        }
        ConsoleCursorInfo info = cli::ctor<ConsoleCursorInfo>();
        GetConsoleCursorInfo(this->outputHandle, info);
        info->Size = value;
        if(!(SetConsoleCursorInfo(this->outputHandle, info))) 
        {
            throw cli::gcnew<Exception>(_T("SetConsoleCursorInfo failed"));
        }
        return get_CursorSize();
    }
    
    int32_t WindowsConsoleDriver::get_CursorTop() {
        ConsoleScreenBufferInfo info = cli::ctor<ConsoleScreenBufferInfo>();
        GetConsoleScreenBufferInfo(this->outputHandle, info);
        return (int32_t)(info->CursorPosition->Y);
    }
    
    int32_t WindowsConsoleDriver::set_CursorTop(int32_t value) {
        SetCursorPosition(this->get_CursorLeft(), value);
        return get_CursorTop();
    }
    
    bool WindowsConsoleDriver::get_CursorVisible() {
        ConsoleCursorInfo info = cli::ctor<ConsoleCursorInfo>();
        GetConsoleCursorInfo(this->outputHandle, info);
        return info->Visible;
    }
    
    bool WindowsConsoleDriver::set_CursorVisible(bool value) {
        ConsoleCursorInfo info = cli::ctor<ConsoleCursorInfo>();
        GetConsoleCursorInfo(this->outputHandle, info);
        if((info->Visible ==  value)) 
        {
            return get_CursorVisible();
        }
        info->Visible = value;
        if(!(SetConsoleCursorInfo(this->outputHandle, info))) 
        {
            throw cli::gcnew<Exception>(_T("SetConsoleCursorInfo failed"));
        }
        return get_CursorVisible();
    }
    
    ConsoleColor WindowsConsoleDriver::get_ForegroundColor() {
        ConsoleScreenBufferInfo info = cli::ctor<ConsoleScreenBufferInfo>();
        GetConsoleScreenBufferInfo(this->outputHandle, info);
        return GetForeground(info->Attribute2);
    }
    
    ConsoleColor WindowsConsoleDriver::set_ForegroundColor(ConsoleColor value) {
        ConsoleScreenBufferInfo info = cli::ctor<ConsoleScreenBufferInfo>();
        GetConsoleScreenBufferInfo(this->outputHandle, info);
        int16_t attr = GetAttrForeground((int32_t)(info->Attribute2), value);
        SetConsoleTextAttribute(this->outputHandle, attr);
        return get_ForegroundColor();
    }
    
    bool WindowsConsoleDriver::get_KeyAvailable() {
        int32_t eventsRead;
        InputRecord record = cli::ctor<InputRecord>();
        while(true) {
            if(!(PeekConsoleInput(this->inputHandle, record, 1, eventsRead))) 
            {
                throw cli::gcnew<InvalidOperationException>(cli::concat(_T("Error in PeekConsoleInput "), cli::box(Runtime::InteropServices::Marshal::GetLastWin32Error())));
            }
            if((eventsRead ==  0)) 
            {
                return false;
            }
            if((((int32_t)(record->EventType) ==  1) && record->KeyDown)) 
            {
                return true;
            }
            if(!(ReadConsoleInput(this->inputHandle, record, 1, eventsRead))) 
            {
                throw cli::gcnew<InvalidOperationException>(cli::concat(_T("Error in ReadConsoleInput "), cli::box(Runtime::InteropServices::Marshal::GetLastWin32Error())));
            }
        }
    }
    
    bool WindowsConsoleDriver::get_Initialized() {
        return false;
    }
    
    int32_t WindowsConsoleDriver::get_LargestWindowHeight() {
        Coord coord = GetLargestConsoleWindowSize(this->outputHandle);
        if((((int32_t)(coord->X) ==  0) && ((int32_t)(coord->Y) ==  0))) 
        {
            throw cli::gcnew<Exception>(cli::concat(_T("GetLargestConsoleWindowSize"), cli::box(Runtime::InteropServices::Marshal::GetLastWin32Error())));
        }
        return (int32_t)(coord->Y);
    }
    
    int32_t WindowsConsoleDriver::get_LargestWindowWidth() {
        Coord coord = GetLargestConsoleWindowSize(this->outputHandle);
        if((((int32_t)(coord->X) ==  0) && ((int32_t)(coord->Y) ==  0))) 
        {
            throw cli::gcnew<Exception>(cli::concat(_T("GetLargestConsoleWindowSize"), cli::box(Runtime::InteropServices::Marshal::GetLastWin32Error())));
        }
        return (int32_t)(coord->X);
    }
    
    bool WindowsConsoleDriver::get_NumberLock() {
        int16_t state = GetKeyState(144);
        return (((int32_t)(state) & 1) ==  1);
    }
    
    String* WindowsConsoleDriver::get_Title() {
        Text::StringBuilder *sb = cli::gcnew<Text::StringBuilder>(1024);
        if((GetConsoleTitle(sb, 1024) ==  0)) 
        {
            sb = cli::gcnew<Text::StringBuilder>(26001);
            if((GetConsoleTitle(sb, 26000) ==  0)) 
            {
                throw cli::gcnew<Exception>(cli::concat(_T("Got "), cli::box(Runtime::InteropServices::Marshal::GetLastWin32Error())));
            }
        }
        return sb->ToString_1636a0751cb9ac11();
    }
    
    String* WindowsConsoleDriver::set_Title(String* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("value"));
        }
        if(!(SetConsoleTitle(value))) 
        {
            throw cli::gcnew<Exception>(cli::concat(_T("Got "), cli::box(Runtime::InteropServices::Marshal::GetLastWin32Error())));
        }
        return get_Title();
    }
    
    bool WindowsConsoleDriver::get_TreatControlCAsInput() {
        int32_t mode;
        if(!(GetConsoleMode(this->inputHandle, mode))) 
        {
            throw cli::gcnew<Exception>(cli::concat(_T("Failed in GetConsoleMode: "), cli::box(Runtime::InteropServices::Marshal::GetLastWin32Error())));
        }
        return ((mode & 1) ==  0);
    }
    
    bool WindowsConsoleDriver::set_TreatControlCAsInput(bool value) {
        int32_t mode;
        if(!(GetConsoleMode(this->inputHandle, mode))) 
        {
            throw cli::gcnew<Exception>(cli::concat(_T("Failed in GetConsoleMode: "), cli::box(Runtime::InteropServices::Marshal::GetLastWin32Error())));
        }
        bool cAsInput = ((mode & 1) ==  0);
        if((cAsInput ==  value)) 
        {
            return get_TreatControlCAsInput();
        }
        if(value) 
        {
            (mode = mode & -2);
        }
         else 
        {
            (mode = mode | 1);
        }
        if(!(SetConsoleMode(this->inputHandle, mode))) 
        {
            throw cli::gcnew<Exception>(cli::concat(_T("Failed in SetConsoleMode: "), cli::box(Runtime::InteropServices::Marshal::GetLastWin32Error())));
        }
        return get_TreatControlCAsInput();
    }
    
    int32_t WindowsConsoleDriver::get_WindowHeight() {
        ConsoleScreenBufferInfo info = cli::ctor<ConsoleScreenBufferInfo>();
        GetConsoleScreenBufferInfo(this->outputHandle, info);
        return (((int32_t)(info->Window->Bottom) - (int32_t)(info->Window->Top)) + 1);
    }
    
    int32_t WindowsConsoleDriver::set_WindowHeight(int32_t value) {
        SetWindowSize(this->get_WindowWidth(), value);
        return get_WindowHeight();
    }
    
    int32_t WindowsConsoleDriver::get_WindowLeft() {
        ConsoleScreenBufferInfo info = cli::ctor<ConsoleScreenBufferInfo>();
        GetConsoleScreenBufferInfo(this->outputHandle, info);
        return (int32_t)(info->Window->Left);
    }
    
    int32_t WindowsConsoleDriver::set_WindowLeft(int32_t value) {
        SetWindowPosition(value, this->get_WindowTop());
        return get_WindowLeft();
    }
    
    int32_t WindowsConsoleDriver::get_WindowTop() {
        ConsoleScreenBufferInfo info = cli::ctor<ConsoleScreenBufferInfo>();
        GetConsoleScreenBufferInfo(this->outputHandle, info);
        return (int32_t)(info->Window->Top);
    }
    
    int32_t WindowsConsoleDriver::set_WindowTop(int32_t value) {
        SetWindowPosition(this->get_WindowLeft(), value);
        return get_WindowTop();
    }
    
    int32_t WindowsConsoleDriver::get_WindowWidth() {
        ConsoleScreenBufferInfo info = cli::ctor<ConsoleScreenBufferInfo>();
        GetConsoleScreenBufferInfo(this->outputHandle, info);
        return (((int32_t)(info->Window->Right) - (int32_t)(info->Window->Left)) + 1);
    }
    
    int32_t WindowsConsoleDriver::set_WindowWidth(int32_t value) {
        SetWindowSize(value, this->get_WindowHeight());
        return get_WindowWidth();
    }
    
}
namespace System {
    
    
    void __ComObject::constructor() {
        Initialize(Object::GetType());
    }
    
    void __ComObject::constructor(Type* t) {
        Initialize(t);
    }
    
    void __ComObject::constructor(void* pItf) {
        InitializeApartmentDetails();
        Guid iid = get_IID_IUnknown();
        int32_t hr = Runtime::InteropServices::Marshal::QueryInterface(pItf, iid, this->iunknown);
        Runtime::InteropServices::Marshal::ThrowExceptionForHR(hr);
    }
    
    void __ComObject::Finalize_e871e3b866a85e2c() {
        {
            cli::finally_guard([&]() {
                Finalize_b946fbc32e26afd6();
            });
            if((this->synchronization_context != nullptr)) 
            {
                this->synchronization_context->Post_3eaec456ea854a8e(cli::bind([&] (Object* state) -> void {
                     ReleaseInterfaces();
                }
                ), this);
            }
             else 
            {
                ReleaseInterfaces();
            }
        }
    }
    
    __ComObject* __ComObject::CreateRCW(Type* t) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void __ComObject::ReleaseInterfaces() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void __ComObject::Initialize(Type* t) {
        InitializeApartmentDetails();
        if(::System::IntPtr::op_Inequality(this->iunknown, (*::System::IntPtr::Zero))) 
        {
            return;
        }
        Runtime::InteropServices::ObjectCreationDelegate *ocd = Runtime::InteropServices::ExtensibleClassFactory::GetObjectCreationCallback(t);
        if((ocd != nullptr)) 
        {
            this->iunknown = ocd->Invoke((*::System::IntPtr::Zero));
            if(::System::IntPtr::op_Equality(this->iunknown, (*::System::IntPtr::Zero))) 
            {
                throw cli::gcnew<Runtime::InteropServices::COMException>(String::Format2(_T("ObjectCreationDelegate for type {0} failed to return a valid COM object"), t));
            }
        }
         else 
        {
            int32_t hr = CoCreateInstance(GetCLSID(t), (*::System::IntPtr::Zero), 21U, __ComObject::get_IID_IUnknown(), this->iunknown);
            Runtime::InteropServices::Marshal::ThrowExceptionForHR(hr);
        }
    }
    
    void __ComObject::InitializeApartmentDetails() {
        if(((int32_t)(Threading::Thread::get_CurrentThread()->GetApartmentState()) != 0)) 
        {
            return;
        }
        this->synchronization_context = Threading::SynchronizationContext::get_Current();
        if(((this->synchronization_context != nullptr) && Type::op_Equality2(this->synchronization_context->GetType(), cli::typeof<Type>::info))) 
        {
            this->synchronization_context = nullptr;
        }
    }
    
    Guid __ComObject::GetCLSID(Type* t) {
        if(t->get_IsImport()) 
        {
            return t->get_GUID_bdb6b630c3237a21();
        }
        Type *super = t->get_BaseType_6a0646ae880055f6();
        while(Type::op_Inequality2(super, cli::typeof<Type>::info)) {
            if(super->get_IsImport()) 
            {
                return super->get_GUID_bdb6b630c3237a21();
            }
            super = super->get_BaseType_6a0646ae880055f6();
        }
        throw cli::gcnew<Runtime::InteropServices::COMException>(cli::concat(_T("Could not find base COM type for type "), t->ToString_1636a0751cb9ac11()));
    }
    
    void* __ComObject::GetInterfaceInternal(Type* t, bool throwException) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void* __ComObject::GetInterface(Type* t, bool throwException) {
        CheckIUnknown();
        return GetInterfaceInternal(t, throwException);
    }
    
    void* __ComObject::GetInterface2(Type* t) {
        return GetInterface(t, true);
    }
    
    void __ComObject::CheckIUnknown() {
        if(::System::IntPtr::op_Equality(this->iunknown, (*::System::IntPtr::Zero))) 
        {
            throw cli::gcnew<Runtime::InteropServices::InvalidComObjectException>(_T("COM object that has been separated from its underlying RCW cannot be used."));
        }
    }
    
    bool __ComObject::Equals_ed975d2f4a7d193e(Object* obj) {
        CheckIUnknown();
        if((obj ==  nullptr)) 
        {
            return false;
        }
        __ComObject *co = cli::as<__ComObject*>(obj);
        if((cli::cast<Object*>(co) ==  nullptr)) 
        {
            return false;
        }
        return ::System::IntPtr::op_Equality(this->iunknown, co->get_IUnknown());
    }
    
    int32_t __ComObject::GetHashCode_6648aef0f235ee6c() {
        CheckIUnknown();
        return cli::import(this->iunknown)->ToInt32();
    }
    
    int32_t __ComObject::CoCreateInstance(Guid rclsid, void* pUnkOuter, uint32_t dwClsContext, Guid riid, void* pUnk) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void __ComObject::_Finalize_m__3(Object* state) {
         ReleaseInterfaces();
    }
    
    void* __ComObject::get_IUnknown() {
        if(::System::IntPtr::op_Equality(this->iunknown, (*::System::IntPtr::Zero))) 
        {
            throw cli::gcnew<Runtime::InteropServices::InvalidComObjectException>(_T("COM object that has been separated from its underlying RCW cannot be used."));
        }
        return this->iunknown;
    }
    
    void* __ComObject::get_IDispatch() {
        void *pUnk = GetInterface2(cli::typeof<Type>::info);
        if(::System::IntPtr::op_Equality(pUnk, (*::System::IntPtr::Zero))) 
        {
            throw cli::gcnew<Runtime::InteropServices::InvalidComObjectException>(_T("COM object that has been separated from its underlying RCW cannot be used."));
        }
        return pUnk;
    }
    
    Guid __ComObject::get_IID_IUnknown() {
        return cli::ctor<Guid>(_T("00000000-0000-0000-C000-000000000046"));
    }
    
    Guid __ComObject::get_IID_IDispatch() {
        return cli::ctor<Guid>(_T("00020400-0000-0000-C000-000000000046"));
    }
    
}
namespace System { namespace Collections {
    
    
    void ArrayListEnumerator::constructor(ArrayList* list) {
    }
    
    void ArrayListEnumerator::constructor(ArrayList* list, int32_t index, int32_t count) {
        this->m_List = list;
        this->m_Index = index;
        this->m_Count = count;
        this->m_Pos = (this->m_Index - 1);
        this->m_Current = nullptr;
        this->m_ExpectedStateChanges = list->_version;
    }
    
    System::Object* ArrayListEnumerator::Clone() {
        return this->MemberwiseClone();
    }
    
    bool ArrayListEnumerator::MoveNext() {
        if((this->m_List->_version != this->m_ExpectedStateChanges)) 
        {
            throw cli::gcnew<System::InvalidOperationException>(_T("List has changed."));
        }
        this->m_Pos++;
        if(((this->m_Pos - this->m_Index) < this->m_Count)) 
        {
            this->m_Current = this->m_List->get_Item_fd0155f142ae570(this->m_Pos);
            return true;
        }
        return false;
    }
    
    void ArrayListEnumerator::Reset() {
        this->m_Current = nullptr;
        this->m_Pos = (this->m_Index - 1);
    }
    
    System::Object* ArrayListEnumerator::get_Current() {
        if((this->m_Pos ==  (this->m_Index - 1))) 
        {
            throw cli::gcnew<System::InvalidOperationException>(_T("Enumerator unusable (Reset pending, or past end of array."));
        }
        return this->m_Current;
    }
    
}}
namespace System { namespace Collections {
    
    System::Object*  SimpleEnumerator2::endFlag;
    
    SimpleEnumerator2::SimpleEnumerator2()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void SimpleEnumerator2::constructor(ArrayList* list) {
        this->list = list;
        this->index = -1;
        this->version = list->_version;
        this->currentElement = endFlag;
    }
    
    void SimpleEnumerator2::static_constructor() {
    }
    
    System::Object* SimpleEnumerator2::Clone() {
        return System::Object::MemberwiseClone();
    }
    
    bool SimpleEnumerator2::MoveNext() {
        if((this->version != this->list->_version)) 
        {
            throw cli::gcnew<System::InvalidOperationException>(_T("List has changed."));
        }
        if((++this->index < this->list->get_Count_2354963792616712())) 
        {
            this->currentElement = this->list->get_Item_fd0155f142ae570(this->index);
            return true;
        }
         else 
        {
            this->currentElement = endFlag;
            return false;
        }
    }
    
    void SimpleEnumerator2::Reset() {
        if((this->version != this->list->_version)) 
        {
            throw cli::gcnew<System::InvalidOperationException>(_T("List has changed."));
        }
        this->currentElement = endFlag;
        this->index = -1;
    }
    
    System::Object* SimpleEnumerator2::get_Current() {
        if((this->currentElement ==  endFlag)) 
        {
            if((this->index ==  -1)) 
            {
                throw cli::gcnew<System::InvalidOperationException>(_T("Enumerator not started"));
            }
             else 
            {
                throw cli::gcnew<System::InvalidOperationException>(_T("Enumerator ended"));
            }
        }
        return this->currentElement;
    }
    
}}
namespace System { namespace Collections {
    
    
    void EnumeratorWithRange::constructor(IEnumerator* enumerator, int32_t index, int32_t count) {
        this->m_Count = 0;
        this->m_StartIndex = index;
        this->m_MaxCount = count;
        this->m_Enumerator = enumerator;
        Reset();
    }
    
    System::Object* EnumeratorWithRange::Clone() {
        return this->MemberwiseClone();
    }
    
    bool EnumeratorWithRange::MoveNext() {
        if((this->m_Count >= this->m_MaxCount)) 
        {
            return false;
        }
        this->m_Count++;
        return this->m_Enumerator->MoveNext_4e78e145935f5417();
    }
    
    void EnumeratorWithRange::Reset() {
        this->m_Count = 0;
        this->m_Enumerator->Reset_bcd82381eed41868();
        for(int32_t i = 0; (i < this->m_StartIndex); i++){
            this->m_Enumerator->MoveNext_4e78e145935f5417();
        }
    }
    
    System::Object* EnumeratorWithRange::get_Current() {
        return this->m_Enumerator->get_Current_8eca9b3da02b123a();
    }
    
}}
namespace System { namespace Collections {
    
    
    void ArrayListAdapter::constructor(IList* adaptee) {
        this->m_Adaptee = adaptee;
    }
    
    int32_t ArrayListAdapter::Add_e6a92085999ce388(System::Object* value) {
        return this->m_Adaptee->Add_985508e3bf9b7a73(value);
    }
    
    void ArrayListAdapter::Clear_cd6654e5a40f5056() {
        this->m_Adaptee->Clear_e0ee496065507a2f();
    }
    
    bool ArrayListAdapter::Contains_f1c198d01147f1ee(System::Object* value) {
        return this->m_Adaptee->Contains_2a2192a595869f4e(value);
    }
    
    int32_t ArrayListAdapter::IndexOf_7e9811d6771f771d(System::Object* value) {
        return this->m_Adaptee->IndexOf_7f6d78d7aa6d53e5(value);
    }
    
    int32_t ArrayListAdapter::IndexOf_1c0527e45dc3728e(System::Object* value, int32_t startIndex) {
        return ArrayList::IndexOf_adae3dc40eaa594e(value, startIndex, (this->m_Adaptee->get_Count_8f254f3dd8e2403() - startIndex));
    }
    
    int32_t ArrayListAdapter::IndexOf_adae3dc40eaa594e(System::Object* value, int32_t startIndex, int32_t count) {
        if(((startIndex < 0) || (startIndex > this->m_Adaptee->get_Count_8f254f3dd8e2403()))) 
        {
            ArrayList::ThrowNewArgumentOutOfRangeException(_T("startIndex"), cli::box(startIndex), _T("Does not specify valid index."));
        }
        if((count < 0)) 
        {
            ArrayList::ThrowNewArgumentOutOfRangeException(_T("count"), cli::box(count), _T("Can\'t be less than 0."));
        }
        if((startIndex > (this->m_Adaptee->get_Count_8f254f3dd8e2403() - count))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("count"), _T("Start index and count do not specify a valid range."));
        }
        if((value ==  nullptr)) 
        {
            for(int32_t i = startIndex; (i < (startIndex + count)); i++){
                if((this->m_Adaptee->get_Item_8550d21996ef9dc5(i) ==  nullptr)) 
                {
                    return i;
                }
            }
        }
         else 
        {
            for(int32_t i = startIndex; (i < (startIndex + count)); i++){
                if(value->Equals_ed975d2f4a7d193e(this->m_Adaptee->get_Item_8550d21996ef9dc5(i))) 
                {
                    return i;
                }
            }
        }
        return -1;
    }
    
    int32_t ArrayListAdapter::LastIndexOf_ecfd0185f74248a7(System::Object* value) {
        return ArrayList::LastIndexOf_ed2c73a4e33a0826(value, (this->m_Adaptee->get_Count_8f254f3dd8e2403() - 1));
    }
    
    int32_t ArrayListAdapter::LastIndexOf_ed2c73a4e33a0826(System::Object* value, int32_t startIndex) {
        return ArrayList::LastIndexOf_c6f99b5b290904b1(value, startIndex, (startIndex + 1));
    }
    
    int32_t ArrayListAdapter::LastIndexOf_c6f99b5b290904b1(System::Object* value, int32_t startIndex, int32_t count) {
        if((startIndex < 0)) 
        {
            ArrayList::ThrowNewArgumentOutOfRangeException(_T("startIndex"), cli::box(startIndex), _T("< 0"));
        }
        if((count < 0)) 
        {
            ArrayList::ThrowNewArgumentOutOfRangeException(_T("count"), cli::box(count), _T("count is negative."));
        }
        if((((startIndex - count) + 1) < 0)) 
        {
            ArrayList::ThrowNewArgumentOutOfRangeException(_T("count"), cli::box(count), _T("count is too large."));
        }
        if((value ==  nullptr)) 
        {
            for(int32_t i = startIndex; (i > (startIndex - count)); i--){
                if((this->m_Adaptee->get_Item_8550d21996ef9dc5(i) ==  nullptr)) 
                {
                    return i;
                }
            }
        }
         else 
        {
            for(int32_t i = startIndex; (i > (startIndex - count)); i--){
                if(value->Equals_ed975d2f4a7d193e(this->m_Adaptee->get_Item_8550d21996ef9dc5(i))) 
                {
                    return i;
                }
            }
        }
        return -1;
    }
    
    void ArrayListAdapter::Insert_59557a2615bf3b8e(int32_t index, System::Object* value) {
        this->m_Adaptee->Insert_16e8bd69dfc603f4(index, value);
    }
    
    void ArrayListAdapter::InsertRange_2250ae882d749466(int32_t index, ICollection* c) {
        if((c ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("c"));
        }
        if((index > this->m_Adaptee->get_Count_8f254f3dd8e2403())) 
        {
            ArrayList::ThrowNewArgumentOutOfRangeException(_T("index"), cli::box(index), _T("Index must be >= 0 and <= Count."));
        }
        for(auto tmp_203 : c) {
            auto value = cli::cast<System::Object*>(tmp_203);
            {
                this->m_Adaptee->Insert_16e8bd69dfc603f4(index++, value);
            }
        }
    }
    
    void ArrayListAdapter::Remove_2225381aaf812c6d(System::Object* value) {
        this->m_Adaptee->Remove_69f1b1e57bb34112(value);
    }
    
    void ArrayListAdapter::RemoveAt_2abea768d3273318(int32_t index) {
        this->m_Adaptee->RemoveAt_dce190584913328b(index);
    }
    
    void ArrayListAdapter::RemoveRange_808c38a5e4171a64(int32_t index, int32_t count) {
        ArrayList::CheckRange(index, count, this->m_Adaptee->get_Count_8f254f3dd8e2403());
        for(int32_t i = 0; (i < count); i++){
            this->m_Adaptee->RemoveAt_dce190584913328b(index);
        }
    }
    
    void ArrayListAdapter::Reverse_e7caef4018f63b41() {
        ArrayList::Reverse_bb783f185b528565(0, this->m_Adaptee->get_Count_8f254f3dd8e2403());
    }
    
    void ArrayListAdapter::Reverse_bb783f185b528565(int32_t index, int32_t count) {
        System::Object *tmp;
        ArrayList::CheckRange(index, count, this->m_Adaptee->get_Count_8f254f3dd8e2403());
        for(int32_t i = 0; (i < (count / 2)); i++){
            tmp = this->m_Adaptee->get_Item_8550d21996ef9dc5((i + index));
            this->m_Adaptee->set_Item_d57705373e0668e7((i + index), this->m_Adaptee->get_Item_8550d21996ef9dc5(((((index + count) - i) + index) - 1)));
            this->m_Adaptee->set_Item_d57705373e0668e7(((((index + count) - i) + index) - 1), tmp);
        }
    }
    
    void ArrayListAdapter::SetRange_87e491be8261c464(int32_t index, ICollection* c) {
        if((c ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("c"));
        }
        if(((index < 0) || ((index + c->get_Count_8f254f3dd8e2403()) > this->m_Adaptee->get_Count_8f254f3dd8e2403()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("index"));
        }
        int32_t x = index;
        for(auto tmp_204 : c) {
            auto value = cli::cast<System::Object*>(tmp_204);
            {
                this->m_Adaptee->set_Item_d57705373e0668e7(x++, value);
            }
        }
    }
    
    void ArrayListAdapter::CopyTo_c634d425a65b1fc3(System::Array* array) {
        this->m_Adaptee->CopyTo_7065a6e3cf6a140(array, 0);
    }
    
    void ArrayListAdapter::CopyTo_2bc540dad3c25b9e(System::Array* array, int32_t index) {
        this->m_Adaptee->CopyTo_7065a6e3cf6a140(array, index);
    }
    
    void ArrayListAdapter::CopyTo_4b0d97bda775c102(int32_t index, System::Array* array, int32_t arrayIndex, int32_t count) {
        if((index < 0)) 
        {
            ArrayList::ThrowNewArgumentOutOfRangeException(_T("index"), cli::box(index), _T("Can\'t be less than zero."));
        }
        if((arrayIndex < 0)) 
        {
            ArrayList::ThrowNewArgumentOutOfRangeException(_T("arrayIndex"), cli::box(arrayIndex), _T("Can\'t be less than zero."));
        }
        if((count < 0)) 
        {
            ArrayList::ThrowNewArgumentOutOfRangeException(_T("index"), cli::box(index), _T("Can\'t be less than zero."));
        }
        if((index >= this->m_Adaptee->get_Count_8f254f3dd8e2403())) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Can\'t be more or equal to list count."), _T("index"));
        }
        if((array->get_Rank() > 1)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Can\'t copy into multi-dimensional array."));
        }
        if((arrayIndex >= array->get_Length())) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("arrayIndex can\'t be greater than array.Length - 1."));
        }
        if((((array->get_Length() - arrayIndex) + 1) < count)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Destination array is too small."));
        }
        if((index > (this->m_Adaptee->get_Count_8f254f3dd8e2403() - count))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Index and count do not denote a valid range of elements."), _T("index"));
        }
        for(int32_t i = 0; (i < count); i++){
            array->SetValue5(this->m_Adaptee->get_Item_8550d21996ef9dc5((index + i)), (arrayIndex + i));
        }
    }
    
    IEnumerator* ArrayListAdapter::GetEnumerator_84e3ba8f2fdefd62() {
        return this->m_Adaptee->GetEnumerator_674ad93a972a4d67();
    }
    
    IEnumerator* ArrayListAdapter::GetEnumerator_78a3fe75766282cd(int32_t index, int32_t count) {
        ArrayList::CheckRange(index, count, this->m_Adaptee->get_Count_8f254f3dd8e2403());
        return cli::gcnew<EnumeratorWithRange>(this->m_Adaptee->GetEnumerator_674ad93a972a4d67(), index, count);
    }
    
    void ArrayListAdapter::AddRange_a8bb4db32a72ffe(ICollection* c) {
        for(auto tmp_205 : c) {
            auto value = cli::cast<System::Object*>(tmp_205);
            {
                this->m_Adaptee->Add_985508e3bf9b7a73(value);
            }
        }
    }
    
    int32_t ArrayListAdapter::BinarySearch_77606568b997fd61(System::Object* value) {
        return ArrayList::BinarySearch_f0deec366fa04a93(value, nullptr);
    }
    
    int32_t ArrayListAdapter::BinarySearch_f0deec366fa04a93(System::Object* value, IComparer* comparer) {
        return ArrayList::BinarySearch_5160cee074873e3f(0, this->m_Adaptee->get_Count_8f254f3dd8e2403(), value, comparer);
    }
    
    int32_t ArrayListAdapter::BinarySearch_5160cee074873e3f(int32_t index, int32_t count, System::Object* value, IComparer* comparer) {
        int32_t r, x, y, z;
        ArrayList::CheckRange(index, count, this->m_Adaptee->get_Count_8f254f3dd8e2403());
        if((comparer ==  nullptr)) 
        {
            comparer = Comparer::Default2;
        }
        x = index;
        y = ((index + count) - 1);
        while((x <= y)) {
            z = (x + ((y - x) / 2));
            r = comparer->Compare_451fd276747b629d(value, this->m_Adaptee->get_Item_8550d21996ef9dc5(z));
            if((r < 0)) 
            {
                y = (z - 1);
            }
             else 
            {
                if((r > 0)) 
                {
                    x = (z + 1);
                }
                 else 
                {
                    return z;
                }
            }
        }
        return ~(x);
    }
    
    System::Object* ArrayListAdapter::Clone_5d610374e21ea7b0() {
        return cli::gcnew<ArrayListAdapter>(this->m_Adaptee);
    }
    
    ArrayList* ArrayListAdapter::GetRange_21d02af9397d43dc(int32_t index, int32_t count) {
        ArrayList::CheckRange(index, count, this->m_Adaptee->get_Count_8f254f3dd8e2403());
        return cli::gcnew<RangedArrayList>(this, index, count);
    }
    
    void ArrayListAdapter::TrimToSize_d8592d0aafda93d() {
    }
    
    void ArrayListAdapter::Sort_9fb0fdfea73c2096() {
        ArrayList::Sort_bdf7dee226e6219b(Comparer::Default2);
    }
    
    void ArrayListAdapter::Sort_bdf7dee226e6219b(IComparer* comparer) {
        ArrayList::Sort_e6922b45a581abd6(0, this->m_Adaptee->get_Count_8f254f3dd8e2403(), comparer);
    }
    
    void ArrayListAdapter::Sort_e6922b45a581abd6(int32_t index, int32_t count, IComparer* comparer) {
        ArrayList::CheckRange(index, count, this->m_Adaptee->get_Count_8f254f3dd8e2403());
        if((comparer ==  nullptr)) 
        {
            comparer = Comparer::Default2;
        }
        QuickSort(this->m_Adaptee, index, ((index + count) - 1), comparer);
    }
    
    void ArrayListAdapter::Swap(IList* list, int32_t x, int32_t y) {
        System::Object *tmp;
        tmp = list->get_Item_8550d21996ef9dc5(x);
        list->set_Item_d57705373e0668e7(x, list->get_Item_8550d21996ef9dc5(y));
        list->set_Item_d57705373e0668e7(y, tmp);
    }
    
    void ArrayListAdapter::QuickSort(IList* list, int32_t left, int32_t right, IComparer* comparer) {
        int32_t i, j, middle;
        System::Object *pivot;
        if((left >= right)) 
        {
            return;
        }
        middle = (left + ((right - left) / 2));
        if((comparer->Compare_451fd276747b629d(list->get_Item_8550d21996ef9dc5(middle), list->get_Item_8550d21996ef9dc5(left)) < 0)) 
        {
            Swap(list, middle, left);
        }
        if((comparer->Compare_451fd276747b629d(list->get_Item_8550d21996ef9dc5(right), list->get_Item_8550d21996ef9dc5(left)) < 0)) 
        {
            Swap(list, right, left);
        }
        if((comparer->Compare_451fd276747b629d(list->get_Item_8550d21996ef9dc5(right), list->get_Item_8550d21996ef9dc5(middle)) < 0)) 
        {
            Swap(list, right, middle);
        }
        if((((right - left) + 1) <= 3)) 
        {
            return;
        }
        Swap(list, (right - 1), middle);
        pivot = list->get_Item_8550d21996ef9dc5((right - 1));
        i = left;
        j = (right - 1);
        for(; ; ){
            while((comparer->Compare_451fd276747b629d(list->get_Item_8550d21996ef9dc5(++i), pivot) < 0)) ;
            while((comparer->Compare_451fd276747b629d(list->get_Item_8550d21996ef9dc5(--j), pivot) > 0)) ;
            if((i < j)) 
            {
                Swap(list, i, j);
            }
             else 
            {
                break;
            }
        }
        Swap(list, (right - 1), i);
        QuickSort(list, left, (i - 1), comparer);
        QuickSort(list, (i + 1), right, comparer);
    }
    
    cli::array<System::Object*>* ArrayListAdapter::ToArray_360bcd462eb48114() {
        cli::array<System::Object*> *retval;
        retval = (new cli::array<System::Object*>(this->m_Adaptee->get_Count_8f254f3dd8e2403()));
        this->m_Adaptee->CopyTo_7065a6e3cf6a140(retval, 0);
        return retval;
    }
    
    System::Array* ArrayListAdapter::ToArray_7b80f35a5dbfbc47(System::Type* elementType) {
        System::Array *retval;
        retval = System::Array::CreateInstance(elementType, this->m_Adaptee->get_Count_8f254f3dd8e2403());
        this->m_Adaptee->CopyTo_7065a6e3cf6a140(retval, 0);
        return retval;
    }
    
    System::Object* ArrayListAdapter::get_Item_fd0155f142ae570(int32_t index) {
        return this->m_Adaptee->get_Item_8550d21996ef9dc5(index);
    }
    
    System::Object* ArrayListAdapter::set_Item_9f12782653a34813(int32_t index, System::Object* value) {
        this->m_Adaptee->set_Item_d57705373e0668e7(index, value);
        return get_Item_fd0155f142ae570(index);
    }
    
    int32_t ArrayListAdapter::get_Count_2354963792616712() {
        return this->m_Adaptee->get_Count_8f254f3dd8e2403();
    }
    
    int32_t ArrayListAdapter::get_Capacity_2220db8052d52582() {
        return this->m_Adaptee->get_Count_8f254f3dd8e2403();
    }
    
    int32_t ArrayListAdapter::set_Capacity_8cc9f300b61d27aa(int32_t value) {
        if((value < this->m_Adaptee->get_Count_8f254f3dd8e2403())) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("capacity"));
        }
        return get_Capacity_2220db8052d52582();
    }
    
    bool ArrayListAdapter::get_IsFixedSize_97a42a087785251() {
        return this->m_Adaptee->get_IsFixedSize_4d3eaee3435ee591();
    }
    
    bool ArrayListAdapter::get_IsReadOnly_671df7b1908db8ee() {
        return this->m_Adaptee->get_IsReadOnly_53b6e02d46187790();
    }
    
    System::Object* ArrayListAdapter::get_SyncRoot_edb1ba826807b569() {
        return this->m_Adaptee->get_SyncRoot_257108f45cc89e19();
    }
    
    bool ArrayListAdapter::get_IsSynchronized_ffa26be0a148c3c0() {
        return this->m_Adaptee->get_IsSynchronized_20926e7dabc53dbf();
    }
    
}}
namespace System { namespace Collections {
    
    
    void ArrayListWrapper::constructor(ArrayList* innerArrayList) {
        this->m_InnerArrayList = innerArrayList;
    }
    
    int32_t ArrayListWrapper::Add_e6a92085999ce388(System::Object* value) {
        return this->m_InnerArrayList->Add_e6a92085999ce388(value);
    }
    
    void ArrayListWrapper::Clear_cd6654e5a40f5056() {
        this->m_InnerArrayList->Clear_cd6654e5a40f5056();
    }
    
    bool ArrayListWrapper::Contains_f1c198d01147f1ee(System::Object* value) {
        return this->m_InnerArrayList->Contains_f1c198d01147f1ee(value);
    }
    
    int32_t ArrayListWrapper::IndexOf_7e9811d6771f771d(System::Object* value) {
        return this->m_InnerArrayList->IndexOf_7e9811d6771f771d(value);
    }
    
    int32_t ArrayListWrapper::IndexOf_1c0527e45dc3728e(System::Object* value, int32_t startIndex) {
        return this->m_InnerArrayList->IndexOf_1c0527e45dc3728e(value, startIndex);
    }
    
    int32_t ArrayListWrapper::IndexOf_adae3dc40eaa594e(System::Object* value, int32_t startIndex, int32_t count) {
        return this->m_InnerArrayList->IndexOf_adae3dc40eaa594e(value, startIndex, count);
    }
    
    int32_t ArrayListWrapper::LastIndexOf_ecfd0185f74248a7(System::Object* value) {
        return this->m_InnerArrayList->LastIndexOf_ecfd0185f74248a7(value);
    }
    
    int32_t ArrayListWrapper::LastIndexOf_ed2c73a4e33a0826(System::Object* value, int32_t startIndex) {
        return this->m_InnerArrayList->LastIndexOf_ed2c73a4e33a0826(value, startIndex);
    }
    
    int32_t ArrayListWrapper::LastIndexOf_c6f99b5b290904b1(System::Object* value, int32_t startIndex, int32_t count) {
        return this->m_InnerArrayList->LastIndexOf_c6f99b5b290904b1(value, startIndex, count);
    }
    
    void ArrayListWrapper::Insert_59557a2615bf3b8e(int32_t index, System::Object* value) {
        this->m_InnerArrayList->Insert_59557a2615bf3b8e(index, value);
    }
    
    void ArrayListWrapper::InsertRange_2250ae882d749466(int32_t index, ICollection* c) {
        this->m_InnerArrayList->InsertRange_2250ae882d749466(index, c);
    }
    
    void ArrayListWrapper::Remove_2225381aaf812c6d(System::Object* value) {
        this->m_InnerArrayList->Remove_2225381aaf812c6d(value);
    }
    
    void ArrayListWrapper::RemoveAt_2abea768d3273318(int32_t index) {
        this->m_InnerArrayList->RemoveAt_2abea768d3273318(index);
    }
    
    void ArrayListWrapper::RemoveRange_808c38a5e4171a64(int32_t index, int32_t count) {
        this->m_InnerArrayList->RemoveRange_808c38a5e4171a64(index, count);
    }
    
    void ArrayListWrapper::Reverse_e7caef4018f63b41() {
        this->m_InnerArrayList->Reverse_e7caef4018f63b41();
    }
    
    void ArrayListWrapper::Reverse_bb783f185b528565(int32_t index, int32_t count) {
        this->m_InnerArrayList->Reverse_bb783f185b528565(index, count);
    }
    
    void ArrayListWrapper::SetRange_87e491be8261c464(int32_t index, ICollection* c) {
        this->m_InnerArrayList->SetRange_87e491be8261c464(index, c);
    }
    
    void ArrayListWrapper::CopyTo_c634d425a65b1fc3(System::Array* array) {
        this->m_InnerArrayList->CopyTo_c634d425a65b1fc3(array);
    }
    
    void ArrayListWrapper::CopyTo_2bc540dad3c25b9e(System::Array* array, int32_t index) {
        this->m_InnerArrayList->CopyTo_2bc540dad3c25b9e(array, index);
    }
    
    void ArrayListWrapper::CopyTo_4b0d97bda775c102(int32_t index, System::Array* array, int32_t arrayIndex, int32_t count) {
        this->m_InnerArrayList->CopyTo_4b0d97bda775c102(index, array, arrayIndex, count);
    }
    
    IEnumerator* ArrayListWrapper::GetEnumerator_84e3ba8f2fdefd62() {
        return this->m_InnerArrayList->GetEnumerator_84e3ba8f2fdefd62();
    }
    
    IEnumerator* ArrayListWrapper::GetEnumerator_78a3fe75766282cd(int32_t index, int32_t count) {
        return this->m_InnerArrayList->GetEnumerator_78a3fe75766282cd(index, count);
    }
    
    void ArrayListWrapper::AddRange_a8bb4db32a72ffe(ICollection* c) {
        this->m_InnerArrayList->AddRange_a8bb4db32a72ffe(c);
    }
    
    int32_t ArrayListWrapper::BinarySearch_77606568b997fd61(System::Object* value) {
        return this->m_InnerArrayList->BinarySearch_77606568b997fd61(value);
    }
    
    int32_t ArrayListWrapper::BinarySearch_f0deec366fa04a93(System::Object* value, IComparer* comparer) {
        return this->m_InnerArrayList->BinarySearch_f0deec366fa04a93(value, comparer);
    }
    
    int32_t ArrayListWrapper::BinarySearch_5160cee074873e3f(int32_t index, int32_t count, System::Object* value, IComparer* comparer) {
        return this->m_InnerArrayList->BinarySearch_5160cee074873e3f(index, count, value, comparer);
    }
    
    System::Object* ArrayListWrapper::Clone_5d610374e21ea7b0() {
        return this->m_InnerArrayList->Clone_5d610374e21ea7b0();
    }
    
    ArrayList* ArrayListWrapper::GetRange_21d02af9397d43dc(int32_t index, int32_t count) {
        return this->m_InnerArrayList->GetRange_21d02af9397d43dc(index, count);
    }
    
    void ArrayListWrapper::TrimToSize_d8592d0aafda93d() {
        this->m_InnerArrayList->TrimToSize_d8592d0aafda93d();
    }
    
    void ArrayListWrapper::Sort_9fb0fdfea73c2096() {
        this->m_InnerArrayList->Sort_9fb0fdfea73c2096();
    }
    
    void ArrayListWrapper::Sort_bdf7dee226e6219b(IComparer* comparer) {
        this->m_InnerArrayList->Sort_bdf7dee226e6219b(comparer);
    }
    
    void ArrayListWrapper::Sort_e6922b45a581abd6(int32_t index, int32_t count, IComparer* comparer) {
        this->m_InnerArrayList->Sort_e6922b45a581abd6(index, count, comparer);
    }
    
    cli::array<System::Object*>* ArrayListWrapper::ToArray_360bcd462eb48114() {
        return this->m_InnerArrayList->ToArray_360bcd462eb48114();
    }
    
    System::Array* ArrayListWrapper::ToArray_7b80f35a5dbfbc47(System::Type* elementType) {
        return this->m_InnerArrayList->ToArray_7b80f35a5dbfbc47(elementType);
    }
    
    System::Object* ArrayListWrapper::get_Item_fd0155f142ae570(int32_t index) {
        return this->m_InnerArrayList->get_Item_fd0155f142ae570(index);
    }
    
    System::Object* ArrayListWrapper::set_Item_9f12782653a34813(int32_t index, System::Object* value) {
        this->m_InnerArrayList->set_Item_9f12782653a34813(index, value);
        return get_Item_fd0155f142ae570(index);
    }
    
    int32_t ArrayListWrapper::get_Count_2354963792616712() {
        return this->m_InnerArrayList->get_Count_2354963792616712();
    }
    
    int32_t ArrayListWrapper::get_Capacity_2220db8052d52582() {
        return this->m_InnerArrayList->get_Capacity_2220db8052d52582();
    }
    
    int32_t ArrayListWrapper::set_Capacity_8cc9f300b61d27aa(int32_t value) {
        this->m_InnerArrayList->set_Capacity_8cc9f300b61d27aa(value);
        return get_Capacity_2220db8052d52582();
    }
    
    bool ArrayListWrapper::get_IsFixedSize_97a42a087785251() {
        return this->m_InnerArrayList->get_IsFixedSize_97a42a087785251();
    }
    
    bool ArrayListWrapper::get_IsReadOnly_671df7b1908db8ee() {
        return this->m_InnerArrayList->get_IsReadOnly_671df7b1908db8ee();
    }
    
    bool ArrayListWrapper::get_IsSynchronized_ffa26be0a148c3c0() {
        return this->m_InnerArrayList->get_IsSynchronized_ffa26be0a148c3c0();
    }
    
    System::Object* ArrayListWrapper::get_SyncRoot_edb1ba826807b569() {
        return this->m_InnerArrayList->get_SyncRoot_edb1ba826807b569();
    }
    
}}
namespace System { namespace Collections {
    
    
    void SynchronizedArrayListWrapper::constructor(ArrayList* innerArrayList) {
        this->m_SyncRoot = innerArrayList->get_SyncRoot_edb1ba826807b569();
    }
    
    int32_t SynchronizedArrayListWrapper::Add_e6a92085999ce388(System::Object* value) {
        {
            cli::lock_guard{this->m_SyncRoot};
            return this->m_InnerArrayList->Add_e6a92085999ce388(value);
        }
    }
    
    void SynchronizedArrayListWrapper::Clear_cd6654e5a40f5056() {
        {
            cli::lock_guard{this->m_SyncRoot};
            this->m_InnerArrayList->Clear_cd6654e5a40f5056();
        }
    }
    
    bool SynchronizedArrayListWrapper::Contains_f1c198d01147f1ee(System::Object* value) {
        {
            cli::lock_guard{this->m_SyncRoot};
            return this->m_InnerArrayList->Contains_f1c198d01147f1ee(value);
        }
    }
    
    int32_t SynchronizedArrayListWrapper::IndexOf_7e9811d6771f771d(System::Object* value) {
        {
            cli::lock_guard{this->m_SyncRoot};
            return this->m_InnerArrayList->IndexOf_7e9811d6771f771d(value);
        }
    }
    
    int32_t SynchronizedArrayListWrapper::IndexOf_1c0527e45dc3728e(System::Object* value, int32_t startIndex) {
        {
            cli::lock_guard{this->m_SyncRoot};
            return this->m_InnerArrayList->IndexOf_1c0527e45dc3728e(value, startIndex);
        }
    }
    
    int32_t SynchronizedArrayListWrapper::IndexOf_adae3dc40eaa594e(System::Object* value, int32_t startIndex, int32_t count) {
        {
            cli::lock_guard{this->m_SyncRoot};
            return this->m_InnerArrayList->IndexOf_adae3dc40eaa594e(value, startIndex, count);
        }
    }
    
    int32_t SynchronizedArrayListWrapper::LastIndexOf_ecfd0185f74248a7(System::Object* value) {
        {
            cli::lock_guard{this->m_SyncRoot};
            return this->m_InnerArrayList->LastIndexOf_ecfd0185f74248a7(value);
        }
    }
    
    int32_t SynchronizedArrayListWrapper::LastIndexOf_ed2c73a4e33a0826(System::Object* value, int32_t startIndex) {
        {
            cli::lock_guard{this->m_SyncRoot};
            return this->m_InnerArrayList->LastIndexOf_ed2c73a4e33a0826(value, startIndex);
        }
    }
    
    int32_t SynchronizedArrayListWrapper::LastIndexOf_c6f99b5b290904b1(System::Object* value, int32_t startIndex, int32_t count) {
        {
            cli::lock_guard{this->m_SyncRoot};
            return this->m_InnerArrayList->LastIndexOf_c6f99b5b290904b1(value, startIndex, count);
        }
    }
    
    void SynchronizedArrayListWrapper::Insert_59557a2615bf3b8e(int32_t index, System::Object* value) {
        {
            cli::lock_guard{this->m_SyncRoot};
            this->m_InnerArrayList->Insert_59557a2615bf3b8e(index, value);
        }
    }
    
    void SynchronizedArrayListWrapper::InsertRange_2250ae882d749466(int32_t index, ICollection* c) {
        {
            cli::lock_guard{this->m_SyncRoot};
            this->m_InnerArrayList->InsertRange_2250ae882d749466(index, c);
        }
    }
    
    void SynchronizedArrayListWrapper::Remove_2225381aaf812c6d(System::Object* value) {
        {
            cli::lock_guard{this->m_SyncRoot};
            this->m_InnerArrayList->Remove_2225381aaf812c6d(value);
        }
    }
    
    void SynchronizedArrayListWrapper::RemoveAt_2abea768d3273318(int32_t index) {
        {
            cli::lock_guard{this->m_SyncRoot};
            this->m_InnerArrayList->RemoveAt_2abea768d3273318(index);
        }
    }
    
    void SynchronizedArrayListWrapper::RemoveRange_808c38a5e4171a64(int32_t index, int32_t count) {
        {
            cli::lock_guard{this->m_SyncRoot};
            this->m_InnerArrayList->RemoveRange_808c38a5e4171a64(index, count);
        }
    }
    
    void SynchronizedArrayListWrapper::Reverse_e7caef4018f63b41() {
        {
            cli::lock_guard{this->m_SyncRoot};
            this->m_InnerArrayList->Reverse_e7caef4018f63b41();
        }
    }
    
    void SynchronizedArrayListWrapper::Reverse_bb783f185b528565(int32_t index, int32_t count) {
        {
            cli::lock_guard{this->m_SyncRoot};
            this->m_InnerArrayList->Reverse_bb783f185b528565(index, count);
        }
    }
    
    void SynchronizedArrayListWrapper::CopyTo_c634d425a65b1fc3(System::Array* array) {
        {
            cli::lock_guard{this->m_SyncRoot};
            this->m_InnerArrayList->CopyTo_c634d425a65b1fc3(array);
        }
    }
    
    void SynchronizedArrayListWrapper::CopyTo_2bc540dad3c25b9e(System::Array* array, int32_t index) {
        {
            cli::lock_guard{this->m_SyncRoot};
            this->m_InnerArrayList->CopyTo_2bc540dad3c25b9e(array, index);
        }
    }
    
    void SynchronizedArrayListWrapper::CopyTo_4b0d97bda775c102(int32_t index, System::Array* array, int32_t arrayIndex, int32_t count) {
        {
            cli::lock_guard{this->m_SyncRoot};
            this->m_InnerArrayList->CopyTo_4b0d97bda775c102(index, array, arrayIndex, count);
        }
    }
    
    IEnumerator* SynchronizedArrayListWrapper::GetEnumerator_84e3ba8f2fdefd62() {
        {
            cli::lock_guard{this->m_SyncRoot};
            return this->m_InnerArrayList->GetEnumerator_84e3ba8f2fdefd62();
        }
    }
    
    IEnumerator* SynchronizedArrayListWrapper::GetEnumerator_78a3fe75766282cd(int32_t index, int32_t count) {
        {
            cli::lock_guard{this->m_SyncRoot};
            return this->m_InnerArrayList->GetEnumerator_78a3fe75766282cd(index, count);
        }
    }
    
    void SynchronizedArrayListWrapper::AddRange_a8bb4db32a72ffe(ICollection* c) {
        {
            cli::lock_guard{this->m_SyncRoot};
            this->m_InnerArrayList->AddRange_a8bb4db32a72ffe(c);
        }
    }
    
    int32_t SynchronizedArrayListWrapper::BinarySearch_77606568b997fd61(System::Object* value) {
        {
            cli::lock_guard{this->m_SyncRoot};
            return this->m_InnerArrayList->BinarySearch_77606568b997fd61(value);
        }
    }
    
    int32_t SynchronizedArrayListWrapper::BinarySearch_f0deec366fa04a93(System::Object* value, IComparer* comparer) {
        {
            cli::lock_guard{this->m_SyncRoot};
            return this->m_InnerArrayList->BinarySearch_f0deec366fa04a93(value, comparer);
        }
    }
    
    int32_t SynchronizedArrayListWrapper::BinarySearch_5160cee074873e3f(int32_t index, int32_t count, System::Object* value, IComparer* comparer) {
        {
            cli::lock_guard{this->m_SyncRoot};
            return this->m_InnerArrayList->BinarySearch_5160cee074873e3f(index, count, value, comparer);
        }
    }
    
    System::Object* SynchronizedArrayListWrapper::Clone_5d610374e21ea7b0() {
        {
            cli::lock_guard{this->m_SyncRoot};
            return this->m_InnerArrayList->Clone_5d610374e21ea7b0();
        }
    }
    
    ArrayList* SynchronizedArrayListWrapper::GetRange_21d02af9397d43dc(int32_t index, int32_t count) {
        {
            cli::lock_guard{this->m_SyncRoot};
            return this->m_InnerArrayList->GetRange_21d02af9397d43dc(index, count);
        }
    }
    
    void SynchronizedArrayListWrapper::TrimToSize_d8592d0aafda93d() {
        {
            cli::lock_guard{this->m_SyncRoot};
            this->m_InnerArrayList->TrimToSize_d8592d0aafda93d();
        }
    }
    
    void SynchronizedArrayListWrapper::Sort_9fb0fdfea73c2096() {
        {
            cli::lock_guard{this->m_SyncRoot};
            this->m_InnerArrayList->Sort_9fb0fdfea73c2096();
        }
    }
    
    void SynchronizedArrayListWrapper::Sort_bdf7dee226e6219b(IComparer* comparer) {
        {
            cli::lock_guard{this->m_SyncRoot};
            this->m_InnerArrayList->Sort_bdf7dee226e6219b(comparer);
        }
    }
    
    void SynchronizedArrayListWrapper::Sort_e6922b45a581abd6(int32_t index, int32_t count, IComparer* comparer) {
        {
            cli::lock_guard{this->m_SyncRoot};
            this->m_InnerArrayList->Sort_e6922b45a581abd6(index, count, comparer);
        }
    }
    
    cli::array<System::Object*>* SynchronizedArrayListWrapper::ToArray_360bcd462eb48114() {
        {
            cli::lock_guard{this->m_SyncRoot};
            return this->m_InnerArrayList->ToArray_360bcd462eb48114();
        }
    }
    
    System::Array* SynchronizedArrayListWrapper::ToArray_7b80f35a5dbfbc47(System::Type* elementType) {
        {
            cli::lock_guard{this->m_SyncRoot};
            return this->m_InnerArrayList->ToArray_7b80f35a5dbfbc47(elementType);
        }
    }
    
    System::Object* SynchronizedArrayListWrapper::get_Item_fd0155f142ae570(int32_t index) {
        {
            cli::lock_guard{this->m_SyncRoot};
            return this->m_InnerArrayList->get_Item_fd0155f142ae570(index);
        }
    }
    
    System::Object* SynchronizedArrayListWrapper::set_Item_9f12782653a34813(int32_t index, System::Object* value) {
        {
            cli::lock_guard{this->m_SyncRoot};
            this->m_InnerArrayList->set_Item_9f12782653a34813(index, value);
        }
        return get_Item_fd0155f142ae570(index);
    }
    
    int32_t SynchronizedArrayListWrapper::get_Count_2354963792616712() {
        {
            cli::lock_guard{this->m_SyncRoot};
            return this->m_InnerArrayList->get_Count_2354963792616712();
        }
    }
    
    int32_t SynchronizedArrayListWrapper::get_Capacity_2220db8052d52582() {
        {
            cli::lock_guard{this->m_SyncRoot};
            return this->m_InnerArrayList->get_Capacity_2220db8052d52582();
        }
    }
    
    int32_t SynchronizedArrayListWrapper::set_Capacity_8cc9f300b61d27aa(int32_t value) {
        {
            cli::lock_guard{this->m_SyncRoot};
            this->m_InnerArrayList->set_Capacity_8cc9f300b61d27aa(value);
        }
        return get_Capacity_2220db8052d52582();
    }
    
    bool SynchronizedArrayListWrapper::get_IsFixedSize_97a42a087785251() {
        {
            cli::lock_guard{this->m_SyncRoot};
            return this->m_InnerArrayList->get_IsFixedSize_97a42a087785251();
        }
    }
    
    bool SynchronizedArrayListWrapper::get_IsReadOnly_671df7b1908db8ee() {
        {
            cli::lock_guard{this->m_SyncRoot};
            return this->m_InnerArrayList->get_IsReadOnly_671df7b1908db8ee();
        }
    }
    
    bool SynchronizedArrayListWrapper::get_IsSynchronized_ffa26be0a148c3c0() {
        return true;
    }
    
    System::Object* SynchronizedArrayListWrapper::get_SyncRoot_edb1ba826807b569() {
        return this->m_SyncRoot;
    }
    
}}
namespace System { namespace Collections {
    
    
    void FixedSizeArrayListWrapper::constructor(ArrayList* innerList) {
    }
    
    int32_t FixedSizeArrayListWrapper::Add_e6a92085999ce388(System::Object* value) {
        throw cli::gcnew<System::NotSupportedException>(this->get_ErrorMessage_d1b0b946fa8d50da());
    }
    
    void FixedSizeArrayListWrapper::AddRange_a8bb4db32a72ffe(ICollection* c) {
        throw cli::gcnew<System::NotSupportedException>(this->get_ErrorMessage_d1b0b946fa8d50da());
    }
    
    void FixedSizeArrayListWrapper::Clear_cd6654e5a40f5056() {
        throw cli::gcnew<System::NotSupportedException>(this->get_ErrorMessage_d1b0b946fa8d50da());
    }
    
    void FixedSizeArrayListWrapper::Insert_59557a2615bf3b8e(int32_t index, System::Object* value) {
        throw cli::gcnew<System::NotSupportedException>(this->get_ErrorMessage_d1b0b946fa8d50da());
    }
    
    void FixedSizeArrayListWrapper::InsertRange_2250ae882d749466(int32_t index, ICollection* c) {
        throw cli::gcnew<System::NotSupportedException>(this->get_ErrorMessage_d1b0b946fa8d50da());
    }
    
    void FixedSizeArrayListWrapper::Remove_2225381aaf812c6d(System::Object* value) {
        throw cli::gcnew<System::NotSupportedException>(this->get_ErrorMessage_d1b0b946fa8d50da());
    }
    
    void FixedSizeArrayListWrapper::RemoveAt_2abea768d3273318(int32_t index) {
        throw cli::gcnew<System::NotSupportedException>(this->get_ErrorMessage_d1b0b946fa8d50da());
    }
    
    void FixedSizeArrayListWrapper::RemoveRange_808c38a5e4171a64(int32_t index, int32_t count) {
        throw cli::gcnew<System::NotSupportedException>(this->get_ErrorMessage_d1b0b946fa8d50da());
    }
    
    void FixedSizeArrayListWrapper::TrimToSize_d8592d0aafda93d() {
        throw cli::gcnew<System::NotSupportedException>(this->get_ErrorMessage_d1b0b946fa8d50da());
    }
    
    System::String* FixedSizeArrayListWrapper::get_ErrorMessage_d1b0b946fa8d50da() {
        return _T("Can\'t add or remove from a fixed-size list.");
    }
    
    int32_t FixedSizeArrayListWrapper::get_Capacity_2220db8052d52582() {
        return ArrayListWrapper::get_Capacity_2220db8052d52582();
    }
    
    int32_t FixedSizeArrayListWrapper::set_Capacity_8cc9f300b61d27aa(int32_t value) {
        throw cli::gcnew<System::NotSupportedException>(this->get_ErrorMessage_d1b0b946fa8d50da());
        return get_Capacity_2220db8052d52582();
    }
    
    bool FixedSizeArrayListWrapper::get_IsFixedSize_97a42a087785251() {
        return true;
    }
    
}}
namespace System { namespace Collections {
    
    
    void ReadOnlyArrayListWrapper::constructor(ArrayList* innerArrayList) {
    }
    
    void ReadOnlyArrayListWrapper::Reverse_e7caef4018f63b41() {
        throw cli::gcnew<System::NotSupportedException>(this->get_ErrorMessage_d1b0b946fa8d50da());
    }
    
    void ReadOnlyArrayListWrapper::Reverse_bb783f185b528565(int32_t index, int32_t count) {
        throw cli::gcnew<System::NotSupportedException>(this->get_ErrorMessage_d1b0b946fa8d50da());
    }
    
    void ReadOnlyArrayListWrapper::SetRange_87e491be8261c464(int32_t index, ICollection* c) {
        throw cli::gcnew<System::NotSupportedException>(this->get_ErrorMessage_d1b0b946fa8d50da());
    }
    
    void ReadOnlyArrayListWrapper::Sort_9fb0fdfea73c2096() {
        throw cli::gcnew<System::NotSupportedException>(this->get_ErrorMessage_d1b0b946fa8d50da());
    }
    
    void ReadOnlyArrayListWrapper::Sort_bdf7dee226e6219b(IComparer* comparer) {
        throw cli::gcnew<System::NotSupportedException>(this->get_ErrorMessage_d1b0b946fa8d50da());
    }
    
    void ReadOnlyArrayListWrapper::Sort_e6922b45a581abd6(int32_t index, int32_t count, IComparer* comparer) {
        throw cli::gcnew<System::NotSupportedException>(this->get_ErrorMessage_d1b0b946fa8d50da());
    }
    
    System::String* ReadOnlyArrayListWrapper::get_ErrorMessage_d1b0b946fa8d50da() {
        return _T("Can\'t modify a readonly list.");
    }
    
    bool ReadOnlyArrayListWrapper::get_IsReadOnly_671df7b1908db8ee() {
        return true;
    }
    
    System::Object* ReadOnlyArrayListWrapper::get_Item_fd0155f142ae570(int32_t index) {
        return this->m_InnerArrayList->get_Item_fd0155f142ae570(index);
    }
    
    System::Object* ReadOnlyArrayListWrapper::set_Item_9f12782653a34813(int32_t index, System::Object* value) {
        throw cli::gcnew<System::NotSupportedException>(this->get_ErrorMessage_d1b0b946fa8d50da());
        return get_Item_fd0155f142ae570(index);
    }
    
}}
namespace System { namespace Collections {
    
    
    void RangedArrayList::constructor(ArrayList* innerList, int32_t index, int32_t count) {
        this->m_InnerIndex = index;
        this->m_InnerCount = count;
        this->m_InnerStateChanges = innerList->_version;
    }
    
    void RangedArrayList::VerifyStateChanges() {
        if((this->m_InnerStateChanges != this->m_InnerArrayList->_version)) 
        {
            throw cli::gcnew<System::InvalidOperationException>(_T("ArrayList view is invalid because the underlying ArrayList was modified."));
        }
    }
    
    int32_t RangedArrayList::Add_e6a92085999ce388(System::Object* value) {
        VerifyStateChanges();
        this->m_InnerArrayList->Insert_59557a2615bf3b8e((this->m_InnerIndex + this->m_InnerCount), value);
        this->m_InnerStateChanges = this->m_InnerArrayList->_version;
        return ++this->m_InnerCount;
    }
    
    void RangedArrayList::Clear_cd6654e5a40f5056() {
        VerifyStateChanges();
        this->m_InnerArrayList->RemoveRange_808c38a5e4171a64(this->m_InnerIndex, this->m_InnerCount);
        this->m_InnerCount = 0;
        this->m_InnerStateChanges = this->m_InnerArrayList->_version;
    }
    
    bool RangedArrayList::Contains_f1c198d01147f1ee(System::Object* value) {
        return this->m_InnerArrayList->Contains_381049624765eb70(value, this->m_InnerIndex, this->m_InnerCount);
    }
    
    int32_t RangedArrayList::IndexOf_7e9811d6771f771d(System::Object* value) {
        return ArrayList::IndexOf_1c0527e45dc3728e(value, 0);
    }
    
    int32_t RangedArrayList::IndexOf_1c0527e45dc3728e(System::Object* value, int32_t startIndex) {
        return ArrayList::IndexOf_adae3dc40eaa594e(value, startIndex, (this->m_InnerCount - startIndex));
    }
    
    int32_t RangedArrayList::IndexOf_adae3dc40eaa594e(System::Object* value, int32_t startIndex, int32_t count) {
        if(((startIndex < 0) || (startIndex > this->m_InnerCount))) 
        {
            ArrayList::ThrowNewArgumentOutOfRangeException(_T("startIndex"), cli::box(startIndex), _T("Does not specify valid index."));
        }
        if((count < 0)) 
        {
            ArrayList::ThrowNewArgumentOutOfRangeException(_T("count"), cli::box(count), _T("Can\'t be less than 0."));
        }
        if((startIndex > (this->m_InnerCount - count))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("count"), _T("Start index and count do not specify a valid range."));
        }
        int32_t retval = this->m_InnerArrayList->IndexOf_adae3dc40eaa594e(value, (this->m_InnerIndex + startIndex), count);
        if((retval ==  -1)) 
        {
            return -1;
        }
         else 
        {
            return (retval - this->m_InnerIndex);
        }
    }
    
    int32_t RangedArrayList::LastIndexOf_ecfd0185f74248a7(System::Object* value) {
        return ArrayList::LastIndexOf_ed2c73a4e33a0826(value, (this->m_InnerCount - 1));
    }
    
    int32_t RangedArrayList::LastIndexOf_ed2c73a4e33a0826(System::Object* value, int32_t startIndex) {
        return ArrayList::LastIndexOf_c6f99b5b290904b1(value, startIndex, (startIndex + 1));
    }
    
    int32_t RangedArrayList::LastIndexOf_c6f99b5b290904b1(System::Object* value, int32_t startIndex, int32_t count) {
        if((startIndex < 0)) 
        {
            ArrayList::ThrowNewArgumentOutOfRangeException(_T("startIndex"), cli::box(startIndex), _T("< 0"));
        }
        if((count < 0)) 
        {
            ArrayList::ThrowNewArgumentOutOfRangeException(_T("count"), cli::box(count), _T("count is negative."));
        }
        int32_t retval = this->m_InnerArrayList->LastIndexOf_c6f99b5b290904b1(value, (this->m_InnerIndex + startIndex), count);
        if((retval ==  -1)) 
        {
            return -1;
        }
         else 
        {
            return (retval - this->m_InnerIndex);
        }
    }
    
    void RangedArrayList::Insert_59557a2615bf3b8e(int32_t index, System::Object* value) {
        VerifyStateChanges();
        if(((index < 0) || (index > this->m_InnerCount))) 
        {
            ArrayList::ThrowNewArgumentOutOfRangeException(_T("index"), cli::box(index), _T("Index must be >= 0 and <= Count."));
        }
        this->m_InnerArrayList->Insert_59557a2615bf3b8e((this->m_InnerIndex + index), value);
        this->m_InnerCount++;
        this->m_InnerStateChanges = this->m_InnerArrayList->_version;
    }
    
    void RangedArrayList::InsertRange_2250ae882d749466(int32_t index, ICollection* c) {
        VerifyStateChanges();
        if(((index < 0) || (index > this->m_InnerCount))) 
        {
            ArrayList::ThrowNewArgumentOutOfRangeException(_T("index"), cli::box(index), _T("Index must be >= 0 and <= Count."));
        }
        this->m_InnerArrayList->InsertRange_2250ae882d749466((this->m_InnerIndex + index), c);
        (this->m_InnerCount = this->m_InnerCount + c->get_Count_8f254f3dd8e2403());
        this->m_InnerStateChanges = this->m_InnerArrayList->_version;
    }
    
    void RangedArrayList::Remove_2225381aaf812c6d(System::Object* value) {
        VerifyStateChanges();
        int32_t x = ArrayList::IndexOf_7e9811d6771f771d(value);
        if((x > -1)) 
        {
            ArrayList::RemoveAt_2abea768d3273318(x);
        }
        this->m_InnerStateChanges = this->m_InnerArrayList->_version;
    }
    
    void RangedArrayList::RemoveAt_2abea768d3273318(int32_t index) {
        VerifyStateChanges();
        if(((index < 0) || (index > this->m_InnerCount))) 
        {
            ArrayList::ThrowNewArgumentOutOfRangeException(_T("index"), cli::box(index), _T("Index must be >= 0 and <= Count."));
        }
        this->m_InnerArrayList->RemoveAt_2abea768d3273318((this->m_InnerIndex + index));
        this->m_InnerCount--;
        this->m_InnerStateChanges = this->m_InnerArrayList->_version;
    }
    
    void RangedArrayList::RemoveRange_808c38a5e4171a64(int32_t index, int32_t count) {
        VerifyStateChanges();
        ArrayList::CheckRange(index, count, this->m_InnerCount);
        this->m_InnerArrayList->RemoveRange_808c38a5e4171a64((this->m_InnerIndex + index), count);
        (this->m_InnerCount = this->m_InnerCount - count);
        this->m_InnerStateChanges = this->m_InnerArrayList->_version;
    }
    
    void RangedArrayList::Reverse_e7caef4018f63b41() {
        ArrayList::Reverse_bb783f185b528565(0, this->m_InnerCount);
    }
    
    void RangedArrayList::Reverse_bb783f185b528565(int32_t index, int32_t count) {
        VerifyStateChanges();
        ArrayList::CheckRange(index, count, this->m_InnerCount);
        this->m_InnerArrayList->Reverse_bb783f185b528565((this->m_InnerIndex + index), count);
        this->m_InnerStateChanges = this->m_InnerArrayList->_version;
    }
    
    void RangedArrayList::SetRange_87e491be8261c464(int32_t index, ICollection* c) {
        VerifyStateChanges();
        if(((index < 0) || (index > this->m_InnerCount))) 
        {
            ArrayList::ThrowNewArgumentOutOfRangeException(_T("index"), cli::box(index), _T("Index must be >= 0 and <= Count."));
        }
        this->m_InnerArrayList->SetRange_87e491be8261c464((this->m_InnerIndex + index), c);
        this->m_InnerStateChanges = this->m_InnerArrayList->_version;
    }
    
    void RangedArrayList::CopyTo_c634d425a65b1fc3(System::Array* array) {
        ArrayList::CopyTo_2bc540dad3c25b9e(array, 0);
    }
    
    void RangedArrayList::CopyTo_2bc540dad3c25b9e(System::Array* array, int32_t index) {
        ArrayList::CopyTo_4b0d97bda775c102(0, array, index, this->m_InnerCount);
    }
    
    void RangedArrayList::CopyTo_4b0d97bda775c102(int32_t index, System::Array* array, int32_t arrayIndex, int32_t count) {
        ArrayList::CheckRange(index, count, this->m_InnerCount);
        this->m_InnerArrayList->CopyTo_4b0d97bda775c102((this->m_InnerIndex + index), array, arrayIndex, count);
    }
    
    IEnumerator* RangedArrayList::GetEnumerator_84e3ba8f2fdefd62() {
        return ArrayList::GetEnumerator_78a3fe75766282cd(0, this->m_InnerCount);
    }
    
    IEnumerator* RangedArrayList::GetEnumerator_78a3fe75766282cd(int32_t index, int32_t count) {
        ArrayList::CheckRange(index, count, this->m_InnerCount);
        return this->m_InnerArrayList->GetEnumerator_78a3fe75766282cd((this->m_InnerIndex + index), count);
    }
    
    void RangedArrayList::AddRange_a8bb4db32a72ffe(ICollection* c) {
        VerifyStateChanges();
        this->m_InnerArrayList->InsertRange_2250ae882d749466(this->m_InnerCount, c);
        (this->m_InnerCount = this->m_InnerCount + c->get_Count_8f254f3dd8e2403());
        this->m_InnerStateChanges = this->m_InnerArrayList->_version;
    }
    
    int32_t RangedArrayList::BinarySearch_77606568b997fd61(System::Object* value) {
        return ArrayList::BinarySearch_5160cee074873e3f(0, this->m_InnerCount, value, Comparer::Default2);
    }
    
    int32_t RangedArrayList::BinarySearch_f0deec366fa04a93(System::Object* value, IComparer* comparer) {
        return ArrayList::BinarySearch_5160cee074873e3f(0, this->m_InnerCount, value, comparer);
    }
    
    int32_t RangedArrayList::BinarySearch_5160cee074873e3f(int32_t index, int32_t count, System::Object* value, IComparer* comparer) {
        ArrayList::CheckRange(index, count, this->m_InnerCount);
        return this->m_InnerArrayList->BinarySearch_5160cee074873e3f((this->m_InnerIndex + index), count, value, comparer);
    }
    
    System::Object* RangedArrayList::Clone_5d610374e21ea7b0() {
        return cli::gcnew<RangedArrayList>(cli::cast<ArrayList*>(this->m_InnerArrayList->Clone_5d610374e21ea7b0()), this->m_InnerIndex, this->m_InnerCount);
    }
    
    ArrayList* RangedArrayList::GetRange_21d02af9397d43dc(int32_t index, int32_t count) {
        ArrayList::CheckRange(index, count, this->m_InnerCount);
        return cli::gcnew<RangedArrayList>(this, index, count);
    }
    
    void RangedArrayList::TrimToSize_d8592d0aafda93d() {
        throw cli::gcnew<System::NotSupportedException>();
    }
    
    void RangedArrayList::Sort_9fb0fdfea73c2096() {
        ArrayList::Sort_bdf7dee226e6219b(Comparer::Default2);
    }
    
    void RangedArrayList::Sort_bdf7dee226e6219b(IComparer* comparer) {
        ArrayList::Sort_e6922b45a581abd6(0, this->m_InnerCount, comparer);
    }
    
    void RangedArrayList::Sort_e6922b45a581abd6(int32_t index, int32_t count, IComparer* comparer) {
        VerifyStateChanges();
        ArrayList::CheckRange(index, count, this->m_InnerCount);
        this->m_InnerArrayList->Sort_e6922b45a581abd6((this->m_InnerIndex + index), count, comparer);
        this->m_InnerStateChanges = this->m_InnerArrayList->_version;
    }
    
    cli::array<System::Object*>* RangedArrayList::ToArray_360bcd462eb48114() {
        cli::array<System::Object*> *array;
        array = (new cli::array<System::Object*>(this->m_InnerCount));
        this->m_InnerArrayList->CopyTo_4b0d97bda775c102(this->m_InnerIndex, array, 0, this->m_InnerCount);
        return array;
    }
    
    System::Array* RangedArrayList::ToArray_7b80f35a5dbfbc47(System::Type* elementType) {
        System::Array *array;
        array = System::Array::CreateInstance(elementType, this->m_InnerCount);
        this->m_InnerArrayList->CopyTo_4b0d97bda775c102(this->m_InnerIndex, array, 0, this->m_InnerCount);
        return array;
    }
    
    bool RangedArrayList::get_IsSynchronized_ffa26be0a148c3c0() {
        return false;
    }
    
    System::Object* RangedArrayList::get_Item_fd0155f142ae570(int32_t index) {
        if(((index < 0) || (index > this->m_InnerCount))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("index"));
        }
        return this->m_InnerArrayList->get_Item_fd0155f142ae570((this->m_InnerIndex + index));
    }
    
    System::Object* RangedArrayList::set_Item_9f12782653a34813(int32_t index, System::Object* value) {
        if(((index < 0) || (index > this->m_InnerCount))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("index"));
        }
        this->m_InnerArrayList->set_Item_9f12782653a34813((this->m_InnerIndex + index), value);
        return get_Item_fd0155f142ae570(index);
    }
    
    int32_t RangedArrayList::get_Count_2354963792616712() {
        VerifyStateChanges();
        return this->m_InnerCount;
    }
    
    int32_t RangedArrayList::get_Capacity_2220db8052d52582() {
        return this->m_InnerArrayList->get_Capacity_2220db8052d52582();
    }
    
    int32_t RangedArrayList::set_Capacity_8cc9f300b61d27aa(int32_t value) {
        if((value < this->m_InnerCount)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>();
        }
        return get_Capacity_2220db8052d52582();
    }
    
}}
namespace System { namespace Collections {
    
    
    void SynchronizedListWrapper::constructor(IList* innerList) {
        this->m_SyncRoot = innerList->get_SyncRoot_257108f45cc89e19();
    }
    
    int32_t SynchronizedListWrapper::Add_bcf09ba25e62648f(System::Object* value) {
        {
            cli::lock_guard{this->m_SyncRoot};
            return this->m_InnerList->Add_985508e3bf9b7a73(value);
        }
    }
    
    void SynchronizedListWrapper::Clear_77f454011f626479() {
        {
            cli::lock_guard{this->m_SyncRoot};
            this->m_InnerList->Clear_e0ee496065507a2f();
        }
    }
    
    bool SynchronizedListWrapper::Contains_f9107b57b0828239(System::Object* value) {
        {
            cli::lock_guard{this->m_SyncRoot};
            return this->m_InnerList->Contains_2a2192a595869f4e(value);
        }
    }
    
    int32_t SynchronizedListWrapper::IndexOf_e6724c0395a3dad0(System::Object* value) {
        {
            cli::lock_guard{this->m_SyncRoot};
            return this->m_InnerList->IndexOf_7f6d78d7aa6d53e5(value);
        }
    }
    
    void SynchronizedListWrapper::Insert_290942a010dce429(int32_t index, System::Object* value) {
        {
            cli::lock_guard{this->m_SyncRoot};
            this->m_InnerList->Insert_16e8bd69dfc603f4(index, value);
        }
    }
    
    void SynchronizedListWrapper::Remove_f0670db65479e773(System::Object* value) {
        {
            cli::lock_guard{this->m_SyncRoot};
            this->m_InnerList->Remove_69f1b1e57bb34112(value);
        }
    }
    
    void SynchronizedListWrapper::RemoveAt_a5bebe22efe6f1a7(int32_t index) {
        {
            cli::lock_guard{this->m_SyncRoot};
            this->m_InnerList->RemoveAt_dce190584913328b(index);
        }
    }
    
    void SynchronizedListWrapper::CopyTo_91752f56f47af7f3(System::Array* array, int32_t index) {
        {
            cli::lock_guard{this->m_SyncRoot};
            this->m_InnerList->CopyTo_7065a6e3cf6a140(array, index);
        }
    }
    
    IEnumerator* SynchronizedListWrapper::GetEnumerator_6e025ed1cc117836() {
        {
            cli::lock_guard{this->m_SyncRoot};
            return this->m_InnerList->GetEnumerator_674ad93a972a4d67();
        }
    }
    
    int32_t SynchronizedListWrapper::get_Count_614a2abb891f748b() {
        {
            cli::lock_guard{this->m_SyncRoot};
            return this->m_InnerList->get_Count_8f254f3dd8e2403();
        }
    }
    
    bool SynchronizedListWrapper::get_IsSynchronized_23e3b7993e71d737() {
        return true;
    }
    
    System::Object* SynchronizedListWrapper::get_SyncRoot_a3def0e51eeaf8d9() {
        {
            cli::lock_guard{this->m_SyncRoot};
            return this->m_InnerList->get_SyncRoot_257108f45cc89e19();
        }
    }
    
    bool SynchronizedListWrapper::get_IsFixedSize_3444cf8f8ef3efa4() {
        {
            cli::lock_guard{this->m_SyncRoot};
            return this->m_InnerList->get_IsFixedSize_4d3eaee3435ee591();
        }
    }
    
    bool SynchronizedListWrapper::get_IsReadOnly_fe00057b4a1798ff() {
        {
            cli::lock_guard{this->m_SyncRoot};
            return this->m_InnerList->get_IsReadOnly_53b6e02d46187790();
        }
    }
    
    System::Object* SynchronizedListWrapper::get_Item_896a441a7363c710(int32_t index) {
        {
            cli::lock_guard{this->m_SyncRoot};
            return this->m_InnerList->get_Item_8550d21996ef9dc5(index);
        }
    }
    
    System::Object* SynchronizedListWrapper::set_Item_a9ec2ce7dfe8dea5(int32_t index, System::Object* value) {
        {
            cli::lock_guard{this->m_SyncRoot};
            this->m_InnerList->set_Item_d57705373e0668e7(index, value);
        }
        return get_Item_896a441a7363c710(index);
    }
    
}}
namespace System { namespace Collections {
    
    
    void FixedSizeListWrapper::constructor(IList* innerList) {
    }
    
    int32_t FixedSizeListWrapper::Add_bcf09ba25e62648f(System::Object* value) {
        throw cli::gcnew<System::NotSupportedException>(this->get_ErrorMessage_461bc84fd2dc69d6());
    }
    
    void FixedSizeListWrapper::Clear_77f454011f626479() {
        throw cli::gcnew<System::NotSupportedException>(this->get_ErrorMessage_461bc84fd2dc69d6());
    }
    
    void FixedSizeListWrapper::Insert_290942a010dce429(int32_t index, System::Object* value) {
        throw cli::gcnew<System::NotSupportedException>(this->get_ErrorMessage_461bc84fd2dc69d6());
    }
    
    void FixedSizeListWrapper::Remove_f0670db65479e773(System::Object* value) {
        throw cli::gcnew<System::NotSupportedException>(this->get_ErrorMessage_461bc84fd2dc69d6());
    }
    
    void FixedSizeListWrapper::RemoveAt_a5bebe22efe6f1a7(int32_t index) {
        throw cli::gcnew<System::NotSupportedException>(this->get_ErrorMessage_461bc84fd2dc69d6());
    }
    
    System::String* FixedSizeListWrapper::get_ErrorMessage_461bc84fd2dc69d6() {
        return _T("List is fixed-size.");
    }
    
    bool FixedSizeListWrapper::get_IsFixedSize_3444cf8f8ef3efa4() {
        return true;
    }
    
}}
namespace System { namespace Collections {
    
    
    void ReadOnlyListWrapper::constructor(IList* innerList) {
    }
    
    System::String* ReadOnlyListWrapper::get_ErrorMessage_461bc84fd2dc69d6() {
        return _T("List is read-only.");
    }
    
    bool ReadOnlyListWrapper::get_IsReadOnly_fe00057b4a1798ff() {
        return true;
    }
    
    System::Object* ReadOnlyListWrapper::get_Item_896a441a7363c710(int32_t index) {
        return this->m_InnerList->get_Item_8550d21996ef9dc5(index);
    }
    
    System::Object* ReadOnlyListWrapper::set_Item_a9ec2ce7dfe8dea5(int32_t index, System::Object* value) {
        throw cli::gcnew<System::NotSupportedException>(this->get_ErrorMessage_461bc84fd2dc69d6());
        return get_Item_896a441a7363c710(index);
    }
    
}}
namespace System { namespace Collections {
    
    
    void ListWrapper::constructor(IList* innerList) {
        this->m_InnerList = innerList;
    }
    
    int32_t ListWrapper::Add_bcf09ba25e62648f(System::Object* value) {
        return this->m_InnerList->Add_985508e3bf9b7a73(value);
    }
    
    void ListWrapper::Clear_77f454011f626479() {
        this->m_InnerList->Clear_e0ee496065507a2f();
    }
    
    bool ListWrapper::Contains_f9107b57b0828239(System::Object* value) {
        return this->m_InnerList->Contains_2a2192a595869f4e(value);
    }
    
    int32_t ListWrapper::IndexOf_e6724c0395a3dad0(System::Object* value) {
        return this->m_InnerList->IndexOf_7f6d78d7aa6d53e5(value);
    }
    
    void ListWrapper::Insert_290942a010dce429(int32_t index, System::Object* value) {
        this->m_InnerList->Insert_16e8bd69dfc603f4(index, value);
    }
    
    void ListWrapper::Remove_f0670db65479e773(System::Object* value) {
        this->m_InnerList->Remove_69f1b1e57bb34112(value);
    }
    
    void ListWrapper::RemoveAt_a5bebe22efe6f1a7(int32_t index) {
        this->m_InnerList->RemoveAt_dce190584913328b(index);
    }
    
    void ListWrapper::CopyTo_91752f56f47af7f3(System::Array* array, int32_t index) {
        this->m_InnerList->CopyTo_7065a6e3cf6a140(array, index);
    }
    
    IEnumerator* ListWrapper::GetEnumerator_6e025ed1cc117836() {
        return this->m_InnerList->GetEnumerator_674ad93a972a4d67();
    }
    
    System::Object* ListWrapper::get_Item_896a441a7363c710(int32_t index) {
        return this->m_InnerList->get_Item_8550d21996ef9dc5(index);
    }
    
    System::Object* ListWrapper::set_Item_a9ec2ce7dfe8dea5(int32_t index, System::Object* value) {
        this->m_InnerList->set_Item_d57705373e0668e7(index, value);
        return get_Item_896a441a7363c710(index);
    }
    
    int32_t ListWrapper::get_Count_614a2abb891f748b() {
        return this->m_InnerList->get_Count_8f254f3dd8e2403();
    }
    
    bool ListWrapper::get_IsSynchronized_23e3b7993e71d737() {
        return this->m_InnerList->get_IsSynchronized_20926e7dabc53dbf();
    }
    
    System::Object* ListWrapper::get_SyncRoot_a3def0e51eeaf8d9() {
        return this->m_InnerList->get_SyncRoot_257108f45cc89e19();
    }
    
    bool ListWrapper::get_IsFixedSize_3444cf8f8ef3efa4() {
        return this->m_InnerList->get_IsFixedSize_4d3eaee3435ee591();
    }
    
    bool ListWrapper::get_IsReadOnly_fe00057b4a1798ff() {
        return this->m_InnerList->get_IsReadOnly_53b6e02d46187790();
    }
    
}}
namespace System { namespace Collections {
    
    cli::array<System::Object*>*  ArrayList::EmptyArray;
    
    ArrayList::ArrayList()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void ArrayList::constructor() {
        this->_items = EmptyArray;
    }
    
    void ArrayList::constructor(ICollection* c) {
        System::Array *array;
        if((c ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("c"));
        }
        array = cli::as<System::Array*>(c);
        if(((array != nullptr) && (array->get_Rank() != 1))) 
        {
            throw cli::gcnew<System::RankException>();
        }
        this->_items = (new cli::array<System::Object*>(c->get_Count_8f254f3dd8e2403()));
        AddRange_a8bb4db32a72ffe(c);
    }
    
    void ArrayList::constructor(int32_t capacity) {
        if((capacity < 0)) 
        {
            ThrowNewArgumentOutOfRangeException(_T("capacity"), cli::box(capacity), _T("The initial capacity can\'t be smaller than zero."));
        }
        if((capacity ==  0)) 
        {
            capacity = 4;
        }
        this->_items = (new cli::array<System::Object*>(capacity));
    }
    
    void ArrayList::constructor(int32_t initialCapacity, bool forceZeroSize) {
        if(forceZeroSize) 
        {
            this->_items = nullptr;
        }
         else 
        {
            throw cli::gcnew<System::InvalidOperationException>(_T("Use ArrayList(int)"));
        }
    }
    
    void ArrayList::constructor(cli::array<System::Object*>* array, int32_t index, int32_t count) {
        if((count ==  0)) 
        {
            this->_items = (new cli::array<System::Object*>(4));
        }
         else 
        {
            this->_items = (new cli::array<System::Object*>(count));
        }
        System::Array::Copy2(array, index, this->_items, 0, count);
        this->_size = count;
    }
    
    void ArrayList::static_constructor() {
    }
    
    void ArrayList::EnsureCapacity(int32_t count) {
        if((count <= this->_items->get_Length())) 
        {
            return;
        }
        int32_t newLength;
        cli::array<System::Object*> *newData;
        newLength = (this->_items->get_Length() << 1);
        if((newLength ==  0)) 
        {
            newLength = 4;
        }
        while((newLength < count)) {
            (newLength = newLength << 1);
        }
        newData = (new cli::array<System::Object*>(newLength));
        System::Array::Copy2(this->_items, 0, newData, 0, this->_items->get_Length());
        this->_items = newData;
    }
    
    void ArrayList::Shift(int32_t index, int32_t count) {
        if((count > 0)) 
        {
            if(((this->_size + count) > this->_items->get_Length())) 
            {
                int32_t newLength;
                cli::array<System::Object*> *newData;
                newLength = (this->_items->get_Length() > 0) ? (this->_items->get_Length() << 1) : 1;
                while((newLength < (this->_size + count))) {
                    (newLength = newLength << 1);
                }
                newData = (new cli::array<System::Object*>(newLength));
                System::Array::Copy2(this->_items, 0, newData, 0, index);
                System::Array::Copy2(this->_items, index, newData, (index + count), (this->_size - index));
                this->_items = newData;
            }
             else 
            {
                System::Array::Copy2(this->_items, index, this->_items, (index + count), (this->_size - index));
            }
        }
         else 
        {
            if((count < 0)) 
            {
                int32_t x = (index - count);
                System::Array::Copy2(this->_items, x, this->_items, index, (this->_size - x));
                System::Array::Clear2(this->_items, (this->_size + count), -(count));
            }
        }
    }
    
    int32_t ArrayList::Add_e6a92085999ce388(System::Object* value) {
        if((this->_items->get_Length() <= this->_size)) 
        {
            EnsureCapacity((this->_size + 1));
        }
        this->_items->at(this->_size) = value;
        this->_version++;
        return this->_size++;
    }
    
    void ArrayList::Clear_cd6654e5a40f5056() {
        System::Array::Clear2(this->_items, 0, this->_size);
        this->_size = 0;
        this->_version++;
    }
    
    bool ArrayList::Contains_f1c198d01147f1ee(System::Object* item) {
        return (IndexOf_adae3dc40eaa594e(item, 0, this->_size) > -1);
    }
    
    bool ArrayList::Contains_381049624765eb70(System::Object* value, int32_t startIndex, int32_t count) {
        return (IndexOf_adae3dc40eaa594e(value, startIndex, count) > -1);
    }
    
    int32_t ArrayList::IndexOf_7e9811d6771f771d(System::Object* value) {
        return IndexOf_1c0527e45dc3728e(value, 0);
    }
    
    int32_t ArrayList::IndexOf_1c0527e45dc3728e(System::Object* value, int32_t startIndex) {
        return IndexOf_adae3dc40eaa594e(value, startIndex, (this->_size - startIndex));
    }
    
    int32_t ArrayList::IndexOf_adae3dc40eaa594e(System::Object* value, int32_t startIndex, int32_t count) {
        if(((startIndex < 0) || (startIndex > this->_size))) 
        {
            ThrowNewArgumentOutOfRangeException(_T("startIndex"), cli::box(startIndex), _T("Does not specify valid index."));
        }
        if((count < 0)) 
        {
            ThrowNewArgumentOutOfRangeException(_T("count"), cli::box(count), _T("Can\'t be less than 0."));
        }
        if((startIndex > (this->_size - count))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("count"), _T("Start index and count do not specify a valid range."));
        }
        return System::Array::template IndexOf_13<System::Object*>(this->_items, value, startIndex, count);
    }
    
    int32_t ArrayList::LastIndexOf_ecfd0185f74248a7(System::Object* value) {
        return LastIndexOf_ed2c73a4e33a0826(value, (this->_size - 1));
    }
    
    int32_t ArrayList::LastIndexOf_ed2c73a4e33a0826(System::Object* value, int32_t startIndex) {
        return LastIndexOf_c6f99b5b290904b1(value, startIndex, (startIndex + 1));
    }
    
    int32_t ArrayList::LastIndexOf_c6f99b5b290904b1(System::Object* value, int32_t startIndex, int32_t count) {
        return System::Array::template LastIndexOf_13<System::Object*>(this->_items, value, startIndex, count);
    }
    
    void ArrayList::Insert_59557a2615bf3b8e(int32_t index, System::Object* value) {
        if(((index < 0) || (index > this->_size))) 
        {
            ThrowNewArgumentOutOfRangeException(_T("index"), cli::box(index), _T("Index must be >= 0 and <= Count."));
        }
        Shift(index, 1);
        this->_items->at(index) = value;
        this->_size++;
        this->_version++;
    }
    
    void ArrayList::InsertRange_2250ae882d749466(int32_t index, ICollection* c) {
        int32_t i;
        if((c ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("c"));
        }
        if(((index < 0) || (index > this->_size))) 
        {
            ThrowNewArgumentOutOfRangeException(_T("index"), cli::box(index), _T("Index must be >= 0 and <= Count."));
        }
        i = c->get_Count_8f254f3dd8e2403();
        if((this->_items->get_Length() < (this->_size + i))) 
        {
            EnsureCapacity((this->_size + i));
        }
        if((index < this->_size)) 
        {
            System::Array::Copy2(this->_items, index, this->_items, (index + i), (this->_size - index));
        }
        if((this ==  c->get_SyncRoot_257108f45cc89e19())) 
        {
            System::Array::Copy2(this->_items, 0, this->_items, index, index);
            System::Array::Copy2(this->_items, (index + i), this->_items, (index << 1), (this->_size - index));
        }
         else 
        {
            c->CopyTo_7065a6e3cf6a140(this->_items, index);
        }
        (this->_size = this->_size + c->get_Count_8f254f3dd8e2403());
        this->_version++;
    }
    
    void ArrayList::Remove_2225381aaf812c6d(System::Object* obj) {
        int32_t x;
        x = IndexOf_7e9811d6771f771d(obj);
        if((x > -1)) 
        {
            RemoveAt_2abea768d3273318(x);
        }
        this->_version++;
    }
    
    void ArrayList::RemoveAt_2abea768d3273318(int32_t index) {
        if(((index < 0) || (index >= this->_size))) 
        {
            ThrowNewArgumentOutOfRangeException(_T("index"), cli::box(index), _T("Less than 0 or more than list count."));
        }
        Shift(index, -1);
        this->_size--;
        this->_version++;
    }
    
    void ArrayList::RemoveRange_808c38a5e4171a64(int32_t index, int32_t count) {
        ArrayList::CheckRange(index, count, this->_size);
        Shift(index, -(count));
        (this->_size = this->_size - count);
        this->_version++;
    }
    
    void ArrayList::Reverse_e7caef4018f63b41() {
        System::Array::Reverse2(this->_items, 0, this->_size);
        this->_version++;
    }
    
    void ArrayList::Reverse_bb783f185b528565(int32_t index, int32_t count) {
        ArrayList::CheckRange(index, count, this->_size);
        System::Array::Reverse2(this->_items, index, count);
        this->_version++;
    }
    
    void ArrayList::CopyTo_c634d425a65b1fc3(System::Array* array) {
        System::Array::Copy(this->_items, array, this->_size);
    }
    
    void ArrayList::CopyTo_2bc540dad3c25b9e(System::Array* array, int32_t arrayIndex) {
        CopyTo_4b0d97bda775c102(0, array, arrayIndex, this->_size);
    }
    
    void ArrayList::CopyTo_4b0d97bda775c102(int32_t index, System::Array* array, int32_t arrayIndex, int32_t count) {
        if((array ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("array"));
        }
        if((array->get_Rank() != 1)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Must have only 1 dimensions."), _T("array"));
        }
        System::Array::Copy2(this->_items, index, array, arrayIndex, count);
    }
    
    IEnumerator* ArrayList::GetEnumerator_84e3ba8f2fdefd62() {
        return cli::gcnew<SimpleEnumerator2>(this);
    }
    
    IEnumerator* ArrayList::GetEnumerator_78a3fe75766282cd(int32_t index, int32_t count) {
        ArrayList::CheckRange(index, count, this->_size);
        return cli::gcnew<ArrayListEnumerator>(this, index, count);
    }
    
    void ArrayList::AddRange_a8bb4db32a72ffe(ICollection* c) {
        InsertRange_2250ae882d749466(this->_size, c);
    }
    
    int32_t ArrayList::BinarySearch_77606568b997fd61(System::Object* value) {
        try {
            return System::Array::template BinarySearch_13<System::Object*>(this->_items, 0, this->_size, value);
        }
        catch(System::InvalidOperationException* e) {
            throw cli::gcnew<System::ArgumentException>(e->get_Message_d211df4045b57cbf());
        }
    }
    
    int32_t ArrayList::BinarySearch_f0deec366fa04a93(System::Object* value, IComparer* comparer) {
        try {
            return System::Array::BinarySearch4(this->_items, 0, this->_size, value, comparer);
        }
        catch(System::InvalidOperationException* e) {
            throw cli::gcnew<System::ArgumentException>(e->get_Message_d211df4045b57cbf());
        }
    }
    
    int32_t ArrayList::BinarySearch_5160cee074873e3f(int32_t index, int32_t count, System::Object* value, IComparer* comparer) {
        try {
            return System::Array::BinarySearch4(this->_items, index, count, value, comparer);
        }
        catch(System::InvalidOperationException* e) {
            throw cli::gcnew<System::ArgumentException>(e->get_Message_d211df4045b57cbf());
        }
    }
    
    ArrayList* ArrayList::GetRange_21d02af9397d43dc(int32_t index, int32_t count) {
        ArrayList::CheckRange(index, count, this->_size);
        if(this->get_IsSynchronized_ffa26be0a148c3c0()) 
        {
            return ArrayList::Synchronized(cli::gcnew<RangedArrayList>(this, index, count));
        }
         else 
        {
            return cli::gcnew<RangedArrayList>(this, index, count);
        }
    }
    
    void ArrayList::SetRange_87e491be8261c464(int32_t index, ICollection* c) {
        if((c ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("c"));
        }
        if(((index < 0) || ((index + c->get_Count_8f254f3dd8e2403()) > this->_size))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("index"));
        }
        c->CopyTo_7065a6e3cf6a140(this->_items, index);
        this->_version++;
    }
    
    void ArrayList::TrimToSize_d8592d0aafda93d() {
        if((this->_items->get_Length() > this->_size)) 
        {
            cli::array<System::Object*> *newArray;
            if((this->_size ==  0)) 
            {
                newArray = (new cli::array<System::Object*>(4));
            }
             else 
            {
                newArray = (new cli::array<System::Object*>(this->_size));
            }
            System::Array::Copy2(this->_items, 0, newArray, 0, this->_size);
            this->_items = newArray;
        }
    }
    
    void ArrayList::Sort_9fb0fdfea73c2096() {
        System::Array::template Sort_13<System::Object*>(this->_items, 0, this->_size);
        this->_version++;
    }
    
    void ArrayList::Sort_bdf7dee226e6219b(IComparer* comparer) {
        System::Array::Sort7(this->_items, 0, this->_size, comparer);
    }
    
    void ArrayList::Sort_e6922b45a581abd6(int32_t index, int32_t count, IComparer* comparer) {
        ArrayList::CheckRange(index, count, this->_size);
        System::Array::Sort7(this->_items, index, count, comparer);
    }
    
    cli::array<System::Object*>* ArrayList::ToArray_360bcd462eb48114() {
        cli::array<System::Object*> *retval;
        retval = (new cli::array<System::Object*>(this->_size));
        CopyTo_c634d425a65b1fc3(retval);
        return retval;
    }
    
    System::Array* ArrayList::ToArray_7b80f35a5dbfbc47(System::Type* type) {
        System::Array *retval;
        retval = System::Array::CreateInstance(type, this->_size);
        CopyTo_c634d425a65b1fc3(retval);
        return retval;
    }
    
    System::Object* ArrayList::Clone_5d610374e21ea7b0() {
        return cli::gcnew<ArrayList>(this->_items, 0, this->_size);
    }
    
    void ArrayList::CheckRange(int32_t index, int32_t count, int32_t listCount) {
        if((index < 0)) 
        {
            ThrowNewArgumentOutOfRangeException(_T("index"), cli::box(index), _T("Can\'t be less than 0."));
        }
        if((count < 0)) 
        {
            ThrowNewArgumentOutOfRangeException(_T("count"), cli::box(count), _T("Can\'t be less than 0."));
        }
        if((index > (listCount - count))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Index and count do not denote a valid range of elements."), _T("index"));
        }
    }
    
    void ArrayList::ThrowNewArgumentOutOfRangeException(System::String* name, System::Object* actual, System::String* message) {
        throw cli::gcnew<System::ArgumentOutOfRangeException>(name, actual, message);
    }
    
    ArrayList* ArrayList::Adapter(IList* list) {
        if((list ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("list"));
        }
        ArrayList *arrayList = cli::as<ArrayList*>(list);
        if((arrayList != nullptr)) 
        {
            return arrayList;
        }
         else 
        {
            arrayList = cli::gcnew<ArrayListAdapter>(list);
        }
        if(list->get_IsSynchronized_20926e7dabc53dbf()) 
        {
            return ArrayList::Synchronized(arrayList);
        }
         else 
        {
            return arrayList;
        }
    }
    
    ArrayList* ArrayList::Synchronized(ArrayList* list) {
        if((list ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("list"));
        }
        if(list->get_IsSynchronized_ffa26be0a148c3c0()) 
        {
            return list;
        }
        return cli::gcnew<SynchronizedArrayListWrapper>(list);
    }
    
    IList* ArrayList::Synchronized2(IList* list) {
        if((list ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("list"));
        }
        if(list->get_IsSynchronized_20926e7dabc53dbf()) 
        {
            return list;
        }
        return cli::gcnew<SynchronizedListWrapper>(list);
    }
    
    ArrayList* ArrayList::ReadOnly(ArrayList* list) {
        if((list ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("list"));
        }
        if(list->get_IsReadOnly_671df7b1908db8ee()) 
        {
            return list;
        }
        return cli::gcnew<ReadOnlyArrayListWrapper>(list);
    }
    
    IList* ArrayList::ReadOnly2(IList* list) {
        if((list ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("list"));
        }
        if(list->get_IsReadOnly_53b6e02d46187790()) 
        {
            return list;
        }
        return cli::gcnew<ReadOnlyListWrapper>(list);
    }
    
    ArrayList* ArrayList::FixedSize(ArrayList* list) {
        if((list ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("list"));
        }
        if(list->get_IsFixedSize_97a42a087785251()) 
        {
            return list;
        }
        return cli::gcnew<FixedSizeArrayListWrapper>(list);
    }
    
    IList* ArrayList::FixedSize2(IList* list) {
        if((list ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("list"));
        }
        if(list->get_IsFixedSize_4d3eaee3435ee591()) 
        {
            return list;
        }
        return cli::gcnew<FixedSizeListWrapper>(list);
    }
    
    ArrayList* ArrayList::Repeat(System::Object* value, int32_t count) {
        ArrayList *arrayList = cli::gcnew<ArrayList>(count);
        for(int32_t i = 0; (i < count); i++){
            arrayList->Add_e6a92085999ce388(value);
        }
        return arrayList;
    }
    
    System::Object* ArrayList::get_Item_fd0155f142ae570(int32_t index) {
        if(((index < 0) || (index >= this->_size))) 
        {
            ThrowNewArgumentOutOfRangeException(_T("index"), cli::box(index), _T("Index is less than 0 or more than or equal to the list count."));
        }
        return this->_items->at(index);
    }
    
    System::Object* ArrayList::set_Item_9f12782653a34813(int32_t index, System::Object* value) {
        if(((index < 0) || (index >= this->_size))) 
        {
            ThrowNewArgumentOutOfRangeException(_T("index"), cli::box(index), _T("Index is less than 0 or more than or equal to the list count."));
        }
        this->_items->at(index) = value;
        this->_version++;
        return get_Item_fd0155f142ae570(index);
    }
    
    int32_t ArrayList::get_Count_2354963792616712() {
        return this->_size;
    }
    
    int32_t ArrayList::get_Capacity_2220db8052d52582() {
        return this->_items->get_Length();
    }
    
    int32_t ArrayList::set_Capacity_8cc9f300b61d27aa(int32_t value) {
        if((value < this->_size)) 
        {
            ThrowNewArgumentOutOfRangeException(_T("Capacity"), cli::box(value), _T("Must be more than count."));
        }
        cli::array<System::Object*> *newArray;
        newArray = (new cli::array<System::Object*>(value));
        System::Array::Copy2(this->_items, 0, newArray, 0, this->_size);
        this->_items = newArray;
        return get_Capacity_2220db8052d52582();
    }
    
    bool ArrayList::get_IsFixedSize_97a42a087785251() {
        return false;
    }
    
    bool ArrayList::get_IsReadOnly_671df7b1908db8ee() {
        return false;
    }
    
    bool ArrayList::get_IsSynchronized_ffa26be0a148c3c0() {
        return false;
    }
    
    System::Object* ArrayList::get_SyncRoot_edb1ba826807b569() {
        return this;
    }
    
}}
namespace System { namespace Collections {
    
    
    void BitArrayEnumerator::constructor(BitArray* ba) {
        this->_index = -1;
        this->_bitArray = ba;
        this->_version = ba->_version;
    }
    
    System::Object* BitArrayEnumerator::Clone() {
        return System::Object::MemberwiseClone();
    }
    
    bool BitArrayEnumerator::MoveNext() {
        checkVersion();
        if((this->_index < (this->_bitArray->get_Count() - 1))) 
        {
            this->_current = this->_bitArray->get_Item(++this->_index);
            return true;
        }
        this->_index = this->_bitArray->get_Count();
        return false;
    }
    
    void BitArrayEnumerator::Reset() {
        checkVersion();
        this->_index = -1;
    }
    
    void BitArrayEnumerator::checkVersion() {
        if((this->_version != this->_bitArray->_version)) 
        {
            throw cli::gcnew<System::InvalidOperationException>();
        }
    }
    
    System::Object* BitArrayEnumerator::get_Current() {
        if((this->_index ==  -1)) 
        {
            throw cli::gcnew<System::InvalidOperationException>(_T("Enum not started"));
        }
        if((this->_index >= this->_bitArray->get_Count())) 
        {
            throw cli::gcnew<System::InvalidOperationException>(_T("Enum Ended"));
        }
        return cli::box(this->_current);
    }
    
}}
namespace System { namespace Collections {
    
    
    void BitArray::constructor(BitArray* bits) {
        if((bits ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("bits"));
        }
        this->m_length = bits->m_length;
        this->m_array = (new cli::array<int32_t>(((this->m_length + 31) / 32)));
        if((this->m_array->get_Length() ==  1)) 
        {
            this->m_array->at(0) = bits->m_array->at(0);
        }
         else 
        {
            System::Array::Copy(bits->m_array, this->m_array, this->m_array->get_Length());
        }
    }
    
    void BitArray::constructor(cli::array<bool>* values) {
        if((values ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("values"));
        }
        this->m_length = values->get_Length();
        this->m_array = (new cli::array<int32_t>(((this->m_length + 31) / 32)));
        for(int32_t i = 0; (i < values->get_Length()); i++) {
            this->set_Item(i, values->at(i));
        }
    }
    
    void BitArray::constructor(cli::array<unsigned char>* bytes) {
        if((bytes ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("bytes"));
        }
        this->m_length = (bytes->get_Length() * 8);
        this->m_array = (new cli::array<int32_t>(((this->m_length + 31) / 32)));
        for(int32_t i = 0; (i < bytes->get_Length()); i++) {
            setByte(i, bytes->at(i));
        }
    }
    
    void BitArray::constructor(cli::array<int32_t>* values) {
        if((values ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("values"));
        }
        int32_t arrlen = values->get_Length();
        this->m_length = (arrlen * 32);
        this->m_array = (new cli::array<int32_t>(arrlen));
        System::Array::Copy(values, this->m_array, arrlen);
    }
    
    void BitArray::constructor(int32_t length) {
        if((length < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("length"));
        }
        this->m_length = length;
        this->m_array = (new cli::array<int32_t>(((this->m_length + 31) / 32)));
    }
    
    void BitArray::constructor(int32_t length, bool defaultValue) {
        if(defaultValue) 
        {
            for(int32_t i = 0; (i < this->m_array->get_Length()); i++) {
                this->m_array->at(i) = -1;
            }
        }
    }
    
    unsigned char BitArray::getByte(int32_t byteIndex) {
        int32_t index = (byteIndex / 4);
        int32_t shift = ((byteIndex % 4) * 8);
        int32_t theByte = (this->m_array->at(index) & (255 << (shift & 31)));
        return (unsigned char)((theByte >> (shift & 31)) & 255);
    }
    
    void BitArray::setByte(int32_t byteIndex, unsigned char value) {
        int32_t index = (byteIndex / 4);
        int32_t shift = ((byteIndex % 4) * 8);
        (this->m_array->at(index) = this->m_array->at(index) & ~((255 << (shift & 31))));
        (this->m_array->at(index) = this->m_array->at(index) | ((int32_t)(value) << (shift & 31)));
        this->_version++;
    }
    
    void BitArray::checkOperand(BitArray* operand) {
        if((operand ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>();
        }
        if((operand->m_length != this->m_length)) 
        {
            throw cli::gcnew<System::ArgumentException>();
        }
    }
    
    System::Object* BitArray::Clone() {
        return cli::gcnew<BitArray>(this);
    }
    
    void BitArray::CopyTo(System::Array* array, int32_t index) {
        if((array ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("array"));
        }
        if((index < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("index"));
        }
        if((array->get_Rank() != 1)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("array"), _T("Array rank must be 1"));
        }
        if(((index >= array->get_Length()) && (this->m_length > 0))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("index"), _T("index is greater than array.Length"));
        }
        if(cli::is<cli::array<bool>>(array)) 
        {
            if(((array->get_Length() - index) < this->m_length)) 
            {
                throw cli::gcnew<System::ArgumentException>();
            }
            cli::array<bool> *barray = cli::cast<cli::array<bool>*>(array);
            for(int32_t i = 0; (i < this->m_length); i++) {
                barray->at((index + i)) = this->get_Item(i);
            }
        }
         else 
        {
            if(cli::is<cli::array<unsigned char>>(array)) 
            {
                int32_t numbytes = ((this->m_length + 7) / 8);
                if(((array->get_Length() - index) < numbytes)) 
                {
                    throw cli::gcnew<System::ArgumentException>();
                }
                cli::array<unsigned char> *barray = cli::cast<cli::array<unsigned char>*>(array);
                for(int32_t i = 0; (i < numbytes); i++) {
                    barray->at((index + i)) = getByte(i);
                }
            }
             else 
            {
                if(cli::is<cli::array<int32_t>>(array)) 
                {
                    System::Array::Copy2(this->m_array, 0, array, index, ((this->m_length + 31) / 32));
                }
                 else 
                {
                    throw cli::gcnew<System::ArgumentException>(_T("array"), _T("Unsupported type"));
                }
            }
        }
    }
    
    BitArray* BitArray::Not() {
        int32_t ints = ((this->m_length + 31) / 32);
        for(int32_t i = 0; (i < ints); i++) {
            this->m_array->at(i) = ~(this->m_array->at(i));
        }
        this->_version++;
        return this;
    }
    
    BitArray* BitArray::And(BitArray* value) {
        checkOperand(value);
        int32_t ints = ((this->m_length + 31) / 32);
        for(int32_t i = 0; (i < ints); i++) {
            (this->m_array->at(i) = this->m_array->at(i) & value->m_array->at(i));
        }
        this->_version++;
        return this;
    }
    
    BitArray* BitArray::Or(BitArray* value) {
        checkOperand(value);
        int32_t ints = ((this->m_length + 31) / 32);
        for(int32_t i = 0; (i < ints); i++) {
            (this->m_array->at(i) = this->m_array->at(i) | value->m_array->at(i));
        }
        this->_version++;
        return this;
    }
    
    BitArray* BitArray::Xor(BitArray* value) {
        checkOperand(value);
        int32_t ints = ((this->m_length + 31) / 32);
        for(int32_t i = 0; (i < ints); i++) {
            (this->m_array->at(i) = this->m_array->at(i) ^ value->m_array->at(i));
        }
        this->_version++;
        return this;
    }
    
    bool BitArray::Get(int32_t index) {
        if(((index < 0) || (index >= this->m_length))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>();
        }
        return ((this->m_array->at((index >> 5)) & (1 << ((index & 31) & 31))) != 0);
    }
    
    void BitArray::Set(int32_t index, bool value) {
        if(((index < 0) || (index >= this->m_length))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>();
        }
        if(value) 
        {
            (this->m_array->at((index >> 5)) = this->m_array->at((index >> 5)) | (1 << ((index & 31) & 31)));
        }
         else 
        {
            (this->m_array->at((index >> 5)) = this->m_array->at((index >> 5)) & ~((1 << ((index & 31) & 31))));
        }
        this->_version++;
    }
    
    void BitArray::SetAll(bool value) {
        if(value) 
        {
            for(int32_t i = 0; (i < this->m_array->get_Length()); i++) {
                this->m_array->at(i) = -1;
            }
        }
         else 
        {
            System::Array::Clear2(this->m_array, 0, this->m_array->get_Length());
        }
        this->_version++;
    }
    
    IEnumerator* BitArray::GetEnumerator() {
        return cli::gcnew<BitArrayEnumerator>(this);
    }
    
    int32_t BitArray::get_Count() {
        return this->m_length;
    }
    
    bool BitArray::get_IsReadOnly() {
        return false;
    }
    
    bool BitArray::get_IsSynchronized() {
        return false;
    }
    
    bool BitArray::get_Item(int32_t index) {
        return Get(index);
    }
    
    bool BitArray::set_Item(int32_t index, bool value) {
        Set(index, value);
        return get_Item(index);
    }
    
    int32_t BitArray::get_Length() {
        return this->m_length;
    }
    
    int32_t BitArray::set_Length(int32_t value) {
        if((this->m_length ==  value)) 
        {
            return get_Length();
        }
        if((value < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>();
        }
        if((value > this->m_length)) 
        {
            int32_t numints = ((value + 31) / 32);
            int32_t old_numints = ((this->m_length + 31) / 32);
            if((numints > this->m_array->get_Length())) 
            {
                cli::array<int32_t> *newArr = (new cli::array<int32_t>(numints));
                System::Array::Copy(this->m_array, newArr, this->m_array->get_Length());
                this->m_array = newArr;
            }
             else 
            {
                System::Array::Clear2(this->m_array, old_numints, (numints - old_numints));
            }
            int32_t mask = (this->m_length % 32);
            if((mask > 0)) 
            {
                (this->m_array->at((old_numints - 1)) = this->m_array->at((old_numints - 1)) & ((1 << (mask & 31)) - 1));
            }
        }
        this->m_length = value;
        this->_version++;
        return get_Length();
    }
    
    System::Object* BitArray::get_SyncRoot() {
        return this;
    }
    
}}
namespace System { namespace Collections {
    
    CaseInsensitiveComparer*  CaseInsensitiveComparer::defaultComparer;
    CaseInsensitiveComparer*  CaseInsensitiveComparer::defaultInvariantComparer;
    
    CaseInsensitiveComparer::CaseInsensitiveComparer()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void CaseInsensitiveComparer::constructor() {
        this->culture = System::Globalization::CultureInfo::get_CurrentCulture();
    }
    
    void CaseInsensitiveComparer::constructor(bool invariant) {
    }
    
    void CaseInsensitiveComparer::constructor(System::Globalization::CultureInfo* culture) {
        if((culture ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("culture"));
        }
        if((culture->get_LCID_f4b9bc9d0bf0db86() != System::Globalization::CultureInfo::get_InvariantCulture()->get_LCID_f4b9bc9d0bf0db86())) 
        {
            this->culture = culture;
        }
    }
    
    void CaseInsensitiveComparer::static_constructor() {
    }
    
    int32_t CaseInsensitiveComparer::Compare(System::Object* a, System::Object* b) {
        System::String *sa = cli::as<System::String*>(a);
        System::String *sb = cli::as<System::String*>(b);
        if(((sa != nullptr) && (sb != nullptr))) 
        {
            if((this->culture != nullptr)) 
            {
                return this->culture->get_CompareInfo_ef6e4d0bc469f6a()->Compare_272e035d74e81a5d(sa, sb, System::Globalization::CompareOptions::IgnoreCase);
            }
             else 
            {
                return System::Globalization::CultureInfo::get_InvariantCulture()->get_CompareInfo_ef6e4d0bc469f6a()->Compare_272e035d74e81a5d(sa, sb, System::Globalization::CompareOptions::IgnoreCase);
            }
        }
         else 
        {
            return Comparer::Default2->Compare(a, b);
        }
    }
    
    CaseInsensitiveComparer* CaseInsensitiveComparer::get_Default() {
        return defaultComparer;
    }
    
    CaseInsensitiveComparer* CaseInsensitiveComparer::get_DefaultInvariant() {
        return defaultInvariantComparer;
    }
    
}}
namespace System { namespace Collections {
    
    CaseInsensitiveHashCodeProvider*  CaseInsensitiveHashCodeProvider::singletonInvariant;
    CaseInsensitiveHashCodeProvider*  CaseInsensitiveHashCodeProvider::singleton;
    System::Object*  CaseInsensitiveHashCodeProvider::sync;
    
    CaseInsensitiveHashCodeProvider::CaseInsensitiveHashCodeProvider()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void CaseInsensitiveHashCodeProvider::constructor() {
        System::Globalization::CultureInfo *culture = System::Globalization::CultureInfo::get_CurrentCulture();
        if(!(AreEqual(culture, System::Globalization::CultureInfo::get_InvariantCulture()))) 
        {
            this->m_text = System::Globalization::CultureInfo::get_CurrentCulture()->get_TextInfo_63dfa6e5f11a61f0();
        }
    }
    
    void CaseInsensitiveHashCodeProvider::constructor(System::Globalization::CultureInfo* culture) {
        if((culture ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("culture"));
        }
        if(!(AreEqual(culture, System::Globalization::CultureInfo::get_InvariantCulture()))) 
        {
            this->m_text = culture->get_TextInfo_63dfa6e5f11a61f0();
        }
    }
    
    void CaseInsensitiveHashCodeProvider::static_constructor() {
    }
    
    bool CaseInsensitiveHashCodeProvider::AreEqual(System::Globalization::CultureInfo* a, System::Globalization::CultureInfo* b) {
        return (a->get_LCID_f4b9bc9d0bf0db86() ==  b->get_LCID_f4b9bc9d0bf0db86());
    }
    
    bool CaseInsensitiveHashCodeProvider::AreEqual2(System::Globalization::TextInfo* info, System::Globalization::CultureInfo* culture) {
        return (info->get_LCID() ==  culture->get_LCID_f4b9bc9d0bf0db86());
    }
    
    int32_t CaseInsensitiveHashCodeProvider::GetHashCode2(System::Object* obj) {
        if((obj ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("obj"));
        }
        System::String *str = cli::as<System::String*>(obj);
        if((str ==  nullptr)) 
        {
            return obj->GetHashCode_6648aef0f235ee6c();
        }
        int32_t h = 0;
        char16_t c;
        if(((this->m_text != nullptr) && !(AreEqual2(this->m_text, System::Globalization::CultureInfo::get_InvariantCulture())))) 
        {
            str = this->m_text->ToLower_4a9626b08fd9b34f(str);
            for(int32_t i = 0; (i < str->get_Length()); i++){
                c = str->get_Chars(i);
                h = ((h * 31) + (int32_t)(c));
            }
        }
         else 
        {
            for(int32_t i = 0; (i < str->get_Length()); i++){
                c = System::Char::ToLower2(str->get_Chars(i), System::Globalization::CultureInfo::get_InvariantCulture());
                h = ((h * 31) + (int32_t)(c));
            }
        }
        return h;
    }
    
    CaseInsensitiveHashCodeProvider* CaseInsensitiveHashCodeProvider::get_Default() {
        {
            cli::lock_guard{sync};
            if((singleton ==  nullptr)) 
            {
                singleton = cli::gcnew<CaseInsensitiveHashCodeProvider>();
            }
             else 
            {
                if((singleton->m_text ==  nullptr)) 
                {
                    if(!(AreEqual(System::Globalization::CultureInfo::get_CurrentCulture(), System::Globalization::CultureInfo::get_InvariantCulture()))) 
                    {
                        singleton = cli::gcnew<CaseInsensitiveHashCodeProvider>();
                    }
                }
                 else 
                {
                    if(!(AreEqual2(singleton->m_text, System::Globalization::CultureInfo::get_CurrentCulture()))) 
                    {
                        singleton = cli::gcnew<CaseInsensitiveHashCodeProvider>();
                    }
                }
            }
            return singleton;
        }
    }
    
    CaseInsensitiveHashCodeProvider* CaseInsensitiveHashCodeProvider::get_DefaultInvariant() {
        return singletonInvariant;
    }
    
}}
namespace System { namespace Collections {
    
    
    void CollectionBase::constructor() {
    }
    
    void CollectionBase::constructor(int32_t capacity) {
        this->list = cli::gcnew<ArrayList>(capacity);
    }
    
    IEnumerator* CollectionBase::GetEnumerator() {
        return this->get_InnerList()->GetEnumerator_84e3ba8f2fdefd62();
    }
    
    void CollectionBase::Clear() {
        OnClear_546ea22836fc4347();
        this->get_InnerList()->Clear_cd6654e5a40f5056();
        OnClearComplete_262d89123b61bb40();
    }
    
    void CollectionBase::RemoveAt(int32_t index) {
        System::Object *objectToRemove;
        objectToRemove = this->get_InnerList()->get_Item_fd0155f142ae570(index);
        OnValidate_b8e0f62511f977c6(objectToRemove);
        OnRemove_aefde0c876b0f4bb(index, objectToRemove);
        this->get_InnerList()->RemoveAt_2abea768d3273318(index);
        OnRemoveComplete_e8fa485a1524028a(index, objectToRemove);
    }
    
    void CollectionBase::OnClear_546ea22836fc4347() {
    }
    
    void CollectionBase::OnClearComplete_262d89123b61bb40() {
    }
    
    void CollectionBase::OnInsert_b7fce752b35e7db5(int32_t index, System::Object* value) {
    }
    
    void CollectionBase::OnInsertComplete_5963d3846329d8fa(int32_t index, System::Object* value) {
    }
    
    void CollectionBase::OnRemove_aefde0c876b0f4bb(int32_t index, System::Object* value) {
    }
    
    void CollectionBase::OnRemoveComplete_e8fa485a1524028a(int32_t index, System::Object* value) {
    }
    
    void CollectionBase::OnSet_744186d05d41e86d(int32_t index, System::Object* oldValue, System::Object* newValue) {
    }
    
    void CollectionBase::OnSetComplete_8b0900bc1e5ce252(int32_t index, System::Object* oldValue, System::Object* newValue) {
    }
    
    void CollectionBase::OnValidate_b8e0f62511f977c6(System::Object* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("CollectionBase.OnValidate: Invalid parameter value passed to method: null"));
        }
    }
    
    void CollectionBase::CopyTo(System::Array* array, int32_t index) {
        this->get_InnerList()->CopyTo_2bc540dad3c25b9e(array, index);
    }
    
    int32_t CollectionBase::Add(System::Object* value) {
        int32_t newPosition;
        OnValidate_b8e0f62511f977c6(value);
        newPosition = this->get_InnerList()->get_Count_2354963792616712();
        OnInsert_b7fce752b35e7db5(newPosition, value);
        this->get_InnerList()->Add_e6a92085999ce388(value);
        try {
            OnInsertComplete_5963d3846329d8fa(newPosition, value);
        }
        catch(...) {
            this->get_InnerList()->RemoveAt_2abea768d3273318(newPosition);
            throw ;
        }
        return newPosition;
    }
    
    bool CollectionBase::Contains(System::Object* value) {
        return this->get_InnerList()->Contains_f1c198d01147f1ee(value);
    }
    
    int32_t CollectionBase::IndexOf(System::Object* value) {
        return this->get_InnerList()->IndexOf_7e9811d6771f771d(value);
    }
    
    void CollectionBase::Insert(int32_t index, System::Object* value) {
        OnValidate_b8e0f62511f977c6(value);
        OnInsert_b7fce752b35e7db5(index, value);
        this->get_InnerList()->Insert_59557a2615bf3b8e(index, value);
        try {
            OnInsertComplete_5963d3846329d8fa(index, value);
        }
        catch(...) {
            this->get_InnerList()->RemoveAt_2abea768d3273318(index);
            throw ;
        }
    }
    
    void CollectionBase::Remove(System::Object* value) {
        int32_t removeIndex;
        OnValidate_b8e0f62511f977c6(value);
        removeIndex = this->get_InnerList()->IndexOf_7e9811d6771f771d(value);
        if((removeIndex ==  -1)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("The element cannot be found."), _T("value"));
        }
        OnRemove_aefde0c876b0f4bb(removeIndex, value);
        this->get_InnerList()->Remove_2225381aaf812c6d(value);
        OnRemoveComplete_e8fa485a1524028a(removeIndex, value);
    }
    
    int32_t CollectionBase::get_Count() {
        return this->get_InnerList()->get_Count_2354963792616712();
    }
    
    int32_t CollectionBase::get_Capacity() {
        if((this->list ==  nullptr)) 
        {
            this->list = cli::gcnew<ArrayList>();
        }
        return this->list->get_Capacity_2220db8052d52582();
    }
    
    int32_t CollectionBase::set_Capacity(int32_t value) {
        if((this->list ==  nullptr)) 
        {
            this->list = cli::gcnew<ArrayList>();
        }
        this->list->set_Capacity_8cc9f300b61d27aa(value);
        return get_Capacity();
    }
    
    ArrayList* CollectionBase::get_InnerList() {
        if((this->list ==  nullptr)) 
        {
            this->list = cli::gcnew<ArrayList>();
        }
        return this->list;
    }
    
    IList* CollectionBase::get_List() {
        return this;
    }
    
    System::Object* CollectionBase::get_SyncRoot() {
        return this->get_InnerList()->get_SyncRoot_edb1ba826807b569();
    }
    
    bool CollectionBase::get_IsSynchronized() {
        return this->get_InnerList()->get_IsSynchronized_ffa26be0a148c3c0();
    }
    
    bool CollectionBase::get_IsFixedSize() {
        return this->get_InnerList()->get_IsFixedSize_97a42a087785251();
    }
    
    bool CollectionBase::get_IsReadOnly() {
        return this->get_InnerList()->get_IsReadOnly_671df7b1908db8ee();
    }
    
    System::Object* CollectionBase::get_Item(int32_t index) {
        return this->get_InnerList()->get_Item_fd0155f142ae570(index);
    }
    
    System::Object* CollectionBase::set_Item(int32_t index, System::Object* value) {
        if(((index < 0) || (index >= this->get_InnerList()->get_Count_2354963792616712()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("index"));
        }
        System::Object *oldValue;
        OnValidate_b8e0f62511f977c6(value);
        oldValue = this->get_InnerList()->get_Item_fd0155f142ae570(index);
        OnSet_744186d05d41e86d(index, oldValue, value);
        this->get_InnerList()->set_Item_9f12782653a34813(index, value);
        try {
            OnSetComplete_8b0900bc1e5ce252(index, oldValue, value);
        }
        catch(...) {
            this->get_InnerList()->set_Item_9f12782653a34813(index, oldValue);
            throw ;
        }
        return get_Item(index);
    }
    
}}
namespace System { namespace Collections {
    
    
    void CollectionDebuggerView::constructor(ICollection* col) {
        this->c = col;
    }
    
    cli::array<System::Object*>* CollectionDebuggerView::get_Items() {
        cli::array<System::Object*> *o = (new cli::array<System::Object*>(this->c->get_Count_8f254f3dd8e2403()));
        this->c->CopyTo_7065a6e3cf6a140(o, 0);
        return o;
    }
    
}}
namespace System { namespace Collections {
    
    Comparer*  Comparer::Default2;
    Comparer*  Comparer::DefaultInvariant;
    
    Comparer::Comparer()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void Comparer::constructor() {
    }
    
    void Comparer::constructor(System::Globalization::CultureInfo* culture) {
        if((culture ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("culture"));
        }
        this->m_compareInfo = culture->get_CompareInfo_ef6e4d0bc469f6a();
    }
    
    void Comparer::static_constructor() {
    }
    
    int32_t Comparer::Compare(System::Object* a, System::Object* b) {
        if((a ==  b)) 
        {
            return 0;
        }
         else 
        {
            if((a ==  nullptr)) 
            {
                return -1;
            }
             else 
            {
                if((b ==  nullptr)) 
                {
                    return 1;
                }
            }
        }
        if((this->m_compareInfo != nullptr)) 
        {
            System::String *sa = cli::as<System::String*>(a);
            System::String *sb = cli::as<System::String*>(b);
            if(((sa != nullptr) && (sb != nullptr))) 
            {
                return this->m_compareInfo->Compare_50fe18f7ad0224bc(sa, sb);
            }
        }
        if(cli::is<System::IComparable>(a)) 
        {
            return cli::as<System::IComparable*>(a)->CompareTo_ed9d39205b7812f0(b);
        }
         else 
        {
            if(cli::is<System::IComparable>(b)) 
            {
                return -(cli::as<System::IComparable*>(b)->CompareTo_ed9d39205b7812f0(a));
            }
        }
        throw cli::gcnew<System::ArgumentException>(Locale::GetText(_T("Neither \'a\' nor \'b\' implements IComparable.")));
    }
    
    void Comparer::GetObjectData(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        if((info ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("info"));
        }
        info->AddValue(_T("CompareInfo"), this->m_compareInfo, cli::typeof<System::Type>::info);
    }
    
}}
namespace System { namespace Collections {
    
    
    void DictionaryBase::constructor() {
        this->hashtable = cli::gcnew<Hashtable>();
    }
    
    void DictionaryBase::Clear() {
        OnClear_6ef9b9f2f0fd4809();
        this->hashtable->Clear_f1f405c8fa63a059();
        OnClearComplete_5ab571a511f10976();
    }
    
    void DictionaryBase::CopyTo(System::Array* array, int32_t index) {
        if((array ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("array"));
        }
        if((index < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("index must be possitive"));
        }
        if((array->get_Rank() > 1)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("array is multidimensional"));
        }
        int32_t size = array->get_Length();
        if((index > size)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("index is larger than array size"));
        }
        if(((index + this->get_Count()) > size)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Copy will overlflow array"));
        }
        DoCopy(array, index);
    }
    
    void DictionaryBase::DoCopy(System::Array* array, int32_t index) {
        for(auto tmp_206 : this->hashtable) {
            auto de = cli::cast<DictionaryEntry>(tmp_206);
            array->SetValue5(cli::box(de), index++);
        }
    }
    
    IDictionaryEnumerator* DictionaryBase::GetEnumerator() {
        return this->hashtable->GetEnumerator_47df71de9b680069();
    }
    
    void DictionaryBase::OnClear_6ef9b9f2f0fd4809() {
    }
    
    void DictionaryBase::OnClearComplete_5ab571a511f10976() {
    }
    
    System::Object* DictionaryBase::OnGet_94f724c5d18f2041(System::Object* key, System::Object* currentValue) {
        return currentValue;
    }
    
    void DictionaryBase::OnInsert_862340ab831c4da5(System::Object* key, System::Object* value) {
    }
    
    void DictionaryBase::OnInsertComplete_dc9f25e67cf29410(System::Object* key, System::Object* value) {
    }
    
    void DictionaryBase::OnSet_5d422c0e116e47b0(System::Object* key, System::Object* oldValue, System::Object* newValue) {
    }
    
    void DictionaryBase::OnSetComplete_6298bb84d799d58a(System::Object* key, System::Object* oldValue, System::Object* newValue) {
    }
    
    void DictionaryBase::OnRemove_e1848c9085edcf00(System::Object* key, System::Object* value) {
    }
    
    void DictionaryBase::OnRemoveComplete_492d5c927ebfd38f(System::Object* key, System::Object* value) {
    }
    
    void DictionaryBase::OnValidate_a02562a8e925acee(System::Object* key, System::Object* value) {
    }
    
    void DictionaryBase::Add(System::Object* key, System::Object* value) {
        OnValidate_a02562a8e925acee(key, value);
        OnInsert_862340ab831c4da5(key, value);
        this->hashtable->Add_3f7ab157bcb41156(key, value);
        try {
            OnInsertComplete_dc9f25e67cf29410(key, value);
        }
        catch(...) {
            this->hashtable->Remove_fd653674dd8a5ac4(key);
            throw ;
        }
    }
    
    void DictionaryBase::Remove(System::Object* key) {
        if(!(this->hashtable->Contains_be7d0f2741618cb4(key))) 
        {
            return;
        }
        System::Object *value = this->hashtable->get_Item_d75c6e706b965758(key);
        OnValidate_a02562a8e925acee(key, value);
        OnRemove_e1848c9085edcf00(key, value);
        this->hashtable->Remove_fd653674dd8a5ac4(key);
        try {
            OnRemoveComplete_492d5c927ebfd38f(key, value);
        }
        catch(...) {
            this->hashtable->set_Item_84c7e24d9caa09(key, value);
            throw ;
        }
    }
    
    bool DictionaryBase::Contains(System::Object* key) {
        return this->hashtable->Contains_be7d0f2741618cb4(key);
    }
    
    IEnumerator* DictionaryBase::GetEnumerator2() {
        return this->hashtable->GetEnumerator_47df71de9b680069();
    }
    
    int32_t DictionaryBase::get_Count() {
        return this->hashtable->get_Count_40aff81471a60b4c();
    }
    
    IDictionary* DictionaryBase::get_Dictionary() {
        return this;
    }
    
    Hashtable* DictionaryBase::get_InnerHashtable() {
        return this->hashtable;
    }
    
    bool DictionaryBase::get_IsFixedSize() {
        return false;
    }
    
    bool DictionaryBase::get_IsReadOnly() {
        return false;
    }
    
    System::Object* DictionaryBase::get_Item(System::Object* key) {
        System::Object *value = this->hashtable->get_Item_d75c6e706b965758(key);
        OnGet_94f724c5d18f2041(key, value);
        return value;
    }
    
    System::Object* DictionaryBase::set_Item(System::Object* key, System::Object* value) {
        OnValidate_a02562a8e925acee(key, value);
        System::Object *current_value = this->hashtable->get_Item_d75c6e706b965758(key);
        OnSet_5d422c0e116e47b0(key, current_value, value);
        this->hashtable->set_Item_84c7e24d9caa09(key, value);
        try {
            OnSetComplete_6298bb84d799d58a(key, current_value, value);
        }
        catch(...) {
            this->hashtable->set_Item_84c7e24d9caa09(key, current_value);
            throw ;
        }
        return get_Item(key);
    }
    
    ICollection* DictionaryBase::get_Keys() {
        return this->hashtable->get_Keys_8171dfd94447fa93();
    }
    
    ICollection* DictionaryBase::get_Values() {
        return this->hashtable->get_Values_4ed88b5f6e59ef25();
    }
    
    bool DictionaryBase::get_IsSynchronized() {
        return this->hashtable->get_IsSynchronized_6d887770284f3341();
    }
    
    System::Object* DictionaryBase::get_SyncRoot() {
        return this->hashtable->get_SyncRoot_2d1e4aa44bab8a0d();
    }
    
}}
namespace System { namespace Collections {
    
    KeyMarker*  KeyMarker::Removed;
    
    KeyMarker::KeyMarker()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void KeyMarker::constructor() {
    }
    
    void KeyMarker::static_constructor() {
    }
    
    System::Object* KeyMarker::GetRealObject(System::Runtime::Serialization::StreamingContext context) {
        return Removed;
    }
    
}}
namespace System { namespace Collections {
    
    System::String*  Enumerator::xstr;
    
    Enumerator::Enumerator()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void Enumerator::constructor(Hashtable* host, EnumeratorMode mode) {
        this->host = host;
        this->stamp = host->modificationCount;
        this->size = host->table->get_Length();
        this->mode = mode;
        Reset();
    }
    
    void Enumerator::static_constructor() {
    }
    
    void Enumerator::FailFast() {
        if((this->host->modificationCount != this->stamp)) 
        {
            throw cli::gcnew<System::InvalidOperationException>(xstr);
        }
    }
    
    void Enumerator::Reset() {
        FailFast();
        this->pos = -1;
        this->currentKey = nullptr;
        this->currentValue = nullptr;
    }
    
    bool Enumerator::MoveNext() {
        FailFast();
        if((this->pos < this->size)) 
        {
            while((++this->pos < this->size)) {
                Slot entry = this->host->table->at(this->pos);
                if(((entry->key != nullptr) && (entry->key != KeyMarker::Removed))) 
                {
                    this->currentKey = entry->key;
                    this->currentValue = entry->value;
                    return true;
                }
            }
        }
        this->currentKey = nullptr;
        this->currentValue = nullptr;
        return false;
    }
    
    DictionaryEntry Enumerator::get_Entry() {
        if((this->currentKey ==  nullptr)) 
        {
            throw cli::gcnew<System::InvalidOperationException>();
        }
        FailFast();
        return cli::ctor<DictionaryEntry>(this->currentKey, this->currentValue);
    }
    
    System::Object* Enumerator::get_Key() {
        if((this->currentKey ==  nullptr)) 
        {
            throw cli::gcnew<System::InvalidOperationException>();
        }
        FailFast();
        return this->currentKey;
    }
    
    System::Object* Enumerator::get_Value() {
        if((this->currentKey ==  nullptr)) 
        {
            throw cli::gcnew<System::InvalidOperationException>();
        }
        FailFast();
        return this->currentValue;
    }
    
    System::Object* Enumerator::get_Current() {
        if((this->currentKey ==  nullptr)) 
        {
            throw cli::gcnew<System::InvalidOperationException>();
        }
        switch(this->mode) {
            case EnumeratorMode::KEY_MODE: case_949: {
                return this->currentKey;
            }
            case EnumeratorMode::VALUE_MODE: case_950: {
                return this->currentValue;
            }
            case EnumeratorMode::ENTRY_MODE: case_951: {
                return cli::box(cli::ctor<DictionaryEntry>(this->currentKey, this->currentValue));
            }
        }
        throw cli::gcnew<System::Exception>(_T("should never happen"));
    }
    
}}
namespace System { namespace Collections {
    
    
    void HashKeys::constructor(Hashtable* host) {
        if((host ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>();
        }
        this->host = host;
    }
    
    void HashKeys::CopyTo_26b7b563095a6a78(System::Array* array, int32_t arrayIndex) {
        if((array ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("array"));
        }
        if((array->get_Rank() != 1)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("array"));
        }
        if((arrayIndex < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("arrayIndex"));
        }
        if(((array->get_Length() - arrayIndex) < this->get_Count_870e31a32a0811da())) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("not enough space"));
        }
        this->host->CopyToArray(array, arrayIndex, EnumeratorMode::KEY_MODE);
    }
    
    IEnumerator* HashKeys::GetEnumerator_d0848c73b0d4ba7e() {
        return cli::gcnew<Enumerator>(this->host, EnumeratorMode::KEY_MODE);
    }
    
    int32_t HashKeys::get_Count_870e31a32a0811da() {
        return this->host->get_Count_40aff81471a60b4c();
    }
    
    bool HashKeys::get_IsSynchronized_1b4048350ba18310() {
        return this->host->get_IsSynchronized_6d887770284f3341();
    }
    
    System::Object* HashKeys::get_SyncRoot_2b118fba429beabc() {
        return this->host->get_SyncRoot_2d1e4aa44bab8a0d();
    }
    
}}
namespace System { namespace Collections {
    
    
    void HashValues::constructor(Hashtable* host) {
        if((host ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>();
        }
        this->host = host;
    }
    
    void HashValues::CopyTo_3dedcd2541c30c5b(System::Array* array, int32_t arrayIndex) {
        if((array ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("array"));
        }
        if((array->get_Rank() != 1)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("array"));
        }
        if((arrayIndex < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("arrayIndex"));
        }
        if(((array->get_Length() - arrayIndex) < this->get_Count_7bc0b9b088d0f437())) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("not enough space"));
        }
        this->host->CopyToArray(array, arrayIndex, EnumeratorMode::VALUE_MODE);
    }
    
    IEnumerator* HashValues::GetEnumerator_76e01e69f9d79a21() {
        return cli::gcnew<Enumerator>(this->host, EnumeratorMode::VALUE_MODE);
    }
    
    int32_t HashValues::get_Count_7bc0b9b088d0f437() {
        return this->host->get_Count_40aff81471a60b4c();
    }
    
    bool HashValues::get_IsSynchronized_124b5400ee4ed680() {
        return this->host->get_IsSynchronized_6d887770284f3341();
    }
    
    System::Object* HashValues::get_SyncRoot_aa8e50be6f68d1c8() {
        return this->host->get_SyncRoot_2d1e4aa44bab8a0d();
    }
    
}}
namespace System { namespace Collections {
    
    
    void SyncHashtable::constructor(Hashtable* host) {
        if((host ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>();
        }
        this->host = host;
    }
    
    void SyncHashtable::constructor(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        this->host = cli::cast<Hashtable*>(info->GetValue(_T("ParentTable"), cli::typeof<System::Type>::info));
    }
    
    void SyncHashtable::GetObjectData_f5c8af3d5979ea57(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        info->AddValue16(_T("ParentTable"), this->host);
    }
    
    IEnumerator* SyncHashtable::GetEnumerator3() {
        return cli::gcnew<Enumerator>(this->host, EnumeratorMode::ENTRY_MODE);
    }
    
    void SyncHashtable::CopyTo_2ceaf225ee09f8a(System::Array* array, int32_t arrayIndex) {
        this->host->CopyTo_2ceaf225ee09f8a(array, arrayIndex);
    }
    
    void SyncHashtable::Add_3f7ab157bcb41156(System::Object* key, System::Object* value) {
        {
            cli::lock_guard{this->host->get_SyncRoot_2d1e4aa44bab8a0d()};
            this->host->Add_3f7ab157bcb41156(key, value);
        }
    }
    
    void SyncHashtable::Clear_f1f405c8fa63a059() {
        {
            cli::lock_guard{this->host->get_SyncRoot_2d1e4aa44bab8a0d()};
            this->host->Clear_f1f405c8fa63a059();
        }
    }
    
    bool SyncHashtable::Contains_be7d0f2741618cb4(System::Object* key) {
        return (this->host->Find(key) >= 0);
    }
    
    IDictionaryEnumerator* SyncHashtable::GetEnumerator_47df71de9b680069() {
        return cli::gcnew<Enumerator>(this->host, EnumeratorMode::ENTRY_MODE);
    }
    
    void SyncHashtable::Remove_fd653674dd8a5ac4(System::Object* key) {
        {
            cli::lock_guard{this->host->get_SyncRoot_2d1e4aa44bab8a0d()};
            this->host->Remove_fd653674dd8a5ac4(key);
        }
    }
    
    bool SyncHashtable::ContainsKey_5de2e202a0290d76(System::Object* key) {
        return this->host->Contains_be7d0f2741618cb4(key);
    }
    
    bool SyncHashtable::ContainsValue_c2c435f6458aea98(System::Object* value) {
        return this->host->ContainsValue_c2c435f6458aea98(value);
    }
    
    System::Object* SyncHashtable::Clone_7f5df2dba23978b() {
        {
            cli::lock_guard{this->host->get_SyncRoot_2d1e4aa44bab8a0d()};
            return cli::gcnew<SyncHashtable>(cli::cast<Hashtable*>(this->host->Clone_7f5df2dba23978b()));
        }
    }
    
    int32_t SyncHashtable::get_Count_40aff81471a60b4c() {
        return this->host->get_Count_40aff81471a60b4c();
    }
    
    bool SyncHashtable::get_IsSynchronized_6d887770284f3341() {
        return true;
    }
    
    System::Object* SyncHashtable::get_SyncRoot_2d1e4aa44bab8a0d() {
        return this->host->get_SyncRoot_2d1e4aa44bab8a0d();
    }
    
    bool SyncHashtable::get_IsFixedSize_984422caf0fb996a() {
        return this->host->get_IsFixedSize_984422caf0fb996a();
    }
    
    bool SyncHashtable::get_IsReadOnly_4faf7104d0e98623() {
        return this->host->get_IsReadOnly_4faf7104d0e98623();
    }
    
    ICollection* SyncHashtable::get_Keys_8171dfd94447fa93() {
        ICollection *keys = nullptr;
        {
            cli::lock_guard{this->host->get_SyncRoot_2d1e4aa44bab8a0d()};
            keys = this->host->get_Keys_8171dfd94447fa93();
        }
        return keys;
    }
    
    ICollection* SyncHashtable::get_Values_4ed88b5f6e59ef25() {
        ICollection *vals = nullptr;
        {
            cli::lock_guard{this->host->get_SyncRoot_2d1e4aa44bab8a0d()};
            vals = this->host->get_Values_4ed88b5f6e59ef25();
        }
        return vals;
    }
    
    System::Object* SyncHashtable::get_Item_d75c6e706b965758(System::Object* key) {
        return this->host->get_Item_d75c6e706b965758(key);
    }
    
    System::Object* SyncHashtable::set_Item_84c7e24d9caa09(System::Object* key, System::Object* value) {
        {
            cli::lock_guard{this->host->get_SyncRoot_2d1e4aa44bab8a0d()};
            this->host->set_Item_84c7e24d9caa09(key, value);
        }
        return get_Item_d75c6e706b965758(key);
    }
    
}}
namespace System { namespace Collections {
    
    cli::array<int32_t>*  Hashtable::primeTbl;
    
    Hashtable::Hashtable()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void Hashtable::constructor() {
    }
    
    void Hashtable::constructor(int32_t capacity, float loadFactor, IHashCodeProvider* hcp, IComparer* comparer) {
        if((capacity < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("capacity"), _T("negative capacity"));
        }
        if((((loadFactor < 0.1f) || (loadFactor > 1.f)) || System::Single::IsNaN(loadFactor))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("loadFactor"), _T("load factor"));
        }
        if((capacity ==  0)) 
        {
            ++capacity;
        }
        this->loadFactor = (0.75f * loadFactor);
        double tableSize = (double)(((float)(capacity) / this->loadFactor));
        if((tableSize > 2147483647.)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Size is too big"));
        }
        int32_t size = (int32_t)tableSize;
        size = ToPrime(size);
        this->SetTable((new cli::array<Slot>(size)), (new cli::array<int32_t>(size)));
        this->set_hcp(hcp);
        this->set_comparer(comparer);
        this->inUse = 0;
        this->modificationCount = 0;
    }
    
    void Hashtable::constructor(int32_t capacity, float loadFactor) {
    }
    
    void Hashtable::constructor(int32_t capacity) {
    }
    
    void Hashtable::constructor(Hashtable* source) {
        this->inUse = source->inUse;
        this->loadFactor = source->loadFactor;
        this->table = cli::cast<cli::array<Slot>*>(cli::import(source->table)->Clone());
        this->hashes = cli::cast<cli::array<int32_t>*>(cli::import(source->hashes)->Clone());
        this->threshold = source->threshold;
        this->hcpRef = source->hcpRef;
        this->comparerRef = source->comparerRef;
        this->equalityComparer = source->equalityComparer;
    }
    
    void Hashtable::constructor(int32_t capacity, IHashCodeProvider* hcp, IComparer* comparer) {
    }
    
    void Hashtable::constructor(IDictionary* d, float loadFactor, IHashCodeProvider* hcp, IComparer* comparer) {
        if((d ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("dictionary"));
        }
        IDictionaryEnumerator *it = d->GetEnumerator_40657fcb15842551();
        while(it->MoveNext_4e78e145935f5417()) {
            Add_3f7ab157bcb41156(it->get_Key_ed7954531cb20258(), it->get_Value_889e0f410f0d67ef());
        }
    }
    
    void Hashtable::constructor(IDictionary* d, float loadFactor) {
    }
    
    void Hashtable::constructor(IDictionary* d) {
    }
    
    void Hashtable::constructor(IDictionary* d, IHashCodeProvider* hcp, IComparer* comparer) {
    }
    
    void Hashtable::constructor(IHashCodeProvider* hcp, IComparer* comparer) {
    }
    
    void Hashtable::constructor(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        this->serializationInfo = info;
    }
    
    void Hashtable::constructor(IDictionary* d, IEqualityComparer* equalityComparer) {
    }
    
    void Hashtable::constructor(IDictionary* d, float loadFactor, IEqualityComparer* equalityComparer) {
        this->equalityComparer = equalityComparer;
    }
    
    void Hashtable::constructor(IEqualityComparer* equalityComparer) {
    }
    
    void Hashtable::constructor(int32_t capacity, IEqualityComparer* equalityComparer) {
    }
    
    void Hashtable::constructor(int32_t capacity, float loadFactor, IEqualityComparer* equalityComparer) {
        this->equalityComparer = equalityComparer;
    }
    
    void Hashtable::static_constructor() {
    }
    
    IEnumerator* Hashtable::GetEnumerator() {
        return cli::gcnew<Enumerator>(this, EnumeratorMode::ENTRY_MODE);
    }
    
    void Hashtable::CopyTo_2ceaf225ee09f8a(System::Array* array, int32_t arrayIndex) {
        if((array ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("array"));
        }
        if((arrayIndex < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("arrayIndex"));
        }
        if((array->get_Rank() > 1)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("array is multidimensional"));
        }
        if(((array->get_Length() > 0) && (arrayIndex >= array->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("arrayIndex is equal to or greater than array.Length"));
        }
        if(((arrayIndex + this->inUse) > array->get_Length())) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Not enough room from arrayIndex to end of array for this Hashtable"));
        }
        IDictionaryEnumerator *it = GetEnumerator_47df71de9b680069();
        int32_t i = arrayIndex;
        while(it->MoveNext_4e78e145935f5417()) {
            array->SetValue5(cli::box(it->get_Entry_7d036eca1ef8d5f4()), i++);
        }
    }
    
    void Hashtable::Add_3f7ab157bcb41156(System::Object* key, System::Object* value) {
        PutImpl(key, value, false);
    }
    
    void Hashtable::Clear_f1f405c8fa63a059() {
        for(int32_t i = 0; (i < this->table->get_Length()); i++){
            this->table->at(i)->key = nullptr;
            this->table->at(i)->value = nullptr;
            this->hashes->at(i) = 0;
        }
        this->inUse = 0;
        this->modificationCount++;
    }
    
    bool Hashtable::Contains_be7d0f2741618cb4(System::Object* key) {
        return (Find(key) >= 0);
    }
    
    IDictionaryEnumerator* Hashtable::GetEnumerator_47df71de9b680069() {
        return cli::gcnew<Enumerator>(this, EnumeratorMode::ENTRY_MODE);
    }
    
    void Hashtable::Remove_fd653674dd8a5ac4(System::Object* key) {
        int32_t i = Find(key);
        if((i >= 0)) 
        {
            cli::array<Slot> *table = this->table;
            int32_t h = this->hashes->at(i);
            (h = h & -2147483648);
            this->hashes->at(i) = h;
            table->at(i)->key = (h != 0) ? KeyMarker::Removed : nullptr;
            table->at(i)->value = nullptr;
            --this->inUse;
            ++this->modificationCount;
        }
    }
    
    bool Hashtable::ContainsKey_5de2e202a0290d76(System::Object* key) {
        return Contains_be7d0f2741618cb4(key);
    }
    
    bool Hashtable::ContainsValue_c2c435f6458aea98(System::Object* value) {
        int32_t size = this->table->get_Length();
        cli::array<Slot> *table = this->table;
        if((value ==  nullptr)) 
        {
            for(int32_t i = 0; (i < size); i++){
                Slot entry = table->at(i);
                if((((entry->key != nullptr) && (entry->key != KeyMarker::Removed)) && (entry->value ==  nullptr))) 
                {
                    return true;
                }
            }
        }
         else 
        {
            for(int32_t i = 0; (i < size); i++){
                Slot entry = table->at(i);
                if((((entry->key != nullptr) && (entry->key != KeyMarker::Removed)) && value->Equals_ed975d2f4a7d193e(entry->value))) 
                {
                    return true;
                }
            }
        }
        return false;
    }
    
    System::Object* Hashtable::Clone_7f5df2dba23978b() {
        return cli::gcnew<Hashtable>(this);
    }
    
    void Hashtable::GetObjectData_f5c8af3d5979ea57(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        if((info ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("info"));
        }
        info->AddValue12(_T("LoadFactor"), this->loadFactor);
        info->AddValue4(_T("Version"), this->modificationCount);
        if((this->equalityComparer != nullptr)) 
        {
            info->AddValue16(_T("KeyComparer"), this->equalityComparer);
        }
         else 
        {
            info->AddValue16(_T("Comparer"), this->comparerRef);
        }
        if((this->hcpRef != nullptr)) 
        {
            info->AddValue16(_T("HashCodeProvider"), this->hcpRef);
        }
        info->AddValue4(_T("HashSize"), this->table->get_Length());
        cli::array<System::Object*> *keys = (new cli::array<System::Object*>(this->inUse));
        CopyToArray(keys, 0, EnumeratorMode::KEY_MODE);
        cli::array<System::Object*> *values = (new cli::array<System::Object*>(this->inUse));
        CopyToArray(values, 0, EnumeratorMode::VALUE_MODE);
        info->AddValue16(_T("Keys"), keys);
        info->AddValue16(_T("Values"), values);
        info->AddValue16(_T("equalityComparer"), this->equalityComparer);
    }
    
    void Hashtable::OnDeserialization_868d234d4d762260(System::Object* sender) {
        if((this->serializationInfo ==  nullptr)) 
        {
            return;
        }
        this->loadFactor = cli::unbox<float>(this->serializationInfo->GetValue(_T("LoadFactor"), cli::typeof<System::Type>::info));
        this->modificationCount = cli::unbox<int32_t>(this->serializationInfo->GetValue(_T("Version"), cli::typeof<System::Type>::info));
        try {
            this->equalityComparer = cli::cast<IEqualityComparer*>(this->serializationInfo->GetValue(_T("KeyComparer"), cli::typeof<System::Type>::info));
        }
        catch(...) {
        }
        if((this->equalityComparer ==  nullptr)) 
        {
            this->comparerRef = cli::cast<IComparer*>(this->serializationInfo->GetValue(_T("Comparer"), cli::typeof<System::Type>::info));
        }
        try {
            this->hcpRef = cli::cast<IHashCodeProvider*>(this->serializationInfo->GetValue(_T("HashCodeProvider"), cli::typeof<System::Type>::info));
        }
        catch(...) {
        }
        int32_t size = cli::unbox<int32_t>(this->serializationInfo->GetValue(_T("HashSize"), cli::typeof<System::Type>::info));
        cli::array<System::Object*> *keys = cli::cast<cli::array<System::Object*>*>(this->serializationInfo->GetValue(_T("Keys"), cli::typeof<System::Type>::info));
        cli::array<System::Object*> *values = cli::cast<cli::array<System::Object*>*>(this->serializationInfo->GetValue(_T("Values"), cli::typeof<System::Type>::info));
        if((keys->get_Length() != values->get_Length())) 
        {
            throw cli::gcnew<System::Runtime::Serialization::SerializationException>(_T("Keys and values of uneven size"));
        }
        size = ToPrime(size);
        this->SetTable((new cli::array<Slot>(size)), (new cli::array<int32_t>(size)));
        for(int32_t i = 0; (i < keys->get_Length()); i++) {
            Add_3f7ab157bcb41156(keys->at(i), values->at(i));
        }
        AdjustThreshold();
        this->serializationInfo = nullptr;
    }
    
    Hashtable* Hashtable::Synchronized(Hashtable* table) {
        if((table ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("table"));
        }
        return cli::gcnew<SyncHashtable>(table);
    }
    
    int32_t Hashtable::GetHash_6b53c6911c980a14(System::Object* key) {
        if((this->equalityComparer != nullptr)) 
        {
            return this->equalityComparer->GetHashCode_f8793dfb2b096a5a(key);
        }
        if((this->hcpRef ==  nullptr)) 
        {
            return key->GetHashCode_6648aef0f235ee6c();
        }
        return this->hcpRef->GetHashCode_5d8a358493971efd(key);
    }
    
    bool Hashtable::KeyEquals_c2b05002bc8dc204(System::Object* item, System::Object* key) {
        if((key ==  KeyMarker::Removed)) 
        {
            return false;
        }
        if((this->equalityComparer != nullptr)) 
        {
            return this->equalityComparer->Equals_ad190887ea91ded(item, key);
        }
        if((this->comparerRef ==  nullptr)) 
        {
            return item->Equals_ed975d2f4a7d193e(key);
        }
        return (this->comparerRef->Compare_451fd276747b629d(item, key) ==  0);
    }
    
    void Hashtable::AdjustThreshold() {
        int32_t size = this->table->get_Length();
        this->threshold = (int32_t)((float)(size) * this->loadFactor);
        if((this->threshold >= size)) 
        {
            this->threshold = (size - 1);
        }
    }
    
    void Hashtable::SetTable(cli::array<Slot>* table, cli::array<int32_t>* hashes) {
        if((table ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("table"));
        }
        this->table = table;
        this->hashes = hashes;
        AdjustThreshold();
    }
    
    int32_t Hashtable::Find(System::Object* key) {
        if((key ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("key"), _T("null key"));
        }
        cli::array<Slot> *table = this->table;
        cli::array<int32_t> *hashes = this->hashes;
        uint32_t size = (uint32_t)table->get_Length();
        int32_t h = (this->GetHash_6b53c6911c980a14(key) & 2147483647);
        uint32_t indx = (uint32_t)h;
        uint32_t step = (((uint32_t)((h >> 5) + 1) % (size - 1U)) + 1U);
        for(uint32_t i = size; (i > 0U); i--){
            (indx = indx % size);
            Slot entry = table->at((int32_t)indx);
            int32_t hashMix = hashes->at((int32_t)indx);
            System::Object *k = entry->key;
            if((k ==  nullptr)) 
            {
                break;
            }
            if(((k ==  key) || (((hashMix & 2147483647) ==  h) && this->KeyEquals_c2b05002bc8dc204(key, k)))) 
            {
                return (int32_t)indx;
            }
            if(((hashMix & -2147483648) ==  0)) 
            {
                break;
            }
            (indx = indx + step);
        }
        return -1;
    }
    
    void Hashtable::Rehash() {
        int32_t oldSize = this->table->get_Length();
        uint32_t newSize = (uint32_t)ToPrime(((oldSize << 1) | 1));
        cli::array<Slot> *newTable = (new cli::array<Slot>((int32_t)newSize));
        cli::array<Slot> *table = this->table;
        cli::array<int32_t> *newHashes = (new cli::array<int32_t>((int32_t)newSize));
        cli::array<int32_t> *hashes = this->hashes;
        for(int32_t i = 0; (i < oldSize); i++){
            Slot s = table->at(i);
            if((s->key != nullptr)) 
            {
                int32_t h = (hashes->at(i) & 2147483647);
                uint32_t spot = (uint32_t)h;
                uint32_t step = ((((uint32_t)(h >> 5) + 1U) % (newSize - 1U)) + 1U);
                for(uint32_t j = (spot % newSize); ; (spot = spot + step), j = (spot % newSize)){
                    if((newTable->at((int32_t)j)->key ==  nullptr)) 
                    {
                        newTable->at((int32_t)j)->key = s->key;
                        newTable->at((int32_t)j)->value = s->value;
                        (newHashes->at((int32_t)j) = newHashes->at((int32_t)j) | h);
                        break;
                    }
                     else 
                    {
                        (newHashes->at((int32_t)j) = newHashes->at((int32_t)j) | -2147483648);
                    }
                }
            }
        }
        ++this->modificationCount;
        this->SetTable(newTable, newHashes);
    }
    
    void Hashtable::PutImpl(System::Object* key, System::Object* value, bool overwrite) {
        if((key ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("key"), _T("null key"));
        }
        if((this->inUse >= this->threshold)) 
        {
            this->Rehash();
        }
        uint32_t size = (uint32_t)this->table->get_Length();
        int32_t h = (this->GetHash_6b53c6911c980a14(key) & 2147483647);
        uint32_t spot = (uint32_t)h;
        uint32_t step = (((uint32_t)(((spot >> 5) + 1U)) % (size - 1U)) + 1U);
        cli::array<Slot> *table = this->table;
        cli::array<int32_t> *hashes = this->hashes;
        Slot entry;
        int32_t freeIndx = -1;
        for(int32_t i = 0; ((int64_t)(i) < (int64_t)(size)); i++){
            int32_t indx = (int32_t)(spot % size);
            entry = table->at(indx);
            int32_t hashMix = hashes->at(indx);
            if((((freeIndx ==  -1) && (entry->key ==  KeyMarker::Removed)) && ((hashMix & -2147483648) != 0))) 
            {
                freeIndx = indx;
            }
            if(((entry->key ==  nullptr) || ((entry->key ==  KeyMarker::Removed) && ((hashMix & -2147483648) ==  0)))) 
            {
                if((freeIndx ==  -1)) 
                {
                    freeIndx = indx;
                }
                break;
            }
            if((((hashMix & 2147483647) ==  h) && KeyEquals_c2b05002bc8dc204(key, entry->key))) 
            {
                if(overwrite) 
                {
                    table->at(indx)->value = value;
                    ++this->modificationCount;
                }
                 else 
                {
                    throw cli::gcnew<System::ArgumentException>(cli::concat(_T("Key duplication when adding: "), key));
                }
                return;
            }
            if((freeIndx ==  -1)) 
            {
                (hashes->at(indx) = hashes->at(indx) | -2147483648);
            }
            (spot = spot + step);
        }
        if((freeIndx != -1)) 
        {
            table->at(freeIndx)->key = key;
            table->at(freeIndx)->value = value;
            (hashes->at(freeIndx) = hashes->at(freeIndx) | h);
            ++this->inUse;
            ++this->modificationCount;
        }
    }
    
    void Hashtable::CopyToArray(System::Array* arr, int32_t i, EnumeratorMode mode) {
        IEnumerator *it = cli::gcnew<Enumerator>(this, mode);
        while(it->MoveNext_4e78e145935f5417()) {
            arr->SetValue5(it->get_Current_8eca9b3da02b123a(), i++);
        }
    }
    
    bool Hashtable::TestPrime(int32_t x) {
        if(((x & 1) != 0)) 
        {
            int32_t top = (int32_t)System::Math::Sqrt((double)(x));
            for(int32_t n = 3; (n < top); (n = n + 2)){
                if(((x % n) ==  0)) 
                {
                    return false;
                }
            }
            return true;
        }
        return (x ==  2);
    }
    
    int32_t Hashtable::CalcPrime(int32_t x) {
        for(int32_t i = ((x & -2) - 1); (i < 2147483647); (i = i + 2)){
            if(TestPrime(i)) 
            {
                return i;
            }
        }
        return x;
    }
    
    int32_t Hashtable::ToPrime(int32_t x) {
        for(int32_t i = 0; (i < primeTbl->get_Length()); i++){
            if((x <= primeTbl->at(i))) 
            {
                return primeTbl->at(i);
            }
        }
        return CalcPrime(x);
    }
    
    IComparer* Hashtable::get_comparer() {
        return this->comparerRef;
    }
    
    IComparer* Hashtable::set_comparer(IComparer* value) {
        this->comparerRef = value;
        return get_comparer();
    }
    
    IHashCodeProvider* Hashtable::get_hcp() {
        return this->hcpRef;
    }
    
    IHashCodeProvider* Hashtable::set_hcp(IHashCodeProvider* value) {
        this->hcpRef = value;
        return get_hcp();
    }
    
    IEqualityComparer* Hashtable::get_EqualityComparer() {
        return this->equalityComparer;
    }
    
    int32_t Hashtable::get_Count_40aff81471a60b4c() {
        return this->inUse;
    }
    
    bool Hashtable::get_IsSynchronized_6d887770284f3341() {
        return false;
    }
    
    System::Object* Hashtable::get_SyncRoot_2d1e4aa44bab8a0d() {
        return this;
    }
    
    bool Hashtable::get_IsFixedSize_984422caf0fb996a() {
        return false;
    }
    
    bool Hashtable::get_IsReadOnly_4faf7104d0e98623() {
        return false;
    }
    
    ICollection* Hashtable::get_Keys_8171dfd94447fa93() {
        if((this->hashKeys ==  nullptr)) 
        {
            this->hashKeys = cli::gcnew<HashKeys>(this);
        }
        return this->hashKeys;
    }
    
    ICollection* Hashtable::get_Values_4ed88b5f6e59ef25() {
        if((this->hashValues ==  nullptr)) 
        {
            this->hashValues = cli::gcnew<HashValues>(this);
        }
        return this->hashValues;
    }
    
    System::Object* Hashtable::get_Item_d75c6e706b965758(System::Object* key) {
        if((key ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("key"), _T("null key"));
        }
        cli::array<Slot> *table = this->table;
        cli::array<int32_t> *hashes = this->hashes;
        uint32_t size = (uint32_t)table->get_Length();
        int32_t h = (this->GetHash_6b53c6911c980a14(key) & 2147483647);
        uint32_t indx = (uint32_t)h;
        uint32_t step = (((uint32_t)((h >> 5) + 1) % (size - 1U)) + 1U);
        for(uint32_t i = size; (i > 0U); i--){
            (indx = indx % size);
            Slot entry = table->at((int32_t)indx);
            int32_t hashMix = hashes->at((int32_t)indx);
            System::Object *k = entry->key;
            if((k ==  nullptr)) 
            {
                break;
            }
            if(((k ==  key) || (((hashMix & 2147483647) ==  h) && this->KeyEquals_c2b05002bc8dc204(key, k)))) 
            {
                return entry->value;
            }
            if(((hashMix & -2147483648) ==  0)) 
            {
                break;
            }
            (indx = indx + step);
        }
        return nullptr;
    }
    
    System::Object* Hashtable::set_Item_84c7e24d9caa09(System::Object* key, System::Object* value) {
        PutImpl(key, value, true);
        return get_Item_d75c6e706b965758(key);
    }
    
}}
namespace System { namespace Collections {
    
    
    void SyncQueue::constructor(Queue* queue) {
        this->queue = queue;
    }
    
    void SyncQueue::CopyTo_a242f31c9e5a44f6(System::Array* array, int32_t index) {
        {
            cli::lock_guard{this->queue};
            this->queue->CopyTo_a242f31c9e5a44f6(array, index);
        }
    }
    
    IEnumerator* SyncQueue::GetEnumerator_9c4544dfc8024fc3() {
        {
            cli::lock_guard{this->queue};
            return this->queue->GetEnumerator_9c4544dfc8024fc3();
        }
    }
    
    System::Object* SyncQueue::Clone_bcf06e67c65a40c7() {
        {
            cli::lock_guard{this->queue};
            return cli::gcnew<SyncQueue>(cli::cast<Queue*>(this->queue->Clone_bcf06e67c65a40c7()));
        }
    }
    
    void SyncQueue::Clear_861e11dd27e6c911() {
        {
            cli::lock_guard{this->queue};
            this->queue->Clear_861e11dd27e6c911();
        }
    }
    
    void SyncQueue::TrimToSize_ba0f5f9778fb48a6() {
        {
            cli::lock_guard{this->queue};
            this->queue->TrimToSize_ba0f5f9778fb48a6();
        }
    }
    
    bool SyncQueue::Contains_26022acb06595f32(System::Object* obj) {
        {
            cli::lock_guard{this->queue};
            return this->queue->Contains_26022acb06595f32(obj);
        }
    }
    
    System::Object* SyncQueue::Dequeue_65b33648b3aa820f() {
        {
            cli::lock_guard{this->queue};
            return this->queue->Dequeue_65b33648b3aa820f();
        }
    }
    
    void SyncQueue::Enqueue_7ab7b5c658b77bbe(System::Object* obj) {
        {
            cli::lock_guard{this->queue};
            this->queue->Enqueue_7ab7b5c658b77bbe(obj);
        }
    }
    
    System::Object* SyncQueue::Peek_8319b8ebd54b1ede() {
        {
            cli::lock_guard{this->queue};
            return this->queue->Peek_8319b8ebd54b1ede();
        }
    }
    
    cli::array<System::Object*>* SyncQueue::ToArray_ccb213d63131bb6c() {
        {
            cli::lock_guard{this->queue};
            return this->queue->ToArray_ccb213d63131bb6c();
        }
    }
    
    int32_t SyncQueue::get_Count_d68471db5ed73aae() {
        {
            cli::lock_guard{this->queue};
            return this->queue->get_Count_d68471db5ed73aae();
        }
    }
    
    bool SyncQueue::get_IsSynchronized_c60381663baf0d11() {
        return true;
    }
    
    System::Object* SyncQueue::get_SyncRoot_d7b361956ed7602e() {
        return this->queue->get_SyncRoot_d7b361956ed7602e();
    }
    
}}
namespace System { namespace Collections {
    
    
    void QueueEnumerator::constructor(Queue* q) {
        this->queue = q;
        this->_version = q->_version;
        this->current = -1;
    }
    
    System::Object* QueueEnumerator::Clone() {
        QueueEnumerator *q = cli::gcnew<QueueEnumerator>(this->queue);
        q->_version = this->_version;
        q->current = this->current;
        return q;
    }
    
    bool QueueEnumerator::MoveNext_e38147317beb6367() {
        if((this->_version != this->queue->_version)) 
        {
            throw cli::gcnew<System::InvalidOperationException>();
        }
        if((this->current >= (this->queue->_size - 1))) 
        {
            this->current = 2147483647;
            return false;
        }
         else 
        {
            this->current++;
            return true;
        }
    }
    
    void QueueEnumerator::Reset_f399ddbfb4a26238() {
        if((this->_version != this->queue->_version)) 
        {
            throw cli::gcnew<System::InvalidOperationException>();
        }
        this->current = -1;
    }
    
    System::Object* QueueEnumerator::get_Current_dfd4e333254568bd() {
        if((((this->_version != this->queue->_version) || (this->current < 0)) || (this->current >= this->queue->_size))) 
        {
            throw cli::gcnew<System::InvalidOperationException>();
        }
        return this->queue->_array->at(((this->queue->_head + this->current) % this->queue->_array->get_Length()));
    }
    
}}
namespace System { namespace Collections {
    
    
    void Queue::constructor() {
    }
    
    void Queue::constructor(int32_t capacity) {
    }
    
    void Queue::constructor(ICollection* col) {
        if((col ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("col"));
        }
        for(auto tmp_207 : col) {
            auto o = cli::cast<System::Object*>(tmp_207);
            Enqueue_7ab7b5c658b77bbe(o);
        }
    }
    
    void Queue::constructor(int32_t capacity, float growFactor) {
        if((capacity < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("capacity"), _T("Needs a non-negative number"));
        }
        if(!(((growFactor >= 1.f) && (growFactor <= 10.f)))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("growFactor"), _T("Queue growth factor must be between 1.0 and 10.0, inclusive"));
        }
        this->_array = (new cli::array<System::Object*>(capacity));
        this->_growFactor = (int32_t)(growFactor * 100.f);
    }
    
    void Queue::CopyTo_a242f31c9e5a44f6(System::Array* array, int32_t index) {
        if((array ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("array"));
        }
        if((index < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("index"));
        }
        if((((array->get_Rank() > 1) || ((index != 0) && (index >= array->get_Length()))) || (this->_size > (array->get_Length() - index)))) 
        {
            throw cli::gcnew<System::ArgumentException>();
        }
        int32_t contents_length = this->_array->get_Length();
        int32_t length_from_head = (contents_length - this->_head);
        System::Array::Copy2(this->_array, this->_head, array, index, System::Math::Min5(this->_size, length_from_head));
        if((this->_size > length_from_head)) 
        {
            System::Array::Copy2(this->_array, 0, array, (index + length_from_head), (this->_size - length_from_head));
        }
    }
    
    IEnumerator* Queue::GetEnumerator_9c4544dfc8024fc3() {
        return cli::gcnew<QueueEnumerator>(this);
    }
    
    System::Object* Queue::Clone_bcf06e67c65a40c7() {
        Queue *newQueue;
        newQueue = cli::gcnew<Queue>(this->_array->get_Length());
        newQueue->_growFactor = this->_growFactor;
        System::Array::Copy2(this->_array, 0, newQueue->_array, 0, this->_array->get_Length());
        newQueue->_head = this->_head;
        newQueue->_size = this->_size;
        newQueue->_tail = this->_tail;
        return newQueue;
    }
    
    void Queue::Clear_861e11dd27e6c911() {
        this->_version++;
        this->_head = 0;
        this->_size = 0;
        this->_tail = 0;
        for(int32_t length = (this->_array->get_Length() - 1); (length >= 0); length--) {
            this->_array->at(length) = nullptr;
        }
    }
    
    bool Queue::Contains_26022acb06595f32(System::Object* obj) {
        int32_t tail = (this->_head + this->_size);
        if((obj ==  nullptr)) 
        {
            for(int32_t i = this->_head; (i < tail); i++){
                if((this->_array->at((i % this->_array->get_Length())) ==  nullptr)) 
                {
                    return true;
                }
            }
        }
         else 
        {
            for(int32_t i = this->_head; (i < tail); i++){
                if(obj->Equals_ed975d2f4a7d193e(this->_array->at((i % this->_array->get_Length())))) 
                {
                    return true;
                }
            }
        }
        return false;
    }
    
    System::Object* Queue::Dequeue_65b33648b3aa820f() {
        this->_version++;
        if((this->_size < 1)) 
        {
            throw cli::gcnew<System::InvalidOperationException>();
        }
        System::Object *result = this->_array->at(this->_head);
        this->_array->at(this->_head) = nullptr;
        this->_head = ((this->_head + 1) % this->_array->get_Length());
        this->_size--;
        return result;
    }
    
    void Queue::Enqueue_7ab7b5c658b77bbe(System::Object* obj) {
        this->_version++;
        if((this->_size ==  this->_array->get_Length())) 
        {
            grow();
        }
        this->_array->at(this->_tail) = obj;
        this->_tail = ((this->_tail + 1) % this->_array->get_Length());
        this->_size++;
    }
    
    System::Object* Queue::Peek_8319b8ebd54b1ede() {
        if((this->_size < 1)) 
        {
            throw cli::gcnew<System::InvalidOperationException>();
        }
        return this->_array->at(this->_head);
    }
    
    Queue* Queue::Synchronized(Queue* queue) {
        if((queue ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("queue"));
        }
        return cli::gcnew<SyncQueue>(queue);
    }
    
    cli::array<System::Object*>* Queue::ToArray_ccb213d63131bb6c() {
        cli::array<System::Object*> *ret = (new cli::array<System::Object*>(this->_size));
        CopyTo_a242f31c9e5a44f6(ret, 0);
        return ret;
    }
    
    void Queue::TrimToSize_ba0f5f9778fb48a6() {
        this->_version++;
        cli::array<System::Object*> *trimmed = (new cli::array<System::Object*>(this->_size));
        CopyTo_a242f31c9e5a44f6(trimmed, 0);
        this->_array = trimmed;
        this->_head = 0;
        this->_tail = 0;
    }
    
    void Queue::grow() {
        int32_t newCapacity = ((this->_array->get_Length() * this->_growFactor) / 100);
        if((newCapacity < (this->_array->get_Length() + 1))) 
        {
            newCapacity = (this->_array->get_Length() + 1);
        }
        cli::array<System::Object*> *newContents = (new cli::array<System::Object*>(newCapacity));
        CopyTo_a242f31c9e5a44f6(newContents, 0);
        this->_array = newContents;
        this->_head = 0;
        this->_tail = (this->_head + this->_size);
    }
    
    int32_t Queue::get_Count_d68471db5ed73aae() {
        return this->_size;
    }
    
    bool Queue::get_IsSynchronized_c60381663baf0d11() {
        return false;
    }
    
    System::Object* Queue::get_SyncRoot_d7b361956ed7602e() {
        return this;
    }
    
}}
namespace System { namespace Collections {
    
    
    void ReadOnlyCollectionBase::constructor() {
        this->list = cli::gcnew<ArrayList>();
    }
    
    IEnumerator* ReadOnlyCollectionBase::GetEnumerator_92182c889cb5e81d() {
        return this->get_InnerList()->GetEnumerator_84e3ba8f2fdefd62();
    }
    
    IEnumerator* ReadOnlyCollectionBase::GetEnumerator2() {
        return GetEnumerator_92182c889cb5e81d();
    }
    
    void ReadOnlyCollectionBase::CopyTo(System::Array* array, int32_t index) {
        {
            cli::lock_guard{this->get_InnerList()};
            this->get_InnerList()->CopyTo_2bc540dad3c25b9e(array, index);
        }
    }
    
    int32_t ReadOnlyCollectionBase::get_Count_d1f8482d32e8ef54() {
        return this->get_InnerList()->get_Count_2354963792616712();
    }
    
    ArrayList* ReadOnlyCollectionBase::get_InnerList() {
        return this->list;
    }
    
    System::Object* ReadOnlyCollectionBase::get_SyncRoot() {
        return this->get_InnerList()->get_SyncRoot_edb1ba826807b569();
    }
    
    bool ReadOnlyCollectionBase::get_IsSynchronized() {
        return this->get_InnerList()->get_IsSynchronized_ffa26be0a148c3c0();
    }
    
}}
namespace System { namespace Collections {
    
    System::String*  Enumerator2::xstr;
    
    Enumerator2::Enumerator2()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void Enumerator2::constructor(SortedList* host, EnumeratorMode2 mode) {
        this->host = host;
        this->stamp = host->modificationCount;
        this->size = host->get_Count_78ce60b82e5a007();
        this->mode = mode;
        Reset();
    }
    
    void Enumerator2::constructor(SortedList* host) {
    }
    
    void Enumerator2::static_constructor() {
    }
    
    void Enumerator2::Reset() {
        if(((this->host->modificationCount != this->stamp) || this->invalid)) 
        {
            throw cli::gcnew<System::InvalidOperationException>(xstr);
        }
        this->pos = -1;
        this->currentKey = nullptr;
        this->currentValue = nullptr;
    }
    
    bool Enumerator2::MoveNext() {
        if(((this->host->modificationCount != this->stamp) || this->invalid)) 
        {
            throw cli::gcnew<System::InvalidOperationException>(xstr);
        }
        cli::array<Slot2> *table = this->host->table;
        if((++this->pos < this->size)) 
        {
            Slot2 entry = table->at(this->pos);
            this->currentKey = entry->key;
            this->currentValue = entry->value;
            return true;
        }
        this->currentKey = nullptr;
        this->currentValue = nullptr;
        return false;
    }
    
    System::Object* Enumerator2::Clone() {
        Enumerator2 *e = cli::gcnew<Enumerator2>(this->host, this->mode);
        e->stamp = this->stamp;
        e->pos = this->pos;
        e->size = this->size;
        e->currentKey = this->currentKey;
        e->currentValue = this->currentValue;
        e->invalid = this->invalid;
        return e;
    }
    
    DictionaryEntry Enumerator2::get_Entry() {
        if(((this->invalid || (this->pos >= this->size)) || (this->pos ==  -1))) 
        {
            throw cli::gcnew<System::InvalidOperationException>(xstr);
        }
        return cli::ctor<DictionaryEntry>(this->currentKey, this->currentValue);
    }
    
    System::Object* Enumerator2::get_Key() {
        if(((this->invalid || (this->pos >= this->size)) || (this->pos ==  -1))) 
        {
            throw cli::gcnew<System::InvalidOperationException>(xstr);
        }
        return this->currentKey;
    }
    
    System::Object* Enumerator2::get_Value() {
        if(((this->invalid || (this->pos >= this->size)) || (this->pos ==  -1))) 
        {
            throw cli::gcnew<System::InvalidOperationException>(xstr);
        }
        return this->currentValue;
    }
    
    System::Object* Enumerator2::get_Current() {
        if(((this->invalid || (this->pos >= this->size)) || (this->pos ==  -1))) 
        {
            throw cli::gcnew<System::InvalidOperationException>(xstr);
        }
        switch(this->mode) {
            case EnumeratorMode2::KEY_MODE: case_952: {
                return this->currentKey;
            }
            case EnumeratorMode2::VALUE_MODE: case_953: {
                return this->currentValue;
            }
            case EnumeratorMode2::ENTRY_MODE: case_954: {
                return cli::box(this->get_Entry());
            }
            default: case_955: {
                throw cli::gcnew<System::NotSupportedException>(cli::concat(cli::box(this->mode), _T(" is not a supported mode.")));
            }
        }
    }
    
}}
namespace System { namespace Collections {
    
    
    void ListKeys::constructor(SortedList* host) {
        if((host ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>();
        }
        this->host = host;
    }
    
    void ListKeys::CopyTo_ab674e4725a04dd5(System::Array* array, int32_t arrayIndex) {
        this->host->CopyToArray(array, arrayIndex, EnumeratorMode2::KEY_MODE);
    }
    
    int32_t ListKeys::Add_c75566abdfd3f1dc(System::Object* value) {
        throw cli::gcnew<System::NotSupportedException>(_T("IList::Add not supported"));
    }
    
    void ListKeys::Clear_de8b60e6daa645fa() {
        throw cli::gcnew<System::NotSupportedException>(_T("IList::Clear not supported"));
    }
    
    bool ListKeys::Contains_a17f9f0078013e59(System::Object* key) {
        return this->host->Contains_34d44683dd1aa8bd(key);
    }
    
    int32_t ListKeys::IndexOf_1478511550cde2ad(System::Object* key) {
        return this->host->IndexOfKey_81491507d0744836(key);
    }
    
    void ListKeys::Insert_1f210e681eab810a(int32_t index, System::Object* value) {
        throw cli::gcnew<System::NotSupportedException>(_T("IList::Insert not supported"));
    }
    
    void ListKeys::Remove_96c7b29ece8e3105(System::Object* value) {
        throw cli::gcnew<System::NotSupportedException>(_T("IList::Remove not supported"));
    }
    
    void ListKeys::RemoveAt_acef67f8944a5305(int32_t index) {
        throw cli::gcnew<System::NotSupportedException>(_T("IList::RemoveAt not supported"));
    }
    
    IEnumerator* ListKeys::GetEnumerator_cfd57c074767b6cf() {
        return cli::gcnew<Enumerator2>(this->host, EnumeratorMode2::KEY_MODE);
    }
    
    int32_t ListKeys::get_Count_8dbd9d9efdb630c7() {
        return this->host->get_Count_78ce60b82e5a007();
    }
    
    bool ListKeys::get_IsSynchronized_30c043785c3848e1() {
        return this->host->get_IsSynchronized_766878a892ebabf4();
    }
    
    System::Object* ListKeys::get_SyncRoot_d7cb07b3d3ac34f9() {
        return this->host->get_SyncRoot_d4fc4c9fde3847f6();
    }
    
    bool ListKeys::get_IsFixedSize_de999dd589b62794() {
        return true;
    }
    
    bool ListKeys::get_IsReadOnly_ef714023f662889b() {
        return true;
    }
    
    System::Object* ListKeys::get_Item_9b384f79b2a8f442(int32_t index) {
        return this->host->GetKey_bd6d1bec1a5b310c(index);
    }
    
    System::Object* ListKeys::set_Item_766478b9723d0685(int32_t index, System::Object* value) {
        throw cli::gcnew<System::NotSupportedException>(_T("attempt to modify a key"));
        return get_Item_9b384f79b2a8f442(index);
    }
    
}}
namespace System { namespace Collections {
    
    
    void ListValues::constructor(SortedList* host) {
        if((host ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>();
        }
        this->host = host;
    }
    
    void ListValues::CopyTo_5c11843f30416058(System::Array* array, int32_t arrayIndex) {
        this->host->CopyToArray(array, arrayIndex, EnumeratorMode2::VALUE_MODE);
    }
    
    int32_t ListValues::Add_b209d72c1dbda305(System::Object* value) {
        throw cli::gcnew<System::NotSupportedException>(_T("IList::Add not supported"));
    }
    
    void ListValues::Clear_5f40b3c399928145() {
        throw cli::gcnew<System::NotSupportedException>(_T("IList::Clear not supported"));
    }
    
    bool ListValues::Contains_1431cca1be25e62e(System::Object* value) {
        return this->host->ContainsValue_ef34ededfed85e10(value);
    }
    
    int32_t ListValues::IndexOf_4988cb7302341a9d(System::Object* value) {
        return this->host->IndexOfValue_782f6ce5fef83fb5(value);
    }
    
    void ListValues::Insert_7e27e989df4a7c98(int32_t index, System::Object* value) {
        throw cli::gcnew<System::NotSupportedException>(_T("IList::Insert not supported"));
    }
    
    void ListValues::Remove_bbb8a6a15af4657f(System::Object* value) {
        throw cli::gcnew<System::NotSupportedException>(_T("IList::Remove not supported"));
    }
    
    void ListValues::RemoveAt_3e80344965f12590(int32_t index) {
        throw cli::gcnew<System::NotSupportedException>(_T("IList::RemoveAt not supported"));
    }
    
    IEnumerator* ListValues::GetEnumerator_9e0ab377ed68f679() {
        return cli::gcnew<Enumerator2>(this->host, EnumeratorMode2::VALUE_MODE);
    }
    
    int32_t ListValues::get_Count_2968b09a1d64f9e5() {
        return this->host->get_Count_78ce60b82e5a007();
    }
    
    bool ListValues::get_IsSynchronized_625d34d3b10e142e() {
        return this->host->get_IsSynchronized_766878a892ebabf4();
    }
    
    System::Object* ListValues::get_SyncRoot_ecf4ff86be0f7dc5() {
        return this->host->get_SyncRoot_d4fc4c9fde3847f6();
    }
    
    bool ListValues::get_IsFixedSize_7509d66a3ff49ce6() {
        return true;
    }
    
    bool ListValues::get_IsReadOnly_216abd3d5aa2f510() {
        return true;
    }
    
    System::Object* ListValues::get_Item_d6a462476dd6db5b(int32_t index) {
        return this->host->GetByIndex_920ca5caddf75e3d(index);
    }
    
    System::Object* ListValues::set_Item_5e0f725cf069c7d2(int32_t index, System::Object* value) {
        throw cli::gcnew<System::NotSupportedException>(_T("This operation is not supported on GetValueList return"));
        return get_Item_d6a462476dd6db5b(index);
    }
    
}}
namespace System { namespace Collections {
    
    
    void SynchedSortedList::constructor(SortedList* host) {
        if((host ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>();
        }
        this->host = host;
    }
    
    void SynchedSortedList::CopyTo_8484dba7aeba95d9(System::Array* array, int32_t arrayIndex) {
        {
            cli::lock_guard{this->host->get_SyncRoot_d4fc4c9fde3847f6()};
            this->host->CopyTo_8484dba7aeba95d9(array, arrayIndex);
        }
    }
    
    void SynchedSortedList::Add_73ffb8be47e034c5(System::Object* key, System::Object* value) {
        {
            cli::lock_guard{this->host->get_SyncRoot_d4fc4c9fde3847f6()};
            this->host->PutImpl(key, value, false);
        }
    }
    
    void SynchedSortedList::Clear_5308a33218829a30() {
        {
            cli::lock_guard{this->host->get_SyncRoot_d4fc4c9fde3847f6()};
            this->host->Clear_5308a33218829a30();
        }
    }
    
    bool SynchedSortedList::Contains_34d44683dd1aa8bd(System::Object* key) {
        {
            cli::lock_guard{this->host->get_SyncRoot_d4fc4c9fde3847f6()};
            return (this->host->Find(key) >= 0);
        }
    }
    
    IDictionaryEnumerator* SynchedSortedList::GetEnumerator_958c16317aeb4444() {
        {
            cli::lock_guard{this->host->get_SyncRoot_d4fc4c9fde3847f6()};
            return this->host->GetEnumerator_958c16317aeb4444();
        }
    }
    
    void SynchedSortedList::Remove_61abf193a3ae1d2b(System::Object* key) {
        {
            cli::lock_guard{this->host->get_SyncRoot_d4fc4c9fde3847f6()};
            this->host->Remove_61abf193a3ae1d2b(key);
        }
    }
    
    bool SynchedSortedList::ContainsKey_e3470ab0b9b87703(System::Object* key) {
        {
            cli::lock_guard{this->host->get_SyncRoot_d4fc4c9fde3847f6()};
            return this->host->Contains_34d44683dd1aa8bd(key);
        }
    }
    
    bool SynchedSortedList::ContainsValue_ef34ededfed85e10(System::Object* value) {
        {
            cli::lock_guard{this->host->get_SyncRoot_d4fc4c9fde3847f6()};
            return this->host->ContainsValue_ef34ededfed85e10(value);
        }
    }
    
    System::Object* SynchedSortedList::Clone_e04bc1da0532c023() {
        {
            cli::lock_guard{this->host->get_SyncRoot_d4fc4c9fde3847f6()};
            return cli::as<SortedList*>(this->host->Clone_e04bc1da0532c023());
        }
    }
    
    System::Object* SynchedSortedList::GetByIndex_920ca5caddf75e3d(int32_t index) {
        {
            cli::lock_guard{this->host->get_SyncRoot_d4fc4c9fde3847f6()};
            return this->host->GetByIndex_920ca5caddf75e3d(index);
        }
    }
    
    System::Object* SynchedSortedList::GetKey_bd6d1bec1a5b310c(int32_t index) {
        {
            cli::lock_guard{this->host->get_SyncRoot_d4fc4c9fde3847f6()};
            return this->host->GetKey_bd6d1bec1a5b310c(index);
        }
    }
    
    IList* SynchedSortedList::GetKeyList_ffbd7f3ff810d3() {
        {
            cli::lock_guard{this->host->get_SyncRoot_d4fc4c9fde3847f6()};
            return cli::gcnew<ListKeys>(this->host);
        }
    }
    
    IList* SynchedSortedList::GetValueList_17bf7e573fc23371() {
        {
            cli::lock_guard{this->host->get_SyncRoot_d4fc4c9fde3847f6()};
            return cli::gcnew<ListValues>(this->host);
        }
    }
    
    void SynchedSortedList::RemoveAt_cba3ea1ee2c9606d(int32_t index) {
        {
            cli::lock_guard{this->host->get_SyncRoot_d4fc4c9fde3847f6()};
            this->host->RemoveAt_cba3ea1ee2c9606d(index);
        }
    }
    
    int32_t SynchedSortedList::IndexOfKey_81491507d0744836(System::Object* key) {
        {
            cli::lock_guard{this->host->get_SyncRoot_d4fc4c9fde3847f6()};
            return this->host->IndexOfKey_81491507d0744836(key);
        }
    }
    
    int32_t SynchedSortedList::IndexOfValue_782f6ce5fef83fb5(System::Object* val) {
        {
            cli::lock_guard{this->host->get_SyncRoot_d4fc4c9fde3847f6()};
            return this->host->IndexOfValue_782f6ce5fef83fb5(val);
        }
    }
    
    void SynchedSortedList::SetByIndex_6f02898365af9fc4(int32_t index, System::Object* value) {
        {
            cli::lock_guard{this->host->get_SyncRoot_d4fc4c9fde3847f6()};
            this->host->SetByIndex_6f02898365af9fc4(index, value);
        }
    }
    
    void SynchedSortedList::TrimToSize_40ad24c8c4892462() {
        {
            cli::lock_guard{this->host->get_SyncRoot_d4fc4c9fde3847f6()};
            this->host->TrimToSize_40ad24c8c4892462();
        }
    }
    
    int32_t SynchedSortedList::get_Capacity_db68c0b120caeec5() {
        {
            cli::lock_guard{this->host->get_SyncRoot_d4fc4c9fde3847f6()};
            return this->host->get_Capacity_db68c0b120caeec5();
        }
    }
    
    int32_t SynchedSortedList::set_Capacity_13c76b6b4fffc55d(int32_t value) {
        {
            cli::lock_guard{this->host->get_SyncRoot_d4fc4c9fde3847f6()};
            this->host->set_Capacity_13c76b6b4fffc55d(value);
        }
        return get_Capacity_db68c0b120caeec5();
    }
    
    int32_t SynchedSortedList::get_Count_78ce60b82e5a007() {
        return this->host->get_Count_78ce60b82e5a007();
    }
    
    bool SynchedSortedList::get_IsSynchronized_766878a892ebabf4() {
        return true;
    }
    
    System::Object* SynchedSortedList::get_SyncRoot_d4fc4c9fde3847f6() {
        return this->host->get_SyncRoot_d4fc4c9fde3847f6();
    }
    
    bool SynchedSortedList::get_IsFixedSize_8ae72e21b9352319() {
        return this->host->get_IsFixedSize_8ae72e21b9352319();
    }
    
    bool SynchedSortedList::get_IsReadOnly_1c2de291a8a6bf90() {
        return this->host->get_IsReadOnly_1c2de291a8a6bf90();
    }
    
    ICollection* SynchedSortedList::get_Keys_2962390e8ff57dd6() {
        ICollection *keys = nullptr;
        {
            cli::lock_guard{this->host->get_SyncRoot_d4fc4c9fde3847f6()};
            keys = this->host->get_Keys_2962390e8ff57dd6();
        }
        return keys;
    }
    
    ICollection* SynchedSortedList::get_Values_cb1c2f63e58da7b3() {
        ICollection *vals = nullptr;
        {
            cli::lock_guard{this->host->get_SyncRoot_d4fc4c9fde3847f6()};
            vals = this->host->get_Values_cb1c2f63e58da7b3();
        }
        return vals;
    }
    
    System::Object* SynchedSortedList::get_Item_c9a994fdd927bead(System::Object* key) {
        {
            cli::lock_guard{this->host->get_SyncRoot_d4fc4c9fde3847f6()};
            return this->host->GetImpl(key);
        }
    }
    
    System::Object* SynchedSortedList::set_Item_1ba4748ac76411aa(System::Object* key, System::Object* value) {
        {
            cli::lock_guard{this->host->get_SyncRoot_d4fc4c9fde3847f6()};
            this->host->PutImpl(key, value, true);
        }
        return get_Item_c9a994fdd927bead(key);
    }
    
}}
namespace System { namespace Collections {
    
    
    void SortedList::constructor() {
    }
    
    void SortedList::constructor(int32_t initialCapacity) {
    }
    
    void SortedList::constructor(IComparer* comparer, int32_t capacity) {
        if((capacity < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("capacity"));
        }
        if((capacity ==  0)) 
        {
            this->defaultCapacity = 0;
        }
         else 
        {
            this->defaultCapacity = 16;
        }
        this->comparer = comparer;
        InitTable(capacity, true);
    }
    
    void SortedList::constructor(IComparer* comparer) {
        this->comparer = comparer;
        InitTable(16, true);
    }
    
    void SortedList::constructor(IDictionary* d) {
    }
    
    void SortedList::constructor(IDictionary* d, IComparer* comparer) {
        if((d ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("dictionary"));
        }
        InitTable(d->get_Count_8f254f3dd8e2403(), true);
        this->comparer = comparer;
        IDictionaryEnumerator *it = d->GetEnumerator_40657fcb15842551();
        while(it->MoveNext_4e78e145935f5417()) {
            Add_73ffb8be47e034c5(it->get_Key_ed7954531cb20258(), it->get_Value_889e0f410f0d67ef());
        }
    }
    
    IEnumerator* SortedList::GetEnumerator() {
        return cli::gcnew<Enumerator2>(this, EnumeratorMode2::ENTRY_MODE);
    }
    
    void SortedList::Add_73ffb8be47e034c5(System::Object* key, System::Object* value) {
        PutImpl(key, value, false);
    }
    
    void SortedList::Clear_5308a33218829a30() {
        this->defaultCapacity = 16;
        this->table = (new cli::array<Slot2>(this->defaultCapacity));
        this->inUse = 0;
        this->modificationCount++;
    }
    
    bool SortedList::Contains_34d44683dd1aa8bd(System::Object* key) {
        if((key ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>();
        }
        try {
            return (Find(key) >= 0);
        }
        catch(System::Exception*) {
            throw cli::gcnew<System::InvalidOperationException>();
        }
    }
    
    IDictionaryEnumerator* SortedList::GetEnumerator_958c16317aeb4444() {
        return cli::gcnew<Enumerator2>(this, EnumeratorMode2::ENTRY_MODE);
    }
    
    void SortedList::Remove_61abf193a3ae1d2b(System::Object* key) {
        int32_t i = IndexOfKey_81491507d0744836(key);
        if((i >= 0)) 
        {
            RemoveAt_cba3ea1ee2c9606d(i);
        }
    }
    
    void SortedList::CopyTo_8484dba7aeba95d9(System::Array* array, int32_t arrayIndex) {
        if((array ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>();
        }
        if((arrayIndex < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>();
        }
        if((array->get_Rank() > 1)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("array is multi-dimensional"));
        }
        if((arrayIndex >= array->get_Length())) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("arrayIndex is greater than or equal to array.Length"));
        }
        if((this->get_Count_78ce60b82e5a007() > (array->get_Length() - arrayIndex))) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("Not enough space in array from arrayIndex to end of array"));
        }
        IDictionaryEnumerator *it = GetEnumerator_958c16317aeb4444();
        int32_t i = arrayIndex;
        while(it->MoveNext_4e78e145935f5417()) {
            array->SetValue5(cli::box(it->get_Entry_7d036eca1ef8d5f4()), i++);
        }
    }
    
    System::Object* SortedList::Clone_e04bc1da0532c023() {
        SortedList *sl = cli::gcnew<SortedList>(this, this->comparer);
        sl->modificationCount = this->modificationCount;
        return sl;
    }
    
    IList* SortedList::GetKeyList_ffbd7f3ff810d3() {
        return cli::gcnew<ListKeys>(this);
    }
    
    IList* SortedList::GetValueList_17bf7e573fc23371() {
        return cli::gcnew<ListValues>(this);
    }
    
    void SortedList::RemoveAt_cba3ea1ee2c9606d(int32_t index) {
        cli::array<Slot2> *table = this->table;
        int32_t cnt = this->get_Count_78ce60b82e5a007();
        if(((index >= 0) && (index < cnt))) 
        {
            if((index != (cnt - 1))) 
            {
                System::Array::Copy2(table, (index + 1), table, index, ((cnt - 1) - index));
            }
             else 
            {
                table->at(index)->key = nullptr;
                table->at(index)->value = nullptr;
            }
            --this->inUse;
            ++this->modificationCount;
        }
         else 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("index out of range"));
        }
    }
    
    int32_t SortedList::IndexOfKey_81491507d0744836(System::Object* key) {
        if((key ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>();
        }
        int32_t indx = 0;
        try {
            indx = Find(key);
        }
        catch(System::Exception*) {
            throw cli::gcnew<System::InvalidOperationException>();
        }
        return (indx | (indx >> 31));
    }
    
    int32_t SortedList::IndexOfValue_782f6ce5fef83fb5(System::Object* value) {
        if((this->inUse ==  0)) 
        {
            return -1;
        }
        for(int32_t i = 0; (i < this->inUse); i++){
            Slot2 current = this->table->at(i);
            if(System::Object::Equals2(value, current->value)) 
            {
                return i;
            }
        }
        return -1;
    }
    
    bool SortedList::ContainsKey_e3470ab0b9b87703(System::Object* key) {
        if((key ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>();
        }
        try {
            return Contains_34d44683dd1aa8bd(key);
        }
        catch(System::Exception*) {
            throw cli::gcnew<System::InvalidOperationException>();
        }
    }
    
    bool SortedList::ContainsValue_ef34ededfed85e10(System::Object* value) {
        return (IndexOfValue_782f6ce5fef83fb5(value) >= 0);
    }
    
    System::Object* SortedList::GetByIndex_920ca5caddf75e3d(int32_t index) {
        if(((index >= 0) && (index < this->get_Count_78ce60b82e5a007()))) 
        {
            return this->table->at(index)->value;
        }
         else 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("index out of range"));
        }
    }
    
    void SortedList::SetByIndex_6f02898365af9fc4(int32_t index, System::Object* value) {
        if(((index >= 0) && (index < this->get_Count_78ce60b82e5a007()))) 
        {
            this->table->at(index)->value = value;
        }
         else 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("index out of range"));
        }
    }
    
    System::Object* SortedList::GetKey_bd6d1bec1a5b310c(int32_t index) {
        if(((index >= 0) && (index < this->get_Count_78ce60b82e5a007()))) 
        {
            return this->table->at(index)->key;
        }
         else 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("index out of range"));
        }
    }
    
    SortedList* SortedList::Synchronized(SortedList* list) {
        if((list ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(Locale::GetText(_T("Base list is null.")));
        }
        return cli::gcnew<SynchedSortedList>(list);
    }
    
    void SortedList::TrimToSize_40ad24c8c4892462() {
        if((this->get_Count_78ce60b82e5a007() ==  0)) 
        {
            Resize(this->defaultCapacity, false);
        }
         else 
        {
            Resize(this->get_Count_78ce60b82e5a007(), true);
        }
    }
    
    void SortedList::Resize(int32_t n, bool copy) {
        cli::array<Slot2> *table = this->table;
        cli::array<Slot2> *newTable = (new cli::array<Slot2>(n));
        if(copy) 
        {
            System::Array::Copy2(table, 0, newTable, 0, n);
        }
        this->table = newTable;
    }
    
    void SortedList::EnsureCapacity(int32_t n, int32_t free) {
        cli::array<Slot2> *table = this->table;
        cli::array<Slot2> *newTable = nullptr;
        int32_t cap = this->get_Capacity_db68c0b120caeec5();
        bool gap = ((free >= 0) && (free < this->get_Count_78ce60b82e5a007()));
        if((n > cap)) 
        {
            newTable = (new cli::array<Slot2>((n << 1)));
        }
        if((newTable != nullptr)) 
        {
            if(gap) 
            {
                int32_t copyLen = free;
                if((copyLen > 0)) 
                {
                    System::Array::Copy2(table, 0, newTable, 0, copyLen);
                }
                copyLen = (this->get_Count_78ce60b82e5a007() - free);
                if((copyLen > 0)) 
                {
                    System::Array::Copy2(table, free, newTable, (free + 1), copyLen);
                }
            }
             else 
            {
                System::Array::Copy(table, newTable, this->get_Count_78ce60b82e5a007());
            }
            this->table = newTable;
        }
         else 
        {
            if(gap) 
            {
                System::Array::Copy2(table, free, table, (free + 1), (this->get_Count_78ce60b82e5a007() - free));
            }
        }
    }
    
    void SortedList::PutImpl(System::Object* key, System::Object* value, bool overwrite) {
        if((key ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("null key"));
        }
        cli::array<Slot2> *table = this->table;
        int32_t freeIndx = -1;
        try {
            freeIndx = Find(key);
        }
        catch(System::Exception*) {
            throw cli::gcnew<System::InvalidOperationException>();
        }
        if((freeIndx >= 0)) 
        {
            if(!(overwrite)) 
            {
                System::String *msg = Locale::GetText2(_T("Key \'{0}\' already exists in list."), (new cli::array<System::Object*>({key})));
                throw cli::gcnew<System::ArgumentException>(msg);
            }
            table->at(freeIndx)->value = value;
            ++this->modificationCount;
            return;
        }
        freeIndx = ~(freeIndx);
        if((freeIndx > (this->get_Capacity_db68c0b120caeec5() + 1))) 
        {
            throw cli::gcnew<System::Exception>(cli::concat(_T("SortedList::internal error ("), key, _T(", "), value, _T(") at ["), cli::box(freeIndx), _T("]")));
        }
        EnsureCapacity((this->get_Count_78ce60b82e5a007() + 1), freeIndx);
        table = this->table;
        table->at(freeIndx)->key = key;
        table->at(freeIndx)->value = value;
        ++this->inUse;
        ++this->modificationCount;
    }
    
    System::Object* SortedList::GetImpl(System::Object* key) {
        int32_t i = Find(key);
        if((i >= 0)) 
        {
            return this->table->at(i)->value;
        }
         else 
        {
            return nullptr;
        }
    }
    
    void SortedList::InitTable(int32_t capacity, bool forceSize) {
        if((!(forceSize) && (capacity < this->defaultCapacity))) 
        {
            capacity = this->defaultCapacity;
        }
        this->table = (new cli::array<Slot2>(capacity));
        this->inUse = 0;
        this->modificationCount = 0;
    }
    
    void SortedList::CopyToArray(System::Array* arr, int32_t i, EnumeratorMode2 mode) {
        if((arr ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("arr"));
        }
        if(((i < 0) || ((i + this->get_Count_78ce60b82e5a007()) > arr->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("i"));
        }
        IEnumerator *it = cli::gcnew<Enumerator2>(this, mode);
        while(it->MoveNext_4e78e145935f5417()) {
            arr->SetValue5(it->get_Current_8eca9b3da02b123a(), i++);
        }
    }
    
    int32_t SortedList::Find(System::Object* key) {
        cli::array<Slot2> *table = this->table;
        int32_t len = this->get_Count_78ce60b82e5a007();
        if((len ==  0)) 
        {
            return -1;
        }
        IComparer *comparer = (this->comparer ==  nullptr) ? Comparer::Default2 : this->comparer;
        int32_t left = 0;
        int32_t right = (len - 1);
        while((left <= right)) {
            int32_t guess = ((left + right) >> 1);
            int32_t cmp = comparer->Compare_451fd276747b629d(table->at(guess)->key, key);
            if((cmp ==  0)) 
            {
                return guess;
            }
            if((cmp < 0)) 
            {
                left = (guess + 1);
            }
             else 
            {
                right = (guess - 1);
            }
        }
        return ~(left);
    }
    
    int32_t SortedList::get_Count_78ce60b82e5a007() {
        return this->inUse;
    }
    
    bool SortedList::get_IsSynchronized_766878a892ebabf4() {
        return false;
    }
    
    System::Object* SortedList::get_SyncRoot_d4fc4c9fde3847f6() {
        return this;
    }
    
    bool SortedList::get_IsFixedSize_8ae72e21b9352319() {
        return false;
    }
    
    bool SortedList::get_IsReadOnly_1c2de291a8a6bf90() {
        return false;
    }
    
    ICollection* SortedList::get_Keys_2962390e8ff57dd6() {
        return cli::gcnew<ListKeys>(this);
    }
    
    ICollection* SortedList::get_Values_cb1c2f63e58da7b3() {
        return cli::gcnew<ListValues>(this);
    }
    
    System::Object* SortedList::get_Item_c9a994fdd927bead(System::Object* key) {
        if((key ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>();
        }
        return GetImpl(key);
    }
    
    System::Object* SortedList::set_Item_1ba4748ac76411aa(System::Object* key, System::Object* value) {
        if((key ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>();
        }
        if(this->get_IsReadOnly_1c2de291a8a6bf90()) 
        {
            throw cli::gcnew<System::NotSupportedException>(_T("SortedList is Read Only."));
        }
        if(((Find(key) < 0) && this->get_IsFixedSize_8ae72e21b9352319())) 
        {
            throw cli::gcnew<System::NotSupportedException>(_T("Key not found and SortedList is fixed size."));
        }
        PutImpl(key, value, true);
        return get_Item_c9a994fdd927bead(key);
    }
    
    int32_t SortedList::get_Capacity_db68c0b120caeec5() {
        return this->table->get_Length();
    }
    
    int32_t SortedList::set_Capacity_13c76b6b4fffc55d(int32_t value) {
        int32_t current = this->table->get_Length();
        if((this->inUse > value)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("capacity too small"));
        }
         else 
        {
            if((value ==  0)) 
            {
                cli::array<Slot2> *newTable = (new cli::array<Slot2>(this->defaultCapacity));
                System::Array::Copy(this->table, newTable, this->inUse);
                this->table = newTable;
            }
             else 
            {
                if((value > this->inUse)) 
                {
                    cli::array<Slot2> *newTable = (new cli::array<Slot2>(value));
                    System::Array::Copy(this->table, newTable, this->inUse);
                    this->table = newTable;
                }
                 else 
                {
                    if((value > current)) 
                    {
                        cli::array<Slot2> *newTable = (new cli::array<Slot2>(value));
                        System::Array::Copy(this->table, newTable, current);
                        this->table = newTable;
                    }
                }
            }
        }
        return get_Capacity_db68c0b120caeec5();
    }
    
}}
namespace System { namespace Collections {
    
    
    void SyncStack::constructor(Stack* s) {
        this->stack = s;
    }
    
    void SyncStack::Clear_8c8c25624b18372d() {
        {
            cli::lock_guard{this->stack};
            this->stack->Clear_8c8c25624b18372d();
        }
    }
    
    System::Object* SyncStack::Clone_be99069adbf1961c() {
        {
            cli::lock_guard{this->stack};
            return Stack::Synchronized(cli::cast<Stack*>(this->stack->Clone_be99069adbf1961c()));
        }
    }
    
    bool SyncStack::Contains_e73575808049e7be(System::Object* obj) {
        {
            cli::lock_guard{this->stack};
            return this->stack->Contains_e73575808049e7be(obj);
        }
    }
    
    void SyncStack::CopyTo_f10714ed2802c46b(System::Array* array, int32_t index) {
        {
            cli::lock_guard{this->stack};
            this->stack->CopyTo_f10714ed2802c46b(array, index);
        }
    }
    
    IEnumerator* SyncStack::GetEnumerator_ae53897f8a2f577a() {
        {
            cli::lock_guard{this->stack};
            return cli::gcnew<Enumerator3>(this->stack);
        }
    }
    
    System::Object* SyncStack::Peek_6b91e1254bdabd34() {
        {
            cli::lock_guard{this->stack};
            return this->stack->Peek_6b91e1254bdabd34();
        }
    }
    
    System::Object* SyncStack::Pop_9492442210514403() {
        {
            cli::lock_guard{this->stack};
            return this->stack->Pop_9492442210514403();
        }
    }
    
    void SyncStack::Push_9a8495c8210a673(System::Object* obj) {
        {
            cli::lock_guard{this->stack};
            this->stack->Push_9a8495c8210a673(obj);
        }
    }
    
    cli::array<System::Object*>* SyncStack::ToArray_429131696de6db19() {
        {
            cli::lock_guard{this->stack};
            return this->stack->ToArray_429131696de6db19();
        }
    }
    
    int32_t SyncStack::get_Count_a768d394e63a6b27() {
        {
            cli::lock_guard{this->stack};
            return this->stack->get_Count_a768d394e63a6b27();
        }
    }
    
    bool SyncStack::get_IsSynchronized_d5977c6adec21cc3() {
        return true;
    }
    
    System::Object* SyncStack::get_SyncRoot_d19ca4cd2e3adde6() {
        return this->stack->get_SyncRoot_d19ca4cd2e3adde6();
    }
    
}}
namespace System { namespace Collections {
    
    
    void Enumerator3::constructor(Stack* s) {
        this->stack = s;
        this->modCount = s->modCount;
        this->current = -2;
    }
    
    System::Object* Enumerator3::Clone() {
        return System::Object::MemberwiseClone();
    }
    
    bool Enumerator3::MoveNext_95653590660ca25b() {
        if((this->modCount != this->stack->modCount)) 
        {
            throw cli::gcnew<System::InvalidOperationException>();
        }
        switch(this->current) {
            case -2: case_956: {
                this->current = this->stack->current;
                return (this->current != -1);
            }
            case -1: case_957: {
                return false;
            }
            default: case_958: {
                this->current--;
                return (this->current != -1);
            }
        }
    }
    
    void Enumerator3::Reset_f5f37e29637be803() {
        if((this->modCount != this->stack->modCount)) 
        {
            throw cli::gcnew<System::InvalidOperationException>();
        }
        this->current = -2;
    }
    
    System::Object* Enumerator3::get_Current_9c1f38e77bf983c1() {
        if(((((this->modCount != this->stack->modCount) || (this->current ==  -2)) || (this->current ==  -1)) || (this->current > this->stack->count))) 
        {
            throw cli::gcnew<System::InvalidOperationException>();
        }
        return this->stack->contents->at(this->current);
    }
    
}}
namespace System { namespace Collections {
    
    
    void Stack::constructor() {
        this->contents = (new cli::array<System::Object*>(16));
        this->capacity = 16;
    }
    
    void Stack::constructor(ICollection* col) {
        if((col ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("col"));
        }
        for(auto tmp_208 : col) {
            auto o = cli::cast<System::Object*>(tmp_208);
            Push_9a8495c8210a673(o);
        }
    }
    
    void Stack::constructor(int32_t initialCapacity) {
        if((initialCapacity < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("initialCapacity"));
        }
        this->capacity = initialCapacity;
        this->contents = (new cli::array<System::Object*>(this->capacity));
    }
    
    void Stack::Resize(int32_t ncapacity) {
        ncapacity = System::Math::Max5(ncapacity, 16);
        cli::array<System::Object*> *ncontents = (new cli::array<System::Object*>(ncapacity));
        System::Array::Copy(this->contents, ncontents, this->count);
        this->capacity = ncapacity;
        this->contents = ncontents;
    }
    
    Stack* Stack::Synchronized(Stack* stack) {
        if((stack ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("stack"));
        }
        return cli::gcnew<SyncStack>(stack);
    }
    
    void Stack::Clear_8c8c25624b18372d() {
        this->modCount++;
        for(int32_t i = 0; (i < this->count); i++){
            this->contents->at(i) = nullptr;
        }
        this->count = 0;
        this->current = -1;
    }
    
    System::Object* Stack::Clone_be99069adbf1961c() {
        Stack *stack = cli::gcnew<Stack>(this->contents);
        stack->current = this->current;
        stack->count = this->count;
        return stack;
    }
    
    bool Stack::Contains_e73575808049e7be(System::Object* obj) {
        if((this->count ==  0)) 
        {
            return false;
        }
        if((obj ==  nullptr)) 
        {
            for(int32_t i = 0; (i < this->count); i++){
                if((this->contents->at(i) ==  nullptr)) 
                {
                    return true;
                }
            }
        }
         else 
        {
            for(int32_t i = 0; (i < this->count); i++){
                if(obj->Equals_ed975d2f4a7d193e(this->contents->at(i))) 
                {
                    return true;
                }
            }
        }
        return false;
    }
    
    void Stack::CopyTo_f10714ed2802c46b(System::Array* array, int32_t index) {
        if((array ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("array"));
        }
        if((index < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("index"));
        }
        if((((array->get_Rank() > 1) || ((array->get_Length() > 0) && (index >= array->get_Length()))) || (this->count > (array->get_Length() - index)))) 
        {
            throw cli::gcnew<System::ArgumentException>();
        }
        for(int32_t i = this->current; (i != -1); i--){
            array->SetValue5(this->contents->at(i), ((this->count - (i + 1)) + index));
        }
    }
    
    IEnumerator* Stack::GetEnumerator_ae53897f8a2f577a() {
        return cli::gcnew<Enumerator3>(this);
    }
    
    System::Object* Stack::Peek_6b91e1254bdabd34() {
        if((this->current ==  -1)) 
        {
            throw cli::gcnew<System::InvalidOperationException>();
        }
         else 
        {
            return this->contents->at(this->current);
        }
    }
    
    System::Object* Stack::Pop_9492442210514403() {
        if((this->current ==  -1)) 
        {
            throw cli::gcnew<System::InvalidOperationException>();
        }
         else 
        {
            this->modCount++;
            System::Object *ret = this->contents->at(this->current);
            this->contents->at(this->current) = nullptr;
            this->count--;
            this->current--;
            if(((this->count <= (this->capacity / 4)) && (this->count > 16))) 
            {
                Resize((this->capacity / 2));
            }
            return ret;
        }
    }
    
    void Stack::Push_9a8495c8210a673(System::Object* obj) {
        this->modCount++;
        if((this->capacity ==  this->count)) 
        {
            Resize((this->capacity * 2));
        }
        this->count++;
        this->current++;
        this->contents->at(this->current) = obj;
    }
    
    cli::array<System::Object*>* Stack::ToArray_429131696de6db19() {
        cli::array<System::Object*> *ret = (new cli::array<System::Object*>(this->count));
        System::Array::Copy(this->contents, ret, this->count);
        System::Array::Reverse(ret);
        return ret;
    }
    
    int32_t Stack::get_Count_a768d394e63a6b27() {
        return this->count;
    }
    
    bool Stack::get_IsSynchronized_d5977c6adec21cc3() {
        return false;
    }
    
    System::Object* Stack::get_SyncRoot_d19ca4cd2e3adde6() {
        return this;
    }
    
}}
namespace System { namespace Collections {
    
    
    void ComparerImpl::constructor() {
    }
    
    int32_t ComparerImpl::Compare(System::Object* x, System::Object* y) {
        IStructuralComparable *comparer = cli::as<IStructuralComparable*>(x);
        if((comparer != nullptr)) 
        {
            return comparer->CompareTo_6a6cfba1da2bec3b(y, this);
        }
        return Comparer::Default2->Compare(x, y);
    }
    
    int32_t ComparerImpl::GetHashCode2(System::Object* obj) {
        IEqualityComparer *comparer = cli::as<IEqualityComparer*>(obj);
        if((comparer != nullptr)) 
        {
            return comparer->GetHashCode_f8793dfb2b096a5a(this);
        }
        return Generic::EqualityComparer<System::Object*>::get_Default()->GetHashCode_f61694b39bec824d(obj);
    }
    
    bool ComparerImpl::Equals3(System::Object* x, System::Object* y) {
        IEqualityComparer *comparer = cli::as<IEqualityComparer*>(x);
        if((comparer != nullptr)) 
        {
            return comparer->Equals_ad190887ea91ded(y, this);
        }
        return Generic::EqualityComparer<System::Object*>::get_Default()->Equals_e786aaeef5b10ff2(x, y);
    }
    
}}
namespace System { namespace Collections {
    
    ComparerImpl*  StructuralComparisons::comparer;
    
    StructuralComparisons::StructuralComparisons()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void StructuralComparisons::static_constructor() {
    }
    
    IComparer* StructuralComparisons::get_StructuralComparer() {
        return comparer;
    }
    
    IEqualityComparer* StructuralComparisons::get_StructuralEqualityComparer() {
        return comparer;
    }
    
}}
namespace System { namespace Collections { namespace Concurrent {
    
    
}}}
namespace System { namespace Collections { namespace Concurrent {
    
    
}}}
namespace System { namespace Collections { namespace Concurrent {
    
    
}}}
namespace System { namespace Collections { namespace Concurrent {
    
    
}}}
namespace System { namespace Collections { namespace Concurrent {
    
    
}}}
namespace System { namespace Collections { namespace Concurrent {
    
    
}}}
namespace System { namespace Collections { namespace Concurrent {
    
    
}}}
namespace System { namespace Collections { namespace Concurrent {
    
    
}}}
namespace System { namespace Collections { namespace Concurrent {
    
    
}}}
namespace System { namespace Collections { namespace Concurrent {
    
    
}}}
namespace System { namespace Collections { namespace Concurrent {
    
    
}}}
namespace System { namespace Collections { namespace Concurrent {
    
    
}}}
namespace System { namespace Collections { namespace Concurrent {
    
    
}}}
namespace System { namespace Collections { namespace Concurrent {
    
    
    OrderablePartitioner<System::Tuple4<int32_t, int32_t>*>* Partitioner2::Create(int32_t fromInclusive, int32_t toExclusive) {
        int32_t rangeSize = ((toExclusive - fromInclusive) / (System::Environment::get_ProcessorCount() * 3));
        if((rangeSize < 1)) 
        {
            rangeSize = 1;
        }
        return Create2(fromInclusive, toExclusive, rangeSize);
    }
    
    OrderablePartitioner<System::Tuple4<int32_t, int32_t>*>* Partitioner2::Create2(int32_t fromInclusive, int32_t toExclusive, int32_t rangeSize) {
        if((fromInclusive >= toExclusive)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("toExclusive"));
        }
        if((rangeSize <= 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("rangeSize"));
        }
        return cli::gcnew<Partitioners::UserRangePartitioner>(fromInclusive, toExclusive, rangeSize);
    }
    
    OrderablePartitioner<System::Tuple4<int64_t, int64_t>*>* Partitioner2::Create3(int64_t fromInclusive, int64_t toExclusive) {
        int64_t rangeSize = ((toExclusive - fromInclusive) / (int64_t)((System::Environment::get_ProcessorCount() * 3)));
        if((rangeSize < 1L)) 
        {
            rangeSize = 1L;
        }
        return Create4(fromInclusive, toExclusive, rangeSize);
    }
    
    OrderablePartitioner<System::Tuple4<int64_t, int64_t>*>* Partitioner2::Create4(int64_t fromInclusive, int64_t toExclusive, int64_t rangeSize) {
        if((rangeSize <= 0L)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("rangeSize"));
        }
        if((fromInclusive >= toExclusive)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("toExclusive"));
        }
        return cli::gcnew<Partitioners::UserLongRangePartitioner>(fromInclusive, toExclusive, rangeSize);
    }
    
}}}
namespace System { namespace Collections { namespace Concurrent {
    
    
}}}
namespace System { namespace Collections { namespace Concurrent {
    
    
}}}
namespace System { namespace Collections { namespace Concurrent {
    
    
}}}
namespace System { namespace Collections { namespace Concurrent {
    
    
}}}
namespace System { namespace Collections { namespace Concurrent { namespace Partitioners {
    
    
}}}}
namespace System { namespace Collections { namespace Concurrent { namespace Partitioners {
    
    
}}}}
namespace System { namespace Collections { namespace Concurrent { namespace Partitioners {
    
    
}}}}
namespace System { namespace Collections { namespace Concurrent { namespace Partitioners {
    
    
}}}}
namespace System { namespace Collections { namespace Concurrent { namespace Partitioners {
    
    
    void UserRangePartitioner::constructor(int32_t start, int32_t end, int32_t rangeSize) {
        this->start = start;
        this->end = end;
        this->rangeSize = rangeSize;
    }
    
    System::Collections::Generic::IList2<System::Collections::Generic::IEnumerator2<System::Collections::Generic::KeyValuePair<int64_t, System::Tuple4<int32_t, int32_t>*>>*>* UserRangePartitioner::GetOrderablePartitions_abc13b50067e2c56(int32_t partitionCount) {
        if((partitionCount <= 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("partitionCount"));
        }
        auto storey_209 = cli::gcnew<_GetOrderablePartitions_c__AnonStorey16>();
        storey_209->currentIndex = 0;
        System::Func<int32_t> *getNextIndex = cli::bind(storey_209, &_GetOrderablePartitions_c__AnonStorey16::__m__B);
        cli::array<System::Collections::Generic::IEnumerator2<System::Collections::Generic::KeyValuePair<int64_t, System::Tuple4<int32_t, int32_t>*>>*> *enumerators = (new cli::array<System::Collections::Generic::IEnumerator2<System::Collections::Generic::KeyValuePair<int64_t, System::Tuple4<int32_t, int32_t>*>>*>(partitionCount));
        for(int32_t i = 0; (i < partitionCount); i++) {
            enumerators->at(i) = GetEnumerator(getNextIndex);
        }
        return enumerators;
    }
    
    System::Collections::Generic::IEnumerator2<System::Collections::Generic::KeyValuePair<int64_t, System::Tuple4<int32_t, int32_t>*>>* UserRangePartitioner::GetEnumerator(System::Func<int32_t>* getNextIndex) {
        return (nullptr/*TODO: Implement Yield Expression!*/);
    }
    
}}}}
namespace System { namespace Collections { namespace Concurrent { namespace Partitioners {
    
    
    void UserLongRangePartitioner::constructor(int64_t start, int64_t end, int64_t rangeSize) {
        this->start = start;
        this->end = end;
        this->rangeSize = rangeSize;
    }
    
    System::Collections::Generic::IList2<System::Collections::Generic::IEnumerator2<System::Collections::Generic::KeyValuePair<int64_t, System::Tuple4<int64_t, int64_t>*>>*>* UserLongRangePartitioner::GetOrderablePartitions_abc13b50067e2c56(int32_t partitionCount) {
        if((partitionCount <= 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("partitionCount"));
        }
        auto storey_210 = cli::gcnew<_GetOrderablePartitions_c__AnonStorey17>();
        storey_210->currentIndex = 0L;
        System::Func<int64_t> *getNextIndex = cli::bind(storey_210, &_GetOrderablePartitions_c__AnonStorey17::__m__C);
        cli::array<System::Collections::Generic::IEnumerator2<System::Collections::Generic::KeyValuePair<int64_t, System::Tuple4<int64_t, int64_t>*>>*> *enumerators = (new cli::array<System::Collections::Generic::IEnumerator2<System::Collections::Generic::KeyValuePair<int64_t, System::Tuple4<int64_t, int64_t>*>>*>(partitionCount));
        for(int32_t i = 0; (i < partitionCount); i++) {
            enumerators->at(i) = GetEnumerator(getNextIndex);
        }
        return enumerators;
    }
    
    System::Collections::Generic::IEnumerator2<System::Collections::Generic::KeyValuePair<int64_t, System::Tuple4<int64_t, int64_t>*>>* UserLongRangePartitioner::GetEnumerator(System::Func<int64_t>* getNextIndex) {
        return (nullptr/*TODO: Implement Yield Expression!*/);
    }
    
}}}}
namespace System { namespace Collections { namespace Generic {
    
    
}}}
namespace System { namespace Collections { namespace Generic {
    
    
}}}
namespace System { namespace Collections { namespace Generic {
    
    
}}}
namespace System { namespace Collections { namespace Generic {
    
    
}}}
namespace System { namespace Collections { namespace Generic {
    
    
}}}
namespace System { namespace Collections { namespace Generic {
    
    
}}}
namespace System { namespace Collections { namespace Generic {
    
    
}}}
namespace System { namespace Collections { namespace Generic {
    
    
}}}
namespace System { namespace Collections { namespace Generic {
    
    
}}}
namespace System { namespace Collections { namespace Generic {
    
    
}}}
namespace System { namespace Collections { namespace Generic {
    
    
}}}
namespace System { namespace Collections { namespace Generic {
    
    
    void InternalStringComparer::constructor() {
    }
    
    int32_t InternalStringComparer::GetHashCode_f61694b39bec824d(System::String* obj) {
        if((obj ==  nullptr)) 
        {
            return 0;
        }
        return obj->GetHashCode_6648aef0f235ee6c();
    }
    
    bool InternalStringComparer::Equals_e786aaeef5b10ff2(System::String* x, System::String* y) {
        if((x ==  nullptr)) 
        {
            return (y ==  nullptr);
        }
        if((cli::cast<System::Object*>(x) ==  cli::cast<System::Object*>(y))) 
        {
            return true;
        }
        return x->Equals5(y);
    }
    
}}}
namespace System { namespace Collections { namespace Generic {
    
    
}}}
namespace System { namespace Collections { namespace Generic {
    
    
    void KeyNotFoundException::constructor() {
    }
    
    void KeyNotFoundException::constructor(System::String* message) {
    }
    
    void KeyNotFoundException::constructor(System::String* message, System::Exception* innerException) {
    }
    
    void KeyNotFoundException::constructor(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
    }
    
}}}
namespace System { namespace Collections { namespace Generic {
    
    
}}}
namespace System { namespace Collections { namespace ObjectModel {
    
    
}}}
namespace System { namespace Collections { namespace ObjectModel {
    
    
}}}
namespace System { namespace Collections { namespace ObjectModel {
    
    
}}}
namespace System { namespace Deployment { namespace Internal {
    
    
    System::Object* InternalActivationContextHelper::GetActivationContextData(System::ActivationContext* appInfo) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    System::Object* InternalActivationContextHelper::GetApplicationComponentManifest(System::ActivationContext* appInfo) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    cli::array<unsigned char>* InternalActivationContextHelper::GetApplicationManifestBytes(System::ActivationContext* appInfo) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    System::Object* InternalActivationContextHelper::GetDeploymentComponentManifest(System::ActivationContext* appInfo) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    cli::array<unsigned char>* InternalActivationContextHelper::GetDeploymentManifestBytes(System::ActivationContext* appInfo) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool InternalActivationContextHelper::IsFirstRun(System::ActivationContext* appInfo) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    void InternalActivationContextHelper::PrepareForExecution(System::ActivationContext* appInfo) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
}}}
namespace System { namespace Deployment { namespace Internal {
    
    
    System::Object* InternalApplicationIdentityHelper::GetInternalAppId(System::ApplicationIdentity* id) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
}}}
namespace System { namespace Diagnostics {
    
    
    void ConditionalAttribute::constructor(System::String* conditionString) {
        this->myCondition = conditionString;
    }
    
    System::String* ConditionalAttribute::get_ConditionString() {
        return this->myCondition;
    }
    
}}
namespace System { namespace Diagnostics {
    
    
    void DebuggableAttribute::constructor(bool isJITTrackingEnabled, bool isJITOptimizerDisabled) {
        this->JITTrackingEnabledFlag = isJITTrackingEnabled;
        this->JITOptimizerDisabledFlag = isJITOptimizerDisabled;
        if(isJITTrackingEnabled) 
        {
            (this->debuggingModes = (DebuggingModes)(((int32_t)(this->debuggingModes) | 1)));
        }
        if(isJITOptimizerDisabled) 
        {
            (this->debuggingModes = (DebuggingModes)(((int32_t)(this->debuggingModes) | 256)));
        }
    }
    
    void DebuggableAttribute::constructor(DebuggingModes modes) {
        this->debuggingModes = modes;
        this->JITTrackingEnabledFlag = ((int32_t)(((int32_t)(this->debuggingModes) & 1)) != 0);
        this->JITOptimizerDisabledFlag = ((int32_t)(((int32_t)(this->debuggingModes) & 256)) != 0);
    }
    
    DebuggingModes DebuggableAttribute::get_DebuggingFlags() {
        return this->debuggingModes;
    }
    
    bool DebuggableAttribute::get_IsJITTrackingEnabled() {
        return this->JITTrackingEnabledFlag;
    }
    
    bool DebuggableAttribute::get_IsJITOptimizerDisabled() {
        return this->JITOptimizerDisabledFlag;
    }
    
}}
namespace System { namespace Diagnostics {
    
    System::String*  Debugger::DefaultCategory;
    
    Debugger::Debugger()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void Debugger::constructor() {
    }
    
    void Debugger::static_constructor() {
    }
    
    bool Debugger::IsAttached_internal() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Debugger::Break() {
    }
    
    bool Debugger::IsLogging() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool Debugger::Launch() {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Debugger::Log(int32_t level, System::String* category, System::String* message) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool Debugger::get_IsAttached() {
        return IsAttached_internal();
    }
    
}}
namespace System { namespace Diagnostics {
    
    
    void DebuggerBrowsableAttribute::constructor(DebuggerBrowsableState state) {
        this->state = state;
    }
    
    DebuggerBrowsableState DebuggerBrowsableAttribute::get_State() {
        return this->state;
    }
    
}}
namespace System { namespace Diagnostics {
    
    
    void DebuggerDisplayAttribute::constructor(System::String* value) {
        if((value ==  nullptr)) 
        {
            value = System::String::Empty;
        }
        this->value = value;
        this->type = System::String::Empty;
        this->name = System::String::Empty;
    }
    
    System::String* DebuggerDisplayAttribute::get_Value() {
        return this->value;
    }
    
    System::Type* DebuggerDisplayAttribute::get_Target() {
        return this->target_type;
    }
    
    System::Type* DebuggerDisplayAttribute::set_Target(System::Type* value) {
        if(System::Type::op_Equality2(value, nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("value"));
        }
        this->target_type = value;
        this->target_type_name = this->target_type->get_AssemblyQualifiedName_cea373c2171bd483();
        return get_Target();
    }
    
    System::String* DebuggerDisplayAttribute::get_TargetTypeName() {
        return this->target_type_name;
    }
    
    System::String* DebuggerDisplayAttribute::set_TargetTypeName(System::String* value) {
        this->target_type_name = value;
        return get_TargetTypeName();
    }
    
    System::String* DebuggerDisplayAttribute::get_Type() {
        return this->type;
    }
    
    System::String* DebuggerDisplayAttribute::set_Type(System::String* value) {
        this->type = value;
        return get_Type();
    }
    
    System::String* DebuggerDisplayAttribute::get_Name() {
        return this->name;
    }
    
    System::String* DebuggerDisplayAttribute::set_Name(System::String* value) {
        this->name = value;
        return get_Name();
    }
    
}}
namespace System { namespace Diagnostics {
    
    
    void DebuggerHiddenAttribute::constructor() {
    }
    
}}
namespace System { namespace Diagnostics {
    
    
    void DebuggerNonUserCodeAttribute::constructor() {
    }
    
}}
namespace System { namespace Diagnostics {
    
    
    void DebuggerStepperBoundaryAttribute::constructor() {
    }
    
}}
namespace System { namespace Diagnostics {
    
    
    void DebuggerStepThroughAttribute::constructor() {
    }
    
}}
namespace System { namespace Diagnostics {
    
    
    void DebuggerTypeProxyAttribute::constructor(System::String* typeName) {
        this->proxy_type_name = typeName;
    }
    
    void DebuggerTypeProxyAttribute::constructor(System::Type* type) {
        this->proxy_type_name = type->get_Name_50fad5fa936c3ae2();
    }
    
    System::String* DebuggerTypeProxyAttribute::get_ProxyTypeName() {
        return this->proxy_type_name;
    }
    
    System::Type* DebuggerTypeProxyAttribute::get_Target() {
        return this->target_type;
    }
    
    System::Type* DebuggerTypeProxyAttribute::set_Target(System::Type* value) {
        this->target_type = value;
        this->target_type_name = this->target_type->get_Name_50fad5fa936c3ae2();
        return get_Target();
    }
    
    System::String* DebuggerTypeProxyAttribute::get_TargetTypeName() {
        return this->target_type_name;
    }
    
    System::String* DebuggerTypeProxyAttribute::set_TargetTypeName(System::String* value) {
        this->target_type_name = value;
        return get_TargetTypeName();
    }
    
}}
namespace System { namespace Diagnostics {
    
    
    void DebuggerVisualizerAttribute::constructor(System::String* visualizerTypeName) {
        this->visualizerName = visualizerTypeName;
    }
    
    void DebuggerVisualizerAttribute::constructor(System::Type* visualizer) {
        if(System::Type::op_Equality2(visualizer, nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("visualizer"));
        }
        this->visualizerName = visualizer->get_AssemblyQualifiedName_cea373c2171bd483();
    }
    
    void DebuggerVisualizerAttribute::constructor(System::String* visualizerTypeName, System::String* visualizerObjectSourceTypeName) {
        this->visualizerName = visualizerTypeName;
        this->visualizerSourceName = visualizerObjectSourceTypeName;
    }
    
    void DebuggerVisualizerAttribute::constructor(System::String* visualizerTypeName, System::Type* visualizerObjectSource) {
        if(System::Type::op_Equality2(visualizerObjectSource, nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("visualizerObjectSource"));
        }
        this->visualizerName = visualizerTypeName;
        this->visualizerSourceName = visualizerObjectSource->get_AssemblyQualifiedName_cea373c2171bd483();
    }
    
    void DebuggerVisualizerAttribute::constructor(System::Type* visualizer, System::String* visualizerObjectSourceTypeName) {
        if(System::Type::op_Equality2(visualizer, nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("visualizer"));
        }
        this->visualizerName = visualizer->get_AssemblyQualifiedName_cea373c2171bd483();
        this->visualizerSourceName = visualizerObjectSourceTypeName;
    }
    
    void DebuggerVisualizerAttribute::constructor(System::Type* visualizer, System::Type* visualizerObjectSource) {
        if(System::Type::op_Equality2(visualizer, nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("visualizer"));
        }
        if(System::Type::op_Equality2(visualizerObjectSource, nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("visualizerObjectSource"));
        }
        this->visualizerName = visualizer->get_AssemblyQualifiedName_cea373c2171bd483();
        this->visualizerSourceName = visualizerObjectSource->get_AssemblyQualifiedName_cea373c2171bd483();
    }
    
    System::String* DebuggerVisualizerAttribute::get_Description() {
        return this->description;
    }
    
    System::String* DebuggerVisualizerAttribute::set_Description(System::String* value) {
        this->description = value;
        return get_Description();
    }
    
    System::Type* DebuggerVisualizerAttribute::get_Target() {
        return this->target;
    }
    
    System::Type* DebuggerVisualizerAttribute::set_Target(System::Type* value) {
        this->target = value;
        this->targetTypeName = this->target->get_AssemblyQualifiedName_cea373c2171bd483();
        return get_Target();
    }
    
    System::String* DebuggerVisualizerAttribute::get_TargetTypeName() {
        return this->targetTypeName;
    }
    
    System::String* DebuggerVisualizerAttribute::set_TargetTypeName(System::String* value) {
        this->targetTypeName = value;
        return get_TargetTypeName();
    }
    
    System::String* DebuggerVisualizerAttribute::get_VisualizerObjectSourceTypeName() {
        return this->visualizerSourceName;
    }
    
    System::String* DebuggerVisualizerAttribute::get_VisualizerTypeName() {
        return this->visualizerName;
    }
    
}}
namespace System { namespace Diagnostics {
    
    
    void StackFrame::constructor() {
        get_frame_info(2, false, this->methodBase, this->ilOffset, this->nativeOffset, this->fileName, this->lineNumber, this->columnNumber);
    }
    
    void StackFrame::constructor(bool fNeedFileInfo) {
        get_frame_info(2, fNeedFileInfo, this->methodBase, this->ilOffset, this->nativeOffset, this->fileName, this->lineNumber, this->columnNumber);
    }
    
    void StackFrame::constructor(int32_t skipFrames) {
        get_frame_info((skipFrames + 2), false, this->methodBase, this->ilOffset, this->nativeOffset, this->fileName, this->lineNumber, this->columnNumber);
    }
    
    void StackFrame::constructor(int32_t skipFrames, bool fNeedFileInfo) {
        get_frame_info((skipFrames + 2), fNeedFileInfo, this->methodBase, this->ilOffset, this->nativeOffset, this->fileName, this->lineNumber, this->columnNumber);
    }
    
    void StackFrame::constructor(System::String* fileName, int32_t lineNumber) {
        get_frame_info(2, false, this->methodBase, this->ilOffset, this->nativeOffset, fileName, lineNumber, this->columnNumber);
        this->fileName = fileName;
        this->lineNumber = lineNumber;
        this->columnNumber = 0;
    }
    
    void StackFrame::constructor(System::String* fileName, int32_t lineNumber, int32_t colNumber) {
        get_frame_info(2, false, this->methodBase, this->ilOffset, this->nativeOffset, fileName, lineNumber, this->columnNumber);
        this->fileName = fileName;
        this->lineNumber = lineNumber;
        this->columnNumber = colNumber;
    }
    
    bool StackFrame::get_frame_info(int32_t skip, bool needFileInfo, System::Reflection::MethodBase* method, int32_t iloffset, int32_t native_offset, System::String* file, int32_t line, int32_t column) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t StackFrame::GetFileLineNumber_55fe214715732be8() {
        return this->lineNumber;
    }
    
    int32_t StackFrame::GetFileColumnNumber_4d47ac0b355aa095() {
        return this->columnNumber;
    }
    
    System::String* StackFrame::GetFileName_a639782e0c46ed4e() {
        if(((System::Security::SecurityManager::get_SecurityEnabled() && (this->fileName != nullptr)) && (this->fileName->get_Length() > 0))) 
        {
            System::String *fn = System::IO::Path::GetFullPath(this->fileName);
            cli::gcnew<System::Security::Permissions::FileIOPermission>(System::Security::Permissions::FileIOPermissionAccess::PathDiscovery, fn)->Demand();
        }
        return this->fileName;
    }
    
    System::String* StackFrame::GetSecureFileName() {
        System::String *filename = _T("<filename unknown>");
        if((this->fileName ==  nullptr)) 
        {
            return filename;
        }
        try {
            filename = GetFileName_a639782e0c46ed4e();
        }
        catch(System::Security::SecurityException*) {
        }
        return filename;
    }
    
    int32_t StackFrame::GetILOffset_3f696258d4f94ef6() {
        return this->ilOffset;
    }
    
    System::Reflection::MethodBase* StackFrame::GetMethod_c520bf4862e6a796() {
        return this->methodBase;
    }
    
    int32_t StackFrame::GetNativeOffset_bd54530a35fdb2cf() {
        return this->nativeOffset;
    }
    
    System::String* StackFrame::GetInternalMethodName() {
        return this->internalMethodName;
    }
    
    System::String* StackFrame::ToString_1636a0751cb9ac11() {
        System::Text::StringBuilder *sb = cli::gcnew<System::Text::StringBuilder>();
        if(System::Reflection::MethodBase::op_Equality2(this->methodBase, nullptr)) 
        {
            sb->Append2(Locale::GetText(_T("<unknown method>")));
        }
         else 
        {
            sb->Append2(this->methodBase->get_Name_50fad5fa936c3ae2());
        }
        sb->Append2(Locale::GetText(_T(" at ")));
        if((this->ilOffset ==  -1)) 
        {
            sb->Append2(Locale::GetText(_T("<unknown offset>")));
        }
         else 
        {
            sb->Append2(Locale::GetText(_T("offset ")));
            sb->Append8(this->ilOffset);
        }
        sb->Append2(Locale::GetText(_T(" in file:line:column ")));
        sb->Append2(GetSecureFileName());
        sb->AppendFormat4(_T(":{0}:{1}"), cli::box(this->lineNumber), cli::box(this->columnNumber));
        return sb->ToString_1636a0751cb9ac11();
    }
    
}}
namespace System { namespace Diagnostics {
    
    
    void StackTrace::constructor() {
        init_frames(0, false);
    }
    
    void StackTrace::constructor(bool fNeedFileInfo) {
        init_frames(0, fNeedFileInfo);
    }
    
    void StackTrace::constructor(int32_t skipFrames) {
        init_frames(skipFrames, false);
    }
    
    void StackTrace::constructor(int32_t skipFrames, bool fNeedFileInfo) {
        init_frames(skipFrames, fNeedFileInfo);
    }
    
    void StackTrace::constructor(System::Exception* e) {
    }
    
    void StackTrace::constructor(System::Exception* e, bool fNeedFileInfo) {
    }
    
    void StackTrace::constructor(System::Exception* e, int32_t skipFrames) {
    }
    
    void StackTrace::constructor(System::Exception* e, int32_t skipFrames, bool fNeedFileInfo) {
    }
    
    void StackTrace::constructor(System::Exception* e, int32_t skipFrames, bool fNeedFileInfo, bool returnNativeFrames) {
        if((e ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("e"));
        }
        if((skipFrames < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("< 0"), _T("skipFrames"));
        }
        this->frames = get_trace(e, skipFrames, fNeedFileInfo);
        if(!(returnNativeFrames)) 
        {
            bool resize = false;
            for(int32_t i = 0; (i < this->frames->get_Length()); ++i) {
                if(System::Reflection::MethodBase::op_Equality2(this->frames->at(i)->GetMethod_c520bf4862e6a796(), nullptr)) 
                {
                    resize = true;
                }
            }
            if(resize) 
            {
                System::Collections::Generic::List<StackFrame*> *l = cli::gcnew<System::Collections::Generic::List<StackFrame*>>();
                for(int32_t i = 0; (i < this->frames->get_Length()); ++i) {
                    if(System::Reflection::MethodBase::op_Inequality2(this->frames->at(i)->GetMethod_c520bf4862e6a796(), nullptr)) 
                    {
                        l->Add(this->frames->at(i));
                    }
                }
                this->frames = l->ToArray();
            }
        }
    }
    
    void StackTrace::constructor(StackFrame* frame) {
        this->frames = (new cli::array<StackFrame*>(1));
        this->frames->at(0) = frame;
    }
    
    void StackTrace::constructor(System::Threading::Thread* targetThread, bool needFileInfo) {
        if((targetThread ==  System::Threading::Thread::get_CurrentThread())) 
        {
            init_frames(0, needFileInfo);
            return;
        }
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    void StackTrace::init_frames(int32_t skipFrames, bool fNeedFileInfo) {
        if((skipFrames < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("< 0"), _T("skipFrames"));
        }
        StackFrame *sf;
        System::Collections::Generic::List<StackFrame*> *l = cli::gcnew<System::Collections::Generic::List<StackFrame*>>();
        (skipFrames = skipFrames + 2);
        while((((sf = cli::gcnew<StackFrame>(skipFrames, fNeedFileInfo)) != (nullptr)) && System::Reflection::MethodBase::op_Inequality2(sf->GetMethod_c520bf4862e6a796(), nullptr))) {
            l->Add(sf);
            skipFrames++;
        };
        this->debug_info = fNeedFileInfo;
        this->frames = l->ToArray();
    }
    
    cli::array<StackFrame*>* StackTrace::get_trace(System::Exception* e, int32_t skipFrames, bool fNeedFileInfo) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    StackFrame* StackTrace::GetFrame_e0dab4b211315370(int32_t index) {
        if(((index < 0) || (index >= this->get_FrameCount_3360fc636a0e470d()))) 
        {
            return nullptr;
        }
        return this->frames->at(index);
    }
    
    cli::array<StackFrame*>* StackTrace::GetFrames_ffdb22808b4e738a() {
        return this->frames;
    }
    
    System::String* StackTrace::ToString_1636a0751cb9ac11() {
        System::String *newline = System::String::Format3(_T("{0}   {1} "), System::Environment::get_NewLine(), Locale::GetText(_T("at")));
        System::String *unknown = Locale::GetText(_T("<unknown method>"));
        System::String *debuginfo = Locale::GetText(_T(" in {0}:line {1}"));
        System::Text::StringBuilder *sb = cli::gcnew<System::Text::StringBuilder>();
        for(int32_t i = 0; (i < this->get_FrameCount_3360fc636a0e470d()); i++){
            StackFrame *frame = GetFrame_e0dab4b211315370(i);
            if((i > 0)) 
            {
                sb->Append2(newline);
            }
             else 
            {
                sb->AppendFormat3(_T("   {0} "), Locale::GetText(_T("at")));
            }
            System::Reflection::MethodBase *method = frame->GetMethod_c520bf4862e6a796();
            if(System::Reflection::MethodBase::op_Inequality2(method, nullptr)) 
            {
                sb->AppendFormat4(_T("{0}.{1}"), method->get_DeclaringType_6121cd6a84393166()->get_FullName_7e8fa72ba225e1a4(), method->get_Name_50fad5fa936c3ae2());
                sb->Append2(_T("("));
                cli::array<System::Reflection::ParameterInfo*> *p = method->GetParameters_9d17bcb549474c9();
                for(int32_t j = 0; (j < p->get_Length()); ++j){
                    if((j > 0)) 
                    {
                        sb->Append2(_T(", "));
                    }
                    System::Type *pt = p->at(j)->get_ParameterType_97c5fa09a0b988d();
                    bool byref = pt->get_IsByRef();
                    if(byref) 
                    {
                        pt = pt->GetElementType_ab5070dbbfe66f5f();
                    }
                    if((pt->get_IsClass() && System::String::op_Inequality(pt->get_Namespace_cb4ed37007083e7f(), System::String::Empty))) 
                    {
                        sb->Append2(pt->get_Namespace_cb4ed37007083e7f());
                        sb->Append2(_T("."));
                    }
                    sb->Append2(pt->get_Name_50fad5fa936c3ae2());
                    if(byref) 
                    {
                        sb->Append2(_T(" ByRef"));
                    }
                    sb->AppendFormat3(_T(" {0}"), p->at(j)->get_Name_1ad7a68577256740());
                }
                sb->Append2(_T(")"));
            }
             else 
            {
                sb->Append2(unknown);
            }
            if(this->debug_info) 
            {
                System::String *fname = frame->GetSecureFileName();
                if(System::String::op_Inequality(fname, _T("<filename unknown>"))) 
                {
                    sb->AppendFormat4(debuginfo, fname, cli::box(frame->GetFileLineNumber_55fe214715732be8()));
                }
            }
        }
        return sb->ToString_1636a0751cb9ac11();
    }
    
    int32_t StackTrace::get_FrameCount_3360fc636a0e470d() {
        return (this->frames ==  nullptr) ? 0 : this->frames->get_Length();
    }
    
}}
namespace System { namespace Diagnostics { namespace CodeAnalysis {
    
    
    void SuppressMessageAttribute::constructor(System::String* category, System::String* checkId) {
        this->category = category;
        this->checkId = checkId;
    }
    
    System::String* SuppressMessageAttribute::get_Category() {
        return this->category;
    }
    
    System::String* SuppressMessageAttribute::get_CheckId() {
        return this->checkId;
    }
    
    System::String* SuppressMessageAttribute::get_Justification() {
        return this->justification;
    }
    
    System::String* SuppressMessageAttribute::set_Justification(System::String* value) {
        this->justification = value;
        return get_Justification();
    }
    
    System::String* SuppressMessageAttribute::get_MessageId() {
        return this->messageId;
    }
    
    System::String* SuppressMessageAttribute::set_MessageId(System::String* value) {
        this->messageId = value;
        return get_MessageId();
    }
    
    System::String* SuppressMessageAttribute::get_Scope() {
        return this->scope;
    }
    
    System::String* SuppressMessageAttribute::set_Scope(System::String* value) {
        this->scope = value;
        return get_Scope();
    }
    
    System::String* SuppressMessageAttribute::get_Target() {
        return this->target;
    }
    
    System::String* SuppressMessageAttribute::set_Target(System::String* value) {
        this->target = value;
        return get_Target();
    }
    
}}}
namespace System { namespace Diagnostics { namespace Contracts {
    
    System::EventHandler2<ContractFailedEventArgs*>*  Contract::ContractFailed;
    
    System::Type* Contract::GetContractExceptionType() {
        return cli::typeof<System::Type>::info;
    }
    
    System::Type* Contract::GetContractShouldAssertExceptionType() {
        return cli::typeof<System::Type>::info;
    }
    
    void Contract::ReportFailure(ContractFailureKind kind, System::String* userMessage, System::String* conditionText, System::Exception* innerException) {
        System::String *msg = Internal::ContractHelper::RaiseContractFailedEvent(kind, userMessage, conditionText, innerException);
        if((msg != nullptr)) 
        {
            Internal::ContractHelper::TriggerFailure(kind, msg, userMessage, conditionText, innerException);
        }
    }
    
    void Contract::AssertMustUseRewriter(ContractFailureKind kind, System::String* message) {
        Internal::ContractHelper::TriggerFailure(kind, _T("Assembly must be re-written by the code contract rewritter"), nullptr, message, nullptr);
    }
    
    void Contract::Assert(bool condition) {
        if(condition) 
        {
            return;
        }
        ReportFailure(ContractFailureKind::Assert, nullptr, nullptr, nullptr);
    }
    
    void Contract::Assert2(bool condition, System::String* userMessage) {
        if(condition) 
        {
            return;
        }
        ReportFailure(ContractFailureKind::Assert, userMessage, nullptr, nullptr);
    }
    
    void Contract::Assume(bool condition) {
        if(condition) 
        {
            return;
        }
        ReportFailure(ContractFailureKind::Assume, nullptr, nullptr, nullptr);
    }
    
    void Contract::Assume2(bool condition, System::String* userMessage) {
        if(condition) 
        {
            return;
        }
        ReportFailure(ContractFailureKind::Assume, userMessage, nullptr, nullptr);
    }
    
    void Contract::EndContractBlock() {
    }
    
    void Contract::Ensures(bool condition) {
        AssertMustUseRewriter(ContractFailureKind::Postcondition, _T("Contract.Ensures"));
    }
    
    void Contract::Ensures2(bool condition, System::String* userMessage) {
        AssertMustUseRewriter(ContractFailureKind::Postcondition, _T("Contract.Ensures"));
    }
    
    bool Contract::Exists(int32_t fromInclusive, int32_t toExclusive, System::Predicate<int32_t>* predicate) {
        if((predicate ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("predicate"));
        }
        if((toExclusive < fromInclusive)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("toExclusitve < fromInclusive"));
        }
        for(int32_t i = fromInclusive; (i < toExclusive); i++) {
            if(predicate->Invoke(i)) 
            {
                return true;
            }
        }
        return false;
    }
    
    bool Contract::ForAll(int32_t fromInclusive, int32_t toExclusive, System::Predicate<int32_t>* predicate) {
        if((predicate ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("predicate"));
        }
        if((toExclusive < fromInclusive)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("toExclusitve < fromInclusive"));
        }
        for(int32_t i = fromInclusive; (i < toExclusive); i++) {
            if(!(predicate->Invoke(i))) 
            {
                return false;
            }
        }
        return true;
    }
    
    void Contract::Invariant(bool condition) {
        AssertMustUseRewriter(ContractFailureKind::Invariant, _T("Contract.Invariant"));
    }
    
    void Contract::Invariant2(bool condition, System::String* userMessage) {
        AssertMustUseRewriter(ContractFailureKind::Invariant, _T("Contract.Invariant"));
    }
    
    void Contract::Requires(bool condition) {
        AssertMustUseRewriter(ContractFailureKind::Precondition, _T("Contract.Requires"));
    }
    
    void Contract::Requires2(bool condition, System::String* userMessage) {
        AssertMustUseRewriter(ContractFailureKind::Precondition, _T("Contract.Requires"));
    }
    
    System::EventHandler2<ContractFailedEventArgs*>* Contract::get_InternalContractFailedEvent() {
        return ContractFailed;
    }
    
    void Contract::add_ContractFailed(System::EventHandler2<ContractFailedEventArgs*>* value) {
      // TODO: "Implement automatic events!"
    }
    
    void Contract::remove_ContractFailed(System::EventHandler2<ContractFailedEventArgs*>* value) {
      // TODO: "Implement automatic events!"
    }
    
}}}
namespace System { namespace Diagnostics { namespace Contracts {
    
    
    void ContractClassAttribute::constructor(System::Type* typeContainingContracts) {
        this->type = typeContainingContracts;
    }
    
    System::Type* ContractClassAttribute::get_TypeContainingContracts() {
        return this->type;
    }
    
}}}
namespace System { namespace Diagnostics { namespace Contracts {
    
    
    void ContractClassForAttribute::constructor(System::Type* typeContractsAreFor) {
        this->type = typeContractsAreFor;
    }
    
    System::Type* ContractClassForAttribute::get_TypeContractsAreFor() {
        return this->type;
    }
    
}}}
namespace System { namespace Diagnostics { namespace Contracts {
    
    
    void ContractException::constructor(System::String* failure, ContractFailureKind kind, System::String* condition, System::String* userMessage, System::Exception* innerException) {
        this->set_Failure(failure);
        this->set_Kind(kind);
        this->set_Condition(condition);
        this->set_UserMessage(userMessage);
    }
    
    System::String* ContractException::get_Failure() {
        return this->_Failure_k__BackingField;
    }
    
    System::String* ContractException::set_Failure(System::String* value) {
        this->_Failure_k__BackingField = value;
        return get_Failure();
    }
    
    ContractFailureKind ContractException::get_Kind() {
        return this->_Kind_k__BackingField;
    }
    
    ContractFailureKind ContractException::set_Kind(ContractFailureKind value) {
        this->_Kind_k__BackingField = value;
        return get_Kind();
    }
    
    System::String* ContractException::get_Condition() {
        return this->_Condition_k__BackingField;
    }
    
    System::String* ContractException::set_Condition(System::String* value) {
        this->_Condition_k__BackingField = value;
        return get_Condition();
    }
    
    System::String* ContractException::get_UserMessage() {
        return this->_UserMessage_k__BackingField;
    }
    
    System::String* ContractException::set_UserMessage(System::String* value) {
        this->_UserMessage_k__BackingField = value;
        return get_UserMessage();
    }
    
}}}
namespace System { namespace Diagnostics { namespace Contracts {
    
    
    void ContractFailedEventArgs::constructor(ContractFailureKind failureKind, System::String* message, System::String* condition, System::Exception* originalException) {
        this->set_Condition(condition);
        this->set_FailureKind(failureKind);
        this->set_Handled(false);
        this->set_Unwind(false);
        this->set_Message(message);
        this->set_OriginalException(originalException);
    }
    
    void ContractFailedEventArgs::SetHandled() {
        this->set_Handled(true);
    }
    
    void ContractFailedEventArgs::SetUnwind() {
        this->set_Unwind(true);
    }
    
    System::String* ContractFailedEventArgs::get_Condition() {
        return this->_Condition_k__BackingField;
    }
    
    System::String* ContractFailedEventArgs::set_Condition(System::String* value) {
        this->_Condition_k__BackingField = value;
        return get_Condition();
    }
    
    ContractFailureKind ContractFailedEventArgs::get_FailureKind() {
        return this->_FailureKind_k__BackingField;
    }
    
    ContractFailureKind ContractFailedEventArgs::set_FailureKind(ContractFailureKind value) {
        this->_FailureKind_k__BackingField = value;
        return get_FailureKind();
    }
    
    bool ContractFailedEventArgs::get_Handled() {
        return this->_Handled_k__BackingField;
    }
    
    bool ContractFailedEventArgs::set_Handled(bool value) {
        this->_Handled_k__BackingField = value;
        return get_Handled();
    }
    
    bool ContractFailedEventArgs::get_Unwind() {
        return this->_Unwind_k__BackingField;
    }
    
    bool ContractFailedEventArgs::set_Unwind(bool value) {
        this->_Unwind_k__BackingField = value;
        return get_Unwind();
    }
    
    System::String* ContractFailedEventArgs::get_Message() {
        return this->_Message_k__BackingField;
    }
    
    System::String* ContractFailedEventArgs::set_Message(System::String* value) {
        this->_Message_k__BackingField = value;
        return get_Message();
    }
    
    System::Exception* ContractFailedEventArgs::get_OriginalException() {
        return this->_OriginalException_k__BackingField;
    }
    
    System::Exception* ContractFailedEventArgs::set_OriginalException(System::Exception* value) {
        this->_OriginalException_k__BackingField = value;
        return get_OriginalException();
    }
    
}}}
namespace System { namespace Diagnostics { namespace Contracts {
    
    
    void ContractInvariantMethodAttribute::constructor() {
    }
    
}}}
namespace System { namespace Diagnostics { namespace Contracts {
    
    
    void ContractPublicPropertyNameAttribute::constructor(System::String* name) {
        this->name = name;
    }
    
    System::String* ContractPublicPropertyNameAttribute::get_Name() {
        return this->name;
    }
    
}}}
namespace System { namespace Diagnostics { namespace Contracts {
    
    
    void ContractReferenceAssemblyAttribute::constructor() {
    }
    
}}}
namespace System { namespace Diagnostics { namespace Contracts {
    
    
    void ContractRuntimeIgnoredAttribute::constructor() {
    }
    
}}}
namespace System { namespace Diagnostics { namespace Contracts {
    
    
    void ContractShouldAssertException::constructor(System::String* msg) {
    }
    
}}}
namespace System { namespace Diagnostics { namespace Contracts {
    
    
    void ContractVerificationAttribute::constructor(bool value) {
        this->val = value;
    }
    
    bool ContractVerificationAttribute::get_Value() {
        return this->val;
    }
    
}}}
namespace System { namespace Diagnostics { namespace Contracts {
    
    
    void PureAttribute::constructor() {
    }
    
}}}
namespace System { namespace Diagnostics { namespace Contracts { namespace Internal {
    
    
    System::String* ContractHelper::RaiseContractFailedEvent(System::Diagnostics::Contracts::ContractFailureKind failureKind, System::String* userMessage, System::String* conditionText, System::Exception* innerException) {
        System::Text::StringBuilder *msg = cli::gcnew<System::Text::StringBuilder>(60);
        switch(failureKind) {
            case System::Diagnostics::Contracts::ContractFailureKind::Assert: case_959: {
                msg->Append2(_T("Assertion failed"));
                break;
            }
            case System::Diagnostics::Contracts::ContractFailureKind::Assume: case_960: {
                msg->Append2(_T("Assumption failed"));
                break;
            }
            case System::Diagnostics::Contracts::ContractFailureKind::Invariant: case_961: {
                msg->Append2(_T("Invariant failed"));
                break;
            }
            case System::Diagnostics::Contracts::ContractFailureKind::Postcondition: case_962: {
                msg->Append2(_T("Postcondition failed"));
                break;
            }
            case System::Diagnostics::Contracts::ContractFailureKind::PostconditionOnException: case_963: {
                msg->Append2(_T("Postcondition failed after throwing an exception"));
                break;
            }
            case System::Diagnostics::Contracts::ContractFailureKind::Precondition: case_964: {
                msg->Append2(_T("Precondition failed"));
                break;
            }
            default: case_965: {
                throw cli::gcnew<System::NotSupportedException>(cli::concat(_T("Not supported: "), cli::box(failureKind)));
            }
        }
        if((conditionText != nullptr)) 
        {
            msg->Append2(_T(": "));
            msg->Append2(conditionText);
        }
         else 
        {
            msg->Append16(u'.');
        }
        if((userMessage != nullptr)) 
        {
            msg->Append2(_T("  "));
            msg->Append2(userMessage);
        }
        System::String *msgString = msg->ToString_1636a0751cb9ac11();
        System::Exception *handlerException = nullptr;
        bool unwind = false, handled = false;
        System::EventHandler2<System::Diagnostics::Contracts::ContractFailedEventArgs*> *contractFailed = System::Diagnostics::Contracts::Contract::get_InternalContractFailedEvent();
        if((contractFailed != nullptr)) 
        {
            cli::array<System::Delegate*> *handlers = contractFailed->GetInvocationList_8fef0390be027d95();
            System::Diagnostics::Contracts::ContractFailedEventArgs *e = cli::gcnew<System::Diagnostics::Contracts::ContractFailedEventArgs>(failureKind, msgString, conditionText, innerException);
            for(auto tmp_211 : handlers) {
                auto handler = cli::cast<System::Delegate*>(tmp_211);
                {
                    try {
                        handler->DynamicInvoke((new cli::array<System::Object*>({nullptr, e})));
                    }
                    catch(System::Exception* ex) {
                        e->SetUnwind();
                        handlerException = ex->get_InnerException();
                    }
                }
            }
            unwind = e->get_Unwind();
            handled = e->get_Handled();
        }
        if(unwind) 
        {
            System::Exception *ex = ([&]() {
                System::Exception* tmp_212 = innerException;
                if(tmp_212 == nullptr) {
                    return handlerException;
                } else
                    return tmp_212;
            })();
            throw cli::gcnew<System::Diagnostics::Contracts::ContractException>(msgString, failureKind, conditionText, userMessage, ex);
        }
        return handled ? nullptr : msgString;
    }
    
    void ContractHelper::TriggerFailure(System::Diagnostics::Contracts::ContractFailureKind kind, System::String* displayMessage, System::String* userMessage, System::String* conditionText, System::Exception* innerException) {
        System::Text::StringBuilder *msg = cli::gcnew<System::Text::StringBuilder>(50);
        if((conditionText != nullptr)) 
        {
            msg->Append2(_T("Expression: "));
            msg->AppendLine2(conditionText);
        }
        msg->Append2(_T("Description: "));
        if((displayMessage != nullptr)) 
        {
            msg->Append2(displayMessage);
        }
        if(System::Environment::get_UserInteractive()) 
        {
            throw cli::gcnew<System::Diagnostics::Contracts::ContractShouldAssertException>(msg->ToString_1636a0751cb9ac11());
        }
         else 
        {
            System::Environment::FailFast(msg->ToString_1636a0751cb9ac11());
        }
    }
    
}}}}
namespace System { namespace Diagnostics { namespace SymbolStore {
    
    System::Guid  SymDocumentType::Text;
    
    void SymDocumentType::constructor() {
    }
    
}}}
namespace System { namespace Diagnostics { namespace SymbolStore {
    
    System::Guid  SymLanguageType::Basic;
    System::Guid  SymLanguageType::C;
    System::Guid  SymLanguageType::Cobol;
    System::Guid  SymLanguageType::CPlusPlus;
    System::Guid  SymLanguageType::CSharp;
    System::Guid  SymLanguageType::ILAssembly;
    System::Guid  SymLanguageType::Java;
    System::Guid  SymLanguageType::JScript;
    System::Guid  SymLanguageType::MCPlusPlus;
    System::Guid  SymLanguageType::Pascal;
    System::Guid  SymLanguageType::SMC;
    
    void SymLanguageType::constructor() {
    }
    
}}}
namespace System { namespace Diagnostics { namespace SymbolStore {
    
    System::Guid  SymLanguageVendor::Microsoft;
    
    void SymLanguageVendor::constructor() {
    }
    
}}}
namespace System { namespace Globalization {
    
    
    void Calendar::constructor() {
        this->twoDigitYearMax = 99;
    }
    
    System::String* Calendar::M_ValidValues(System::Object* a, System::Object* b) {
        System::IO::StringWriter *sw = cli::gcnew<System::IO::StringWriter>();
        sw->Write_d1ec280d8f085d73(_T("Valid values are between {0} and {1}, inclusive."), a, b);
        return sw->ToString_1636a0751cb9ac11();
    }
    
    void Calendar::M_ArgumentInRange(System::String* param, int32_t arg, int32_t a, int32_t b) {
        if(((a <= arg) && (arg <= b))) 
        {
            return;
        }
        throw cli::gcnew<System::ArgumentOutOfRangeException>(param, M_ValidValues(cli::box(a), cli::box(b)));
    }
    
    void Calendar::M_CheckHMSM(int32_t hour, int32_t minute, int32_t second, int32_t milliseconds) {
        M_ArgumentInRange(_T("hour"), hour, 0, 23);
        M_ArgumentInRange(_T("minute"), minute, 0, 59);
        M_ArgumentInRange(_T("second"), second, 0, 59);
        M_ArgumentInRange(_T("milliseconds"), milliseconds, 0, 999999);
    }
    
    System::Object* Calendar::Clone_15536a878f1b8fa9() {
        Calendar *c = cli::cast<Calendar*>(System::Object::MemberwiseClone());
        c->m_isReadOnly = false;
        return c;
    }
    
    int32_t Calendar::GetLeapMonth_702af567932b9b18(int32_t year) {
        return GetLeapMonth_fb3256a34d84f7ed(year, GetEra_1d16c3456dce785e(ToDateTime_1fb5be79b550c0bc(year, 1, 1, 0, 0, 0, 0)));
    }
    
    int32_t Calendar::GetLeapMonth_fb3256a34d84f7ed(int32_t year, int32_t era) {
        int32_t max = GetMonthsInYear_2ae36c9a94a7bffb(year, era);
        for(int32_t i = 1; (i <= max); i++) {
            if(IsLeapMonth_85b9917f2bdaeef7(year, i, era)) 
            {
                return i;
            }
        }
        return 0;
    }
    
    Calendar* Calendar::ReadOnly(Calendar* calendar) {
        if(calendar->m_isReadOnly) 
        {
            return calendar;
        }
        Calendar *c = cli::cast<Calendar*>(calendar->Clone_15536a878f1b8fa9());
        c->m_isReadOnly = true;
        return c;
    }
    
    void Calendar::CheckReadOnly() {
        if(this->m_isReadOnly) 
        {
            throw cli::gcnew<System::InvalidOperationException>(_T("This Calendar is read-only."));
        }
    }
    
    void Calendar::M_CheckYE_c830e88539d38d64(int32_t year, int32_t era) {
    }
    
    System::DateTime Calendar::AddDays_a5cc6f493e3eba66(System::DateTime time, int32_t days) {
        return time->Add(System::TimeSpan::FromDays((double)(days)));
    }
    
    System::DateTime Calendar::AddHours_7f68cf2ff908d7f0(System::DateTime time, int32_t hours) {
        return time->Add(System::TimeSpan::FromHours((double)(hours)));
    }
    
    System::DateTime Calendar::AddMilliseconds_ffe5aa206bba766d(System::DateTime time, double milliseconds) {
        return time->Add(System::TimeSpan::FromMilliseconds(milliseconds));
    }
    
    System::DateTime Calendar::AddMinutes_983d6711183cba1(System::DateTime time, int32_t minutes) {
        return time->Add(System::TimeSpan::FromMinutes((double)(minutes)));
    }
    
    System::DateTime Calendar::AddSeconds_f797ca31880c3704(System::DateTime time, int32_t seconds) {
        return time->Add(System::TimeSpan::FromSeconds((double)(seconds)));
    }
    
    System::DateTime Calendar::AddWeeks_6f66c2c4109c30c4(System::DateTime time, int32_t weeks) {
        return time->AddDays((double)((weeks * this->get_M_DaysInWeek_2053f6f90ba9f109())));
    }
    
    int32_t Calendar::GetDaysInMonth_432b8c940d2032fb(int32_t year, int32_t month) {
        return GetDaysInMonth_233a2cea4d4c72fe(year, month, 0);
    }
    
    int32_t Calendar::GetDaysInYear_ae45f36c8a3dcc91(int32_t year) {
        return GetDaysInYear_ae0f8cfee3ff2567(year, 0);
    }
    
    int32_t Calendar::GetHour_9084e1b608d42a3a(System::DateTime time) {
        return time->get_TimeOfDay()->get_Hours();
    }
    
    double Calendar::GetMilliseconds_6b6709567ed09a5(System::DateTime time) {
        return (double)(time->get_TimeOfDay()->get_Milliseconds());
    }
    
    int32_t Calendar::GetMinute_42f1da20fb6e9d3f(System::DateTime time) {
        return time->get_TimeOfDay()->get_Minutes();
    }
    
    int32_t Calendar::GetMonthsInYear_ccc452060ce28ee9(int32_t year) {
        return GetMonthsInYear_2ae36c9a94a7bffb(year, 0);
    }
    
    int32_t Calendar::GetSecond_8bfa984d0b9c4f(System::DateTime time) {
        return time->get_TimeOfDay()->get_Seconds();
    }
    
    int32_t Calendar::M_DiffDays(System::DateTime timeA, System::DateTime timeB) {
        int64_t diff = (timeA->get_Ticks() - timeB->get_Ticks());
        if((diff >= 0L)) 
        {
            return (int32_t)(diff / 864000000000L);
        }
        (diff = diff + 1L);
        return (-1 + (int32_t)(diff / 864000000000L));
    }
    
    System::DateTime Calendar::M_GetFirstDayOfSecondWeekOfYear(int32_t year, CalendarWeekRule rule, System::DayOfWeek firstDayOfWeek) {
        System::DateTime d1 = ToDateTime_1fb5be79b550c0bc(year, 1, 1, 0, 0, 0, 0);
        int32_t dow1 = (int32_t)(GetDayOfWeek_4c0b69c7bb83520e(d1));
        int32_t fdow = (int32_t)(firstDayOfWeek);
        int32_t d = 0;
        switch(rule) {
            case CalendarWeekRule::FirstDay: case_966: {
                if((fdow > dow1)) 
                {
                    (d = d + (fdow - dow1));
                }
                 else 
                {
                    (d = d + ((fdow + this->get_M_DaysInWeek_2053f6f90ba9f109()) - dow1));
                }
                break;
            }
            case CalendarWeekRule::FirstFullWeek: case_967: {
                d = this->get_M_DaysInWeek_2053f6f90ba9f109();
                if((fdow >= dow1)) 
                {
                    (d = d + (fdow - dow1));
                }
                 else 
                {
                    (d = d + ((fdow + this->get_M_DaysInWeek_2053f6f90ba9f109()) - dow1));
                }
                break;
            }
            case CalendarWeekRule::FirstFourDayWeek: case_968: {
                int32_t dow4 = ((dow1 + 3) % this->get_M_DaysInWeek_2053f6f90ba9f109());
                d = 3;
                if((fdow > dow4)) 
                {
                    (d = d + (fdow - dow4));
                }
                 else 
                {
                    (d = d + ((fdow + this->get_M_DaysInWeek_2053f6f90ba9f109()) - dow4));
                }
                break;
            }
        }
        return AddDays_a5cc6f493e3eba66(d1, d);
    }
    
    int32_t Calendar::GetWeekOfYear_d25712e900e29bec(System::DateTime time, CalendarWeekRule rule, System::DayOfWeek firstDayOfWeek) {
        if((((int32_t)(firstDayOfWeek) < 0) || (6 < (int32_t)(firstDayOfWeek)))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("firstDayOfWeek"), _T("Value is not a valid day of week."));
        }
        int32_t year = GetYear_75c1b17aa90af360(time);
        int32_t days;
        while(true) {
            System::DateTime secondWeek = M_GetFirstDayOfSecondWeekOfYear(year, rule, firstDayOfWeek);
            days = (M_DiffDays(time, secondWeek) + this->get_M_DaysInWeek_2053f6f90ba9f109());
            if((days >= 0)) 
            {
                break;
            }
            (year = year - 1);
        }
        return (1 + (days / this->get_M_DaysInWeek_2053f6f90ba9f109()));
    }
    
    bool Calendar::IsLeapDay_2231fa71c75fa310(int32_t year, int32_t month, int32_t day) {
        return IsLeapDay_7c795c9f36944ade(year, month, day, 0);
    }
    
    bool Calendar::IsLeapMonth_8cd2a3d21440e57e(int32_t year, int32_t month) {
        return IsLeapMonth_85b9917f2bdaeef7(year, month, 0);
    }
    
    bool Calendar::IsLeapYear_59be46b16a9b7a45(int32_t year) {
        return IsLeapYear_7aad026a1103cfb(year, 0);
    }
    
    System::DateTime Calendar::ToDateTime_1fb5be79b550c0bc(int32_t year, int32_t month, int32_t day, int32_t hour, int32_t minute, int32_t second, int32_t millisecond) {
        return ToDateTime_82b4ff6780819fcd(year, month, day, hour, minute, second, millisecond, 0);
    }
    
    int32_t Calendar::ToFourDigitYear_cb92a104112b3121(int32_t year) {
        if((year < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("year"), _T("Non-negative number required."));
        }
        if((year <= 99)) 
        {
            int32_t year2 = (this->get_TwoDigitYearMax_14e9789b3d89e801() % 100);
            int32_t d = (year - year2);
            year = ((this->get_TwoDigitYearMax_14e9789b3d89e801() + d) + (d <= 0) ? 0 : -100);
        }
        int32_t era = 0;
        M_CheckYE_c830e88539d38d64(year, era);
        return year;
    }
    
    int32_t Calendar::get_M_DaysInWeek_2053f6f90ba9f109() {
        return 7;
    }
    
    CalendarAlgorithmType Calendar::get_AlgorithmType_1e3f8ed99adb8bde() {
        return CalendarAlgorithmType::Unknown;
    }
    
    System::DateTime Calendar::get_MaxSupportedDateTime_7bc53f690ae04821() {
        return (*System::DateTime::MaxValue);
    }
    
    System::DateTime Calendar::get_MinSupportedDateTime_63cdcad9cf7fca4e() {
        return (*System::DateTime::MinValue);
    }
    
    bool Calendar::get_IsReadOnly() {
        return this->m_isReadOnly;
    }
    
    int32_t Calendar::get_M_MaxYear_b3d9776fced847fe() {
        if((this->M_MaxYearValue ==  0)) 
        {
            this->M_MaxYearValue = GetYear_75c1b17aa90af360((*System::DateTime::MaxValue));
        }
        return this->M_MaxYearValue;
    }
    
    int32_t Calendar::get_TwoDigitYearMax_14e9789b3d89e801() {
        return this->twoDigitYearMax;
    }
    
    int32_t Calendar::set_TwoDigitYearMax_4852e071586288ab(int32_t value) {
        CheckReadOnly();
        M_ArgumentInRange(_T("year"), value, 100, this->get_M_MaxYear_b3d9776fced847fe());
        int32_t era = 0;
        M_CheckYE_c830e88539d38d64(value, era);
        this->twoDigitYearMax = value;
        return get_TwoDigitYearMax_14e9789b3d89e801();
    }
    
    cli::array<System::String*>* Calendar::get_AbbreviatedEraNames() {
        if(((this->M_AbbrEraNames ==  nullptr) || (this->M_AbbrEraNames->get_Length() != this->get_Eras_91b8aa89b8256658()->get_Length()))) 
        {
            throw cli::gcnew<System::Exception>(_T("Internal: M_AbbrEraNames wrong initialized!"));
        }
        return cli::cast<cli::array<System::String*>*>(cli::import(this->M_AbbrEraNames)->Clone());
    }
    
    cli::array<System::String*>* Calendar::set_AbbreviatedEraNames(cli::array<System::String*>* value) {
        CheckReadOnly();
        if((value->get_Length() != this->get_Eras_91b8aa89b8256658()->get_Length())) 
        {
            System::IO::StringWriter *sw = cli::gcnew<System::IO::StringWriter>();
            sw->Write_f2bf6875dbaeba6a(_T("Array length must be equal Eras length {0}."), cli::box(this->get_Eras_91b8aa89b8256658()->get_Length()));
            throw cli::gcnew<System::ArgumentException>(sw->ToString_1636a0751cb9ac11());
        }
        this->M_AbbrEraNames = cli::cast<cli::array<System::String*>*>(cli::import(value)->Clone());
        return get_AbbreviatedEraNames();
    }
    
    cli::array<System::String*>* Calendar::get_EraNames() {
        if(((this->M_EraNames ==  nullptr) || (this->M_EraNames->get_Length() != this->get_Eras_91b8aa89b8256658()->get_Length()))) 
        {
            throw cli::gcnew<System::Exception>(_T("Internal: M_EraNames not initialized!"));
        }
        return cli::cast<cli::array<System::String*>*>(cli::import(this->M_EraNames)->Clone());
    }
    
    cli::array<System::String*>* Calendar::set_EraNames(cli::array<System::String*>* value) {
        CheckReadOnly();
        if((value->get_Length() != this->get_Eras_91b8aa89b8256658()->get_Length())) 
        {
            System::IO::StringWriter *sw = cli::gcnew<System::IO::StringWriter>();
            sw->Write_f2bf6875dbaeba6a(_T("Array length must be equal Eras length {0}."), cli::box(this->get_Eras_91b8aa89b8256658()->get_Length()));
            throw cli::gcnew<System::ArgumentException>(sw->ToString_1636a0751cb9ac11());
        }
        this->M_EraNames = cli::cast<cli::array<System::String*>*>(cli::import(value)->Clone());
        return get_EraNames();
    }
    
}}
namespace System { namespace Globalization {
    
    
    double CCMath::round(double x) {
        return System::Math::Floor((x + 0.5));
    }
    
    double CCMath::mod(double x, double y) {
        return (x - (y * System::Math::Floor((x / y))));
    }
    
    int32_t CCMath::div(int32_t x, int32_t y) {
        return (int32_t)System::Math::Floor(((double)(x) / (double)(y)));
    }
    
    int32_t CCMath::mod2(int32_t x, int32_t y) {
        return (x - (y * div(x, y)));
    }
    
    int32_t CCMath::div_mod(int32_t remainder, int32_t x, int32_t y) {
        int32_t d = div(x, y);
        remainder = (x - (y * d));
        return d;
    }
    
    int32_t CCMath::signum(double x) {
        if((x < std::numeric_limits<double>::epsilon())) 
        {
            return -1;
        }
        if((x ==  std::numeric_limits<double>::epsilon())) 
        {
            return 0;
        }
        return 1;
    }
    
    int32_t CCMath::signum2(int32_t x) {
        if((x < 0)) 
        {
            return -1;
        }
        if((x ==  0)) 
        {
            return 0;
        }
        return 1;
    }
    
    double CCMath::amod(double x, double y) {
        double d = mod(x, y);
        return (d ==  std::numeric_limits<double>::epsilon()) ? y : d;
    }
    
    int32_t CCMath::amod2(int32_t x, int32_t y) {
        int32_t i = mod2(x, y);
        return (i ==  0) ? y : i;
    }
    
}}
namespace System { namespace Globalization {
    
    
    System::DateTime CCFixed::ToDateTime(int32_t date) {
        int64_t ticks = ((int64_t)((date - 1)) * 864000000000L);
        return cli::ctor<System::DateTime>(ticks);
    }
    
    System::DateTime CCFixed::ToDateTime2(int32_t date, int32_t hour, int32_t minute, int32_t second, double milliseconds) {
        System::DateTime time = ToDateTime(date);
        time = time->AddHours((double)(hour));
        time = time->AddMinutes((double)(minute));
        time = time->AddSeconds((double)(second));
        return time->AddMilliseconds(milliseconds);
    }
    
    int32_t CCFixed::FromDateTime(System::DateTime time) {
        return (1 + (int32_t)(time->get_Ticks() / 864000000000L));
    }
    
    System::DayOfWeek CCFixed::day_of_week(int32_t date) {
        return (System::DayOfWeek)(CCMath::mod2(date, 7));
    }
    
    int32_t CCFixed::kday_on_or_before(int32_t date, int32_t k) {
        return (date - (int32_t)(day_of_week((date - k))));
    }
    
    int32_t CCFixed::kday_on_or_after(int32_t date, int32_t k) {
        return kday_on_or_before((date + 6), k);
    }
    
    int32_t CCFixed::kd_nearest(int32_t date, int32_t k) {
        return kday_on_or_before((date + 3), k);
    }
    
    int32_t CCFixed::kday_after(int32_t date, int32_t k) {
        return kday_on_or_before((date + 7), k);
    }
    
    int32_t CCFixed::kday_before(int32_t date, int32_t k) {
        return kday_on_or_before((date - 1), k);
    }
    
}}
namespace System { namespace Globalization {
    
    
    bool CCGregorianCalendar::is_leap_year(int32_t year) {
        if((CCMath::mod2(year, 4) != 0)) 
        {
            return false;
        }
        switch(CCMath::mod2(year, 400)) {
            case 100: case_969: {
                return false;
            }
            case 200: case_970: {
                return false;
            }
            case 300: case_971: {
                return false;
            }
        }
        return true;
    }
    
    int32_t CCGregorianCalendar::fixed_from_dmy(int32_t day, int32_t month, int32_t year) {
        int32_t k = 0;
        (k = k + (365 * (year - 1)));
        (k = k + CCMath::div((year - 1), 4));
        (k = k - CCMath::div((year - 1), 100));
        (k = k + CCMath::div((year - 1), 400));
        (k = k + CCMath::div(((367 * month) - 362), 12));
        if((month > 2)) 
        {
            (k = k + is_leap_year(year) ? -1 : -2);
        }
        (k = k + day);
        return k;
    }
    
    int32_t CCGregorianCalendar::year_from_fixed(int32_t date) {
        int32_t d = (date - 1);
        int32_t n_400 = CCMath::div_mod(d, d, 146097);
        int32_t n_100 = CCMath::div_mod(d, d, 36524);
        int32_t n_4 = CCMath::div_mod(d, d, 1461);
        int32_t n_1 = CCMath::div(d, 365);
        int32_t year = ((((400 * n_400) + (100 * n_100)) + (4 * n_4)) + n_1);
        return ((n_100 ==  4) || (n_1 ==  4)) ? year : (year + 1);
    }
    
    void CCGregorianCalendar::my_from_fixed(int32_t month, int32_t year, int32_t date) {
        year = year_from_fixed(date);
        int32_t prior_days = (date - fixed_from_dmy(1, 1, year));
        int32_t correction;
        if((date < fixed_from_dmy(1, 3, year))) 
        {
            correction = 0;
        }
         else 
        {
            if(is_leap_year(year)) 
            {
                correction = 1;
            }
             else 
            {
                correction = 2;
            }
        }
        month = CCMath::div(((12 * (prior_days + correction)) + 373), 367);
    }
    
    void CCGregorianCalendar::dmy_from_fixed(int32_t day, int32_t month, int32_t year, int32_t date) {
        my_from_fixed(month, year, date);
        day = ((date - fixed_from_dmy(1, month, year)) + 1);
    }
    
    int32_t CCGregorianCalendar::month_from_fixed(int32_t date) {
        int32_t month, year;
        my_from_fixed(month, year, date);
        return month;
    }
    
    int32_t CCGregorianCalendar::day_from_fixed(int32_t date) {
        int32_t day, month, year;
        dmy_from_fixed(day, month, year, date);
        return day;
    }
    
    int32_t CCGregorianCalendar::date_difference(int32_t dayA, int32_t monthA, int32_t yearA, int32_t dayB, int32_t monthB, int32_t yearB) {
        return (fixed_from_dmy(dayB, monthB, yearB) - fixed_from_dmy(dayA, monthA, yearA));
    }
    
    int32_t CCGregorianCalendar::day_number(int32_t day, int32_t month, int32_t year) {
        return date_difference(31, 12, (year - 1), day, month, year);
    }
    
    int32_t CCGregorianCalendar::days_remaining(int32_t day, int32_t month, int32_t year) {
        return date_difference(day, month, year, 31, 12, year);
    }
    
    System::DateTime CCGregorianCalendar::AddMonths(System::DateTime time, int32_t months) {
        int32_t rd = CCFixed::FromDateTime(time);
        int32_t day, month, year;
        dmy_from_fixed(day, month, year, rd);
        (month = month + months);
        (year = year + CCMath::div_mod(month, month, 12));
        int32_t maxday = GetDaysInMonth(year, month);
        if((day > maxday)) 
        {
            day = maxday;
        }
        rd = fixed_from_dmy(day, month, year);
        System::DateTime t = CCFixed::ToDateTime(rd);
        return t->Add(time->get_TimeOfDay());
    }
    
    System::DateTime CCGregorianCalendar::AddYears(System::DateTime time, int32_t years) {
        int32_t rd = CCFixed::FromDateTime(time);
        int32_t day, month, year;
        dmy_from_fixed(day, month, year, rd);
        (year = year + years);
        int32_t maxday = GetDaysInMonth(year, month);
        if((day > maxday)) 
        {
            day = maxday;
        }
        rd = fixed_from_dmy(day, month, year);
        System::DateTime t = CCFixed::ToDateTime(rd);
        return t->Add(time->get_TimeOfDay());
    }
    
    int32_t CCGregorianCalendar::GetDayOfMonth(System::DateTime time) {
        return day_from_fixed(CCFixed::FromDateTime(time));
    }
    
    int32_t CCGregorianCalendar::GetDayOfYear(System::DateTime time) {
        int32_t rd = CCFixed::FromDateTime(time);
        int32_t year = year_from_fixed(rd);
        int32_t rd1_1 = fixed_from_dmy(1, 1, year);
        return ((rd - rd1_1) + 1);
    }
    
    int32_t CCGregorianCalendar::GetDaysInMonth(int32_t year, int32_t month) {
        int32_t rd1 = fixed_from_dmy(1, month, year);
        int32_t rd2 = fixed_from_dmy(1, (month + 1), year);
        return (rd2 - rd1);
    }
    
    int32_t CCGregorianCalendar::GetDaysInYear(int32_t year) {
        int32_t rd1 = fixed_from_dmy(1, 1, year);
        int32_t rd2 = fixed_from_dmy(1, 1, (year + 1));
        return (rd2 - rd1);
    }
    
    int32_t CCGregorianCalendar::GetMonth(System::DateTime time) {
        return month_from_fixed(CCFixed::FromDateTime(time));
    }
    
    int32_t CCGregorianCalendar::GetYear(System::DateTime time) {
        return year_from_fixed(CCFixed::FromDateTime(time));
    }
    
    bool CCGregorianCalendar::IsLeapDay(int32_t year, int32_t month, int32_t day) {
        return ((is_leap_year(year) && (month ==  2)) && (day ==  29));
    }
    
    System::DateTime CCGregorianCalendar::ToDateTime(int32_t year, int32_t month, int32_t day, int32_t hour, int32_t minute, int32_t second, int32_t milliseconds) {
        return CCFixed::ToDateTime2(fixed_from_dmy(day, month, year), hour, minute, second, (double)(milliseconds));
    }
    
}}
namespace System { namespace Globalization {
    
    
    bool CCJulianCalendar::is_leap_year(int32_t year) {
        return (CCMath::mod2(year, 4) ==  (year > 0) ? 0 : 3);
    }
    
    int32_t CCJulianCalendar::fixed_from_dmy(int32_t day, int32_t month, int32_t year) {
        int32_t y = (year < 0) ? (year + 1) : year;
        int32_t k = -2;
        (k = k + (365 * (y - 1)));
        (k = k + CCMath::div((y - 1), 4));
        (k = k + CCMath::div(((367 * month) - 362), 12));
        if((month > 2)) 
        {
            (k = k + is_leap_year(year) ? -1 : -2);
        }
        (k = k + day);
        return k;
    }
    
    int32_t CCJulianCalendar::year_from_fixed(int32_t date) {
        int32_t approx = CCMath::div(((4 * (date - -1)) + 1464), 1461);
        return (approx <= 0) ? (approx - 1) : approx;
    }
    
    void CCJulianCalendar::my_from_fixed(int32_t month, int32_t year, int32_t date) {
        year = year_from_fixed(date);
        int32_t prior_days = (date - fixed_from_dmy(1, 1, year));
        int32_t correction;
        if((date < fixed_from_dmy(1, 3, year))) 
        {
            correction = 0;
        }
         else 
        {
            if(is_leap_year(year)) 
            {
                correction = 1;
            }
             else 
            {
                correction = 2;
            }
        }
        month = CCMath::div(((12 * (prior_days + correction)) + 373), 367);
    }
    
    void CCJulianCalendar::dmy_from_fixed(int32_t day, int32_t month, int32_t year, int32_t date) {
        my_from_fixed(month, year, date);
        day = ((date - fixed_from_dmy(1, month, year)) + 1);
    }
    
    int32_t CCJulianCalendar::month_from_fixed(int32_t date) {
        int32_t month, year;
        my_from_fixed(month, year, date);
        return month;
    }
    
    int32_t CCJulianCalendar::day_from_fixed(int32_t date) {
        int32_t day;
        int32_t month;
        int32_t year;
        dmy_from_fixed(day, month, year, date);
        return day;
    }
    
    int32_t CCJulianCalendar::date_difference(int32_t dayA, int32_t monthA, int32_t yearA, int32_t dayB, int32_t monthB, int32_t yearB) {
        return (fixed_from_dmy(dayB, monthB, yearB) - fixed_from_dmy(dayA, monthA, yearA));
    }
    
    int32_t CCJulianCalendar::day_number(int32_t day, int32_t month, int32_t year) {
        return date_difference(31, 12, (year - 1), day, month, year);
    }
    
    int32_t CCJulianCalendar::days_remaining(int32_t day, int32_t month, int32_t year) {
        return date_difference(day, month, year, 31, 12, year);
    }
    
}}
namespace System { namespace Globalization {
    
    
    bool CCHebrewCalendar::is_leap_year(int32_t year) {
        return (CCMath::mod2(((7 * year) + 1), 19) < 7);
    }
    
    int32_t CCHebrewCalendar::last_month_of_year(int32_t year) {
        return is_leap_year(year) ? 13 : 12;
    }
    
    int32_t CCHebrewCalendar::elapsed_days(int32_t year) {
        int32_t months_elapsed = CCMath::div(((235 * year) - 234), 19);
        int32_t r;
        int32_t d = CCMath::div_mod(r, months_elapsed, 1080);
        int32_t parts_elapsed = (204 + (793 * r));
        int32_t hours_elapsed = (((11 + (12 * months_elapsed)) + (793 * d)) + CCMath::div(parts_elapsed, 1080));
        int32_t day = ((29 * months_elapsed) + CCMath::div(hours_elapsed, 24));
        if((CCMath::mod2((3 * (day + 1)), 7) < 3)) 
        {
            (day = day + 1);
        }
        return day;
    }
    
    int32_t CCHebrewCalendar::new_year_delay(int32_t year) {
        int32_t ny1 = elapsed_days(year);
        int32_t ny2 = elapsed_days((year + 1));
        if(((ny2 - ny1) ==  356)) 
        {
            return 2;
        }
        int32_t ny0 = elapsed_days((year - 1));
        if(((ny1 - ny0) ==  382)) 
        {
            return 1;
        }
        return 0;
    }
    
    int32_t CCHebrewCalendar::last_day_of_month(int32_t month, int32_t year) {
        if(((month < 1) || (month > 13))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("month"), _T("Month should be between One and Thirteen."));
        }
        switch(month) {
            case 2: case_972: {
                return 29;
            }
            case 4: case_973: {
                return 29;
            }
            case 6: case_974: {
                return 29;
            }
            case 8: case_975: {
                if(!(long_heshvan(year))) 
                {
                    return 29;
                }
                break;
            }
            case 9: case_976: {
                if(short_kislev(year)) 
                {
                    return 29;
                }
                break;
            }
            case 10: case_977: {
                return 29;
            }
            case 12: case_978: {
                if(!(is_leap_year(year))) 
                {
                    return 29;
                }
                break;
            }
            case 13: case_979: {
                return 29;
            }
        }
        return 30;
    }
    
    bool CCHebrewCalendar::long_heshvan(int32_t year) {
        return (CCMath::mod2(days_in_year(year), 10) ==  5);
    }
    
    bool CCHebrewCalendar::short_kislev(int32_t year) {
        return (CCMath::mod2(days_in_year(year), 10) ==  3);
    }
    
    int32_t CCHebrewCalendar::days_in_year(int32_t year) {
        return (fixed_from_dmy(1, 7, (year + 1)) - fixed_from_dmy(1, 7, year));
    }
    
    int32_t CCHebrewCalendar::fixed_from_dmy(int32_t day, int32_t month, int32_t year) {
        int32_t m;
        int32_t k = -1373428;
        (k = k + elapsed_days(year));
        (k = k + new_year_delay(year));
        if((month < 7)) 
        {
            int32_t l = last_month_of_year(year);
            for(m = 7; (m <= l); m++){
                (k = k + last_day_of_month(m, year));
            }
            for(m = 1; (m < month); m++){
                (k = k + last_day_of_month(m, year));
            }
        }
         else 
        {
            for(m = 7; (m < month); m++){
                (k = k + last_day_of_month(m, year));
            }
        }
        (k = k + day);
        return k;
    }
    
    int32_t CCHebrewCalendar::year_from_fixed(int32_t date) {
        int32_t approx = (int32_t)System::Math::Floor(((double)((date - -1373427)) / 365.246822205978));
        int32_t y;
        for(y = approx; (date >= fixed_from_dmy(1, 7, y)); y++){
        }
        return (y - 1);
    }
    
    void CCHebrewCalendar::my_from_fixed(int32_t month, int32_t year, int32_t date) {
        year = year_from_fixed(date);
        int32_t start = (date < fixed_from_dmy(1, 1, year)) ? 7 : 1;
        for(month = start; (date > fixed_from_dmy(last_day_of_month(month, year), month, year)); month++){
        }
    }
    
    void CCHebrewCalendar::dmy_from_fixed(int32_t day, int32_t month, int32_t year, int32_t date) {
        my_from_fixed(month, year, date);
        day = ((date - fixed_from_dmy(1, month, year)) + 1);
    }
    
    int32_t CCHebrewCalendar::month_from_fixed(int32_t date) {
        int32_t month, year;
        my_from_fixed(month, year, date);
        return month;
    }
    
    int32_t CCHebrewCalendar::day_from_fixed(int32_t date) {
        int32_t day, month, year;
        dmy_from_fixed(day, month, year, date);
        return day;
    }
    
    int32_t CCHebrewCalendar::date_difference(int32_t dayA, int32_t monthA, int32_t yearA, int32_t dayB, int32_t monthB, int32_t yearB) {
        return (fixed_from_dmy(dayB, monthB, yearB) - fixed_from_dmy(dayA, monthA, yearA));
    }
    
    int32_t CCHebrewCalendar::day_number(int32_t day, int32_t month, int32_t year) {
        return (date_difference(1, 7, year, day, month, year) + 1);
    }
    
    int32_t CCHebrewCalendar::days_remaining(int32_t day, int32_t month, int32_t year) {
        return (date_difference(day, month, year, 1, 7, (year + 1)) - 1);
    }
    
}}
namespace System { namespace Globalization {
    
    
    bool CCHijriCalendar::is_leap_year(int32_t year) {
        return (CCMath::mod2((14 + (11 * year)), 30) < 11);
    }
    
    int32_t CCHijriCalendar::fixed_from_dmy(int32_t day, int32_t month, int32_t year) {
        int32_t k = 227013;
        (k = k + (354 * (year - 1)));
        (k = k + CCMath::div((3 + (11 * year)), 30));
        (k = k + (int32_t)System::Math::Ceiling2((29.5 * (double)((month - 1)))));
        (k = k + day);
        return k;
    }
    
    int32_t CCHijriCalendar::year_from_fixed(int32_t date) {
        return CCMath::div(((30 * (date - 227014)) + 10646), 10631);
    }
    
    void CCHijriCalendar::my_from_fixed(int32_t month, int32_t year, int32_t date) {
        year = year_from_fixed(date);
        int32_t m = (1 + (int32_t)System::Math::Ceiling2(((double)(((date - 29) - fixed_from_dmy(1, 1, year))) / 29.5)));
        month = (m < 12) ? m : 12;
    }
    
    void CCHijriCalendar::dmy_from_fixed(int32_t day, int32_t month, int32_t year, int32_t date) {
        my_from_fixed(month, year, date);
        day = ((date - fixed_from_dmy(1, month, year)) + 1);
    }
    
    int32_t CCHijriCalendar::month_from_fixed(int32_t date) {
        int32_t month, year;
        my_from_fixed(month, year, date);
        return month;
    }
    
    int32_t CCHijriCalendar::day_from_fixed(int32_t date) {
        int32_t day;
        int32_t month;
        int32_t year;
        dmy_from_fixed(day, month, year, date);
        return day;
    }
    
    int32_t CCHijriCalendar::date_difference(int32_t dayA, int32_t monthA, int32_t yearA, int32_t dayB, int32_t monthB, int32_t yearB) {
        return (fixed_from_dmy(dayB, monthB, yearB) - fixed_from_dmy(dayA, monthA, yearA));
    }
    
    int32_t CCHijriCalendar::day_number(int32_t day, int32_t month, int32_t year) {
        return date_difference(31, 12, (year - 1), day, month, year);
    }
    
    int32_t CCHijriCalendar::days_remaining(int32_t day, int32_t month, int32_t year) {
        return date_difference(day, month, year, 31, 12, year);
    }
    
}}
namespace System { namespace Globalization {
    
    
    void CCEastAsianLunisolarCalendar::constructor() {
    }
    
    int32_t CCEastAsianLunisolarCalendar::fixed_from_dmy(int32_t day, int32_t month, int32_t year) {
        throw cli::gcnew<System::Exception>(_T("fixed_from_dmy"));
    }
    
    int32_t CCEastAsianLunisolarCalendar::year_from_fixed(int32_t date) {
        throw cli::gcnew<System::Exception>(_T("year_from_fixed"));
    }
    
    void CCEastAsianLunisolarCalendar::my_from_fixed(int32_t month, int32_t year, int32_t date) {
        throw cli::gcnew<System::Exception>(_T("my_from_fixed"));
    }
    
    void CCEastAsianLunisolarCalendar::dmy_from_fixed(int32_t day, int32_t month, int32_t year, int32_t date) {
        throw cli::gcnew<System::Exception>(_T("dmy_from_fixed"));
    }
    
    System::DateTime CCEastAsianLunisolarCalendar::AddMonths(System::DateTime date, int32_t months) {
        throw cli::gcnew<System::Exception>(_T("AddMonths"));
    }
    
    System::DateTime CCEastAsianLunisolarCalendar::AddYears(System::DateTime date, int32_t years) {
        throw cli::gcnew<System::Exception>(_T("AddYears"));
    }
    
    int32_t CCEastAsianLunisolarCalendar::GetDayOfMonth(System::DateTime date) {
        throw cli::gcnew<System::Exception>(_T("GetDayOfMonth"));
    }
    
    int32_t CCEastAsianLunisolarCalendar::GetDayOfYear(System::DateTime date) {
        throw cli::gcnew<System::Exception>(_T("GetDayOfYear"));
    }
    
    int32_t CCEastAsianLunisolarCalendar::GetDaysInMonth(int32_t gyear, int32_t month) {
        throw cli::gcnew<System::Exception>(_T("GetDaysInMonth"));
    }
    
    int32_t CCEastAsianLunisolarCalendar::GetDaysInYear(int32_t year) {
        throw cli::gcnew<System::Exception>(_T("GetDaysInYear"));
    }
    
    int32_t CCEastAsianLunisolarCalendar::GetMonth(System::DateTime date) {
        throw cli::gcnew<System::Exception>(_T("GetMonth"));
    }
    
    bool CCEastAsianLunisolarCalendar::IsLeapMonth(int32_t gyear, int32_t month) {
        int32_t goldenNumber = (gyear % 19);
        bool chu = false;
        bool leap = false;
        double s = std::numeric_limits<double>::epsilon();
        for(int32_t y = 0; (y < goldenNumber); y++){
            for(int32_t l = 0, m = 1; (m <= month); m++){
                if(leap) 
                {
                    (l = l + 30);
                    leap = false;
                    if(((y ==  goldenNumber) && (m ==  month))) 
                    {
                        return true;
                    }
                }
                 else 
                {
                    (l = l + chu ? 30 : 29);
                    chu = !(chu);
                    (s = s + 30.44);
                    if(((s - (double)(l)) > 29.)) 
                    {
                        leap = true;
                    }
                }
            }
        }
        return false;
    }
    
    bool CCEastAsianLunisolarCalendar::IsLeapYear(int32_t gyear) {
        int32_t d = (gyear % 19);
        switch(d) {
            case 0: case 3: case 6: case 9: case 11: case 14: case 17: case_980: {
                return true;
            }
            default: case_981: {
                return false;
            }
        }
    }
    
    System::DateTime CCEastAsianLunisolarCalendar::ToDateTime(int32_t year, int32_t month, int32_t day, int32_t hour, int32_t minute, int32_t second, int32_t millisecond) {
        throw cli::gcnew<System::Exception>(_T("ToDateTime"));
    }
    
}}
namespace System { namespace Globalization {
    
    
    void CCGregorianEraHandler::constructor() {
        this->_Eras = cli::gcnew<System::Collections::SortedList>();
    }
    
    void CCGregorianEraHandler::appendEra(int32_t nr, int32_t rd_start, int32_t rd_end) {
        Era era = cli::ctor<Era>(nr, rd_start, rd_end);
        this->_Eras->set_Item_1ba4748ac76411aa(cli::box(nr), cli::box(era));
    }
    
    void CCGregorianEraHandler::appendEra2(int32_t nr, int32_t rd_start) {
        appendEra(nr, rd_start, CCFixed::FromDateTime((*System::DateTime::MaxValue)));
    }
    
    int32_t CCGregorianEraHandler::GregorianYear(int32_t year, int32_t era) {
        Era e = cli::unbox<Era>(this->_Eras->get_Item_c9a994fdd927bead(cli::box(era)));
        return e->GregorianYear(year);
    }
    
    int32_t CCGregorianEraHandler::EraYear(int32_t era, int32_t date) {
        System::Collections::IList *list = this->_Eras->GetValueList_17bf7e573fc23371();
        for(auto tmp_213 : list) {
            auto e = cli::cast<Era>(tmp_213);
            {
                if(e->Covers(date)) 
                {
                    return e->EraYear(era, date);
                }
            }
        }
        throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("date"), _T("Time value was out of era range."));
    }
    
    void CCGregorianEraHandler::CheckDateTime(System::DateTime time) {
        int32_t date = CCFixed::FromDateTime(time);
        if(!(ValidDate(date))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("time"), _T("Time value was out of era range."));
        }
    }
    
    bool CCGregorianEraHandler::ValidDate(int32_t date) {
        System::Collections::IList *list = this->_Eras->GetValueList_17bf7e573fc23371();
        for(auto tmp_214 : list) {
            auto e = cli::cast<Era>(tmp_214);
            {
                if(e->Covers(date)) 
                {
                    return true;
                }
            }
        }
        return false;
    }
    
    bool CCGregorianEraHandler::ValidEra(int32_t era) {
        return this->_Eras->Contains_34d44683dd1aa8bd(cli::box(era));
    }
    
    cli::array<int32_t>* CCGregorianEraHandler::get_Eras() {
        cli::array<int32_t> *a = (new cli::array<int32_t>(this->_Eras->get_Count_78ce60b82e5a007()));
        for(int32_t i = 0; (i < this->_Eras->get_Count_78ce60b82e5a007()); i++){
            Era e = cli::unbox<Era>(this->_Eras->GetByIndex_920ca5caddf75e3d(i));
            a->at(i) = e->get_Nr();
        }
        return a;
    }
    
}}
namespace System { namespace Globalization {
    
    
    void CCEastAsianLunisolarEraHandler::constructor() {
        this->_Eras = cli::gcnew<System::Collections::SortedList>();
    }
    
    void CCEastAsianLunisolarEraHandler::appendEra(int32_t nr, int32_t rd_start, int32_t rd_end) {
        Era2 era = cli::ctor<Era2>(nr, rd_start, rd_end);
        this->_Eras->set_Item_1ba4748ac76411aa(cli::box(nr), cli::box(era));
    }
    
    void CCEastAsianLunisolarEraHandler::appendEra2(int32_t nr, int32_t rd_start) {
        appendEra(nr, rd_start, CCFixed::FromDateTime((*System::DateTime::MaxValue)));
    }
    
    int32_t CCEastAsianLunisolarEraHandler::GregorianYear(int32_t year, int32_t era) {
        Era2 e = cli::unbox<Era2>(this->_Eras->get_Item_c9a994fdd927bead(cli::box(era)));
        return e->GregorianYear(year);
    }
    
    int32_t CCEastAsianLunisolarEraHandler::EraYear(int32_t era, int32_t date) {
        for(auto tmp_215 : this->_Eras->get_Values_cb1c2f63e58da7b3()) {
            auto e = cli::cast<Era2>(tmp_215);
            if(e->Covers(date)) 
            {
                return e->EraYear(era, date);
            }
        }
        throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("date"), _T("Time value was out of era range."));
    }
    
    void CCEastAsianLunisolarEraHandler::CheckDateTime(System::DateTime time) {
        int32_t date = CCFixed::FromDateTime(time);
        if(!(ValidDate(date))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("time"), _T("Time value was out of era range."));
        }
    }
    
    bool CCEastAsianLunisolarEraHandler::ValidDate(int32_t date) {
        for(auto tmp_216 : this->_Eras->get_Values_cb1c2f63e58da7b3()) {
            auto e = cli::cast<Era2>(tmp_216);
            {
                if(e->Covers(date)) 
                {
                    return true;
                }
            }
        }
        return false;
    }
    
    bool CCEastAsianLunisolarEraHandler::ValidEra(int32_t era) {
        return this->_Eras->Contains_34d44683dd1aa8bd(cli::box(era));
    }
    
    cli::array<int32_t>* CCEastAsianLunisolarEraHandler::get_Eras() {
        cli::array<int32_t> *a = (new cli::array<int32_t>(this->_Eras->get_Count_78ce60b82e5a007()));
        for(int32_t i = 0; (i < this->_Eras->get_Count_78ce60b82e5a007()); i++){
            Era2 e = cli::unbox<Era2>(this->_Eras->GetByIndex_920ca5caddf75e3d(i));
            a->at(i) = e->get_Nr();
        }
        return a;
    }
    
}}
namespace System { namespace Globalization {
    
    
    int32_t CharUnicodeInfo::GetDecimalDigitValue(char16_t ch) {
        int32_t i = (int32_t)(ch);
        switch(i) {
            case 178: case_982: {
                return 2;
            }
            case 179: case_983: {
                return 3;
            }
            case 185: case_984: {
                return 1;
            }
            case 8304: case_985: {
                return 0;
            }
        }
        if(((8308 <= i) && (i < 8314))) 
        {
            return (i - 8304);
        }
        if(((8320 <= i) && (i < 8330))) 
        {
            return (i - 8320);
        }
        if(!(System::Char::IsDigit(ch))) 
        {
            return -1;
        }
        if((i < 58)) 
        {
            return (i - 48);
        }
        if((i < 1642)) 
        {
            return (i - 1632);
        }
        if((i < 1786)) 
        {
            return (i - 1776);
        }
        if((i < 2416)) 
        {
            return (i - 2406);
        }
        if((i < 2544)) 
        {
            return (i - 2534);
        }
        if((i < 2672)) 
        {
            return (i - 2662);
        }
        if((i < 2800)) 
        {
            return (i - 2790);
        }
        if((i < 2928)) 
        {
            return (i - 2918);
        }
        if((i < 3056)) 
        {
            return (i - 3046);
        }
        if((i < 3184)) 
        {
            return (i - 3174);
        }
        if((i < 3312)) 
        {
            return (i - 3302);
        }
        if((i < 3440)) 
        {
            return (i - 3430);
        }
        if((i < 3674)) 
        {
            return (i - 3664);
        }
        if((i < 3802)) 
        {
            return (i - 3792);
        }
        if((i < 3882)) 
        {
            return (i - 3872);
        }
        if((i < 4170)) 
        {
            return (i - 4160);
        }
        if((i < 4978)) 
        {
            return (i - 4968);
        }
        if((i < 6122)) 
        {
            return (i - 6112);
        }
        if((i < 6170)) 
        {
            return (i - 6160);
        }
        if((i < 8314)) 
        {
            return (i - 8304);
        }
        if((i < 8330)) 
        {
            return (i - 8320);
        }
        if((i < 65296)) 
        {
            return -1;
        }
        if((i < 65306)) 
        {
            return (i - 65296);
        }
        return -1;
    }
    
    int32_t CharUnicodeInfo::GetDecimalDigitValue2(System::String* s, int32_t index) {
        if((s ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("s"));
        }
        return GetDecimalDigitValue(s->get_Chars(index));
    }
    
    int32_t CharUnicodeInfo::GetDigitValue(char16_t ch) {
        int32_t i = GetDecimalDigitValue(ch);
        if((i >= 0)) 
        {
            return i;
        }
        i = (int32_t)(ch);
        if((i ==  9450)) 
        {
            return 0;
        }
        if(((i >= 9312) && (i < 9321))) 
        {
            return (i - 9311);
        }
        if(((i >= 9332) && (i < 9341))) 
        {
            return (i - 9331);
        }
        if(((i >= 9352) && (i < 9361))) 
        {
            return (i - 9351);
        }
        if(((i >= 9461) && (i < 9470))) 
        {
            return (i - 9460);
        }
        if(((i >= 10102) && (i < 10111))) 
        {
            return (i - 10101);
        }
        if(((i >= 10112) && (i < 10121))) 
        {
            return (i - 10111);
        }
        if(((i >= 10122) && (i < 10131))) 
        {
            return (i - 10121);
        }
        return -1;
    }
    
    int32_t CharUnicodeInfo::GetDigitValue2(System::String* s, int32_t index) {
        if((s ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("s"));
        }
        return GetDigitValue(s->get_Chars(index));
    }
    
    double CharUnicodeInfo::GetNumericValue(char16_t ch) {
        int32_t i = GetDigitValue(ch);
        if((i >= 0)) 
        {
            return (double)(i);
        }
        i = (int32_t)(ch);
        switch(i) {
            case 188: case_986: {
                return 0.25;
            }
            case 189: case_987: {
                return 0.5;
            }
            case 190: case_988: {
                return 0.75;
            }
            case 2548: case_989: {
                return 1.;
            }
            case 2549: case_990: {
                return 2.;
            }
            case 2550: case_991: {
                return 3.;
            }
            case 2551: case_992: {
                return 4.;
            }
            case 2553: case_993: {
                return 16.;
            }
            case 3056: case_994: {
                return 10.;
            }
            case 3057: case_995: {
                return 100.;
            }
            case 3058: case_996: {
                return 1000.;
            }
            case 4988: case_997: {
                return 10000.;
            }
            case 5870: case_998: {
                return 17.;
            }
            case 5871: case_999: {
                return 18.;
            }
            case 5872: case_1000: {
                return 19.;
            }
            case 8531: case_1001: {
                return 0.333333333333333;
            }
            case 8532: case_1002: {
                return 0.666666666666667;
            }
            case 8537: case_1003: {
                return 0.166666666666667;
            }
            case 8538: case_1004: {
                return 0.833333333333333;
            }
            case 8539: case_1005: {
                return 0.125;
            }
            case 8540: case_1006: {
                return 0.375;
            }
            case 8541: case_1007: {
                return 0.625;
            }
            case 8542: case_1008: {
                return 0.875;
            }
            case 8543: case_1009: {
                return 1.;
            }
            case 8556: case_1010: {
                return 50.;
            }
            case 8557: case_1011: {
                return 100.;
            }
            case 8558: case_1012: {
                return 500.;
            }
            case 8559: case_1013: {
                return 1000.;
            }
            case 8572: case_1014: {
                return 50.;
            }
            case 8573: case_1015: {
                return 100.;
            }
            case 8574: case_1016: {
                return 500.;
            }
            case 8575: case_1017: {
                return 1000.;
            }
            case 8576: case_1018: {
                return 1000.;
            }
            case 8577: case_1019: {
                return 5000.;
            }
            case 8578: case_1020: {
                return 10000.;
            }
            case 9470: case 10111: case 10121: case 10131: case_1021: {
                return 10.;
            }
            case 12295: case_1022: {
                return std::numeric_limits<double>::epsilon();
            }
            case 12344: case_1023: {
                return 10.;
            }
            case 12345: case_1024: {
                return 20.;
            }
            case 12346: case_1025: {
                return 30.;
            }
        }
        if(((9451 <= i) && (i < 9461))) 
        {
            return (double)((i - 9440));
        }
        if(((12321 <= i) && (i < 12330))) 
        {
            return (double)((i - 12320));
        }
        if(((12881 <= i) && (i < 12896))) 
        {
            return (double)((i - 12860));
        }
        if(((12977 <= i) && (i < 12992))) 
        {
            return (double)((i - 12941));
        }
        if(!(System::Char::IsNumber(ch))) 
        {
            return std::numeric_limits<double>::epsilon();
        }
        if((i < 3891)) 
        {
            return ((0.5 + (double)(i)) - 3882.);
        }
        if((i < 4988)) 
        {
            return (double)(((i - 4977) * 10));
        }
        if((i < 8537)) 
        {
            return (0.2 * (double)((i - 8532)));
        }
        if((i < 8556)) 
        {
            return (double)((i - 8543));
        }
        if((i < 8572)) 
        {
            return (double)((i - 8559));
        }
        if((i < 9332)) 
        {
            return (double)((i - 9311));
        }
        if((i < 9352)) 
        {
            return (double)((i - 9331));
        }
        if((i < 9372)) 
        {
            return (double)((i - 9351));
        }
        if((i < 12694)) 
        {
            return (double)((i - 12689));
        }
        if((i < 12842)) 
        {
            return (double)((i - 12831));
        }
        if((i < 12938)) 
        {
            return (double)((i - 12927));
        }
        return std::numeric_limits<double>::epsilon();
    }
    
    double CharUnicodeInfo::GetNumericValue2(System::String* s, int32_t index) {
        if((s ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("s"));
        }
        return GetNumericValue(s->get_Chars(index));
    }
    
    UnicodeCategory CharUnicodeInfo::GetUnicodeCategory(char16_t ch) {
        return System::Char::GetUnicodeCategory(ch);
    }
    
    UnicodeCategory CharUnicodeInfo::GetUnicodeCategory2(System::String* s, int32_t index) {
        if((s ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("s"));
        }
        return System::Char::GetUnicodeCategory2(s, index);
    }
    
}}
namespace System { namespace Globalization {
    
    CCEastAsianLunisolarEraHandler*  ChineseLunisolarCalendar::era_handler;
    System::DateTime  ChineseLunisolarCalendar::ChineseMin;
    System::DateTime  ChineseLunisolarCalendar::ChineseMax;
    
    ChineseLunisolarCalendar::ChineseLunisolarCalendar()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void ChineseLunisolarCalendar::static_constructor() {
        era_handler = cli::gcnew<CCEastAsianLunisolarEraHandler>();
        era_handler->appendEra2(1, CCFixed::FromDateTime(cli::ctor<System::DateTime>(1, 1, 1)));
    }
    
    void ChineseLunisolarCalendar::constructor() {
    }
    
    int32_t ChineseLunisolarCalendar::GetEra_1d16c3456dce785e(System::DateTime time) {
        int32_t rd = CCFixed::FromDateTime(time);
        int32_t era;
        era_handler->EraYear(era, rd);
        return era;
    }
    
    cli::array<int32_t>* ChineseLunisolarCalendar::get_Eras_91b8aa89b8256658() {
        return cli::cast<cli::array<int32_t>*>(cli::import(era_handler->get_Eras())->Clone());
    }
    
    System::DateTime ChineseLunisolarCalendar::get_MinSupportedDateTime_63cdcad9cf7fca4e() {
        return ChineseMin;
    }
    
    System::DateTime ChineseLunisolarCalendar::get_MaxSupportedDateTime_7bc53f690ae04821() {
        return ChineseMax;
    }
    
}}
namespace System { namespace Globalization {
    
    
    void CodePageDataItem::constructor() {
    }
    
}}
namespace System { namespace Globalization {
    
    bool  CompareInfo::useManagedCollation;
    System::Collections::Hashtable*  CompareInfo::collators;
    System::Object*  CompareInfo::monitor;
    
    CompareInfo::CompareInfo()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void CompareInfo::constructor() {
    }
    
    void CompareInfo::constructor(CultureInfo* ci) {
        this->culture = ci->get_LCID_f4b9bc9d0bf0db86();
        if(CompareInfo::get_UseManagedCollation()) 
        {
            {
                cli::lock_guard{monitor};
                if((collators ==  nullptr)) 
                {
                    collators = cli::gcnew<System::Collections::Hashtable>();
                }
                this->collator = cli::cast<Mono::Globalization::Unicode::SimpleCollator*>(collators->get_Item_d75c6e706b965758(cli::box(ci->get_LCID_f4b9bc9d0bf0db86())));
                if((this->collator ==  nullptr)) 
                {
                    this->collator = cli::gcnew<Mono::Globalization::Unicode::SimpleCollator>(ci);
                    collators->set_Item_84c7e24d9caa09(cli::box(ci->get_LCID_f4b9bc9d0bf0db86()), this->collator);
                }
            }
        }
         else 
        {
            this->icu_name = ci->get_IcuName();
            this->construct_compareinfo(this->icu_name);
        }
    }
    
    void CompareInfo::static_constructor() {
    }
    
    void CompareInfo::Finalize_5d1f090c8cfaa1be() {
        {
            cli::finally_guard([&]() {
                Finalize_b946fbc32e26afd6();
            });
            free_internal_collator();
        }
    }
    
    void CompareInfo::OnDeserialization(System::Object* sender) {
        if(CompareInfo::get_UseManagedCollation()) 
        {
            this->collator = cli::gcnew<Mono::Globalization::Unicode::SimpleCollator>(cli::gcnew<CultureInfo>(this->culture));
        }
         else 
        {
            try {
                this->construct_compareinfo(this->icu_name);
            }
            catch(...) {
            }
        }
    }
    
    void CompareInfo::construct_compareinfo(System::String* locale) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void CompareInfo::free_internal_collator() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t CompareInfo::internal_compare(System::String* str1, int32_t offset1, int32_t length1, System::String* str2, int32_t offset2, int32_t length2, CompareOptions options) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void CompareInfo::assign_sortkey(System::Object* key, System::String* source, CompareOptions options) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t CompareInfo::internal_index(System::String* source, int32_t sindex, int32_t count, char16_t value, CompareOptions options, bool first) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t CompareInfo::internal_index2(System::String* source, int32_t sindex, int32_t count, System::String* value, CompareOptions options, bool first) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t CompareInfo::internal_compare_managed(System::String* str1, int32_t offset1, int32_t length1, System::String* str2, int32_t offset2, int32_t length2, CompareOptions options) {
        return this->collator->Compare3(str1, offset1, length1, str2, offset2, length2, options);
    }
    
    int32_t CompareInfo::internal_compare_switch(System::String* str1, int32_t offset1, int32_t length1, System::String* str2, int32_t offset2, int32_t length2, CompareOptions options) {
        return CompareInfo::get_UseManagedCollation() ? internal_compare_managed(str1, offset1, length1, str2, offset2, length2, options) : internal_compare(str1, offset1, length1, str2, offset2, length2, options);
    }
    
    int32_t CompareInfo::Compare_50fe18f7ad0224bc(System::String* string1, System::String* string2) {
        return Compare_272e035d74e81a5d(string1, string2, CompareOptions::None);
    }
    
    int32_t CompareInfo::Compare_272e035d74e81a5d(System::String* string1, System::String* string2, CompareOptions options) {
        if(((int32_t)(((int32_t)(options) & 1879048223)) != (int32_t)(options))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("options"));
        }
        if((string1 ==  nullptr)) 
        {
            if((string2 ==  nullptr)) 
            {
                return 0;
            }
            return -1;
        }
        if((string2 ==  nullptr)) 
        {
            return 1;
        }
        if(((string1->get_Length() ==  0) && (string2->get_Length() ==  0))) 
        {
            return 0;
        }
        return internal_compare_switch(string1, 0, string1->get_Length(), string2, 0, string2->get_Length(), options);
    }
    
    int32_t CompareInfo::Compare_341393099ee9866c(System::String* string1, int32_t offset1, System::String* string2, int32_t offset2) {
        return Compare_f1be80f4ffa76329(string1, offset1, string2, offset2, CompareOptions::None);
    }
    
    int32_t CompareInfo::Compare_f1be80f4ffa76329(System::String* string1, int32_t offset1, System::String* string2, int32_t offset2, CompareOptions options) {
        if(((int32_t)(((int32_t)(options) & 1879048223)) != (int32_t)(options))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("options"));
        }
        if((string1 ==  nullptr)) 
        {
            if((string2 ==  nullptr)) 
            {
                return 0;
            }
            return -1;
        }
        if((string2 ==  nullptr)) 
        {
            return 1;
        }
        if((((string1->get_Length() ==  0) || (offset1 ==  string1->get_Length())) && ((string2->get_Length() ==  0) || (offset2 ==  string2->get_Length())))) 
        {
            return 0;
        }
        if(((offset1 < 0) || (offset2 < 0))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("Offsets must not be less than zero"));
        }
        if((offset1 > string1->get_Length())) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("Offset1 is greater than or equal to the length of string1"));
        }
        if((offset2 > string2->get_Length())) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("Offset2 is greater than or equal to the length of string2"));
        }
        return internal_compare_switch(string1, offset1, (string1->get_Length() - offset1), string2, offset2, (string2->get_Length() - offset2), options);
    }
    
    int32_t CompareInfo::Compare_e4c71eff518222d5(System::String* string1, int32_t offset1, int32_t length1, System::String* string2, int32_t offset2, int32_t length2) {
        return Compare_cfb40aa8f022b1c6(string1, offset1, length1, string2, offset2, length2, CompareOptions::None);
    }
    
    int32_t CompareInfo::Compare_cfb40aa8f022b1c6(System::String* string1, int32_t offset1, int32_t length1, System::String* string2, int32_t offset2, int32_t length2, CompareOptions options) {
        if(((int32_t)(((int32_t)(options) & 1879048223)) != (int32_t)(options))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("options"));
        }
        if((string1 ==  nullptr)) 
        {
            if((string2 ==  nullptr)) 
            {
                return 0;
            }
            return -1;
        }
        if((string2 ==  nullptr)) 
        {
            return 1;
        }
        if(((((string1->get_Length() ==  0) || (offset1 ==  string1->get_Length())) || (length1 ==  0)) && (((string2->get_Length() ==  0) || (offset2 ==  string2->get_Length())) || (length2 ==  0)))) 
        {
            return 0;
        }
        if(((((offset1 < 0) || (length1 < 0)) || (offset2 < 0)) || (length2 < 0))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("Offsets and lengths must not be less than zero"));
        }
        if((offset1 > string1->get_Length())) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("Offset1 is greater than or equal to the length of string1"));
        }
        if((offset2 > string2->get_Length())) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("Offset2 is greater than or equal to the length of string2"));
        }
        if((length1 > (string1->get_Length() - offset1))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("Length1 is greater than the number of characters from offset1 to the end of string1"));
        }
        if((length2 > (string2->get_Length() - offset2))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("Length2 is greater than the number of characters from offset2 to the end of string2"));
        }
        return internal_compare_switch(string1, offset1, length1, string2, offset2, length2, options);
    }
    
    bool CompareInfo::Equals_ed975d2f4a7d193e(System::Object* value) {
        CompareInfo *other = cli::as<CompareInfo*>(value);
        if((other ==  nullptr)) 
        {
            return false;
        }
        return (other->culture ==  this->culture);
    }
    
    CompareInfo* CompareInfo::GetCompareInfo(int32_t culture) {
        return cli::gcnew<CultureInfo>(culture)->get_CompareInfo_ef6e4d0bc469f6a();
    }
    
    CompareInfo* CompareInfo::GetCompareInfo2(System::String* name) {
        if((name ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("name"));
        }
        return cli::gcnew<CultureInfo>(name)->get_CompareInfo_ef6e4d0bc469f6a();
    }
    
    CompareInfo* CompareInfo::GetCompareInfo3(int32_t culture, System::Reflection::Assembly* assembly) {
        if(System::Reflection::Assembly::op_Equality(assembly, nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("assembly"));
        }
        if(System::Reflection::Assembly::op_Inequality(assembly, cli::typeof<System::Type>::info->get_Module_ea7d65dc88202263()->get_Assembly_dbea84123403c0aa())) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Assembly is an invalid type"));
        }
        return GetCompareInfo(culture);
    }
    
    CompareInfo* CompareInfo::GetCompareInfo4(System::String* name, System::Reflection::Assembly* assembly) {
        if((name ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("name"));
        }
        if(System::Reflection::Assembly::op_Equality(assembly, nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("assembly"));
        }
        if(System::Reflection::Assembly::op_Inequality(assembly, cli::typeof<System::Type>::info->get_Module_ea7d65dc88202263()->get_Assembly_dbea84123403c0aa())) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Assembly is an invalid type"));
        }
        return GetCompareInfo2(name);
    }
    
    int32_t CompareInfo::GetHashCode_6648aef0f235ee6c() {
        return this->get_LCID();
    }
    
    SortKey* CompareInfo::GetSortKey_76c4476fb6c2b7c1(System::String* source) {
        return GetSortKey_250194ddfe99a207(source, CompareOptions::None);
    }
    
    SortKey* CompareInfo::GetSortKey_250194ddfe99a207(System::String* source, CompareOptions options) {
        switch(options) {
            case CompareOptions::Ordinal: case CompareOptions::OrdinalIgnoreCase: case_1026: {
                throw cli::gcnew<System::ArgumentException>(_T("Now allowed CompareOptions."), _T("options"));
            }
        }
        if(CompareInfo::get_UseManagedCollation()) 
        {
            return this->collator->GetSortKey2(source, options);
        }
        SortKey *key = cli::gcnew<SortKey>(this->culture, source, options);
        assign_sortkey(key, source, options);
        return key;
    }
    
    int32_t CompareInfo::IndexOf_9c7b97d4f571f153(System::String* source, char16_t value) {
        return IndexOf_d25f4e56610cd081(source, value, 0, source->get_Length(), CompareOptions::None);
    }
    
    int32_t CompareInfo::IndexOf_dd6d478317271ca6(System::String* source, System::String* value) {
        return IndexOf_434caa895db2be65(source, value, 0, source->get_Length(), CompareOptions::None);
    }
    
    int32_t CompareInfo::IndexOf_61b63989536ef546(System::String* source, char16_t value, CompareOptions options) {
        return IndexOf_d25f4e56610cd081(source, value, 0, source->get_Length(), options);
    }
    
    int32_t CompareInfo::IndexOf_9314bddb56529e1d(System::String* source, char16_t value, int32_t startIndex) {
        return IndexOf_d25f4e56610cd081(source, value, startIndex, (source->get_Length() - startIndex), CompareOptions::None);
    }
    
    int32_t CompareInfo::IndexOf_75c6c055d8cfb310(System::String* source, System::String* value, CompareOptions options) {
        return IndexOf_434caa895db2be65(source, value, 0, source->get_Length(), options);
    }
    
    int32_t CompareInfo::IndexOf_ccad65d26a41a9cd(System::String* source, System::String* value, int32_t startIndex) {
        return IndexOf_434caa895db2be65(source, value, startIndex, (source->get_Length() - startIndex), CompareOptions::None);
    }
    
    int32_t CompareInfo::IndexOf_6eceb976ca70cd8e(System::String* source, char16_t value, int32_t startIndex, CompareOptions options) {
        return IndexOf_d25f4e56610cd081(source, value, startIndex, (source->get_Length() - startIndex), options);
    }
    
    int32_t CompareInfo::IndexOf_60e351d75135f46d(System::String* source, char16_t value, int32_t startIndex, int32_t count) {
        return IndexOf_d25f4e56610cd081(source, value, startIndex, count, CompareOptions::None);
    }
    
    int32_t CompareInfo::IndexOf_62c9d90f539625a7(System::String* source, System::String* value, int32_t startIndex, CompareOptions options) {
        return IndexOf_434caa895db2be65(source, value, startIndex, (source->get_Length() - startIndex), options);
    }
    
    int32_t CompareInfo::IndexOf_b74a781533c8ed6d(System::String* source, System::String* value, int32_t startIndex, int32_t count) {
        return IndexOf_434caa895db2be65(source, value, startIndex, count, CompareOptions::None);
    }
    
    int32_t CompareInfo::internal_index_managed(System::String* s, int32_t sindex, int32_t count, char16_t c, CompareOptions opt, bool first) {
        return first ? this->collator->IndexOf4(s, c, sindex, count, opt) : this->collator->LastIndexOf4(s, c, sindex, count, opt);
    }
    
    int32_t CompareInfo::internal_index_switch(System::String* s, int32_t sindex, int32_t count, char16_t c, CompareOptions opt, bool first) {
        return (CompareInfo::get_UseManagedCollation() && !((first && ((int32_t)(opt) ==  1073741824)))) ? internal_index_managed(s, sindex, count, c, opt, first) : internal_index(s, sindex, count, c, opt, first);
    }
    
    int32_t CompareInfo::IndexOf_d25f4e56610cd081(System::String* source, char16_t value, int32_t startIndex, int32_t count, CompareOptions options) {
        if((source ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("source"));
        }
        if((startIndex < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("startIndex"));
        }
        if(((count < 0) || ((source->get_Length() - startIndex) < count))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("count"));
        }
        if(((int32_t)(((int32_t)(options) & 1342177311)) != (int32_t)(options))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("options"));
        }
        if((count ==  0)) 
        {
            return -1;
        }
        if(((int32_t)(((int32_t)(options) & 1073741824)) != 0)) 
        {
            for(int32_t pos = startIndex; (pos < (startIndex + count)); pos++){
                if(((int32_t)(source->get_Chars(pos)) ==  (int32_t)(value))) 
                {
                    return pos;
                }
            }
            return -1;
        }
         else 
        {
            return internal_index_switch(source, startIndex, count, value, options, true);
        }
    }
    
    int32_t CompareInfo::internal_index_managed2(System::String* s1, int32_t sindex, int32_t count, System::String* s2, CompareOptions opt, bool first) {
        return first ? this->collator->IndexOf2(s1, s2, sindex, count, opt) : this->collator->LastIndexOf2(s1, s2, sindex, count, opt);
    }
    
    int32_t CompareInfo::internal_index_switch2(System::String* s1, int32_t sindex, int32_t count, System::String* s2, CompareOptions opt, bool first) {
        return (CompareInfo::get_UseManagedCollation() && !((first && ((int32_t)(opt) ==  1073741824)))) ? internal_index_managed2(s1, sindex, count, s2, opt, first) : internal_index2(s1, sindex, count, s2, opt, first);
    }
    
    int32_t CompareInfo::IndexOf_434caa895db2be65(System::String* source, System::String* value, int32_t startIndex, int32_t count, CompareOptions options) {
        if((source ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("source"));
        }
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("value"));
        }
        if((startIndex < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("startIndex"));
        }
        if(((count < 0) || ((source->get_Length() - startIndex) < count))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("count"));
        }
        if(((int32_t)(((int32_t)(options) & 1342177311)) != (int32_t)(options))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("options"));
        }
        if((value->get_Length() ==  0)) 
        {
            return startIndex;
        }
        if((count ==  0)) 
        {
            return -1;
        }
        return internal_index_switch2(source, startIndex, count, value, options, true);
    }
    
    bool CompareInfo::IsPrefix_fd99a7e73f2a5cba(System::String* source, System::String* prefix) {
        return IsPrefix_5175c6f6b5c36f0a(source, prefix, CompareOptions::None);
    }
    
    bool CompareInfo::IsPrefix_5175c6f6b5c36f0a(System::String* source, System::String* prefix, CompareOptions options) {
        if((source ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("source"));
        }
        if((prefix ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("prefix"));
        }
        if(((int32_t)(((int32_t)(options) & 1342177311)) != (int32_t)(options))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("options"));
        }
        if(CompareInfo::get_UseManagedCollation()) 
        {
            return this->collator->IsPrefix(source, prefix, options);
        }
        if((source->get_Length() < prefix->get_Length())) 
        {
            return false;
        }
         else 
        {
            return (Compare_cfb40aa8f022b1c6(source, 0, prefix->get_Length(), prefix, 0, prefix->get_Length(), options) ==  0);
        }
    }
    
    bool CompareInfo::IsSuffix_b5bcb2cbb9f575c7(System::String* source, System::String* suffix) {
        return IsSuffix_aee4ee93cc1fc6d(source, suffix, CompareOptions::None);
    }
    
    bool CompareInfo::IsSuffix_aee4ee93cc1fc6d(System::String* source, System::String* suffix, CompareOptions options) {
        if((source ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("source"));
        }
        if((suffix ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("suffix"));
        }
        if(((int32_t)(((int32_t)(options) & 1342177311)) != (int32_t)(options))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("options"));
        }
        if(CompareInfo::get_UseManagedCollation()) 
        {
            return this->collator->IsSuffix(source, suffix, options);
        }
        if((source->get_Length() < suffix->get_Length())) 
        {
            return false;
        }
         else 
        {
            return (Compare_cfb40aa8f022b1c6(source, (source->get_Length() - suffix->get_Length()), suffix->get_Length(), suffix, 0, suffix->get_Length(), options) ==  0);
        }
    }
    
    int32_t CompareInfo::LastIndexOf_6ef54df3a337d7df(System::String* source, char16_t value) {
        return LastIndexOf_3dd9c7ed9a014563(source, value, (source->get_Length() - 1), source->get_Length(), CompareOptions::None);
    }
    
    int32_t CompareInfo::LastIndexOf_cce999127e14fb8(System::String* source, System::String* value) {
        return LastIndexOf_dcf739de60ff316f(source, value, (source->get_Length() - 1), source->get_Length(), CompareOptions::None);
    }
    
    int32_t CompareInfo::LastIndexOf_9b4ba083ca07b46c(System::String* source, char16_t value, CompareOptions options) {
        return LastIndexOf_3dd9c7ed9a014563(source, value, (source->get_Length() - 1), source->get_Length(), options);
    }
    
    int32_t CompareInfo::LastIndexOf_36afeb037dd8551(System::String* source, char16_t value, int32_t startIndex) {
        return LastIndexOf_3dd9c7ed9a014563(source, value, startIndex, (startIndex + 1), CompareOptions::None);
    }
    
    int32_t CompareInfo::LastIndexOf_7ce9454dba9ad554(System::String* source, System::String* value, CompareOptions options) {
        return LastIndexOf_dcf739de60ff316f(source, value, (source->get_Length() - 1), source->get_Length(), options);
    }
    
    int32_t CompareInfo::LastIndexOf_726af652382a35da(System::String* source, System::String* value, int32_t startIndex) {
        return LastIndexOf_dcf739de60ff316f(source, value, startIndex, (startIndex + 1), CompareOptions::None);
    }
    
    int32_t CompareInfo::LastIndexOf_b16ef57bb1dd2c7d(System::String* source, char16_t value, int32_t startIndex, CompareOptions options) {
        return LastIndexOf_3dd9c7ed9a014563(source, value, startIndex, (startIndex + 1), options);
    }
    
    int32_t CompareInfo::LastIndexOf_ed6dad7a88d75f3f(System::String* source, char16_t value, int32_t startIndex, int32_t count) {
        return LastIndexOf_3dd9c7ed9a014563(source, value, startIndex, count, CompareOptions::None);
    }
    
    int32_t CompareInfo::LastIndexOf_c981d9279c2bd5ee(System::String* source, System::String* value, int32_t startIndex, CompareOptions options) {
        return LastIndexOf_dcf739de60ff316f(source, value, startIndex, (startIndex + 1), options);
    }
    
    int32_t CompareInfo::LastIndexOf_5c1e773a5b209242(System::String* source, System::String* value, int32_t startIndex, int32_t count) {
        return LastIndexOf_dcf739de60ff316f(source, value, startIndex, count, CompareOptions::None);
    }
    
    int32_t CompareInfo::LastIndexOf_3dd9c7ed9a014563(System::String* source, char16_t value, int32_t startIndex, int32_t count, CompareOptions options) {
        if((source ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("source"));
        }
        if((startIndex < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("startIndex"));
        }
        if(((count < 0) || ((startIndex - count) < -1))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("count"));
        }
        if(((int32_t)(((int32_t)(options) & 1342177311)) != (int32_t)(options))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("options"));
        }
        if((count ==  0)) 
        {
            return -1;
        }
        if(((int32_t)(((int32_t)(options) & 1073741824)) != 0)) 
        {
            for(int32_t pos = startIndex; (pos > (startIndex - count)); pos--){
                if(((int32_t)(source->get_Chars(pos)) ==  (int32_t)(value))) 
                {
                    return pos;
                }
            }
            return -1;
        }
         else 
        {
            return internal_index_switch(source, startIndex, count, value, options, false);
        }
    }
    
    int32_t CompareInfo::LastIndexOf_dcf739de60ff316f(System::String* source, System::String* value, int32_t startIndex, int32_t count, CompareOptions options) {
        if((source ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("source"));
        }
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("value"));
        }
        if((startIndex < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("startIndex"));
        }
        if(((count < 0) || ((startIndex - count) < -1))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("count"));
        }
        if(((int32_t)(((int32_t)(options) & 1342177311)) != (int32_t)(options))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("options"));
        }
        if((count ==  0)) 
        {
            return -1;
        }
        int32_t valuelen = value->get_Length();
        if((valuelen ==  0)) 
        {
            return startIndex;
        }
        return internal_index_switch2(source, startIndex, count, value, options, false);
    }
    
    bool CompareInfo::IsSortable(char16_t ch) {
        return Mono::Globalization::Unicode::MSCompatUnicodeTable::IsSortable2((int32_t)(ch));
    }
    
    bool CompareInfo::IsSortable2(System::String* text) {
        return Mono::Globalization::Unicode::MSCompatUnicodeTable::IsSortable(text);
    }
    
    System::String* CompareInfo::ToString_1636a0751cb9ac11() {
        return cli::concat(_T("CompareInfo - "), cli::box(this->culture));
    }
    
    bool CompareInfo::get_UseManagedCollation() {
        return useManagedCollation;
    }
    
    int32_t CompareInfo::get_LCID() {
        return this->culture;
    }
    
    System::String* CompareInfo::get_Name_43d83d40e01dbdd2() {
        return this->icu_name;
    }
    
}}
namespace System { namespace Globalization {
    
    CultureInfo*  CultureInfo::invariant_culture_info;
    System::Object*  CultureInfo::shared_table_lock;
    int32_t  CultureInfo::BootstrapCultureID;
    System::String*  CultureInfo::MSG_READONLY;
    System::Collections::Hashtable*  CultureInfo::shared_by_number;
    System::Collections::Hashtable*  CultureInfo::shared_by_name;
    System::Collections::Generic::Dictionary<System::String*, int32_t>*  CultureInfo::__f__switch_map6;
    
    CultureInfo::CultureInfo()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void CultureInfo::constructor(int32_t culture) {
    }
    
    void CultureInfo::constructor(int32_t culture, bool useUserOverride) {
    }
    
    void CultureInfo::constructor(int32_t culture, bool useUserOverride, bool read_only) {
        if((culture < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("culture"), _T("Positive number required."));
        }
        this->constructed = true;
        this->m_isReadOnly = read_only;
        this->m_useUserOverride = useUserOverride;
        if((culture ==  127)) 
        {
            ConstructInvariant(read_only);
            return;
        }
        if(!(ConstructInternalLocaleFromLcid(culture))) 
        {
            throw cli::gcnew<CultureNotFoundException>(_T("culture"), System::String::Format2(_T("Culture ID {0} (0x{0:X4}) is not a supported culture."), cli::box(culture)));
        }
    }
    
    void CultureInfo::constructor(System::String* name) {
    }
    
    void CultureInfo::constructor(System::String* name, bool useUserOverride) {
    }
    
    void CultureInfo::constructor(System::String* name, bool useUserOverride, bool read_only) {
        if((name ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("name"));
        }
        this->constructed = true;
        this->m_isReadOnly = read_only;
        this->m_useUserOverride = useUserOverride;
        if((name->get_Length() ==  0)) 
        {
            ConstructInvariant(read_only);
            return;
        }
        if(!(ConstructInternalLocaleFromName(name->ToLowerInvariant()))) 
        {
            throw cli::gcnew<CultureNotFoundException>(_T("name"), cli::concat(_T("Culture name "), name));
        }
    }
    
    void CultureInfo::constructor() {
        this->constructed = true;
    }
    
    void CultureInfo::static_constructor() {
    }
    
    CultureInfo* CultureInfo::CreateSpecificCulture(System::String* name) {
        if((name ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("name"));
        }
        if(System::String::op_Equality(name, System::String::Empty)) 
        {
            return CultureInfo::get_InvariantCulture();
        }
        CultureInfo *ci = cli::gcnew<CultureInfo>();
        if(!(ConstructInternalLocaleFromSpecificName(ci, name->ToLowerInvariant()))) 
        {
            throw cli::gcnew<System::ArgumentException>(cli::concat(_T("Culture name "), name), name);
        }
        return ci;
    }
    
    CultureInfo* CultureInfo::ConstructCurrentCulture() {
        CultureInfo *ci = cli::gcnew<CultureInfo>();
        if(!(ConstructInternalLocaleFromCurrentLocale(ci))) 
        {
            ci = get_InvariantCulture();
        }
        BootstrapCultureID = ci->cultureID;
        return ci;
    }
    
    CultureInfo* CultureInfo::ConstructCurrentUICulture() {
        return ConstructCurrentCulture();
    }
    
    CultureInfo* CultureInfo::GetConsoleFallbackUICulture() {
        System::String* tmp_217 = this->get_Name_7a59bd1b86cfacd3();
        ::System::Int32 tmp_218 = -1;
        if(::System::String::Equals3(tmp_217, _T("ar")) ||
        ::System::String::Equals3(tmp_217, _T("ar-BH")) ||
        ::System::String::Equals3(tmp_217, _T("ar-EG")) ||
        ::System::String::Equals3(tmp_217, _T("ar-IQ")) ||
        ::System::String::Equals3(tmp_217, _T("ar-JO")) ||
        ::System::String::Equals3(tmp_217, _T("ar-KW")) ||
        ::System::String::Equals3(tmp_217, _T("ar-LB")) ||
        ::System::String::Equals3(tmp_217, _T("ar-LY")) ||
        ::System::String::Equals3(tmp_217, _T("ar-QA")) ||
        ::System::String::Equals3(tmp_217, _T("ar-SA")) ||
        ::System::String::Equals3(tmp_217, _T("ar-SY")) ||
        ::System::String::Equals3(tmp_217, _T("ar-AE")) ||
        ::System::String::Equals3(tmp_217, _T("ar-YE")) ||
        ::System::String::Equals3(tmp_217, _T("dv")) ||
        ::System::String::Equals3(tmp_217, _T("dv-MV")) ||
        ::System::String::Equals3(tmp_217, _T("fa")) ||
        ::System::String::Equals3(tmp_217, _T("fa-IR")) ||
        ::System::String::Equals3(tmp_217, _T("gu")) ||
        ::System::String::Equals3(tmp_217, _T("gu-IN")) ||
        ::System::String::Equals3(tmp_217, _T("he")) ||
        ::System::String::Equals3(tmp_217, _T("he-IL")) ||
        ::System::String::Equals3(tmp_217, _T("hi")) ||
        ::System::String::Equals3(tmp_217, _T("hi-IN")) ||
        ::System::String::Equals3(tmp_217, _T("kn")) ||
        ::System::String::Equals3(tmp_217, _T("kn-IN")) ||
        ::System::String::Equals3(tmp_217, _T("kok")) ||
        ::System::String::Equals3(tmp_217, _T("kok-IN")) ||
        ::System::String::Equals3(tmp_217, _T("mr")) ||
        ::System::String::Equals3(tmp_217, _T("mr-IN")) ||
        ::System::String::Equals3(tmp_217, _T("pa")) ||
        ::System::String::Equals3(tmp_217, _T("pa-IN")) ||
        ::System::String::Equals3(tmp_217, _T("sa")) ||
        ::System::String::Equals3(tmp_217, _T("sa-IN")) ||
        ::System::String::Equals3(tmp_217, _T("syr")) ||
        ::System::String::Equals3(tmp_217, _T("syr-SY")) ||
        ::System::String::Equals3(tmp_217, _T("ta")) ||
        ::System::String::Equals3(tmp_217, _T("ta-IN")) ||
        ::System::String::Equals3(tmp_217, _T("te")) ||
        ::System::String::Equals3(tmp_217, _T("te-IN")) ||
        ::System::String::Equals3(tmp_217, _T("th")) ||
        ::System::String::Equals3(tmp_217, _T("th-TH")) ||
        ::System::String::Equals3(tmp_217, _T("ur")) ||
        ::System::String::Equals3(tmp_217, _T("ur-PK")) ||
        ::System::String::Equals3(tmp_217, _T("vi")) ||
        ::System::String::Equals3(tmp_217, _T("vi-VN"))) tmp_218 = 0;
        if(::System::String::Equals3(tmp_217, _T("ar-DZ")) ||
        ::System::String::Equals3(tmp_217, _T("ar-MA")) ||
        ::System::String::Equals3(tmp_217, _T("ar-TN"))) tmp_218 = 1;
        switch(tmp_218)
        {
            case 0: case_1027: 
            {
                return GetCultureInfo2(_T("en"));
            }
            case 1: case_1028: 
            {
                return GetCultureInfo2(_T("fr"));
            }
        }
        return ((int32_t)(((int32_t)(this->get_CultureTypes()) & 32)) != 0) ? CultureInfo::get_InvariantCulture() : this;
    }
    
    void CultureInfo::ClearCachedData() {
        System::Threading::Thread::get_CurrentThread()->set_CurrentCulture(nullptr);
        System::Threading::Thread::get_CurrentThread()->set_CurrentUICulture(nullptr);
    }
    
    System::Object* CultureInfo::Clone_490644fd8134e39b() {
        if(!(this->constructed)) 
        {
            Construct();
        }
        CultureInfo *ci = cli::cast<CultureInfo*>(System::Object::MemberwiseClone());
        ci->m_isReadOnly = false;
        ci->cached_serialized_form = nullptr;
        if(!(this->get_IsNeutralCulture_9f9d058104a281b5())) 
        {
            ci->set_NumberFormat_f7b4f6eb05a5ded6(cli::cast<NumberFormatInfo*>(this->get_NumberFormat_56b6d54c07628932()->Clone()));
            ci->set_DateTimeFormat_435b1b701c3815b6(cli::cast<DateTimeFormatInfo*>(this->get_DateTimeFormat_cb96d9a9bbedcdf2()->Clone()));
        }
        return ci;
    }
    
    bool CultureInfo::Equals_ed975d2f4a7d193e(System::Object* value) {
        CultureInfo *b = cli::as<CultureInfo*>(value);
        if((b != nullptr)) 
        {
            return (b->cultureID ==  this->cultureID);
        }
        return false;
    }
    
    cli::array<CultureInfo*>* CultureInfo::GetCultures(CultureTypes types) {
        bool neutral = ((int32_t)(((int32_t)(types) & 1)) != 0);
        bool specific = ((int32_t)(((int32_t)(types) & 2)) != 0);
        bool installed = ((int32_t)(((int32_t)(types) & 4)) != 0);
        cli::array<CultureInfo*> *infos = internal_get_cultures(neutral, specific, installed);
        if(((neutral && (infos->get_Length() > 0)) && (infos->at(0) ==  nullptr))) 
        {
            infos->at(0) = cli::cast<CultureInfo*>(CultureInfo::get_InvariantCulture()->Clone_490644fd8134e39b());
        }
        return infos;
    }
    
    int32_t CultureInfo::GetHashCode_6648aef0f235ee6c() {
        return this->cultureID;
    }
    
    CultureInfo* CultureInfo::ReadOnly(CultureInfo* ci) {
        if((ci ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("ci"));
        }
        if(ci->m_isReadOnly) 
        {
            return ci;
        }
         else 
        {
            CultureInfo *new_ci = cli::cast<CultureInfo*>(ci->Clone_490644fd8134e39b());
            new_ci->m_isReadOnly = true;
            if((new_ci->numInfo != nullptr)) 
            {
                new_ci->numInfo = NumberFormatInfo::ReadOnly(new_ci->numInfo);
            }
            if((new_ci->dateTimeInfo != nullptr)) 
            {
                new_ci->dateTimeInfo = DateTimeFormatInfo::ReadOnly(new_ci->dateTimeInfo);
            }
            if((new_ci->textInfo != nullptr)) 
            {
                new_ci->textInfo = TextInfo::ReadOnly(new_ci->textInfo);
            }
            return new_ci;
        }
    }
    
    System::String* CultureInfo::ToString_1636a0751cb9ac11() {
        return this->m_name;
    }
    
    bool CultureInfo::IsIDNeutralCulture(int32_t lcid) {
        bool ret;
        if(!(internal_is_lcid_neutral(lcid, ret))) 
        {
            throw cli::gcnew<System::ArgumentException>(System::String::Format2(_T("Culture id 0x{:x4} is not supported."), cli::box(lcid)));
        }
        return ret;
    }
    
    void CultureInfo::CheckNeutral() {
    }
    
    System::Object* CultureInfo::GetFormat_49958c0908ff1d8f(System::Type* formatType) {
        System::Object *format = nullptr;
        if(System::Type::op_Equality2(formatType, cli::typeof<System::Type>::info)) 
        {
            format = this->get_NumberFormat_56b6d54c07628932();
        }
         else 
        {
            if(System::Type::op_Equality2(formatType, cli::typeof<System::Type>::info)) 
            {
                format = this->get_DateTimeFormat_cb96d9a9bbedcdf2();
            }
        }
        return format;
    }
    
    void CultureInfo::Construct() {
        construct_internal_locale_from_lcid(this->cultureID);
        this->constructed = true;
    }
    
    bool CultureInfo::ConstructInternalLocaleFromName(System::String* locale) {
        System::String* tmp_219 = locale;
        ::System::Int32 tmp_220 = -1;
        if(::System::String::Equals3(tmp_219, _T("zh-hans"))) tmp_220 = 0;
        if(::System::String::Equals3(tmp_219, _T("zh-hant"))) tmp_220 = 1;
        switch(tmp_220)
        {
            case 0: case_1029: 
            {
                locale = _T("zh-chs");
                break;
            }
            case 1: case_1030: 
            {
                locale = _T("zh-cht");
                break;
            }
        }
        if(!(construct_internal_locale_from_name(locale))) 
        {
            return false;
        }
        return true;
    }
    
    bool CultureInfo::ConstructInternalLocaleFromLcid(int32_t lcid) {
        if(!(construct_internal_locale_from_lcid(lcid))) 
        {
            return false;
        }
        return true;
    }
    
    bool CultureInfo::ConstructInternalLocaleFromSpecificName(CultureInfo* ci, System::String* name) {
        if(!(construct_internal_locale_from_specific_name(ci, name))) 
        {
            return false;
        }
        return true;
    }
    
    bool CultureInfo::ConstructInternalLocaleFromCurrentLocale(CultureInfo* ci) {
        if(!(construct_internal_locale_from_current_locale(ci))) 
        {
            return false;
        }
        return true;
    }
    
    bool CultureInfo::construct_internal_locale_from_lcid(int32_t lcid) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool CultureInfo::construct_internal_locale_from_name(System::String* name) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool CultureInfo::construct_internal_locale_from_specific_name(CultureInfo* ci, System::String* name) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool CultureInfo::construct_internal_locale_from_current_locale(CultureInfo* ci) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    cli::array<CultureInfo*>* CultureInfo::internal_get_cultures(bool neutral, bool specific, bool installed) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void CultureInfo::construct_datetime_format() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void CultureInfo::construct_number_format() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool CultureInfo::internal_is_lcid_neutral(int32_t lcid, bool is_neutral) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void CultureInfo::ConstructInvariant(bool read_only) {
        this->cultureID = 127;
        this->numInfo = NumberFormatInfo::get_InvariantInfo();
        this->dateTimeInfo = DateTimeFormatInfo::get_InvariantInfo();
        if(!(read_only)) 
        {
            this->numInfo = cli::cast<NumberFormatInfo*>(this->numInfo->Clone());
            this->dateTimeInfo = cli::cast<DateTimeFormatInfo*>(this->dateTimeInfo->Clone());
        }
        this->textInfo = CreateTextInfo(read_only);
        this->m_name = System::String::Empty;
        this->displayname = this->englishname = this->nativename = _T("Invariant Language (Invariant Country)");
        this->iso3lang = _T("IVL");
        this->iso2lang = _T("iv");
        this->icu_name = _T("en_US_POSIX");
        this->win3lang = _T("IVL");
    }
    
    TextInfo* CultureInfo::CreateTextInfo(bool readOnly) {
        return cli::gcnew<TextInfo>(this, this->cultureID, this->textinfo_data, readOnly);
    }
    
    void CultureInfo::insert_into_shared_tables(CultureInfo* c) {
        if((shared_by_number ==  nullptr)) 
        {
            shared_by_number = cli::gcnew<System::Collections::Hashtable>();
            shared_by_name = cli::gcnew<System::Collections::Hashtable>();
        }
        shared_by_number->set_Item_84c7e24d9caa09(cli::box(c->cultureID), c);
        shared_by_name->set_Item_84c7e24d9caa09(c->m_name, c);
    }
    
    CultureInfo* CultureInfo::GetCultureInfo(int32_t culture) {
        CultureInfo *c;
        {
            cli::lock_guard{shared_table_lock};
            if((shared_by_number != nullptr)) 
            {
                c = cli::as<CultureInfo*>(shared_by_number->get_Item_d75c6e706b965758(cli::box(culture)));
                if((c != nullptr)) 
                {
                    return cli::cast<CultureInfo*>(c);
                }
            }
            c = cli::gcnew<CultureInfo>(culture, false, true);
            insert_into_shared_tables(c);
            return c;
        }
    }
    
    CultureInfo* CultureInfo::GetCultureInfo2(System::String* name) {
        if((name ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("name"));
        }
        CultureInfo *c;
        {
            cli::lock_guard{shared_table_lock};
            if((shared_by_name != nullptr)) 
            {
                c = cli::as<CultureInfo*>(shared_by_name->get_Item_d75c6e706b965758(name));
                if((c != nullptr)) 
                {
                    return cli::cast<CultureInfo*>(c);
                }
            }
            c = cli::gcnew<CultureInfo>(name, false, true);
            insert_into_shared_tables(c);
            return c;
        }
    }
    
    CultureInfo* CultureInfo::GetCultureInfo3(System::String* name, System::String* altName) {
        if((name ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("null"));
        }
        if((altName ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("null"));
        }
        return GetCultureInfo2(name);
    }
    
    CultureInfo* CultureInfo::GetCultureInfoByIetfLanguageTag(System::String* name) {
        System::String* tmp_221 = name;
        ::System::Int32 tmp_222 = -1;
        if(::System::String::Equals3(tmp_221, _T("zh-Hans"))) tmp_222 = 0;
        if(::System::String::Equals3(tmp_221, _T("zh-Hant"))) tmp_222 = 1;
        switch(tmp_222)
        {
            case 0: case_1031: 
            {
                return GetCultureInfo2(_T("zh-CHS"));
            }
            case 1: case_1032: 
            {
                return GetCultureInfo2(_T("zh-CHT"));
            }
            default: case_1033: 
            {
                return GetCultureInfo2(name);
            }
        }
    }
    
    CultureInfo* CultureInfo::CreateCulture(System::String* name, bool reference) {
        bool read_only;
        bool use_user_override;
        bool invariant = (name->get_Length() ==  0);
        if(reference) 
        {
            use_user_override = invariant ? false : true;
            read_only = false;
        }
         else 
        {
            read_only = false;
            use_user_override = invariant ? false : true;
        }
        return cli::gcnew<CultureInfo>(name, use_user_override, read_only);
    }
    
    void CultureInfo::ConstructCalendars() {
        if((this->calendar_data ==  nullptr)) 
        {
            this->optional_calendars = (new cli::array<Calendar*>({cli::gcnew<GregorianCalendar>(GregorianCalendarTypes::Localized)}));
            return;
        }
        this->optional_calendars = (new cli::array<Calendar*>(5));
        for(int32_t i = 0; (i < 5); i++){
            Calendar *cal = nullptr;
            int32_t caldata = (*(this->calendar_data + (int32_t)(i)));
            int32_t caltype = (caldata >> 24);
            switch(caltype) {
                case 0: case_1034: {
                    GregorianCalendarTypes greg_type;
                    greg_type = (GregorianCalendarTypes)((caldata & 16777215));
                    cal = cli::gcnew<GregorianCalendar>(greg_type);
                    break;
                }
                case 1: case_1035: {
                    cal = cli::gcnew<HijriCalendar>();
                    break;
                }
                case 2: case_1036: {
                    cal = cli::gcnew<ThaiBuddhistCalendar>();
                    break;
                }
                default: case_1037: {
                    throw cli::gcnew<System::Exception>(cli::concat(_T("invalid calendar type:  "), cli::box(caldata)));
                }
            }
            this->optional_calendars->at(i) = cal;
        }
    }
    
    CultureInfo* CultureInfo::get_InvariantCulture() {
        return invariant_culture_info;
    }
    
    CultureInfo* CultureInfo::get_CurrentCulture() {
        return System::Threading::Thread::get_CurrentThread()->get_CurrentCulture();
    }
    
    CultureInfo* CultureInfo::get_CurrentUICulture() {
        return System::Threading::Thread::get_CurrentThread()->get_CurrentUICulture();
    }
    
    System::String* CultureInfo::get_Territory() {
        return this->territory;
    }
    
    CultureTypes CultureInfo::get_CultureTypes() {
        CultureTypes ret = (CultureTypes)0L;
        for(auto tmp_223 : System::Enum::GetValues(cli::typeof<System::Type>::info)) {
            auto v = cli::cast<CultureTypes>(tmp_223);
            if((System::Array::template IndexOf_1<CultureInfo*>(GetCultures(v), this) >= 0)) 
            {
                (ret = (CultureTypes)(((int32_t)(ret) | (int32_t)(v))));
            }
        }
        return ret;
    }
    
    System::String* CultureInfo::get_IetfLanguageTag() {
        System::String* tmp_224 = this->get_Name_7a59bd1b86cfacd3();
        ::System::Int32 tmp_225 = -1;
        if(::System::String::Equals3(tmp_224, _T("zh-CHS"))) tmp_225 = 0;
        if(::System::String::Equals3(tmp_224, _T("zh-CHT"))) tmp_225 = 1;
        switch(tmp_225)
        {
            case 0: case_1038: 
            {
                return _T("zh-Hans");
            }
            case 1: case_1039: 
            {
                return _T("zh-Hant");
            }
            default: case_1040: 
            {
                return this->get_Name_7a59bd1b86cfacd3();
            }
        }
    }
    
    int32_t CultureInfo::get_KeyboardLayoutId_273912e657e107e5() {
        switch(this->get_LCID_f4b9bc9d0bf0db86()) {
            case 4: case_1041: {
                return 2052;
            }
            case 1034: case_1042: {
                return 3082;
            }
            case 31748: case_1043: {
                return 1028;
            }
            case 31770: case_1044: {
                return 2074;
            }
            default: case_1045: {
                return (this->get_LCID_f4b9bc9d0bf0db86() < 1024) ? (this->get_LCID_f4b9bc9d0bf0db86() + 1024) : this->get_LCID_f4b9bc9d0bf0db86();
            }
        }
    }
    
    int32_t CultureInfo::get_LCID_f4b9bc9d0bf0db86() {
        return this->cultureID;
    }
    
    System::String* CultureInfo::get_Name_7a59bd1b86cfacd3() {
        return this->m_name;
    }
    
    System::String* CultureInfo::get_NativeName_a995d62d1c2e9299() {
        if(!(this->constructed)) 
        {
            Construct();
        }
        return this->nativename;
    }
    
    Calendar* CultureInfo::get_Calendar_5bead9100809a423() {
        return this->get_DateTimeFormat_cb96d9a9bbedcdf2()->get_Calendar();
    }
    
    cli::array<Calendar*>* CultureInfo::get_OptionalCalendars_87cc46022bfd6370() {
        if((this->optional_calendars ==  nullptr)) 
        {
            {
                cli::lock_guard{this};
                if((this->optional_calendars ==  nullptr)) 
                {
                    ConstructCalendars();
                }
            }
        }
        return this->optional_calendars;
    }
    
    CultureInfo* CultureInfo::get_Parent_87d5fb2f5c680cba() {
        if((this->parent_culture ==  nullptr)) 
        {
            if(!(this->constructed)) 
            {
                Construct();
            }
            if((this->parent_lcid ==  this->cultureID)) 
            {
                return nullptr;
            }
            if((this->parent_lcid ==  127)) 
            {
                this->parent_culture = get_InvariantCulture();
            }
             else 
            {
                if((this->cultureID ==  127)) 
                {
                    this->parent_culture = this;
                }
                 else 
                {
                    this->parent_culture = cli::gcnew<CultureInfo>(this->parent_lcid);
                }
            }
        }
        return this->parent_culture;
    }
    
    TextInfo* CultureInfo::get_TextInfo_63dfa6e5f11a61f0() {
        if((this->textInfo ==  nullptr)) 
        {
            if(!(this->constructed)) 
            {
                Construct();
            }
            {
                cli::lock_guard{this};
                if((this->textInfo ==  nullptr)) 
                {
                    this->textInfo = CreateTextInfo(this->m_isReadOnly);
                }
            }
        }
        return this->textInfo;
    }
    
    System::String* CultureInfo::get_ThreeLetterISOLanguageName_87cb454d9c6b990() {
        if(!(this->constructed)) 
        {
            Construct();
        }
        return this->iso3lang;
    }
    
    System::String* CultureInfo::get_ThreeLetterWindowsLanguageName_d83af167f1e2a02a() {
        if(!(this->constructed)) 
        {
            Construct();
        }
        return this->win3lang;
    }
    
    System::String* CultureInfo::get_TwoLetterISOLanguageName_85225151341c586c() {
        if(!(this->constructed)) 
        {
            Construct();
        }
        return this->iso2lang;
    }
    
    bool CultureInfo::get_UseUserOverride() {
        return this->m_useUserOverride;
    }
    
    System::String* CultureInfo::get_IcuName() {
        if(!(this->constructed)) 
        {
            Construct();
        }
        return this->icu_name;
    }
    
    CompareInfo* CultureInfo::get_CompareInfo_ef6e4d0bc469f6a() {
        if((this->compareInfo ==  nullptr)) 
        {
            if(!(this->constructed)) 
            {
                Construct();
            }
            {
                cli::lock_guard{this};
                if((this->compareInfo ==  nullptr)) 
                {
                    this->compareInfo = cli::gcnew<CompareInfo>(this);
                }
            }
        }
        return this->compareInfo;
    }
    
    bool CultureInfo::get_IsNeutralCulture_9f9d058104a281b5() {
        if(!(this->constructed)) 
        {
            Construct();
        }
        if((this->cultureID ==  127)) 
        {
            return false;
        }
        return (((this->cultureID & 65280) ==  0) || (this->specific_lcid ==  0));
    }
    
    NumberFormatInfo* CultureInfo::get_NumberFormat_56b6d54c07628932() {
        if(!(this->constructed)) 
        {
            Construct();
        }
        CheckNeutral();
        if((this->numInfo ==  nullptr)) 
        {
            {
                cli::lock_guard{this};
                if((this->numInfo ==  nullptr)) 
                {
                    this->numInfo = cli::gcnew<NumberFormatInfo>(this->m_isReadOnly);
                    construct_number_format();
                }
            }
        }
        return this->numInfo;
    }
    
    NumberFormatInfo* CultureInfo::set_NumberFormat_f7b4f6eb05a5ded6(NumberFormatInfo* value) {
        if(!(this->constructed)) 
        {
            Construct();
        }
        if(this->m_isReadOnly) 
        {
            throw cli::gcnew<System::InvalidOperationException>(MSG_READONLY);
        }
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("NumberFormat"));
        }
        this->numInfo = value;
        return get_NumberFormat_56b6d54c07628932();
    }
    
    DateTimeFormatInfo* CultureInfo::get_DateTimeFormat_cb96d9a9bbedcdf2() {
        if(!(this->constructed)) 
        {
            Construct();
        }
        CheckNeutral();
        if((this->dateTimeInfo ==  nullptr)) 
        {
            {
                cli::lock_guard{this};
                if((this->dateTimeInfo ==  nullptr)) 
                {
                    this->dateTimeInfo = cli::gcnew<DateTimeFormatInfo>(this->m_isReadOnly);
                    construct_datetime_format();
                    if((this->optional_calendars != nullptr)) 
                    {
                        this->dateTimeInfo->set_Calendar(this->optional_calendars->at(0));
                    }
                }
            }
        }
        return this->dateTimeInfo;
    }
    
    DateTimeFormatInfo* CultureInfo::set_DateTimeFormat_435b1b701c3815b6(DateTimeFormatInfo* value) {
        if(!(this->constructed)) 
        {
            Construct();
        }
        if(this->m_isReadOnly) 
        {
            throw cli::gcnew<System::InvalidOperationException>(MSG_READONLY);
        }
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("DateTimeFormat"));
        }
        this->dateTimeInfo = value;
        return get_DateTimeFormat_cb96d9a9bbedcdf2();
    }
    
    System::String* CultureInfo::get_DisplayName_52e82426094191e5() {
        if(!(this->constructed)) 
        {
            Construct();
        }
        return this->displayname;
    }
    
    System::String* CultureInfo::get_EnglishName_57b493e168ab483b() {
        if(!(this->constructed)) 
        {
            Construct();
        }
        return this->englishname;
    }
    
    CultureInfo* CultureInfo::get_InstalledUICulture() {
        return GetCultureInfo(BootstrapCultureID);
    }
    
    bool CultureInfo::get_IsReadOnly() {
        return this->m_isReadOnly;
    }
    
}}
namespace System { namespace Globalization {
    
    
    void CultureNotFoundException::constructor() {
    }
    
    void CultureNotFoundException::constructor(System::String* message) {
    }
    
    void CultureNotFoundException::constructor(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        this->invalid_culture_name = cli::cast<System::String*>(info->GetValue(_T("invalid_culture_name"), cli::typeof<System::Type>::info));
        this->invalid_culture_id = cli::unbox<System::Nullable2<int32_t>>(info->GetValue(_T("invalid_culture_id"), cli::typeof<System::Type>::info));
    }
    
    void CultureNotFoundException::constructor(System::String* message, System::Exception* innerException) {
    }
    
    void CultureNotFoundException::constructor(System::String* paramName, System::String* message) {
    }
    
    void CultureNotFoundException::constructor(System::String* message, int32_t invalidCultureId, System::Exception* innerException) {
        this->invalid_culture_id = cli::wrap_nullable(invalidCultureId);
    }
    
    void CultureNotFoundException::constructor(System::String* paramName, int32_t invalidCultureId, System::String* message) {
        this->invalid_culture_id = cli::wrap_nullable(invalidCultureId);
    }
    
    void CultureNotFoundException::constructor(System::String* message, System::String* invalidCultureName, System::Exception* innerException) {
        this->invalid_culture_name = invalidCultureName;
    }
    
    void CultureNotFoundException::constructor(System::String* paramName, System::String* invalidCultureName, System::String* message) {
        this->invalid_culture_name = invalidCultureName;
    }
    
    void CultureNotFoundException::GetObjectData_bc9b88d7eb43b6d8(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        if((info ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("info"));
        }
        System::ArgumentException::GetObjectData_bc9b88d7eb43b6d8(info, context);
        info->AddValue(_T("invalid_culture_name"), this->invalid_culture_name, cli::typeof<System::Type>::info);
        info->AddValue(_T("invalid_culture_id"), cli::box(this->invalid_culture_id), cli::typeof<System::Type>::info);
    }
    
    System::Nullable2<int32_t> CultureNotFoundException::get_InvalidCultureId_ff22afdc31cbb8b() {
        return this->invalid_culture_id;
    }
    
    System::String* CultureNotFoundException::get_InvalidCultureName_bee3729bec787d8a() {
        return this->invalid_culture_name;
    }
    
    System::String* CultureNotFoundException::get_Message_d211df4045b57cbf() {
        if(((this->invalid_culture_name ==  nullptr) && (this->invalid_culture_id->get_HasValue() ==  false))) 
        {
            return System::ArgumentException::get_Message_d211df4045b57cbf();
        }
        if((this->invalid_culture_name != nullptr)) 
        {
            return System::String::Format2(_T("Culture name {0} is invalid"), this->invalid_culture_name);
        }
        return System::String::Format2(_T("Culture ID {0} is invalid"), cli::box(this->invalid_culture_id));
    }
    
}}
namespace System { namespace Globalization {
    
    System::String*  DateTimeFormatInfo::MSG_READONLY;
    cli::array<System::String*>*  DateTimeFormatInfo::INVARIANT_ABBREVIATED_DAY_NAMES;
    cli::array<System::String*>*  DateTimeFormatInfo::INVARIANT_DAY_NAMES;
    cli::array<System::String*>*  DateTimeFormatInfo::INVARIANT_ABBREVIATED_MONTH_NAMES;
    cli::array<System::String*>*  DateTimeFormatInfo::INVARIANT_MONTH_NAMES;
    cli::array<System::String*>*  DateTimeFormatInfo::INVARIANT_SHORT_DAY_NAMES;
    DateTimeFormatInfo*  DateTimeFormatInfo::theInvariantDateTimeFormatInfo;
    
    DateTimeFormatInfo::DateTimeFormatInfo()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void DateTimeFormatInfo::constructor(bool read_only) {
        this->m_isReadOnly = read_only;
        this->amDesignator = _T("AM");
        this->pmDesignator = _T("PM");
        this->dateSeparator = _T("/");
        this->timeSeparator = _T(":");
        this->shortDatePattern = _T("MM/dd/yyyy");
        this->longDatePattern = _T("dddd, dd MMMM yyyy");
        this->shortTimePattern = _T("HH:mm");
        this->longTimePattern = _T("HH:mm:ss");
        this->monthDayPattern = _T("MMMM dd");
        this->yearMonthPattern = _T("yyyy MMMM");
        this->fullDateTimePattern = _T("dddd, dd MMMM yyyy HH:mm:ss");
        this->_RFC1123Pattern = _T("ddd, dd MMM yyyy HH\':\'mm\':\'ss \'GMT\'");
        this->_SortableDateTimePattern = _T("yyyy\'-\'MM\'-\'dd\'T\'HH\':\'mm\':\'ss");
        this->_UniversalSortableDateTimePattern = _T("yyyy\'-\'MM\'-\'dd HH\':\'mm\':\'ss\'Z\'");
        this->firstDayOfWeek = 0;
        this->calendar = cli::gcnew<GregorianCalendar>();
        this->calendarWeekRule = 0;
        this->abbreviatedDayNames = INVARIANT_ABBREVIATED_DAY_NAMES;
        this->dayNames = INVARIANT_DAY_NAMES;
        this->abbreviatedMonthNames = INVARIANT_ABBREVIATED_MONTH_NAMES;
        this->monthNames = INVARIANT_MONTH_NAMES;
        this->m_genitiveAbbreviatedMonthNames = INVARIANT_ABBREVIATED_MONTH_NAMES;
        this->genitiveMonthNames = INVARIANT_MONTH_NAMES;
        this->shortDayNames = INVARIANT_SHORT_DAY_NAMES;
    }
    
    void DateTimeFormatInfo::constructor() {
    }
    
    void DateTimeFormatInfo::static_constructor() {
    }
    
    DateTimeFormatInfo* DateTimeFormatInfo::GetInstance(System::IFormatProvider* provider) {
        if((provider != nullptr)) 
        {
            DateTimeFormatInfo *dtfi;
            dtfi = cli::cast<DateTimeFormatInfo*>(provider->GetFormat_b67414a65453cc7e(cli::typeof<System::Type>::info));
            if((dtfi != nullptr)) 
            {
                return dtfi;
            }
        }
        return DateTimeFormatInfo::get_CurrentInfo();
    }
    
    DateTimeFormatInfo* DateTimeFormatInfo::ReadOnly(DateTimeFormatInfo* dtfi) {
        DateTimeFormatInfo *copy = cli::cast<DateTimeFormatInfo*>(dtfi->Clone());
        copy->m_isReadOnly = true;
        return copy;
    }
    
    System::Object* DateTimeFormatInfo::Clone() {
        DateTimeFormatInfo *clone = cli::cast<DateTimeFormatInfo*>(System::Object::MemberwiseClone());
        clone->m_isReadOnly = false;
        return clone;
    }
    
    System::Object* DateTimeFormatInfo::GetFormat(System::Type* formatType) {
        return System::Type::op_Equality2(formatType, System::Object::GetType()) ? this : nullptr;
    }
    
    System::String* DateTimeFormatInfo::GetAbbreviatedEraName(int32_t era) {
        if(((era < 0) || (era >= this->calendar->get_AbbreviatedEraNames()->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("era"), cli::import(era)->ToString_1636a0751cb9ac11());
        }
        return this->calendar->get_AbbreviatedEraNames()->at(era);
    }
    
    System::String* DateTimeFormatInfo::GetAbbreviatedMonthName(int32_t month) {
        if(((month < 1) || (month > 13))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>();
        }
        return this->abbreviatedMonthNames->at((month - 1));
    }
    
    int32_t DateTimeFormatInfo::GetEra(System::String* eraName) {
        if((eraName ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>();
        }
        cli::array<System::String*> *eras = this->calendar->get_EraNames();
        for(int32_t i = 0; (i < eras->get_Length()); i++) {
            if((CultureInfo::get_InvariantCulture()->get_CompareInfo_ef6e4d0bc469f6a()->Compare_272e035d74e81a5d(eraName, eras->at(i), CompareOptions::IgnoreCase) ==  0)) 
            {
                return this->calendar->get_Eras_91b8aa89b8256658()->at(i);
            }
        }
        eras = this->calendar->get_AbbreviatedEraNames();
        for(int32_t i = 0; (i < eras->get_Length()); i++) {
            if((CultureInfo::get_InvariantCulture()->get_CompareInfo_ef6e4d0bc469f6a()->Compare_272e035d74e81a5d(eraName, eras->at(i), CompareOptions::IgnoreCase) ==  0)) 
            {
                return this->calendar->get_Eras_91b8aa89b8256658()->at(i);
            }
        }
        return -1;
    }
    
    System::String* DateTimeFormatInfo::GetEraName(int32_t era) {
        if(((era < 0) || (era > this->calendar->get_EraNames()->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("era"), cli::import(era)->ToString_1636a0751cb9ac11());
        }
        return this->calendar->get_EraNames()->at((era - 1));
    }
    
    System::String* DateTimeFormatInfo::GetMonthName(int32_t month) {
        if(((month < 1) || (month > 13))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>();
        }
        return this->monthNames->at((month - 1));
    }
    
    cli::array<System::String*>* DateTimeFormatInfo::GetAllDateTimePatterns() {
        return cli::cast<cli::array<System::String*>*>(cli::import(GetAllDateTimePatternsInternal())->Clone());
    }
    
    cli::array<System::String*>* DateTimeFormatInfo::GetAllDateTimePatternsInternal() {
        FillAllDateTimePatterns();
        return this->all_date_time_patterns;
    }
    
    void DateTimeFormatInfo::FillAllDateTimePatterns() {
        if((this->all_date_time_patterns != nullptr)) 
        {
            return;
        }
        System::Collections::Generic::List<System::String*> *al = cli::gcnew<System::Collections::Generic::List<System::String*>>();
        al->AddRange(GetAllRawDateTimePatterns(u'd'));
        al->AddRange(GetAllRawDateTimePatterns(u'D'));
        al->AddRange(GetAllRawDateTimePatterns(u'g'));
        al->AddRange(GetAllRawDateTimePatterns(u'G'));
        al->AddRange(GetAllRawDateTimePatterns(u'f'));
        al->AddRange(GetAllRawDateTimePatterns(u'F'));
        al->AddRange(GetAllRawDateTimePatterns(u'm'));
        al->AddRange(GetAllRawDateTimePatterns(u'M'));
        al->AddRange(GetAllRawDateTimePatterns(u'r'));
        al->AddRange(GetAllRawDateTimePatterns(u'R'));
        al->AddRange(GetAllRawDateTimePatterns(u's'));
        al->AddRange(GetAllRawDateTimePatterns(u't'));
        al->AddRange(GetAllRawDateTimePatterns(u'T'));
        al->AddRange(GetAllRawDateTimePatterns(u'u'));
        al->AddRange(GetAllRawDateTimePatterns(u'U'));
        al->AddRange(GetAllRawDateTimePatterns(u'y'));
        al->AddRange(GetAllRawDateTimePatterns(u'Y'));
        this->all_date_time_patterns = al->ToArray();
    }
    
    cli::array<System::String*>* DateTimeFormatInfo::GetAllDateTimePatterns2(char16_t format) {
        return cli::cast<cli::array<System::String*>*>(cli::import(GetAllRawDateTimePatterns(format))->Clone());
    }
    
    cli::array<System::String*>* DateTimeFormatInfo::GetAllRawDateTimePatterns(char16_t format) {
        cli::array<System::String*> *list;
        switch(format) {
            case u'D': case_1046: {
                if(((this->allLongDatePatterns != nullptr) && (this->allLongDatePatterns->get_Length() > 0))) 
                {
                    return this->allLongDatePatterns;
                }
                return (new cli::array<System::String*>({get_LongDatePattern()}));
            }
            case u'd': case_1047: {
                if(((this->allShortDatePatterns != nullptr) && (this->allShortDatePatterns->get_Length() > 0))) 
                {
                    return this->allShortDatePatterns;
                }
                return (new cli::array<System::String*>({get_ShortDatePattern()}));
            }
            case u'T': case_1048: {
                if(((this->allLongTimePatterns != nullptr) && (this->allLongTimePatterns->get_Length() > 0))) 
                {
                    return this->allLongTimePatterns;
                }
                return (new cli::array<System::String*>({get_LongTimePattern()}));
            }
            case u't': case_1049: {
                if(((this->allShortTimePatterns != nullptr) && (this->allShortTimePatterns->get_Length() > 0))) 
                {
                    return this->allShortTimePatterns;
                }
                return (new cli::array<System::String*>({get_ShortTimePattern()}));
            }
            case u'G': case_1050: {
                list = PopulateCombinedList(this->allShortDatePatterns, this->allLongTimePatterns);
                if(((list != nullptr) && (list->get_Length() > 0))) 
                {
                    return list;
                }
                return (new cli::array<System::String*>({cli::concat(this->get_ShortDatePattern(), _T(" "), this->get_LongTimePattern())}));
            }
            case u'g': case_1051: {
                list = PopulateCombinedList(this->allShortDatePatterns, this->allShortTimePatterns);
                if(((list != nullptr) && (list->get_Length() > 0))) 
                {
                    return list;
                }
                return (new cli::array<System::String*>({cli::concat(this->get_ShortDatePattern(), _T(" "), this->get_ShortTimePattern())}));
            }
            case u'U': case u'F': case_1052: {
                list = PopulateCombinedList(this->allLongDatePatterns, this->allLongTimePatterns);
                if(((list != nullptr) && (list->get_Length() > 0))) 
                {
                    return list;
                }
                return (new cli::array<System::String*>({cli::concat(this->get_LongDatePattern(), _T(" "), this->get_LongTimePattern())}));
            }
            case u'f': case_1053: {
                list = PopulateCombinedList(this->allLongDatePatterns, this->allShortTimePatterns);
                if(((list != nullptr) && (list->get_Length() > 0))) 
                {
                    return list;
                }
                return (new cli::array<System::String*>({cli::concat(this->get_LongDatePattern(), _T(" "), this->get_ShortTimePattern())}));
            }
            case u'm': case u'M': case_1054: {
                if(((this->monthDayPatterns != nullptr) && (this->monthDayPatterns->get_Length() > 0))) 
                {
                    return this->monthDayPatterns;
                }
                return (new cli::array<System::String*>({get_MonthDayPattern()}));
            }
            case u'Y': case u'y': case_1055: {
                if(((this->yearMonthPatterns != nullptr) && (this->yearMonthPatterns->get_Length() > 0))) 
                {
                    return this->yearMonthPatterns;
                }
                return (new cli::array<System::String*>({get_YearMonthPattern()}));
            }
            case u'r': case u'R': case_1056: {
                return (new cli::array<System::String*>({get_RFC1123Pattern()}));
            }
            case u's': case_1057: {
                return (new cli::array<System::String*>({get_SortableDateTimePattern()}));
            }
            case u'u': case_1058: {
                return (new cli::array<System::String*>({get_UniversalSortableDateTimePattern()}));
            }
        }
        throw cli::gcnew<System::ArgumentException>(_T("Format specifier was invalid."));
    }
    
    System::String* DateTimeFormatInfo::GetDayName(System::DayOfWeek dayofweek) {
        int32_t index = (int32_t)(dayofweek);
        if(((index < 0) || (index > 6))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>();
        }
        return this->dayNames->at(index);
    }
    
    System::String* DateTimeFormatInfo::GetAbbreviatedDayName(System::DayOfWeek dayofweek) {
        int32_t index = (int32_t)(dayofweek);
        if(((index < 0) || (index > 6))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>();
        }
        return this->abbreviatedDayNames->at(index);
    }
    
    void DateTimeFormatInfo::FillInvariantPatterns() {
        this->allShortDatePatterns = (new cli::array<System::String*>({_T("MM/dd/yyyy")}));
        this->allLongDatePatterns = (new cli::array<System::String*>({_T("dddd, dd MMMM yyyy")}));
        this->allLongTimePatterns = (new cli::array<System::String*>({_T("HH:mm:ss")}));
        this->allShortTimePatterns = (new cli::array<System::String*>({_T("HH:mm"), _T("hh:mm tt"), _T("H:mm"), _T("h:mm tt")}));
        this->monthDayPatterns = (new cli::array<System::String*>({_T("MMMM dd")}));
        this->yearMonthPatterns = (new cli::array<System::String*>({_T("yyyy MMMM")}));
    }
    
    cli::array<System::String*>* DateTimeFormatInfo::PopulateCombinedList(cli::array<System::String*>* dates, cli::array<System::String*>* times) {
        if(((dates != nullptr) && (times != nullptr))) 
        {
            cli::array<System::String*> *list = (new cli::array<System::String*>((dates->get_Length() * times->get_Length())));
            int32_t i = 0;
            for(auto tmp_226 : dates) {
                auto d = cli::cast<System::String*>(tmp_226);
                for(auto tmp_227 : times) {
                    auto t = cli::cast<System::String*>(tmp_227);
                    list->at(i++) = cli::concat(d, _T(" "));
                }
            }
            return list;
        }
        return nullptr;
    }
    
    System::String* DateTimeFormatInfo::GetShortestDayName(System::DayOfWeek dayOfWeek) {
        int32_t index = (int32_t)(dayOfWeek);
        if(((index < 0) || (index > 6))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>();
        }
        return this->shortDayNames->at(index);
    }
    
    void DateTimeFormatInfo::SetAllDateTimePatterns(cli::array<System::String*>* patterns, char16_t format) {
        if((patterns ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("patterns"));
        }
        if((patterns->get_Length() ==  0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("patterns"), _T("The argument patterns must not be of zero-length"));
        }
        switch(format) {
            case u'Y': case u'y': case_1059: {
                this->yearMonthPatterns = patterns;
                break;
            }
            case u'm': case u'M': case_1060: {
                this->monthDayPatterns = patterns;
                break;
            }
            case u'D': case_1061: {
                this->allLongDatePatterns = patterns;
                break;
            }
            case u'd': case_1062: {
                this->allShortDatePatterns = patterns;
                break;
            }
            case u'T': case_1063: {
                this->allLongTimePatterns = patterns;
                break;
            }
            case u't': case_1064: {
                this->allShortTimePatterns = patterns;
                break;
            }
            default: case_1065: {
                throw cli::gcnew<System::ArgumentException>(_T("format"), _T("Format specifier is invalid"));
            }
        }
    }
    
    void DateTimeFormatInfo::CheckDaysValue(cli::array<System::String*>* value) {
        if(this->get_IsReadOnly()) 
        {
            throw cli::gcnew<System::InvalidOperationException>(MSG_READONLY);
        }
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>();
        }
        if((value->get_Length() != 7)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("An array with exactly 7 elements is required"));
        }
        int32_t ni = System::Array::template IndexOf_1<System::String*>(value, nullptr);
        if((ni >= 0)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(System::String::Format2(_T("Element at index {0} is null"), cli::box(ni)));
        }
    }
    
    void DateTimeFormatInfo::CheckMonthsValue(cli::array<System::String*>* value) {
        if(this->get_IsReadOnly()) 
        {
            throw cli::gcnew<System::InvalidOperationException>(MSG_READONLY);
        }
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>();
        }
        if((value->get_Length() != 13)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("An array with exactly 13 elements is required"));
        }
        int32_t ni = System::Array::template IndexOf_1<System::String*>(value, nullptr);
        if((ni >= 0)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(System::String::Format2(_T("Element at index {0} is null"), cli::box(ni)));
        }
    }
    
    bool DateTimeFormatInfo::get_IsReadOnly() {
        return this->m_isReadOnly;
    }
    
    cli::array<System::String*>* DateTimeFormatInfo::get_AbbreviatedDayNames() {
        return cli::cast<cli::array<System::String*>*>(cli::import(this->get_RawAbbreviatedDayNames())->Clone());
    }
    
    cli::array<System::String*>* DateTimeFormatInfo::set_AbbreviatedDayNames(cli::array<System::String*>* value) {
        this->set_RawAbbreviatedDayNames(value);
        return get_AbbreviatedDayNames();
    }
    
    cli::array<System::String*>* DateTimeFormatInfo::get_RawAbbreviatedDayNames() {
        return this->abbreviatedDayNames;
    }
    
    cli::array<System::String*>* DateTimeFormatInfo::set_RawAbbreviatedDayNames(cli::array<System::String*>* value) {
        CheckDaysValue(value);
        this->abbreviatedDayNames = cli::cast<cli::array<System::String*>*>(cli::import(value)->Clone());
        return get_RawAbbreviatedDayNames();
    }
    
    cli::array<System::String*>* DateTimeFormatInfo::get_AbbreviatedMonthNames() {
        return cli::cast<cli::array<System::String*>*>(cli::import(this->get_RawAbbreviatedMonthNames())->Clone());
    }
    
    cli::array<System::String*>* DateTimeFormatInfo::set_AbbreviatedMonthNames(cli::array<System::String*>* value) {
        this->set_RawAbbreviatedMonthNames(value);
        return get_AbbreviatedMonthNames();
    }
    
    cli::array<System::String*>* DateTimeFormatInfo::get_RawAbbreviatedMonthNames() {
        return this->abbreviatedMonthNames;
    }
    
    cli::array<System::String*>* DateTimeFormatInfo::set_RawAbbreviatedMonthNames(cli::array<System::String*>* value) {
        CheckMonthsValue(value);
        this->abbreviatedMonthNames = cli::cast<cli::array<System::String*>*>(cli::import(value)->Clone());
        return get_RawAbbreviatedMonthNames();
    }
    
    cli::array<System::String*>* DateTimeFormatInfo::get_DayNames() {
        return cli::cast<cli::array<System::String*>*>(cli::import(this->get_RawDayNames())->Clone());
    }
    
    cli::array<System::String*>* DateTimeFormatInfo::set_DayNames(cli::array<System::String*>* value) {
        this->set_RawDayNames(value);
        return get_DayNames();
    }
    
    cli::array<System::String*>* DateTimeFormatInfo::get_RawDayNames() {
        return this->dayNames;
    }
    
    cli::array<System::String*>* DateTimeFormatInfo::set_RawDayNames(cli::array<System::String*>* value) {
        CheckDaysValue(value);
        this->dayNames = cli::cast<cli::array<System::String*>*>(cli::import(value)->Clone());
        return get_RawDayNames();
    }
    
    cli::array<System::String*>* DateTimeFormatInfo::get_MonthNames() {
        return cli::cast<cli::array<System::String*>*>(cli::import(this->get_RawMonthNames())->Clone());
    }
    
    cli::array<System::String*>* DateTimeFormatInfo::set_MonthNames(cli::array<System::String*>* value) {
        this->set_RawMonthNames(value);
        return get_MonthNames();
    }
    
    cli::array<System::String*>* DateTimeFormatInfo::get_RawMonthNames() {
        return this->monthNames;
    }
    
    cli::array<System::String*>* DateTimeFormatInfo::set_RawMonthNames(cli::array<System::String*>* value) {
        CheckMonthsValue(value);
        this->monthNames = cli::cast<cli::array<System::String*>*>(cli::import(value)->Clone());
        return get_RawMonthNames();
    }
    
    cli::array<System::String*>* DateTimeFormatInfo::get_AbbreviatedMonthGenitiveNames() {
        return cli::cast<cli::array<System::String*>*>(cli::import(this->m_genitiveAbbreviatedMonthNames)->Clone());
    }
    
    cli::array<System::String*>* DateTimeFormatInfo::set_AbbreviatedMonthGenitiveNames(cli::array<System::String*>* value) {
        CheckMonthsValue(value);
        this->m_genitiveAbbreviatedMonthNames = value;
        return get_AbbreviatedMonthGenitiveNames();
    }
    
    cli::array<System::String*>* DateTimeFormatInfo::get_MonthGenitiveNames() {
        return cli::cast<cli::array<System::String*>*>(cli::import(this->genitiveMonthNames)->Clone());
    }
    
    cli::array<System::String*>* DateTimeFormatInfo::set_MonthGenitiveNames(cli::array<System::String*>* value) {
        CheckMonthsValue(value);
        this->genitiveMonthNames = value;
        return get_MonthGenitiveNames();
    }
    
    System::String* DateTimeFormatInfo::get_NativeCalendarName() {
        return System::String::Empty;
    }
    
    cli::array<System::String*>* DateTimeFormatInfo::get_ShortestDayNames() {
        return cli::cast<cli::array<System::String*>*>(cli::import(this->shortDayNames)->Clone());
    }
    
    cli::array<System::String*>* DateTimeFormatInfo::set_ShortestDayNames(cli::array<System::String*>* value) {
        CheckDaysValue(value);
        this->shortDayNames = value;
        return get_ShortestDayNames();
    }
    
    System::String* DateTimeFormatInfo::get_AMDesignator() {
        return this->amDesignator;
    }
    
    System::String* DateTimeFormatInfo::set_AMDesignator(System::String* value) {
        if(this->get_IsReadOnly()) 
        {
            throw cli::gcnew<System::InvalidOperationException>(MSG_READONLY);
        }
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>();
        }
        this->amDesignator = value;
        return get_AMDesignator();
    }
    
    System::String* DateTimeFormatInfo::get_PMDesignator() {
        return this->pmDesignator;
    }
    
    System::String* DateTimeFormatInfo::set_PMDesignator(System::String* value) {
        if(this->get_IsReadOnly()) 
        {
            throw cli::gcnew<System::InvalidOperationException>(MSG_READONLY);
        }
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>();
        }
        this->pmDesignator = value;
        return get_PMDesignator();
    }
    
    System::String* DateTimeFormatInfo::get_DateSeparator() {
        return this->dateSeparator;
    }
    
    System::String* DateTimeFormatInfo::set_DateSeparator(System::String* value) {
        if(this->get_IsReadOnly()) 
        {
            throw cli::gcnew<System::InvalidOperationException>(MSG_READONLY);
        }
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>();
        }
        this->dateSeparator = value;
        return get_DateSeparator();
    }
    
    System::String* DateTimeFormatInfo::get_TimeSeparator() {
        return this->timeSeparator;
    }
    
    System::String* DateTimeFormatInfo::set_TimeSeparator(System::String* value) {
        if(this->get_IsReadOnly()) 
        {
            throw cli::gcnew<System::InvalidOperationException>(MSG_READONLY);
        }
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>();
        }
        this->timeSeparator = value;
        return get_TimeSeparator();
    }
    
    System::String* DateTimeFormatInfo::get_LongDatePattern() {
        return this->longDatePattern;
    }
    
    System::String* DateTimeFormatInfo::set_LongDatePattern(System::String* value) {
        if(this->get_IsReadOnly()) 
        {
            throw cli::gcnew<System::InvalidOperationException>(MSG_READONLY);
        }
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>();
        }
        this->longDatePattern = value;
        return get_LongDatePattern();
    }
    
    System::String* DateTimeFormatInfo::get_ShortDatePattern() {
        return this->shortDatePattern;
    }
    
    System::String* DateTimeFormatInfo::set_ShortDatePattern(System::String* value) {
        if(this->get_IsReadOnly()) 
        {
            throw cli::gcnew<System::InvalidOperationException>(MSG_READONLY);
        }
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>();
        }
        this->shortDatePattern = value;
        return get_ShortDatePattern();
    }
    
    System::String* DateTimeFormatInfo::get_ShortTimePattern() {
        return this->shortTimePattern;
    }
    
    System::String* DateTimeFormatInfo::set_ShortTimePattern(System::String* value) {
        if(this->get_IsReadOnly()) 
        {
            throw cli::gcnew<System::InvalidOperationException>(MSG_READONLY);
        }
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>();
        }
        this->shortTimePattern = value;
        return get_ShortTimePattern();
    }
    
    System::String* DateTimeFormatInfo::get_LongTimePattern() {
        return this->longTimePattern;
    }
    
    System::String* DateTimeFormatInfo::set_LongTimePattern(System::String* value) {
        if(this->get_IsReadOnly()) 
        {
            throw cli::gcnew<System::InvalidOperationException>(MSG_READONLY);
        }
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>();
        }
        this->longTimePattern = value;
        return get_LongTimePattern();
    }
    
    System::String* DateTimeFormatInfo::get_MonthDayPattern() {
        return this->monthDayPattern;
    }
    
    System::String* DateTimeFormatInfo::set_MonthDayPattern(System::String* value) {
        if(this->get_IsReadOnly()) 
        {
            throw cli::gcnew<System::InvalidOperationException>(MSG_READONLY);
        }
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>();
        }
        this->monthDayPattern = value;
        return get_MonthDayPattern();
    }
    
    System::String* DateTimeFormatInfo::get_YearMonthPattern() {
        return this->yearMonthPattern;
    }
    
    System::String* DateTimeFormatInfo::set_YearMonthPattern(System::String* value) {
        if(this->get_IsReadOnly()) 
        {
            throw cli::gcnew<System::InvalidOperationException>(MSG_READONLY);
        }
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>();
        }
        this->yearMonthPattern = value;
        return get_YearMonthPattern();
    }
    
    System::String* DateTimeFormatInfo::get_FullDateTimePattern() {
        if((this->fullDateTimePattern != nullptr)) 
        {
            return this->fullDateTimePattern;
        }
         else 
        {
            return cli::concat(this->longDatePattern, _T(" "));
        }
    }
    
    System::String* DateTimeFormatInfo::set_FullDateTimePattern(System::String* value) {
        if(this->get_IsReadOnly()) 
        {
            throw cli::gcnew<System::InvalidOperationException>(MSG_READONLY);
        }
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>();
        }
        this->fullDateTimePattern = value;
        return get_FullDateTimePattern();
    }
    
    DateTimeFormatInfo* DateTimeFormatInfo::get_CurrentInfo() {
        return System::Threading::Thread::get_CurrentThread()->get_CurrentCulture()->get_DateTimeFormat_cb96d9a9bbedcdf2();
    }
    
    DateTimeFormatInfo* DateTimeFormatInfo::get_InvariantInfo() {
        if((theInvariantDateTimeFormatInfo ==  nullptr)) 
        {
            theInvariantDateTimeFormatInfo = DateTimeFormatInfo::ReadOnly(cli::gcnew<DateTimeFormatInfo>());
            theInvariantDateTimeFormatInfo->FillInvariantPatterns();
        }
        return theInvariantDateTimeFormatInfo;
    }
    
    System::DayOfWeek DateTimeFormatInfo::get_FirstDayOfWeek() {
        return (System::DayOfWeek)(this->firstDayOfWeek);
    }
    
    System::DayOfWeek DateTimeFormatInfo::set_FirstDayOfWeek(System::DayOfWeek value) {
        if(this->get_IsReadOnly()) 
        {
            throw cli::gcnew<System::InvalidOperationException>(MSG_READONLY);
        }
        if((((int32_t)(value) < 0) || ((int32_t)(value) > 6))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>();
        }
        this->firstDayOfWeek = (int32_t)(value);
        return get_FirstDayOfWeek();
    }
    
    Calendar* DateTimeFormatInfo::get_Calendar() {
        return this->calendar;
    }
    
    Calendar* DateTimeFormatInfo::set_Calendar(Calendar* value) {
        if(this->get_IsReadOnly()) 
        {
            throw cli::gcnew<System::InvalidOperationException>(MSG_READONLY);
        }
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>();
        }
        this->calendar = value;
        return get_Calendar();
    }
    
    CalendarWeekRule DateTimeFormatInfo::get_CalendarWeekRule() {
        return (CalendarWeekRule)(this->calendarWeekRule);
    }
    
    CalendarWeekRule DateTimeFormatInfo::set_CalendarWeekRule(CalendarWeekRule value) {
        if(this->get_IsReadOnly()) 
        {
            throw cli::gcnew<System::InvalidOperationException>(MSG_READONLY);
        }
        this->calendarWeekRule = (int32_t)(value);
        return get_CalendarWeekRule();
    }
    
    System::String* DateTimeFormatInfo::get_RFC1123Pattern() {
        return this->_RFC1123Pattern;
    }
    
    System::String* DateTimeFormatInfo::get_RoundtripPattern() {
        return _T("yyyy\'-\'MM\'-\'dd\'T\'HH\':\'mm\':\'ss.fffffffK");
    }
    
    System::String* DateTimeFormatInfo::get_SortableDateTimePattern() {
        return this->_SortableDateTimePattern;
    }
    
    System::String* DateTimeFormatInfo::get_UniversalSortableDateTimePattern() {
        return this->_UniversalSortableDateTimePattern;
    }
    
}}
namespace System { namespace Globalization {
    
    
    void DaylightTime::constructor(System::DateTime start, System::DateTime end, System::TimeSpan delta) {
        this->m_start = start;
        this->m_end = end;
        this->m_delta = delta;
    }
    
    System::DateTime DaylightTime::get_Start() {
        return this->m_start;
    }
    
    System::DateTime DaylightTime::get_End() {
        return this->m_end;
    }
    
    System::TimeSpan DaylightTime::get_Delta() {
        return this->m_delta;
    }
    
}}
namespace System { namespace Globalization {
    
    
    void EastAsianLunisolarCalendar::constructor(CCEastAsianLunisolarEraHandler* eraHandler) {
        this->M_EraHandler = eraHandler;
    }
    
    void EastAsianLunisolarCalendar::M_CheckDateTime(System::DateTime time) {
        this->M_EraHandler->CheckDateTime(time);
    }
    
    void EastAsianLunisolarCalendar::M_CheckEra(int32_t era) {
        if((era ==  0)) 
        {
            era = this->get_ActualCurrentEra_d2c09b5f859d63e9();
        }
        if(!(this->M_EraHandler->ValidEra(era))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Era value was not valid."));
        }
    }
    
    int32_t EastAsianLunisolarCalendar::M_CheckYEG(int32_t year, int32_t era) {
        M_CheckEra(era);
        return this->M_EraHandler->GregorianYear(year, era);
    }
    
    void EastAsianLunisolarCalendar::M_CheckYE_c830e88539d38d64(int32_t year, int32_t era) {
        M_CheckYEG(year, era);
    }
    
    int32_t EastAsianLunisolarCalendar::M_CheckYMEG(int32_t year, int32_t month, int32_t era) {
        int32_t gregorianYear = M_CheckYEG(year, era);
        if(((month < 1) || (month > 12))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("month"), _T("Month must be between one and twelve."));
        }
        return gregorianYear;
    }
    
    int32_t EastAsianLunisolarCalendar::M_CheckYMDEG(int32_t year, int32_t month, int32_t day, int32_t era) {
        int32_t gregorianYear = M_CheckYMEG(year, month, era);
        Calendar::M_ArgumentInRange(_T("day"), day, 1, EastAsianLunisolarCalendar::GetDaysInMonth_233a2cea4d4c72fe(year, month, era));
        return gregorianYear;
    }
    
    System::DateTime EastAsianLunisolarCalendar::AddMonths_a4a4579bf9385278(System::DateTime time, int32_t months) {
        System::DateTime t = CCEastAsianLunisolarCalendar::AddMonths(time, months);
        M_CheckDateTime(t);
        return t;
    }
    
    System::DateTime EastAsianLunisolarCalendar::AddYears_8bb7ea0ef803063e(System::DateTime time, int32_t years) {
        System::DateTime t = CCEastAsianLunisolarCalendar::AddYears(time, years);
        M_CheckDateTime(t);
        return t;
    }
    
    int32_t EastAsianLunisolarCalendar::GetDayOfMonth_7da4e9f8c6f0dece(System::DateTime time) {
        M_CheckDateTime(time);
        return CCEastAsianLunisolarCalendar::GetDayOfMonth(time);
    }
    
    System::DayOfWeek EastAsianLunisolarCalendar::GetDayOfWeek_4c0b69c7bb83520e(System::DateTime time) {
        M_CheckDateTime(time);
        int32_t rd = CCFixed::FromDateTime(time);
        return (System::DayOfWeek)(CCFixed::day_of_week(rd));
    }
    
    int32_t EastAsianLunisolarCalendar::GetDayOfYear_1eaa1ac34e65f799(System::DateTime time) {
        M_CheckDateTime(time);
        return CCEastAsianLunisolarCalendar::GetDayOfYear(time);
    }
    
    int32_t EastAsianLunisolarCalendar::GetDaysInMonth_233a2cea4d4c72fe(int32_t year, int32_t month, int32_t era) {
        int32_t gregorianYear = M_CheckYMEG(year, month, era);
        return CCEastAsianLunisolarCalendar::GetDaysInMonth(gregorianYear, month);
    }
    
    int32_t EastAsianLunisolarCalendar::GetDaysInYear_ae0f8cfee3ff2567(int32_t year, int32_t era) {
        int32_t gregorianYear = M_CheckYEG(year, era);
        return CCEastAsianLunisolarCalendar::GetDaysInYear(gregorianYear);
    }
    
    int32_t EastAsianLunisolarCalendar::GetLeapMonth_fb3256a34d84f7ed(int32_t year, int32_t era) {
        return Calendar::GetLeapMonth_fb3256a34d84f7ed(year, era);
    }
    
    int32_t EastAsianLunisolarCalendar::GetMonth_66424683b988a96b(System::DateTime time) {
        M_CheckDateTime(time);
        return CCEastAsianLunisolarCalendar::GetMonth(time);
    }
    
    int32_t EastAsianLunisolarCalendar::GetMonthsInYear_2ae36c9a94a7bffb(int32_t year, int32_t era) {
        Calendar::M_CheckYE_c830e88539d38d64(year, era);
        return EastAsianLunisolarCalendar::IsLeapYear_7aad026a1103cfb(year, era) ? 13 : 12;
    }
    
    int32_t EastAsianLunisolarCalendar::GetYear_75c1b17aa90af360(System::DateTime time) {
        int32_t rd = CCFixed::FromDateTime(time);
        int32_t era;
        return this->M_EraHandler->EraYear(era, rd);
    }
    
    bool EastAsianLunisolarCalendar::IsLeapDay_7c795c9f36944ade(int32_t year, int32_t month, int32_t day, int32_t era) {
        int32_t gregorianYear = M_CheckYMDEG(year, month, day, era);
        return CCEastAsianLunisolarCalendar::IsLeapMonth(gregorianYear, month);
    }
    
    bool EastAsianLunisolarCalendar::IsLeapMonth_85b9917f2bdaeef7(int32_t year, int32_t month, int32_t era) {
        int32_t gregorianYear = M_CheckYMEG(year, month, era);
        return CCEastAsianLunisolarCalendar::IsLeapMonth(gregorianYear, month);
    }
    
    bool EastAsianLunisolarCalendar::IsLeapYear_7aad026a1103cfb(int32_t year, int32_t era) {
        int32_t gregorianYear = M_CheckYEG(year, era);
        return CCEastAsianLunisolarCalendar::IsLeapYear(gregorianYear);
    }
    
    System::DateTime EastAsianLunisolarCalendar::ToDateTime_82b4ff6780819fcd(int32_t year, int32_t month, int32_t day, int32_t hour, int32_t minute, int32_t second, int32_t millisecond, int32_t era) {
        int32_t gregorianYear = M_CheckYMDEG(year, month, day, era);
        Calendar::M_CheckHMSM(hour, minute, second, millisecond);
        return CCGregorianCalendar::ToDateTime(gregorianYear, month, day, hour, minute, second, millisecond);
    }
    
    int32_t EastAsianLunisolarCalendar::ToFourDigitYear_cb92a104112b3121(int32_t year) {
        if((year < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("year"), _T("Non-negative number required."));
        }
        int32_t era = 0;
        Calendar::M_CheckYE_c830e88539d38d64(year, era);
        return year;
    }
    
    int32_t EastAsianLunisolarCalendar::GetCelestialStem(int32_t sexagenaryYear) {
        if(((sexagenaryYear < 1) || (60 < sexagenaryYear))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("sexagendaryYear is less than 0 or greater than 60"));
        }
        return (((sexagenaryYear - 1) % 10) + 1);
    }
    
    int32_t EastAsianLunisolarCalendar::GetSexagenaryYear_7e817f7e639c1442(System::DateTime time) {
        return ((EastAsianLunisolarCalendar::GetYear_75c1b17aa90af360(time) - 1900) % 60);
    }
    
    int32_t EastAsianLunisolarCalendar::GetTerrestrialBranch(int32_t sexagenaryYear) {
        if(((sexagenaryYear < 1) || (60 < sexagenaryYear))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("sexagendaryYear is less than 0 or greater than 60"));
        }
        return (((sexagenaryYear - 1) % 12) + 1);
    }
    
    int32_t EastAsianLunisolarCalendar::get_TwoDigitYearMax_14e9789b3d89e801() {
        return this->twoDigitYearMax;
    }
    
    int32_t EastAsianLunisolarCalendar::set_TwoDigitYearMax_4852e071586288ab(int32_t value) {
        Calendar::CheckReadOnly();
        Calendar::M_ArgumentInRange(_T("value"), value, 100, this->get_M_MaxYear_b3d9776fced847fe());
        this->twoDigitYearMax = value;
        return get_TwoDigitYearMax_14e9789b3d89e801();
    }
    
    int32_t EastAsianLunisolarCalendar::get_ActualCurrentEra_d2c09b5f859d63e9() {
        return 1;
    }
    
    CalendarAlgorithmType EastAsianLunisolarCalendar::get_AlgorithmType_1e3f8ed99adb8bde() {
        return CalendarAlgorithmType::LunisolarCalendar;
    }
    
}}
namespace System { namespace Globalization {
    
    System::Nullable2<System::DateTime>  GregorianCalendar::Min;
    System::Nullable2<System::DateTime>  GregorianCalendar::Max;
    
    void GregorianCalendar::constructor(GregorianCalendarTypes type) {
        this->set_CalendarType_868621f754c8b21(type);
        this->M_AbbrEraNames = (new cli::array<System::String*>({_T("AD")}));
        this->M_EraNames = (new cli::array<System::String*>({_T("A.D.")}));
        if((this->twoDigitYearMax ==  99)) 
        {
            this->twoDigitYearMax = 2029;
        }
    }
    
    void GregorianCalendar::constructor() {
    }
    
    void GregorianCalendar::M_CheckEra(int32_t era) {
        if((era ==  0)) 
        {
            era = 1;
        }
        if((era != 1)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Era value was not valid."));
        }
    }
    
    void GregorianCalendar::M_CheckYE_c830e88539d38d64(int32_t year, int32_t era) {
        M_CheckEra(era);
        Calendar::M_ArgumentInRange(_T("year"), year, 1, 9999);
    }
    
    void GregorianCalendar::M_CheckYME(int32_t year, int32_t month, int32_t era) {
        Calendar::M_CheckYE_c830e88539d38d64(year, era);
        if(((month < 1) || (month > 12))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("month"), _T("Month must be between one and twelve."));
        }
    }
    
    void GregorianCalendar::M_CheckYMDE(int32_t year, int32_t month, int32_t day, int32_t era) {
        M_CheckYME(year, month, era);
        Calendar::M_ArgumentInRange(_T("day"), day, 1, GregorianCalendar::GetDaysInMonth_233a2cea4d4c72fe(year, month, era));
    }
    
    System::DateTime GregorianCalendar::AddMonths_a4a4579bf9385278(System::DateTime time, int32_t months) {
        return CCGregorianCalendar::AddMonths(time, months);
    }
    
    System::DateTime GregorianCalendar::AddYears_8bb7ea0ef803063e(System::DateTime time, int32_t years) {
        return CCGregorianCalendar::AddYears(time, years);
    }
    
    int32_t GregorianCalendar::GetDayOfMonth_7da4e9f8c6f0dece(System::DateTime time) {
        return CCGregorianCalendar::GetDayOfMonth(time);
    }
    
    System::DayOfWeek GregorianCalendar::GetDayOfWeek_4c0b69c7bb83520e(System::DateTime time) {
        int32_t rd = CCFixed::FromDateTime(time);
        return (System::DayOfWeek)(CCFixed::day_of_week(rd));
    }
    
    int32_t GregorianCalendar::GetDayOfYear_1eaa1ac34e65f799(System::DateTime time) {
        return CCGregorianCalendar::GetDayOfYear(time);
    }
    
    int32_t GregorianCalendar::GetDaysInMonth_233a2cea4d4c72fe(int32_t year, int32_t month, int32_t era) {
        M_CheckYME(year, month, era);
        return CCGregorianCalendar::GetDaysInMonth(year, month);
    }
    
    int32_t GregorianCalendar::GetDaysInYear_ae0f8cfee3ff2567(int32_t year, int32_t era) {
        Calendar::M_CheckYE_c830e88539d38d64(year, era);
        return CCGregorianCalendar::GetDaysInYear(year);
    }
    
    int32_t GregorianCalendar::GetEra_1d16c3456dce785e(System::DateTime time) {
        return 1;
    }
    
    int32_t GregorianCalendar::GetLeapMonth_fb3256a34d84f7ed(int32_t year, int32_t era) {
        return 0;
    }
    
    int32_t GregorianCalendar::GetMonth_66424683b988a96b(System::DateTime time) {
        return CCGregorianCalendar::GetMonth(time);
    }
    
    int32_t GregorianCalendar::GetMonthsInYear_2ae36c9a94a7bffb(int32_t year, int32_t era) {
        Calendar::M_CheckYE_c830e88539d38d64(year, era);
        return 12;
    }
    
    int32_t GregorianCalendar::GetWeekOfYear_d25712e900e29bec(System::DateTime time, CalendarWeekRule rule, System::DayOfWeek firstDayOfWeek) {
        return Calendar::GetWeekOfYear_d25712e900e29bec(time, rule, firstDayOfWeek);
    }
    
    int32_t GregorianCalendar::GetYear_75c1b17aa90af360(System::DateTime time) {
        return CCGregorianCalendar::GetYear(time);
    }
    
    bool GregorianCalendar::IsLeapDay_7c795c9f36944ade(int32_t year, int32_t month, int32_t day, int32_t era) {
        M_CheckYMDE(year, month, day, era);
        return CCGregorianCalendar::IsLeapDay(year, month, day);
    }
    
    bool GregorianCalendar::IsLeapMonth_85b9917f2bdaeef7(int32_t year, int32_t month, int32_t era) {
        M_CheckYME(year, month, era);
        return false;
    }
    
    bool GregorianCalendar::IsLeapYear_7aad026a1103cfb(int32_t year, int32_t era) {
        Calendar::M_CheckYE_c830e88539d38d64(year, era);
        return CCGregorianCalendar::is_leap_year(year);
    }
    
    System::DateTime GregorianCalendar::ToDateTime_82b4ff6780819fcd(int32_t year, int32_t month, int32_t day, int32_t hour, int32_t minute, int32_t second, int32_t millisecond, int32_t era) {
        M_CheckYMDE(year, month, day, era);
        Calendar::M_CheckHMSM(hour, minute, second, millisecond);
        return CCGregorianCalendar::ToDateTime(year, month, day, hour, minute, second, millisecond);
    }
    
    int32_t GregorianCalendar::ToFourDigitYear_cb92a104112b3121(int32_t year) {
        return Calendar::ToFourDigitYear_cb92a104112b3121(year);
    }
    
    cli::array<int32_t>* GregorianCalendar::get_Eras_91b8aa89b8256658() {
        return (new cli::array<int32_t>({ADEra}));
    }
    
    int32_t GregorianCalendar::get_TwoDigitYearMax_14e9789b3d89e801() {
        return this->twoDigitYearMax;
    }
    
    int32_t GregorianCalendar::set_TwoDigitYearMax_4852e071586288ab(int32_t value) {
        Calendar::CheckReadOnly();
        Calendar::M_ArgumentInRange(_T("value"), value, 100, this->get_M_MaxYear_b3d9776fced847fe());
        this->twoDigitYearMax = value;
        return get_TwoDigitYearMax_14e9789b3d89e801();
    }
    
    GregorianCalendarTypes GregorianCalendar::get_CalendarType_23a247a9bf212892() {
        return this->m_type;
    }
    
    GregorianCalendarTypes GregorianCalendar::set_CalendarType_868621f754c8b21(GregorianCalendarTypes value) {
        Calendar::CheckReadOnly();
        this->m_type = value;
        return get_CalendarType_23a247a9bf212892();
    }
    
    CalendarAlgorithmType GregorianCalendar::get_AlgorithmType_1e3f8ed99adb8bde() {
        return CalendarAlgorithmType::SolarCalendar;
    }
    
    System::DateTime GregorianCalendar::get_MinSupportedDateTime_63cdcad9cf7fca4e() {
        if(((System::Nullable2<System::DateTime>)(cli::unwrap_nullable(Min)) ==  nullptr)) 
        {
            Min = cli::wrap_nullable(cli::ctor<System::DateTime>(1, 1, 1, 0, 0, 0));
        }
        return Min->get_Value();
    }
    
    System::DateTime GregorianCalendar::get_MaxSupportedDateTime_7bc53f690ae04821() {
        if(((System::Nullable2<System::DateTime>)(cli::unwrap_nullable(Max)) ==  nullptr)) 
        {
            Max = cli::wrap_nullable(cli::ctor<System::DateTime>(9999, 12, 31, 11, 59, 59));
        }
        return Max->get_Value();
    }
    
}}
namespace System { namespace Globalization {
    
    int32_t  HebrewCalendar::HebrewEra;
    System::DateTime  HebrewCalendar::Min;
    System::DateTime  HebrewCalendar::Max;
    
    HebrewCalendar::HebrewCalendar()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void HebrewCalendar::constructor() {
        this->M_AbbrEraNames = (new cli::array<System::String*>({_T("A.M.")}));
        this->M_EraNames = (new cli::array<System::String*>({_T("Anno Mundi")}));
        if((this->twoDigitYearMax ==  99)) 
        {
            this->twoDigitYearMax = 5790;
        }
    }
    
    void HebrewCalendar::static_constructor() {
    }
    
    void HebrewCalendar::M_CheckDateTime(System::DateTime time) {
        if(((time->get_Ticks() < 499147488000000000L) || (time->get_Ticks() > 706783967999999999L))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("time"), _T("Only hebrew years between 5343 and 6000, inclusive, are supported."));
        }
    }
    
    void HebrewCalendar::M_CheckEra(int32_t era) {
        if((era ==  0)) 
        {
            era = HebrewEra;
        }
        if((era != HebrewEra)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Era value was not valid."));
        }
    }
    
    void HebrewCalendar::M_CheckYE_c830e88539d38d64(int32_t year, int32_t era) {
        M_CheckEra(era);
        if(((year < 5343) || (year > this->get_M_MaxYear_b3d9776fced847fe()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("year"), _T("Only hebrew years between 5343 and 6000, inclusive, are supported."));
        }
    }
    
    void HebrewCalendar::M_CheckYME(int32_t year, int32_t month, int32_t era) {
        Calendar::M_CheckYE_c830e88539d38d64(year, era);
        int32_t l = CCHebrewCalendar::last_month_of_year(year);
        if(((month < 1) || (month > l))) 
        {
            System::IO::StringWriter *sw = cli::gcnew<System::IO::StringWriter>();
            sw->Write_f2bf6875dbaeba6a(_T("Month must be between 1 and {0}."), cli::box(l));
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("month"), sw->ToString_1636a0751cb9ac11());
        }
    }
    
    void HebrewCalendar::M_CheckYMDE(int32_t year, int32_t month, int32_t day, int32_t era) {
        M_CheckYME(year, month, era);
        Calendar::M_ArgumentInRange(_T("day"), day, 1, HebrewCalendar::GetDaysInMonth_233a2cea4d4c72fe(year, month, era));
    }
    
    System::DateTime HebrewCalendar::AddMonths_a4a4579bf9385278(System::DateTime time, int32_t months) {
        int32_t y, m, d;
        System::DateTime t;
        if((months ==  0)) 
        {
            t = time;
        }
         else 
        {
            int32_t rd = CCFixed::FromDateTime(time);
            CCHebrewCalendar::dmy_from_fixed(d, m, y, rd);
            m = M_Month(m, y);
            if((months < 0)) 
            {
                while((months < 0)) {
                    if(((m + months) > 0)) 
                    {
                        (m = m + months);
                        months = 0;
                    }
                     else 
                    {
                        (months = months + m);
                        (y = y - 1);
                        m = Calendar::GetMonthsInYear_ccc452060ce28ee9(y);
                    }
                }
            }
             else 
            {
                while((months > 0)) {
                    int32_t my = Calendar::GetMonthsInYear_ccc452060ce28ee9(y);
                    if(((m + months) <= my)) 
                    {
                        (m = m + months);
                        months = 0;
                    }
                     else 
                    {
                        (months = months - ((my - m) + 1));
                        m = 1;
                        (y = y + 1);
                    }
                }
            }
            t = Calendar::ToDateTime_1fb5be79b550c0bc(y, m, d, 0, 0, 0, 0);
            t = t->Add(time->get_TimeOfDay());
        }
        M_CheckDateTime(t);
        return t;
    }
    
    System::DateTime HebrewCalendar::AddYears_8bb7ea0ef803063e(System::DateTime time, int32_t years) {
        int32_t rd = CCFixed::FromDateTime(time);
        int32_t day, month, year;
        CCHebrewCalendar::dmy_from_fixed(day, month, year, rd);
        (year = year + years);
        rd = CCHebrewCalendar::fixed_from_dmy(day, month, year);
        System::DateTime t = CCFixed::ToDateTime(rd);
        t = t->Add(time->get_TimeOfDay());
        M_CheckDateTime(t);
        return t;
    }
    
    int32_t HebrewCalendar::GetDayOfMonth_7da4e9f8c6f0dece(System::DateTime time) {
        M_CheckDateTime(time);
        int32_t rd = CCFixed::FromDateTime(time);
        return CCHebrewCalendar::day_from_fixed(rd);
    }
    
    System::DayOfWeek HebrewCalendar::GetDayOfWeek_4c0b69c7bb83520e(System::DateTime time) {
        M_CheckDateTime(time);
        int32_t rd = CCFixed::FromDateTime(time);
        return (System::DayOfWeek)(CCFixed::day_of_week(rd));
    }
    
    int32_t HebrewCalendar::GetDayOfYear_1eaa1ac34e65f799(System::DateTime time) {
        M_CheckDateTime(time);
        int32_t rd = CCFixed::FromDateTime(time);
        int32_t year = CCHebrewCalendar::year_from_fixed(rd);
        int32_t rd1_7 = CCHebrewCalendar::fixed_from_dmy(1, 7, year);
        return ((rd - rd1_7) + 1);
    }
    
    int32_t HebrewCalendar::M_CCMonth(int32_t month, int32_t year) {
        if((month <= 6)) 
        {
            return (6 + month);
        }
         else 
        {
            int32_t l = CCHebrewCalendar::last_month_of_year(year);
            if((l ==  12)) 
            {
                return (month - 6);
            }
             else 
            {
                return (month <= 7) ? (6 + month) : (month - 7);
            }
        }
    }
    
    int32_t HebrewCalendar::M_Month(int32_t ccmonth, int32_t year) {
        if((ccmonth >= 7)) 
        {
            return (ccmonth - 6);
        }
         else 
        {
            int32_t l = CCHebrewCalendar::last_month_of_year(year);
            return (ccmonth + (l ==  12) ? 6 : 7);
        }
    }
    
    int32_t HebrewCalendar::GetDaysInMonth_233a2cea4d4c72fe(int32_t year, int32_t month, int32_t era) {
        M_CheckYME(year, month, era);
        int32_t ccmonth = M_CCMonth(month, year);
        return CCHebrewCalendar::last_day_of_month(ccmonth, year);
    }
    
    int32_t HebrewCalendar::GetDaysInYear_ae0f8cfee3ff2567(int32_t year, int32_t era) {
        Calendar::M_CheckYE_c830e88539d38d64(year, era);
        int32_t rd1 = CCHebrewCalendar::fixed_from_dmy(1, 7, year);
        int32_t rd2 = CCHebrewCalendar::fixed_from_dmy(1, 7, (year + 1));
        return (rd2 - rd1);
    }
    
    int32_t HebrewCalendar::GetEra_1d16c3456dce785e(System::DateTime time) {
        M_CheckDateTime(time);
        return HebrewEra;
    }
    
    int32_t HebrewCalendar::GetLeapMonth_fb3256a34d84f7ed(int32_t year, int32_t era) {
        return HebrewCalendar::IsLeapMonth_85b9917f2bdaeef7(year, 7, era) ? 7 : 0;
    }
    
    int32_t HebrewCalendar::GetMonth_66424683b988a96b(System::DateTime time) {
        M_CheckDateTime(time);
        int32_t rd = CCFixed::FromDateTime(time);
        int32_t ccmonth, year;
        CCHebrewCalendar::my_from_fixed(ccmonth, year, rd);
        return M_Month(ccmonth, year);
    }
    
    int32_t HebrewCalendar::GetMonthsInYear_2ae36c9a94a7bffb(int32_t year, int32_t era) {
        Calendar::M_CheckYE_c830e88539d38d64(year, era);
        return CCHebrewCalendar::last_month_of_year(year);
    }
    
    int32_t HebrewCalendar::GetYear_75c1b17aa90af360(System::DateTime time) {
        M_CheckDateTime(time);
        int32_t rd = CCFixed::FromDateTime(time);
        return CCHebrewCalendar::year_from_fixed(rd);
    }
    
    bool HebrewCalendar::IsLeapDay_7c795c9f36944ade(int32_t year, int32_t month, int32_t day, int32_t era) {
        M_CheckYMDE(year, month, day, era);
        return (Calendar::IsLeapYear_59be46b16a9b7a45(year) && ((month ==  7) || ((month ==  6) && (day ==  30))));
    }
    
    bool HebrewCalendar::IsLeapMonth_85b9917f2bdaeef7(int32_t year, int32_t month, int32_t era) {
        M_CheckYME(year, month, era);
        return (Calendar::IsLeapYear_59be46b16a9b7a45(year) && (month ==  7));
    }
    
    bool HebrewCalendar::IsLeapYear_7aad026a1103cfb(int32_t year, int32_t era) {
        Calendar::M_CheckYE_c830e88539d38d64(year, era);
        return CCHebrewCalendar::is_leap_year(year);
    }
    
    System::DateTime HebrewCalendar::ToDateTime_82b4ff6780819fcd(int32_t year, int32_t month, int32_t day, int32_t hour, int32_t minute, int32_t second, int32_t millisecond, int32_t era) {
        M_CheckYMDE(year, month, day, era);
        Calendar::M_CheckHMSM(hour, minute, second, millisecond);
        int32_t ccm = M_CCMonth(month, year);
        int32_t rd = CCHebrewCalendar::fixed_from_dmy(day, ccm, year);
        return CCFixed::ToDateTime2(rd, hour, minute, second, (double)(millisecond));
    }
    
    int32_t HebrewCalendar::ToFourDigitYear_cb92a104112b3121(int32_t year) {
        Calendar::M_ArgumentInRange(_T("year"), year, 0, (this->get_M_MaxYear_b3d9776fced847fe() - 1));
        int32_t baseExtra = (this->twoDigitYearMax % 100);
        int32_t baseCentury = (this->twoDigitYearMax - baseExtra);
        if((year >= 100)) 
        {
            return year;
        }
        if((year <= baseExtra)) 
        {
            return (baseCentury + year);
        }
         else 
        {
            return ((baseCentury + year) - 100);
        }
    }
    
    int32_t HebrewCalendar::get_M_MaxYear_b3d9776fced847fe() {
        return 6000;
    }
    
    cli::array<int32_t>* HebrewCalendar::get_Eras_91b8aa89b8256658() {
        return (new cli::array<int32_t>({HebrewEra}));
    }
    
    int32_t HebrewCalendar::get_TwoDigitYearMax_14e9789b3d89e801() {
        return this->twoDigitYearMax;
    }
    
    int32_t HebrewCalendar::set_TwoDigitYearMax_4852e071586288ab(int32_t value) {
        Calendar::CheckReadOnly();
        Calendar::M_ArgumentInRange(_T("value"), value, 5343, this->get_M_MaxYear_b3d9776fced847fe());
        this->twoDigitYearMax = value;
        return get_TwoDigitYearMax_14e9789b3d89e801();
    }
    
    CalendarAlgorithmType HebrewCalendar::get_AlgorithmType_1e3f8ed99adb8bde() {
        return CalendarAlgorithmType::LunisolarCalendar;
    }
    
    System::DateTime HebrewCalendar::get_MinSupportedDateTime_63cdcad9cf7fca4e() {
        return Min;
    }
    
    System::DateTime HebrewCalendar::get_MaxSupportedDateTime_7bc53f690ae04821() {
        return Max;
    }
    
}}
namespace System { namespace Globalization {
    
    int32_t  HijriCalendar::HijriEra;
    int32_t  HijriCalendar::M_MinFixed;
    int32_t  HijriCalendar::M_MaxFixed;
    System::DateTime  HijriCalendar::Min;
    System::DateTime  HijriCalendar::Max;
    
    HijriCalendar::HijriCalendar()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void HijriCalendar::constructor() {
        this->M_AbbrEraNames = (new cli::array<System::String*>({_T("A.H.")}));
        this->M_EraNames = (new cli::array<System::String*>({_T("Anno Hegirae")}));
        if((this->twoDigitYearMax ==  99)) 
        {
            this->twoDigitYearMax = 1451;
        }
    }
    
    void HijriCalendar::static_constructor() {
    }
    
    void HijriCalendar::M_CheckFixedHijri(System::String* param, int32_t rdHijri) {
        if(((rdHijri < M_MinFixed) || (rdHijri > (M_MaxFixed - this->get_AddHijriDate_de230c2822d0e775())))) 
        {
            System::IO::StringWriter *sw = cli::gcnew<System::IO::StringWriter>();
            int32_t day, month, year;
            CCHijriCalendar::dmy_from_fixed(day, month, year, (M_MaxFixed - this->get_AddHijriDate_de230c2822d0e775()));
            if((this->get_AddHijriDate_de230c2822d0e775() != 0)) 
            {
                sw->Write_e2bf1f4b5968ab9(_T("This HijriCalendar (AddHijriDate {0}) allows dates from 1. 1. 1 to {1}. {2}. {3}."), (new cli::array<System::Object*>({cli::box(this->get_AddHijriDate_de230c2822d0e775()), cli::box(day), cli::box(month), cli::box(year)})));
            }
             else 
            {
                sw->Write_4d2ac9c7b9e5e3b6(_T("HijriCalendar allows dates from 1.1.1 to {0}.{1}.{2}."), cli::box(day), cli::box(month), cli::box(year));
            }
            throw cli::gcnew<System::ArgumentOutOfRangeException>(param, sw->ToString_1636a0751cb9ac11());
        }
    }
    
    void HijriCalendar::M_CheckDateTime(System::DateTime time) {
        int32_t rd = (CCFixed::FromDateTime(time) - this->get_AddHijriDate_de230c2822d0e775());
        M_CheckFixedHijri(_T("time"), rd);
    }
    
    int32_t HijriCalendar::M_FromDateTime(System::DateTime time) {
        return (CCFixed::FromDateTime(time) - this->get_AddHijriDate_de230c2822d0e775());
    }
    
    System::DateTime HijriCalendar::M_ToDateTime(int32_t rd) {
        return CCFixed::ToDateTime((rd + this->get_AddHijriDate_de230c2822d0e775()));
    }
    
    System::DateTime HijriCalendar::M_ToDateTime2(int32_t date, int32_t hour, int32_t minute, int32_t second, int32_t milliseconds) {
        return CCFixed::ToDateTime2((date + this->get_AddHijriDate_de230c2822d0e775()), hour, minute, second, (double)(milliseconds));
    }
    
    void HijriCalendar::M_CheckEra(int32_t era) {
        if((era ==  0)) 
        {
            era = HijriEra;
        }
        if((era != HijriEra)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Era value was not valid."));
        }
    }
    
    void HijriCalendar::M_CheckYE_c830e88539d38d64(int32_t year, int32_t era) {
        M_CheckEra(era);
        Calendar::M_ArgumentInRange(_T("year"), year, 1, 9666);
    }
    
    void HijriCalendar::M_CheckYME(int32_t year, int32_t month, int32_t era) {
        Calendar::M_CheckYE_c830e88539d38d64(year, era);
        if(((month < 1) || (month > 12))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("month"), _T("Month must be between one and twelve."));
        }
        if((year ==  9666)) 
        {
            int32_t rd = CCHijriCalendar::fixed_from_dmy(1, month, year);
            M_CheckFixedHijri(_T("month"), rd);
        }
    }
    
    void HijriCalendar::M_CheckYMDE(int32_t year, int32_t month, int32_t day, int32_t era) {
        M_CheckYME(year, month, era);
        Calendar::M_ArgumentInRange(_T("day"), day, 1, HijriCalendar::GetDaysInMonth_233a2cea4d4c72fe(year, month, HijriEra));
        if((year ==  9666)) 
        {
            int32_t rd = CCHijriCalendar::fixed_from_dmy(day, month, year);
            M_CheckFixedHijri(_T("day"), rd);
        }
    }
    
    System::DateTime HijriCalendar::AddMonths_a4a4579bf9385278(System::DateTime time, int32_t months) {
        int32_t rd = M_FromDateTime(time);
        int32_t day, month, year;
        CCHijriCalendar::dmy_from_fixed(day, month, year, rd);
        (month = month + months);
        (year = year + CCMath::div_mod(month, month, 12));
        rd = CCHijriCalendar::fixed_from_dmy(day, month, year);
        M_CheckFixedHijri(_T("time"), rd);
        System::DateTime t = M_ToDateTime(rd);
        return t->Add(time->get_TimeOfDay());
    }
    
    System::DateTime HijriCalendar::AddYears_8bb7ea0ef803063e(System::DateTime time, int32_t years) {
        int32_t rd = M_FromDateTime(time);
        int32_t day, month, year;
        CCHijriCalendar::dmy_from_fixed(day, month, year, rd);
        (year = year + years);
        rd = CCHijriCalendar::fixed_from_dmy(day, month, year);
        M_CheckFixedHijri(_T("time"), rd);
        System::DateTime t = M_ToDateTime(rd);
        return t->Add(time->get_TimeOfDay());
    }
    
    int32_t HijriCalendar::GetDayOfMonth_7da4e9f8c6f0dece(System::DateTime time) {
        int32_t rd = M_FromDateTime(time);
        M_CheckFixedHijri(_T("time"), rd);
        return CCHijriCalendar::day_from_fixed(rd);
    }
    
    System::DayOfWeek HijriCalendar::GetDayOfWeek_4c0b69c7bb83520e(System::DateTime time) {
        int32_t rd = M_FromDateTime(time);
        M_CheckFixedHijri(_T("time"), rd);
        return (System::DayOfWeek)(CCFixed::day_of_week(rd));
    }
    
    int32_t HijriCalendar::GetDayOfYear_1eaa1ac34e65f799(System::DateTime time) {
        int32_t rd = M_FromDateTime(time);
        M_CheckFixedHijri(_T("time"), rd);
        int32_t year = CCHijriCalendar::year_from_fixed(rd);
        int32_t rd1_1 = CCHijriCalendar::fixed_from_dmy(1, 1, year);
        return ((rd - rd1_1) + 1);
    }
    
    int32_t HijriCalendar::GetDaysInMonth_233a2cea4d4c72fe(int32_t year, int32_t month, int32_t era) {
        M_CheckYME(year, month, era);
        int32_t rd1 = CCHijriCalendar::fixed_from_dmy(1, month, year);
        int32_t rd2 = CCHijriCalendar::fixed_from_dmy(1, (month + 1), year);
        return (rd2 - rd1);
    }
    
    int32_t HijriCalendar::GetDaysInYear_ae0f8cfee3ff2567(int32_t year, int32_t era) {
        Calendar::M_CheckYE_c830e88539d38d64(year, era);
        int32_t rd1 = CCHijriCalendar::fixed_from_dmy(1, 1, year);
        int32_t rd2 = CCHijriCalendar::fixed_from_dmy(1, 1, (year + 1));
        return (rd2 - rd1);
    }
    
    int32_t HijriCalendar::GetEra_1d16c3456dce785e(System::DateTime time) {
        M_CheckDateTime(time);
        return HijriEra;
    }
    
    int32_t HijriCalendar::GetLeapMonth_fb3256a34d84f7ed(int32_t year, int32_t era) {
        return 0;
    }
    
    int32_t HijriCalendar::GetMonth_66424683b988a96b(System::DateTime time) {
        int32_t rd = M_FromDateTime(time);
        M_CheckFixedHijri(_T("time"), rd);
        return CCHijriCalendar::month_from_fixed(rd);
    }
    
    int32_t HijriCalendar::GetMonthsInYear_2ae36c9a94a7bffb(int32_t year, int32_t era) {
        Calendar::M_CheckYE_c830e88539d38d64(year, era);
        return 12;
    }
    
    int32_t HijriCalendar::GetYear_75c1b17aa90af360(System::DateTime time) {
        int32_t rd = M_FromDateTime(time);
        M_CheckFixedHijri(_T("time"), rd);
        return CCHijriCalendar::year_from_fixed(rd);
    }
    
    bool HijriCalendar::IsLeapDay_7c795c9f36944ade(int32_t year, int32_t month, int32_t day, int32_t era) {
        M_CheckYMDE(year, month, day, era);
        return ((Calendar::IsLeapYear_59be46b16a9b7a45(year) && (month ==  12)) && (day ==  30));
    }
    
    bool HijriCalendar::IsLeapMonth_85b9917f2bdaeef7(int32_t year, int32_t month, int32_t era) {
        M_CheckYME(year, month, era);
        return false;
    }
    
    bool HijriCalendar::IsLeapYear_7aad026a1103cfb(int32_t year, int32_t era) {
        Calendar::M_CheckYE_c830e88539d38d64(year, era);
        return CCHijriCalendar::is_leap_year(year);
    }
    
    System::DateTime HijriCalendar::ToDateTime_82b4ff6780819fcd(int32_t year, int32_t month, int32_t day, int32_t hour, int32_t minute, int32_t second, int32_t millisecond, int32_t era) {
        M_CheckYMDE(year, month, day, era);
        Calendar::M_CheckHMSM(hour, minute, second, millisecond);
        int32_t rd = CCHijriCalendar::fixed_from_dmy(day, month, year);
        return M_ToDateTime2(rd, hour, minute, second, millisecond);
    }
    
    int32_t HijriCalendar::ToFourDigitYear_cb92a104112b3121(int32_t year) {
        return Calendar::ToFourDigitYear_cb92a104112b3121(year);
    }
    
    cli::array<int32_t>* HijriCalendar::get_Eras_91b8aa89b8256658() {
        return (new cli::array<int32_t>({HijriEra}));
    }
    
    int32_t HijriCalendar::get_TwoDigitYearMax_14e9789b3d89e801() {
        return this->twoDigitYearMax;
    }
    
    int32_t HijriCalendar::set_TwoDigitYearMax_4852e071586288ab(int32_t value) {
        Calendar::CheckReadOnly();
        Calendar::M_ArgumentInRange(_T("value"), value, 100, this->get_M_MaxYear_b3d9776fced847fe());
        this->twoDigitYearMax = value;
        return get_TwoDigitYearMax_14e9789b3d89e801();
    }
    
    int32_t HijriCalendar::get_AddHijriDate_de230c2822d0e775() {
        return this->M_AddHijriDate;
    }
    
    int32_t HijriCalendar::set_AddHijriDate_4e624536250a29c4(int32_t value) {
        Calendar::CheckReadOnly();
        if(((value < -3) && (value > 3))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("AddHijriDate"), _T("Value should be between -3 and 3."));
        }
        this->M_AddHijriDate = value;
        return get_AddHijriDate_de230c2822d0e775();
    }
    
    CalendarAlgorithmType HijriCalendar::get_AlgorithmType_1e3f8ed99adb8bde() {
        return CalendarAlgorithmType::LunarCalendar;
    }
    
    System::DateTime HijriCalendar::get_MinSupportedDateTime_63cdcad9cf7fca4e() {
        return Min;
    }
    
    System::DateTime HijriCalendar::get_MaxSupportedDateTime_7bc53f690ae04821() {
        return Max;
    }
    
    int32_t HijriCalendar::get_HijriAdjustment() {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t HijriCalendar::set_HijriAdjustment(int32_t value) {
        throw cli::gcnew<System::NotImplementedException>();
        return get_HijriAdjustment();
    }
    
}}
namespace System { namespace Globalization {
    
    
    void IdnMapping::constructor() {
    }
    
    bool IdnMapping::Equals_ed975d2f4a7d193e(System::Object* obj) {
        IdnMapping *other = cli::as<IdnMapping*>(obj);
        return (((other != nullptr) && (this->allow_unassigned ==  other->allow_unassigned)) && (this->use_std3 ==  other->use_std3));
    }
    
    int32_t IdnMapping::GetHashCode_6648aef0f235ee6c() {
        return (this->allow_unassigned ? 2 : 0 + this->use_std3 ? 1 : 0);
    }
    
    System::String* IdnMapping::GetAscii(System::String* unicode) {
        if((unicode ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("unicode"));
        }
        return GetAscii3(unicode, 0, unicode->get_Length());
    }
    
    System::String* IdnMapping::GetAscii2(System::String* unicode, int32_t index) {
        if((unicode ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("unicode"));
        }
        return GetAscii3(unicode, index, (unicode->get_Length() - index));
    }
    
    System::String* IdnMapping::GetAscii3(System::String* unicode, int32_t index, int32_t count) {
        if((unicode ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("unicode"));
        }
        if((index < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("index must be non-negative value"));
        }
        if(((count < 0) || ((index + count) > unicode->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("index + count must point inside the argument unicode string"));
        }
        return Convert2(unicode, index, count, true);
    }
    
    System::String* IdnMapping::Convert2(System::String* input, int32_t index, int32_t count, bool toAscii) {
        System::String *s = input->Substring2(index, count);
        for(int32_t i = 0; (i < s->get_Length()); i++) {
            if(((int32_t)(s->get_Chars(i)) >= 128)) 
            {
                s = s->ToLower2(CultureInfo::get_InvariantCulture());
                break;
            }
        }
        cli::array<System::String*> *labels = s->Split((new cli::array<char16_t>({u'.', u'\x3002', u'\xff0e', u'\xff61'})));
        int32_t iter = 0;
        for(int32_t i = 0; (i < labels->get_Length()); (iter = iter + labels->at(i)->get_Length()), i++){
            if(((labels->at(i)->get_Length() ==  0) && ((i + 1) ==  labels->get_Length()))) 
            {
                continue;
            }
            if(toAscii) 
            {
                labels->at(i) = ToAscii(labels->at(i), iter);
            }
             else 
            {
                labels->at(i) = ToUnicode(labels->at(i), iter);
            }
        }
        return System::String::Join(_T("."), labels);
    }
    
    System::String* IdnMapping::ToAscii(System::String* s, int32_t offset) {
        for(int32_t i = 0; (i < s->get_Length()); i++){
            if((((int32_t)(s->get_Chars(i)) < 32) || ((int32_t)(s->get_Chars(i)) ==  127))) 
            {
                throw cli::gcnew<System::ArgumentException>(System::String::Format2(_T("Not allowed character was found, at {0}"), cli::box((offset + i))));
            }
            if(((int32_t)(s->get_Chars(i)) >= 128)) 
            {
                s = NamePrep(s, offset);
                break;
            }
        }
        if(this->use_std3) 
        {
            VerifyStd3AsciiRules(s, offset);
        }
        for(int32_t i = 0; (i < s->get_Length()); i++){
            if(((int32_t)(s->get_Chars(i)) >= 128)) 
            {
                if(s->StartsWith2(_T("xn--"), System::StringComparison::OrdinalIgnoreCase)) 
                {
                    throw cli::gcnew<System::ArgumentException>(System::String::Format2(_T("The input string must not start with ACE (xn--), at {0}"), cli::box((offset + i))));
                }
                s = this->puny->Encode(s, offset);
                s = cli::concat(_T("xn--"), s);
                break;
            }
        }
        VerifyLength(s, offset);
        return s;
    }
    
    void IdnMapping::VerifyLength(System::String* s, int32_t offset) {
        if((s->get_Length() ==  0)) 
        {
            throw cli::gcnew<System::ArgumentException>(System::String::Format2(_T("A label in the input string resulted in an invalid zero-length string, at {0}"), cli::box(offset)));
        }
        if((s->get_Length() > 63)) 
        {
            throw cli::gcnew<System::ArgumentException>(System::String::Format2(_T("A label in the input string exceeded the length in ASCII representation, at {0}"), cli::box(offset)));
        }
    }
    
    System::String* IdnMapping::NamePrep(System::String* s, int32_t offset) {
        s = s->Normalize2(System::Text::NormalizationForm::FormKC);
        VerifyProhibitedCharacters(s, offset);
        if(!(this->allow_unassigned)) 
        {
            for(int32_t i = 0; (i < s->get_Length()); i++) {
                if(((int32_t)(System::Char::GetUnicodeCategory2(s, i)) ==  29)) 
                {
                    throw cli::gcnew<System::ArgumentException>(System::String::Format2(_T("Use of unassigned Unicode characer is prohibited in this IdnMapping, at {0}"), cli::box((offset + i))));
                }
            }
        }
        return s;
    }
    
    void IdnMapping::VerifyProhibitedCharacters(System::String* s, int32_t offset) {
        for(int32_t i = 0; (i < s->get_Length()); i++){
            switch(System::Char::GetUnicodeCategory2(s, i)) {
                case UnicodeCategory::SpaceSeparator: case_1066: {
                    if(((int32_t)(s->get_Chars(i)) < 128)) 
                    {
                        continue;
                    }
                    break;
                }
                case UnicodeCategory::Control: case_1067: {
                    if((((int32_t)(s->get_Chars(i)) != 0) && ((int32_t)(s->get_Chars(i)) < 128))) 
                    {
                        continue;
                    }
                    break;
                }
                case UnicodeCategory::PrivateUse: case UnicodeCategory::Surrogate: case_1068: {
                    break;
                }
                default: case_1069: {
                    char16_t c = s->get_Chars(i);
                    if((((((((64991 <= (int32_t)(c)) && ((int32_t)(c) <= 65007)) || (((int32_t)(c) & 65535) ==  65534)) || ((65529 <= (int32_t)(c)) && ((int32_t)(c) <= 65533))) || ((12272 <= (int32_t)(c)) && ((int32_t)(c) <= 12283))) || ((8234 <= (int32_t)(c)) && ((int32_t)(c) <= 8238))) || ((8298 <= (int32_t)(c)) && ((int32_t)(c) <= 8303)))) 
                    {
                        break;
                    }
                    switch(c) {
                        case u'\x340': case u'\x341': case u'\x200e': case u'\x200f': case u'\x2028': case u'\x2029': case_1070: {
                            break;
                        }
                        default: case_1071: {
                            continue;
                        }
                    }
                    break;
                }
            }
            throw cli::gcnew<System::ArgumentException>(System::String::Format2(_T("Not allowed character was in the input string, at {0}"), cli::box((offset + i))));
        }
    }
    
    void IdnMapping::VerifyStd3AsciiRules(System::String* s, int32_t offset) {
        if(((s->get_Length() > 0) && ((int32_t)(s->get_Chars(0)) ==  45))) 
        {
            throw cli::gcnew<System::ArgumentException>(System::String::Format2(_T("\'-\' is not allowed at head of a sequence in STD3 mode, found at {0}"), cli::box(offset)));
        }
        if(((s->get_Length() > 0) && ((int32_t)(s->get_Chars((s->get_Length() - 1))) ==  45))) 
        {
            throw cli::gcnew<System::ArgumentException>(System::String::Format2(_T("\'-\' is not allowed at tail of a sequence in STD3 mode, found at {0}"), cli::box(((offset + s->get_Length()) - 1))));
        }
        for(int32_t i = 0; (i < s->get_Length()); i++){
            char16_t c = s->get_Chars(i);
            if(((int32_t)(c) ==  45)) 
            {
                continue;
            }
            if((((((int32_t)(c) <= 47) || ((58 <= (int32_t)(c)) && ((int32_t)(c) <= 64))) || ((91 <= (int32_t)(c)) && ((int32_t)(c) <= 96))) || ((123 <= (int32_t)(c)) && ((int32_t)(c) <= 127)))) 
            {
                throw cli::gcnew<System::ArgumentException>(System::String::Format2(_T("Not allowed character in STD3 mode, found at {0}"), cli::box((offset + i))));
            }
        }
    }
    
    System::String* IdnMapping::GetUnicode(System::String* ascii) {
        if((ascii ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("ascii"));
        }
        return GetUnicode3(ascii, 0, ascii->get_Length());
    }
    
    System::String* IdnMapping::GetUnicode2(System::String* ascii, int32_t index) {
        if((ascii ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("ascii"));
        }
        return GetUnicode3(ascii, index, (ascii->get_Length() - index));
    }
    
    System::String* IdnMapping::GetUnicode3(System::String* ascii, int32_t index, int32_t count) {
        if((ascii ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("ascii"));
        }
        if((index < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("index must be non-negative value"));
        }
        if(((count < 0) || ((index + count) > ascii->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("index + count must point inside the argument ascii string"));
        }
        return Convert2(ascii, index, count, false);
    }
    
    System::String* IdnMapping::ToUnicode(System::String* s, int32_t offset) {
        for(int32_t i = 0; (i < s->get_Length()); i++){
            if(((int32_t)(s->get_Chars(i)) >= 128)) 
            {
                s = NamePrep(s, offset);
                break;
            }
        }
        if(!(s->StartsWith2(_T("xn--"), System::StringComparison::OrdinalIgnoreCase))) 
        {
            return s;
        }
        s = s->ToLower2(CultureInfo::get_InvariantCulture());
        System::String *at3 = s;
        s = s->Substring(4);
        s = this->puny->Decode(s, offset);
        System::String *at5 = s;
        s = ToAscii(s, offset);
        if((System::String::Compare7(at3, s, System::StringComparison::OrdinalIgnoreCase) != 0)) 
        {
            throw cli::gcnew<System::ArgumentException>(System::String::Format2(_T("ToUnicode() failed at verifying the result, at label part from {0}"), cli::box(offset)));
        }
        return at5;
    }
    
    bool IdnMapping::get_AllowUnassigned() {
        return this->allow_unassigned;
    }
    
    bool IdnMapping::set_AllowUnassigned(bool value) {
        this->allow_unassigned = value;
        return get_AllowUnassigned();
    }
    
    bool IdnMapping::get_UseStd3AsciiRules() {
        return this->use_std3;
    }
    
    bool IdnMapping::set_UseStd3AsciiRules(bool value) {
        this->use_std3 = value;
        return get_UseStd3AsciiRules();
    }
    
}}
namespace System { namespace Globalization {
    
    
    void Bootstring::constructor(char16_t delimiter, int32_t baseNum, int32_t tmin, int32_t tmax, int32_t skew, int32_t damp, int32_t initialBias, int32_t initialN) {
        this->delimiter = delimiter;
        this->base_num = baseNum;
        this->tmin = tmin;
        this->tmax = tmax;
        this->skew = skew;
        this->damp = damp;
        this->initial_bias = initialBias;
        this->initial_n = initialN;
    }
    
    System::String* Bootstring::Encode(System::String* s, int32_t offset) {
        int32_t n = this->initial_n;
        int32_t delta = 0;
        int32_t bias = this->initial_bias;
        int32_t b = 0, h = 0;
        System::Text::StringBuilder *sb = cli::gcnew<System::Text::StringBuilder>();
        for(int32_t i = 0; (i < s->get_Length()); i++) {
            if(((int32_t)(s->get_Chars(i)) < 128)) 
            {
                sb->Append16(s->get_Chars(i));
            }
        }
        b = h = sb->get_Length();
        if((b > 0)) 
        {
            sb->Append16(this->delimiter);
        }
        while((h < s->get_Length())) {
            int32_t m = 2147483647;
            for(int32_t i = 0; (i < s->get_Length()); i++) {
                if((((int32_t)(s->get_Chars(i)) >= n) && ((int32_t)(s->get_Chars(i)) < m))) 
                {
                    m = (int32_t)(s->get_Chars(i));
                }
            }
            /*checked*/ {
                (delta = delta + ((m - n) * (h + 1)));
            }
            n = m;
            for(int32_t i = 0; (i < s->get_Length()); i++){
                char16_t c = s->get_Chars(i);
                if((((int32_t)(c) < n) || ((int32_t)(c) < 128))) 
                {
                    /*checked*/ {
                        delta++;
                    }
                }
                if(((int32_t)(c) ==  n)) 
                {
                    int32_t q = delta;
                    for(int32_t k = this->base_num; ; (k = k + this->base_num)){
                        int32_t t = (k <= (bias + this->tmin)) ? this->tmin : (k >= (bias + this->tmax)) ? this->tmax : (k - bias);
                        if((q < t)) 
                        {
                            break;
                        }
                        sb->Append16(EncodeDigit((t + ((q - t) % (this->base_num - t)))));
                        q = ((q - t) / (this->base_num - t));
                    }
                    sb->Append16(EncodeDigit(q));
                    bias = Adapt(delta, (h + 1), (h ==  b));
                    delta = 0;
                    h++;
                }
            }
            delta++;
            n++;
        }
        return sb->ToString_1636a0751cb9ac11();
    }
    
    char16_t Bootstring::EncodeDigit(int32_t d) {
        return (char16_t)(d < 26) ? (d + 97) : ((d - 26) + 48);
    }
    
    int32_t Bootstring::DecodeDigit(char16_t c) {
        return (((int32_t)(c) - 48) < 10) ? ((int32_t)(c) - 22) : (((int32_t)(c) - 65) < 26) ? ((int32_t)(c) - 65) : (((int32_t)(c) - 97) < 26) ? ((int32_t)(c) - 97) : this->base_num;
    }
    
    int32_t Bootstring::Adapt(int32_t delta, int32_t numPoints, bool firstTime) {
        if(firstTime) 
        {
            delta = (delta / this->damp);
        }
         else 
        {
            delta = (delta / 2);
        }
        delta = (delta + (delta / numPoints));
        int32_t k = 0;
        while((delta > (((this->base_num - this->tmin) * this->tmax) / 2))) {
            delta = (delta / (this->base_num - this->tmin));
            (k = k + this->base_num);
        }
        return (k + ((((this->base_num - this->tmin) + 1) * delta) / (delta + this->skew)));
    }
    
    System::String* Bootstring::Decode(System::String* s, int32_t offset) {
        int32_t n = this->initial_n;
        int32_t i = 0;
        int32_t bias = this->initial_bias;
        int32_t b = 0;
        System::Text::StringBuilder *sb = cli::gcnew<System::Text::StringBuilder>();
        for(int32_t j = 0; (j < s->get_Length()); j++){
            if(((int32_t)(s->get_Chars(j)) ==  (int32_t)(this->delimiter))) 
            {
                b = j;
            }
        }
        if((b < 0)) 
        {
            return s;
        }
        sb->Append19(s, 0, b);
        for(int32_t z = (b > 0) ? (b + 1) : 0; (z < s->get_Length()); ){
            int32_t old_i = i;
            int32_t w = 1;
            for(int32_t k = this->base_num; ; (k = k + this->base_num)){
                int32_t digit = DecodeDigit(s->get_Chars(z++));
                i = (i + (digit * w));
                int32_t t = (k <= (bias + this->tmin)) ? this->tmin : (k >= (bias + this->tmax)) ? this->tmax : (k - bias);
                if((digit < t)) 
                {
                    break;
                }
                w = (w * (this->base_num - t));
            }
            bias = Adapt((i - old_i), (sb->get_Length() + 1), (old_i ==  0));
            n = (n + (i / (sb->get_Length() + 1)));
            i = (i % (sb->get_Length() + 1));
            if((n < 128)) 
            {
                throw cli::gcnew<System::ArgumentException>(System::String::Format2(_T("Invalid Bootstring decode result, at {0}"), cli::box((offset + z))));
            }
            sb->Insert5(i, (char16_t)n);
            i++;
        }
        return sb->ToString_1636a0751cb9ac11();
    }
    
}}
namespace System { namespace Globalization {
    
    
    void Punycode::constructor() {
    }
    
}}
namespace System { namespace Globalization {
    
    CCGregorianEraHandler*  JapaneseCalendar::M_EraHandler;
    System::DateTime  JapaneseCalendar::JapanMin;
    System::DateTime  JapaneseCalendar::JapanMax;
    
    JapaneseCalendar::JapaneseCalendar()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void JapaneseCalendar::static_constructor() {
        M_EraHandler = cli::gcnew<CCGregorianEraHandler>();
        M_EraHandler->appendEra(1, CCGregorianCalendar::fixed_from_dmy(8, 9, 1868), CCGregorianCalendar::fixed_from_dmy(29, 7, 1912));
        M_EraHandler->appendEra(2, CCGregorianCalendar::fixed_from_dmy(30, 7, 1912), CCGregorianCalendar::fixed_from_dmy(24, 12, 1926));
        M_EraHandler->appendEra(3, CCGregorianCalendar::fixed_from_dmy(25, 12, 1926), CCGregorianCalendar::fixed_from_dmy(7, 1, 1989));
        M_EraHandler->appendEra2(4, CCGregorianCalendar::fixed_from_dmy(8, 1, 1989));
    }
    
    void JapaneseCalendar::constructor() {
        this->M_AbbrEraNames = (new cli::array<System::String*>({_T("M"), _T("T"), _T("S"), _T("H")}));
        this->M_EraNames = (new cli::array<System::String*>({_T("Meiji"), _T("Taisho"), _T("Showa"), _T("Heisei")}));
    }
    
    void JapaneseCalendar::M_CheckDateTime(System::DateTime time) {
        M_EraHandler->CheckDateTime(time);
    }
    
    void JapaneseCalendar::M_CheckEra(int32_t era) {
        if((era ==  0)) 
        {
            era = 4;
        }
        if(!(M_EraHandler->ValidEra(era))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Era value was not valid."));
        }
    }
    
    int32_t JapaneseCalendar::M_CheckYEG(int32_t year, int32_t era) {
        M_CheckEra(era);
        return M_EraHandler->GregorianYear(year, era);
    }
    
    void JapaneseCalendar::M_CheckYE_c830e88539d38d64(int32_t year, int32_t era) {
        M_CheckYEG(year, era);
    }
    
    int32_t JapaneseCalendar::M_CheckYMEG(int32_t year, int32_t month, int32_t era) {
        int32_t gregorianYear = M_CheckYEG(year, era);
        if(((month < 1) || (month > 12))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("month"), _T("Month must be between one and twelve."));
        }
        return gregorianYear;
    }
    
    int32_t JapaneseCalendar::M_CheckYMDEG(int32_t year, int32_t month, int32_t day, int32_t era) {
        int32_t gregorianYear = M_CheckYMEG(year, month, era);
        Calendar::M_ArgumentInRange(_T("day"), day, 1, JapaneseCalendar::GetDaysInMonth_233a2cea4d4c72fe(year, month, era));
        return gregorianYear;
    }
    
    System::DateTime JapaneseCalendar::AddMonths_a4a4579bf9385278(System::DateTime time, int32_t months) {
        System::DateTime t = CCGregorianCalendar::AddMonths(time, months);
        M_CheckDateTime(t);
        return t;
    }
    
    System::DateTime JapaneseCalendar::AddYears_8bb7ea0ef803063e(System::DateTime time, int32_t years) {
        System::DateTime t = CCGregorianCalendar::AddYears(time, years);
        M_CheckDateTime(t);
        return t;
    }
    
    int32_t JapaneseCalendar::GetDayOfMonth_7da4e9f8c6f0dece(System::DateTime time) {
        M_CheckDateTime(time);
        return CCGregorianCalendar::GetDayOfMonth(time);
    }
    
    System::DayOfWeek JapaneseCalendar::GetDayOfWeek_4c0b69c7bb83520e(System::DateTime time) {
        M_CheckDateTime(time);
        int32_t rd = CCFixed::FromDateTime(time);
        return (System::DayOfWeek)(CCFixed::day_of_week(rd));
    }
    
    int32_t JapaneseCalendar::GetDayOfYear_1eaa1ac34e65f799(System::DateTime time) {
        M_CheckDateTime(time);
        return CCGregorianCalendar::GetDayOfYear(time);
    }
    
    int32_t JapaneseCalendar::GetDaysInMonth_233a2cea4d4c72fe(int32_t year, int32_t month, int32_t era) {
        int32_t gregorianYear = M_CheckYMEG(year, month, era);
        return CCGregorianCalendar::GetDaysInMonth(gregorianYear, month);
    }
    
    int32_t JapaneseCalendar::GetDaysInYear_ae0f8cfee3ff2567(int32_t year, int32_t era) {
        int32_t gregorianYear = M_CheckYEG(year, era);
        return CCGregorianCalendar::GetDaysInYear(gregorianYear);
    }
    
    int32_t JapaneseCalendar::GetEra_1d16c3456dce785e(System::DateTime time) {
        int32_t rd = CCFixed::FromDateTime(time);
        int32_t era;
        M_EraHandler->EraYear(era, rd);
        return era;
    }
    
    int32_t JapaneseCalendar::GetLeapMonth_fb3256a34d84f7ed(int32_t year, int32_t era) {
        return 0;
    }
    
    int32_t JapaneseCalendar::GetMonth_66424683b988a96b(System::DateTime time) {
        M_CheckDateTime(time);
        return CCGregorianCalendar::GetMonth(time);
    }
    
    int32_t JapaneseCalendar::GetMonthsInYear_2ae36c9a94a7bffb(int32_t year, int32_t era) {
        Calendar::M_CheckYE_c830e88539d38d64(year, era);
        return 12;
    }
    
    int32_t JapaneseCalendar::GetWeekOfYear_d25712e900e29bec(System::DateTime time, CalendarWeekRule rule, System::DayOfWeek firstDayOfWeek) {
        return Calendar::GetWeekOfYear_d25712e900e29bec(time, rule, firstDayOfWeek);
    }
    
    int32_t JapaneseCalendar::GetYear_75c1b17aa90af360(System::DateTime time) {
        int32_t rd = CCFixed::FromDateTime(time);
        int32_t era;
        return M_EraHandler->EraYear(era, rd);
    }
    
    bool JapaneseCalendar::IsLeapDay_7c795c9f36944ade(int32_t year, int32_t month, int32_t day, int32_t era) {
        int32_t gregorianYear = M_CheckYMDEG(year, month, day, era);
        return CCGregorianCalendar::IsLeapDay(gregorianYear, month, day);
    }
    
    bool JapaneseCalendar::IsLeapMonth_85b9917f2bdaeef7(int32_t year, int32_t month, int32_t era) {
        M_CheckYMEG(year, month, era);
        return false;
    }
    
    bool JapaneseCalendar::IsLeapYear_7aad026a1103cfb(int32_t year, int32_t era) {
        int32_t gregorianYear = M_CheckYEG(year, era);
        return CCGregorianCalendar::is_leap_year(gregorianYear);
    }
    
    System::DateTime JapaneseCalendar::ToDateTime_82b4ff6780819fcd(int32_t year, int32_t month, int32_t day, int32_t hour, int32_t minute, int32_t second, int32_t millisecond, int32_t era) {
        int32_t gregorianYear = M_CheckYMDEG(year, month, day, era);
        Calendar::M_CheckHMSM(hour, minute, second, millisecond);
        return CCGregorianCalendar::ToDateTime(gregorianYear, month, day, hour, minute, second, millisecond);
    }
    
    int32_t JapaneseCalendar::ToFourDigitYear_cb92a104112b3121(int32_t year) {
        if((year < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("year"), _T("Non-negative number required."));
        }
        int32_t era = 0;
        Calendar::M_CheckYE_c830e88539d38d64(year, era);
        return year;
    }
    
    cli::array<int32_t>* JapaneseCalendar::get_Eras_91b8aa89b8256658() {
        return cli::cast<cli::array<int32_t>*>(cli::import(M_EraHandler->get_Eras())->Clone());
    }
    
    int32_t JapaneseCalendar::get_TwoDigitYearMax_14e9789b3d89e801() {
        return this->twoDigitYearMax;
    }
    
    int32_t JapaneseCalendar::set_TwoDigitYearMax_4852e071586288ab(int32_t value) {
        Calendar::CheckReadOnly();
        Calendar::M_ArgumentInRange(_T("value"), value, 100, this->get_M_MaxYear_b3d9776fced847fe());
        this->twoDigitYearMax = value;
        return get_TwoDigitYearMax_14e9789b3d89e801();
    }
    
    CalendarAlgorithmType JapaneseCalendar::get_AlgorithmType_1e3f8ed99adb8bde() {
        return CalendarAlgorithmType::SolarCalendar;
    }
    
    System::DateTime JapaneseCalendar::get_MinSupportedDateTime_63cdcad9cf7fca4e() {
        return JapanMin;
    }
    
    System::DateTime JapaneseCalendar::get_MaxSupportedDateTime_7bc53f690ae04821() {
        return JapanMax;
    }
    
}}
namespace System { namespace Globalization {
    
    CCEastAsianLunisolarEraHandler*  JapaneseLunisolarCalendar::era_handler;
    System::DateTime  JapaneseLunisolarCalendar::JapanMin;
    System::DateTime  JapaneseLunisolarCalendar::JapanMax;
    
    JapaneseLunisolarCalendar::JapaneseLunisolarCalendar()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void JapaneseLunisolarCalendar::static_constructor() {
        era_handler = cli::gcnew<CCEastAsianLunisolarEraHandler>();
        era_handler->appendEra(3, CCGregorianCalendar::fixed_from_dmy(25, 12, 1926), CCGregorianCalendar::fixed_from_dmy(7, 1, 1989));
        era_handler->appendEra2(4, CCGregorianCalendar::fixed_from_dmy(8, 1, 1989));
    }
    
    void JapaneseLunisolarCalendar::constructor() {
    }
    
    int32_t JapaneseLunisolarCalendar::GetEra_1d16c3456dce785e(System::DateTime time) {
        int32_t rd = CCFixed::FromDateTime(time);
        int32_t era;
        era_handler->EraYear(era, rd);
        return era;
    }
    
    int32_t JapaneseLunisolarCalendar::get_ActualCurrentEra_d2c09b5f859d63e9() {
        return 4;
    }
    
    cli::array<int32_t>* JapaneseLunisolarCalendar::get_Eras_91b8aa89b8256658() {
        return cli::cast<cli::array<int32_t>*>(cli::import(era_handler->get_Eras())->Clone());
    }
    
    System::DateTime JapaneseLunisolarCalendar::get_MinSupportedDateTime_63cdcad9cf7fca4e() {
        return JapanMin;
    }
    
    System::DateTime JapaneseLunisolarCalendar::get_MaxSupportedDateTime_7bc53f690ae04821() {
        return JapanMax;
    }
    
}}
namespace System { namespace Globalization {
    
    int32_t  JulianCalendar::JulianEra;
    System::DateTime  JulianCalendar::JulianMin;
    System::DateTime  JulianCalendar::JulianMax;
    
    JulianCalendar::JulianCalendar()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void JulianCalendar::constructor() {
        this->M_AbbrEraNames = (new cli::array<System::String*>({_T("C.E.")}));
        this->M_EraNames = (new cli::array<System::String*>({_T("Common Era")}));
        if((this->twoDigitYearMax ==  99)) 
        {
            this->twoDigitYearMax = 2029;
        }
    }
    
    void JulianCalendar::static_constructor() {
    }
    
    void JulianCalendar::M_CheckEra(int32_t era) {
        if((era ==  0)) 
        {
            era = JulianEra;
        }
        if((era != JulianEra)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Era value was not valid."));
        }
    }
    
    void JulianCalendar::M_CheckYE_c830e88539d38d64(int32_t year, int32_t era) {
        M_CheckEra(era);
        Calendar::M_ArgumentInRange(_T("year"), year, 1, 9999);
    }
    
    void JulianCalendar::M_CheckYME(int32_t year, int32_t month, int32_t era) {
        Calendar::M_CheckYE_c830e88539d38d64(year, era);
        if(((month < 1) || (month > 12))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("month"), _T("Month must be between one and twelve."));
        }
    }
    
    void JulianCalendar::M_CheckYMDE(int32_t year, int32_t month, int32_t day, int32_t era) {
        M_CheckYME(year, month, era);
        Calendar::M_ArgumentInRange(_T("day"), day, 1, JulianCalendar::GetDaysInMonth_233a2cea4d4c72fe(year, month, era));
        if(((year ==  9999) && (((month ==  10) && (day > 19)) || (month > 10)))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("The maximum Julian date is 19. 10. 9999."));
        }
    }
    
    System::DateTime JulianCalendar::AddMonths_a4a4579bf9385278(System::DateTime time, int32_t months) {
        int32_t rd = CCFixed::FromDateTime(time);
        int32_t day, month, year;
        CCJulianCalendar::dmy_from_fixed(day, month, year, rd);
        (month = month + months);
        (year = year + CCMath::div_mod(month, month, 12));
        rd = CCJulianCalendar::fixed_from_dmy(day, month, year);
        System::DateTime t = CCFixed::ToDateTime(rd);
        return t->Add(time->get_TimeOfDay());
    }
    
    System::DateTime JulianCalendar::AddYears_8bb7ea0ef803063e(System::DateTime time, int32_t years) {
        int32_t rd = CCFixed::FromDateTime(time);
        int32_t day, month, year;
        CCJulianCalendar::dmy_from_fixed(day, month, year, rd);
        (year = year + years);
        rd = CCJulianCalendar::fixed_from_dmy(day, month, year);
        System::DateTime t = CCFixed::ToDateTime(rd);
        return t->Add(time->get_TimeOfDay());
    }
    
    int32_t JulianCalendar::GetDayOfMonth_7da4e9f8c6f0dece(System::DateTime time) {
        int32_t rd = CCFixed::FromDateTime(time);
        return CCJulianCalendar::day_from_fixed(rd);
    }
    
    System::DayOfWeek JulianCalendar::GetDayOfWeek_4c0b69c7bb83520e(System::DateTime time) {
        int32_t rd = CCFixed::FromDateTime(time);
        return (System::DayOfWeek)(CCFixed::day_of_week(rd));
    }
    
    int32_t JulianCalendar::GetDayOfYear_1eaa1ac34e65f799(System::DateTime time) {
        int32_t rd = CCFixed::FromDateTime(time);
        int32_t year = CCJulianCalendar::year_from_fixed(rd);
        int32_t rd1_1 = CCJulianCalendar::fixed_from_dmy(1, 1, year);
        return ((rd - rd1_1) + 1);
    }
    
    int32_t JulianCalendar::GetDaysInMonth_233a2cea4d4c72fe(int32_t year, int32_t month, int32_t era) {
        M_CheckYME(year, month, era);
        int32_t rd1 = CCJulianCalendar::fixed_from_dmy(1, month, year);
        int32_t rd2 = CCJulianCalendar::fixed_from_dmy(1, (month + 1), year);
        return (rd2 - rd1);
    }
    
    int32_t JulianCalendar::GetDaysInYear_ae0f8cfee3ff2567(int32_t year, int32_t era) {
        Calendar::M_CheckYE_c830e88539d38d64(year, era);
        int32_t rd1 = CCJulianCalendar::fixed_from_dmy(1, 1, year);
        int32_t rd2 = CCJulianCalendar::fixed_from_dmy(1, 1, (year + 1));
        return (rd2 - rd1);
    }
    
    int32_t JulianCalendar::GetEra_1d16c3456dce785e(System::DateTime time) {
        return JulianEra;
    }
    
    int32_t JulianCalendar::GetLeapMonth_fb3256a34d84f7ed(int32_t year, int32_t era) {
        return 0;
    }
    
    int32_t JulianCalendar::GetMonth_66424683b988a96b(System::DateTime time) {
        int32_t rd = CCFixed::FromDateTime(time);
        return CCJulianCalendar::month_from_fixed(rd);
    }
    
    int32_t JulianCalendar::GetMonthsInYear_2ae36c9a94a7bffb(int32_t year, int32_t era) {
        Calendar::M_CheckYE_c830e88539d38d64(year, era);
        return 12;
    }
    
    int32_t JulianCalendar::GetYear_75c1b17aa90af360(System::DateTime time) {
        int32_t rd = CCFixed::FromDateTime(time);
        return CCJulianCalendar::year_from_fixed(rd);
    }
    
    bool JulianCalendar::IsLeapDay_7c795c9f36944ade(int32_t year, int32_t month, int32_t day, int32_t era) {
        M_CheckYMDE(year, month, day, era);
        return ((Calendar::IsLeapYear_59be46b16a9b7a45(year) && (month ==  2)) && (day ==  29));
    }
    
    bool JulianCalendar::IsLeapMonth_85b9917f2bdaeef7(int32_t year, int32_t month, int32_t era) {
        M_CheckYME(year, month, era);
        return false;
    }
    
    bool JulianCalendar::IsLeapYear_7aad026a1103cfb(int32_t year, int32_t era) {
        Calendar::M_CheckYE_c830e88539d38d64(year, era);
        return CCJulianCalendar::is_leap_year(year);
    }
    
    System::DateTime JulianCalendar::ToDateTime_82b4ff6780819fcd(int32_t year, int32_t month, int32_t day, int32_t hour, int32_t minute, int32_t second, int32_t millisecond, int32_t era) {
        M_CheckYMDE(year, month, day, era);
        Calendar::M_CheckHMSM(hour, minute, second, millisecond);
        int32_t rd = CCJulianCalendar::fixed_from_dmy(day, month, year);
        return CCFixed::ToDateTime2(rd, hour, minute, second, (double)(millisecond));
    }
    
    int32_t JulianCalendar::ToFourDigitYear_cb92a104112b3121(int32_t year) {
        return Calendar::ToFourDigitYear_cb92a104112b3121(year);
    }
    
    cli::array<int32_t>* JulianCalendar::get_Eras_91b8aa89b8256658() {
        return (new cli::array<int32_t>({JulianEra}));
    }
    
    int32_t JulianCalendar::get_TwoDigitYearMax_14e9789b3d89e801() {
        return this->twoDigitYearMax;
    }
    
    int32_t JulianCalendar::set_TwoDigitYearMax_4852e071586288ab(int32_t value) {
        Calendar::CheckReadOnly();
        Calendar::M_ArgumentInRange(_T("value"), value, 100, this->get_M_MaxYear_b3d9776fced847fe());
        this->twoDigitYearMax = value;
        return get_TwoDigitYearMax_14e9789b3d89e801();
    }
    
    CalendarAlgorithmType JulianCalendar::get_AlgorithmType_1e3f8ed99adb8bde() {
        return CalendarAlgorithmType::SolarCalendar;
    }
    
    System::DateTime JulianCalendar::get_MinSupportedDateTime_63cdcad9cf7fca4e() {
        return JulianMin;
    }
    
    System::DateTime JulianCalendar::get_MaxSupportedDateTime_7bc53f690ae04821() {
        return JulianMax;
    }
    
}}
namespace System { namespace Globalization {
    
    CCGregorianEraHandler*  KoreanCalendar::M_EraHandler;
    System::DateTime  KoreanCalendar::KoreanMin;
    System::DateTime  KoreanCalendar::KoreanMax;
    
    KoreanCalendar::KoreanCalendar()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void KoreanCalendar::static_constructor() {
        M_EraHandler = cli::gcnew<CCGregorianEraHandler>();
        M_EraHandler->appendEra2(1, CCGregorianCalendar::fixed_from_dmy(1, 1, -2332));
    }
    
    void KoreanCalendar::constructor() {
        this->M_AbbrEraNames = (new cli::array<System::String*>({_T("K.C.E.")}));
        this->M_EraNames = (new cli::array<System::String*>({_T("Korean Current Era")}));
        if((this->twoDigitYearMax ==  99)) 
        {
            this->twoDigitYearMax = 4362;
        }
    }
    
    void KoreanCalendar::M_CheckEra(int32_t era) {
        if((era ==  0)) 
        {
            era = 1;
        }
        if(!(M_EraHandler->ValidEra(era))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Era value was not valid."));
        }
    }
    
    int32_t KoreanCalendar::M_CheckYEG(int32_t year, int32_t era) {
        M_CheckEra(era);
        return M_EraHandler->GregorianYear(year, era);
    }
    
    void KoreanCalendar::M_CheckYE_c830e88539d38d64(int32_t year, int32_t era) {
        M_CheckYEG(year, era);
    }
    
    int32_t KoreanCalendar::M_CheckYMEG(int32_t year, int32_t month, int32_t era) {
        int32_t gregorianYear = M_CheckYEG(year, era);
        if(((month < 1) || (month > 12))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("month"), _T("Month must be between one and twelve."));
        }
        return gregorianYear;
    }
    
    int32_t KoreanCalendar::M_CheckYMDEG(int32_t year, int32_t month, int32_t day, int32_t era) {
        int32_t gregorianYear = M_CheckYMEG(year, month, era);
        Calendar::M_ArgumentInRange(_T("day"), day, 1, KoreanCalendar::GetDaysInMonth_233a2cea4d4c72fe(year, month, era));
        return gregorianYear;
    }
    
    System::DateTime KoreanCalendar::AddMonths_a4a4579bf9385278(System::DateTime time, int32_t months) {
        return CCGregorianCalendar::AddMonths(time, months);
    }
    
    System::DateTime KoreanCalendar::AddYears_8bb7ea0ef803063e(System::DateTime time, int32_t years) {
        return CCGregorianCalendar::AddYears(time, years);
    }
    
    int32_t KoreanCalendar::GetDayOfMonth_7da4e9f8c6f0dece(System::DateTime time) {
        return CCGregorianCalendar::GetDayOfMonth(time);
    }
    
    System::DayOfWeek KoreanCalendar::GetDayOfWeek_4c0b69c7bb83520e(System::DateTime time) {
        int32_t rd = CCFixed::FromDateTime(time);
        return (System::DayOfWeek)(CCFixed::day_of_week(rd));
    }
    
    int32_t KoreanCalendar::GetDayOfYear_1eaa1ac34e65f799(System::DateTime time) {
        return CCGregorianCalendar::GetDayOfYear(time);
    }
    
    int32_t KoreanCalendar::GetDaysInMonth_233a2cea4d4c72fe(int32_t year, int32_t month, int32_t era) {
        int32_t gregorianYear = M_CheckYMEG(year, month, era);
        return CCGregorianCalendar::GetDaysInMonth(gregorianYear, month);
    }
    
    int32_t KoreanCalendar::GetDaysInYear_ae0f8cfee3ff2567(int32_t year, int32_t era) {
        int32_t gregorianYear = M_CheckYEG(year, era);
        return CCGregorianCalendar::GetDaysInYear(gregorianYear);
    }
    
    int32_t KoreanCalendar::GetEra_1d16c3456dce785e(System::DateTime time) {
        int32_t rd = CCFixed::FromDateTime(time);
        int32_t era;
        M_EraHandler->EraYear(era, rd);
        return era;
    }
    
    int32_t KoreanCalendar::GetLeapMonth_fb3256a34d84f7ed(int32_t year, int32_t era) {
        return 0;
    }
    
    int32_t KoreanCalendar::GetMonth_66424683b988a96b(System::DateTime time) {
        return CCGregorianCalendar::GetMonth(time);
    }
    
    int32_t KoreanCalendar::GetMonthsInYear_2ae36c9a94a7bffb(int32_t year, int32_t era) {
        M_CheckYEG(year, era);
        return 12;
    }
    
    int32_t KoreanCalendar::GetWeekOfYear_d25712e900e29bec(System::DateTime time, CalendarWeekRule rule, System::DayOfWeek firstDayOfWeek) {
        return Calendar::GetWeekOfYear_d25712e900e29bec(time, rule, firstDayOfWeek);
    }
    
    int32_t KoreanCalendar::GetYear_75c1b17aa90af360(System::DateTime time) {
        int32_t rd = CCFixed::FromDateTime(time);
        int32_t era;
        return M_EraHandler->EraYear(era, rd);
    }
    
    bool KoreanCalendar::IsLeapDay_7c795c9f36944ade(int32_t year, int32_t month, int32_t day, int32_t era) {
        int32_t gregorianYear = M_CheckYMDEG(year, month, day, era);
        return CCGregorianCalendar::IsLeapDay(gregorianYear, month, day);
    }
    
    bool KoreanCalendar::IsLeapMonth_85b9917f2bdaeef7(int32_t year, int32_t month, int32_t era) {
        M_CheckYMEG(year, month, era);
        return false;
    }
    
    bool KoreanCalendar::IsLeapYear_7aad026a1103cfb(int32_t year, int32_t era) {
        int32_t gregorianYear = M_CheckYEG(year, era);
        return CCGregorianCalendar::is_leap_year(gregorianYear);
    }
    
    System::DateTime KoreanCalendar::ToDateTime_82b4ff6780819fcd(int32_t year, int32_t month, int32_t day, int32_t hour, int32_t minute, int32_t second, int32_t millisecond, int32_t era) {
        int32_t gregorianYear = M_CheckYMDEG(year, month, day, era);
        Calendar::M_CheckHMSM(hour, minute, second, millisecond);
        return CCGregorianCalendar::ToDateTime(gregorianYear, month, day, hour, minute, second, millisecond);
    }
    
    int32_t KoreanCalendar::ToFourDigitYear_cb92a104112b3121(int32_t year) {
        return Calendar::ToFourDigitYear_cb92a104112b3121(year);
    }
    
    cli::array<int32_t>* KoreanCalendar::get_Eras_91b8aa89b8256658() {
        return cli::cast<cli::array<int32_t>*>(cli::import(M_EraHandler->get_Eras())->Clone());
    }
    
    int32_t KoreanCalendar::get_TwoDigitYearMax_14e9789b3d89e801() {
        return this->twoDigitYearMax;
    }
    
    int32_t KoreanCalendar::set_TwoDigitYearMax_4852e071586288ab(int32_t value) {
        Calendar::CheckReadOnly();
        Calendar::M_ArgumentInRange(_T("value"), value, 100, this->get_M_MaxYear_b3d9776fced847fe());
        this->twoDigitYearMax = value;
        return get_TwoDigitYearMax_14e9789b3d89e801();
    }
    
    CalendarAlgorithmType KoreanCalendar::get_AlgorithmType_1e3f8ed99adb8bde() {
        return CalendarAlgorithmType::SolarCalendar;
    }
    
    System::DateTime KoreanCalendar::get_MinSupportedDateTime_63cdcad9cf7fca4e() {
        return KoreanMin;
    }
    
    System::DateTime KoreanCalendar::get_MaxSupportedDateTime_7bc53f690ae04821() {
        return KoreanMax;
    }
    
}}
namespace System { namespace Globalization {
    
    CCEastAsianLunisolarEraHandler*  KoreanLunisolarCalendar::era_handler;
    System::DateTime  KoreanLunisolarCalendar::KoreanMin;
    System::DateTime  KoreanLunisolarCalendar::KoreanMax;
    
    KoreanLunisolarCalendar::KoreanLunisolarCalendar()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void KoreanLunisolarCalendar::static_constructor() {
        era_handler = cli::gcnew<CCEastAsianLunisolarEraHandler>();
        era_handler->appendEra2(1, CCFixed::FromDateTime(cli::ctor<System::DateTime>(1, 1, 1)));
    }
    
    void KoreanLunisolarCalendar::constructor() {
    }
    
    int32_t KoreanLunisolarCalendar::GetEra_1d16c3456dce785e(System::DateTime time) {
        int32_t rd = CCFixed::FromDateTime(time);
        int32_t era;
        era_handler->EraYear(era, rd);
        return era;
    }
    
    cli::array<int32_t>* KoreanLunisolarCalendar::get_Eras_91b8aa89b8256658() {
        return cli::cast<cli::array<int32_t>*>(cli::import(era_handler->get_Eras())->Clone());
    }
    
    System::DateTime KoreanLunisolarCalendar::get_MinSupportedDateTime_63cdcad9cf7fca4e() {
        return KoreanMin;
    }
    
    System::DateTime KoreanLunisolarCalendar::get_MaxSupportedDateTime_7bc53f690ae04821() {
        return KoreanMax;
    }
    
}}
namespace System { namespace Globalization {
    
    cli::array<System::String*>*  NumberFormatInfo::invariantNativeDigits;
    
    NumberFormatInfo::NumberFormatInfo()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void NumberFormatInfo::constructor(int32_t lcid, bool read_only) {
        this->isReadOnly = read_only;
        if((lcid != 127)) 
        {
            lcid = 127;
        }
        if((lcid ==  127)) 
        {
            this->currencyDecimalDigits = 2;
            this->currencyDecimalSeparator = _T(".");
            this->currencyGroupSeparator = _T(",");
            this->currencyGroupSizes = (new cli::array<int32_t>({3}));
            this->currencyNegativePattern = 0;
            this->currencyPositivePattern = 0;
            this->currencySymbol = _T("");
            this->nanSymbol = _T("NaN");
            this->negativeInfinitySymbol = _T("-Infinity");
            this->negativeSign = _T("-");
            this->numberDecimalDigits = 2;
            this->numberDecimalSeparator = _T(".");
            this->numberGroupSeparator = _T(",");
            this->numberGroupSizes = (new cli::array<int32_t>({3}));
            this->numberNegativePattern = 1;
            this->percentDecimalDigits = 2;
            this->percentDecimalSeparator = _T(".");
            this->percentGroupSeparator = _T(",");
            this->percentGroupSizes = (new cli::array<int32_t>({3}));
            this->percentNegativePattern = 0;
            this->percentPositivePattern = 0;
            this->percentSymbol = _T("%");
            this->perMilleSymbol = _T("");
            this->positiveInfinitySymbol = _T("Infinity");
            this->positiveSign = _T("+");
        }
    }
    
    void NumberFormatInfo::constructor(bool read_only) {
    }
    
    void NumberFormatInfo::constructor() {
    }
    
    void NumberFormatInfo::static_constructor() {
    }
    
    void NumberFormatInfo::InitPatterns() {
        cli::array<System::String*> *partOne, *partTwo;
        cli::array<System::String*> *posNeg = this->decimalFormats->Split2((new cli::array<char16_t>({u';'})), 2);
        if((posNeg->get_Length() ==  2)) 
        {
            partOne = posNeg->at(0)->Split2((new cli::array<char16_t>({u'.'})), 2);
            if((partOne->get_Length() ==  2)) 
            {
                this->numberDecimalDigits = 0;
                for(int32_t i = 0; (i < partOne->at(1)->get_Length()); i++){
                    if(((int32_t)(partOne->at(1)->get_Chars(i)) ==  (int32_t)(this->digitPattern->get_Chars(0)))) 
                    {
                        this->numberDecimalDigits++;
                    }
                     else 
                    {
                        break;
                    }
                }
                partTwo = partOne->at(0)->Split((new cli::array<char16_t>({u','})));
                if((partTwo->get_Length() > 1)) 
                {
                    this->numberGroupSizes = (new cli::array<int32_t>((partTwo->get_Length() - 1)));
                    for(int32_t i = 0; (i < this->numberGroupSizes->get_Length()); i++){
                        System::String *pat = partTwo->at((i + 1));
                        this->numberGroupSizes->at(i) = pat->get_Length();
                    }
                }
                 else 
                {
                    this->numberGroupSizes = (new cli::array<int32_t>({0}));
                }
                if((posNeg->at(1)->StartsWith(_T("(")) && posNeg->at(1)->EndsWith(_T(")")))) 
                {
                    this->numberNegativePattern = 0;
                }
                 else 
                {
                    if(posNeg->at(1)->StartsWith(_T("- "))) 
                    {
                        this->numberNegativePattern = 2;
                    }
                     else 
                    {
                        if(posNeg->at(1)->StartsWith(_T("-"))) 
                        {
                            this->numberNegativePattern = 1;
                        }
                         else 
                        {
                            if(posNeg->at(1)->EndsWith(_T(" -"))) 
                            {
                                this->numberNegativePattern = 4;
                            }
                             else 
                            {
                                if(posNeg->at(1)->EndsWith(_T("-"))) 
                                {
                                    this->numberNegativePattern = 3;
                                }
                                 else 
                                {
                                    this->numberNegativePattern = 1;
                                }
                            }
                        }
                    }
                }
            }
        }
        posNeg = this->currencyFormats->Split2((new cli::array<char16_t>({u';'})), 2);
        if((posNeg->get_Length() ==  2)) 
        {
            partOne = posNeg->at(0)->Split2((new cli::array<char16_t>({u'.'})), 2);
            if((partOne->get_Length() ==  2)) 
            {
                this->currencyDecimalDigits = 0;
                for(int32_t i = 0; (i < partOne->at(1)->get_Length()); i++){
                    if(((int32_t)(partOne->at(1)->get_Chars(i)) ==  (int32_t)(this->zeroPattern->get_Chars(0)))) 
                    {
                        this->currencyDecimalDigits++;
                    }
                     else 
                    {
                        break;
                    }
                }
                partTwo = partOne->at(0)->Split((new cli::array<char16_t>({u','})));
                if((partTwo->get_Length() > 1)) 
                {
                    this->currencyGroupSizes = (new cli::array<int32_t>((partTwo->get_Length() - 1)));
                    for(int32_t i = 0; (i < this->currencyGroupSizes->get_Length()); i++){
                        System::String *pat = partTwo->at((i + 1));
                        this->currencyGroupSizes->at(i) = pat->get_Length();
                    }
                }
                 else 
                {
                    this->currencyGroupSizes = (new cli::array<int32_t>({0}));
                }
                if((posNeg->at(1)->StartsWith(_T("( ")) && posNeg->at(1)->EndsWith(_T(")")))) 
                {
                    this->currencyNegativePattern = 14;
                }
                 else 
                {
                    if((posNeg->at(1)->StartsWith(_T("(")) && posNeg->at(1)->EndsWith(_T(")")))) 
                    {
                        this->currencyNegativePattern = 0;
                    }
                     else 
                    {
                        if((posNeg->at(1)->StartsWith(_T(" ")) && posNeg->at(1)->EndsWith(_T("-")))) 
                        {
                            this->currencyNegativePattern = 11;
                        }
                         else 
                        {
                            if((posNeg->at(1)->StartsWith(_T("")) && posNeg->at(1)->EndsWith(_T("-")))) 
                            {
                                this->currencyNegativePattern = 3;
                            }
                             else 
                            {
                                if((posNeg->at(1)->StartsWith(_T("(")) && posNeg->at(1)->EndsWith(_T(" ")))) 
                                {
                                    this->currencyNegativePattern = 15;
                                }
                                 else 
                                {
                                    if((posNeg->at(1)->StartsWith(_T("(")) && posNeg->at(1)->EndsWith(_T("")))) 
                                    {
                                        this->currencyNegativePattern = 4;
                                    }
                                     else 
                                    {
                                        if((posNeg->at(1)->StartsWith(_T("-")) && posNeg->at(1)->EndsWith(_T(" ")))) 
                                        {
                                            this->currencyNegativePattern = 8;
                                        }
                                         else 
                                        {
                                            if((posNeg->at(1)->StartsWith(_T("-")) && posNeg->at(1)->EndsWith(_T("")))) 
                                            {
                                                this->currencyNegativePattern = 5;
                                            }
                                             else 
                                            {
                                                if(posNeg->at(1)->StartsWith(_T("- "))) 
                                                {
                                                    this->currencyNegativePattern = 9;
                                                }
                                                 else 
                                                {
                                                    if(posNeg->at(1)->StartsWith(_T("-"))) 
                                                    {
                                                        this->currencyNegativePattern = 1;
                                                    }
                                                     else 
                                                    {
                                                        if(posNeg->at(1)->StartsWith(_T(" -"))) 
                                                        {
                                                            this->currencyNegativePattern = 12;
                                                        }
                                                         else 
                                                        {
                                                            if(posNeg->at(1)->StartsWith(_T("-"))) 
                                                            {
                                                                this->currencyNegativePattern = 2;
                                                            }
                                                             else 
                                                            {
                                                                if(posNeg->at(1)->EndsWith(_T(" -"))) 
                                                                {
                                                                    this->currencyNegativePattern = 10;
                                                                }
                                                                 else 
                                                                {
                                                                    if(posNeg->at(1)->EndsWith(_T("-"))) 
                                                                    {
                                                                        this->currencyNegativePattern = 7;
                                                                    }
                                                                     else 
                                                                    {
                                                                        if(posNeg->at(1)->EndsWith(_T("- "))) 
                                                                        {
                                                                            this->currencyNegativePattern = 13;
                                                                        }
                                                                         else 
                                                                        {
                                                                            if(posNeg->at(1)->EndsWith(_T("-"))) 
                                                                            {
                                                                                this->currencyNegativePattern = 6;
                                                                            }
                                                                             else 
                                                                            {
                                                                                this->currencyNegativePattern = 0;
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                if(posNeg->at(0)->StartsWith(_T(" "))) 
                {
                    this->currencyPositivePattern = 2;
                }
                 else 
                {
                    if(posNeg->at(0)->StartsWith(_T(""))) 
                    {
                        this->currencyPositivePattern = 0;
                    }
                     else 
                    {
                        if(posNeg->at(0)->EndsWith(_T(" "))) 
                        {
                            this->currencyPositivePattern = 3;
                        }
                         else 
                        {
                            if(posNeg->at(0)->EndsWith(_T(""))) 
                            {
                                this->currencyPositivePattern = 1;
                            }
                             else 
                            {
                                this->currencyPositivePattern = 0;
                            }
                        }
                    }
                }
            }
        }
        if(this->percentFormats->StartsWith(_T("%"))) 
        {
            this->percentPositivePattern = 2;
            this->percentNegativePattern = 2;
        }
         else 
        {
            if(this->percentFormats->EndsWith(_T(" %"))) 
            {
                this->percentPositivePattern = 0;
                this->percentNegativePattern = 0;
            }
             else 
            {
                if(this->percentFormats->EndsWith(_T("%"))) 
                {
                    this->percentPositivePattern = 1;
                    this->percentNegativePattern = 1;
                }
                 else 
                {
                    this->percentPositivePattern = 0;
                    this->percentNegativePattern = 0;
                }
            }
        }
        partOne = this->percentFormats->Split2((new cli::array<char16_t>({u'.'})), 2);
        if((partOne->get_Length() ==  2)) 
        {
            this->percentDecimalDigits = 0;
            for(int32_t i = 0; (i < partOne->at(1)->get_Length()); i++){
                if(((int32_t)(partOne->at(1)->get_Chars(i)) ==  (int32_t)(this->digitPattern->get_Chars(0)))) 
                {
                    this->percentDecimalDigits++;
                }
                 else 
                {
                    break;
                }
            }
            partTwo = partOne->at(0)->Split((new cli::array<char16_t>({u','})));
            if((partTwo->get_Length() > 1)) 
            {
                this->percentGroupSizes = (new cli::array<int32_t>((partTwo->get_Length() - 1)));
                for(int32_t i = 0; (i < this->percentGroupSizes->get_Length()); i++){
                    System::String *pat = partTwo->at((i + 1));
                    this->percentGroupSizes->at(i) = pat->get_Length();
                }
            }
             else 
            {
                this->percentGroupSizes = (new cli::array<int32_t>({0}));
            }
        }
    }
    
    System::Object* NumberFormatInfo::GetFormat(System::Type* formatType) {
        return System::Type::op_Equality2(formatType, cli::typeof<System::Type>::info) ? this : nullptr;
    }
    
    System::Object* NumberFormatInfo::Clone() {
        NumberFormatInfo *clone = cli::cast<NumberFormatInfo*>(System::Object::MemberwiseClone());
        clone->isReadOnly = false;
        return clone;
    }
    
    NumberFormatInfo* NumberFormatInfo::ReadOnly(NumberFormatInfo* nfi) {
        NumberFormatInfo *copy = cli::cast<NumberFormatInfo*>(nfi->Clone());
        copy->isReadOnly = true;
        return copy;
    }
    
    NumberFormatInfo* NumberFormatInfo::GetInstance(System::IFormatProvider* formatProvider) {
        if((formatProvider != nullptr)) 
        {
            NumberFormatInfo *nfi;
            nfi = cli::cast<NumberFormatInfo*>(formatProvider->GetFormat_b67414a65453cc7e(cli::typeof<System::Type>::info));
            if((nfi != nullptr)) 
            {
                return nfi;
            }
        }
        return NumberFormatInfo::get_CurrentInfo();
    }
    
    int32_t NumberFormatInfo::get_CurrencyDecimalDigits() {
        return this->currencyDecimalDigits;
    }
    
    int32_t NumberFormatInfo::set_CurrencyDecimalDigits(int32_t value) {
        if(((value < 0) || (value > 99))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("The value specified for the property is less than 0 or greater than 99"));
        }
        if(this->isReadOnly) 
        {
            throw cli::gcnew<System::InvalidOperationException>(_T("The current instance is read-only and a set operation was attempted"));
        }
        this->currencyDecimalDigits = value;
        return get_CurrencyDecimalDigits();
    }
    
    System::String* NumberFormatInfo::get_CurrencyDecimalSeparator() {
        return this->currencyDecimalSeparator;
    }
    
    System::String* NumberFormatInfo::set_CurrencyDecimalSeparator(System::String* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("The value specified for the property is a null reference"));
        }
        if(this->isReadOnly) 
        {
            throw cli::gcnew<System::InvalidOperationException>(_T("The current instance is read-only and a set operation was attempted"));
        }
        this->currencyDecimalSeparator = value;
        return get_CurrencyDecimalSeparator();
    }
    
    System::String* NumberFormatInfo::get_CurrencyGroupSeparator() {
        return this->currencyGroupSeparator;
    }
    
    System::String* NumberFormatInfo::set_CurrencyGroupSeparator(System::String* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("The value specified for the property is a null reference"));
        }
        if(this->isReadOnly) 
        {
            throw cli::gcnew<System::InvalidOperationException>(_T("The current instance is read-only and a set operation was attempted"));
        }
        this->currencyGroupSeparator = value;
        return get_CurrencyGroupSeparator();
    }
    
    cli::array<int32_t>* NumberFormatInfo::get_CurrencyGroupSizes() {
        return cli::cast<cli::array<int32_t>*>(cli::import(this->get_RawCurrencyGroupSizes())->Clone());
    }
    
    cli::array<int32_t>* NumberFormatInfo::set_CurrencyGroupSizes(cli::array<int32_t>* value) {
        this->set_RawCurrencyGroupSizes(value);
        return get_CurrencyGroupSizes();
    }
    
    cli::array<int32_t>* NumberFormatInfo::get_RawCurrencyGroupSizes() {
        return this->currencyGroupSizes;
    }
    
    cli::array<int32_t>* NumberFormatInfo::set_RawCurrencyGroupSizes(cli::array<int32_t>* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("The value specified for the property is a null reference"));
        }
        if(this->isReadOnly) 
        {
            throw cli::gcnew<System::InvalidOperationException>(_T("The current instance is read-only and a set operation was attempted"));
        }
        if((value->get_Length() ==  0)) 
        {
            this->currencyGroupSizes = (new cli::array<int32_t>(0));
            return get_RawCurrencyGroupSizes();
        }
        int32_t last = (value->get_Length() - 1);
        for(int32_t i = 0; (i < last); i++) {
            if(((value->at(i) < 1) || (value->at(i) > 9))) 
            {
                throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("One of the elements in the array specified is not between 1 and 9"));
            }
        }
        if(((value->at(last) < 0) || (value->at(last) > 9))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("Last element in the array specified is not between 0 and 9"));
        }
        this->currencyGroupSizes = cli::cast<cli::array<int32_t>*>(cli::import(value)->Clone());
        return get_RawCurrencyGroupSizes();
    }
    
    int32_t NumberFormatInfo::get_CurrencyNegativePattern() {
        return this->currencyNegativePattern;
    }
    
    int32_t NumberFormatInfo::set_CurrencyNegativePattern(int32_t value) {
        if(((value < 0) || (value > 15))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("The value specified for the property is less than 0 or greater than 15"));
        }
        if(this->isReadOnly) 
        {
            throw cli::gcnew<System::InvalidOperationException>(_T("The current instance is read-only and a set operation was attempted"));
        }
        this->currencyNegativePattern = value;
        return get_CurrencyNegativePattern();
    }
    
    int32_t NumberFormatInfo::get_CurrencyPositivePattern() {
        return this->currencyPositivePattern;
    }
    
    int32_t NumberFormatInfo::set_CurrencyPositivePattern(int32_t value) {
        if(((value < 0) || (value > 3))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("The value specified for the property is less than 0 or greater than 3"));
        }
        if(this->isReadOnly) 
        {
            throw cli::gcnew<System::InvalidOperationException>(_T("The current instance is read-only and a set operation was attempted"));
        }
        this->currencyPositivePattern = value;
        return get_CurrencyPositivePattern();
    }
    
    System::String* NumberFormatInfo::get_CurrencySymbol() {
        return this->currencySymbol;
    }
    
    System::String* NumberFormatInfo::set_CurrencySymbol(System::String* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("The value specified for the property is a null reference"));
        }
        if(this->isReadOnly) 
        {
            throw cli::gcnew<System::InvalidOperationException>(_T("The current instance is read-only and a set operation was attempted"));
        }
        this->currencySymbol = value;
        return get_CurrencySymbol();
    }
    
    NumberFormatInfo* NumberFormatInfo::get_CurrentInfo() {
        NumberFormatInfo *nfi = cli::cast<NumberFormatInfo*>(System::Threading::Thread::get_CurrentThread()->get_CurrentCulture()->get_NumberFormat_56b6d54c07628932());
        nfi->isReadOnly = true;
        return nfi;
    }
    
    NumberFormatInfo* NumberFormatInfo::get_InvariantInfo() {
        NumberFormatInfo *nfi = cli::gcnew<NumberFormatInfo>(true);
        return nfi;
    }
    
    bool NumberFormatInfo::get_IsReadOnly() {
        return this->isReadOnly;
    }
    
    System::String* NumberFormatInfo::get_NaNSymbol() {
        return this->nanSymbol;
    }
    
    System::String* NumberFormatInfo::set_NaNSymbol(System::String* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("The value specified for the property is a null reference"));
        }
        if(this->isReadOnly) 
        {
            throw cli::gcnew<System::InvalidOperationException>(_T("The current instance is read-only and a set operation was attempted"));
        }
        this->nanSymbol = value;
        return get_NaNSymbol();
    }
    
    cli::array<System::String*>* NumberFormatInfo::get_NativeDigits() {
        return this->nativeDigits;
    }
    
    cli::array<System::String*>* NumberFormatInfo::set_NativeDigits(cli::array<System::String*>* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("value"));
        }
        if((value->get_Length() != 10)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Argument array length must be 10"));
        }
        for(auto tmp_228 : value) {
            auto s = cli::cast<System::String*>(tmp_228);
            if(System::String::IsNullOrEmpty(s)) 
            {
                throw cli::gcnew<System::ArgumentException>(_T("Argument array contains one or more null strings"));
            }
        }
        this->nativeDigits = value;
        return get_NativeDigits();
    }
    
    DigitShapes NumberFormatInfo::get_DigitSubstitution() {
        return (DigitShapes)(this->digitSubstitution);
    }
    
    DigitShapes NumberFormatInfo::set_DigitSubstitution(DigitShapes value) {
        this->digitSubstitution = (int32_t)(value);
        return get_DigitSubstitution();
    }
    
    System::String* NumberFormatInfo::get_NegativeInfinitySymbol() {
        return this->negativeInfinitySymbol;
    }
    
    System::String* NumberFormatInfo::set_NegativeInfinitySymbol(System::String* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("The value specified for the property is a null reference"));
        }
        if(this->isReadOnly) 
        {
            throw cli::gcnew<System::InvalidOperationException>(_T("The current instance is read-only and a set operation was attempted"));
        }
        this->negativeInfinitySymbol = value;
        return get_NegativeInfinitySymbol();
    }
    
    System::String* NumberFormatInfo::get_NegativeSign() {
        return this->negativeSign;
    }
    
    System::String* NumberFormatInfo::set_NegativeSign(System::String* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("The value specified for the property is a null reference"));
        }
        if(this->isReadOnly) 
        {
            throw cli::gcnew<System::InvalidOperationException>(_T("The current instance is read-only and a set operation was attempted"));
        }
        this->negativeSign = value;
        return get_NegativeSign();
    }
    
    int32_t NumberFormatInfo::get_NumberDecimalDigits() {
        return this->numberDecimalDigits;
    }
    
    int32_t NumberFormatInfo::set_NumberDecimalDigits(int32_t value) {
        if(((value < 0) || (value > 99))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("The value specified for the property is less than 0 or greater than 99"));
        }
        if(this->isReadOnly) 
        {
            throw cli::gcnew<System::InvalidOperationException>(_T("The current instance is read-only and a set operation was attempted"));
        }
        this->numberDecimalDigits = value;
        return get_NumberDecimalDigits();
    }
    
    System::String* NumberFormatInfo::get_NumberDecimalSeparator() {
        return this->numberDecimalSeparator;
    }
    
    System::String* NumberFormatInfo::set_NumberDecimalSeparator(System::String* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("The value specified for the property is a null reference"));
        }
        if(this->isReadOnly) 
        {
            throw cli::gcnew<System::InvalidOperationException>(_T("The current instance is read-only and a set operation was attempted"));
        }
        this->numberDecimalSeparator = value;
        return get_NumberDecimalSeparator();
    }
    
    System::String* NumberFormatInfo::get_NumberGroupSeparator() {
        return this->numberGroupSeparator;
    }
    
    System::String* NumberFormatInfo::set_NumberGroupSeparator(System::String* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("The value specified for the property is a null reference"));
        }
        if(this->isReadOnly) 
        {
            throw cli::gcnew<System::InvalidOperationException>(_T("The current instance is read-only and a set operation was attempted"));
        }
        this->numberGroupSeparator = value;
        return get_NumberGroupSeparator();
    }
    
    cli::array<int32_t>* NumberFormatInfo::get_NumberGroupSizes() {
        return cli::cast<cli::array<int32_t>*>(cli::import(this->get_RawNumberGroupSizes())->Clone());
    }
    
    cli::array<int32_t>* NumberFormatInfo::set_NumberGroupSizes(cli::array<int32_t>* value) {
        this->set_RawNumberGroupSizes(value);
        return get_NumberGroupSizes();
    }
    
    cli::array<int32_t>* NumberFormatInfo::get_RawNumberGroupSizes() {
        return this->numberGroupSizes;
    }
    
    cli::array<int32_t>* NumberFormatInfo::set_RawNumberGroupSizes(cli::array<int32_t>* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("The value specified for the property is a null reference"));
        }
        if(this->isReadOnly) 
        {
            throw cli::gcnew<System::InvalidOperationException>(_T("The current instance is read-only and a set operation was attempted"));
        }
        if((value->get_Length() ==  0)) 
        {
            this->numberGroupSizes = (new cli::array<int32_t>(0));
            return get_RawNumberGroupSizes();
        }
        int32_t last = (value->get_Length() - 1);
        for(int32_t i = 0; (i < last); i++) {
            if(((value->at(i) < 1) || (value->at(i) > 9))) 
            {
                throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("One of the elements in the array specified is not between 1 and 9"));
            }
        }
        if(((value->at(last) < 0) || (value->at(last) > 9))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("Last element in the array specified is not between 0 and 9"));
        }
        this->numberGroupSizes = cli::cast<cli::array<int32_t>*>(cli::import(value)->Clone());
        return get_RawNumberGroupSizes();
    }
    
    int32_t NumberFormatInfo::get_NumberNegativePattern() {
        return this->numberNegativePattern;
    }
    
    int32_t NumberFormatInfo::set_NumberNegativePattern(int32_t value) {
        if(((value < 0) || (value > 4))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("The value specified for the property is less than 0 or greater than 15"));
        }
        if(this->isReadOnly) 
        {
            throw cli::gcnew<System::InvalidOperationException>(_T("The current instance is read-only and a set operation was attempted"));
        }
        this->numberNegativePattern = value;
        return get_NumberNegativePattern();
    }
    
    int32_t NumberFormatInfo::get_PercentDecimalDigits() {
        return this->percentDecimalDigits;
    }
    
    int32_t NumberFormatInfo::set_PercentDecimalDigits(int32_t value) {
        if(((value < 0) || (value > 99))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("The value specified for the property is less than 0 or greater than 99"));
        }
        if(this->isReadOnly) 
        {
            throw cli::gcnew<System::InvalidOperationException>(_T("The current instance is read-only and a set operation was attempted"));
        }
        this->percentDecimalDigits = value;
        return get_PercentDecimalDigits();
    }
    
    System::String* NumberFormatInfo::get_PercentDecimalSeparator() {
        return this->percentDecimalSeparator;
    }
    
    System::String* NumberFormatInfo::set_PercentDecimalSeparator(System::String* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("The value specified for the property is a null reference"));
        }
        if(this->isReadOnly) 
        {
            throw cli::gcnew<System::InvalidOperationException>(_T("The current instance is read-only and a set operation was attempted"));
        }
        this->percentDecimalSeparator = value;
        return get_PercentDecimalSeparator();
    }
    
    System::String* NumberFormatInfo::get_PercentGroupSeparator() {
        return this->percentGroupSeparator;
    }
    
    System::String* NumberFormatInfo::set_PercentGroupSeparator(System::String* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("The value specified for the property is a null reference"));
        }
        if(this->isReadOnly) 
        {
            throw cli::gcnew<System::InvalidOperationException>(_T("The current instance is read-only and a set operation was attempted"));
        }
        this->percentGroupSeparator = value;
        return get_PercentGroupSeparator();
    }
    
    cli::array<int32_t>* NumberFormatInfo::get_PercentGroupSizes() {
        return cli::cast<cli::array<int32_t>*>(cli::import(this->get_RawPercentGroupSizes())->Clone());
    }
    
    cli::array<int32_t>* NumberFormatInfo::set_PercentGroupSizes(cli::array<int32_t>* value) {
        this->set_RawPercentGroupSizes(value);
        return get_PercentGroupSizes();
    }
    
    cli::array<int32_t>* NumberFormatInfo::get_RawPercentGroupSizes() {
        return this->percentGroupSizes;
    }
    
    cli::array<int32_t>* NumberFormatInfo::set_RawPercentGroupSizes(cli::array<int32_t>* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("The value specified for the property is a null reference"));
        }
        if(this->isReadOnly) 
        {
            throw cli::gcnew<System::InvalidOperationException>(_T("The current instance is read-only and a set operation was attempted"));
        }
        if((this ==  CultureInfo::get_CurrentCulture()->get_NumberFormat_56b6d54c07628932())) 
        {
            throw cli::gcnew<System::Exception>(_T("HERE the value was modified"));
        }
        if((value->get_Length() ==  0)) 
        {
            this->percentGroupSizes = (new cli::array<int32_t>(0));
            return get_RawPercentGroupSizes();
        }
        int32_t last = (value->get_Length() - 1);
        for(int32_t i = 0; (i < last); i++) {
            if(((value->at(i) < 1) || (value->at(i) > 9))) 
            {
                throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("One of the elements in the array specified is not between 1 and 9"));
            }
        }
        if(((value->at(last) < 0) || (value->at(last) > 9))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("Last element in the array specified is not between 0 and 9"));
        }
        this->percentGroupSizes = cli::cast<cli::array<int32_t>*>(cli::import(value)->Clone());
        return get_RawPercentGroupSizes();
    }
    
    int32_t NumberFormatInfo::get_PercentNegativePattern() {
        return this->percentNegativePattern;
    }
    
    int32_t NumberFormatInfo::set_PercentNegativePattern(int32_t value) {
        if(((value < 0) || (value > 2))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("The value specified for the property is less than 0 or greater than 15"));
        }
        if(this->isReadOnly) 
        {
            throw cli::gcnew<System::InvalidOperationException>(_T("The current instance is read-only and a set operation was attempted"));
        }
        this->percentNegativePattern = value;
        return get_PercentNegativePattern();
    }
    
    int32_t NumberFormatInfo::get_PercentPositivePattern() {
        return this->percentPositivePattern;
    }
    
    int32_t NumberFormatInfo::set_PercentPositivePattern(int32_t value) {
        if(((value < 0) || (value > 2))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("The value specified for the property is less than 0 or greater than 3"));
        }
        if(this->isReadOnly) 
        {
            throw cli::gcnew<System::InvalidOperationException>(_T("The current instance is read-only and a set operation was attempted"));
        }
        this->percentPositivePattern = value;
        return get_PercentPositivePattern();
    }
    
    System::String* NumberFormatInfo::get_PercentSymbol() {
        return this->percentSymbol;
    }
    
    System::String* NumberFormatInfo::set_PercentSymbol(System::String* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("The value specified for the property is a null reference"));
        }
        if(this->isReadOnly) 
        {
            throw cli::gcnew<System::InvalidOperationException>(_T("The current instance is read-only and a set operation was attempted"));
        }
        this->percentSymbol = value;
        return get_PercentSymbol();
    }
    
    System::String* NumberFormatInfo::get_PerMilleSymbol() {
        return this->perMilleSymbol;
    }
    
    System::String* NumberFormatInfo::set_PerMilleSymbol(System::String* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("The value specified for the property is a null reference"));
        }
        if(this->isReadOnly) 
        {
            throw cli::gcnew<System::InvalidOperationException>(_T("The current instance is read-only and a set operation was attempted"));
        }
        this->perMilleSymbol = value;
        return get_PerMilleSymbol();
    }
    
    System::String* NumberFormatInfo::get_PositiveInfinitySymbol() {
        return this->positiveInfinitySymbol;
    }
    
    System::String* NumberFormatInfo::set_PositiveInfinitySymbol(System::String* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("The value specified for the property is a null reference"));
        }
        if(this->isReadOnly) 
        {
            throw cli::gcnew<System::InvalidOperationException>(_T("The current instance is read-only and a set operation was attempted"));
        }
        this->positiveInfinitySymbol = value;
        return get_PositiveInfinitySymbol();
    }
    
    System::String* NumberFormatInfo::get_PositiveSign() {
        return this->positiveSign;
    }
    
    System::String* NumberFormatInfo::set_PositiveSign(System::String* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("The value specified for the property is a null reference"));
        }
        if(this->isReadOnly) 
        {
            throw cli::gcnew<System::InvalidOperationException>(_T("The current instance is read-only and a set operation was attempted"));
        }
        this->positiveSign = value;
        return get_PositiveSign();
    }
    
}}
namespace System { namespace Globalization {
    
    int32_t  PersianCalendar::PersianEra;
    System::DateTime  PersianCalendar::PersianMin;
    System::DateTime  PersianCalendar::PersianMax;
    
    PersianCalendar::PersianCalendar()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void PersianCalendar::constructor() {
        this->M_AbbrEraNames = (new cli::array<System::String*>({_T("A.P.")}));
        this->M_EraNames = (new cli::array<System::String*>({_T("Anno Persico")}));
        if((this->twoDigitYearMax ==  99)) 
        {
            this->twoDigitYearMax = 1410;
        }
    }
    
    void PersianCalendar::static_constructor() {
    }
    
    void PersianCalendar::M_CheckDateTime(System::DateTime time) {
        if((time->get_Ticks() < 196036416000000000L)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("time"), _T("Only positive Persian years are supported."));
        }
    }
    
    void PersianCalendar::M_CheckEra(int32_t era) {
        if((era ==  0)) 
        {
            era = PersianEra;
        }
        if((era != PersianEra)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Era value was not valid."));
        }
    }
    
    void PersianCalendar::M_CheckYE_c830e88539d38d64(int32_t year, int32_t era) {
        M_CheckEra(era);
        if(((year < 1) || (year > this->get_M_MaxYear_b3d9776fced847fe()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("year"), _T("Only Persian years between 1 and 9378, inclusive, are supported."));
        }
    }
    
    void PersianCalendar::M_CheckYME(int32_t year, int32_t month, int32_t era) {
        Calendar::M_CheckYE_c830e88539d38d64(year, era);
        if(((month < 1) || (month > 12))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("month"), _T("Month must be between one and twelve."));
        }
         else 
        {
            if(((year ==  this->get_M_MaxYear_b3d9776fced847fe()) && (month > 10))) 
            {
                throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("month"), _T("Months in year 9378 must be between one and ten."));
            }
        }
    }
    
    void PersianCalendar::M_CheckYMDE(int32_t year, int32_t month, int32_t day, int32_t era) {
        M_CheckYME(year, month, era);
        Calendar::M_ArgumentInRange(_T("day"), day, 1, PersianCalendar::GetDaysInMonth_233a2cea4d4c72fe(year, month, era));
        if((((year ==  this->get_M_MaxYear_b3d9776fced847fe()) && (month ==  10)) && (day > 10))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("day"), _T("Days in month 10 of year 9378 must be between one and ten."));
        }
    }
    
    int32_t PersianCalendar::fixed_from_dmy(int32_t day, int32_t month, int32_t year) {
        int32_t k = 226894;
        (k = k + (365 * (year - 1)));
        (k = k + (((8 * year) + 21) / 33));
        if((month <= 7)) 
        {
            (k = k + (31 * (month - 1)));
        }
         else 
        {
            (k = k + ((30 * (month - 1)) + 6));
        }
        (k = k + day);
        return k;
    }
    
    int32_t PersianCalendar::year_from_fixed(int32_t date) {
        return ((((33 * (date - 226895)) + 3) / 12053) + 1);
    }
    
    void PersianCalendar::my_from_fixed(int32_t month, int32_t year, int32_t date) {
        int32_t day;
        year = year_from_fixed(date);
        day = (date - fixed_from_dmy(1, 1, year));
        if((day < 216)) 
        {
            month = ((day / 31) + 1);
        }
         else 
        {
            month = (((day - 6) / 30) + 1);
        }
    }
    
    void PersianCalendar::dmy_from_fixed(int32_t day, int32_t month, int32_t year, int32_t date) {
        year = year_from_fixed(date);
        day = (date - fixed_from_dmy(1, 1, year));
        if((day < 216)) 
        {
            month = ((day / 31) + 1);
            day = ((day % 31) + 1);
        }
         else 
        {
            month = (((day - 6) / 30) + 1);
            day = (((day - 6) % 30) + 1);
        }
    }
    
    bool PersianCalendar::is_leap_year(int32_t year) {
        return ((((25 * year) + 11) % 33) < 8);
    }
    
    System::DateTime PersianCalendar::AddMonths_a4a4579bf9385278(System::DateTime time, int32_t months) {
        int32_t rd = CCFixed::FromDateTime(time);
        int32_t day, month, year;
        dmy_from_fixed(day, month, year, rd);
        (month = month + months);
        (year = year + CCMath::div_mod(month, month, 12));
        rd = fixed_from_dmy(day, month, year);
        System::DateTime t = CCFixed::ToDateTime(rd);
        t = t->Add(time->get_TimeOfDay());
        M_CheckDateTime(t);
        return t;
    }
    
    System::DateTime PersianCalendar::AddYears_8bb7ea0ef803063e(System::DateTime time, int32_t years) {
        int32_t rd = CCFixed::FromDateTime(time);
        int32_t day, month, year;
        dmy_from_fixed(day, month, year, rd);
        (year = year + years);
        rd = fixed_from_dmy(day, month, year);
        System::DateTime t = CCFixed::ToDateTime(rd);
        t = t->Add(time->get_TimeOfDay());
        M_CheckDateTime(t);
        return t;
    }
    
    int32_t PersianCalendar::GetDayOfMonth_7da4e9f8c6f0dece(System::DateTime time) {
        int32_t day, month, year;
        M_CheckDateTime(time);
        int32_t rd = CCFixed::FromDateTime(time);
        dmy_from_fixed(day, month, year, rd);
        return day;
    }
    
    System::DayOfWeek PersianCalendar::GetDayOfWeek_4c0b69c7bb83520e(System::DateTime time) {
        M_CheckDateTime(time);
        int32_t rd = CCFixed::FromDateTime(time);
        return (System::DayOfWeek)(CCFixed::day_of_week(rd));
    }
    
    int32_t PersianCalendar::GetDayOfYear_1eaa1ac34e65f799(System::DateTime time) {
        M_CheckDateTime(time);
        int32_t rd = CCFixed::FromDateTime(time);
        int32_t year = year_from_fixed(rd);
        int32_t rd1_1 = fixed_from_dmy(1, 1, year);
        return ((rd - rd1_1) + 1);
    }
    
    int32_t PersianCalendar::GetDaysInMonth_233a2cea4d4c72fe(int32_t year, int32_t month, int32_t era) {
        M_CheckYME(year, month, era);
        if((month <= 6)) 
        {
            return 31;
        }
         else 
        {
            if(((month ==  12) && !(is_leap_year(year)))) 
            {
                return 29;
            }
             else 
            {
                return 30;
            }
        }
    }
    
    int32_t PersianCalendar::GetDaysInYear_ae0f8cfee3ff2567(int32_t year, int32_t era) {
        Calendar::M_CheckYE_c830e88539d38d64(year, era);
        return is_leap_year(year) ? 366 : 365;
    }
    
    int32_t PersianCalendar::GetEra_1d16c3456dce785e(System::DateTime time) {
        M_CheckDateTime(time);
        return PersianEra;
    }
    
    int32_t PersianCalendar::GetLeapMonth_fb3256a34d84f7ed(int32_t year, int32_t era) {
        return 0;
    }
    
    int32_t PersianCalendar::GetMonth_66424683b988a96b(System::DateTime time) {
        M_CheckDateTime(time);
        int32_t rd = CCFixed::FromDateTime(time);
        int32_t month, year;
        my_from_fixed(month, year, rd);
        return month;
    }
    
    int32_t PersianCalendar::GetMonthsInYear_2ae36c9a94a7bffb(int32_t year, int32_t era) {
        Calendar::M_CheckYE_c830e88539d38d64(year, era);
        return 12;
    }
    
    int32_t PersianCalendar::GetYear_75c1b17aa90af360(System::DateTime time) {
        M_CheckDateTime(time);
        int32_t rd = CCFixed::FromDateTime(time);
        return year_from_fixed(rd);
    }
    
    bool PersianCalendar::IsLeapDay_7c795c9f36944ade(int32_t year, int32_t month, int32_t day, int32_t era) {
        M_CheckYMDE(year, month, day, era);
        return ((is_leap_year(year) && (month ==  12)) && (day ==  30));
    }
    
    bool PersianCalendar::IsLeapMonth_85b9917f2bdaeef7(int32_t year, int32_t month, int32_t era) {
        M_CheckYME(year, month, era);
        return false;
    }
    
    bool PersianCalendar::IsLeapYear_7aad026a1103cfb(int32_t year, int32_t era) {
        Calendar::M_CheckYE_c830e88539d38d64(year, era);
        return is_leap_year(year);
    }
    
    System::DateTime PersianCalendar::ToDateTime_82b4ff6780819fcd(int32_t year, int32_t month, int32_t day, int32_t hour, int32_t minute, int32_t second, int32_t millisecond, int32_t era) {
        M_CheckYMDE(year, month, day, era);
        Calendar::M_CheckHMSM(hour, minute, second, millisecond);
        int32_t rd = fixed_from_dmy(day, month, year);
        return CCFixed::ToDateTime2(rd, hour, minute, second, (double)(millisecond));
    }
    
    int32_t PersianCalendar::ToFourDigitYear_cb92a104112b3121(int32_t year) {
        Calendar::M_ArgumentInRange(_T("year"), year, 0, 99);
        int32_t baseExtra = (this->twoDigitYearMax % 100);
        int32_t baseCentury = (this->twoDigitYearMax - baseExtra);
        if((year <= baseExtra)) 
        {
            return (baseCentury + year);
        }
         else 
        {
            return ((baseCentury + year) - 100);
        }
    }
    
    cli::array<int32_t>* PersianCalendar::get_Eras_91b8aa89b8256658() {
        return (new cli::array<int32_t>({PersianEra}));
    }
    
    int32_t PersianCalendar::get_TwoDigitYearMax_14e9789b3d89e801() {
        return this->twoDigitYearMax;
    }
    
    int32_t PersianCalendar::set_TwoDigitYearMax_4852e071586288ab(int32_t value) {
        Calendar::CheckReadOnly();
        Calendar::M_ArgumentInRange(_T("value"), value, 100, this->get_M_MaxYear_b3d9776fced847fe());
        this->twoDigitYearMax = value;
        return get_TwoDigitYearMax_14e9789b3d89e801();
    }
    
    CalendarAlgorithmType PersianCalendar::get_AlgorithmType_1e3f8ed99adb8bde() {
        return CalendarAlgorithmType::SolarCalendar;
    }
    
    System::DateTime PersianCalendar::get_MinSupportedDateTime_63cdcad9cf7fca4e() {
        return PersianMin;
    }
    
    System::DateTime PersianCalendar::get_MaxSupportedDateTime_7bc53f690ae04821() {
        return PersianMax;
    }
    
}}
namespace System { namespace Globalization {
    
    RegionInfo*  RegionInfo::currentRegion;
    
    void RegionInfo::constructor(int32_t culture) {
        if(!(GetByTerritory(CultureInfo::GetCultureInfo(culture)))) 
        {
            throw cli::gcnew<System::ArgumentException>(System::String::Format2(_T("Region ID {0} (0x{0:X4}) is not a supported region."), cli::box(culture)), _T("culture"));
        }
    }
    
    void RegionInfo::constructor(System::String* name) {
        if((name ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>();
        }
        if(construct_internal_region_from_name(name->ToUpperInvariant())) 
        {
            this->lcid = name->GetHashCode_6648aef0f235ee6c();
            return;
        }
        if(!(GetByTerritory(CultureInfo::GetCultureInfo2(name)))) 
        {
            throw cli::gcnew<System::ArgumentException>(System::String::Format2(_T("Region name {0} is not supported."), name), _T("name"));
        }
    }
    
    bool RegionInfo::GetByTerritory(CultureInfo* ci) {
        if((ci ==  nullptr)) 
        {
            throw cli::gcnew<System::Exception>(_T("INTERNAL ERROR: should not happen."));
        }
        if((ci->get_IsNeutralCulture_9f9d058104a281b5() || (ci->get_Territory() ==  nullptr))) 
        {
            return false;
        }
        this->lcid = ci->get_LCID_f4b9bc9d0bf0db86();
        return construct_internal_region_from_name(ci->get_Territory()->ToUpperInvariant());
    }
    
    bool RegionInfo::construct_internal_region_from_name(System::String* name) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool RegionInfo::Equals_ed975d2f4a7d193e(System::Object* value) {
        RegionInfo *other = cli::as<RegionInfo*>(value);
        return ((other != nullptr) && (this->lcid ==  other->lcid));
    }
    
    int32_t RegionInfo::GetHashCode_6648aef0f235ee6c() {
        return (int32_t)((2147483648L + (int64_t)((this->regionId << 3))) + (int64_t)(this->regionId));
    }
    
    System::String* RegionInfo::ToString_1636a0751cb9ac11() {
        return this->get_Name_aa8506371e3ae98f();
    }
    
    RegionInfo* RegionInfo::get_CurrentRegion() {
        if((currentRegion ==  nullptr)) 
        {
            CultureInfo *ci = CultureInfo::get_CurrentCulture();
            if(((ci != nullptr) && (CultureInfo::BootstrapCultureID != 127))) 
            {
                currentRegion = cli::gcnew<RegionInfo>(CultureInfo::BootstrapCultureID);
            }
             else 
            {
                currentRegion = nullptr;
            }
        }
        return currentRegion;
    }
    
    System::String* RegionInfo::get_CurrencyEnglishName_11b35a21eae160d() {
        return this->currencyEnglishName;
    }
    
    System::String* RegionInfo::get_CurrencySymbol_b69fe85c17be1743() {
        return this->currencySymbol;
    }
    
    System::String* RegionInfo::get_DisplayName_bc0a8e7d4f2ccbb3() {
        return this->englishName;
    }
    
    System::String* RegionInfo::get_EnglishName_ef4bbabc6246acac() {
        return this->englishName;
    }
    
    int32_t RegionInfo::get_GeoId_444432e0a6fc700f() {
        return this->regionId;
    }
    
    bool RegionInfo::get_IsMetric_c8c7150d013c863e() {
        System::String* tmp_229 = this->iso2Name;
        ::System::Int32 tmp_230 = -1;
        if(::System::String::Equals3(tmp_229, _T("US")) ||
        ::System::String::Equals3(tmp_229, _T("UK"))) tmp_230 = 0;
        switch(tmp_230)
        {
            case 0: case_1072: 
            {
                return false;
            }
            default: case_1073: 
            {
                return true;
            }
        }
    }
    
    System::String* RegionInfo::get_ISOCurrencySymbol_9795598a14d3034d() {
        return this->isoCurrencySymbol;
    }
    
    System::String* RegionInfo::get_NativeName_28f7744bba08c8d9() {
        return this->get_DisplayName_bc0a8e7d4f2ccbb3();
    }
    
    System::String* RegionInfo::get_CurrencyNativeName_220dbae82fc109a1() {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    System::String* RegionInfo::get_Name_aa8506371e3ae98f() {
        return this->iso2Name;
    }
    
    System::String* RegionInfo::get_ThreeLetterISORegionName_81c0fa077c952438() {
        return this->iso3Name;
    }
    
    System::String* RegionInfo::get_ThreeLetterWindowsRegionName_ff69caefd8da1bc1() {
        return this->win3Name;
    }
    
    System::String* RegionInfo::get_TwoLetterISORegionName_a80b0feff91b723a() {
        return this->iso2Name;
    }
    
}}
namespace System { namespace Globalization {
    
    
    void StringInfo::constructor() {
    }
    
    void StringInfo::constructor(System::String* value) {
        this->set_String(value);
    }
    
    bool StringInfo::Equals_ed975d2f4a7d193e(System::Object* value) {
        StringInfo *other = cli::as<StringInfo*>(value);
        return ((other != nullptr) && System::String::op_Equality(this->s, other->s));
    }
    
    int32_t StringInfo::GetHashCode_6648aef0f235ee6c() {
        return this->s->GetHashCode_6648aef0f235ee6c();
    }
    
    System::String* StringInfo::SubstringByTextElements(int32_t startingTextElement) {
        if(((startingTextElement < 0) || (this->s->get_Length() ==  0))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("startingTextElement"));
        }
        int32_t idx = 0;
        for(int32_t i = 0; (i < startingTextElement); i++){
            if((idx >= this->s->get_Length())) 
            {
                throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("startingTextElement"));
            }
            (idx = idx + GetNextTextElementLength(this->s, idx));
        }
        return this->s->Substring(idx);
    }
    
    System::String* StringInfo::SubstringByTextElements2(int32_t startingTextElement, int32_t lengthInTextElements) {
        if(((startingTextElement < 0) || (this->s->get_Length() ==  0))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("startingTextElement"));
        }
        if((lengthInTextElements < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("lengthInTextElements"));
        }
        int32_t idx = 0;
        for(int32_t i = 0; (i < startingTextElement); i++){
            if((idx >= this->s->get_Length())) 
            {
                throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("startingTextElement"));
            }
            (idx = idx + GetNextTextElementLength(this->s, idx));
        }
        int32_t start = idx;
        for(int32_t i = 0; (i < lengthInTextElements); i++){
            if((idx >= this->s->get_Length())) 
            {
                throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("lengthInTextElements"));
            }
            (idx = idx + GetNextTextElementLength(this->s, idx));
        }
        return this->s->Substring2(start, (idx - start));
    }
    
    System::String* StringInfo::GetNextTextElement(System::String* str) {
        if(((str ==  nullptr) || (str->get_Length() ==  0))) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("string is null"));
        }
        return GetNextTextElement2(str, 0);
    }
    
    System::String* StringInfo::GetNextTextElement2(System::String* str, int32_t index) {
        int32_t len = GetNextTextElementLength(str, index);
        return (len != 1) ? str->Substring2(index, len) : cli::gcnew<System::String>(str->get_Chars(index), 1);
    }
    
    int32_t StringInfo::GetNextTextElementLength(System::String* str, int32_t index) {
        if((str ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("string is null"));
        }
        if((index >= str->get_Length())) 
        {
            return 0;
        }
        if((index < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("Index is not valid"));
        }
        char16_t ch = str->get_Chars(index);
        UnicodeCategory cat = System::Char::GetUnicodeCategory(ch);
        if(((int32_t)(cat) ==  16)) 
        {
            if((((int32_t)(ch) >= 55296) && ((int32_t)(ch) <= 56319))) 
            {
                if(((((index + 1) < str->get_Length()) && ((int32_t)(str->get_Chars((index + 1))) >= 56320)) && ((int32_t)(str->get_Chars((index + 1))) <= 57343))) 
                {
                    return 2;
                }
                 else 
                {
                    return 1;
                }
            }
             else 
            {
                return 1;
            }
        }
         else 
        {
            if(((((int32_t)(cat) ==  5) || ((int32_t)(cat) ==  6)) || ((int32_t)(cat) ==  7))) 
            {
                return 1;
            }
            int32_t count = 1;
            while(((index + count) < str->get_Length())) {
                cat = System::Char::GetUnicodeCategory(str->get_Chars((index + count)));
                if(((((int32_t)(cat) != 5) && ((int32_t)(cat) != 6)) && ((int32_t)(cat) != 7))) 
                {
                    break;
                }
                count++;
            }
            return count;
        }
    }
    
    TextElementEnumerator* StringInfo::GetTextElementEnumerator(System::String* str) {
        if(((str ==  nullptr) || (str->get_Length() ==  0))) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("string is null"));
        }
        return cli::gcnew<TextElementEnumerator>(str, 0);
    }
    
    TextElementEnumerator* StringInfo::GetTextElementEnumerator2(System::String* str, int32_t index) {
        if((str ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("string is null"));
        }
        if(((index < 0) || (index >= str->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("Index is not valid"));
        }
        return cli::gcnew<TextElementEnumerator>(str, index);
    }
    
    cli::array<int32_t>* StringInfo::ParseCombiningCharacters(System::String* str) {
        if((str ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("string is null"));
        }
        System::Collections::ArrayList *indices = cli::gcnew<System::Collections::ArrayList>(str->get_Length());
        TextElementEnumerator *tee = GetTextElementEnumerator(str);
        tee->Reset();
        while(tee->MoveNext()) {
            indices->Add_e6a92085999ce388(cli::box(tee->get_ElementIndex()));
        }
        return cli::cast<cli::array<int32_t>*>(indices->ToArray_7b80f35a5dbfbc47(cli::typeof<System::Type>::info));
    }
    
    int32_t StringInfo::get_LengthInTextElements() {
        if((this->length < 0)) 
        {
            this->length = 0;
            for(int32_t idx = 0; (idx < this->s->get_Length()); this->length++) {
                (idx = idx + GetNextTextElementLength(this->s, idx));
            }
        }
        return this->length;
    }
    
    System::String* StringInfo::get_String() {
        return this->s;
    }
    
    System::String* StringInfo::set_String(System::String* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("value"));
        }
        this->length = -1;
        this->s = value;
        return get_String();
    }
    
}}
namespace System { namespace Globalization {
    
    CCGregorianEraHandler*  TaiwanCalendar::M_EraHandler;
    System::DateTime  TaiwanCalendar::TaiwanMin;
    System::DateTime  TaiwanCalendar::TaiwanMax;
    
    TaiwanCalendar::TaiwanCalendar()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void TaiwanCalendar::static_constructor() {
        M_EraHandler = cli::gcnew<CCGregorianEraHandler>();
        M_EraHandler->appendEra2(1, CCGregorianCalendar::fixed_from_dmy(1, 1, 1912));
    }
    
    void TaiwanCalendar::constructor() {
        this->M_AbbrEraNames = (new cli::array<System::String*>({_T("T.C.E.")}));
        this->M_EraNames = (new cli::array<System::String*>({_T("Taiwan current era")}));
    }
    
    void TaiwanCalendar::M_CheckDateTime(System::DateTime time) {
        M_EraHandler->CheckDateTime(time);
    }
    
    void TaiwanCalendar::M_CheckEra(int32_t era) {
        if((era ==  0)) 
        {
            era = 1;
        }
        if(!(M_EraHandler->ValidEra(era))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Era value was not valid."));
        }
    }
    
    int32_t TaiwanCalendar::M_CheckYEG(int32_t year, int32_t era) {
        M_CheckEra(era);
        return M_EraHandler->GregorianYear(year, era);
    }
    
    void TaiwanCalendar::M_CheckYE_c830e88539d38d64(int32_t year, int32_t era) {
        M_CheckYEG(year, era);
    }
    
    int32_t TaiwanCalendar::M_CheckYMEG(int32_t year, int32_t month, int32_t era) {
        int32_t gregorianYear = M_CheckYEG(year, era);
        if(((month < 1) || (month > 12))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("month"), _T("Month must be between one and twelve."));
        }
        return gregorianYear;
    }
    
    int32_t TaiwanCalendar::M_CheckYMDEG(int32_t year, int32_t month, int32_t day, int32_t era) {
        int32_t gregorianYear = M_CheckYMEG(year, month, era);
        Calendar::M_ArgumentInRange(_T("day"), day, 1, TaiwanCalendar::GetDaysInMonth_233a2cea4d4c72fe(year, month, era));
        return gregorianYear;
    }
    
    System::DateTime TaiwanCalendar::AddMonths_a4a4579bf9385278(System::DateTime time, int32_t months) {
        System::DateTime t = CCGregorianCalendar::AddMonths(time, months);
        M_CheckDateTime(t);
        return t;
    }
    
    System::DateTime TaiwanCalendar::AddYears_8bb7ea0ef803063e(System::DateTime time, int32_t years) {
        System::DateTime t = CCGregorianCalendar::AddYears(time, years);
        M_CheckDateTime(t);
        return t;
    }
    
    int32_t TaiwanCalendar::GetDayOfMonth_7da4e9f8c6f0dece(System::DateTime time) {
        M_CheckDateTime(time);
        return CCGregorianCalendar::GetDayOfMonth(time);
    }
    
    System::DayOfWeek TaiwanCalendar::GetDayOfWeek_4c0b69c7bb83520e(System::DateTime time) {
        M_CheckDateTime(time);
        int32_t rd = CCFixed::FromDateTime(time);
        return (System::DayOfWeek)(CCFixed::day_of_week(rd));
    }
    
    int32_t TaiwanCalendar::GetDayOfYear_1eaa1ac34e65f799(System::DateTime time) {
        M_CheckDateTime(time);
        return CCGregorianCalendar::GetDayOfYear(time);
    }
    
    int32_t TaiwanCalendar::GetDaysInMonth_233a2cea4d4c72fe(int32_t year, int32_t month, int32_t era) {
        int32_t gregorianYear = M_CheckYMEG(year, month, era);
        return CCGregorianCalendar::GetDaysInMonth(gregorianYear, month);
    }
    
    int32_t TaiwanCalendar::GetDaysInYear_ae0f8cfee3ff2567(int32_t year, int32_t era) {
        int32_t gregorianYear = M_CheckYEG(year, era);
        return CCGregorianCalendar::GetDaysInYear(gregorianYear);
    }
    
    int32_t TaiwanCalendar::GetEra_1d16c3456dce785e(System::DateTime time) {
        int32_t rd = CCFixed::FromDateTime(time);
        int32_t era;
        M_EraHandler->EraYear(era, rd);
        return era;
    }
    
    int32_t TaiwanCalendar::GetLeapMonth_fb3256a34d84f7ed(int32_t year, int32_t era) {
        return 0;
    }
    
    int32_t TaiwanCalendar::GetMonth_66424683b988a96b(System::DateTime time) {
        M_CheckDateTime(time);
        return CCGregorianCalendar::GetMonth(time);
    }
    
    int32_t TaiwanCalendar::GetMonthsInYear_2ae36c9a94a7bffb(int32_t year, int32_t era) {
        M_CheckYEG(year, era);
        return 12;
    }
    
    int32_t TaiwanCalendar::GetWeekOfYear_d25712e900e29bec(System::DateTime time, CalendarWeekRule rule, System::DayOfWeek firstDayOfWeek) {
        return Calendar::GetWeekOfYear_d25712e900e29bec(time, rule, firstDayOfWeek);
    }
    
    int32_t TaiwanCalendar::GetYear_75c1b17aa90af360(System::DateTime time) {
        int32_t rd = CCFixed::FromDateTime(time);
        int32_t era;
        return M_EraHandler->EraYear(era, rd);
    }
    
    bool TaiwanCalendar::IsLeapDay_7c795c9f36944ade(int32_t year, int32_t month, int32_t day, int32_t era) {
        int32_t gregorianYear = M_CheckYMDEG(year, month, day, era);
        return CCGregorianCalendar::IsLeapDay(gregorianYear, month, day);
    }
    
    bool TaiwanCalendar::IsLeapMonth_85b9917f2bdaeef7(int32_t year, int32_t month, int32_t era) {
        M_CheckYMEG(year, month, era);
        return false;
    }
    
    bool TaiwanCalendar::IsLeapYear_7aad026a1103cfb(int32_t year, int32_t era) {
        int32_t gregorianYear = M_CheckYEG(year, era);
        return CCGregorianCalendar::is_leap_year(gregorianYear);
    }
    
    System::DateTime TaiwanCalendar::ToDateTime_82b4ff6780819fcd(int32_t year, int32_t month, int32_t day, int32_t hour, int32_t minute, int32_t second, int32_t millisecond, int32_t era) {
        int32_t gregorianYear = M_CheckYMDEG(year, month, day, era);
        Calendar::M_CheckHMSM(hour, minute, second, millisecond);
        return CCGregorianCalendar::ToDateTime(gregorianYear, month, day, hour, minute, second, millisecond);
    }
    
    int32_t TaiwanCalendar::ToFourDigitYear_cb92a104112b3121(int32_t year) {
        if((year < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("year"), _T("Non-negative number required."));
        }
        int32_t era = 0;
        Calendar::M_CheckYE_c830e88539d38d64(year, era);
        return year;
    }
    
    cli::array<int32_t>* TaiwanCalendar::get_Eras_91b8aa89b8256658() {
        return cli::cast<cli::array<int32_t>*>(cli::import(M_EraHandler->get_Eras())->Clone());
    }
    
    int32_t TaiwanCalendar::get_TwoDigitYearMax_14e9789b3d89e801() {
        return this->twoDigitYearMax;
    }
    
    int32_t TaiwanCalendar::set_TwoDigitYearMax_4852e071586288ab(int32_t value) {
        Calendar::CheckReadOnly();
        Calendar::M_ArgumentInRange(_T("value"), value, 100, this->get_M_MaxYear_b3d9776fced847fe());
        this->twoDigitYearMax = value;
        return get_TwoDigitYearMax_14e9789b3d89e801();
    }
    
    CalendarAlgorithmType TaiwanCalendar::get_AlgorithmType_1e3f8ed99adb8bde() {
        return CalendarAlgorithmType::SolarCalendar;
    }
    
    System::DateTime TaiwanCalendar::get_MinSupportedDateTime_63cdcad9cf7fca4e() {
        return TaiwanMin;
    }
    
    System::DateTime TaiwanCalendar::get_MaxSupportedDateTime_7bc53f690ae04821() {
        return TaiwanMax;
    }
    
}}
namespace System { namespace Globalization {
    
    CCEastAsianLunisolarEraHandler*  TaiwanLunisolarCalendar::era_handler;
    System::DateTime  TaiwanLunisolarCalendar::TaiwanMin;
    System::DateTime  TaiwanLunisolarCalendar::TaiwanMax;
    
    TaiwanLunisolarCalendar::TaiwanLunisolarCalendar()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void TaiwanLunisolarCalendar::static_constructor() {
        era_handler = cli::gcnew<CCEastAsianLunisolarEraHandler>();
        era_handler->appendEra(1, CCFixed::FromDateTime(TaiwanMin), CCFixed::FromDateTime(TaiwanMax));
    }
    
    void TaiwanLunisolarCalendar::constructor() {
    }
    
    int32_t TaiwanLunisolarCalendar::GetEra_1d16c3456dce785e(System::DateTime time) {
        int32_t rd = CCFixed::FromDateTime(time);
        int32_t era;
        era_handler->EraYear(era, rd);
        return era;
    }
    
    cli::array<int32_t>* TaiwanLunisolarCalendar::get_Eras_91b8aa89b8256658() {
        return cli::cast<cli::array<int32_t>*>(cli::import(era_handler->get_Eras())->Clone());
    }
    
    System::DateTime TaiwanLunisolarCalendar::get_MinSupportedDateTime_63cdcad9cf7fca4e() {
        return TaiwanMin;
    }
    
    System::DateTime TaiwanLunisolarCalendar::get_MaxSupportedDateTime_7bc53f690ae04821() {
        return TaiwanMax;
    }
    
}}
namespace System { namespace Globalization {
    
    
    void TextElementEnumerator::constructor(System::String* str, int32_t startpos) {
        this->index = -1;
        this->startpos = startpos;
        this->str = str->Substring(startpos);
        this->element = nullptr;
    }
    
    System::String* TextElementEnumerator::GetTextElement() {
        if((this->element ==  nullptr)) 
        {
            throw cli::gcnew<System::InvalidOperationException>();
        }
        return this->element;
    }
    
    bool TextElementEnumerator::MoveNext() {
        this->elementindex = (this->index + 1);
        if((this->elementindex < this->str->get_Length())) 
        {
            this->element = StringInfo::GetNextTextElement2(this->str, this->elementindex);
            (this->index = this->index + this->element->get_Length());
            return true;
        }
         else 
        {
            this->element = nullptr;
            return false;
        }
    }
    
    void TextElementEnumerator::Reset() {
        this->element = nullptr;
        this->index = -1;
    }
    
    System::Object* TextElementEnumerator::get_Current() {
        if((this->element ==  nullptr)) 
        {
            throw cli::gcnew<System::InvalidOperationException>();
        }
        return this->element;
    }
    
    int32_t TextElementEnumerator::get_ElementIndex() {
        if((this->element ==  nullptr)) 
        {
            throw cli::gcnew<System::InvalidOperationException>();
        }
        return (this->elementindex + this->startpos);
    }
    
}}
namespace System { namespace Globalization {
    
    
    void TextInfo::constructor(CultureInfo* ci, int32_t lcid, void* data, bool read_only) {
        this->m_isReadOnly = read_only;
        this->m_win32LangID = lcid;
        this->ci = ci;
        if((data != nullptr)) 
        {
            this->data = (*(Data*)(data));
        }
         else 
        {
            this->data = cli::ctor<Data>();
            this->data->list_sep = 44;
        }
        CultureInfo *tmp = ci;
        while((((tmp->get_Parent_87d5fb2f5c680cba() != nullptr) && (tmp->get_Parent_87d5fb2f5c680cba()->get_LCID_f4b9bc9d0bf0db86() != 127)) && (tmp->get_Parent_87d5fb2f5c680cba() != tmp))) tmp = tmp->get_Parent_87d5fb2f5c680cba();
        if((tmp != nullptr)) 
        {
            switch(tmp->get_LCID_f4b9bc9d0bf0db86()) {
                case 44: case 31: case_1074: {
                    this->handleDotI = true;
                    break;
                }
            }
        }
    }
    
    void TextInfo::constructor(TextInfo* textInfo) {
        this->m_win32LangID = textInfo->m_win32LangID;
        this->m_nDataItem = textInfo->m_nDataItem;
        this->m_useUserOverride = textInfo->m_useUserOverride;
        this->m_listSeparator = textInfo->get_ListSeparator_38425c2002d1a031();
        this->customCultureName = textInfo->get_CultureName();
        this->ci = textInfo->ci;
        this->handleDotI = textInfo->handleDotI;
        this->data = textInfo->data;
    }
    
    bool TextInfo::Equals_ed975d2f4a7d193e(System::Object* obj) {
        if((obj ==  nullptr)) 
        {
            return false;
        }
        TextInfo *other = cli::as<TextInfo*>(obj);
        if((other ==  nullptr)) 
        {
            return false;
        }
        if((other->m_win32LangID != this->m_win32LangID)) 
        {
            return false;
        }
        if((other->ci != this->ci)) 
        {
            return false;
        }
        return true;
    }
    
    int32_t TextInfo::GetHashCode_6648aef0f235ee6c() {
        return this->m_win32LangID;
    }
    
    System::String* TextInfo::ToString_1636a0751cb9ac11() {
        return cli::concat(_T("TextInfo - "), cli::box(this->m_win32LangID));
    }
    
    System::String* TextInfo::ToTitleCase(System::String* str) {
        if((str ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("str"));
        }
        System::Text::StringBuilder *sb = nullptr;
        int32_t i = 0;
        int32_t start = 0;
        while((i < str->get_Length())) {
            if(!(System::Char::IsLetter(str->get_Chars(i++)))) 
            {
                continue;
            }
            i--;
            char16_t t = ToTitleCase2(str->get_Chars(i));
            bool capitalize = true;
            if(((int32_t)(t) ==  (int32_t)(str->get_Chars(i)))) 
            {
                capitalize = false;
                bool allTitle = true;
                int32_t saved = i;
                while((++i < str->get_Length())) {
                    if(System::Char::IsWhiteSpace(str->get_Chars(i))) 
                    {
                        break;
                    }
                    t = ToTitleCase2(str->get_Chars(i));
                    if(((int32_t)(t) != (int32_t)(str->get_Chars(i)))) 
                    {
                        allTitle = false;
                        break;
                    }
                }
                if(allTitle) 
                {
                    continue;
                }
                i = saved;
                while((++i < str->get_Length())) {
                    if(System::Char::IsWhiteSpace(str->get_Chars(i))) 
                    {
                        break;
                    }
                    if(((int32_t)(ToLower_6b32dfb00a24a852(str->get_Chars(i))) != (int32_t)(str->get_Chars(i)))) 
                    {
                        capitalize = true;
                        i = saved;
                        break;
                    }
                }
            }
            if(capitalize) 
            {
                if((sb ==  nullptr)) 
                {
                    sb = cli::gcnew<System::Text::StringBuilder>(str->get_Length());
                }
                sb->Append19(str, start, (i - start));
                sb->Append16(ToTitleCase2(str->get_Chars(i)));
                start = (i + 1);
                while((++i < str->get_Length())) {
                    if(System::Char::IsWhiteSpace(str->get_Chars(i))) 
                    {
                        break;
                    }
                    sb->Append16(ToLower_6b32dfb00a24a852(str->get_Chars(i)));
                }
                start = i;
            }
        }
        if((sb != nullptr)) 
        {
            sb->Append19(str, start, (str->get_Length() - start));
        }
        return (sb != nullptr) ? sb->ToString_1636a0751cb9ac11() : str;
    }
    
    char16_t TextInfo::ToLower_6b32dfb00a24a852(char16_t c) {
        if((((int32_t)(c) < 64) || ((96 < (int32_t)(c)) && ((int32_t)(c) < 128)))) 
        {
            return c;
        }
         else 
        {
            if((((65 <= (int32_t)(c)) && ((int32_t)(c) <= 90)) && (!(this->handleDotI) || ((int32_t)(c) != 73)))) 
            {
                return (char16_t)((int32_t)(c) + 32);
            }
        }
        if(((this->ci ==  nullptr) || (this->ci->get_LCID_f4b9bc9d0bf0db86() ==  127))) 
        {
            return System::Char::ToLowerInvariant(c);
        }
        switch(c) {
            case u'I': case_1075: {
                if(this->handleDotI) 
                {
                    return u'\x131';
                }
                break;
            }
            case u'\x130': case_1076: {
                return u'i';
            }
            case u'\x1c5': case_1077: {
                return u'\x1c6';
            }
            case u'\x1c8': case_1078: {
                return u'\x1c9';
            }
            case u'\x1cb': case_1079: {
                return u'\x1cc';
            }
            case u'\x1f2': case_1080: {
                return u'\x1f3';
            }
            case u'\x3d2': case_1081: {
                return u'\x3c5';
            }
            case u'\x3d3': case_1082: {
                return u'\x3cd';
            }
            case u'\x3d4': case_1083: {
                return u'\x3cb';
            }
        }
        return System::Char::ToLowerInvariant(c);
    }
    
    char16_t TextInfo::ToUpper_d4d54a4b5ef4f4c7(char16_t c) {
        if(((int32_t)(c) < 96)) 
        {
            return c;
        }
         else 
        {
            if((((97 <= (int32_t)(c)) && ((int32_t)(c) <= 122)) && (!(this->handleDotI) || ((int32_t)(c) != 105)))) 
            {
                return (char16_t)((int32_t)(c) - 32);
            }
        }
        if(((this->ci ==  nullptr) || (this->ci->get_LCID_f4b9bc9d0bf0db86() ==  127))) 
        {
            return System::Char::ToUpperInvariant(c);
        }
        switch(c) {
            case u'i': case_1084: {
                if(this->handleDotI) 
                {
                    return u'\x130';
                }
                break;
            }
            case u'\x131': case_1085: {
                return u'I';
            }
            case u'\x1c5': case_1086: {
                return u'\x1c4';
            }
            case u'\x1c8': case_1087: {
                return u'\x1c7';
            }
            case u'\x1cb': case_1088: {
                return u'\x1ca';
            }
            case u'\x1f2': case_1089: {
                return u'\x1f1';
            }
            case u'\x390': case_1090: {
                return u'\x3aa';
            }
            case u'\x3b0': case_1091: {
                return u'\x3ab';
            }
            case u'\x3d0': case_1092: {
                return u'\x392';
            }
            case u'\x3d1': case_1093: {
                return u'\x398';
            }
            case u'\x3d5': case_1094: {
                return u'\x3a6';
            }
            case u'\x3d6': case_1095: {
                return u'\x3a0';
            }
            case u'\x3f0': case_1096: {
                return u'\x39a';
            }
            case u'\x3f1': case_1097: {
                return u'\x3a1';
            }
        }
        return System::Char::ToUpperInvariant(c);
    }
    
    char16_t TextInfo::ToTitleCase2(char16_t c) {
        switch(c) {
            case u'\x1c4': case u'\x1c5': case u'\x1c6': case_1098: {
                return u'\x1c5';
            }
            case u'\x1c7': case u'\x1c8': case u'\x1c9': case_1099: {
                return u'\x1c8';
            }
            case u'\x1ca': case u'\x1cb': case u'\x1cc': case_1100: {
                return u'\x1cb';
            }
            case u'\x1f1': case u'\x1f2': case u'\x1f3': case_1101: {
                return u'\x1f2';
            }
        }
        if((((8560 <= (int32_t)(c)) && ((int32_t)(c) <= 8575)) || ((9424 <= (int32_t)(c)) && ((int32_t)(c) <= 9449)))) 
        {
            return c;
        }
        return ToUpper_d4d54a4b5ef4f4c7(c);
    }
    
    System::String* TextInfo::ToLower_4a9626b08fd9b34f(System::String* str) {
        if((str ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("str"));
        }
        if((str->get_Length() ==  0)) 
        {
            return System::String::Empty;
        }
        System::String *tmp = System::String::InternalAllocateStr(str->get_Length());
        {
            /* FIXED - BLOCK */
            char16_t* source = cli::fixed_guard(str);
            char16_t* dest = cli::fixed_guard(tmp);
            char16_t *destPtr = (char16_t*)(dest);
            char16_t *sourcePtr = (char16_t*)(source);
            for(int32_t n = 0; (n < str->get_Length()); n++){
                (*destPtr) = ToLower_6b32dfb00a24a852((*sourcePtr));
                sourcePtr++;
                destPtr++;
            }
        }
        return tmp;
    }
    
    System::String* TextInfo::ToUpper_e8666e8cddf53901(System::String* str) {
        if((str ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("str"));
        }
        if((str->get_Length() ==  0)) 
        {
            return System::String::Empty;
        }
        System::String *tmp = System::String::InternalAllocateStr(str->get_Length());
        {
            /* FIXED - BLOCK */
            char16_t* source = cli::fixed_guard(str);
            char16_t* dest = cli::fixed_guard(tmp);
            char16_t *destPtr = (char16_t*)(dest);
            char16_t *sourcePtr = (char16_t*)(source);
            for(int32_t n = 0; (n < str->get_Length()); n++){
                (*destPtr) = ToUpper_d4d54a4b5ef4f4c7((*sourcePtr));
                sourcePtr++;
                destPtr++;
            }
        }
        return tmp;
    }
    
    TextInfo* TextInfo::ReadOnly(TextInfo* textInfo) {
        if((textInfo ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("textInfo"));
        }
        TextInfo *ti = cli::gcnew<TextInfo>(textInfo);
        ti->m_isReadOnly = true;
        return ti;
    }
    
    void TextInfo::OnDeserialization(System::Object* sender) {
    }
    
    System::Object* TextInfo::Clone_44be9aa808ba92d() {
        return cli::gcnew<TextInfo>(this);
    }
    
    int32_t TextInfo::get_ANSICodePage_3487ba754586e2d2() {
        return this->data->ansi;
    }
    
    int32_t TextInfo::get_EBCDICCodePage_9c6cac1274ec0da6() {
        return this->data->ebcdic;
    }
    
    int32_t TextInfo::get_LCID() {
        return this->m_win32LangID;
    }
    
    System::String* TextInfo::get_ListSeparator_38425c2002d1a031() {
        if((this->m_listSeparator ==  nullptr)) 
        {
            this->m_listSeparator = cli::import((char16_t)this->data->list_sep)->ToString_1636a0751cb9ac11();
        }
        return this->m_listSeparator;
    }
    
    System::String* TextInfo::set_ListSeparator_d0d54fbb574b9e9(System::String* value) {
        this->m_listSeparator = value;
        return get_ListSeparator_38425c2002d1a031();
    }
    
    int32_t TextInfo::get_MacCodePage_891737ecab226e53() {
        return this->data->mac;
    }
    
    int32_t TextInfo::get_OEMCodePage_66052b7987828f2f() {
        return this->data->oem;
    }
    
    System::String* TextInfo::get_CultureName() {
        if((this->customCultureName ==  nullptr)) 
        {
            this->customCultureName = (this->ci ==  nullptr) ? System::String::Empty : this->ci->get_Name_7a59bd1b86cfacd3();
        }
        return this->customCultureName;
    }
    
    bool TextInfo::get_IsReadOnly() {
        return this->m_isReadOnly;
    }
    
    bool TextInfo::get_IsRightToLeft() {
        switch(this->m_win32LangID) {
            case 1: case 13: case 32: case 41: case 90: case 101: case 1025: case 1037: case 1056: case 1065: case 1114: case 1125: case 2049: case 3073: case 4097: case 5121: case 6145: case 7169: case 8193: case 9217: case 10241: case 11265: case 12289: case 13313: case 14337: case 15361: case 16385: case_1102: {
                return true;
            }
            default: case_1103: {
                return false;
            }
        }
    }
    
}}
namespace System { namespace Globalization {
    
    CCGregorianEraHandler*  ThaiBuddhistCalendar::M_EraHandler;
    System::DateTime  ThaiBuddhistCalendar::ThaiMin;
    System::DateTime  ThaiBuddhistCalendar::ThaiMax;
    
    ThaiBuddhistCalendar::ThaiBuddhistCalendar()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void ThaiBuddhistCalendar::static_constructor() {
        M_EraHandler = cli::gcnew<CCGregorianEraHandler>();
        M_EraHandler->appendEra2(1, CCGregorianCalendar::fixed_from_dmy(1, 1, -542));
    }
    
    void ThaiBuddhistCalendar::constructor() {
        this->M_AbbrEraNames = (new cli::array<System::String*>({_T("T.B.C.E.")}));
        this->M_EraNames = (new cli::array<System::String*>({_T("ThaiBuddhist current era")}));
        if((this->twoDigitYearMax ==  99)) 
        {
            this->twoDigitYearMax = 2572;
        }
    }
    
    void ThaiBuddhistCalendar::M_CheckEra(int32_t era) {
        if((era ==  0)) 
        {
            era = 1;
        }
        if(!(M_EraHandler->ValidEra(era))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Era value was not valid."));
        }
    }
    
    int32_t ThaiBuddhistCalendar::M_CheckYEG(int32_t year, int32_t era) {
        M_CheckEra(era);
        return M_EraHandler->GregorianYear(year, era);
    }
    
    void ThaiBuddhistCalendar::M_CheckYE_c830e88539d38d64(int32_t year, int32_t era) {
        M_CheckYEG(year, era);
    }
    
    int32_t ThaiBuddhistCalendar::M_CheckYMEG(int32_t year, int32_t month, int32_t era) {
        int32_t gregorianYear = M_CheckYEG(year, era);
        if(((month < 1) || (month > 12))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("month"), _T("Month must be between one and twelve."));
        }
        return gregorianYear;
    }
    
    int32_t ThaiBuddhistCalendar::M_CheckYMDEG(int32_t year, int32_t month, int32_t day, int32_t era) {
        int32_t gregorianYear = M_CheckYMEG(year, month, era);
        Calendar::M_ArgumentInRange(_T("day"), day, 1, ThaiBuddhistCalendar::GetDaysInMonth_233a2cea4d4c72fe(year, month, era));
        return gregorianYear;
    }
    
    System::DateTime ThaiBuddhistCalendar::AddMonths_a4a4579bf9385278(System::DateTime time, int32_t months) {
        return CCGregorianCalendar::AddMonths(time, months);
    }
    
    System::DateTime ThaiBuddhistCalendar::AddYears_8bb7ea0ef803063e(System::DateTime time, int32_t years) {
        return CCGregorianCalendar::AddYears(time, years);
    }
    
    int32_t ThaiBuddhistCalendar::GetDayOfMonth_7da4e9f8c6f0dece(System::DateTime time) {
        return CCGregorianCalendar::GetDayOfMonth(time);
    }
    
    System::DayOfWeek ThaiBuddhistCalendar::GetDayOfWeek_4c0b69c7bb83520e(System::DateTime time) {
        int32_t rd = CCFixed::FromDateTime(time);
        return (System::DayOfWeek)(CCFixed::day_of_week(rd));
    }
    
    int32_t ThaiBuddhistCalendar::GetDayOfYear_1eaa1ac34e65f799(System::DateTime time) {
        return CCGregorianCalendar::GetDayOfYear(time);
    }
    
    int32_t ThaiBuddhistCalendar::GetDaysInMonth_233a2cea4d4c72fe(int32_t year, int32_t month, int32_t era) {
        int32_t gregorianYear = M_CheckYMEG(year, month, era);
        return CCGregorianCalendar::GetDaysInMonth(gregorianYear, month);
    }
    
    int32_t ThaiBuddhistCalendar::GetDaysInYear_ae0f8cfee3ff2567(int32_t year, int32_t era) {
        int32_t gregorianYear = M_CheckYEG(year, era);
        return CCGregorianCalendar::GetDaysInYear(gregorianYear);
    }
    
    int32_t ThaiBuddhistCalendar::GetEra_1d16c3456dce785e(System::DateTime time) {
        int32_t rd = CCFixed::FromDateTime(time);
        int32_t era;
        M_EraHandler->EraYear(era, rd);
        return era;
    }
    
    int32_t ThaiBuddhistCalendar::GetLeapMonth_fb3256a34d84f7ed(int32_t year, int32_t era) {
        return 0;
    }
    
    int32_t ThaiBuddhistCalendar::GetMonth_66424683b988a96b(System::DateTime time) {
        return CCGregorianCalendar::GetMonth(time);
    }
    
    int32_t ThaiBuddhistCalendar::GetMonthsInYear_2ae36c9a94a7bffb(int32_t year, int32_t era) {
        Calendar::M_CheckYE_c830e88539d38d64(year, era);
        return 12;
    }
    
    int32_t ThaiBuddhistCalendar::GetWeekOfYear_d25712e900e29bec(System::DateTime time, CalendarWeekRule rule, System::DayOfWeek firstDayOfWeek) {
        return Calendar::GetWeekOfYear_d25712e900e29bec(time, rule, firstDayOfWeek);
    }
    
    int32_t ThaiBuddhistCalendar::GetYear_75c1b17aa90af360(System::DateTime time) {
        int32_t rd = CCFixed::FromDateTime(time);
        int32_t era;
        return M_EraHandler->EraYear(era, rd);
    }
    
    bool ThaiBuddhistCalendar::IsLeapDay_7c795c9f36944ade(int32_t year, int32_t month, int32_t day, int32_t era) {
        int32_t gregorianYear = M_CheckYMDEG(year, month, day, era);
        return CCGregorianCalendar::IsLeapDay(gregorianYear, month, day);
    }
    
    bool ThaiBuddhistCalendar::IsLeapMonth_85b9917f2bdaeef7(int32_t year, int32_t month, int32_t era) {
        M_CheckYMEG(year, month, era);
        return false;
    }
    
    bool ThaiBuddhistCalendar::IsLeapYear_7aad026a1103cfb(int32_t year, int32_t era) {
        int32_t gregorianYear = M_CheckYEG(year, era);
        return CCGregorianCalendar::is_leap_year(gregorianYear);
    }
    
    System::DateTime ThaiBuddhistCalendar::ToDateTime_82b4ff6780819fcd(int32_t year, int32_t month, int32_t day, int32_t hour, int32_t minute, int32_t second, int32_t millisecond, int32_t era) {
        int32_t gregorianYear = M_CheckYMDEG(year, month, day, era);
        Calendar::M_CheckHMSM(hour, minute, second, millisecond);
        return CCGregorianCalendar::ToDateTime(gregorianYear, month, day, hour, minute, second, millisecond);
    }
    
    int32_t ThaiBuddhistCalendar::ToFourDigitYear_cb92a104112b3121(int32_t year) {
        return Calendar::ToFourDigitYear_cb92a104112b3121(year);
    }
    
    cli::array<int32_t>* ThaiBuddhistCalendar::get_Eras_91b8aa89b8256658() {
        return cli::cast<cli::array<int32_t>*>(cli::import(M_EraHandler->get_Eras())->Clone());
    }
    
    int32_t ThaiBuddhistCalendar::get_TwoDigitYearMax_14e9789b3d89e801() {
        return this->twoDigitYearMax;
    }
    
    int32_t ThaiBuddhistCalendar::set_TwoDigitYearMax_4852e071586288ab(int32_t value) {
        Calendar::CheckReadOnly();
        Calendar::M_ArgumentInRange(_T("value"), value, 100, this->get_M_MaxYear_b3d9776fced847fe());
        this->twoDigitYearMax = value;
        return get_TwoDigitYearMax_14e9789b3d89e801();
    }
    
    CalendarAlgorithmType ThaiBuddhistCalendar::get_AlgorithmType_1e3f8ed99adb8bde() {
        return CalendarAlgorithmType::SolarCalendar;
    }
    
    System::DateTime ThaiBuddhistCalendar::get_MinSupportedDateTime_63cdcad9cf7fca4e() {
        return ThaiMin;
    }
    
    System::DateTime ThaiBuddhistCalendar::get_MaxSupportedDateTime_7bc53f690ae04821() {
        return ThaiMax;
    }
    
}}
namespace System { namespace Globalization {
    
    int32_t  UmAlQuraCalendar::M_MinFixed;
    int32_t  UmAlQuraCalendar::M_MaxFixed;
    System::DateTime  UmAlQuraCalendar::Min;
    System::DateTime  UmAlQuraCalendar::Max;
    
    UmAlQuraCalendar::UmAlQuraCalendar()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void UmAlQuraCalendar::constructor() {
        this->M_AbbrEraNames = (new cli::array<System::String*>({_T("A.H.")}));
        this->M_EraNames = (new cli::array<System::String*>({_T("Anno Hegirae")}));
        if((this->twoDigitYearMax ==  99)) 
        {
            this->twoDigitYearMax = 1451;
        }
    }
    
    void UmAlQuraCalendar::static_constructor() {
    }
    
    void UmAlQuraCalendar::M_CheckFixedHijri(System::String* param, int32_t rdHijri) {
        if(((rdHijri < M_MinFixed) || (rdHijri > (M_MaxFixed - this->get_AddHijriDate_6bdbae9ac7363670())))) 
        {
            System::IO::StringWriter *sw = cli::gcnew<System::IO::StringWriter>();
            int32_t day, month, year;
            CCHijriCalendar::dmy_from_fixed(day, month, year, (M_MaxFixed - this->get_AddHijriDate_6bdbae9ac7363670()));
            if((this->get_AddHijriDate_6bdbae9ac7363670() != 0)) 
            {
                sw->Write_e2bf1f4b5968ab9(_T("This HijriCalendar (AddHijriDate {0}) allows dates from 1. 1. 1 to {1}. {2}. {3}."), (new cli::array<System::Object*>({cli::box(this->get_AddHijriDate_6bdbae9ac7363670()), cli::box(day), cli::box(month), cli::box(year)})));
            }
             else 
            {
                sw->Write_4d2ac9c7b9e5e3b6(_T("HijriCalendar allows dates from 1.1.1 to {0}.{1}.{2}."), cli::box(day), cli::box(month), cli::box(year));
            }
            throw cli::gcnew<System::ArgumentOutOfRangeException>(param, sw->ToString_1636a0751cb9ac11());
        }
    }
    
    void UmAlQuraCalendar::M_CheckDateTime(System::DateTime time) {
        int32_t rd = (CCFixed::FromDateTime(time) - this->get_AddHijriDate_6bdbae9ac7363670());
        M_CheckFixedHijri(_T("time"), rd);
    }
    
    int32_t UmAlQuraCalendar::M_FromDateTime(System::DateTime time) {
        return (CCFixed::FromDateTime(time) - this->get_AddHijriDate_6bdbae9ac7363670());
    }
    
    System::DateTime UmAlQuraCalendar::M_ToDateTime(int32_t rd) {
        return CCFixed::ToDateTime((rd + this->get_AddHijriDate_6bdbae9ac7363670()));
    }
    
    System::DateTime UmAlQuraCalendar::M_ToDateTime2(int32_t date, int32_t hour, int32_t minute, int32_t second, int32_t milliseconds) {
        return CCFixed::ToDateTime2((date + this->get_AddHijriDate_6bdbae9ac7363670()), hour, minute, second, (double)(milliseconds));
    }
    
    void UmAlQuraCalendar::M_CheckEra(int32_t era) {
        if((era ==  0)) 
        {
            era = 1;
        }
        if((era != 1)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Era value was not valid."));
        }
    }
    
    void UmAlQuraCalendar::M_CheckYE_c830e88539d38d64(int32_t year, int32_t era) {
        M_CheckEra(era);
        Calendar::M_ArgumentInRange(_T("year"), year, 1, 9666);
    }
    
    void UmAlQuraCalendar::M_CheckYME(int32_t year, int32_t month, int32_t era) {
        Calendar::M_CheckYE_c830e88539d38d64(year, era);
        if(((month < 1) || (month > 12))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("month"), _T("Month must be between one and twelve."));
        }
        if((year ==  9666)) 
        {
            int32_t rd = CCHijriCalendar::fixed_from_dmy(1, month, year);
            M_CheckFixedHijri(_T("month"), rd);
        }
    }
    
    void UmAlQuraCalendar::M_CheckYMDE(int32_t year, int32_t month, int32_t day, int32_t era) {
        M_CheckYME(year, month, era);
        Calendar::M_ArgumentInRange(_T("day"), day, 1, UmAlQuraCalendar::GetDaysInMonth_233a2cea4d4c72fe(year, month, 1));
        if((year ==  9666)) 
        {
            int32_t rd = CCHijriCalendar::fixed_from_dmy(day, month, year);
            M_CheckFixedHijri(_T("day"), rd);
        }
    }
    
    System::DateTime UmAlQuraCalendar::AddMonths_a4a4579bf9385278(System::DateTime time, int32_t months) {
        int32_t rd = M_FromDateTime(time);
        int32_t day, month, year;
        CCHijriCalendar::dmy_from_fixed(day, month, year, rd);
        (month = month + months);
        (year = year + CCMath::div_mod(month, month, 12));
        rd = CCHijriCalendar::fixed_from_dmy(day, month, year);
        M_CheckFixedHijri(_T("time"), rd);
        System::DateTime t = M_ToDateTime(rd);
        return t->Add(time->get_TimeOfDay());
    }
    
    System::DateTime UmAlQuraCalendar::AddYears_8bb7ea0ef803063e(System::DateTime time, int32_t years) {
        int32_t rd = M_FromDateTime(time);
        int32_t day, month, year;
        CCHijriCalendar::dmy_from_fixed(day, month, year, rd);
        (year = year + years);
        rd = CCHijriCalendar::fixed_from_dmy(day, month, year);
        M_CheckFixedHijri(_T("time"), rd);
        System::DateTime t = M_ToDateTime(rd);
        return t->Add(time->get_TimeOfDay());
    }
    
    int32_t UmAlQuraCalendar::GetDayOfMonth_7da4e9f8c6f0dece(System::DateTime time) {
        int32_t rd = M_FromDateTime(time);
        M_CheckFixedHijri(_T("time"), rd);
        return CCHijriCalendar::day_from_fixed(rd);
    }
    
    System::DayOfWeek UmAlQuraCalendar::GetDayOfWeek_4c0b69c7bb83520e(System::DateTime time) {
        int32_t rd = M_FromDateTime(time);
        M_CheckFixedHijri(_T("time"), rd);
        return (System::DayOfWeek)(CCFixed::day_of_week(rd));
    }
    
    int32_t UmAlQuraCalendar::GetDayOfYear_1eaa1ac34e65f799(System::DateTime time) {
        int32_t rd = M_FromDateTime(time);
        M_CheckFixedHijri(_T("time"), rd);
        int32_t year = CCHijriCalendar::year_from_fixed(rd);
        int32_t rd1_1 = CCHijriCalendar::fixed_from_dmy(1, 1, year);
        return ((rd - rd1_1) + 1);
    }
    
    int32_t UmAlQuraCalendar::GetDaysInMonth_233a2cea4d4c72fe(int32_t year, int32_t month, int32_t era) {
        M_CheckYME(year, month, era);
        int32_t rd1 = CCHijriCalendar::fixed_from_dmy(1, month, year);
        int32_t rd2 = CCHijriCalendar::fixed_from_dmy(1, (month + 1), year);
        return (rd2 - rd1);
    }
    
    int32_t UmAlQuraCalendar::GetDaysInYear_ae0f8cfee3ff2567(int32_t year, int32_t era) {
        Calendar::M_CheckYE_c830e88539d38d64(year, era);
        int32_t rd1 = CCHijriCalendar::fixed_from_dmy(1, 1, year);
        int32_t rd2 = CCHijriCalendar::fixed_from_dmy(1, 1, (year + 1));
        return (rd2 - rd1);
    }
    
    int32_t UmAlQuraCalendar::GetEra_1d16c3456dce785e(System::DateTime time) {
        M_CheckDateTime(time);
        return 1;
    }
    
    int32_t UmAlQuraCalendar::GetLeapMonth_fb3256a34d84f7ed(int32_t year, int32_t era) {
        return 0;
    }
    
    int32_t UmAlQuraCalendar::GetMonth_66424683b988a96b(System::DateTime time) {
        int32_t rd = M_FromDateTime(time);
        M_CheckFixedHijri(_T("time"), rd);
        return CCHijriCalendar::month_from_fixed(rd);
    }
    
    int32_t UmAlQuraCalendar::GetMonthsInYear_2ae36c9a94a7bffb(int32_t year, int32_t era) {
        Calendar::M_CheckYE_c830e88539d38d64(year, era);
        return 12;
    }
    
    int32_t UmAlQuraCalendar::GetYear_75c1b17aa90af360(System::DateTime time) {
        int32_t rd = M_FromDateTime(time);
        M_CheckFixedHijri(_T("time"), rd);
        return CCHijriCalendar::year_from_fixed(rd);
    }
    
    bool UmAlQuraCalendar::IsLeapDay_7c795c9f36944ade(int32_t year, int32_t month, int32_t day, int32_t era) {
        M_CheckYMDE(year, month, day, era);
        return ((Calendar::IsLeapYear_59be46b16a9b7a45(year) && (month ==  12)) && (day ==  30));
    }
    
    bool UmAlQuraCalendar::IsLeapMonth_85b9917f2bdaeef7(int32_t year, int32_t month, int32_t era) {
        M_CheckYME(year, month, era);
        return false;
    }
    
    bool UmAlQuraCalendar::IsLeapYear_7aad026a1103cfb(int32_t year, int32_t era) {
        Calendar::M_CheckYE_c830e88539d38d64(year, era);
        return CCHijriCalendar::is_leap_year(year);
    }
    
    System::DateTime UmAlQuraCalendar::ToDateTime_82b4ff6780819fcd(int32_t year, int32_t month, int32_t day, int32_t hour, int32_t minute, int32_t second, int32_t millisecond, int32_t era) {
        M_CheckYMDE(year, month, day, era);
        Calendar::M_CheckHMSM(hour, minute, second, millisecond);
        int32_t rd = CCHijriCalendar::fixed_from_dmy(day, month, year);
        return M_ToDateTime2(rd, hour, minute, second, millisecond);
    }
    
    int32_t UmAlQuraCalendar::ToFourDigitYear_cb92a104112b3121(int32_t year) {
        return Calendar::ToFourDigitYear_cb92a104112b3121(year);
    }
    
    cli::array<int32_t>* UmAlQuraCalendar::get_Eras_91b8aa89b8256658() {
        return (new cli::array<int32_t>({UmAlQuraEra}));
    }
    
    int32_t UmAlQuraCalendar::get_TwoDigitYearMax_14e9789b3d89e801() {
        return this->twoDigitYearMax;
    }
    
    int32_t UmAlQuraCalendar::set_TwoDigitYearMax_4852e071586288ab(int32_t value) {
        Calendar::CheckReadOnly();
        Calendar::M_ArgumentInRange(_T("value"), value, 100, this->get_M_MaxYear_b3d9776fced847fe());
        this->twoDigitYearMax = value;
        return get_TwoDigitYearMax_14e9789b3d89e801();
    }
    
    int32_t UmAlQuraCalendar::get_AddHijriDate_6bdbae9ac7363670() {
        return this->M_AddHijriDate;
    }
    
    int32_t UmAlQuraCalendar::set_AddHijriDate_bf418fb7733e37f4(int32_t value) {
        Calendar::CheckReadOnly();
        if(((value < -3) && (value > 3))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("AddHijriDate"), _T("Value should be between -3 and 3."));
        }
        this->M_AddHijriDate = value;
        return get_AddHijriDate_6bdbae9ac7363670();
    }
    
    CalendarAlgorithmType UmAlQuraCalendar::get_AlgorithmType_1e3f8ed99adb8bde() {
        return CalendarAlgorithmType::LunarCalendar;
    }
    
    System::DateTime UmAlQuraCalendar::get_MinSupportedDateTime_63cdcad9cf7fca4e() {
        return Min;
    }
    
    System::DateTime UmAlQuraCalendar::get_MaxSupportedDateTime_7bc53f690ae04821() {
        return Max;
    }
    
}}
namespace System { namespace IO {
    
    
    void BinaryReader::constructor(Stream* input) {
    }
    
    void BinaryReader::constructor(Stream* input, System::Text::Encoding* encoding) {
        if(((input ==  nullptr) || (encoding ==  nullptr))) 
        {
            throw cli::gcnew<System::ArgumentNullException>(Locale::GetText(_T("Input or Encoding is a null reference.")));
        }
        if(!(input->get_CanRead_50a10d564be8aaa2())) 
        {
            throw cli::gcnew<System::ArgumentException>(Locale::GetText(_T("The stream doesn\'t support reading.")));
        }
        this->m_stream = input;
        this->m_encoding = encoding;
        this->decoder = encoding->GetDecoder_380c5e0c575e9cb5();
        this->m_buffer = (new cli::array<unsigned char>(System::Math::Max5(16, encoding->GetMaxByteCount_5bd2cee34757a0d4(1))));
    }
    
    void BinaryReader::Close_7e21193605247e18() {
        Dispose_f27856de433d8cee(true);
        this->m_disposed = true;
    }
    
    void BinaryReader::Dispose_f27856de433d8cee(bool disposing) {
        if(((disposing && (this->m_stream != nullptr)) && true)) 
        {
            this->m_stream->Close_59c62ed53ef2a481();
        }
        this->m_disposed = true;
        this->m_buffer = nullptr;
        this->m_encoding = nullptr;
        this->m_stream = nullptr;
        this->charBuffer = nullptr;
    }
    
    void BinaryReader::Dispose2() {
        Dispose_f27856de433d8cee(true);
    }
    
    void BinaryReader::FillBuffer_c9f34917233a7bf0(int32_t numBytes) {
        if((numBytes > this->m_buffer->get_Length())) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("numBytes"));
        }
        if(this->m_disposed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("BinaryReader"), _T("Cannot read from a closed BinaryReader."));
        }
        if((this->m_stream ==  nullptr)) 
        {
            throw cli::gcnew<IOException>(_T("Stream is invalid"));
        }
        int32_t pos = 0;
        while((pos < numBytes)) {
            int32_t n = this->m_stream->Read_c0d6dde3943b413e(this->m_buffer, pos, (numBytes - pos));
            if((n ==  0)) 
            {
                throw cli::gcnew<EndOfStreamException>();
            }
            (pos = pos + n);
        }
    }
    
    int32_t BinaryReader::PeekChar_bba394f88b1679ad() {
        if((this->m_stream ==  nullptr)) 
        {
            if(this->m_disposed) 
            {
                throw cli::gcnew<System::ObjectDisposedException>(_T("BinaryReader"), _T("Cannot read from a closed BinaryReader."));
            }
            throw cli::gcnew<IOException>(_T("Stream is invalid"));
        }
        if(!(this->m_stream->get_CanSeek_8c8861ce02c6bdeb())) 
        {
            return -1;
        }
        cli::array<char16_t> *result = (new cli::array<char16_t>(1));
        int32_t bcount;
        int32_t ccount = ReadCharBytes(result, 0, 1, bcount);
        (this->m_stream->set_Position_cfe1def757785ad(this->m_stream->get_Position_5e75d5c458401f13() - (int64_t)(bcount)));
        if((ccount ==  0)) 
        {
            return -1;
        }
        return (int32_t)(result->at(0));
    }
    
    int32_t BinaryReader::Read_b648b07e7bda1c64() {
        if((this->charBuffer ==  nullptr)) 
        {
            this->charBuffer = (new cli::array<char16_t>(128));
        }
        int32_t count = Read_e707a7910ba322cc(this->charBuffer, 0, 1);
        if((count ==  0)) 
        {
            return -1;
        }
        return (int32_t)(this->charBuffer->at(0));
    }
    
    int32_t BinaryReader::Read_e56820a6e9e603d8(cli::array<unsigned char>* buffer, int32_t index, int32_t count) {
        if((this->m_stream ==  nullptr)) 
        {
            if(this->m_disposed) 
            {
                throw cli::gcnew<System::ObjectDisposedException>(_T("BinaryReader"), _T("Cannot read from a closed BinaryReader."));
            }
            throw cli::gcnew<IOException>(_T("Stream is invalid"));
        }
        if((buffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("buffer is null"));
        }
        if((index < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("index is less than 0"));
        }
        if((count < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("count is less than 0"));
        }
        if(((buffer->get_Length() - index) < count)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("buffer is too small"));
        }
        int32_t bytes_read = this->m_stream->Read_c0d6dde3943b413e(buffer, index, count);
        return bytes_read;
    }
    
    int32_t BinaryReader::Read_e707a7910ba322cc(cli::array<char16_t>* buffer, int32_t index, int32_t count) {
        if((this->m_stream ==  nullptr)) 
        {
            if(this->m_disposed) 
            {
                throw cli::gcnew<System::ObjectDisposedException>(_T("BinaryReader"), _T("Cannot read from a closed BinaryReader."));
            }
            throw cli::gcnew<IOException>(_T("Stream is invalid"));
        }
        if((buffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("buffer is null"));
        }
        if((index < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("index is less than 0"));
        }
        if((count < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("count is less than 0"));
        }
        if(((buffer->get_Length() - index) < count)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("buffer is too small"));
        }
        int32_t bytes_read;
        return ReadCharBytes(buffer, index, count, bytes_read);
    }
    
    int32_t BinaryReader::ReadCharBytes(cli::array<char16_t>* buffer, int32_t index, int32_t count, int32_t bytes_read) {
        int32_t chars_read = 0;
        bytes_read = 0;
        while((chars_read < count)) {
            int32_t pos = 0;
            while(true) {
                CheckBuffer((pos + 1));
                int32_t read_byte = this->m_stream->ReadByte_61a294e42318f99();
                if((read_byte ==  -1)) 
                {
                    return chars_read;
                }
                this->m_buffer->at(pos++) = (unsigned char)read_byte;
                bytes_read++;
                int32_t n = this->m_encoding->GetChars_d7b47e17fd0a13f2(this->m_buffer, 0, pos, buffer, (index + chars_read));
                if((n > 0)) 
                {
                    break;
                }
            }
            chars_read++;
        }
        return chars_read;
    }
    
    int32_t BinaryReader::Read7BitEncodedInt() {
        int32_t ret = 0;
        int32_t shift = 0;
        int32_t len;
        unsigned char b;
        for(len = 0; (len < 5); ++len){
            b = ReadByte_a8e935915607659b();
            ret = (ret | (((int32_t)(b) & 127) << (shift & 31)));
            (shift = shift + 7);
            if((((int32_t)(b) & 128) ==  0)) 
            {
                break;
            }
        }
        if((len < 5)) 
        {
            return ret;
        }
         else 
        {
            throw cli::gcnew<System::FormatException>(_T("Too many bytes in what should have been a 7 bit encoded Int32."));
        }
    }
    
    bool BinaryReader::ReadBoolean_ffac632a26c093b3() {
        return ((int32_t)(ReadByte_a8e935915607659b()) != 0);
    }
    
    unsigned char BinaryReader::ReadByte_a8e935915607659b() {
        if((this->m_stream ==  nullptr)) 
        {
            if(this->m_disposed) 
            {
                throw cli::gcnew<System::ObjectDisposedException>(_T("BinaryReader"), _T("Cannot read from a closed BinaryReader."));
            }
            throw cli::gcnew<IOException>(_T("Stream is invalid"));
        }
        int32_t val = this->m_stream->ReadByte_61a294e42318f99();
        if((val != -1)) 
        {
            return (unsigned char)val;
        }
        throw cli::gcnew<EndOfStreamException>();
    }
    
    cli::array<unsigned char>* BinaryReader::ReadBytes_ff8723a8077b7798(int32_t count) {
        if((this->m_stream ==  nullptr)) 
        {
            if(this->m_disposed) 
            {
                throw cli::gcnew<System::ObjectDisposedException>(_T("BinaryReader"), _T("Cannot read from a closed BinaryReader."));
            }
            throw cli::gcnew<IOException>(_T("Stream is invalid"));
        }
        if((count < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("count is less than 0"));
        }
        cli::array<unsigned char> *buf = (new cli::array<unsigned char>(count));
        int32_t pos = 0;
        while((pos < count)) {
            int32_t n = this->m_stream->Read_c0d6dde3943b413e(buf, pos, (count - pos));
            if((n ==  0)) 
            {
                break;
            }
            (pos = pos + n);
        }
        if((pos != count)) 
        {
            cli::array<unsigned char> *new_buffer = (new cli::array<unsigned char>(pos));
            System::Buffer::BlockCopyInternal(buf, 0, new_buffer, 0, pos);
            return new_buffer;
        }
        return buf;
    }
    
    char16_t BinaryReader::ReadChar_d9df7e93c29686d() {
        int32_t ch = Read_b648b07e7bda1c64();
        if((ch ==  -1)) 
        {
            throw cli::gcnew<EndOfStreamException>();
        }
        return (char16_t)ch;
    }
    
    cli::array<char16_t>* BinaryReader::ReadChars_e251759c1ffa23ff(int32_t count) {
        if((count < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("count is less than 0"));
        }
        if((count ==  0)) 
        {
            return (new cli::array<char16_t>(0));
        }
        cli::array<char16_t> *full = (new cli::array<char16_t>(count));
        int32_t chars = Read_e707a7910ba322cc(full, 0, count);
        if((chars ==  0)) 
        {
            throw cli::gcnew<EndOfStreamException>();
        }
         else 
        {
            if((chars != full->get_Length())) 
            {
                cli::array<char16_t> *ret = (new cli::array<char16_t>(chars));
                System::Array::Copy2(full, 0, ret, 0, chars);
                return ret;
            }
             else 
            {
                return full;
            }
        }
    }
    
    System::Decimal BinaryReader::ReadDecimal_289b04b837613d00() {
        FillBuffer_c9f34917233a7bf0(16);
        System::Decimal ret;
        unsigned char *ret_ptr = (unsigned char*)(&(ret));
        if(System::BitConverter::IsLittleEndian) 
        {
            for(int32_t i = 0; (i < 16); i++){
                if((i < 4)) 
                {
                    (*(ret_ptr + (i + 8))) = this->m_buffer->at(i);
                }
                 else 
                {
                    if((i < 8)) 
                    {
                        (*(ret_ptr + (i + 8))) = this->m_buffer->at(i);
                    }
                     else 
                    {
                        if((i < 12)) 
                        {
                            (*(ret_ptr + (i - 4))) = this->m_buffer->at(i);
                        }
                         else 
                        {
                            if((i < 16)) 
                            {
                                (*(ret_ptr + (i - 12))) = this->m_buffer->at(i);
                            }
                        }
                    }
                }
            }
        }
         else 
        {
            for(int32_t i = 0; (i < 16); i++){
                if((i < 4)) 
                {
                    (*(ret_ptr + (11 - i))) = this->m_buffer->at(i);
                }
                 else 
                {
                    if((i < 8)) 
                    {
                        (*(ret_ptr + (19 - i))) = this->m_buffer->at(i);
                    }
                     else 
                    {
                        if((i < 12)) 
                        {
                            (*(ret_ptr + (15 - i))) = this->m_buffer->at(i);
                        }
                         else 
                        {
                            if((i < 16)) 
                            {
                                (*(ret_ptr + (15 - i))) = this->m_buffer->at(i);
                            }
                        }
                    }
                }
            }
        }
        return ret;
    }
    
    double BinaryReader::ReadDouble_c4cf5262e4ca9658() {
        FillBuffer_c9f34917233a7bf0(8);
        return Mono::Security::BitConverterLE::ToDouble(this->m_buffer, 0);
    }
    
    int16_t BinaryReader::ReadInt16_cc677a86798a4911() {
        FillBuffer_c9f34917233a7bf0(2);
        return (int16_t)((int32_t)(this->m_buffer->at(0)) | ((int32_t)(this->m_buffer->at(1)) << 8));
    }
    
    int32_t BinaryReader::ReadInt32_e79bbed3af40f25f() {
        FillBuffer_c9f34917233a7bf0(4);
        return ((((int32_t)(this->m_buffer->at(0)) | ((int32_t)(this->m_buffer->at(1)) << 8)) | ((int32_t)(this->m_buffer->at(2)) << 16)) | ((int32_t)(this->m_buffer->at(3)) << 24));
    }
    
    int64_t BinaryReader::ReadInt64_324b86c0d5995c31() {
        FillBuffer_c9f34917233a7bf0(8);
        uint32_t ret_low = (uint32_t)((((int32_t)(this->m_buffer->at(0)) | ((int32_t)(this->m_buffer->at(1)) << 8)) | ((int32_t)(this->m_buffer->at(2)) << 16)) | ((int32_t)(this->m_buffer->at(3)) << 24));
        uint32_t ret_high = (uint32_t)((((int32_t)(this->m_buffer->at(4)) | ((int32_t)(this->m_buffer->at(5)) << 8)) | ((int32_t)(this->m_buffer->at(6)) << 16)) | ((int32_t)(this->m_buffer->at(7)) << 24));
        return (int64_t)(((uint64_t)(ret_high) << 32) | (uint64_t)(ret_low));
    }
    
    signed char BinaryReader::ReadSByte_de4608c911742c46() {
        return (signed char)ReadByte_a8e935915607659b();
    }
    
    System::String* BinaryReader::ReadString_7b59e815ae441879() {
        int32_t len = Read7BitEncodedInt();
        if((len < 0)) 
        {
            throw cli::gcnew<IOException>(_T("Invalid binary file (string len < 0)"));
        }
        if((len ==  0)) 
        {
            return System::String::Empty;
        }
        if((this->charByteBuffer ==  nullptr)) 
        {
            this->charBuffer = (new cli::array<char16_t>(this->m_encoding->GetMaxByteCount_5bd2cee34757a0d4(128)));
            this->charByteBuffer = (new cli::array<unsigned char>(128));
        }
        System::Text::StringBuilder *sb = nullptr;
        do {
            int32_t readLen = System::Math::Min5(128, len);
            int32_t n = this->m_stream->Read_c0d6dde3943b413e(this->charByteBuffer, 0, readLen);
            if((n ==  0)) 
            {
                throw cli::gcnew<EndOfStreamException>();
            }
            int32_t cch = this->decoder->GetChars_beecc497fe0b7526(this->charByteBuffer, 0, n, this->charBuffer, 0);
            if(((sb ==  nullptr) && (readLen ==  len))) 
            {
                return cli::gcnew<System::String>(this->charBuffer, 0, cch);
            }
            if((sb ==  nullptr)) 
            {
                sb = cli::gcnew<System::Text::StringBuilder>(len);
            }
            sb->Append18(this->charBuffer, 0, cch);
            (len = len - readLen);
        }
        while((len > 0));
        return sb->ToString_1636a0751cb9ac11();
    }
    
    float BinaryReader::ReadSingle_4a83108898ca41d7() {
        FillBuffer_c9f34917233a7bf0(4);
        return Mono::Security::BitConverterLE::ToSingle(this->m_buffer, 0);
    }
    
    uint16_t BinaryReader::ReadUInt16_12c320b7592221bf() {
        FillBuffer_c9f34917233a7bf0(2);
        return (uint16_t)((int32_t)(this->m_buffer->at(0)) | ((int32_t)(this->m_buffer->at(1)) << 8));
    }
    
    uint32_t BinaryReader::ReadUInt32_3acc4b6c3fc21142() {
        FillBuffer_c9f34917233a7bf0(4);
        return (uint32_t)((((int32_t)(this->m_buffer->at(0)) | ((int32_t)(this->m_buffer->at(1)) << 8)) | ((int32_t)(this->m_buffer->at(2)) << 16)) | ((int32_t)(this->m_buffer->at(3)) << 24));
    }
    
    uint64_t BinaryReader::ReadUInt64_af37b8afdb6259c1() {
        FillBuffer_c9f34917233a7bf0(8);
        uint32_t ret_low = (uint32_t)((((int32_t)(this->m_buffer->at(0)) | ((int32_t)(this->m_buffer->at(1)) << 8)) | ((int32_t)(this->m_buffer->at(2)) << 16)) | ((int32_t)(this->m_buffer->at(3)) << 24));
        uint32_t ret_high = (uint32_t)((((int32_t)(this->m_buffer->at(4)) | ((int32_t)(this->m_buffer->at(5)) << 8)) | ((int32_t)(this->m_buffer->at(6)) << 16)) | ((int32_t)(this->m_buffer->at(7)) << 24));
        return (((uint64_t)(ret_high) << 32) | (uint64_t)(ret_low));
    }
    
    void BinaryReader::CheckBuffer(int32_t length) {
        if((this->m_buffer->get_Length() <= length)) 
        {
            cli::array<unsigned char> *new_buffer = (new cli::array<unsigned char>(length));
            System::Buffer::BlockCopyInternal(this->m_buffer, 0, new_buffer, 0, this->m_buffer->get_Length());
            this->m_buffer = new_buffer;
        }
    }
    
    Stream* BinaryReader::get_BaseStream_f687c258329b093a() {
        return this->m_stream;
    }
    
}}
namespace System { namespace IO {
    
    BinaryWriter*  BinaryWriter::Null;
    
    BinaryWriter::BinaryWriter()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void BinaryWriter::constructor() {
    }
    
    void BinaryWriter::constructor(Stream* output) {
    }
    
    void BinaryWriter::constructor(Stream* output, System::Text::Encoding* encoding) {
        if((output ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("output"));
        }
        if((encoding ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("encoding"));
        }
        if(!(output->get_CanWrite_c8955eadfc77124c())) 
        {
            throw cli::gcnew<System::ArgumentException>(Locale::GetText(_T("Stream does not support writing or already closed.")));
        }
        this->OutStream = output;
        this->m_encoding = encoding;
        this->buffer = (new cli::array<unsigned char>(16));
    }
    
    void BinaryWriter::static_constructor() {
    }
    
    void BinaryWriter::Close_333af8c4ea41df43() {
        Dispose_2ccdb354743e31a8(true);
    }
    
    void BinaryWriter::Dispose() {
        Dispose_2ccdb354743e31a8(true);
    }
    
    void BinaryWriter::Dispose_2ccdb354743e31a8(bool disposing) {
        if(((disposing && (this->OutStream != nullptr)) && true)) 
        {
            this->OutStream->Close_59c62ed53ef2a481();
        }
        this->buffer = nullptr;
        this->m_encoding = nullptr;
        this->disposed = true;
    }
    
    void BinaryWriter::Flush_3f4412918277f178() {
        this->OutStream->Flush_132821400030c993();
    }
    
    int64_t BinaryWriter::Seek_53650fbf52a7a3bf(int32_t offset, SeekOrigin origin) {
        return this->OutStream->Seek_df5b3eadfe9adf31((int64_t)(offset), origin);
    }
    
    void BinaryWriter::Write_664daa13c7b699d4(bool value) {
        if(this->disposed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("BinaryWriter"), _T("Cannot write to a closed BinaryWriter"));
        }
        this->buffer->at(0) = (unsigned char)value ? 1 : 0;
        this->OutStream->Write_1f8a1dbe71b0eb89(this->buffer, 0, 1);
    }
    
    void BinaryWriter::Write_bc6e6f6f19ff3ad3(unsigned char value) {
        if(this->disposed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("BinaryWriter"), _T("Cannot write to a closed BinaryWriter"));
        }
        this->OutStream->WriteByte_4404d6329af3b6d5(value);
    }
    
    void BinaryWriter::Write_748d33f0d08b528e(cli::array<unsigned char>* buffer) {
        if(this->disposed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("BinaryWriter"), _T("Cannot write to a closed BinaryWriter"));
        }
        if((buffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("buffer"));
        }
        this->OutStream->Write_1f8a1dbe71b0eb89(buffer, 0, buffer->get_Length());
    }
    
    void BinaryWriter::Write_67008f3e2ece1dc3(cli::array<unsigned char>* buffer, int32_t index, int32_t count) {
        if(this->disposed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("BinaryWriter"), _T("Cannot write to a closed BinaryWriter"));
        }
        if((buffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("buffer"));
        }
        this->OutStream->Write_1f8a1dbe71b0eb89(buffer, index, count);
    }
    
    void BinaryWriter::Write_8d30dac55ff57ff8(char16_t ch) {
        if(this->disposed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("BinaryWriter"), _T("Cannot write to a closed BinaryWriter"));
        }
        cli::array<char16_t> *dec = (new cli::array<char16_t>(1));
        dec->at(0) = ch;
        cli::array<unsigned char> *enc = this->m_encoding->GetBytes_d1513e6a9072eb1(dec, 0, 1);
        this->OutStream->Write_1f8a1dbe71b0eb89(enc, 0, enc->get_Length());
    }
    
    void BinaryWriter::Write_a7ab51ccd6658347(cli::array<char16_t>* chars) {
        if(this->disposed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("BinaryWriter"), _T("Cannot write to a closed BinaryWriter"));
        }
        if((chars ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("chars"));
        }
        cli::array<unsigned char> *enc = this->m_encoding->GetBytes_d1513e6a9072eb1(chars, 0, chars->get_Length());
        this->OutStream->Write_1f8a1dbe71b0eb89(enc, 0, enc->get_Length());
    }
    
    void BinaryWriter::Write_5e9f6092227a95ed(cli::array<char16_t>* chars, int32_t index, int32_t count) {
        if(this->disposed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("BinaryWriter"), _T("Cannot write to a closed BinaryWriter"));
        }
        if((chars ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("chars"));
        }
        cli::array<unsigned char> *enc = this->m_encoding->GetBytes_d1513e6a9072eb1(chars, index, count);
        this->OutStream->Write_1f8a1dbe71b0eb89(enc, 0, enc->get_Length());
    }
    
    void BinaryWriter::Write_8ba35d7f9fe8fd4b(System::Decimal value) {
        if(this->disposed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("BinaryWriter"), _T("Cannot write to a closed BinaryWriter"));
        }
        unsigned char *value_ptr = (unsigned char*)(&(value));
        if(System::BitConverter::IsLittleEndian) 
        {
            for(int32_t i = 0; (i < 16); i++){
                if((i < 4)) 
                {
                    this->buffer->at((i + 12)) = (*(value_ptr + i));
                }
                 else 
                {
                    if((i < 8)) 
                    {
                        this->buffer->at((i + 4)) = (*(value_ptr + i));
                    }
                     else 
                    {
                        if((i < 12)) 
                        {
                            this->buffer->at((i - 8)) = (*(value_ptr + i));
                        }
                         else 
                        {
                            this->buffer->at((i - 8)) = (*(value_ptr + i));
                        }
                    }
                }
            }
        }
         else 
        {
            for(int32_t i = 0; (i < 16); i++){
                if((i < 4)) 
                {
                    this->buffer->at((15 - i)) = (*(value_ptr + i));
                }
                 else 
                {
                    if((i < 8)) 
                    {
                        this->buffer->at((15 - i)) = (*(value_ptr + i));
                    }
                     else 
                    {
                        if((i < 12)) 
                        {
                            this->buffer->at((11 - i)) = (*(value_ptr + i));
                        }
                         else 
                        {
                            this->buffer->at((19 - i)) = (*(value_ptr + i));
                        }
                    }
                }
            }
        }
        this->OutStream->Write_1f8a1dbe71b0eb89(this->buffer, 0, 16);
    }
    
    void BinaryWriter::Write_f38f5e7709f76e33(double value) {
        if(this->disposed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("BinaryWriter"), _T("Cannot write to a closed BinaryWriter"));
        }
        this->OutStream->Write_1f8a1dbe71b0eb89(Mono::Security::BitConverterLE::GetBytes10(value), 0, 8);
    }
    
    void BinaryWriter::Write_263157ba3ce9bc51(int16_t value) {
        if(this->disposed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("BinaryWriter"), _T("Cannot write to a closed BinaryWriter"));
        }
        this->buffer->at(0) = (unsigned char)value;
        this->buffer->at(1) = (unsigned char)((int32_t)(value) >> 8);
        this->OutStream->Write_1f8a1dbe71b0eb89(this->buffer, 0, 2);
    }
    
    void BinaryWriter::Write_6382fee822de735b(int32_t value) {
        if(this->disposed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("BinaryWriter"), _T("Cannot write to a closed BinaryWriter"));
        }
        this->buffer->at(0) = (unsigned char)value;
        this->buffer->at(1) = (unsigned char)(value >> 8);
        this->buffer->at(2) = (unsigned char)(value >> 16);
        this->buffer->at(3) = (unsigned char)(value >> 24);
        this->OutStream->Write_1f8a1dbe71b0eb89(this->buffer, 0, 4);
    }
    
    void BinaryWriter::Write_f3b14072d1fca470(int64_t value) {
        if(this->disposed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("BinaryWriter"), _T("Cannot write to a closed BinaryWriter"));
        }
        for(int32_t i = 0, sh = 0; (i < 8); i++, (sh = sh + 8)) {
            this->buffer->at(i) = (unsigned char)(value >> (sh & 63));
        }
        this->OutStream->Write_1f8a1dbe71b0eb89(this->buffer, 0, 8);
    }
    
    void BinaryWriter::Write_9eb51dc30d6ae1a5(signed char value) {
        if(this->disposed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("BinaryWriter"), _T("Cannot write to a closed BinaryWriter"));
        }
        this->buffer->at(0) = (unsigned char)value;
        this->OutStream->Write_1f8a1dbe71b0eb89(this->buffer, 0, 1);
    }
    
    void BinaryWriter::Write_6581fbda559dbe80(float value) {
        if(this->disposed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("BinaryWriter"), _T("Cannot write to a closed BinaryWriter"));
        }
        this->OutStream->Write_1f8a1dbe71b0eb89(Mono::Security::BitConverterLE::GetBytes9(value), 0, 4);
    }
    
    void BinaryWriter::Write_6de303e680f3eff5(System::String* value) {
        if(this->disposed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("BinaryWriter"), _T("Cannot write to a closed BinaryWriter"));
        }
        int32_t len = this->m_encoding->GetByteCount_d98cd1485dc2ee98(value);
        Write7BitEncodedInt(len);
        if((this->stringBuffer ==  nullptr)) 
        {
            this->stringBuffer = (new cli::array<unsigned char>(512));
            this->maxCharsPerRound = (512 / this->m_encoding->GetMaxByteCount_5bd2cee34757a0d4(1));
        }
        int32_t chpos = 0;
        int32_t chrem = value->get_Length();
        while((chrem > 0)) {
            int32_t cch = (chrem > this->maxCharsPerRound) ? this->maxCharsPerRound : chrem;
            int32_t blen = this->m_encoding->GetBytes_3384066dd8b91ed8(value, chpos, cch, this->stringBuffer, 0);
            this->OutStream->Write_1f8a1dbe71b0eb89(this->stringBuffer, 0, blen);
            (chpos = chpos + cch);
            (chrem = chrem - cch);
        }
    }
    
    void BinaryWriter::Write_7065176233f87453(uint16_t value) {
        if(this->disposed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("BinaryWriter"), _T("Cannot write to a closed BinaryWriter"));
        }
        this->buffer->at(0) = (unsigned char)value;
        this->buffer->at(1) = (unsigned char)((int32_t)(value) >> 8);
        this->OutStream->Write_1f8a1dbe71b0eb89(this->buffer, 0, 2);
    }
    
    void BinaryWriter::Write_805c393976ef76e5(uint32_t value) {
        if(this->disposed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("BinaryWriter"), _T("Cannot write to a closed BinaryWriter"));
        }
        this->buffer->at(0) = (unsigned char)value;
        this->buffer->at(1) = (unsigned char)(value >> 8);
        this->buffer->at(2) = (unsigned char)(value >> 16);
        this->buffer->at(3) = (unsigned char)(value >> 24);
        this->OutStream->Write_1f8a1dbe71b0eb89(this->buffer, 0, 4);
    }
    
    void BinaryWriter::Write_694a3defde87112b(uint64_t value) {
        if(this->disposed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("BinaryWriter"), _T("Cannot write to a closed BinaryWriter"));
        }
        for(int32_t i = 0, sh = 0; (i < 8); i++, (sh = sh + 8)) {
            this->buffer->at(i) = (unsigned char)(value >> (sh & 63));
        }
        this->OutStream->Write_1f8a1dbe71b0eb89(this->buffer, 0, 8);
    }
    
    void BinaryWriter::Write7BitEncodedInt(int32_t value) {
        do {
            int32_t high = ((value >> 7) & 33554431);
            unsigned char b = (unsigned char)(value & 127);
            if((high != 0)) 
            {
                b = (unsigned char)((int32_t)(b) | 128);
            }
            Write_bc6e6f6f19ff3ad3(b);
            value = high;
        }
        while((value != 0));
    }
    
    Stream* BinaryWriter::get_BaseStream_6d7b07c4266897dc() {
        Flush_3f4412918277f178();
        return this->OutStream;
    }
    
}}
namespace System { namespace IO {
    
    
    void BufferedStream::constructor(Stream* stream) {
    }
    
    void BufferedStream::constructor(Stream* stream, int32_t bufferSize) {
        if((stream ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("stream"));
        }
        if((bufferSize <= 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("bufferSize"), _T("<= 0"));
        }
        if((!(stream->get_CanRead_50a10d564be8aaa2()) && !(stream->get_CanWrite_c8955eadfc77124c()))) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(Locale::GetText(_T("Cannot access a closed Stream.")));
        }
        this->m_stream = stream;
        this->m_buffer = (new cli::array<unsigned char>(bufferSize));
    }
    
    void BufferedStream::Dispose_b215be19126499b0(bool disposing) {
        if(this->disposed) 
        {
            return;
        }
        if((this->m_buffer != nullptr)) 
        {
            BufferedStream::Flush_132821400030c993();
        }
        this->m_stream->Close_59c62ed53ef2a481();
        this->m_buffer = nullptr;
        this->disposed = true;
    }
    
    void BufferedStream::Flush_132821400030c993() {
        CheckObjectDisposedException();
        if(this->m_buffer_reading) 
        {
            if(this->get_CanSeek_8c8861ce02c6bdeb()) 
            {
                this->m_stream->set_Position_cfe1def757785ad(this->get_Position_5e75d5c458401f13());
            }
        }
         else 
        {
            if((this->m_buffer_pos > 0)) 
            {
                this->m_stream->Write_1f8a1dbe71b0eb89(this->m_buffer, 0, this->m_buffer_pos);
            }
        }
        this->m_buffer_read_ahead = 0;
        this->m_buffer_pos = 0;
    }
    
    int64_t BufferedStream::Seek_df5b3eadfe9adf31(int64_t offset, SeekOrigin origin) {
        CheckObjectDisposedException();
        if(!(this->get_CanSeek_8c8861ce02c6bdeb())) 
        {
            throw cli::gcnew<System::NotSupportedException>(Locale::GetText(_T("Non seekable stream.")));
        }
        BufferedStream::Flush_132821400030c993();
        return this->m_stream->Seek_df5b3eadfe9adf31(offset, origin);
    }
    
    void BufferedStream::SetLength_18d421048f3d4df5(int64_t value) {
        CheckObjectDisposedException();
        if((value < 0L)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("value must be positive"));
        }
        if((!(this->m_stream->get_CanWrite_c8955eadfc77124c()) && !(this->m_stream->get_CanSeek_8c8861ce02c6bdeb()))) 
        {
            throw cli::gcnew<System::NotSupportedException>(_T("the stream cannot seek nor write."));
        }
        if(((this->m_stream ==  nullptr) || (!(this->m_stream->get_CanRead_50a10d564be8aaa2()) && !(this->m_stream->get_CanWrite_c8955eadfc77124c())))) 
        {
            throw cli::gcnew<IOException>(_T("the stream is not open"));
        }
        this->m_stream->SetLength_18d421048f3d4df5(value);
        if((this->get_Position_5e75d5c458401f13() > value)) 
        {
            this->set_Position_cfe1def757785ad(value);
        }
    }
    
    int32_t BufferedStream::ReadByte_61a294e42318f99() {
        CheckObjectDisposedException();
        if(!(this->m_stream->get_CanRead_50a10d564be8aaa2())) 
        {
            throw cli::gcnew<System::NotSupportedException>(Locale::GetText(_T("Cannot read from stream")));
        }
        if(!(this->m_buffer_reading)) 
        {
            BufferedStream::Flush_132821400030c993();
            this->m_buffer_reading = true;
        }
        if((1 <= (this->m_buffer_read_ahead - this->m_buffer_pos))) 
        {
            return (int32_t)(this->m_buffer->at(this->m_buffer_pos++));
        }
         else 
        {
            if((this->m_buffer_pos >= this->m_buffer_read_ahead)) 
            {
                this->m_buffer_pos = 0;
                this->m_buffer_read_ahead = 0;
            }
            this->m_buffer_read_ahead = this->m_stream->Read_c0d6dde3943b413e(this->m_buffer, 0, this->m_buffer->get_Length());
            if((1 <= this->m_buffer_read_ahead)) 
            {
                return (int32_t)(this->m_buffer->at(this->m_buffer_pos++));
            }
             else 
            {
                return -1;
            }
        }
    }
    
    void BufferedStream::WriteByte_4404d6329af3b6d5(unsigned char value) {
        CheckObjectDisposedException();
        if(!(this->m_stream->get_CanWrite_c8955eadfc77124c())) 
        {
            throw cli::gcnew<System::NotSupportedException>(Locale::GetText(_T("Cannot write to stream")));
        }
        if(this->m_buffer_reading) 
        {
            BufferedStream::Flush_132821400030c993();
            this->m_buffer_reading = false;
        }
         else 
        {
            if((this->m_buffer_pos >= (this->m_buffer->get_Length() - 1))) 
            {
                BufferedStream::Flush_132821400030c993();
            }
        }
        this->m_buffer->at(this->m_buffer_pos++) = value;
    }
    
    int32_t BufferedStream::Read_c0d6dde3943b413e(cli::array<unsigned char>* array, int32_t offset, int32_t count) {
        if((array ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("array"));
        }
        CheckObjectDisposedException();
        if(!(this->m_stream->get_CanRead_50a10d564be8aaa2())) 
        {
            throw cli::gcnew<System::NotSupportedException>(Locale::GetText(_T("Cannot read from stream")));
        }
        if((offset < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("offset"), _T("< 0"));
        }
        if((count < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("count"), _T("< 0"));
        }
        if(((array->get_Length() - offset) < count)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("array.Length - offset < count"));
        }
        if(!(this->m_buffer_reading)) 
        {
            BufferedStream::Flush_132821400030c993();
            this->m_buffer_reading = true;
        }
        if((count <= (this->m_buffer_read_ahead - this->m_buffer_pos))) 
        {
            System::Buffer::BlockCopyInternal(this->m_buffer, this->m_buffer_pos, array, offset, count);
            (this->m_buffer_pos = this->m_buffer_pos + count);
            if((this->m_buffer_pos ==  this->m_buffer_read_ahead)) 
            {
                this->m_buffer_pos = 0;
                this->m_buffer_read_ahead = 0;
            }
            return count;
        }
        int32_t ret = (this->m_buffer_read_ahead - this->m_buffer_pos);
        System::Buffer::BlockCopyInternal(this->m_buffer, this->m_buffer_pos, array, offset, ret);
        this->m_buffer_pos = 0;
        this->m_buffer_read_ahead = 0;
        (offset = offset + ret);
        (count = count - ret);
        if((count >= this->m_buffer->get_Length())) 
        {
            (ret = ret + this->m_stream->Read_c0d6dde3943b413e(array, offset, count));
        }
         else 
        {
            this->m_buffer_read_ahead = this->m_stream->Read_c0d6dde3943b413e(this->m_buffer, 0, this->m_buffer->get_Length());
            if((count < this->m_buffer_read_ahead)) 
            {
                System::Buffer::BlockCopyInternal(this->m_buffer, 0, array, offset, count);
                this->m_buffer_pos = count;
                (ret = ret + count);
            }
             else 
            {
                System::Buffer::BlockCopyInternal(this->m_buffer, 0, array, offset, this->m_buffer_read_ahead);
                (ret = ret + this->m_buffer_read_ahead);
                this->m_buffer_read_ahead = 0;
            }
        }
        return ret;
    }
    
    void BufferedStream::Write_1f8a1dbe71b0eb89(cli::array<unsigned char>* array, int32_t offset, int32_t count) {
        if((array ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("array"));
        }
        CheckObjectDisposedException();
        if(!(this->m_stream->get_CanWrite_c8955eadfc77124c())) 
        {
            throw cli::gcnew<System::NotSupportedException>(Locale::GetText(_T("Cannot write to stream")));
        }
        if((offset < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("offset"), _T("< 0"));
        }
        if((count < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("count"), _T("< 0"));
        }
        if(((array->get_Length() - offset) < count)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("array.Length - offset < count"));
        }
        if(this->m_buffer_reading) 
        {
            BufferedStream::Flush_132821400030c993();
            this->m_buffer_reading = false;
        }
        if((this->m_buffer_pos >= (this->m_buffer->get_Length() - count))) 
        {
            BufferedStream::Flush_132821400030c993();
            this->m_stream->Write_1f8a1dbe71b0eb89(array, offset, count);
        }
         else 
        {
            System::Buffer::BlockCopyInternal(array, offset, this->m_buffer, this->m_buffer_pos, count);
            (this->m_buffer_pos = this->m_buffer_pos + count);
        }
    }
    
    void BufferedStream::CheckObjectDisposedException() {
        if(this->disposed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("BufferedStream"), Locale::GetText(_T("Stream is closed")));
        }
    }
    
    bool BufferedStream::get_CanRead_50a10d564be8aaa2() {
        return this->m_stream->get_CanRead_50a10d564be8aaa2();
    }
    
    bool BufferedStream::get_CanWrite_c8955eadfc77124c() {
        return this->m_stream->get_CanWrite_c8955eadfc77124c();
    }
    
    bool BufferedStream::get_CanSeek_8c8861ce02c6bdeb() {
        return this->m_stream->get_CanSeek_8c8861ce02c6bdeb();
    }
    
    int64_t BufferedStream::get_Length_ddb8b0d061db5350() {
        BufferedStream::Flush_132821400030c993();
        return this->m_stream->get_Length_ddb8b0d061db5350();
    }
    
    int64_t BufferedStream::get_Position_5e75d5c458401f13() {
        CheckObjectDisposedException();
        return ((this->m_stream->get_Position_5e75d5c458401f13() - (int64_t)(this->m_buffer_read_ahead)) + (int64_t)(this->m_buffer_pos));
    }
    
    int64_t BufferedStream::set_Position_cfe1def757785ad(int64_t value) {
        if((((value < this->get_Position_5e75d5c458401f13()) && ((this->get_Position_5e75d5c458401f13() - value) <= (int64_t)(this->m_buffer_pos))) && this->m_buffer_reading)) 
        {
            (this->m_buffer_pos = this->m_buffer_pos - (int32_t)(this->get_Position_5e75d5c458401f13() - value));
        }
         else 
        {
            if((((value > this->get_Position_5e75d5c458401f13()) && ((value - this->get_Position_5e75d5c458401f13()) < (int64_t)((this->m_buffer_read_ahead - this->m_buffer_pos)))) && this->m_buffer_reading)) 
            {
                (this->m_buffer_pos = this->m_buffer_pos + (int32_t)(value - this->get_Position_5e75d5c458401f13()));
            }
             else 
            {
                BufferedStream::Flush_132821400030c993();
                this->m_stream->set_Position_cfe1def757785ad(value);
            }
        }
        return get_Position_5e75d5c458401f13();
    }
    
}}
namespace System { namespace IO {
    
    
    DirectoryInfo* Directory::CreateDirectory(System::String* path) {
        if((path ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("path"));
        }
        if((path->get_Length() ==  0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Path is empty"));
        }
        if((path->IndexOfAny(Path::InvalidPathChars) != -1)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Path contains invalid chars"));
        }
        if((path->Trim()->get_Length() ==  0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Only blank characters in path"));
        }
        System::Security::SecurityManager::EnsureElevatedPermissions();
        if(File::Exists(path)) 
        {
            throw cli::gcnew<IOException>(cli::concat(_T("Cannot create "), path));
        }
        if((System::Environment::get_IsRunningOnWindows() && System::String::op_Equality(path, _T(":")))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Only \':\' In path"));
        }
        return CreateDirectoriesInternal(path);
    }
    
    DirectoryInfo* Directory::CreateDirectory2(System::String* path, System::Security::AccessControl::DirectorySecurity* directorySecurity) {
        return CreateDirectory(path);
    }
    
    DirectoryInfo* Directory::CreateDirectoriesInternal(System::String* path) {
        if(System::Security::SecurityManager::get_SecurityEnabled()) 
        {
            cli::gcnew<System::Security::Permissions::FileIOPermission>((System::Security::Permissions::FileIOPermissionAccess)3L, path)->Demand();
        }
        DirectoryInfo *info = cli::gcnew<DirectoryInfo>(path, true);
        if(((info->get_Parent() != nullptr) && !(info->get_Parent()->get_Exists_44ccb569427c51d7()))) 
        {
            info->get_Parent()->Create();
        }
        MonoIOError error;
        if(!(MonoIO::CreateDirectory(path, error))) 
        {
            if((((int32_t)(error) != 183) && ((int32_t)(error) != 80))) 
            {
                throw MonoIO::GetException2(path, error);
            }
        }
        return info;
    }
    
    void Directory::Delete(System::String* path) {
        Path::Validate(path);
        if((System::Environment::get_IsRunningOnWindows() && System::String::op_Equality(path, _T(":")))) 
        {
            throw cli::gcnew<System::NotSupportedException>(_T("Only \':\' In path"));
        }
        System::Security::SecurityManager::EnsureElevatedPermissions();
        MonoIOError error;
        bool success;
        if(MonoIO::ExistsSymlink(path, error)) 
        {
            success = MonoIO::DeleteFile(path, error);
        }
         else 
        {
            success = MonoIO::RemoveDirectory(path, error);
        }
        if(!(success)) 
        {
            if(((int32_t)(error) ==  2)) 
            {
                if(File::Exists(path)) 
                {
                    throw cli::gcnew<IOException>(_T("Directory does not exist, but a file of the same name exists."));
                }
                 else 
                {
                    throw cli::gcnew<DirectoryNotFoundException>(_T("Directory does not exist."));
                }
            }
             else 
            {
                throw MonoIO::GetException2(path, error);
            }
        }
    }
    
    void Directory::RecursiveDelete(System::String* path) {
        MonoIOError error;
        for(auto tmp_231 : GetDirectories(path)) {
            auto dir = cli::cast<System::String*>(tmp_231);
            {
                if(MonoIO::ExistsSymlink(dir, error)) 
                {
                    MonoIO::DeleteFile(dir, error);
                }
                 else 
                {
                    RecursiveDelete(dir);
                }
            }
        }
        for(auto tmp_232 : GetFiles(path)) {
            auto file = cli::cast<System::String*>(tmp_232);
            File::Delete(file);
        }
        Directory::Delete(path);
    }
    
    void Directory::Delete2(System::String* path, bool recursive) {
        Path::Validate(path);
        System::Security::SecurityManager::EnsureElevatedPermissions();
        if(recursive) 
        {
            RecursiveDelete(path);
        }
         else 
        {
            Delete(path);
        }
    }
    
    bool Directory::Exists(System::String* path) {
        if((path ==  nullptr)) 
        {
            return false;
        }
        if(!(System::Security::SecurityManager::CheckElevatedPermissions())) 
        {
            return false;
        }
        MonoIOError error;
        bool exists;
        exists = MonoIO::ExistsDirectory(path, error);
        return exists;
    }
    
    System::DateTime Directory::GetLastAccessTime(System::String* path) {
        return File::GetLastAccessTime(path);
    }
    
    System::DateTime Directory::GetLastAccessTimeUtc(System::String* path) {
        return GetLastAccessTime(path)->ToUniversalTime();
    }
    
    System::DateTime Directory::GetLastWriteTime(System::String* path) {
        return File::GetLastWriteTime(path);
    }
    
    System::DateTime Directory::GetLastWriteTimeUtc(System::String* path) {
        return GetLastWriteTime(path)->ToUniversalTime();
    }
    
    System::DateTime Directory::GetCreationTime(System::String* path) {
        return File::GetCreationTime(path);
    }
    
    System::DateTime Directory::GetCreationTimeUtc(System::String* path) {
        return GetCreationTime(path)->ToUniversalTime();
    }
    
    System::String* Directory::GetCurrentDirectory() {
        MonoIOError error;
        System::Security::SecurityManager::EnsureElevatedPermissions();
        System::String *result = MonoIO::GetCurrentDirectory(error);
        if(((int32_t)(error) != 0)) 
        {
            throw MonoIO::GetException(error);
        }
        if((((result != nullptr) && (result->get_Length() > 0)) && System::Security::SecurityManager::get_SecurityEnabled())) 
        {
            cli::gcnew<System::Security::Permissions::FileIOPermission>(System::Security::Permissions::FileIOPermissionAccess::PathDiscovery, result)->Demand();
        }
        return result;
    }
    
    cli::array<System::String*>* Directory::GetDirectories(System::String* path) {
        return GetDirectories2(path, _T("*"));
    }
    
    cli::array<System::String*>* Directory::GetDirectories2(System::String* path, System::String* searchPattern) {
        return GetFileSystemEntries3(path, searchPattern, FileAttributes::Directory2, FileAttributes::Directory2);
    }
    
    cli::array<System::String*>* Directory::GetDirectories3(System::String* path, System::String* searchPattern, SearchOption searchOption) {
        if(((int32_t)(searchOption) ==  0)) 
        {
            return GetDirectories2(path, searchPattern);
        }
        System::Collections::Generic::List<System::String*> *all = cli::gcnew<System::Collections::Generic::List<System::String*>>();
        GetDirectoriesRecurse(path, searchPattern, all);
        return all->ToArray();
    }
    
    void Directory::GetDirectoriesRecurse(System::String* path, System::String* searchPattern, System::Collections::Generic::List<System::String*>* all) {
        all->AddRange(GetDirectories2(path, searchPattern));
        for(auto tmp_233 : GetDirectories(path)) {
            auto dir = cli::cast<System::String*>(tmp_233);
            GetDirectoriesRecurse(dir, searchPattern, all);
        }
    }
    
    System::String* Directory::GetDirectoryRoot(System::String* path) {
        Path::Validate(path);
        System::Security::SecurityManager::EnsureElevatedPermissions();
        return cli::gcnew<System::String>(Path::DirectorySeparatorChar, 1);
    }
    
    cli::array<System::String*>* Directory::GetFiles(System::String* path) {
        return GetFiles2(path, _T("*"));
    }
    
    cli::array<System::String*>* Directory::GetFiles2(System::String* path, System::String* searchPattern) {
        return GetFileSystemEntries3(path, searchPattern, FileAttributes::Directory2, (FileAttributes)0L);
    }
    
    cli::array<System::String*>* Directory::GetFiles3(System::String* path, System::String* searchPattern, SearchOption searchOption) {
        if(((int32_t)(searchOption) ==  0)) 
        {
            return GetFiles2(path, searchPattern);
        }
        System::Collections::Generic::List<System::String*> *all = cli::gcnew<System::Collections::Generic::List<System::String*>>();
        GetFilesRecurse(path, searchPattern, all);
        return all->ToArray();
    }
    
    void Directory::GetFilesRecurse(System::String* path, System::String* searchPattern, System::Collections::Generic::List<System::String*>* all) {
        all->AddRange(GetFiles2(path, searchPattern));
        for(auto tmp_234 : GetDirectories(path)) {
            auto dir = cli::cast<System::String*>(tmp_234);
            GetFilesRecurse(dir, searchPattern, all);
        }
    }
    
    cli::array<System::String*>* Directory::GetFileSystemEntries(System::String* path) {
        return GetFileSystemEntries2(path, _T("*"));
    }
    
    cli::array<System::String*>* Directory::GetFileSystemEntries2(System::String* path, System::String* searchPattern) {
        return GetFileSystemEntries3(path, searchPattern, (FileAttributes)0L, (FileAttributes)0L);
    }
    
    cli::array<System::String*>* Directory::GetLogicalDrives() {
        return System::Environment::GetLogicalDrives();
    }
    
    bool Directory::IsRootDirectory(System::String* path) {
        if((((int32_t)(Path::DirectorySeparatorChar) ==  47) && System::String::op_Equality(path, _T("/")))) 
        {
            return true;
        }
        if(((int32_t)(Path::DirectorySeparatorChar) ==  92)) 
        {
            if(((path->get_Length() ==  3) && path->EndsWith(_T(":\\")))) 
            {
                return true;
            }
        }
        return false;
    }
    
    DirectoryInfo* Directory::GetParent(System::String* path) {
        Path::Validate(path);
        if(IsRootDirectory(path)) 
        {
            return nullptr;
        }
        System::String *parent_name = Path::GetDirectoryName(path);
        if((parent_name->get_Length() ==  0)) 
        {
            parent_name = GetCurrentDirectory();
        }
        return cli::gcnew<DirectoryInfo>(parent_name);
    }
    
    void Directory::Move(System::String* sourceDirName, System::String* destDirName) {
        if((sourceDirName ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("sourceDirName"));
        }
        if((destDirName ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("destDirName"));
        }
        if(((sourceDirName->Trim()->get_Length() ==  0) || (sourceDirName->IndexOfAny(Path::InvalidPathChars) != -1))) 
        {
            throw cli::gcnew<System::ArgumentException>(cli::concat(_T("Invalid source directory name: "), sourceDirName), _T("sourceDirName"));
        }
        if(((destDirName->Trim()->get_Length() ==  0) || (destDirName->IndexOfAny(Path::InvalidPathChars) != -1))) 
        {
            throw cli::gcnew<System::ArgumentException>(cli::concat(_T("Invalid target directory name: "), destDirName), _T("destDirName"));
        }
        if(System::String::op_Equality(sourceDirName, destDirName)) 
        {
            throw cli::gcnew<IOException>(_T("Source and destination path must be different."));
        }
        System::Security::SecurityManager::EnsureElevatedPermissions();
        if(Exists(destDirName)) 
        {
            throw cli::gcnew<IOException>(cli::concat(destDirName, _T(" already exists.")));
        }
        if((!(Exists(sourceDirName)) && !(File::Exists(sourceDirName)))) 
        {
            throw cli::gcnew<DirectoryNotFoundException>(cli::concat(sourceDirName, _T(" does not exist")));
        }
        MonoIOError error;
        if(!(MonoIO::MoveFile(sourceDirName, destDirName, error))) 
        {
            throw MonoIO::GetException(error);
        }
    }
    
    void Directory::SetAccessControl(System::String* path, System::Security::AccessControl::DirectorySecurity* directorySecurity) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Directory::SetCreationTime(System::String* path, System::DateTime creationTime) {
        File::SetCreationTime(path, creationTime);
    }
    
    void Directory::SetCreationTimeUtc(System::String* path, System::DateTime creationTimeUtc) {
        SetCreationTime(path, creationTimeUtc->ToLocalTime());
    }
    
    void Directory::SetCurrentDirectory(System::String* path) {
        if((path ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("path"));
        }
        if((path->Trim()->get_Length() ==  0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("path string must not be an empty string or whitespace string"));
        }
        MonoIOError error;
        if(!(Exists(path))) 
        {
            throw cli::gcnew<DirectoryNotFoundException>(cli::concat(_T("Directory \""), path));
        }
        MonoIO::SetCurrentDirectory(path, error);
        if(((int32_t)(error) != 0)) 
        {
            throw MonoIO::GetException2(path, error);
        }
    }
    
    void Directory::SetLastAccessTime(System::String* path, System::DateTime lastAccessTime) {
        File::SetLastAccessTime(path, lastAccessTime);
    }
    
    void Directory::SetLastAccessTimeUtc(System::String* path, System::DateTime lastAccessTimeUtc) {
        SetLastAccessTime(path, lastAccessTimeUtc->ToLocalTime());
    }
    
    void Directory::SetLastWriteTime(System::String* path, System::DateTime lastWriteTime) {
        File::SetLastWriteTime(path, lastWriteTime);
    }
    
    void Directory::SetLastWriteTimeUtc(System::String* path, System::DateTime lastWriteTimeUtc) {
        SetLastWriteTime(path, lastWriteTimeUtc->ToLocalTime());
    }
    
    System::String* Directory::ValidateDirectoryListing(System::String* path, System::String* searchPattern, bool stop) {
        Path::Validate(path);
        System::String *wild = Path::Combine(path, searchPattern);
        System::String *wildpath = Path::GetDirectoryName(wild);
        if((wildpath->IndexOfAny(Path::InvalidPathChars) != -1)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Pattern contains invalid characters"), _T("pattern"));
        }
        MonoIOError error;
        if(!(MonoIO::ExistsDirectory(wildpath, error))) 
        {
            if(((int32_t)(error) ==  0)) 
            {
                MonoIOError file_error;
                if(MonoIO::ExistsFile(wildpath, file_error)) 
                {
                    throw cli::gcnew<IOException>(_T("The directory name is invalid."));
                }
            }
            if(((int32_t)(error) != 3)) 
            {
                throw MonoIO::GetException2(wildpath, error);
            }
            if((wildpath->IndexOfAny(SearchPattern::WildcardChars) ==  -1)) 
            {
                throw cli::gcnew<DirectoryNotFoundException>(cli::concat(_T("Directory \'"), wildpath));
            }
            if((path->IndexOfAny(SearchPattern::WildcardChars) ==  -1)) 
            {
                throw cli::gcnew<System::ArgumentException>(_T("Pattern is invalid"), _T("searchPattern"));
            }
            throw cli::gcnew<System::ArgumentException>(_T("Path is invalid"), _T("path"));
        }
        stop = false;
        return wild;
    }
    
    cli::array<System::String*>* Directory::GetFileSystemEntries3(System::String* path, System::String* searchPattern, FileAttributes mask, FileAttributes attrs) {
        if((searchPattern ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("searchPattern"));
        }
        if((searchPattern->get_Length() ==  0)) 
        {
            return (new cli::array<System::String*>({}));
        }
        bool stop;
        System::String *path_with_pattern = ValidateDirectoryListing(path, searchPattern, stop);
        if(stop) 
        {
            return (new cli::array<System::String*>({path_with_pattern}));
        }
        MonoIOError error;
        cli::array<System::String*> *result = MonoIO::GetFileSystemEntries(path, path_with_pattern, (int32_t)(attrs), (int32_t)(mask), error);
        if(((int32_t)(error) != 0)) 
        {
            throw MonoIO::GetException2(Path::GetDirectoryName(Path::Combine(path, searchPattern)), error);
        }
        return result;
    }
    
    cli::array<System::String*>* Directory::GetFileSystemEntries4(System::String* path, System::String* searchPattern, SearchOption searchOption) {
        return cli::gcnew<System::Collections::Generic::List<System::String*>>(EnumerateFileSystemEntries(path, searchPattern, searchOption))->ToArray();
    }
    
    void Directory::EnumerateCheck(System::String* path, System::String* searchPattern, SearchOption searchOption) {
        if((searchPattern ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("searchPattern"));
        }
        if((searchPattern->get_Length() ==  0)) 
        {
            return;
        }
        if((((int32_t)(searchOption) != 0) && ((int32_t)(searchOption) != 1))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("searchoption"));
        }
        Path::Validate(path);
        System::Security::SecurityManager::EnsureElevatedPermissions();
    }
    
    System::Collections::Generic::IEnumerable2<System::String*>* Directory::EnumerateKind(System::String* path, System::String* searchPattern, SearchOption searchOption, FileAttributes kind) {
        return (nullptr/*TODO: Implement Yield Expression!*/);
    }
    
    System::Collections::Generic::IEnumerable2<System::String*>* Directory::EnumerateDirectories(System::String* path, System::String* searchPattern, SearchOption searchOption) {
        EnumerateCheck(path, searchPattern, searchOption);
        return EnumerateKind(path, searchPattern, searchOption, FileAttributes::Directory2);
    }
    
    System::Collections::Generic::IEnumerable2<System::String*>* Directory::EnumerateDirectories2(System::String* path, System::String* searchPattern) {
        EnumerateCheck(path, searchPattern, SearchOption::TopDirectoryOnly);
        return EnumerateKind(path, searchPattern, SearchOption::TopDirectoryOnly, FileAttributes::Directory2);
    }
    
    System::Collections::Generic::IEnumerable2<System::String*>* Directory::EnumerateDirectories3(System::String* path) {
        Path::Validate(path);
        System::Security::SecurityManager::EnsureElevatedPermissions();
        return EnumerateKind(path, _T("*"), SearchOption::TopDirectoryOnly, FileAttributes::Directory2);
    }
    
    System::Collections::Generic::IEnumerable2<System::String*>* Directory::EnumerateFiles(System::String* path, System::String* searchPattern, SearchOption searchOption) {
        EnumerateCheck(path, searchPattern, searchOption);
        return EnumerateKind(path, searchPattern, searchOption, FileAttributes::Normal);
    }
    
    System::Collections::Generic::IEnumerable2<System::String*>* Directory::EnumerateFiles2(System::String* path, System::String* searchPattern) {
        EnumerateCheck(path, searchPattern, SearchOption::TopDirectoryOnly);
        return EnumerateKind(path, searchPattern, SearchOption::TopDirectoryOnly, FileAttributes::Normal);
    }
    
    System::Collections::Generic::IEnumerable2<System::String*>* Directory::EnumerateFiles3(System::String* path) {
        Path::Validate(path);
        System::Security::SecurityManager::EnsureElevatedPermissions();
        return EnumerateKind(path, _T("*"), SearchOption::TopDirectoryOnly, FileAttributes::Normal);
    }
    
    System::Collections::Generic::IEnumerable2<System::String*>* Directory::EnumerateFileSystemEntries(System::String* path, System::String* searchPattern, SearchOption searchOption) {
        EnumerateCheck(path, searchPattern, searchOption);
        return EnumerateKind(path, searchPattern, searchOption, (FileAttributes)144L);
    }
    
    System::Collections::Generic::IEnumerable2<System::String*>* Directory::EnumerateFileSystemEntries2(System::String* path, System::String* searchPattern) {
        EnumerateCheck(path, searchPattern, SearchOption::TopDirectoryOnly);
        return EnumerateKind(path, searchPattern, SearchOption::TopDirectoryOnly, (FileAttributes)144L);
    }
    
    System::Collections::Generic::IEnumerable2<System::String*>* Directory::EnumerateFileSystemEntries3(System::String* path) {
        Path::Validate(path);
        System::Security::SecurityManager::EnsureElevatedPermissions();
        return EnumerateKind(path, _T("*"), SearchOption::TopDirectoryOnly, (FileAttributes)144L);
    }
    
    System::Security::AccessControl::DirectorySecurity* Directory::GetAccessControl(System::String* path, System::Security::AccessControl::AccessControlSections includeSections) {
        throw cli::gcnew<System::PlatformNotSupportedException>();
    }
    
    System::Security::AccessControl::DirectorySecurity* Directory::GetAccessControl2(System::String* path) {
        throw cli::gcnew<System::PlatformNotSupportedException>();
    }
    
}}
namespace System { namespace IO {
    
    
    void DirectoryInfo::constructor(System::String* path) {
    }
    
    void DirectoryInfo::constructor(System::String* path, bool simpleOriginalPath) {
        FileSystemInfo::CheckPath(path);
        System::Security::SecurityManager::EnsureElevatedPermissions();
        this->FullPath = Path::GetFullPath(path);
        if(simpleOriginalPath) 
        {
            this->OriginalPath = Path::GetFileName(path);
        }
         else 
        {
            this->OriginalPath = path;
        }
        Initialize();
    }
    
    void DirectoryInfo::constructor(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        Initialize();
    }
    
    void DirectoryInfo::Initialize() {
        int32_t len = (this->FullPath->get_Length() - 1);
        if(((len > 1) && ((int32_t)(this->FullPath->get_Chars(len)) ==  (int32_t)(Path::DirectorySeparatorChar)))) 
        {
            len--;
        }
        int32_t last = this->FullPath->LastIndexOf5(Path::DirectorySeparatorChar, len);
        if(((last ==  -1) || ((last ==  0) && (len ==  0)))) 
        {
            this->current = this->FullPath;
            this->parent = nullptr;
        }
         else 
        {
            this->current = this->FullPath->Substring2((last + 1), (len - last));
            if(((last ==  0) && !(System::Environment::get_IsRunningOnWindows()))) 
            {
                this->parent = Path::DirectorySeparatorStr;
            }
             else 
            {
                this->parent = this->FullPath->Substring2(0, last);
            }
            if(System::Environment::get_IsRunningOnWindows()) 
            {
                if((((this->parent->get_Length() ==  2) && ((int32_t)(this->parent->get_Chars(1)) ==  58)) && System::Char::IsLetter(this->parent->get_Chars(0)))) 
                {
                    (this->parent = cli::concat(this->parent, cli::box(Path::DirectorySeparatorChar)));
                }
            }
        }
    }
    
    void DirectoryInfo::Create() {
        Directory::CreateDirectory(this->FullPath);
    }
    
    DirectoryInfo* DirectoryInfo::CreateSubdirectory(System::String* path) {
        FileSystemInfo::CheckPath(path);
        path = Path::Combine(this->FullPath, path);
        Directory::CreateDirectory(path);
        return cli::gcnew<DirectoryInfo>(path);
    }
    
    cli::array<FileInfo*>* DirectoryInfo::GetFiles() {
        return GetFiles2(_T("*"));
    }
    
    cli::array<FileInfo*>* DirectoryInfo::GetFiles2(System::String* searchPattern) {
        if((searchPattern ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("searchPattern"));
        }
        cli::array<System::String*> *names = Directory::GetFiles2(this->FullPath, searchPattern);
        cli::array<FileInfo*> *infos = (new cli::array<FileInfo*>(names->get_Length()));
        int32_t i = 0;
        for(auto tmp_235 : names) {
            auto name = cli::cast<System::String*>(tmp_235);
            infos->at(i++) = cli::gcnew<FileInfo>(name);
        }
        return infos;
    }
    
    cli::array<DirectoryInfo*>* DirectoryInfo::GetDirectories() {
        return GetDirectories2(_T("*"));
    }
    
    cli::array<DirectoryInfo*>* DirectoryInfo::GetDirectories2(System::String* searchPattern) {
        if((searchPattern ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("searchPattern"));
        }
        cli::array<System::String*> *names = Directory::GetDirectories2(this->FullPath, searchPattern);
        cli::array<DirectoryInfo*> *infos = (new cli::array<DirectoryInfo*>(names->get_Length()));
        int32_t i = 0;
        for(auto tmp_236 : names) {
            auto name = cli::cast<System::String*>(tmp_236);
            infos->at(i++) = cli::gcnew<DirectoryInfo>(name);
        }
        return infos;
    }
    
    cli::array<FileSystemInfo*>* DirectoryInfo::GetFileSystemInfos() {
        return GetFileSystemInfos2(_T("*"));
    }
    
    cli::array<FileSystemInfo*>* DirectoryInfo::GetFileSystemInfos2(System::String* searchPattern) {
        return GetFileSystemInfos3(searchPattern, SearchOption::TopDirectoryOnly);
    }
    
    cli::array<FileSystemInfo*>* DirectoryInfo::GetFileSystemInfos3(System::String* searchPattern, SearchOption searchOption) {
        if((searchPattern ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("searchPattern"));
        }
        if((((int32_t)(searchOption) != 0) && ((int32_t)(searchOption) != 1))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("searchOption"), _T("Must be TopDirectoryOnly or AllDirectories"));
        }
        if(!(Directory::Exists(this->FullPath))) 
        {
            throw cli::gcnew<IOException>(_T("Invalid directory"));
        }
        System::Collections::Generic::List<FileSystemInfo*> *infos = cli::gcnew<System::Collections::Generic::List<FileSystemInfo*>>();
        InternalGetFileSystemInfos(searchPattern, searchOption, infos);
        return infos->ToArray();
    }
    
    void DirectoryInfo::InternalGetFileSystemInfos(System::String* searchPattern, SearchOption searchOption, System::Collections::Generic::List<FileSystemInfo*>* infos) {
        auto storey_237 = cli::gcnew<_InternalGetFileSystemInfos_c__AnonStorey18>();
        storey_237->infos = infos;
        cli::array<System::String*> *dirs = Directory::GetDirectories2(this->FullPath, searchPattern);
        cli::array<System::String*> *files = Directory::GetFiles2(this->FullPath, searchPattern);
        System::Array::template ForEach_1<System::String*>(dirs, cli::bind(storey_237, &_InternalGetFileSystemInfos_c__AnonStorey18::__m__D));
        System::Array::template ForEach_1<System::String*>(files, cli::bind(storey_237, &_InternalGetFileSystemInfos_c__AnonStorey18::__m__E));
        if(((dirs->get_Length() ==  0) || ((int32_t)(searchOption) ==  0))) 
        {
            return;
        }
        for(auto tmp_238 : dirs) {
            auto dir = cli::cast<System::String*>(tmp_238);
            {
                DirectoryInfo *dinfo = cli::gcnew<DirectoryInfo>(dir);
                dinfo->InternalGetFileSystemInfos(searchPattern, searchOption, storey_237->infos);
            }
        }
    }
    
    void DirectoryInfo::Delete_2d3445237ba2ed66() {
        Delete3(false);
    }
    
    void DirectoryInfo::Delete3(bool recursive) {
        Directory::Delete2(this->FullPath, recursive);
    }
    
    void DirectoryInfo::MoveTo(System::String* destDirName) {
        if((destDirName ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("destDirName"));
        }
        if((destDirName->get_Length() ==  0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("An empty file name is not valid."), _T("destDirName"));
        }
        Directory::Move(this->FullPath, Path::GetFullPath(destDirName));
    }
    
    System::String* DirectoryInfo::ToString_1636a0751cb9ac11() {
        return this->OriginalPath;
    }
    
    cli::array<DirectoryInfo*>* DirectoryInfo::GetDirectories3(System::String* searchPattern, SearchOption searchOption) {
        switch(searchOption) {
            case SearchOption::TopDirectoryOnly: case_1104: {
                return GetDirectories2(searchPattern);
            }
            case SearchOption::AllDirectories: case_1105: {
                System::Collections::Queue *workq = cli::gcnew<System::Collections::Queue>(GetDirectories2(searchPattern));
                System::Collections::Queue *doneq = cli::gcnew<System::Collections::Queue>();
                while((workq->get_Count_d68471db5ed73aae() > 0)) {
                    DirectoryInfo *cinfo = cli::cast<DirectoryInfo*>(workq->Dequeue_65b33648b3aa820f());
                    cli::array<DirectoryInfo*> *cinfoDirs = cinfo->GetDirectories2(searchPattern);
                    for(auto tmp_239 : cinfoDirs) {
                        auto i = cli::cast<DirectoryInfo*>(tmp_239);
                        workq->Enqueue_7ab7b5c658b77bbe(i);
                    }
                    doneq->Enqueue_7ab7b5c658b77bbe(cinfo);
                }
                cli::array<DirectoryInfo*> *infos = (new cli::array<DirectoryInfo*>(doneq->get_Count_d68471db5ed73aae()));
                doneq->CopyTo_a242f31c9e5a44f6(infos, 0);
                return infos;
            }
            default: case_1106: {
                System::String *msg = Locale::GetText2(_T("Invalid enum value \'{0}\' for \'{1}\'."), (new cli::array<System::Object*>({cli::box(searchOption), _T("SearchOption")})));
                throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("searchOption"), msg);
            }
        }
    }
    
    int32_t DirectoryInfo::GetFilesSubdirs(System::Collections::ArrayList* l, System::String* pattern) {
        int32_t count;
        cli::array<FileInfo*> *thisdir = nullptr;
        try {
            thisdir = GetFiles2(pattern);
        }
        catch(System::UnauthorizedAccessException*) {
            return 0;
        }
        count = thisdir->get_Length();
        l->Add_e6a92085999ce388(thisdir);
        for(auto tmp_240 : GetDirectories()) {
            auto subdir = cli::cast<DirectoryInfo*>(tmp_240);
            {
                (count = count + subdir->GetFilesSubdirs(l, pattern));
            }
        }
        return count;
    }
    
    cli::array<FileInfo*>* DirectoryInfo::GetFiles3(System::String* searchPattern, SearchOption searchOption) {
        switch(searchOption) {
            case SearchOption::TopDirectoryOnly: case_1107: {
                return GetFiles2(searchPattern);
            }
            case SearchOption::AllDirectories: case_1108: {
                {
                    System::Collections::ArrayList *groups = cli::gcnew<System::Collections::ArrayList>();
                    int32_t count = GetFilesSubdirs(groups, searchPattern);
                    int32_t current = 0;
                    cli::array<FileInfo*> *all = (new cli::array<FileInfo*>(count));
                    for(auto tmp_241 : groups) {
                        auto p = cli::cast<cli::array<FileInfo*>*>(tmp_241);
                        {
                            cli::import(p)->CopyTo(all, current);
                            (current = current + p->get_Length());
                        }
                    }
                    return all;
                }
            }
            default: case_1109: {
                System::String *msg = Locale::GetText2(_T("Invalid enum value \'{0}\' for \'{1}\'."), (new cli::array<System::Object*>({cli::box(searchOption), _T("SearchOption")})));
                throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("searchOption"), msg);
            }
        }
    }
    
    void DirectoryInfo::Create2(System::Security::AccessControl::DirectorySecurity* directorySecurity) {
        if((directorySecurity != nullptr)) 
        {
            throw cli::gcnew<System::UnauthorizedAccessException>();
        }
        Create();
    }
    
    DirectoryInfo* DirectoryInfo::CreateSubdirectory2(System::String* path, System::Security::AccessControl::DirectorySecurity* directorySecurity) {
        if((directorySecurity != nullptr)) 
        {
            throw cli::gcnew<System::UnauthorizedAccessException>();
        }
        return CreateSubdirectory(path);
    }
    
    System::Security::AccessControl::DirectorySecurity* DirectoryInfo::GetAccessControl() {
        throw cli::gcnew<System::UnauthorizedAccessException>();
    }
    
    System::Security::AccessControl::DirectorySecurity* DirectoryInfo::GetAccessControl2(System::Security::AccessControl::AccessControlSections includeSections) {
        throw cli::gcnew<System::UnauthorizedAccessException>();
    }
    
    void DirectoryInfo::SetAccessControl(System::Security::AccessControl::DirectorySecurity* directorySecurity) {
        if((directorySecurity != nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("directorySecurity"));
        }
        throw cli::gcnew<System::UnauthorizedAccessException>();
    }
    
    System::Collections::Generic::IEnumerable2<DirectoryInfo*>* DirectoryInfo::EnumerateDirectories() {
        return EnumerateDirectories3(_T("*"), SearchOption::TopDirectoryOnly);
    }
    
    System::Collections::Generic::IEnumerable2<DirectoryInfo*>* DirectoryInfo::EnumerateDirectories2(System::String* searchPattern) {
        return EnumerateDirectories3(searchPattern, SearchOption::TopDirectoryOnly);
    }
    
    System::Collections::Generic::IEnumerable2<DirectoryInfo*>* DirectoryInfo::EnumerateDirectories3(System::String* searchPattern, SearchOption searchOption) {
        return (nullptr/*TODO: Implement Yield Expression!*/);
    }
    
    System::Collections::Generic::IEnumerable2<FileInfo*>* DirectoryInfo::EnumerateFiles() {
        return EnumerateFiles3(_T("*"), SearchOption::TopDirectoryOnly);
    }
    
    System::Collections::Generic::IEnumerable2<FileInfo*>* DirectoryInfo::EnumerateFiles2(System::String* searchPattern) {
        return EnumerateFiles3(searchPattern, SearchOption::TopDirectoryOnly);
    }
    
    System::Collections::Generic::IEnumerable2<FileInfo*>* DirectoryInfo::EnumerateFiles3(System::String* searchPattern, SearchOption searchOption) {
        return (nullptr/*TODO: Implement Yield Expression!*/);
    }
    
    System::Collections::Generic::IEnumerable2<FileSystemInfo*>* DirectoryInfo::EnumerateFileSystemInfos() {
        return EnumerateFileSystemInfos3(_T("*"), SearchOption::TopDirectoryOnly);
    }
    
    System::Collections::Generic::IEnumerable2<FileSystemInfo*>* DirectoryInfo::EnumerateFileSystemInfos2(System::String* searchPattern) {
        return EnumerateFileSystemInfos3(searchPattern, SearchOption::TopDirectoryOnly);
    }
    
    System::Collections::Generic::IEnumerable2<FileSystemInfo*>* DirectoryInfo::EnumerateFileSystemInfos3(System::String* searchPattern, SearchOption searchOption) {
        if((searchPattern ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("searchPattern"));
        }
        if((((int32_t)(searchOption) != 0) && ((int32_t)(searchOption) != 1))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("searchoption"));
        }
        return EnumerateFileSystemInfos4(this->FullPath, searchPattern, searchOption);
    }
    
    System::Collections::Generic::IEnumerable2<FileSystemInfo*>* DirectoryInfo::EnumerateFileSystemInfos4(System::String* full, System::String* searchPattern, SearchOption searchOption) {
        return (nullptr/*TODO: Implement Yield Expression!*/);
    }
    
    bool DirectoryInfo::get_Exists_44ccb569427c51d7() {
        FileSystemInfo::Refresh2(false);
        if(((int32_t)(this->stat->Attributes) ==  (int32_t)(MonoIO::InvalidFileAttributes))) 
        {
            return false;
        }
        if(((int32_t)(((int32_t)(this->stat->Attributes) & 16)) ==  0)) 
        {
            return false;
        }
        return true;
    }
    
    System::String* DirectoryInfo::get_Name_34b64716a6d0afcd() {
        return this->current;
    }
    
    DirectoryInfo* DirectoryInfo::get_Parent() {
        if(((this->parent ==  nullptr) || (this->parent->get_Length() ==  0))) 
        {
            return nullptr;
        }
        return cli::gcnew<DirectoryInfo>(this->parent);
    }
    
    DirectoryInfo* DirectoryInfo::get_Root() {
        System::String *root = Path::GetPathRoot(this->FullPath);
        if((root ==  nullptr)) 
        {
            return nullptr;
        }
        return cli::gcnew<DirectoryInfo>(root);
    }
    
}}
namespace System { namespace IO {
    
    
    void DirectoryNotFoundException::constructor() {
    }
    
    void DirectoryNotFoundException::constructor(System::String* message) {
    }
    
    void DirectoryNotFoundException::constructor(System::String* message, System::Exception* innerException) {
    }
    
    void DirectoryNotFoundException::constructor(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
    }
    
}}
namespace System { namespace IO {
    
    
    void DriveInfo::constructor(System::String* path, System::String* fstype) {
        this->drive_format = fstype;
        this->path = path;
    }
    
    void DriveInfo::constructor(System::String* driveName) {
        if(!(System::Environment::get_IsUnix())) 
        {
            if(((driveName ==  nullptr) || (driveName->get_Length() ==  0))) 
            {
                throw cli::gcnew<System::ArgumentException>(_T("The drive name is null or empty"), _T("driveName"));
            }
            if(((driveName->get_Length() >= 2) && ((int32_t)(driveName->get_Chars(1)) != 58))) 
            {
                throw cli::gcnew<System::ArgumentException>(_T("Invalid drive name"), _T("driveName"));
            }
            driveName = System::String::Concat5(cli::import(System::Char::ToUpper(driveName->get_Chars(0)))->ToString_1636a0751cb9ac11(), _T(":\\"));
        }
        cli::array<DriveInfo*> *drives = GetDrives();
        for(auto tmp_242 : drives) {
            auto d = cli::cast<DriveInfo*>(tmp_242);
            {
                if(System::String::op_Equality(d->path, driveName)) 
                {
                    this->path = d->path;
                    this->drive_format = d->drive_format;
                    this->path = d->path;
                    return;
                }
            }
        }
        throw cli::gcnew<System::ArgumentException>(_T("The drive name does not exist"), _T("driveName"));
    }
    
    void DriveInfo::GetDiskFreeSpace(System::String* path, uint64_t availableFreeSpace, uint64_t totalSize, uint64_t totalFreeSpace) {
        MonoIOError error;
        if(!(GetDiskFreeSpaceInternal(path, availableFreeSpace, totalSize, totalFreeSpace, error))) 
        {
            throw MonoIO::GetException2(path, error);
        }
    }
    
    cli::array<DriveInfo*>* DriveInfo::GetDrives() {
        cli::array<System::String*> *drives = System::Environment::GetLogicalDrives();
        cli::array<DriveInfo*> *infos = (new cli::array<DriveInfo*>(drives->get_Length()));
        int32_t i = 0;
        for(auto tmp_243 : drives) {
            auto s = cli::cast<System::String*>(tmp_243);
            infos->at(i++) = cli::gcnew<DriveInfo>(s, GetDriveFormat(s));
        }
        return infos;
    }
    
    void DriveInfo::GetObjectData(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    System::String* DriveInfo::ToString_1636a0751cb9ac11() {
        return this->get_Name();
    }
    
    bool DriveInfo::GetDiskFreeSpaceInternal(System::String* pathName, uint64_t freeBytesAvail, uint64_t totalNumberOfBytes, uint64_t totalNumberOfFreeBytes, MonoIOError error) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    uint32_t DriveInfo::GetDriveTypeInternal(System::String* rootPathName) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    System::String* DriveInfo::GetDriveFormat(System::String* rootPathName) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int64_t DriveInfo::get_AvailableFreeSpace() {
        uint64_t availableFreeSpace;
        uint64_t totalSize;
        uint64_t totalFreeSpace;
        GetDiskFreeSpace(this->path, availableFreeSpace, totalSize, totalFreeSpace);
        return (availableFreeSpace > 9223372036854775807UL) ? 9223372036854775807L : (int64_t)availableFreeSpace;
    }
    
    int64_t DriveInfo::get_TotalFreeSpace() {
        uint64_t availableFreeSpace;
        uint64_t totalSize;
        uint64_t totalFreeSpace;
        GetDiskFreeSpace(this->path, availableFreeSpace, totalSize, totalFreeSpace);
        return (totalFreeSpace > 9223372036854775807UL) ? 9223372036854775807L : (int64_t)totalFreeSpace;
    }
    
    int64_t DriveInfo::get_TotalSize() {
        uint64_t availableFreeSpace;
        uint64_t totalSize;
        uint64_t totalFreeSpace;
        GetDiskFreeSpace(this->path, availableFreeSpace, totalSize, totalFreeSpace);
        return (totalSize > 9223372036854775807UL) ? 9223372036854775807L : (int64_t)totalSize;
    }
    
    System::String* DriveInfo::get_VolumeLabel() {
        return this->path;
    }
    
    System::String* DriveInfo::set_VolumeLabel(System::String* value) {
        throw cli::gcnew<System::NotImplementedException>();
        return get_VolumeLabel();
    }
    
    System::String* DriveInfo::get_DriveFormat() {
        return this->drive_format;
    }
    
    DriveType DriveInfo::get_DriveType() {
        return (DriveType)((int32_t)GetDriveTypeInternal(this->path));
    }
    
    System::String* DriveInfo::get_Name() {
        return this->path;
    }
    
    DirectoryInfo* DriveInfo::get_RootDirectory() {
        return cli::gcnew<DirectoryInfo>(this->path);
    }
    
    bool DriveInfo::get_IsReady() {
        return true;
    }
    
}}
namespace System { namespace IO {
    
    
    void DriveNotFoundException::constructor() {
        this->set_HResult(-2147024893);
    }
    
    void DriveNotFoundException::constructor(System::String* message) {
        this->set_HResult(-2147024893);
    }
    
    void DriveNotFoundException::constructor(System::String* message, System::Exception* innerException) {
        this->set_HResult(-2147024893);
    }
    
    void DriveNotFoundException::constructor(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
    }
    
}}
namespace System { namespace IO {
    
    
    void EndOfStreamException::constructor() {
    }
    
    void EndOfStreamException::constructor(System::String* message) {
    }
    
    void EndOfStreamException::constructor(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
    }
    
    void EndOfStreamException::constructor(System::String* message, System::Exception* innerException) {
    }
    
}}
namespace System { namespace IO {
    
    System::Nullable2<System::DateTime>  File::defaultLocalFileTime;
    
    void File::AppendAllText(System::String* path, System::String* contents) {
        {
            /* USING - BLOCK */
            auto w = cli::gcnew<StreamWriter>(path, true);
            cli::using_guard{w};
            w->Write_dcf5e45abd9e11c4(contents);
        }
    }
    
    void File::AppendAllText2(System::String* path, System::String* contents, System::Text::Encoding* encoding) {
        {
            /* USING - BLOCK */
            auto w = cli::gcnew<StreamWriter>(path, true, encoding);
            cli::using_guard{w};
            w->Write_dcf5e45abd9e11c4(contents);
        }
    }
    
    StreamWriter* File::AppendText(System::String* path) {
        return cli::gcnew<StreamWriter>(path, true);
    }
    
    void File::Copy(System::String* sourceFileName, System::String* destFileName) {
        Copy2(sourceFileName, destFileName, false);
    }
    
    void File::Copy2(System::String* sourceFileName, System::String* destFileName, bool overwrite) {
        MonoIOError error;
        if((sourceFileName ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("sourceFileName"));
        }
        if((destFileName ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("destFileName"));
        }
        if((sourceFileName->get_Length() ==  0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("An empty file name is not valid."), _T("sourceFileName"));
        }
        if(((sourceFileName->Trim()->get_Length() ==  0) || (sourceFileName->IndexOfAny(Path::InvalidPathChars) != -1))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("The file name is not valid."));
        }
        if((destFileName->get_Length() ==  0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("An empty file name is not valid."), _T("destFileName"));
        }
        if(((destFileName->Trim()->get_Length() ==  0) || (destFileName->IndexOfAny(Path::InvalidPathChars) != -1))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("The file name is not valid."));
        }
        System::Security::SecurityManager::EnsureElevatedPermissions();
        if(!(MonoIO::Exists(sourceFileName, error))) 
        {
            throw cli::gcnew<FileNotFoundException>(Locale::GetText2(_T("{0} does not exist"), (new cli::array<System::Object*>({sourceFileName}))), sourceFileName);
        }
        if(((int32_t)(((int32_t)(GetAttributes(sourceFileName)) & 16)) ==  16)) 
        {
            throw cli::gcnew<System::ArgumentException>(Locale::GetText2(_T("{0} is a directory"), (new cli::array<System::Object*>({sourceFileName}))));
        }
        if(MonoIO::Exists(destFileName, error)) 
        {
            if(((int32_t)(((int32_t)(GetAttributes(destFileName)) & 16)) ==  16)) 
            {
                throw cli::gcnew<System::ArgumentException>(Locale::GetText2(_T("{0} is a directory"), (new cli::array<System::Object*>({destFileName}))));
            }
            if(!(overwrite)) 
            {
                throw cli::gcnew<IOException>(Locale::GetText2(_T("{0} already exists"), (new cli::array<System::Object*>({destFileName}))));
            }
        }
        System::String *DirName = Path::GetDirectoryName(destFileName);
        if((System::String::op_Inequality(DirName, System::String::Empty) && !(Directory::Exists(DirName)))) 
        {
            throw cli::gcnew<DirectoryNotFoundException>(Locale::GetText2(_T("Destination directory not found: {0}"), (new cli::array<System::Object*>({DirName}))));
        }
        if(!(MonoIO::CopyFile(sourceFileName, destFileName, overwrite, error))) 
        {
            System::String *p = Locale::GetText2(_T("{0}\" or \"{1}"), (new cli::array<System::Object*>({sourceFileName, destFileName})));
            throw MonoIO::GetException2(p, error);
        }
    }
    
    FileStream* File::Create(System::String* path) {
        return Create2(path, 8192);
    }
    
    FileStream* File::Create2(System::String* path, int32_t bufferSize) {
        return cli::gcnew<FileStream>(path, FileMode::Create, FileAccess::ReadWrite, FileShare::None, bufferSize);
    }
    
    FileStream* File::Create3(System::String* path, int32_t bufferSize, FileOptions options) {
        return Create4(path, bufferSize, options, nullptr);
    }
    
    FileStream* File::Create4(System::String* path, int32_t bufferSize, FileOptions options, System::Security::AccessControl::FileSecurity* fileSecurity) {
        return cli::gcnew<FileStream>(path, FileMode::Create, FileAccess::ReadWrite, FileShare::None, bufferSize, options);
    }
    
    StreamWriter* File::CreateText(System::String* path) {
        return cli::gcnew<StreamWriter>(path, false);
    }
    
    void File::Delete(System::String* path) {
        Path::Validate(path);
        if(Directory::Exists(path)) 
        {
            throw cli::gcnew<System::UnauthorizedAccessException>(Locale::GetText2(_T("{0} is a directory"), (new cli::array<System::Object*>({path}))));
        }
        System::String *DirName = Path::GetDirectoryName(path);
        if((System::String::op_Inequality(DirName, System::String::Empty) && !(Directory::Exists(DirName)))) 
        {
            throw cli::gcnew<DirectoryNotFoundException>(Locale::GetText2(_T("Could not find a part of the path \"{0}\"."), (new cli::array<System::Object*>({path}))));
        }
        System::Security::SecurityManager::EnsureElevatedPermissions();
        MonoIOError error;
        if(!(MonoIO::DeleteFile(path, error))) 
        {
            if(((int32_t)(error) != 2)) 
            {
                throw MonoIO::GetException2(path, error);
            }
        }
    }
    
    bool File::Exists(System::String* path) {
        if((System::String::IsNullOrWhiteSpace(path) || (path->IndexOfAny(Path::InvalidPathChars) >= 0))) 
        {
            return false;
        }
        if(!(System::Security::SecurityManager::CheckElevatedPermissions())) 
        {
            return false;
        }
        MonoIOError error;
        return MonoIO::ExistsFile(path, error);
    }
    
    System::Security::AccessControl::FileSecurity* File::GetAccessControl(System::String* path) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    System::Security::AccessControl::FileSecurity* File::GetAccessControl2(System::String* path, System::Security::AccessControl::AccessControlSections includeSections) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    FileAttributes File::GetAttributes(System::String* path) {
        Path::Validate(path);
        System::Security::SecurityManager::EnsureElevatedPermissions();
        MonoIOError error;
        FileAttributes attrs;
        attrs = MonoIO::GetFileAttributes(path, error);
        if(((int32_t)(error) != 0)) 
        {
            throw MonoIO::GetException2(path, error);
        }
        return attrs;
    }
    
    System::DateTime File::GetCreationTime(System::String* path) {
        MonoIOStat stat;
        MonoIOError error;
        Path::Validate(path);
        System::Security::SecurityManager::EnsureElevatedPermissions();
        if(!(MonoIO::GetFileStat(path, stat, error))) 
        {
            if((((int32_t)(error) ==  3) || ((int32_t)(error) ==  2))) 
            {
                return File::get_DefaultLocalFileTime();
            }
             else 
            {
                throw cli::gcnew<IOException>(path);
            }
        }
        return System::DateTime::FromFileTime(stat->CreationTime);
    }
    
    System::DateTime File::GetCreationTimeUtc(System::String* path) {
        return GetCreationTime(path)->ToUniversalTime();
    }
    
    System::DateTime File::GetLastAccessTime(System::String* path) {
        MonoIOStat stat;
        MonoIOError error;
        Path::Validate(path);
        System::Security::SecurityManager::EnsureElevatedPermissions();
        if(!(MonoIO::GetFileStat(path, stat, error))) 
        {
            if((((int32_t)(error) ==  3) || ((int32_t)(error) ==  2))) 
            {
                return File::get_DefaultLocalFileTime();
            }
             else 
            {
                throw cli::gcnew<IOException>(path);
            }
        }
        return System::DateTime::FromFileTime(stat->LastAccessTime);
    }
    
    System::DateTime File::GetLastAccessTimeUtc(System::String* path) {
        return GetLastAccessTime(path)->ToUniversalTime();
    }
    
    System::DateTime File::GetLastWriteTime(System::String* path) {
        MonoIOStat stat;
        MonoIOError error;
        Path::Validate(path);
        System::Security::SecurityManager::EnsureElevatedPermissions();
        if(!(MonoIO::GetFileStat(path, stat, error))) 
        {
            if((((int32_t)(error) ==  3) || ((int32_t)(error) ==  2))) 
            {
                return File::get_DefaultLocalFileTime();
            }
             else 
            {
                throw cli::gcnew<IOException>(path);
            }
        }
        return System::DateTime::FromFileTime(stat->LastWriteTime);
    }
    
    System::DateTime File::GetLastWriteTimeUtc(System::String* path) {
        return GetLastWriteTime(path)->ToUniversalTime();
    }
    
    void File::Move(System::String* sourceFileName, System::String* destFileName) {
        if((sourceFileName ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("sourceFileName"));
        }
        if((destFileName ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("destFileName"));
        }
        if((sourceFileName->get_Length() ==  0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("An empty file name is not valid."), _T("sourceFileName"));
        }
        if(((sourceFileName->Trim()->get_Length() ==  0) || (sourceFileName->IndexOfAny(Path::InvalidPathChars) != -1))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("The file name is not valid."));
        }
        if((destFileName->get_Length() ==  0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("An empty file name is not valid."), _T("destFileName"));
        }
        if(((destFileName->Trim()->get_Length() ==  0) || (destFileName->IndexOfAny(Path::InvalidPathChars) != -1))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("The file name is not valid."));
        }
        System::Security::SecurityManager::EnsureElevatedPermissions();
        MonoIOError error;
        if(!(MonoIO::Exists(sourceFileName, error))) 
        {
            throw cli::gcnew<FileNotFoundException>(Locale::GetText2(_T("{0} does not exist"), (new cli::array<System::Object*>({sourceFileName}))), sourceFileName);
        }
        System::String *DirName;
        DirName = Path::GetDirectoryName(destFileName);
        if((System::String::op_Inequality(DirName, System::String::Empty) && !(Directory::Exists(DirName)))) 
        {
            throw cli::gcnew<DirectoryNotFoundException>(Locale::GetText(_T("Could not find a part of the path.")));
        }
        if(!(MonoIO::MoveFile(sourceFileName, destFileName, error))) 
        {
            if(((int32_t)(error) ==  183)) 
            {
                throw MonoIO::GetException(error);
            }
             else 
            {
                if(((int32_t)(error) ==  32)) 
                {
                    throw MonoIO::GetException2(sourceFileName, error);
                }
            }
            throw MonoIO::GetException(error);
        }
    }
    
    FileStream* File::Open(System::String* path, FileMode mode) {
        return cli::gcnew<FileStream>(path, mode, ((int32_t)(mode) ==  6) ? FileAccess::Write : FileAccess::ReadWrite, FileShare::None);
    }
    
    FileStream* File::Open2(System::String* path, FileMode mode, FileAccess access) {
        return cli::gcnew<FileStream>(path, mode, access, FileShare::None);
    }
    
    FileStream* File::Open3(System::String* path, FileMode mode, FileAccess access, FileShare share) {
        return cli::gcnew<FileStream>(path, mode, access, share);
    }
    
    FileStream* File::OpenRead(System::String* path) {
        return cli::gcnew<FileStream>(path, FileMode::Open, FileAccess::Read, FileShare::Read);
    }
    
    StreamReader* File::OpenText(System::String* path) {
        return cli::gcnew<StreamReader>(path);
    }
    
    FileStream* File::OpenWrite(System::String* path) {
        return cli::gcnew<FileStream>(path, FileMode::OpenOrCreate, FileAccess::Write, FileShare::None);
    }
    
    void File::Replace(System::String* sourceFileName, System::String* destinationFileName, System::String* destinationBackupFileName) {
        Replace2(sourceFileName, destinationFileName, destinationBackupFileName, false);
    }
    
    void File::Replace2(System::String* sourceFileName, System::String* destinationFileName, System::String* destinationBackupFileName, bool ignoreMetadataErrors) {
        MonoIOError error;
        if((sourceFileName ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("sourceFileName"));
        }
        if((destinationFileName ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("destinationFileName"));
        }
        if(((sourceFileName->Trim()->get_Length() ==  0) || (sourceFileName->IndexOfAny(Path::InvalidPathChars) != -1))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("sourceFileName"));
        }
        if(((destinationFileName->Trim()->get_Length() ==  0) || (destinationFileName->IndexOfAny(Path::InvalidPathChars) != -1))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("destinationFileName"));
        }
        System::String *fullSource = Path::GetFullPath(sourceFileName);
        System::String *fullDest = Path::GetFullPath(destinationFileName);
        if(MonoIO::ExistsDirectory(fullSource, error)) 
        {
            throw cli::gcnew<IOException>(Locale::GetText2(_T("{0} is a directory"), (new cli::array<System::Object*>({sourceFileName}))));
        }
        if(MonoIO::ExistsDirectory(fullDest, error)) 
        {
            throw cli::gcnew<IOException>(Locale::GetText2(_T("{0} is a directory"), (new cli::array<System::Object*>({destinationFileName}))));
        }
        if(!(Exists(fullSource))) 
        {
            throw cli::gcnew<FileNotFoundException>(Locale::GetText2(_T("{0} does not exist"), (new cli::array<System::Object*>({sourceFileName}))), sourceFileName);
        }
        if(!(Exists(fullDest))) 
        {
            throw cli::gcnew<FileNotFoundException>(Locale::GetText2(_T("{0} does not exist"), (new cli::array<System::Object*>({destinationFileName}))), destinationFileName);
        }
        if(System::String::op_Equality(fullSource, fullDest)) 
        {
            throw cli::gcnew<IOException>(Locale::GetText(_T("Source and destination arguments are the same file.")));
        }
        System::String *fullBackup = nullptr;
        if((destinationBackupFileName != nullptr)) 
        {
            if(((destinationBackupFileName->Trim()->get_Length() ==  0) || (destinationBackupFileName->IndexOfAny(Path::InvalidPathChars) != -1))) 
            {
                throw cli::gcnew<System::ArgumentException>(_T("destinationBackupFileName"));
            }
            fullBackup = Path::GetFullPath(destinationBackupFileName);
            if(MonoIO::ExistsDirectory(fullBackup, error)) 
            {
                throw cli::gcnew<IOException>(Locale::GetText2(_T("{0} is a directory"), (new cli::array<System::Object*>({destinationBackupFileName}))));
            }
            if(System::String::op_Equality(fullSource, fullBackup)) 
            {
                throw cli::gcnew<IOException>(Locale::GetText(_T("Source and backup arguments are the same file.")));
            }
            if(System::String::op_Equality(fullDest, fullBackup)) 
            {
                throw cli::gcnew<IOException>(Locale::GetText(_T("Destination and backup arguments are the same file.")));
            }
        }
        if(!(MonoIO::ReplaceFile(fullSource, fullDest, fullBackup, ignoreMetadataErrors, error))) 
        {
            throw MonoIO::GetException(error);
        }
    }
    
    void File::SetAccessControl(System::String* path, System::Security::AccessControl::FileSecurity* fileSecurity) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    void File::SetAttributes(System::String* path, FileAttributes fileAttributes) {
        MonoIOError error;
        Path::Validate(path);
        if(!(MonoIO::SetFileAttributes(path, fileAttributes, error))) 
        {
            throw MonoIO::GetException2(path, error);
        }
    }
    
    void File::SetCreationTime(System::String* path, System::DateTime creationTime) {
        MonoIOError error;
        Path::Validate(path);
        if(!(MonoIO::Exists(path, error))) 
        {
            throw MonoIO::GetException2(path, error);
        }
        if(!(MonoIO::SetCreationTime(path, creationTime, error))) 
        {
            throw MonoIO::GetException2(path, error);
        }
    }
    
    void File::SetCreationTimeUtc(System::String* path, System::DateTime creationTimeUtc) {
        SetCreationTime(path, creationTimeUtc->ToLocalTime());
    }
    
    void File::SetLastAccessTime(System::String* path, System::DateTime lastAccessTime) {
        MonoIOError error;
        Path::Validate(path);
        if(!(MonoIO::Exists(path, error))) 
        {
            throw MonoIO::GetException2(path, error);
        }
        if(!(MonoIO::SetLastAccessTime(path, lastAccessTime, error))) 
        {
            throw MonoIO::GetException2(path, error);
        }
    }
    
    void File::SetLastAccessTimeUtc(System::String* path, System::DateTime lastAccessTimeUtc) {
        SetLastAccessTime(path, lastAccessTimeUtc->ToLocalTime());
    }
    
    void File::SetLastWriteTime(System::String* path, System::DateTime lastWriteTime) {
        MonoIOError error;
        Path::Validate(path);
        if(!(MonoIO::Exists(path, error))) 
        {
            throw MonoIO::GetException2(path, error);
        }
        if(!(MonoIO::SetLastWriteTime(path, lastWriteTime, error))) 
        {
            throw MonoIO::GetException2(path, error);
        }
    }
    
    void File::SetLastWriteTimeUtc(System::String* path, System::DateTime lastWriteTimeUtc) {
        SetLastWriteTime(path, lastWriteTimeUtc->ToLocalTime());
    }
    
    cli::array<unsigned char>* File::ReadAllBytes(System::String* path) {
        {
            /* USING - BLOCK */
            auto s = OpenRead(path);
            cli::using_guard{s};
            int64_t size = s->get_Length_ddb8b0d061db5350();
            if((size > 2147483647L)) 
            {
                throw cli::gcnew<IOException>(_T("Reading more than 2GB with this call is not supported"));
            }
            int32_t pos = 0;
            int32_t count = (int32_t)size;
            cli::array<unsigned char> *result = (new cli::array<unsigned char>((int32_t)size));
            while((count > 0)) {
                int32_t n = s->Read_c0d6dde3943b413e(result, pos, count);
                if((n ==  0)) 
                {
                    throw cli::gcnew<IOException>(_T("Unexpected end of stream"));
                }
                (pos = pos + n);
                (count = count - n);
            }
            return result;
        }
    }
    
    cli::array<System::String*>* File::ReadAllLines(System::String* path) {
        {
            /* USING - BLOCK */
            auto reader = File::OpenText(path);
            cli::using_guard{reader};
            return ReadAllLines3(reader);
        }
    }
    
    cli::array<System::String*>* File::ReadAllLines2(System::String* path, System::Text::Encoding* encoding) {
        {
            /* USING - BLOCK */
            auto reader = cli::gcnew<StreamReader>(path, encoding);
            cli::using_guard{reader};
            return ReadAllLines3(reader);
        }
    }
    
    cli::array<System::String*>* File::ReadAllLines3(StreamReader* reader) {
        System::Collections::Generic::List<System::String*> *list = cli::gcnew<System::Collections::Generic::List<System::String*>>();
        while(!(reader->get_EndOfStream())) list->Add(reader->ReadLine_51552a49261f929e());
        return list->ToArray();
    }
    
    System::String* File::ReadAllText(System::String* path) {
        {
            /* USING - BLOCK */
            auto sr = cli::gcnew<StreamReader>(path);
            cli::using_guard{sr};
            return sr->ReadToEnd_f683943dd5002e1e();
        }
    }
    
    System::String* File::ReadAllText2(System::String* path, System::Text::Encoding* encoding) {
        {
            /* USING - BLOCK */
            auto sr = cli::gcnew<StreamReader>(path, encoding);
            cli::using_guard{sr};
            return sr->ReadToEnd_f683943dd5002e1e();
        }
    }
    
    void File::WriteAllBytes(System::String* path, cli::array<unsigned char>* bytes) {
        {
            /* USING - BLOCK */
            auto stream = File::Create(path);
            cli::using_guard{stream};
            stream->Write_1f8a1dbe71b0eb89(bytes, 0, bytes->get_Length());
        }
    }
    
    void File::WriteAllLines(System::String* path, cli::array<System::String*>* contents) {
        {
            /* USING - BLOCK */
            auto writer = cli::gcnew<StreamWriter>(path);
            cli::using_guard{writer};
            WriteAllLines3(writer, contents);
        }
    }
    
    void File::WriteAllLines2(System::String* path, cli::array<System::String*>* contents, System::Text::Encoding* encoding) {
        {
            /* USING - BLOCK */
            auto writer = cli::gcnew<StreamWriter>(path, false, encoding);
            cli::using_guard{writer};
            WriteAllLines3(writer, contents);
        }
    }
    
    void File::WriteAllLines3(StreamWriter* writer, cli::array<System::String*>* contents) {
        for(auto tmp_244 : contents) {
            auto line = cli::cast<System::String*>(tmp_244);
            writer->WriteLine_27fb29d2c5b390c7(line);
        }
    }
    
    void File::WriteAllText(System::String* path, System::String* contents) {
        WriteAllText2(path, contents, System::Text::Encoding::get_UTF8Unmarked());
    }
    
    void File::WriteAllText2(System::String* path, System::String* contents, System::Text::Encoding* encoding) {
        {
            /* USING - BLOCK */
            auto sw = cli::gcnew<StreamWriter>(path, false, encoding);
            cli::using_guard{sw};
            sw->Write_dcf5e45abd9e11c4(contents);
        }
    }
    
    void File::Encrypt(System::String* path) {
        throw cli::gcnew<System::NotSupportedException>(Locale::GetText(_T("File encryption isn\'t supported on any file system.")));
    }
    
    void File::Decrypt(System::String* path) {
        throw cli::gcnew<System::NotSupportedException>(Locale::GetText(_T("File encryption isn\'t supported on any file system.")));
    }
    
    System::Collections::Generic::IEnumerable2<System::String*>* File::ReadLines(System::String* path) {
        return ReadLines3(File::OpenText(path));
    }
    
    System::Collections::Generic::IEnumerable2<System::String*>* File::ReadLines2(System::String* path, System::Text::Encoding* encoding) {
        return ReadLines3(cli::gcnew<StreamReader>(path, encoding));
    }
    
    System::Collections::Generic::IEnumerable2<System::String*>* File::ReadLines3(StreamReader* reader) {
        return (nullptr/*TODO: Implement Yield Expression!*/);
    }
    
    void File::AppendAllLines(System::String* path, System::Collections::Generic::IEnumerable2<System::String*>* contents) {
        Path::Validate(path);
        if((contents ==  nullptr)) 
        {
            return;
        }
        {
            /* USING - BLOCK */
            auto w = cli::gcnew<StreamWriter>(path, true);
            cli::using_guard{w};
            for(auto tmp_245 : contents) {
                auto line = cli::cast<System::String*>(tmp_245);
                w->WriteLine_27fb29d2c5b390c7(line);
            }
        }
    }
    
    void File::AppendAllLines2(System::String* path, System::Collections::Generic::IEnumerable2<System::String*>* contents, System::Text::Encoding* encoding) {
        Path::Validate(path);
        if((contents ==  nullptr)) 
        {
            return;
        }
        {
            /* USING - BLOCK */
            auto w = cli::gcnew<StreamWriter>(path, true, encoding);
            cli::using_guard{w};
            for(auto tmp_246 : contents) {
                auto line = cli::cast<System::String*>(tmp_246);
                w->WriteLine_27fb29d2c5b390c7(line);
            }
        }
    }
    
    void File::WriteAllLines4(System::String* path, System::Collections::Generic::IEnumerable2<System::String*>* contents) {
        Path::Validate(path);
        if((contents ==  nullptr)) 
        {
            return;
        }
        {
            /* USING - BLOCK */
            auto w = cli::gcnew<StreamWriter>(path, false);
            cli::using_guard{w};
            for(auto tmp_247 : contents) {
                auto line = cli::cast<System::String*>(tmp_247);
                w->WriteLine_27fb29d2c5b390c7(line);
            }
        }
    }
    
    void File::WriteAllLines5(System::String* path, System::Collections::Generic::IEnumerable2<System::String*>* contents, System::Text::Encoding* encoding) {
        Path::Validate(path);
        if((contents ==  nullptr)) 
        {
            return;
        }
        {
            /* USING - BLOCK */
            auto w = cli::gcnew<StreamWriter>(path, false, encoding);
            cli::using_guard{w};
            for(auto tmp_248 : contents) {
                auto line = cli::cast<System::String*>(tmp_248);
                w->WriteLine_27fb29d2c5b390c7(line);
            }
        }
    }
    
    System::DateTime File::get_DefaultLocalFileTime() {
        if(((System::Nullable2<System::DateTime>)(cli::unwrap_nullable(defaultLocalFileTime)) ==  nullptr)) 
        {
            defaultLocalFileTime = cli::wrap_nullable(cli::ctor<System::DateTime>(1601, 1, 1)->ToLocalTime());
        }
        return defaultLocalFileTime->get_Value();
    }
    
}}
namespace System { namespace IO {
    
    
    void FileInfo::constructor(System::String* fileName) {
        if((fileName ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("fileName"));
        }
        FileSystemInfo::CheckPath(fileName);
        System::Security::SecurityManager::EnsureElevatedPermissions();
        this->OriginalPath = fileName;
        this->FullPath = Path::GetFullPath(fileName);
    }
    
    void FileInfo::constructor(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
    }
    
    void FileInfo::InternalRefresh_5c7cc70032723c7a() {
        this->exists = File::Exists(this->FullPath);
    }
    
    void FileInfo::Encrypt() {
        throw cli::gcnew<System::NotSupportedException>(Locale::GetText(_T("File encryption isn\'t supported on any file system.")));
    }
    
    void FileInfo::Decrypt() {
        throw cli::gcnew<System::NotSupportedException>(Locale::GetText(_T("File encryption isn\'t supported on any file system.")));
    }
    
    StreamReader* FileInfo::OpenText() {
        return cli::gcnew<StreamReader>(Open2(FileMode::Open, FileAccess::Read));
    }
    
    StreamWriter* FileInfo::CreateText() {
        return cli::gcnew<StreamWriter>(Open2(FileMode::Create, FileAccess::Write));
    }
    
    StreamWriter* FileInfo::AppendText() {
        return cli::gcnew<StreamWriter>(Open2(FileMode::Append, FileAccess::Write));
    }
    
    FileStream* FileInfo::Create() {
        return File::Create(this->FullPath);
    }
    
    FileStream* FileInfo::OpenRead() {
        return Open3(FileMode::Open, FileAccess::Read, FileShare::Read);
    }
    
    FileStream* FileInfo::OpenWrite() {
        return Open2(FileMode::OpenOrCreate, FileAccess::Write);
    }
    
    FileStream* FileInfo::Open(FileMode mode) {
        return Open2(mode, FileAccess::ReadWrite);
    }
    
    FileStream* FileInfo::Open2(FileMode mode, FileAccess access) {
        return Open3(mode, access, FileShare::None);
    }
    
    FileStream* FileInfo::Open3(FileMode mode, FileAccess access, FileShare share) {
        return cli::gcnew<FileStream>(this->FullPath, mode, access, share);
    }
    
    void FileInfo::Delete_2d3445237ba2ed66() {
        MonoIOError error;
        System::Security::SecurityManager::EnsureElevatedPermissions();
        if(!(MonoIO::Exists(this->FullPath, error))) 
        {
            return;
        }
        if(MonoIO::ExistsDirectory(this->FullPath, error)) 
        {
            throw cli::gcnew<System::UnauthorizedAccessException>(cli::concat(_T("Access to the path \""), this->FullPath));
        }
        if(!(MonoIO::DeleteFile(this->FullPath, error))) 
        {
            throw MonoIO::GetException2(this->OriginalPath, error);
        }
    }
    
    void FileInfo::MoveTo(System::String* destFileName) {
        if((destFileName ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("destFileName"));
        }
        if((System::String::op_Equality(destFileName, this->get_Name_34b64716a6d0afcd()) || System::String::op_Equality(destFileName, this->get_FullName_3d8989b544082b48()))) 
        {
            return;
        }
        if(!(File::Exists(this->FullPath))) 
        {
            throw cli::gcnew<FileNotFoundException>();
        }
        File::Move(this->FullPath, destFileName);
        this->FullPath = Path::GetFullPath(destFileName);
    }
    
    FileInfo* FileInfo::CopyTo(System::String* destFileName) {
        return CopyTo2(destFileName, false);
    }
    
    FileInfo* FileInfo::CopyTo2(System::String* destFileName, bool overwrite) {
        if((destFileName ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("destFileName"));
        }
        if((destFileName->get_Length() ==  0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("An empty file name is not valid."), _T("destFileName"));
        }
        System::String *dest = Path::GetFullPath(destFileName);
        if((overwrite && File::Exists(dest))) 
        {
            File::Delete(dest);
        }
        File::Copy(this->FullPath, dest);
        return cli::gcnew<FileInfo>(dest);
    }
    
    System::String* FileInfo::ToString_1636a0751cb9ac11() {
        return this->OriginalPath;
    }
    
    System::Security::AccessControl::FileSecurity* FileInfo::GetAccessControl() {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    System::Security::AccessControl::FileSecurity* FileInfo::GetAccessControl2(System::Security::AccessControl::AccessControlSections includeSections) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    FileInfo* FileInfo::Replace(System::String* destinationFileName, System::String* destinationBackupFileName) {
        System::String *destinationFullPath = nullptr;
        if(!(this->get_Exists_44ccb569427c51d7())) 
        {
            throw cli::gcnew<FileNotFoundException>();
        }
        if((destinationFileName ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("destinationFileName"));
        }
        if((destinationFileName->get_Length() ==  0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("An empty file name is not valid."), _T("destinationFileName"));
        }
        destinationFullPath = Path::GetFullPath(destinationFileName);
        if(!(File::Exists(destinationFullPath))) 
        {
            throw cli::gcnew<FileNotFoundException>();
        }
        FileAttributes attrs = File::GetAttributes(destinationFullPath);
        if(((int32_t)(((int32_t)(attrs) & 1)) ==  1)) 
        {
            throw cli::gcnew<System::UnauthorizedAccessException>();
        }
        if((destinationBackupFileName != nullptr)) 
        {
            if((destinationBackupFileName->get_Length() ==  0)) 
            {
                throw cli::gcnew<System::ArgumentException>(_T("An empty file name is not valid."), _T("destinationBackupFileName"));
            }
            File::Copy2(destinationFullPath, Path::GetFullPath(destinationBackupFileName), true);
        }
        File::Copy2(this->FullPath, destinationFullPath, true);
        File::Delete(this->FullPath);
        return cli::gcnew<FileInfo>(destinationFullPath);
    }
    
    FileInfo* FileInfo::Replace2(System::String* destinationFileName, System::String* destinationBackupFileName, bool ignoreMetadataErrors) {
        return Replace(destinationFileName, destinationBackupFileName);
    }
    
    void FileInfo::SetAccessControl(System::Security::AccessControl::FileSecurity* fileSecurity) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool FileInfo::get_Exists_44ccb569427c51d7() {
        FileSystemInfo::Refresh2(false);
        if(((int32_t)(this->stat->Attributes) ==  (int32_t)(MonoIO::InvalidFileAttributes))) 
        {
            return false;
        }
        if(((int32_t)(((int32_t)(this->stat->Attributes) & 16)) != 0)) 
        {
            return false;
        }
        return this->exists;
    }
    
    System::String* FileInfo::get_Name_34b64716a6d0afcd() {
        return Path::GetFileName(this->FullPath);
    }
    
    bool FileInfo::get_IsReadOnly() {
        if(!(this->get_Exists_44ccb569427c51d7())) 
        {
            throw cli::gcnew<FileNotFoundException>(cli::concat(_T("Could not find file \""), this->OriginalPath), this->OriginalPath);
        }
        return ((int32_t)(((int32_t)(this->stat->Attributes) & 1)) != 0);
    }
    
    bool FileInfo::set_IsReadOnly(bool value) {
        if(!(this->get_Exists_44ccb569427c51d7())) 
        {
            throw cli::gcnew<FileNotFoundException>(cli::concat(_T("Could not find file \""), this->OriginalPath), this->OriginalPath);
        }
        FileAttributes attrs = File::GetAttributes(this->FullPath);
        if(value) 
        {
            (attrs = (FileAttributes)(((int32_t)(attrs) | 1)));
        }
         else 
        {
            (attrs = (FileAttributes)(((int32_t)(attrs) & -2)));
        }
        File::SetAttributes(this->FullPath, attrs);
        return get_IsReadOnly();
    }
    
    int64_t FileInfo::get_Length() {
        if(!(this->get_Exists_44ccb569427c51d7())) 
        {
            throw cli::gcnew<FileNotFoundException>(cli::concat(_T("Could not find file \""), this->OriginalPath), this->OriginalPath);
        }
        return this->stat->Length;
    }
    
    System::String* FileInfo::get_DirectoryName() {
        return Path::GetDirectoryName(this->FullPath);
    }
    
    DirectoryInfo* FileInfo::get_Directory() {
        return cli::gcnew<DirectoryInfo>(this->get_DirectoryName());
    }
    
}}
namespace System { namespace IO {
    
    
    void FileLoadException::constructor() {
        this->set_HResult(-2147024894);
        this->msg = Locale::GetText(_T("I/O Error"));
    }
    
    void FileLoadException::constructor(System::String* message) {
        this->set_HResult(-2147024894);
        this->msg = message;
    }
    
    void FileLoadException::constructor(System::String* message, System::String* fileName) {
        this->set_HResult(-2147024894);
        this->msg = message;
        this->fileName = fileName;
    }
    
    void FileLoadException::constructor(System::String* message, System::Exception* inner) {
        this->set_HResult(-2147024894);
        this->msg = message;
    }
    
    void FileLoadException::constructor(System::String* message, System::String* fileName, System::Exception* inner) {
        this->set_HResult(-2147024894);
        this->msg = message;
        this->fileName = fileName;
    }
    
    void FileLoadException::constructor(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        this->fileName = info->GetString(_T("FileLoad_FileName"));
        this->fusionLog = info->GetString(_T("FileLoad_FusionLog"));
    }
    
    void FileLoadException::GetObjectData_bc9b88d7eb43b6d8(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        IOException::GetObjectData_bc9b88d7eb43b6d8(info, context);
        info->AddValue16(_T("FileLoad_FileName"), this->fileName);
        info->AddValue16(_T("FileLoad_FusionLog"), this->fusionLog);
    }
    
    System::String* FileLoadException::ToString_1636a0751cb9ac11() {
        System::Text::StringBuilder *sb = cli::gcnew<System::Text::StringBuilder>(System::Exception::GetType2()->get_FullName_7e8fa72ba225e1a4());
        sb->AppendFormat3(_T(": {0}"), this->msg);
        if((this->fileName != nullptr)) 
        {
            sb->AppendFormat3(_T(" : {0}"), this->fileName);
        }
        if((this->get_InnerException() != nullptr)) 
        {
            sb->AppendFormat3(_T(" ----> {0}"), this->get_InnerException());
        }
        if((this->get_StackTrace_f3fc28619b4f921() != nullptr)) 
        {
            sb->Append2(System::Environment::get_NewLine());
            sb->Append2(this->get_StackTrace_f3fc28619b4f921());
        }
        return sb->ToString_1636a0751cb9ac11();
    }
    
    System::String* FileLoadException::get_Message_d211df4045b57cbf() {
        return this->msg;
    }
    
    System::String* FileLoadException::get_FileName() {
        return this->fileName;
    }
    
    System::String* FileLoadException::get_FusionLog() {
        return this->fusionLog;
    }
    
}}
namespace System { namespace IO {
    
    
    void FileNotFoundException::constructor() {
        this->set_HResult(-2146232799);
    }
    
    void FileNotFoundException::constructor(System::String* message) {
        this->set_HResult(-2146232799);
    }
    
    void FileNotFoundException::constructor(System::String* message, System::Exception* innerException) {
        this->set_HResult(-2146232799);
    }
    
    void FileNotFoundException::constructor(System::String* message, System::String* fileName) {
        this->set_HResult(-2146232799);
        this->fileName = fileName;
    }
    
    void FileNotFoundException::constructor(System::String* message, System::String* fileName, System::Exception* innerException) {
        this->set_HResult(-2146232799);
        this->fileName = fileName;
    }
    
    void FileNotFoundException::constructor(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        this->fileName = info->GetString(_T("FileNotFound_FileName"));
        this->fusionLog = info->GetString(_T("FileNotFound_FusionLog"));
    }
    
    void FileNotFoundException::GetObjectData_bc9b88d7eb43b6d8(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        IOException::GetObjectData_bc9b88d7eb43b6d8(info, context);
        info->AddValue16(_T("FileNotFound_FileName"), this->fileName);
        info->AddValue16(_T("FileNotFound_FusionLog"), this->fusionLog);
    }
    
    System::String* FileNotFoundException::ToString_1636a0751cb9ac11() {
        System::Text::StringBuilder *sb = cli::gcnew<System::Text::StringBuilder>(System::Exception::GetType2()->get_FullName_7e8fa72ba225e1a4());
        sb->AppendFormat3(_T(": {0}"), this->get_Message_d211df4045b57cbf());
        if(((this->fileName != nullptr) && (this->fileName->get_Length() > 0))) 
        {
            sb->Append2(System::Environment::get_NewLine());
            sb->AppendFormat3(_T("File name: \'{0}\'"), this->fileName);
        }
        if((this->get_InnerException() != nullptr)) 
        {
            sb->AppendFormat3(_T(" ---> {0}"), this->get_InnerException());
        }
        if((this->get_StackTrace_f3fc28619b4f921() != nullptr)) 
        {
            sb->Append2(System::Environment::get_NewLine());
            sb->Append2(this->get_StackTrace_f3fc28619b4f921());
        }
        return sb->ToString_1636a0751cb9ac11();
    }
    
    System::String* FileNotFoundException::get_FileName() {
        return this->fileName;
    }
    
    System::String* FileNotFoundException::get_FusionLog() {
        return this->fusionLog;
    }
    
    System::String* FileNotFoundException::get_Message_d211df4045b57cbf() {
        if((IOException::message ==  nullptr)) 
        {
            if((this->fileName != nullptr)) 
            {
                System::String *message = System::String::Format6(System::Globalization::CultureInfo::get_CurrentCulture(), _T("Could not load file or assembly \'{0}\' or one of its dependencies. The system cannot find the file specified."), (new cli::array<System::Object*>({this->fileName})));
                return message;
            }
        }
        return IOException::message;
    }
    
}}
namespace System { namespace IO {
    
    cli::array<unsigned char>*  FileStream::buf_recycle;
    System::Object*  FileStream::buf_recycle_lock;
    
    FileStream::FileStream()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void FileStream::constructor(void* handle, FileAccess access) {
    }
    
    void FileStream::constructor(void* handle, FileAccess access, bool ownsHandle) {
    }
    
    void FileStream::constructor(void* handle, FileAccess access, bool ownsHandle, int32_t bufferSize) {
    }
    
    void FileStream::constructor(void* handle, FileAccess access, bool ownsHandle, int32_t bufferSize, bool isAsync) {
    }
    
    void FileStream::constructor(void* handle, FileAccess access, bool ownsHandle, int32_t bufferSize, bool isAsync, bool isZeroSize) {
        this->handle = MonoIO::InvalidHandle;
        if(::System::IntPtr::op_Equality(handle, this->handle)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("handle"), Locale::GetText(_T("Invalid.")));
        }
        if((((int32_t)(access) < 1) || ((int32_t)(access) > 3))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("access"));
        }
        MonoIOError error;
        MonoFileType ftype = MonoIO::GetFileType(handle, error);
        if(((int32_t)(error) != 0)) 
        {
            throw MonoIO::GetException2(this->name, error);
        }
        if(((int32_t)(ftype) ==  0)) 
        {
            throw cli::gcnew<IOException>(_T("Invalid handle."));
        }
         else 
        {
            if(((int32_t)(ftype) ==  1)) 
            {
                this->canseek = true;
            }
             else 
            {
                this->canseek = false;
            }
        }
        this->handle = handle;
        ExposeHandle();
        this->access = access;
        this->owner = ownsHandle;
        this->async = isAsync;
        this->anonymous = false;
        if(this->canseek) 
        {
            this->buf_start = MonoIO::Seek(handle, 0L, SeekOrigin::Current, error);
            if(((int32_t)(error) != 0)) 
            {
                throw MonoIO::GetException2(this->name, error);
            }
        }
        this->append_startpos = 0L;
    }
    
    void FileStream::constructor(System::String* path, FileMode mode) {
    }
    
    void FileStream::constructor(System::String* path, FileMode mode, FileAccess access) {
    }
    
    void FileStream::constructor(System::String* path, FileMode mode, FileAccess access, FileShare share) {
    }
    
    void FileStream::constructor(System::String* path, FileMode mode, FileAccess access, FileShare share, int32_t bufferSize) {
    }
    
    void FileStream::constructor(System::String* path, FileMode mode, FileAccess access, FileShare share, int32_t bufferSize, bool useAsync) {
    }
    
    void FileStream::constructor(System::String* path, FileMode mode, FileAccess access, FileShare share, int32_t bufferSize, FileOptions options) {
    }
    
    void FileStream::constructor(Microsoft::Win32::SafeHandles::SafeFileHandle* handle, FileAccess access) {
    }
    
    void FileStream::constructor(Microsoft::Win32::SafeHandles::SafeFileHandle* handle, FileAccess access, int32_t bufferSize) {
    }
    
    void FileStream::constructor(Microsoft::Win32::SafeHandles::SafeFileHandle* handle, FileAccess access, int32_t bufferSize, bool isAsync) {
        this->safeHandle = handle;
    }
    
    void FileStream::constructor(System::String* path, FileMode mode, System::Security::AccessControl::FileSystemRights rights, FileShare share, int32_t bufferSize, FileOptions options) {
    }
    
    void FileStream::constructor(System::String* path, FileMode mode, System::Security::AccessControl::FileSystemRights rights, FileShare share, int32_t bufferSize, FileOptions options, System::Security::AccessControl::FileSecurity* fileSecurity) {
    }
    
    void FileStream::constructor(System::String* path, FileMode mode, FileAccess access, FileShare share, int32_t bufferSize, bool isAsync, bool anonymous) {
    }
    
    void FileStream::constructor(System::String* path, FileMode mode, FileAccess access, FileShare share, int32_t bufferSize, bool anonymous, FileOptions options) {
        if((path ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("path"));
        }
        if((path->get_Length() ==  0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Path is empty"));
        }
        this->anonymous = anonymous;
        (share = (FileShare)(((int32_t)(share) & -17)));
        if((bufferSize <= 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("bufferSize"), _T("Positive number required."));
        }
        if((((int32_t)(mode) < 1) || ((int32_t)(mode) > 6))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("mode"), _T("Enum value was out of legal range."));
        }
        if((((int32_t)(access) < 1) || ((int32_t)(access) > 3))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("access"), _T("Enum value was out of legal range."));
        }
        if((((int32_t)(share) < 0) || ((int32_t)(share) > 7))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("share"), _T("Enum value was out of legal range."));
        }
        if((path->IndexOfAny(Path::InvalidPathChars) != -1)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Name has invalid chars"));
        }
        if(Directory::Exists(path)) 
        {
            System::String *msg = Locale::GetText(_T("Access to the path \'{0}\' is denied."));
            throw cli::gcnew<System::UnauthorizedAccessException>(System::String::Format2(msg, GetSecureFileName2(path, false)));
        }
        if((((int32_t)(mode) ==  6) && ((int32_t)(((int32_t)(access) & 1)) ==  1))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Append access can be requested only in write-only mode."));
        }
        if((((int32_t)(((int32_t)(access) & 2)) ==  0) && (((int32_t)(mode) != 3) && ((int32_t)(mode) != 4)))) 
        {
            System::String *msg = Locale::GetText(_T("Combining FileMode: {0} with FileAccess: {1} is invalid."));
            throw cli::gcnew<System::ArgumentException>(System::String::Format3(msg, cli::box(access), cli::box(mode)));
        }
        System::Security::SecurityManager::EnsureElevatedPermissions();
        System::String *dname;
        if((((int32_t)(Path::DirectorySeparatorChar) != 47) && (path->IndexOf4(u'/') >= 0))) 
        {
            dname = Path::GetDirectoryName(Path::GetFullPath(path));
        }
         else 
        {
            dname = Path::GetDirectoryName(path);
        }
        if((dname->get_Length() > 0)) 
        {
            System::String *fp = Path::GetFullPath(dname);
            if(!(Directory::Exists(fp))) 
            {
                System::String *msg = Locale::GetText(_T("Could not find a part of the path \"{0}\"."));
                System::String *fname = anonymous ? dname : Path::GetFullPath(path);
                throw cli::gcnew<DirectoryNotFoundException>(System::String::Format2(msg, fname));
            }
        }
        if(((((((int32_t)(access) ==  1) && ((int32_t)(mode) != 2)) && ((int32_t)(mode) != 4)) && ((int32_t)(mode) != 1)) && !(File::Exists(path)))) 
        {
            System::String *msg = Locale::GetText(_T("Could not find file \"{0}\"."));
            System::String *fname = GetSecureFileName(path);
            throw cli::gcnew<FileNotFoundException>(System::String::Format2(msg, fname), fname);
        }
        if(!(anonymous)) 
        {
            this->name = path;
        }
        MonoIOError error;
        this->handle = MonoIO::Open(path, mode, access, share, options, error);
        if(::System::IntPtr::op_Equality(this->handle, MonoIO::InvalidHandle)) 
        {
            throw MonoIO::GetException2(GetSecureFileName(path), error);
        }
        this->access = access;
        this->owner = true;
        if(((int32_t)(MonoIO::GetFileType(this->handle, error)) ==  1)) 
        {
            this->canseek = true;
            this->async = ((int32_t)(((int32_t)(options) & 1073741824)) != 0);
        }
         else 
        {
            this->canseek = false;
            this->async = false;
        }
        if(((((int32_t)(access) ==  1) && this->canseek) && (bufferSize ==  4096))) 
        {
            int64_t len = this->get_Length_ddb8b0d061db5350();
            if(((int64_t)(bufferSize) > len)) 
            {
                bufferSize = (int32_t)(len < 1000L) ? 1000L : len;
            }
        }
        InitBuffer(bufferSize, false);
        if(((int32_t)(mode) ==  6)) 
        {
            this->Seek_df5b3eadfe9adf31(0L, SeekOrigin::End);
            this->append_startpos = this->get_Position_5e75d5c458401f13();
        }
         else 
        {
            this->append_startpos = 0L;
        }
    }
    
    void FileStream::static_constructor() {
    }
    
    void FileStream::Finalize_8d87242530ad8015() {
        {
            cli::finally_guard([&]() {
                Finalize_b946fbc32e26afd6();
            });
            Stream::Dispose_b215be19126499b0(false);
        }
    }
    
    void FileStream::ExposeHandle() {
        this->safeHandle = cli::gcnew<Microsoft::Win32::SafeHandles::SafeFileHandle>(this->handle, false);
        FlushBuffer2();
        InitBuffer(0, true);
    }
    
    int32_t FileStream::ReadByte_61a294e42318f99() {
        if(::System::IntPtr::op_Equality(this->handle, MonoIO::InvalidHandle)) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("Stream has been closed"));
        }
        if(!(this->get_CanRead_50a10d564be8aaa2())) 
        {
            throw cli::gcnew<System::NotSupportedException>(_T("Stream does not support reading"));
        }
        if((this->buf_size ==  0)) 
        {
            int32_t n = ReadData(this->handle, this->buf, 0, 1);
            if((n ==  0)) 
            {
                return -1;
            }
             else 
            {
                return (int32_t)(this->buf->at(0));
            }
        }
         else 
        {
            if((this->buf_offset >= this->buf_length)) 
            {
                RefillBuffer();
                if((this->buf_length ==  0)) 
                {
                    return -1;
                }
            }
        }
        return (int32_t)(this->buf->at(this->buf_offset++));
    }
    
    void FileStream::WriteByte_4404d6329af3b6d5(unsigned char value) {
        if(::System::IntPtr::op_Equality(this->handle, MonoIO::InvalidHandle)) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("Stream has been closed"));
        }
        if(!(this->get_CanWrite_c8955eadfc77124c())) 
        {
            throw cli::gcnew<System::NotSupportedException>(_T("Stream does not support writing"));
        }
        if((this->buf_offset ==  this->buf_size)) 
        {
            FlushBuffer2();
        }
        if((this->buf_size ==  0)) 
        {
            this->buf->at(0) = value;
            this->buf_dirty = true;
            this->buf_length = 1;
            FlushBuffer2();
            return;
        }
        this->buf->at(this->buf_offset++) = value;
        if((this->buf_offset > this->buf_length)) 
        {
            this->buf_length = this->buf_offset;
        }
        this->buf_dirty = true;
    }
    
    int32_t FileStream::Read_c0d6dde3943b413e(cli::array<unsigned char>* array, int32_t offset, int32_t count) {
        if(::System::IntPtr::op_Equality(this->handle, MonoIO::InvalidHandle)) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("Stream has been closed"));
        }
        if((array ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("array"));
        }
        if(!(this->get_CanRead_50a10d564be8aaa2())) 
        {
            throw cli::gcnew<System::NotSupportedException>(_T("Stream does not support reading"));
        }
        int32_t len = array->get_Length();
        if((offset < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("offset"), _T("< 0"));
        }
        if((count < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("count"), _T("< 0"));
        }
        if((offset > len)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("destination offset is beyond array size"));
        }
        if((offset > (len - count))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Reading would overrun buffer"));
        }
        if(this->async) 
        {
            System::IAsyncResult *ares = Stream::BeginRead_783f127b729b2f0a(array, offset, count, nullptr, nullptr);
            return Stream::EndRead_fffd36c36fbcca5b(ares);
        }
        return ReadInternal(array, offset, count);
    }
    
    int32_t FileStream::ReadInternal(cli::array<unsigned char>* dest, int32_t offset, int32_t count) {
        int32_t n = ReadSegment(dest, offset, count);
        if((n ==  count)) 
        {
            return count;
        }
        int32_t copied = n;
        (count = count - n);
        if((count > this->buf_size)) 
        {
            FlushBuffer2();
            n = ReadData(this->handle, dest, (offset + n), count);
            (this->buf_start = this->buf_start + (int64_t)(n));
        }
         else 
        {
            RefillBuffer();
            n = ReadSegment(dest, (offset + copied), count);
        }
        return (copied + n);
    }
    
    System::IAsyncResult* FileStream::BeginRead_783f127b729b2f0a(cli::array<unsigned char>* array, int32_t offset, int32_t numBytes, System::AsyncCallback* userCallback, System::Object* stateObject) {
        if(::System::IntPtr::op_Equality(this->handle, MonoIO::InvalidHandle)) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("Stream has been closed"));
        }
        if(!(this->get_CanRead_50a10d564be8aaa2())) 
        {
            throw cli::gcnew<System::NotSupportedException>(_T("This stream does not support reading"));
        }
        if((array ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("array"));
        }
        if((numBytes < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("numBytes"), _T("Must be >= 0"));
        }
        if((offset < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("offset"), _T("Must be >= 0"));
        }
        if((numBytes > (array->get_Length() - offset))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Buffer too small. numBytes/offset wrong."));
        }
        if(!(this->async)) 
        {
            return Stream::BeginRead_783f127b729b2f0a(array, offset, numBytes, userCallback, stateObject);
        }
        ReadDelegate *r = cli::bind(this, &FileStream::ReadInternal);
        return r->BeginInvoke(array, offset, numBytes, userCallback, stateObject);
    }
    
    int32_t FileStream::EndRead_fffd36c36fbcca5b(System::IAsyncResult* asyncResult) {
        if((asyncResult ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("asyncResult"));
        }
        if(!(this->async)) 
        {
            return Stream::EndRead_fffd36c36fbcca5b(asyncResult);
        }
        System::Runtime::Remoting::Messaging::AsyncResult *ares = cli::as<System::Runtime::Remoting::Messaging::AsyncResult*>(asyncResult);
        if((ares ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Invalid IAsyncResult"), _T("asyncResult"));
        }
        ReadDelegate *r = cli::as<ReadDelegate*>(ares->get_AsyncDelegate_eba6a70b3de54142());
        if((r ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Invalid IAsyncResult"), _T("asyncResult"));
        }
        return r->EndInvoke(asyncResult);
    }
    
    void FileStream::Write_1f8a1dbe71b0eb89(cli::array<unsigned char>* array, int32_t offset, int32_t count) {
        if(::System::IntPtr::op_Equality(this->handle, MonoIO::InvalidHandle)) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("Stream has been closed"));
        }
        if((array ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("array"));
        }
        if((offset < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("offset"), _T("< 0"));
        }
        if((count < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("count"), _T("< 0"));
        }
        if((offset > (array->get_Length() - count))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Reading would overrun buffer"));
        }
        if(!(this->get_CanWrite_c8955eadfc77124c())) 
        {
            throw cli::gcnew<System::NotSupportedException>(_T("Stream does not support writing"));
        }
        if(this->async) 
        {
            System::IAsyncResult *ares = Stream::BeginWrite_85b245acef3a8d4a(array, offset, count, nullptr, nullptr);
            Stream::EndWrite_4a9b8c2a22f9c4e3(ares);
            return;
        }
        WriteInternal(array, offset, count);
    }
    
    void FileStream::WriteInternal(cli::array<unsigned char>* src, int32_t offset, int32_t count) {
        if((count > this->buf_size)) 
        {
            MonoIOError error;
            FlushBuffer2();
            int32_t wcount = count;
            while((wcount > 0)) {
                int32_t n = MonoIO::Write(this->handle, src, offset, wcount, error);
                if(((int32_t)(error) != 0)) 
                {
                    throw MonoIO::GetException2(GetSecureFileName(this->name), error);
                }
                (wcount = wcount - n);
                (offset = offset + n);
            }
            (this->buf_start = this->buf_start + (int64_t)(count));
        }
         else 
        {
            int32_t copied = 0;
            while((count > 0)) {
                int32_t n = WriteSegment(src, (offset + copied), count);
                (copied = copied + n);
                (count = count - n);
                if((count ==  0)) 
                {
                    break;
                }
                FlushBuffer2();
            }
        }
    }
    
    System::IAsyncResult* FileStream::BeginWrite_85b245acef3a8d4a(cli::array<unsigned char>* array, int32_t offset, int32_t numBytes, System::AsyncCallback* userCallback, System::Object* stateObject) {
        if(::System::IntPtr::op_Equality(this->handle, MonoIO::InvalidHandle)) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("Stream has been closed"));
        }
        if(!(this->get_CanWrite_c8955eadfc77124c())) 
        {
            throw cli::gcnew<System::NotSupportedException>(_T("This stream does not support writing"));
        }
        if((array ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("array"));
        }
        if((numBytes < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("numBytes"), _T("Must be >= 0"));
        }
        if((offset < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("offset"), _T("Must be >= 0"));
        }
        if((numBytes > (array->get_Length() - offset))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("array too small. numBytes/offset wrong."));
        }
        if(!(this->async)) 
        {
            return Stream::BeginWrite_85b245acef3a8d4a(array, offset, numBytes, userCallback, stateObject);
        }
        FileStreamAsyncResult *result = cli::gcnew<FileStreamAsyncResult>(userCallback, stateObject);
        result->BytesRead = -1;
        result->Count = numBytes;
        result->OriginalCount = numBytes;
        if(this->buf_dirty) 
        {
            MemoryStream *ms = cli::gcnew<MemoryStream>();
            FlushBuffer(ms);
            ms->Write_1f8a1dbe71b0eb89(array, offset, numBytes);
            offset = 0;
            numBytes = (int32_t)ms->get_Length_ddb8b0d061db5350();
        }
        WriteDelegate *w = cli::bind(this, &FileStream::WriteInternal);
        return w->BeginInvoke(array, offset, numBytes, userCallback, stateObject);
    }
    
    void FileStream::EndWrite_4a9b8c2a22f9c4e3(System::IAsyncResult* asyncResult) {
        if((asyncResult ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("asyncResult"));
        }
        if(!(this->async)) 
        {
            Stream::EndWrite_4a9b8c2a22f9c4e3(asyncResult);
            return;
        }
        System::Runtime::Remoting::Messaging::AsyncResult *ares = cli::as<System::Runtime::Remoting::Messaging::AsyncResult*>(asyncResult);
        if((ares ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Invalid IAsyncResult"), _T("asyncResult"));
        }
        WriteDelegate *w = cli::as<WriteDelegate*>(ares->get_AsyncDelegate_eba6a70b3de54142());
        if((w ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Invalid IAsyncResult"), _T("asyncResult"));
        }
        w->EndInvoke(asyncResult);
        return;
    }
    
    int64_t FileStream::Seek_df5b3eadfe9adf31(int64_t offset, SeekOrigin origin) {
        int64_t pos;
        if(::System::IntPtr::op_Equality(this->handle, MonoIO::InvalidHandle)) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("Stream has been closed"));
        }
        if((this->get_CanSeek_8c8861ce02c6bdeb() ==  false)) 
        {
            throw cli::gcnew<System::NotSupportedException>(_T("The stream does not support seeking"));
        }
        switch(origin) {
            case SeekOrigin::End: case_1110: {
                pos = (this->get_Length_ddb8b0d061db5350() + offset);
                break;
            }
            case SeekOrigin::Current: case_1111: {
                pos = (this->get_Position_5e75d5c458401f13() + offset);
                break;
            }
            case SeekOrigin::Begin: case_1112: {
                pos = offset;
                break;
            }
            default: case_1113: {
                throw cli::gcnew<System::ArgumentException>(_T("origin"), _T("Invalid SeekOrigin"));
            }
        }
        if((pos < 0L)) 
        {
            throw cli::gcnew<IOException>(_T("Attempted to Seek before the beginning of the stream"));
        }
        if((pos < this->append_startpos)) 
        {
            throw cli::gcnew<IOException>(_T("Can\'t seek back over pre-existing data in append mode"));
        }
        FlushBuffer2();
        MonoIOError error;
        this->buf_start = MonoIO::Seek(this->handle, pos, SeekOrigin::Begin, error);
        if(((int32_t)(error) != 0)) 
        {
            throw MonoIO::GetException2(GetSecureFileName(this->name), error);
        }
        return this->buf_start;
    }
    
    void FileStream::SetLength_18d421048f3d4df5(int64_t value) {
        if(::System::IntPtr::op_Equality(this->handle, MonoIO::InvalidHandle)) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("Stream has been closed"));
        }
        if((this->get_CanSeek_8c8861ce02c6bdeb() ==  false)) 
        {
            throw cli::gcnew<System::NotSupportedException>(_T("The stream does not support seeking"));
        }
        if((this->get_CanWrite_c8955eadfc77124c() ==  false)) 
        {
            throw cli::gcnew<System::NotSupportedException>(_T("The stream does not support writing"));
        }
        if((value < 0L)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("value is less than 0"));
        }
        FileStream::Flush_132821400030c993();
        MonoIOError error;
        MonoIO::SetLength(this->handle, value, error);
        if(((int32_t)(error) != 0)) 
        {
            throw MonoIO::GetException2(GetSecureFileName(this->name), error);
        }
        if((this->get_Position_5e75d5c458401f13() > value)) 
        {
            this->set_Position_cfe1def757785ad(value);
        }
    }
    
    void FileStream::Flush_132821400030c993() {
        if(::System::IntPtr::op_Equality(this->handle, MonoIO::InvalidHandle)) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("Stream has been closed"));
        }
        FlushBuffer2();
    }
    
    void FileStream::Flush_45c7245c20dbb092(bool flushToDisk) {
        FlushBuffer2();
        if(flushToDisk) 
        {
            MonoIOError error;
            MonoIO::Flush(this->handle, error);
        }
    }
    
    void FileStream::Lock_5f3c7fa1bcb2cdc0(int64_t position, int64_t length) {
        if(::System::IntPtr::op_Equality(this->handle, MonoIO::InvalidHandle)) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("Stream has been closed"));
        }
        if((position < 0L)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("position must not be negative"));
        }
        if((length < 0L)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("length must not be negative"));
        }
        if(::System::IntPtr::op_Equality(this->handle, MonoIO::InvalidHandle)) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("Stream has been closed"));
        }
        MonoIOError error;
        MonoIO::Lock(this->handle, position, length, error);
        if(((int32_t)(error) != 0)) 
        {
            throw MonoIO::GetException2(GetSecureFileName(this->name), error);
        }
    }
    
    void FileStream::Unlock_9bd2607d2344dcd0(int64_t position, int64_t length) {
        if(::System::IntPtr::op_Equality(this->handle, MonoIO::InvalidHandle)) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("Stream has been closed"));
        }
        if((position < 0L)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("position must not be negative"));
        }
        if((length < 0L)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("length must not be negative"));
        }
        MonoIOError error;
        MonoIO::Unlock(this->handle, position, length, error);
        if(((int32_t)(error) != 0)) 
        {
            throw MonoIO::GetException2(GetSecureFileName(this->name), error);
        }
    }
    
    void FileStream::Dispose_b215be19126499b0(bool disposing) {
        System::Exception *exc = nullptr;
        if(::System::IntPtr::op_Inequality(this->handle, MonoIO::InvalidHandle)) 
        {
            try {
                FlushBuffer2();
            }
            catch(System::Exception* e) {
                exc = e;
            }
            if(this->owner) 
            {
                MonoIOError error;
                MonoIO::Close(this->handle, error);
                if(((int32_t)(error) != 0)) 
                {
                    throw MonoIO::GetException2(GetSecureFileName(this->name), error);
                }
                this->handle = MonoIO::InvalidHandle;
            }
        }
        this->canseek = false;
        this->access = (FileAccess)0L;
        if((disposing && (this->buf != nullptr))) 
        {
            if(((this->buf->get_Length() ==  4096) && (buf_recycle ==  nullptr))) 
            {
                {
                    cli::lock_guard{buf_recycle_lock};
                    if((buf_recycle ==  nullptr)) 
                    {
                        buf_recycle = this->buf;
                    }
                }
            }
            this->buf = nullptr;
            System::GC::SuppressFinalize(this);
        }
        if((exc != nullptr)) 
        {
            throw exc;
        }
    }
    
    System::Security::AccessControl::FileSecurity* FileStream::GetAccessControl() {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    void FileStream::SetAccessControl(System::Security::AccessControl::FileSecurity* fileSecurity) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t FileStream::ReadSegment(cli::array<unsigned char>* dest, int32_t dest_offset, int32_t count) {
        count = System::Math::Min5(count, (this->buf_length - this->buf_offset));
        if((count > 0)) 
        {
            System::Buffer::BlockCopyInternal(this->buf, this->buf_offset, dest, dest_offset, count);
            (this->buf_offset = this->buf_offset + count);
        }
        return count;
    }
    
    int32_t FileStream::WriteSegment(cli::array<unsigned char>* src, int32_t src_offset, int32_t count) {
        if((count > (this->buf_size - this->buf_offset))) 
        {
            count = (this->buf_size - this->buf_offset);
        }
        if((count > 0)) 
        {
            System::Buffer::BlockCopy(src, src_offset, this->buf, this->buf_offset, count);
            (this->buf_offset = this->buf_offset + count);
            if((this->buf_offset > this->buf_length)) 
            {
                this->buf_length = this->buf_offset;
            }
            this->buf_dirty = true;
        }
        return count;
    }
    
    void FileStream::FlushBuffer(Stream* st) {
        if(this->buf_dirty) 
        {
            MonoIOError error;
            if(((this->get_CanSeek_8c8861ce02c6bdeb() ==  true) && (this->safeHandle ==  nullptr))) 
            {
                MonoIO::Seek(this->handle, this->buf_start, SeekOrigin::Begin, error);
                if(((int32_t)(error) != 0)) 
                {
                    throw MonoIO::GetException2(GetSecureFileName(this->name), error);
                }
            }
            if((st ==  nullptr)) 
            {
                int32_t wcount = this->buf_length;
                int32_t offset = 0;
                while((wcount > 0)) {
                    int32_t n = MonoIO::Write(this->handle, this->buf, 0, this->buf_length, error);
                    if(((int32_t)(error) != 0)) 
                    {
                        throw MonoIO::GetException2(GetSecureFileName(this->name), error);
                    }
                    (wcount = wcount - n);
                    (offset = offset + n);
                }
            }
             else 
            {
                st->Write_1f8a1dbe71b0eb89(this->buf, 0, this->buf_length);
            }
        }
        (this->buf_start = this->buf_start + (int64_t)(this->buf_offset));
        this->buf_offset = this->buf_length = 0;
        this->buf_dirty = false;
    }
    
    void FileStream::FlushBuffer2() {
        FlushBuffer(nullptr);
    }
    
    void FileStream::FlushBufferIfDirty() {
        if(this->buf_dirty) 
        {
            FlushBuffer(nullptr);
        }
    }
    
    void FileStream::RefillBuffer() {
        FlushBuffer(nullptr);
        this->buf_length = ReadData(this->handle, this->buf, 0, this->buf_size);
    }
    
    int32_t FileStream::ReadData(void* handle, cli::array<unsigned char>* buf, int32_t offset, int32_t count) {
        MonoIOError error;
        int32_t amount = 0;
        amount = MonoIO::Read(handle, buf, offset, count, error);
        if(((int32_t)(error) ==  109)) 
        {
            amount = 0;
        }
         else 
        {
            if(((int32_t)(error) != 0)) 
            {
                throw MonoIO::GetException2(GetSecureFileName(this->name), error);
            }
        }
        if((amount ==  -1)) 
        {
            throw cli::gcnew<IOException>();
        }
        return amount;
    }
    
    void FileStream::InitBuffer(int32_t size, bool isZeroSize) {
        if(isZeroSize) 
        {
            size = 0;
            this->buf = (new cli::array<unsigned char>(1));
        }
         else 
        {
            if((size <= 0)) 
            {
                throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("bufferSize"), _T("Positive number required."));
            }
            size = System::Math::Max5(size, 8);
            if(((size <= 4096) && (buf_recycle != nullptr))) 
            {
                {
                    cli::lock_guard{buf_recycle_lock};
                    if((buf_recycle != nullptr)) 
                    {
                        this->buf = buf_recycle;
                        buf_recycle = nullptr;
                    }
                }
            }
            if((this->buf ==  nullptr)) 
            {
                this->buf = (new cli::array<unsigned char>(size));
            }
             else 
            {
                System::Array::Clear2(this->buf, 0, size);
            }
        }
        this->buf_size = size;
    }
    
    System::String* FileStream::GetSecureFileName(System::String* filename) {
        return this->anonymous ? Path::GetFileName(filename) : Path::GetFullPath(filename);
    }
    
    System::String* FileStream::GetSecureFileName2(System::String* filename, bool full) {
        return this->anonymous ? Path::GetFileName(filename) : full ? Path::GetFullPath(filename) : filename;
    }
    
    bool FileStream::get_CanRead_50a10d564be8aaa2() {
        return (((int32_t)(this->access) ==  1) || ((int32_t)(this->access) ==  3));
    }
    
    bool FileStream::get_CanWrite_c8955eadfc77124c() {
        return (((int32_t)(this->access) ==  2) || ((int32_t)(this->access) ==  3));
    }
    
    bool FileStream::get_CanSeek_8c8861ce02c6bdeb() {
        return this->canseek;
    }
    
    bool FileStream::get_IsAsync_f1144e989e0e63e() {
        return this->async;
    }
    
    System::String* FileStream::get_Name() {
        return this->name;
    }
    
    int64_t FileStream::get_Length_ddb8b0d061db5350() {
        if(::System::IntPtr::op_Equality(this->handle, MonoIO::InvalidHandle)) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("Stream has been closed"));
        }
        if(!(this->get_CanSeek_8c8861ce02c6bdeb())) 
        {
            throw cli::gcnew<System::NotSupportedException>(_T("The stream does not support seeking"));
        }
        FlushBufferIfDirty();
        MonoIOError error;
        int64_t length;
        length = MonoIO::GetLength(this->handle, error);
        if(((int32_t)(error) != 0)) 
        {
            throw MonoIO::GetException2(GetSecureFileName(this->name), error);
        }
        return length;
    }
    
    int64_t FileStream::get_Position_5e75d5c458401f13() {
        if(::System::IntPtr::op_Equality(this->handle, MonoIO::InvalidHandle)) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("Stream has been closed"));
        }
        if((this->get_CanSeek_8c8861ce02c6bdeb() ==  false)) 
        {
            throw cli::gcnew<System::NotSupportedException>(_T("The stream does not support seeking"));
        }
        if((this->safeHandle != nullptr)) 
        {
            MonoIOError error;
            int64_t ret = MonoIO::Seek(this->handle, 0L, SeekOrigin::Current, error);
            if(((int32_t)(error) != 0)) 
            {
                throw MonoIO::GetException2(GetSecureFileName(this->name), error);
            }
            return ret;
        }
        return (this->buf_start + (int64_t)(this->buf_offset));
    }
    
    int64_t FileStream::set_Position_cfe1def757785ad(int64_t value) {
        if(::System::IntPtr::op_Equality(this->handle, MonoIO::InvalidHandle)) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("Stream has been closed"));
        }
        if((this->get_CanSeek_8c8861ce02c6bdeb() ==  false)) 
        {
            throw cli::gcnew<System::NotSupportedException>(_T("The stream does not support seeking"));
        }
        if((value < 0L)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("Attempt to set the position to a negative value"));
        }
        FileStream::Seek_df5b3eadfe9adf31(value, SeekOrigin::Begin);
        return get_Position_5e75d5c458401f13();
    }
    
    void* FileStream::get_Handle_74aea2418d83b5a0() {
        if((this->safeHandle ==  nullptr)) 
        {
            ExposeHandle();
        }
        return this->handle;
    }
    
    Microsoft::Win32::SafeHandles::SafeFileHandle* FileStream::get_SafeFileHandle_b919aff741b12494() {
        if((this->safeHandle ==  nullptr)) 
        {
            ExposeHandle();
        }
        return this->safeHandle;
    }
    
}}
namespace System { namespace IO {
    
    
    void FileStreamAsyncResult::constructor(System::AsyncCallback* cb, System::Object* state) {
        this->state = state;
        this->realcb = cb;
        if((this->realcb != nullptr)) 
        {
            this->cb = cli::bind(&FileStreamAsyncResult::CBWrapper);
        }
        this->wh = cli::gcnew<System::Threading::ManualResetEvent>(false);
    }
    
    void FileStreamAsyncResult::CBWrapper(System::IAsyncResult* ares) {
        FileStreamAsyncResult *res = cli::cast<FileStreamAsyncResult*>(ares);
        res->realcb->BeginInvoke(ares, nullptr, nullptr);
    }
    
    void FileStreamAsyncResult::SetComplete(System::Exception* e) {
        this->exc = e;
        this->completed = true;
        this->wh->Set();
        if((this->cb != nullptr)) 
        {
            this->cb->Invoke(this);
        }
    }
    
    void FileStreamAsyncResult::SetComplete2(System::Exception* e, int32_t nbytes) {
        this->BytesRead = nbytes;
        SetComplete(e);
    }
    
    void FileStreamAsyncResult::SetComplete3(System::Exception* e, int32_t nbytes, bool synch) {
        this->completedSynch = synch;
        SetComplete2(e, nbytes);
    }
    
    System::Object* FileStreamAsyncResult::get_AsyncState() {
        return this->state;
    }
    
    bool FileStreamAsyncResult::get_CompletedSynchronously() {
        return this->completedSynch;
    }
    
    System::Threading::WaitHandle* FileStreamAsyncResult::get_AsyncWaitHandle() {
        return this->wh;
    }
    
    bool FileStreamAsyncResult::get_IsCompleted() {
        return this->completed;
    }
    
    System::Exception* FileStreamAsyncResult::get_Exception() {
        return this->exc;
    }
    
    bool FileStreamAsyncResult::get_Done() {
        return this->done;
    }
    
    bool FileStreamAsyncResult::set_Done(bool value) {
        this->done = value;
        return get_Done();
    }
    
}}
namespace System { namespace IO {
    
    
    void FileSystemInfo::constructor() {
        this->valid = false;
        this->FullPath = nullptr;
    }
    
    void FileSystemInfo::constructor(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        if((info ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("info"));
        }
        this->FullPath = info->GetString(_T("FullPath"));
        this->OriginalPath = info->GetString(_T("OriginalPath"));
    }
    
    void FileSystemInfo::GetObjectData_e22ded754991345d(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        info->AddValue(_T("OriginalPath"), this->OriginalPath, cli::typeof<System::Type>::info);
        info->AddValue(_T("FullPath"), this->FullPath, cli::typeof<System::Type>::info);
    }
    
    void FileSystemInfo::Refresh() {
        Refresh2(true);
    }
    
    void FileSystemInfo::Refresh2(bool force) {
        if((this->valid && !(force))) 
        {
            return;
        }
        MonoIOError error;
        MonoIO::GetFileStat(this->get_FullName_3d8989b544082b48(), this->stat, error);
        this->valid = true;
        InternalRefresh_5c7cc70032723c7a();
    }
    
    void FileSystemInfo::InternalRefresh_5c7cc70032723c7a() {
    }
    
    void FileSystemInfo::CheckPath(System::String* path) {
        if((path ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("path"));
        }
        if((path->get_Length() ==  0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("An empty file name is not valid."));
        }
        if((path->IndexOfAny(Path::InvalidPathChars) != -1)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Illegal characters in path."));
        }
        if(System::Environment::get_IsRunningOnWindows()) 
        {
            int32_t idx = path->IndexOf4(u':');
            if(((idx >= 0) && (idx != 1))) 
            {
                throw cli::gcnew<System::ArgumentException>(_T("path"));
            }
        }
    }
    
    System::String* FileSystemInfo::get_FullName_3d8989b544082b48() {
        return this->FullPath;
    }
    
    System::String* FileSystemInfo::get_Extension() {
        return Path::GetExtension(this->get_Name_34b64716a6d0afcd());
    }
    
    FileAttributes FileSystemInfo::get_Attributes() {
        Refresh2(false);
        return this->stat->Attributes;
    }
    
    FileAttributes FileSystemInfo::set_Attributes(FileAttributes value) {
        MonoIOError error;
        if(!(MonoIO::SetFileAttributes(this->get_FullName_3d8989b544082b48(), value, error))) 
        {
            throw MonoIO::GetException2(this->get_FullName_3d8989b544082b48(), error);
        }
        Refresh2(true);
        return get_Attributes();
    }
    
    System::DateTime FileSystemInfo::get_CreationTime() {
        Refresh2(false);
        return System::DateTime::FromFileTime(this->stat->CreationTime);
    }
    
    System::DateTime FileSystemInfo::set_CreationTime(System::DateTime value) {
        System::Security::SecurityManager::EnsureElevatedPermissions();
        int64_t filetime = value->ToFileTime();
        MonoIOError error;
        if(!(MonoIO::SetFileTime2(this->get_FullName_3d8989b544082b48(), filetime, -1L, -1L, error))) 
        {
            throw MonoIO::GetException2(this->get_FullName_3d8989b544082b48(), error);
        }
        Refresh2(true);
        return get_CreationTime();
    }
    
    System::DateTime FileSystemInfo::get_CreationTimeUtc() {
        return this->get_CreationTime()->ToUniversalTime();
    }
    
    System::DateTime FileSystemInfo::set_CreationTimeUtc(System::DateTime value) {
        this->set_CreationTime(value->ToLocalTime());
        return get_CreationTimeUtc();
    }
    
    System::DateTime FileSystemInfo::get_LastAccessTime() {
        Refresh2(false);
        return System::DateTime::FromFileTime(this->stat->LastAccessTime);
    }
    
    System::DateTime FileSystemInfo::set_LastAccessTime(System::DateTime value) {
        System::Security::SecurityManager::EnsureElevatedPermissions();
        int64_t filetime = value->ToFileTime();
        MonoIOError error;
        if(!(MonoIO::SetFileTime2(this->get_FullName_3d8989b544082b48(), -1L, filetime, -1L, error))) 
        {
            throw MonoIO::GetException2(this->get_FullName_3d8989b544082b48(), error);
        }
        Refresh2(true);
        return get_LastAccessTime();
    }
    
    System::DateTime FileSystemInfo::get_LastAccessTimeUtc() {
        Refresh2(false);
        return this->get_LastAccessTime()->ToUniversalTime();
    }
    
    System::DateTime FileSystemInfo::set_LastAccessTimeUtc(System::DateTime value) {
        this->set_LastAccessTime(value->ToLocalTime());
        return get_LastAccessTimeUtc();
    }
    
    System::DateTime FileSystemInfo::get_LastWriteTime() {
        Refresh2(false);
        return System::DateTime::FromFileTime(this->stat->LastWriteTime);
    }
    
    System::DateTime FileSystemInfo::set_LastWriteTime(System::DateTime value) {
        System::Security::SecurityManager::EnsureElevatedPermissions();
        int64_t filetime = value->ToFileTime();
        MonoIOError error;
        if(!(MonoIO::SetFileTime2(this->get_FullName_3d8989b544082b48(), -1L, -1L, filetime, error))) 
        {
            throw MonoIO::GetException2(this->get_FullName_3d8989b544082b48(), error);
        }
        Refresh2(true);
        return get_LastWriteTime();
    }
    
    System::DateTime FileSystemInfo::get_LastWriteTimeUtc() {
        Refresh2(false);
        return this->get_LastWriteTime()->ToUniversalTime();
    }
    
    System::DateTime FileSystemInfo::set_LastWriteTimeUtc(System::DateTime value) {
        this->set_LastWriteTime(value->ToLocalTime());
        return get_LastWriteTimeUtc();
    }
    
}}
namespace System { namespace IO {
    
    
    void IntPtrStream::constructor(void* base_address, int32_t size) {
        this->base_address = (unsigned char*)((void*)base_address);
        this->size = size;
        this->position = 0;
    }
    
    int32_t IntPtrStream::Read_c0d6dde3943b413e(cli::array<unsigned char>* buffer, int32_t offset, int32_t count) {
        if((buffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("buffer"));
        }
        if(((offset < 0) || (count < 0))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("offset or count less than zero."));
        }
        if(((buffer->get_Length() - offset) < count)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("offset+count"), _T("The size of the buffer is less than offset + count."));
        }
        if(this->closed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("Stream has been closed"));
        }
        if(((this->position >= this->size) || (count ==  0))) 
        {
            return 0;
        }
        if((this->position > (this->size - count))) 
        {
            count = (this->size - this->position);
        }
        System::Runtime::InteropServices::Marshal::Copy9((void*)(void*)((this->base_address + (int32_t)(this->position))), buffer, offset, count);
        (this->position = this->position + count);
        return count;
    }
    
    int32_t IntPtrStream::ReadByte_61a294e42318f99() {
        if((this->position >= this->size)) 
        {
            return -1;
        }
        if(this->closed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("Stream has been closed"));
        }
        return (int32_t)((*(this->base_address + this->position++)));
    }
    
    int64_t IntPtrStream::Seek_df5b3eadfe9adf31(int64_t offset, SeekOrigin loc) {
        if((offset > 2147483647L)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(cli::concat(_T("Offset out of range. "), cli::box(offset)));
        }
        if(this->closed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("Stream has been closed"));
        }
        int32_t ref_point;
        switch(loc) {
            case SeekOrigin::Begin: case_1114: {
                if((offset < 0L)) 
                {
                    throw cli::gcnew<IOException>(_T("Attempted to seek before start of MemoryStream."));
                }
                ref_point = 0;
                break;
            }
            case SeekOrigin::Current: case_1115: {
                ref_point = this->position;
                break;
            }
            case SeekOrigin::End: case_1116: {
                ref_point = this->size;
                break;
            }
            default: case_1117: {
                throw cli::gcnew<System::ArgumentException>(_T("loc"), _T("Invalid SeekOrigin"));
            }
        }
        /*checked*/ {
            try {
                (ref_point = ref_point + (int32_t)offset);
            }
            catch(...) {
                throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("Too large seek destination"));
            }
            if((ref_point < 0)) 
            {
                throw cli::gcnew<IOException>(_T("Attempted to seek before start of MemoryStream."));
            }
        }
        this->position = ref_point;
        return (int64_t)(this->position);
    }
    
    void IntPtrStream::SetLength_18d421048f3d4df5(int64_t value) {
        throw cli::gcnew<System::NotSupportedException>(_T("This stream can not change its size"));
    }
    
    void IntPtrStream::Write_1f8a1dbe71b0eb89(cli::array<unsigned char>* buffer, int32_t offset, int32_t count) {
        throw cli::gcnew<System::NotSupportedException>(_T("This stream can not change its size"));
    }
    
    void IntPtrStream::WriteByte_4404d6329af3b6d5(unsigned char value) {
        throw cli::gcnew<System::NotSupportedException>(_T("This stream can not change its size"));
    }
    
    void IntPtrStream::Flush_132821400030c993() {
    }
    
    void IntPtrStream::Close_59c62ed53ef2a481() {
        this->closed = true;
        if((this->Closed != nullptr)) 
        {
            this->Closed->Invoke(this, nullptr);
        }
    }
    
    void* IntPtrStream::get_BaseAddress() {
        return cli::ctor<::System::IntPtr>((void*)(this->base_address));
    }
    
    bool IntPtrStream::get_CanRead_50a10d564be8aaa2() {
        return true;
    }
    
    bool IntPtrStream::get_CanSeek_8c8861ce02c6bdeb() {
        return true;
    }
    
    bool IntPtrStream::get_CanWrite_c8955eadfc77124c() {
        return false;
    }
    
    int64_t IntPtrStream::get_Position_5e75d5c458401f13() {
        return (int64_t)(this->position);
    }
    
    int64_t IntPtrStream::set_Position_cfe1def757785ad(int64_t value) {
        if((this->position < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("Position"), _T("Can not be negative"));
        }
        if((this->position > this->size)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("Position"), _T("Pointer falls out of range"));
        }
        this->position = (int32_t)value;
        return get_Position_5e75d5c458401f13();
    }
    
    int64_t IntPtrStream::get_Length_ddb8b0d061db5350() {
        return (int64_t)(this->size);
    }
    
    void IntPtrStream::add_Closed(System::EventHandler* value) {
      // TODO: "Implement automatic events!"
    }
    
    void IntPtrStream::remove_Closed(System::EventHandler* value) {
      // TODO: "Implement automatic events!"
    }
    
}}
namespace System { namespace IO {
    
    
    void IOException::constructor() {
    }
    
    void IOException::constructor(System::String* message) {
    }
    
    void IOException::constructor(System::String* message, System::Exception* innerException) {
    }
    
    void IOException::constructor(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
    }
    
    void IOException::constructor(System::String* message, int32_t hresult) {
        this->set_HResult(hresult);
    }
    
}}
namespace System { namespace IO {
    
    
    void MemoryStream::constructor() {
    }
    
    void MemoryStream::constructor(int32_t capacity) {
        if((capacity < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("capacity"));
        }
        this->canWrite = true;
        this->capacity = capacity;
        this->internalBuffer = (new cli::array<unsigned char>(capacity));
        this->expandable = true;
        this->allowGetBuffer = true;
    }
    
    void MemoryStream::constructor(cli::array<unsigned char>* buffer) {
        if((buffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("buffer"));
        }
        InternalConstructor(buffer, 0, buffer->get_Length(), true, false);
    }
    
    void MemoryStream::constructor(cli::array<unsigned char>* buffer, bool writable) {
        if((buffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("buffer"));
        }
        InternalConstructor(buffer, 0, buffer->get_Length(), writable, false);
    }
    
    void MemoryStream::constructor(cli::array<unsigned char>* buffer, int32_t index, int32_t count) {
        InternalConstructor(buffer, index, count, true, false);
    }
    
    void MemoryStream::constructor(cli::array<unsigned char>* buffer, int32_t index, int32_t count, bool writable) {
        InternalConstructor(buffer, index, count, writable, false);
    }
    
    void MemoryStream::constructor(cli::array<unsigned char>* buffer, int32_t index, int32_t count, bool writable, bool publiclyVisible) {
        InternalConstructor(buffer, index, count, writable, publiclyVisible);
    }
    
    void MemoryStream::InternalConstructor(cli::array<unsigned char>* buffer, int32_t index, int32_t count, bool writable, bool publicallyVisible) {
        if((buffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("buffer"));
        }
        if(((index < 0) || (count < 0))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("index or count is less than 0."));
        }
        if(((buffer->get_Length() - index) < count)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("index+count"), _T("The size of the buffer is less than index + count."));
        }
        this->canWrite = writable;
        this->internalBuffer = buffer;
        this->capacity = (count + index);
        this->length = this->capacity;
        this->position = index;
        this->initialIndex = index;
        this->allowGetBuffer = publicallyVisible;
        this->expandable = false;
    }
    
    void MemoryStream::CheckIfClosedThrowDisposed() {
        if(this->streamClosed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("MemoryStream"));
        }
    }
    
    void MemoryStream::Dispose_b215be19126499b0(bool disposing) {
        this->streamClosed = true;
        this->expandable = false;
    }
    
    void MemoryStream::Flush_132821400030c993() {
    }
    
    cli::array<unsigned char>* MemoryStream::GetBuffer_21f804ce00c165c2() {
        if(!(this->allowGetBuffer)) 
        {
            throw cli::gcnew<System::UnauthorizedAccessException>();
        }
        return this->internalBuffer;
    }
    
    int32_t MemoryStream::Read_c0d6dde3943b413e(cli::array<unsigned char>* buffer, int32_t offset, int32_t count) {
        if((buffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("buffer"));
        }
        if(((offset < 0) || (count < 0))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("offset or count less than zero."));
        }
        if(((buffer->get_Length() - offset) < count)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("offset+count"), _T("The size of the buffer is less than offset + count."));
        }
        CheckIfClosedThrowDisposed();
        if(((this->position >= this->length) || (count ==  0))) 
        {
            return 0;
        }
        if((this->position > (this->length - count))) 
        {
            count = (this->length - this->position);
        }
        System::Buffer::BlockCopy(this->internalBuffer, this->position, buffer, offset, count);
        (this->position = this->position + count);
        return count;
    }
    
    int32_t MemoryStream::ReadByte_61a294e42318f99() {
        CheckIfClosedThrowDisposed();
        if((this->position >= this->length)) 
        {
            return -1;
        }
        return (int32_t)(this->internalBuffer->at(this->position++));
    }
    
    int64_t MemoryStream::Seek_df5b3eadfe9adf31(int64_t offset, SeekOrigin loc) {
        CheckIfClosedThrowDisposed();
        if((offset > 2147483647L)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(cli::concat(_T("Offset out of range. "), cli::box(offset)));
        }
        int32_t refPoint;
        switch(loc) {
            case SeekOrigin::Begin: case_1118: {
                if((offset < 0L)) 
                {
                    throw cli::gcnew<IOException>(_T("Attempted to seek before start of MemoryStream."));
                }
                refPoint = this->initialIndex;
                break;
            }
            case SeekOrigin::Current: case_1119: {
                refPoint = this->position;
                break;
            }
            case SeekOrigin::End: case_1120: {
                refPoint = this->length;
                break;
            }
            default: case_1121: {
                throw cli::gcnew<System::ArgumentException>(_T("loc"), _T("Invalid SeekOrigin"));
            }
        }
        (refPoint = refPoint + (int32_t)offset);
        if((refPoint < this->initialIndex)) 
        {
            throw cli::gcnew<IOException>(_T("Attempted to seek before start of MemoryStream."));
        }
        this->position = refPoint;
        return (int64_t)(this->position);
    }
    
    int32_t MemoryStream::CalculateNewCapacity(int32_t minimum) {
        if((minimum < 256)) 
        {
            minimum = 256;
        }
        if((minimum < (this->capacity * 2))) 
        {
            minimum = (this->capacity * 2);
        }
        return minimum;
    }
    
    void MemoryStream::Expand(int32_t newSize) {
        if((newSize > this->capacity)) 
        {
            this->set_Capacity_8fc8ba2e9ae6df4c(CalculateNewCapacity(newSize));
        }
         else 
        {
            if((this->dirty_bytes > 0)) 
            {
                System::Array::Clear2(this->internalBuffer, this->length, this->dirty_bytes);
                this->dirty_bytes = 0;
            }
        }
    }
    
    void MemoryStream::SetLength_18d421048f3d4df5(int64_t value) {
        if((!(this->expandable) && (value > (int64_t)(this->capacity)))) 
        {
            throw cli::gcnew<System::NotSupportedException>(_T("Expanding this MemoryStream is not supported"));
        }
        CheckIfClosedThrowDisposed();
        if(!(this->canWrite)) 
        {
            throw cli::gcnew<System::NotSupportedException>(Locale::GetText(_T("Cannot write to this MemoryStream")));
        }
        if(((value < 0L) || ((value + (int64_t)(this->initialIndex)) > 2147483647L))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>();
        }
        int32_t newSize = ((int32_t)value + this->initialIndex);
        if((newSize > this->length)) 
        {
            Expand(newSize);
        }
         else 
        {
            if((newSize < this->length)) 
            {
                (this->dirty_bytes = this->dirty_bytes + (this->length - newSize));
            }
        }
        this->length = newSize;
        if((this->position > this->length)) 
        {
            this->position = this->length;
        }
    }
    
    cli::array<unsigned char>* MemoryStream::ToArray_ebf8bde16e9d2ad6() {
        int32_t l = (this->length - this->initialIndex);
        cli::array<unsigned char> *outBuffer = (new cli::array<unsigned char>(l));
        if((this->internalBuffer != nullptr)) 
        {
            System::Buffer::BlockCopy(this->internalBuffer, this->initialIndex, outBuffer, 0, l);
        }
        return outBuffer;
    }
    
    void MemoryStream::Write_1f8a1dbe71b0eb89(cli::array<unsigned char>* buffer, int32_t offset, int32_t count) {
        if(!(this->canWrite)) 
        {
            throw cli::gcnew<System::NotSupportedException>(_T("Cannot write to this stream."));
        }
        if((buffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("buffer"));
        }
        if(((offset < 0) || (count < 0))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>();
        }
        if(((buffer->get_Length() - offset) < count)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("offset+count"), _T("The size of the buffer is less than offset + count."));
        }
        CheckIfClosedThrowDisposed();
        if((this->position > (this->length - count))) 
        {
            Expand((this->position + count));
        }
        System::Buffer::BlockCopy(buffer, offset, this->internalBuffer, this->position, count);
        (this->position = this->position + count);
        if((this->position >= this->length)) 
        {
            this->length = this->position;
        }
    }
    
    void MemoryStream::WriteByte_4404d6329af3b6d5(unsigned char value) {
        CheckIfClosedThrowDisposed();
        if(!(this->canWrite)) 
        {
            throw cli::gcnew<System::NotSupportedException>(_T("Cannot write to this stream."));
        }
        if((this->position >= this->length)) 
        {
            Expand((this->position + 1));
            this->length = (this->position + 1);
        }
        this->internalBuffer->at(this->position++) = value;
    }
    
    void MemoryStream::WriteTo_a7b8208fadf74ef1(Stream* stream) {
        CheckIfClosedThrowDisposed();
        if((stream ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("stream"));
        }
        stream->Write_1f8a1dbe71b0eb89(this->internalBuffer, this->initialIndex, (this->length - this->initialIndex));
    }
    
    bool MemoryStream::get_CanRead_50a10d564be8aaa2() {
        return !(this->streamClosed);
    }
    
    bool MemoryStream::get_CanSeek_8c8861ce02c6bdeb() {
        return !(this->streamClosed);
    }
    
    bool MemoryStream::get_CanWrite_c8955eadfc77124c() {
        return (!(this->streamClosed) && this->canWrite);
    }
    
    int32_t MemoryStream::get_Capacity_5e9248c082f69421() {
        CheckIfClosedThrowDisposed();
        return (this->capacity - this->initialIndex);
    }
    
    int32_t MemoryStream::set_Capacity_8fc8ba2e9ae6df4c(int32_t value) {
        CheckIfClosedThrowDisposed();
        if(!(this->expandable)) 
        {
            throw cli::gcnew<System::NotSupportedException>(_T("Cannot expand this MemoryStream"));
        }
        if(((value < 0) || (value < this->length))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("value"), cli::concat(_T("New capacity cannot be negative or less than the current capacity "), cli::box(value), _T(" "), cli::box(this->capacity)));
        }
        if(((this->internalBuffer != nullptr) && (value ==  this->internalBuffer->get_Length()))) 
        {
            return get_Capacity_5e9248c082f69421();
        }
        cli::array<unsigned char> *newBuffer = nullptr;
        if((value != 0)) 
        {
            newBuffer = (new cli::array<unsigned char>(value));
            if((this->internalBuffer != nullptr)) 
            {
                System::Buffer::BlockCopy(this->internalBuffer, 0, newBuffer, 0, this->length);
            }
        }
        this->dirty_bytes = 0;
        this->internalBuffer = newBuffer;
        this->capacity = value;
        return get_Capacity_5e9248c082f69421();
    }
    
    int64_t MemoryStream::get_Length_ddb8b0d061db5350() {
        CheckIfClosedThrowDisposed();
        return (int64_t)((this->length - this->initialIndex));
    }
    
    int64_t MemoryStream::get_Position_5e75d5c458401f13() {
        CheckIfClosedThrowDisposed();
        return (int64_t)((this->position - this->initialIndex));
    }
    
    int64_t MemoryStream::set_Position_cfe1def757785ad(int64_t value) {
        CheckIfClosedThrowDisposed();
        if((value < 0L)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("value"), _T("Position cannot be negative"));
        }
        if((value > 2147483647L)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("value"), _T("Position must be non-negative and less than 2^31 - 1 - origin"));
        }
        this->position = (this->initialIndex + (int32_t)value);
        return get_Position_5e75d5c458401f13();
    }
    
}}
namespace System { namespace IO {
    
    int32_t  MonoIO::FileAlreadyExistsHResult;
    FileAttributes  MonoIO::InvalidFileAttributes;
    void*  MonoIO::InvalidHandle;
    
    MonoIO::MonoIO()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void MonoIO::constructor() {
    }
    
    void MonoIO::static_constructor() {
    }
    
    System::Exception* MonoIO::GetException(MonoIOError error) {
        switch(error) {
            case MonoIOError::ERROR_ACCESS_DENIED: case_1122: {
                return cli::gcnew<System::UnauthorizedAccessException>(_T("Access to the path is denied."));
            }
            case MonoIOError::ERROR_FILE_EXISTS: case_1123: {
                System::String *message = _T("Cannot create a file that already exist.");
                return cli::gcnew<IOException>(message, FileAlreadyExistsHResult);
            }
            default: case_1124: {
                return GetException2(System::String::Empty, error);
            }
        }
    }
    
    System::Exception* MonoIO::GetException2(System::String* path, MonoIOError error) {
        System::String *message;
        switch(error) {
            case MonoIOError::ERROR_FILE_NOT_FOUND: case_1125: {
                message = System::String::Format2(_T("Could not find file \"{0}\""), path);
                return cli::gcnew<FileNotFoundException>(message, path);
            }
            case MonoIOError::ERROR_TOO_MANY_OPEN_FILES: case_1126: {
                return cli::gcnew<IOException>(_T("Too many open files"), (-2147024896 | (int32_t)(error)));
            }
            case MonoIOError::ERROR_PATH_NOT_FOUND: case_1127: {
                message = System::String::Format2(_T("Could not find a part of the path \"{0}\""), path);
                return cli::gcnew<DirectoryNotFoundException>(message);
            }
            case MonoIOError::ERROR_ACCESS_DENIED: case_1128: {
                message = System::String::Format2(_T("Access to the path \"{0}\" is denied."), path);
                return cli::gcnew<System::UnauthorizedAccessException>(message);
            }
            case MonoIOError::ERROR_INVALID_HANDLE: case_1129: {
                message = System::String::Format2(_T("Invalid handle to path \"{0}\""), path);
                return cli::gcnew<IOException>(message, (-2147024896 | (int32_t)(error)));
            }
            case MonoIOError::ERROR_INVALID_DRIVE: case_1130: {
                message = System::String::Format2(_T("Could not find the drive  \'{0}\'. The drive might not be ready or might not be mapped."), path);
                return cli::gcnew<DriveNotFoundException>(message);
            }
            case MonoIOError::ERROR_FILE_EXISTS: case_1131: {
                message = System::String::Format2(_T("Could not create file \"{0}\". File already exists."), path);
                return cli::gcnew<IOException>(message, (-2147024896 | (int32_t)(error)));
            }
            case MonoIOError::ERROR_FILENAME_EXCED_RANGE: case_1132: {
                message = System::String::Format2(_T("Path is too long. Path: {0}"), path);
                return cli::gcnew<PathTooLongException>(message);
            }
            case MonoIOError::ERROR_INVALID_PARAMETER: case_1133: {
                message = System::String::Format5(_T("Invalid parameter"), (new cli::array<System::Object*>({})));
                return cli::gcnew<IOException>(message, (-2147024896 | (int32_t)(error)));
            }
            case MonoIOError::ERROR_WRITE_FAULT: case_1134: {
                message = System::String::Format2(_T("Write fault on path {0}"), path);
                return cli::gcnew<IOException>(message, (-2147024896 | (int32_t)(error)));
            }
            case MonoIOError::ERROR_SHARING_VIOLATION: case_1135: {
                message = System::String::Format2(_T("Sharing violation on path {0}"), path);
                return cli::gcnew<IOException>(message, (-2147024896 | (int32_t)(error)));
            }
            case MonoIOError::ERROR_LOCK_VIOLATION: case_1136: {
                message = System::String::Format2(_T("Lock violation on path {0}"), path);
                return cli::gcnew<IOException>(message, (-2147024896 | (int32_t)(error)));
            }
            case MonoIOError::ERROR_HANDLE_DISK_FULL: case_1137: {
                message = System::String::Format2(_T("Disk full. Path {0}"), path);
                return cli::gcnew<IOException>(message, (-2147024896 | (int32_t)(error)));
            }
            case MonoIOError::ERROR_DIR_NOT_EMPTY: case_1138: {
                message = System::String::Format2(_T("Directory {0} is not empty"), path);
                return cli::gcnew<IOException>(message, (-2147024896 | (int32_t)(error)));
            }
            case MonoIOError::ERROR_ENCRYPTION_FAILED: case_1139: {
                return cli::gcnew<IOException>(_T("Encryption failed"), (-2147024896 | (int32_t)(error)));
            }
            case MonoIOError::ERROR_CANNOT_MAKE: case_1140: {
                message = System::String::Format2(_T("Path {0} is a directory"), path);
                return cli::gcnew<IOException>(message, (-2147024896 | (int32_t)(error)));
            }
            case MonoIOError::ERROR_NOT_SAME_DEVICE: case_1141: {
                message = _T("Source and destination are not on the same device");
                return cli::gcnew<IOException>(message, (-2147024896 | (int32_t)(error)));
            }
            default: case_1142: {
                message = System::String::Format3(_T("Win32 IO returned {0}. Path: {1}"), cli::box(error), path);
                return cli::gcnew<IOException>(message, (-2147024896 | (int32_t)(error)));
            }
        }
    }
    
    bool MonoIO::CreateDirectory(System::String* path, MonoIOError error) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool MonoIO::RemoveDirectory(System::String* path, MonoIOError error) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    cli::array<System::String*>* MonoIO::GetFileSystemEntries(System::String* path, System::String* path_with_pattern, int32_t attrs, int32_t mask, MonoIOError error) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    System::String* MonoIO::GetCurrentDirectory(MonoIOError error) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool MonoIO::SetCurrentDirectory(System::String* path, MonoIOError error) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool MonoIO::MoveFile(System::String* path, System::String* dest, MonoIOError error) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool MonoIO::CopyFile(System::String* path, System::String* dest, bool overwrite, MonoIOError error) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool MonoIO::DeleteFile(System::String* path, MonoIOError error) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool MonoIO::ReplaceFile(System::String* sourceFileName, System::String* destinationFileName, System::String* destinationBackupFileName, bool ignoreMetadataErrors, MonoIOError error) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    FileAttributes MonoIO::GetFileAttributes(System::String* path, MonoIOError error) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool MonoIO::SetFileAttributes(System::String* path, FileAttributes attrs, MonoIOError error) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    MonoFileType MonoIO::GetFileType(void* handle, MonoIOError error) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    System::String* MonoIO::FindFirst(System::String* path, System::String* pattern, FileAttributes result_attr, MonoIOError error, void* handle) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    System::String* MonoIO::FindNext(void* handle, FileAttributes result_attr, MonoIOError error) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t MonoIO::FindClose(void* handle) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool MonoIO::Exists(System::String* path, MonoIOError error) {
        FileAttributes attrs = GetFileAttributes(path, error);
        if(((int32_t)(attrs) ==  (int32_t)(InvalidFileAttributes))) 
        {
            return false;
        }
        return true;
    }
    
    bool MonoIO::ExistsFile(System::String* path, MonoIOError error) {
        FileAttributes attrs = GetFileAttributes(path, error);
        if(((int32_t)(attrs) ==  (int32_t)(InvalidFileAttributes))) 
        {
            return false;
        }
        if(((int32_t)(((int32_t)(attrs) & 16)) != 0)) 
        {
            return false;
        }
        return true;
    }
    
    bool MonoIO::ExistsDirectory(System::String* path, MonoIOError error) {
        FileAttributes attrs = GetFileAttributes(path, error);
        if(((int32_t)(error) ==  2)) 
        {
            error = MonoIOError::ERROR_PATH_NOT_FOUND;
        }
        if(((int32_t)(attrs) ==  (int32_t)(InvalidFileAttributes))) 
        {
            return false;
        }
        if(((int32_t)(((int32_t)(attrs) & 16)) ==  0)) 
        {
            return false;
        }
        return true;
    }
    
    bool MonoIO::ExistsSymlink(System::String* path, MonoIOError error) {
        FileAttributes attrs = GetFileAttributes(path, error);
        if(((int32_t)(attrs) ==  (int32_t)(InvalidFileAttributes))) 
        {
            return false;
        }
        if(((int32_t)(((int32_t)(attrs) & 1024)) ==  0)) 
        {
            return false;
        }
        return true;
    }
    
    bool MonoIO::GetFileStat(System::String* path, MonoIOStat stat, MonoIOError error) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void* MonoIO::Open(System::String* filename, FileMode mode, FileAccess access, FileShare share, FileOptions options, MonoIOError error) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool MonoIO::Close(void* handle, MonoIOError error) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t MonoIO::Read(void* handle, cli::array<unsigned char>* dest, int32_t dest_offset, int32_t count, MonoIOError error) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t MonoIO::Write(void* handle, cli::array<unsigned char>* src, int32_t src_offset, int32_t count, MonoIOError error) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int64_t MonoIO::Seek(void* handle, int64_t offset, SeekOrigin origin, MonoIOError error) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool MonoIO::Flush(void* handle, MonoIOError error) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int64_t MonoIO::GetLength(void* handle, MonoIOError error) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool MonoIO::SetLength(void* handle, int64_t length, MonoIOError error) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool MonoIO::SetFileTime(void* handle, int64_t creation_time, int64_t last_access_time, int64_t last_write_time, MonoIOError error) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool MonoIO::SetFileTime2(System::String* path, int64_t creation_time, int64_t last_access_time, int64_t last_write_time, MonoIOError error) {
        return SetFileTime3(path, 0, creation_time, last_access_time, last_write_time, (*System::DateTime::MinValue), error);
    }
    
    bool MonoIO::SetCreationTime(System::String* path, System::DateTime dateTime, MonoIOError error) {
        return SetFileTime3(path, 1, -1L, -1L, -1L, dateTime, error);
    }
    
    bool MonoIO::SetLastAccessTime(System::String* path, System::DateTime dateTime, MonoIOError error) {
        return SetFileTime3(path, 2, -1L, -1L, -1L, dateTime, error);
    }
    
    bool MonoIO::SetLastWriteTime(System::String* path, System::DateTime dateTime, MonoIOError error) {
        return SetFileTime3(path, 3, -1L, -1L, -1L, dateTime, error);
    }
    
    bool MonoIO::SetFileTime3(System::String* path, int32_t type, int64_t creation_time, int64_t last_access_time, int64_t last_write_time, System::DateTime dateTime, MonoIOError error) {
        void *handle;
        bool result;
        handle = Open(path, FileMode::Open, FileAccess::ReadWrite, FileShare::ReadWrite, FileOptions::None, error);
        if(::System::IntPtr::op_Equality(handle, InvalidHandle)) 
        {
            return false;
        }
        switch(type) {
            case 1: case_1143: {
                creation_time = dateTime->ToFileTime();
                break;
            }
            case 2: case_1144: {
                last_access_time = dateTime->ToFileTime();
                break;
            }
            case 3: case_1145: {
                last_write_time = dateTime->ToFileTime();
                break;
            }
        }
        result = SetFileTime(handle, creation_time, last_access_time, last_write_time, error);
        MonoIOError ignore_error;
        Close(handle, ignore_error);
        return result;
    }
    
    void MonoIO::Lock(void* handle, int64_t position, int64_t length, MonoIOError error) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void MonoIO::Unlock(void* handle, int64_t position, int64_t length, MonoIOError error) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool MonoIO::CreatePipe(void* read_handle, void* write_handle) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool MonoIO::DuplicateHandle(void* source_process_handle, void* source_handle, void* target_process_handle, void* target_handle, int32_t access, int32_t inherit, int32_t options) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t MonoIO::GetTempPath(System::String* path) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void* MonoIO::get_ConsoleOutput() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void* MonoIO::get_ConsoleInput() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void* MonoIO::get_ConsoleError() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    char16_t MonoIO::get_VolumeSeparatorChar() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    char16_t MonoIO::get_DirectorySeparatorChar() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    char16_t MonoIO::get_AltDirectorySeparatorChar() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    char16_t MonoIO::get_PathSeparator() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
}}
namespace System { namespace IO {
    
    cli::array<char16_t>*  Path::InvalidPathChars;
    char16_t  Path::AltDirectorySeparatorChar;
    char16_t  Path::DirectorySeparatorChar;
    char16_t  Path::PathSeparator;
    System::String*  Path::DirectorySeparatorStr;
    char16_t  Path::VolumeSeparatorChar;
    cli::array<char16_t>*  Path::PathSeparatorChars;
    bool  Path::dirEqualsVolume;
    
    Path::Path()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void Path::static_constructor() {
        VolumeSeparatorChar = MonoIO::get_VolumeSeparatorChar();
        DirectorySeparatorChar = MonoIO::get_DirectorySeparatorChar();
        AltDirectorySeparatorChar = MonoIO::get_AltDirectorySeparatorChar();
        PathSeparator = MonoIO::get_PathSeparator();
        InvalidPathChars = GetInvalidPathChars();
        DirectorySeparatorStr = cli::import(DirectorySeparatorChar)->ToString_1636a0751cb9ac11();
        PathSeparatorChars = (new cli::array<char16_t>({DirectorySeparatorChar, AltDirectorySeparatorChar, VolumeSeparatorChar}));
        dirEqualsVolume = ((int32_t)(DirectorySeparatorChar) ==  (int32_t)(VolumeSeparatorChar));
    }
    
    System::String* Path::ChangeExtension(System::String* path, System::String* extension) {
        if((path ==  nullptr)) 
        {
            return nullptr;
        }
        if((path->IndexOfAny(InvalidPathChars) != -1)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Illegal characters in path."));
        }
        int32_t iExt = findExtension(path);
        if((extension ==  nullptr)) 
        {
            return (iExt < 0) ? path : path->Substring2(0, iExt);
        }
         else 
        {
            if((extension->get_Length() ==  0)) 
            {
                return (iExt < 0) ? cli::concat(path, cli::box(u'.')) : path->Substring2(0, (iExt + 1));
            }
             else 
            {
                if((path->get_Length() != 0)) 
                {
                    if(((extension->get_Length() > 0) && ((int32_t)(extension->get_Chars(0)) != 46))) 
                    {
                        extension = cli::concat(_T("."), extension);
                    }
                }
                 else 
                {
                    extension = System::String::Empty;
                }
            }
        }
        if((iExt < 0)) 
        {
            return cli::concat(path, extension);
        }
         else 
        {
            if((iExt > 0)) 
            {
                System::String *temp = path->Substring2(0, iExt);
                return cli::concat(temp, extension);
            }
        }
        return extension;
    }
    
    System::String* Path::Combine(System::String* path1, System::String* path2) {
        if((path1 ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("path1"));
        }
        if((path2 ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("path2"));
        }
        if((path1->get_Length() ==  0)) 
        {
            return path2;
        }
        if((path2->get_Length() ==  0)) 
        {
            return path1;
        }
        if((path1->IndexOfAny(InvalidPathChars) != -1)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Illegal characters in path."));
        }
        if((path2->IndexOfAny(InvalidPathChars) != -1)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Illegal characters in path."));
        }
        if(IsPathRooted(path2)) 
        {
            return path2;
        }
        char16_t p1end = path1->get_Chars((path1->get_Length() - 1));
        if(((((int32_t)(p1end) != (int32_t)(DirectorySeparatorChar)) && ((int32_t)(p1end) != (int32_t)(AltDirectorySeparatorChar))) && ((int32_t)(p1end) != (int32_t)(VolumeSeparatorChar)))) 
        {
            return cli::concat(path1, DirectorySeparatorStr);
        }
        return cli::concat(path1, path2);
    }
    
    System::String* Path::CleanPath(System::String* s) {
        int32_t l = s->get_Length();
        int32_t sub = 0;
        int32_t start = 0;
        char16_t s0 = s->get_Chars(0);
        if((((l > 2) && ((int32_t)(s0) ==  92)) && ((int32_t)(s->get_Chars(1)) ==  92))) 
        {
            start = 2;
        }
        if(((l ==  1) && (((int32_t)(s0) ==  (int32_t)(DirectorySeparatorChar)) || ((int32_t)(s0) ==  (int32_t)(AltDirectorySeparatorChar))))) 
        {
            return s;
        }
        for(int32_t i = start; (i < l); i++){
            char16_t c = s->get_Chars(i);
            if((((int32_t)(c) != (int32_t)(DirectorySeparatorChar)) && ((int32_t)(c) != (int32_t)(AltDirectorySeparatorChar)))) 
            {
                continue;
            }
            if(((i + 1) ==  l)) 
            {
                sub++;
            }
             else 
            {
                c = s->get_Chars((i + 1));
                if((((int32_t)(c) ==  (int32_t)(DirectorySeparatorChar)) || ((int32_t)(c) ==  (int32_t)(AltDirectorySeparatorChar)))) 
                {
                    sub++;
                }
            }
        }
        if((sub ==  0)) 
        {
            return s;
        }
        cli::array<char16_t> *copy = (new cli::array<char16_t>((l - sub)));
        if((start != 0)) 
        {
            copy->at(0) = u'\\';
            copy->at(1) = u'\\';
        }
        for(int32_t i = start, j = start; ((i < l) && (j < copy->get_Length())); i++){
            char16_t c = s->get_Chars(i);
            if((((int32_t)(c) != (int32_t)(DirectorySeparatorChar)) && ((int32_t)(c) != (int32_t)(AltDirectorySeparatorChar)))) 
            {
                copy->at(j++) = c;
                continue;
            }
            if(((j + 1) != copy->get_Length())) 
            {
                copy->at(j++) = DirectorySeparatorChar;
                for(; (i < (l - 1)); i++){
                    c = s->get_Chars((i + 1));
                    if((((int32_t)(c) != (int32_t)(DirectorySeparatorChar)) && ((int32_t)(c) != (int32_t)(AltDirectorySeparatorChar)))) 
                    {
                        break;
                    }
                }
            }
        }
        return cli::gcnew<System::String>(copy);
    }
    
    System::String* Path::GetDirectoryName(System::String* path) {
        if(System::String::op_Equality(path, System::String::Empty)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Invalid path"));
        }
        if(((path ==  nullptr) || System::String::op_Equality(GetPathRoot(path), path))) 
        {
            return nullptr;
        }
        if((path->Trim()->get_Length() ==  0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Argument string consists of whitespace characters only."));
        }
        if((path->IndexOfAny(InvalidPathChars) > -1)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Path contains invalid characters"));
        }
        int32_t nLast = path->LastIndexOfAny(PathSeparatorChars);
        if((nLast ==  0)) 
        {
            nLast++;
        }
        if((nLast > 0)) 
        {
            System::String *ret = path->Substring2(0, nLast);
            int32_t l = ret->get_Length();
            if((((l >= 2) && ((int32_t)(DirectorySeparatorChar) ==  92)) && ((int32_t)(ret->get_Chars((l - 1))) ==  (int32_t)(VolumeSeparatorChar)))) 
            {
                return cli::concat(ret, cli::box(DirectorySeparatorChar));
            }
             else 
            {
                return CleanPath(ret);
            }
        }
        return System::String::Empty;
    }
    
    System::String* Path::GetExtension(System::String* path) {
        if((path ==  nullptr)) 
        {
            return nullptr;
        }
        if((path->IndexOfAny(InvalidPathChars) != -1)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Illegal characters in path."));
        }
        int32_t iExt = findExtension(path);
        if((iExt > -1)) 
        {
            if((iExt < (path->get_Length() - 1))) 
            {
                return path->Substring(iExt);
            }
        }
        return System::String::Empty;
    }
    
    System::String* Path::GetFileName(System::String* path) {
        if(((path ==  nullptr) || (path->get_Length() ==  0))) 
        {
            return path;
        }
        if((path->IndexOfAny(InvalidPathChars) != -1)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Illegal characters in path."));
        }
        int32_t nLast = path->LastIndexOfAny(PathSeparatorChars);
        if((nLast >= 0)) 
        {
            return path->Substring((nLast + 1));
        }
        return path;
    }
    
    System::String* Path::GetFileNameWithoutExtension(System::String* path) {
        return ChangeExtension(GetFileName(path), nullptr);
    }
    
    System::String* Path::GetFullPath(System::String* path) {
        System::String *fullpath = InsecureGetFullPath(path);
        System::Security::SecurityManager::EnsureElevatedPermissions();
        if(System::Security::SecurityManager::get_SecurityEnabled()) 
        {
            cli::gcnew<System::Security::Permissions::FileIOPermission>(System::Security::Permissions::FileIOPermissionAccess::PathDiscovery, fullpath)->Demand();
        }
        return fullpath;
    }
    
    System::String* Path::WindowsDriveAdjustment(System::String* path) {
        if((path->get_Length() < 2)) 
        {
            return path;
        }
        if((((int32_t)(path->get_Chars(1)) != 58) || !(System::Char::IsLetter(path->get_Chars(0))))) 
        {
            return path;
        }
        System::String *current = Directory::GetCurrentDirectory();
        if((path->get_Length() ==  2)) 
        {
            if(((int32_t)(current->get_Chars(0)) ==  (int32_t)(path->get_Chars(0)))) 
            {
                path = current;
            }
             else 
            {
                (path = cli::concat(path, cli::box(u'\\')));
            }
        }
         else 
        {
            if((((int32_t)(path->get_Chars(2)) != (int32_t)(DirectorySeparatorChar)) && ((int32_t)(path->get_Chars(2)) != (int32_t)(AltDirectorySeparatorChar)))) 
            {
                if(((int32_t)(current->get_Chars(0)) ==  (int32_t)(path->get_Chars(0)))) 
                {
                    path = Path::Combine(current, path->Substring2(2, (path->get_Length() - 2)));
                }
                 else 
                {
                    path = System::String::Concat6(path->Substring2(0, 2), DirectorySeparatorStr, path->Substring2(2, (path->get_Length() - 2)));
                }
            }
        }
        return path;
    }
    
    System::String* Path::InsecureGetFullPath(System::String* path) {
        if((path ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("path"));
        }
        if((path->Trim()->get_Length() ==  0)) 
        {
            System::String *msg = Locale::GetText(_T("The specified path is not of a legal form (empty)."));
            throw cli::gcnew<System::ArgumentException>(msg);
        }
        if(System::Environment::get_IsRunningOnWindows()) 
        {
            path = WindowsDriveAdjustment(path);
        }
        char16_t end = path->get_Chars((path->get_Length() - 1));
        bool canonicalize = true;
        if((((path->get_Length() >= 2) && IsDsc(path->get_Chars(0))) && IsDsc(path->get_Chars(1)))) 
        {
            if(((path->get_Length() ==  2) || (path->IndexOf5(path->get_Chars(0), 2) < 0))) 
            {
                throw cli::gcnew<System::ArgumentException>(_T("UNC paths should be of the form \\\\server\\share."));
            }
            if(((int32_t)(path->get_Chars(0)) != (int32_t)(DirectorySeparatorChar))) 
            {
                path = path->Replace(AltDirectorySeparatorChar, DirectorySeparatorChar);
            }
        }
         else 
        {
            if(!(IsPathRooted(path))) 
            {
                int32_t start = 0;
                while(((start = path->IndexOf5(u'.', start)) != (-1))) {
                    if((((++start ==  path->get_Length()) || ((int32_t)(path->get_Chars(start)) ==  (int32_t)(DirectorySeparatorChar))) || ((int32_t)(path->get_Chars(start)) ==  (int32_t)(AltDirectorySeparatorChar)))) 
                    {
                        break;
                    }
                }
                canonicalize = (start > 0);
                path = cli::concat(Directory::GetCurrentDirectory(), DirectorySeparatorStr);
            }
             else 
            {
                if((((((int32_t)(DirectorySeparatorChar) ==  92) && (path->get_Length() >= 2)) && IsDsc(path->get_Chars(0))) && !(IsDsc(path->get_Chars(1))))) 
                {
                    System::String *current = Directory::GetCurrentDirectory();
                    if(((int32_t)(current->get_Chars(1)) ==  (int32_t)(VolumeSeparatorChar))) 
                    {
                        path = cli::concat(current->Substring2(0, 2), path);
                    }
                     else 
                    {
                        path = current->Substring2(0, current->IndexOf5(u'\\', (current->IndexOf7(_T("\\\\")) + 1)));
                    }
                }
            }
        }
        if(canonicalize) 
        {
            path = CanonicalizePath(path);
        }
        if((IsDsc(end) && ((int32_t)(path->get_Chars((path->get_Length() - 1))) != (int32_t)(DirectorySeparatorChar)))) 
        {
            (path = cli::concat(path, cli::box(DirectorySeparatorChar)));
        }
        return path;
    }
    
    bool Path::IsDsc(char16_t c) {
        return (((int32_t)(c) ==  (int32_t)(DirectorySeparatorChar)) || ((int32_t)(c) ==  (int32_t)(AltDirectorySeparatorChar)));
    }
    
    System::String* Path::GetPathRoot(System::String* path) {
        if((path ==  nullptr)) 
        {
            return nullptr;
        }
        if((path->Trim()->get_Length() ==  0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("The specified path is not of a legal form."));
        }
        if(!(IsPathRooted(path))) 
        {
            return System::String::Empty;
        }
        if(((int32_t)(DirectorySeparatorChar) ==  47)) 
        {
            return IsDsc(path->get_Chars(0)) ? DirectorySeparatorStr : System::String::Empty;
        }
         else 
        {
            int32_t len = 2;
            if(((path->get_Length() ==  1) && IsDsc(path->get_Chars(0)))) 
            {
                return DirectorySeparatorStr;
            }
             else 
            {
                if((path->get_Length() < 2)) 
                {
                    return System::String::Empty;
                }
            }
            if((IsDsc(path->get_Chars(0)) && IsDsc(path->get_Chars(1)))) 
            {
                while(((len < path->get_Length()) && !(IsDsc(path->get_Chars(len))))) len++;
                if((len < path->get_Length())) 
                {
                    len++;
                    while(((len < path->get_Length()) && !(IsDsc(path->get_Chars(len))))) len++;
                }
                return cli::concat(DirectorySeparatorStr, DirectorySeparatorStr);
            }
             else 
            {
                if(IsDsc(path->get_Chars(0))) 
                {
                    return DirectorySeparatorStr;
                }
                 else 
                {
                    if(((int32_t)(path->get_Chars(1)) ==  (int32_t)(VolumeSeparatorChar))) 
                    {
                        if(((path->get_Length() >= 3) && IsDsc(path->get_Chars(2)))) 
                        {
                            len++;
                        }
                    }
                     else 
                    {
                        return Directory::GetCurrentDirectory()->Substring2(0, 2);
                    }
                }
            }
            return path->Substring2(0, len);
        }
    }
    
    System::String* Path::GetTempFileName() {
        FileStream *f = nullptr;
        System::String *path;
        System::Random *rnd;
        int32_t num = 0;
        int32_t count = 0;
        System::Security::SecurityManager::EnsureElevatedPermissions();
        rnd = cli::gcnew<System::Random>();
        do {
            num = rnd->Next_5d1c2ba772311adc();
            num++;
            path = Path::Combine(GetTempPath(), cli::concat(_T("tmp"), cli::import(num)->ToString4(_T("x"))));
            try {
                f = cli::gcnew<FileStream>(path, FileMode::CreateNew, FileAccess::ReadWrite, FileShare::Read, 8192, false, (FileOptions)1L);
            }
            catch(IOException* ex) {
                if(((ex->hresult != MonoIO::FileAlreadyExistsHResult) || (count++ > 65536))) 
                {
                    throw ;
                }
            }
        }
        while((f ==  nullptr));
        f->Close_59c62ed53ef2a481();
        return path;
    }
    
    System::String* Path::GetTempPath() {
        System::Security::SecurityManager::EnsureElevatedPermissions();
        System::String *p = get_temp_path();
        if(((p->get_Length() > 0) && ((int32_t)(p->get_Chars((p->get_Length() - 1))) != (int32_t)(DirectorySeparatorChar)))) 
        {
            return cli::concat(p, cli::box(DirectorySeparatorChar));
        }
        return p;
    }
    
    System::String* Path::get_temp_path() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool Path::HasExtension(System::String* path) {
        if(((path ==  nullptr) || (path->Trim()->get_Length() ==  0))) 
        {
            return false;
        }
        if((path->IndexOfAny(InvalidPathChars) != -1)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Illegal characters in path."));
        }
        int32_t pos = findExtension(path);
        return ((0 <= pos) && (pos < (path->get_Length() - 1)));
    }
    
    bool Path::IsPathRooted(System::String* path) {
        if(((path ==  nullptr) || (path->get_Length() ==  0))) 
        {
            return false;
        }
        if((path->IndexOfAny(InvalidPathChars) != -1)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Illegal characters in path."));
        }
        char16_t c = path->get_Chars(0);
        return ((((int32_t)(c) ==  (int32_t)(DirectorySeparatorChar)) || ((int32_t)(c) ==  (int32_t)(AltDirectorySeparatorChar))) || ((!(dirEqualsVolume) && (path->get_Length() > 1)) && ((int32_t)(path->get_Chars(1)) ==  (int32_t)(VolumeSeparatorChar))));
    }
    
    cli::array<char16_t>* Path::GetInvalidFileNameChars() {
        if(System::Environment::get_IsRunningOnWindows()) 
        {
            return (new cli::array<char16_t>({u'\x0', u'\x1', u'\x2', u'\x3', u'\x4', u'\x5', u'\x6', u'\x7', u'\x8', u'\x9', u'\xa', u'\xb', u'\xc', u'\xd', u'\xe', u'\xf', u'\x10', u'\x11', u'\x12', u'\x13', u'\x14', u'\x15', u'\x16', u'\x17', u'\x18', u'\x19', u'\x1a', u'\x1b', u'\x1c', u'\x1d', u'\x1e', u'\x1f', u'"', u'<', u'>', u'\x7c', u':', u'*', u'?', u'\\', u'/'}));
        }
         else 
        {
            return (new cli::array<char16_t>({u'\x0', u'/'}));
        }
    }
    
    cli::array<char16_t>* Path::GetInvalidPathChars() {
        if(System::Environment::get_IsRunningOnWindows()) 
        {
            return (new cli::array<char16_t>({u'"', u'<', u'>', u'\x7c', u'\x0', u'\x1', u'\x2', u'\x3', u'\x4', u'\x5', u'\x6', u'\x7', u'\x8', u'\x9', u'\xa', u'\xb', u'\xc', u'\xd', u'\xe', u'\xf', u'\x10', u'\x11', u'\x12', u'\x13', u'\x14', u'\x15', u'\x16', u'\x17', u'\x18', u'\x19', u'\x1a', u'\x1b', u'\x1c', u'\x1d', u'\x1e', u'\x1f'}));
        }
         else 
        {
            return (new cli::array<char16_t>({u'\x0'}));
        }
    }
    
    System::String* Path::GetRandomFileName() {
        System::Text::StringBuilder *sb = cli::gcnew<System::Text::StringBuilder>(12);
        System::Security::Cryptography::RandomNumberGenerator *rng = System::Security::Cryptography::RandomNumberGenerator::Create();
        cli::array<unsigned char> *buffer = (new cli::array<unsigned char>(11));
        rng->GetBytes_bf6c3bc1baf70dfd(buffer);
        for(int32_t i = 0; (i < buffer->get_Length()); i++){
            if((sb->get_Length() ==  8)) 
            {
                sb->Append16(u'.');
            }
            int32_t b = ((int32_t)(buffer->at(i)) % 36);
            char16_t c = (char16_t)(b < 26) ? (b + 97) : ((b - 26) + 48);
            sb->Append16(c);
        }
        return sb->ToString_1636a0751cb9ac11();
    }
    
    int32_t Path::findExtension(System::String* path) {
        if((path != nullptr)) 
        {
            int32_t iLastDot = path->LastIndexOf4(u'.');
            int32_t iLastSep = path->LastIndexOfAny(PathSeparatorChars);
            if((iLastDot > iLastSep)) 
            {
                return iLastDot;
            }
        }
        return -1;
    }
    
    System::String* Path::GetServerAndShare(System::String* path) {
        int32_t len = 2;
        while(((len < path->get_Length()) && !(IsDsc(path->get_Chars(len))))) len++;
        if((len < path->get_Length())) 
        {
            len++;
            while(((len < path->get_Length()) && !(IsDsc(path->get_Chars(len))))) len++;
        }
        return path->Substring2(2, (len - 2))->Replace(AltDirectorySeparatorChar, DirectorySeparatorChar);
    }
    
    bool Path::SameRoot(System::String* root, System::String* path) {
        if(((root->get_Length() < 2) || (path->get_Length() < 2))) 
        {
            return false;
        }
        if((IsDsc(root->get_Chars(0)) && IsDsc(root->get_Chars(1)))) 
        {
            if(!((IsDsc(path->get_Chars(0)) && IsDsc(path->get_Chars(1))))) 
            {
                return false;
            }
            System::String *rootShare = GetServerAndShare(root);
            System::String *pathShare = GetServerAndShare(path);
            return (System::String::Compare3(rootShare, pathShare, true, System::Globalization::CultureInfo::get_InvariantCulture()) ==  0);
        }
        if(!(cli::import(root->get_Chars(0))->Equals2(path->get_Chars(0)))) 
        {
            return false;
        }
        if(((int32_t)(path->get_Chars(1)) != (int32_t)(VolumeSeparatorChar))) 
        {
            return false;
        }
        if(((root->get_Length() > 2) && (path->get_Length() > 2))) 
        {
            return (IsDsc(root->get_Chars(2)) && IsDsc(path->get_Chars(2)));
        }
        return true;
    }
    
    System::String* Path::CanonicalizePath(System::String* path) {
        if((path ==  nullptr)) 
        {
            return path;
        }
        if(System::Environment::get_IsRunningOnWindows()) 
        {
            path = path->Trim();
        }
        if((path->get_Length() ==  0)) 
        {
            return path;
        }
        System::String *root = Path::GetPathRoot(path);
        cli::array<System::String*> *dirs = path->Split((new cli::array<char16_t>({DirectorySeparatorChar, AltDirectorySeparatorChar})));
        int32_t target = 0;
        bool isUnc = (((System::Environment::get_IsRunningOnWindows() && (root->get_Length() > 2)) && IsDsc(root->get_Chars(0))) && IsDsc(root->get_Chars(1)));
        int32_t limit = isUnc ? 3 : 0;
        for(int32_t i = 0; (i < dirs->get_Length()); i++){
            if(System::Environment::get_IsRunningOnWindows()) 
            {
                dirs->at(i) = dirs->at(i)->TrimEnd((new cli::array<char16_t>({})));
            }
            if((System::String::op_Equality(dirs->at(i), _T(".")) || ((i != 0) && (dirs->at(i)->get_Length() ==  0)))) 
            {
                continue;
            }
             else 
            {
                if(System::String::op_Equality(dirs->at(i), _T(".."))) 
                {
                    if((target > limit)) 
                    {
                        target--;
                    }
                }
                 else 
                {
                    dirs->at(target++) = dirs->at(i);
                }
            }
        }
        if(((target ==  0) || ((target ==  1) && System::String::op_Equality(dirs->at(0), _T(""))))) 
        {
            return root;
        }
         else 
        {
            System::String *ret = System::String::Join2(DirectorySeparatorStr, dirs, 0, target);
            if(System::Environment::get_IsRunningOnWindows()) 
            {
                if(isUnc) 
                {
                    ret = cli::concat(DirectorySeparatorStr, ret);
                }
                if(!(SameRoot(root, ret))) 
                {
                    ret = cli::concat(root, ret);
                }
                if(isUnc) 
                {
                    return ret;
                }
                 else 
                {
                    if((!(IsDsc(path->get_Chars(0))) && SameRoot(root, path))) 
                    {
                        if(((ret->get_Length() <= 2) && !(ret->EndsWith(DirectorySeparatorStr)))) 
                        {
                            (ret = cli::concat(ret, cli::box(DirectorySeparatorChar)));
                        }
                        return ret;
                    }
                     else 
                    {
                        System::String *current = Directory::GetCurrentDirectory();
                        if(((current->get_Length() > 1) && ((int32_t)(current->get_Chars(1)) ==  (int32_t)(VolumeSeparatorChar)))) 
                        {
                            if(((ret->get_Length() ==  0) || IsDsc(ret->get_Chars(0)))) 
                            {
                                (ret = cli::concat(ret, cli::box(u'\\')));
                            }
                            return cli::concat(current->Substring2(0, 2), ret);
                        }
                         else 
                        {
                            if((IsDsc(current->get_Chars((current->get_Length() - 1))) && IsDsc(ret->get_Chars(0)))) 
                            {
                                return cli::concat(current, ret->Substring(1));
                            }
                             else 
                            {
                                return cli::concat(current, ret);
                            }
                        }
                    }
                }
            }
            return ret;
        }
    }
    
    bool Path::IsPathSubsetOf(System::String* subset, System::String* path) {
        if((subset->get_Length() > path->get_Length())) 
        {
            return false;
        }
        int32_t slast = subset->LastIndexOfAny(PathSeparatorChars);
        if((System::String::Compare4(subset, 0, path, 0, slast) != 0)) 
        {
            return false;
        }
        slast++;
        int32_t plast = path->IndexOfAny2(PathSeparatorChars, slast);
        if((plast >= slast)) 
        {
            return (System::String::Compare4(subset, slast, path, slast, (path->get_Length() - plast)) ==  0);
        }
        if((subset->get_Length() != path->get_Length())) 
        {
            return false;
        }
        return (System::String::Compare4(subset, slast, path, slast, (subset->get_Length() - slast)) ==  0);
    }
    
    System::String* Path::Combine2(cli::array<System::String*>* paths) {
        if((paths ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("paths"));
        }
        bool need_sep;
        System::Text::StringBuilder *ret = cli::gcnew<System::Text::StringBuilder>();
        int32_t pathsLen = paths->get_Length();
        int32_t slen;
        for(auto tmp_249 : paths) {
            auto s = cli::cast<System::String*>(tmp_249);
            {
                need_sep = false;
                if((s ==  nullptr)) 
                {
                    throw cli::gcnew<System::ArgumentNullException>(_T("One of the paths contains a null value"), _T("paths"));
                }
                if((s->IndexOfAny(InvalidPathChars) != -1)) 
                {
                    throw cli::gcnew<System::ArgumentException>(_T("Illegal characters in path."));
                }
                pathsLen--;
                if(IsPathRooted(s)) 
                {
                    ret->set_Length(0);
                }
                ret->Append2(s);
                slen = s->get_Length();
                if(((slen > 0) && (pathsLen > 0))) 
                {
                    char16_t p1end = s->get_Chars((slen - 1));
                    if(((((int32_t)(p1end) != (int32_t)(DirectorySeparatorChar)) && ((int32_t)(p1end) != (int32_t)(AltDirectorySeparatorChar))) && ((int32_t)(p1end) != (int32_t)(VolumeSeparatorChar)))) 
                    {
                        need_sep = true;
                    }
                }
                if(need_sep) 
                {
                    ret->Append2(DirectorySeparatorStr);
                }
            }
        }
        return ret->ToString_1636a0751cb9ac11();
    }
    
    System::String* Path::Combine3(System::String* path1, System::String* path2, System::String* path3) {
        if((path1 ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("path1"));
        }
        if((path2 ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("path2"));
        }
        if((path3 ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("path3"));
        }
        return Combine2((new cli::array<System::String*>({path1, path2, path3})));
    }
    
    System::String* Path::Combine4(System::String* path1, System::String* path2, System::String* path3, System::String* path4) {
        if((path1 ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("path1"));
        }
        if((path2 ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("path2"));
        }
        if((path3 ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("path3"));
        }
        if((path4 ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("path4"));
        }
        return Combine2((new cli::array<System::String*>({path1, path2, path3, path4})));
    }
    
    void Path::Validate(System::String* path) {
        Validate2(path, _T("path"));
    }
    
    void Path::Validate2(System::String* path, System::String* parameterName) {
        if((path ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(parameterName);
        }
        if(System::String::IsNullOrWhiteSpace(path)) 
        {
            throw cli::gcnew<System::ArgumentException>(Locale::GetText(_T("Path is empty")));
        }
        if((path->IndexOfAny(InvalidPathChars) != -1)) 
        {
            throw cli::gcnew<System::ArgumentException>(Locale::GetText(_T("Path contains invalid chars")));
        }
        if(System::Environment::get_IsRunningOnWindows()) 
        {
            int32_t idx = path->IndexOf4(u':');
            if(((idx >= 0) && (idx != 1))) 
            {
                throw cli::gcnew<System::ArgumentException>(parameterName);
            }
        }
    }
    
}}
namespace System { namespace IO {
    
    
    void PathTooLongException::constructor() {
    }
    
    void PathTooLongException::constructor(System::String* message) {
    }
    
    void PathTooLongException::constructor(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
    }
    
    void PathTooLongException::constructor(System::String* message, System::Exception* innerException) {
    }
    
}}
namespace System { namespace IO {
    
    cli::array<char16_t>*  SearchPattern::WildcardChars;
    
    SearchPattern::SearchPattern()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void SearchPattern::constructor() {
    }
    
    void SearchPattern::static_constructor() {
    }
    
}}
namespace System { namespace IO {
    
    Stream*  Stream::Null;
    
    Stream::Stream()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void Stream::constructor() {
    }
    
    void Stream::static_constructor() {
    }
    
    void Stream::Dispose() {
        Close_59c62ed53ef2a481();
    }
    
    void Stream::Dispose_b215be19126499b0(bool disposing) {
        if(((this->async_event != nullptr) && disposing)) 
        {
            this->async_event->Close_c2b8b3b2024d18b6();
            this->async_event = nullptr;
        }
    }
    
    void Stream::Close_59c62ed53ef2a481() {
        Dispose_b215be19126499b0(true);
        System::GC::SuppressFinalize(this);
    }
    
    Stream* Stream::Synchronized(Stream* stream) {
        return cli::gcnew<SynchronizedStream>(stream);
    }
    
    System::Threading::WaitHandle* Stream::CreateWaitHandle_becb19c241245f1e() {
        return cli::gcnew<System::Threading::ManualResetEvent>(false);
    }
    
    int32_t Stream::ReadByte_61a294e42318f99() {
        cli::array<unsigned char> *buffer = (new cli::array<unsigned char>(1));
        if((Read_c0d6dde3943b413e(buffer, 0, 1) ==  1)) 
        {
            return (int32_t)(buffer->at(0));
        }
        return -1;
    }
    
    void Stream::WriteByte_4404d6329af3b6d5(unsigned char value) {
        cli::array<unsigned char> *buffer = (new cli::array<unsigned char>(1));
        buffer->at(0) = value;
        Write_1f8a1dbe71b0eb89(buffer, 0, 1);
    }
    
    System::IAsyncResult* Stream::BeginRead_783f127b729b2f0a(cli::array<unsigned char>* buffer, int32_t offset, int32_t count, System::AsyncCallback* callback, System::Object* state) {
        if(!(this->get_CanRead_50a10d564be8aaa2())) 
        {
            throw cli::gcnew<System::NotSupportedException>(_T("This stream does not support reading"));
        }
        if((this->async_event ==  nullptr)) 
        {
            {
                cli::lock_guard{this};
                if((this->async_event ==  nullptr)) 
                {
                    this->async_event = cli::gcnew<System::Threading::AutoResetEvent>(true);
                }
            }
        }
        this->async_event->WaitOne_a04a6b7360612836();
        this->async_read = cli::bind(this, &Stream::Read_c0d6dde3943b413e);
        return this->async_read->BeginInvoke(buffer, offset, count, callback, state);
    }
    
    System::IAsyncResult* Stream::BeginWrite_85b245acef3a8d4a(cli::array<unsigned char>* buffer, int32_t offset, int32_t count, System::AsyncCallback* callback, System::Object* state) {
        if(!(this->get_CanWrite_c8955eadfc77124c())) 
        {
            throw cli::gcnew<System::NotSupportedException>(_T("This stream does not support writing"));
        }
        if((this->async_event ==  nullptr)) 
        {
            {
                cli::lock_guard{this};
                if((this->async_event ==  nullptr)) 
                {
                    this->async_event = cli::gcnew<System::Threading::AutoResetEvent>(true);
                }
            }
        }
        this->async_event->WaitOne_a04a6b7360612836();
        this->async_write = cli::bind(this, &Stream::Write_1f8a1dbe71b0eb89);
        return this->async_write->BeginInvoke(buffer, offset, count, callback, state);
    }
    
    int32_t Stream::EndRead_fffd36c36fbcca5b(System::IAsyncResult* asyncResult) {
        if((asyncResult ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("asyncResult"));
        }
        if((this->async_read ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("EndRead cannot be called multiple times"));
        }
        {
            cli::finally_guard([&]() {
                this->async_read = nullptr;
                this->async_event->Set();
            });
            return this->async_read->EndInvoke(asyncResult);
        }
    }
    
    void Stream::EndWrite_4a9b8c2a22f9c4e3(System::IAsyncResult* asyncResult) {
        if((asyncResult ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("asyncResult"));
        }
        if((this->async_write ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("EndWrite cannot be called multiple times"));
        }
        {
            cli::finally_guard([&]() {
                this->async_write = nullptr;
                this->async_event->Set();
            });
            this->async_write->EndInvoke(asyncResult);
        }
    }
    
    void Stream::CopyTo(Stream* destination) {
        CopyTo2(destination, 16384);
    }
    
    void Stream::CopyTo2(Stream* destination, int32_t bufferSize) {
        if((destination ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("destination"));
        }
        if(!(this->get_CanRead_50a10d564be8aaa2())) 
        {
            throw cli::gcnew<System::NotSupportedException>(_T("This stream does not support reading"));
        }
        if(!(destination->get_CanWrite_c8955eadfc77124c())) 
        {
            throw cli::gcnew<System::NotSupportedException>(_T("This destination stream does not support writing"));
        }
        if((bufferSize <= 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("bufferSize"));
        }
        cli::array<unsigned char> *buffer = (new cli::array<unsigned char>(bufferSize));
        int32_t nread;
        while(((nread = Read_c0d6dde3943b413e(buffer, 0, bufferSize)) != (0))) destination->Write_1f8a1dbe71b0eb89(buffer, 0, nread);
    }
    
    void Stream::ObjectInvariant_58e7c07b1f0b3353() {
    }
    
    bool Stream::get_CanTimeout_b7da06c4b3fd4fd6() {
        return false;
    }
    
    int32_t Stream::get_ReadTimeout_a54423ea8c960199() {
        throw cli::gcnew<System::InvalidOperationException>(_T("Timeouts are not supported on this stream."));
    }
    
    int32_t Stream::set_ReadTimeout_eab8786697629725(int32_t value) {
        throw cli::gcnew<System::InvalidOperationException>(_T("Timeouts are not supported on this stream."));
        return get_ReadTimeout_a54423ea8c960199();
    }
    
    int32_t Stream::get_WriteTimeout_6db3b36efa1fd0f() {
        throw cli::gcnew<System::InvalidOperationException>(_T("Timeouts are not supported on this stream."));
    }
    
    int32_t Stream::set_WriteTimeout_a9da1b34d1999ee9(int32_t value) {
        throw cli::gcnew<System::InvalidOperationException>(_T("Timeouts are not supported on this stream."));
        return get_WriteTimeout_6db3b36efa1fd0f();
    }
    
}}
namespace System { namespace IO {
    
    
    void NullStream::constructor() {
    }
    
    void NullStream::Flush_132821400030c993() {
    }
    
    int32_t NullStream::Read_c0d6dde3943b413e(cli::array<unsigned char>* buffer, int32_t offset, int32_t count) {
        return 0;
    }
    
    int32_t NullStream::ReadByte_61a294e42318f99() {
        return -1;
    }
    
    int64_t NullStream::Seek_df5b3eadfe9adf31(int64_t offset, SeekOrigin origin) {
        return 0L;
    }
    
    void NullStream::SetLength_18d421048f3d4df5(int64_t value) {
    }
    
    void NullStream::Write_1f8a1dbe71b0eb89(cli::array<unsigned char>* buffer, int32_t offset, int32_t count) {
    }
    
    void NullStream::WriteByte_4404d6329af3b6d5(unsigned char value) {
    }
    
    bool NullStream::get_CanRead_50a10d564be8aaa2() {
        return true;
    }
    
    bool NullStream::get_CanSeek_8c8861ce02c6bdeb() {
        return true;
    }
    
    bool NullStream::get_CanWrite_c8955eadfc77124c() {
        return true;
    }
    
    int64_t NullStream::get_Length_ddb8b0d061db5350() {
        return 0L;
    }
    
    int64_t NullStream::get_Position_5e75d5c458401f13() {
        return 0L;
    }
    
    int64_t NullStream::set_Position_cfe1def757785ad(int64_t value) {
        return get_Position_5e75d5c458401f13();
    }
    
}}
namespace System { namespace IO {
    
    
    void SynchronizedStream::constructor(Stream* source) {
        this->source = source;
        this->slock = cli::gcnew<System::Object>();
    }
    
    void SynchronizedStream::Flush_132821400030c993() {
        cli::lock_guard{this->slock};
        {
            this->source->Flush_132821400030c993();
        }
    }
    
    int32_t SynchronizedStream::Read_c0d6dde3943b413e(cli::array<unsigned char>* buffer, int32_t offset, int32_t count) {
        cli::lock_guard{this->slock};
        {
            return this->source->Read_c0d6dde3943b413e(buffer, offset, count);
        }
    }
    
    int32_t SynchronizedStream::ReadByte_61a294e42318f99() {
        cli::lock_guard{this->slock};
        {
            return this->source->ReadByte_61a294e42318f99();
        }
    }
    
    int64_t SynchronizedStream::Seek_df5b3eadfe9adf31(int64_t offset, SeekOrigin origin) {
        cli::lock_guard{this->slock};
        {
            return this->source->Seek_df5b3eadfe9adf31(offset, origin);
        }
    }
    
    void SynchronizedStream::SetLength_18d421048f3d4df5(int64_t value) {
        cli::lock_guard{this->slock};
        {
            this->source->SetLength_18d421048f3d4df5(value);
        }
    }
    
    void SynchronizedStream::Write_1f8a1dbe71b0eb89(cli::array<unsigned char>* buffer, int32_t offset, int32_t count) {
        cli::lock_guard{this->slock};
        {
            this->source->Write_1f8a1dbe71b0eb89(buffer, offset, count);
        }
    }
    
    void SynchronizedStream::WriteByte_4404d6329af3b6d5(unsigned char value) {
        cli::lock_guard{this->slock};
        {
            this->source->WriteByte_4404d6329af3b6d5(value);
        }
    }
    
    bool SynchronizedStream::get_CanRead_50a10d564be8aaa2() {
        cli::lock_guard{this->slock};
        {
            return this->source->get_CanRead_50a10d564be8aaa2();
        }
    }
    
    bool SynchronizedStream::get_CanSeek_8c8861ce02c6bdeb() {
        cli::lock_guard{this->slock};
        {
            return this->source->get_CanSeek_8c8861ce02c6bdeb();
        }
    }
    
    bool SynchronizedStream::get_CanWrite_c8955eadfc77124c() {
        cli::lock_guard{this->slock};
        {
            return this->source->get_CanWrite_c8955eadfc77124c();
        }
    }
    
    int64_t SynchronizedStream::get_Length_ddb8b0d061db5350() {
        cli::lock_guard{this->slock};
        {
            return this->source->get_Length_ddb8b0d061db5350();
        }
    }
    
    int64_t SynchronizedStream::get_Position_5e75d5c458401f13() {
        cli::lock_guard{this->slock};
        {
            return this->source->get_Position_5e75d5c458401f13();
        }
    }
    
    int64_t SynchronizedStream::set_Position_cfe1def757785ad(int64_t value) {
        cli::lock_guard{this->slock};
        {
            this->source->set_Position_cfe1def757785ad(value);
        }
        return get_Position_5e75d5c458401f13();
    }
    
}}
namespace System { namespace IO {
    
    
    void NullStreamReader::constructor() {
    }
    
    int32_t NullStreamReader::Peek_82f04bf3cd196dfd() {
        return -1;
    }
    
    int32_t NullStreamReader::Read_1d437d5ac2290f2b() {
        return -1;
    }
    
    int32_t NullStreamReader::Read_24d2c98803d927e8(cli::array<char16_t>* buffer, int32_t index, int32_t count) {
        return 0;
    }
    
    System::String* NullStreamReader::ReadLine_51552a49261f929e() {
        return nullptr;
    }
    
    System::String* NullStreamReader::ReadToEnd_f683943dd5002e1e() {
        return System::String::Empty;
    }
    
    Stream* NullStreamReader::get_BaseStream_cbffc4235bf758d4() {
        return Stream::Null;
    }
    
    System::Text::Encoding* NullStreamReader::get_CurrentEncoding_b15371dbc6908554() {
        return System::Text::Encoding::get_Unicode();
    }
    
}}
namespace System { namespace IO {
    
    cli::array<unsigned char>*  StreamReader::input_buffer_recycle;
    System::Object*  StreamReader::input_buffer_recycle_lock;
    cli::array<char16_t>*  StreamReader::decoded_buffer_recycle;
    StreamReader*  StreamReader::Null2;
    
    StreamReader::StreamReader()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void StreamReader::constructor() {
    }
    
    void StreamReader::constructor(Stream* stream) {
    }
    
    void StreamReader::constructor(Stream* stream, bool detectEncodingFromByteOrderMarks) {
    }
    
    void StreamReader::constructor(Stream* stream, System::Text::Encoding* encoding) {
    }
    
    void StreamReader::constructor(Stream* stream, System::Text::Encoding* encoding, bool detectEncodingFromByteOrderMarks) {
    }
    
    void StreamReader::constructor(Stream* stream, System::Text::Encoding* encoding, bool detectEncodingFromByteOrderMarks, int32_t bufferSize) {
        Initialize(stream, encoding, detectEncodingFromByteOrderMarks, bufferSize);
    }
    
    void StreamReader::constructor(System::String* path) {
    }
    
    void StreamReader::constructor(System::String* path, bool detectEncodingFromByteOrderMarks) {
    }
    
    void StreamReader::constructor(System::String* path, System::Text::Encoding* encoding) {
    }
    
    void StreamReader::constructor(System::String* path, System::Text::Encoding* encoding, bool detectEncodingFromByteOrderMarks) {
    }
    
    void StreamReader::constructor(System::String* path, System::Text::Encoding* encoding, bool detectEncodingFromByteOrderMarks, int32_t bufferSize) {
        if((path ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("path"));
        }
        if(System::String::op_Equality(System::String::Empty, path)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Empty path not allowed"));
        }
        if((path->IndexOfAny(Path::InvalidPathChars) != -1)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("path contains invalid characters"));
        }
        if((encoding ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("encoding"));
        }
        if((bufferSize <= 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("bufferSize"), _T("The minimum size of the buffer must be positive"));
        }
        Stream *stream = cli::cast<Stream*>(File::OpenRead(path));
        Initialize(stream, encoding, detectEncodingFromByteOrderMarks, bufferSize);
    }
    
    void StreamReader::static_constructor() {
    }
    
    void StreamReader::Initialize(Stream* stream, System::Text::Encoding* encoding, bool detectEncodingFromByteOrderMarks, int32_t bufferSize) {
        if((stream ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("stream"));
        }
        if((encoding ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("encoding"));
        }
        if(!(stream->get_CanRead_50a10d564be8aaa2())) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Cannot read stream"));
        }
        if((bufferSize <= 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("bufferSize"), _T("The minimum size of the buffer must be positive"));
        }
        if((bufferSize < 128)) 
        {
            bufferSize = 128;
        }
        int32_t decoded_buffer_size = (encoding->GetMaxCharCount_4eba560ac1240518(bufferSize) + 1);
        if(((bufferSize <= 1024) && (input_buffer_recycle != nullptr))) 
        {
            {
                cli::lock_guard{input_buffer_recycle_lock};
                if((input_buffer_recycle != nullptr)) 
                {
                    this->input_buffer = input_buffer_recycle;
                    input_buffer_recycle = nullptr;
                }
                if(((decoded_buffer_recycle != nullptr) && (decoded_buffer_size <= decoded_buffer_recycle->get_Length()))) 
                {
                    this->decoded_buffer = decoded_buffer_recycle;
                    decoded_buffer_recycle = nullptr;
                }
            }
        }
        if((this->input_buffer ==  nullptr)) 
        {
            this->input_buffer = (new cli::array<unsigned char>(bufferSize));
        }
         else 
        {
            System::Array::Clear2(this->input_buffer, 0, bufferSize);
        }
        if((this->decoded_buffer ==  nullptr)) 
        {
            this->decoded_buffer = (new cli::array<char16_t>(decoded_buffer_size));
        }
         else 
        {
            System::Array::Clear2(this->decoded_buffer, 0, decoded_buffer_size);
        }
        this->base_stream = stream;
        this->buffer_size = bufferSize;
        this->encoding = encoding;
        this->decoder = encoding->GetDecoder_380c5e0c575e9cb5();
        cli::array<unsigned char> *preamble = encoding->GetPreamble_15ff85f00c460f87();
        this->do_checks = detectEncodingFromByteOrderMarks ? 1 : 0;
        (this->do_checks = this->do_checks + (preamble->get_Length() ==  0) ? 0 : 2);
        this->decoded_count = 0;
        this->pos = 0;
    }
    
    void StreamReader::Close_7c5ccd5fb8dfeba3() {
        TextReader::Dispose_6de32a3267835eb1(true);
    }
    
    void StreamReader::Dispose_6de32a3267835eb1(bool disposing) {
        if(((disposing && (this->base_stream != nullptr)) && true)) 
        {
            this->base_stream->Close_59c62ed53ef2a481();
        }
        if((((this->input_buffer != nullptr) && (this->input_buffer->get_Length() ==  1024)) && (input_buffer_recycle ==  nullptr))) 
        {
            {
                cli::lock_guard{input_buffer_recycle_lock};
                if((input_buffer_recycle ==  nullptr)) 
                {
                    input_buffer_recycle = this->input_buffer;
                }
                if((decoded_buffer_recycle ==  nullptr)) 
                {
                    decoded_buffer_recycle = this->decoded_buffer;
                }
            }
        }
        this->input_buffer = nullptr;
        this->decoded_buffer = nullptr;
        this->encoding = nullptr;
        this->decoder = nullptr;
        this->base_stream = nullptr;
        TextReader::Dispose_6de32a3267835eb1(disposing);
    }
    
    int32_t StreamReader::DoChecks(int32_t count) {
        if(((this->do_checks & 2) ==  2)) 
        {
            cli::array<unsigned char> *preamble = this->encoding->GetPreamble_15ff85f00c460f87();
            int32_t c = preamble->get_Length();
            if((count >= c)) 
            {
                int32_t i;
                for(i = 0; (i < c); i++) {
                    if(((int32_t)(this->input_buffer->at(i)) != (int32_t)(preamble->at(i)))) 
                    {
                        break;
                    }
                }
                if((i ==  c)) 
                {
                    return i;
                }
            }
        }
        if(((this->do_checks & 1) ==  1)) 
        {
            if((count < 2)) 
            {
                return 0;
            }
            if((((int32_t)(this->input_buffer->at(0)) ==  254) && ((int32_t)(this->input_buffer->at(1)) ==  255))) 
            {
                this->encoding = System::Text::Encoding::get_BigEndianUnicode();
                return 2;
            }
            if(((((int32_t)(this->input_buffer->at(0)) ==  255) && ((int32_t)(this->input_buffer->at(1)) ==  254)) && (count < 4))) 
            {
                this->encoding = System::Text::Encoding::get_Unicode();
                return 2;
            }
            if((count < 3)) 
            {
                return 0;
            }
            if(((((int32_t)(this->input_buffer->at(0)) ==  239) && ((int32_t)(this->input_buffer->at(1)) ==  187)) && ((int32_t)(this->input_buffer->at(2)) ==  191))) 
            {
                this->encoding = System::Text::Encoding::get_UTF8Unmarked();
                return 3;
            }
            if((count < 4)) 
            {
                if(((((int32_t)(this->input_buffer->at(0)) ==  255) && ((int32_t)(this->input_buffer->at(1)) ==  254)) && ((int32_t)(this->input_buffer->at(2)) != 0))) 
                {
                    this->encoding = System::Text::Encoding::get_Unicode();
                    return 2;
                }
                return 0;
            }
            if((((((int32_t)(this->input_buffer->at(0)) ==  0) && ((int32_t)(this->input_buffer->at(1)) ==  0)) && ((int32_t)(this->input_buffer->at(2)) ==  254)) && ((int32_t)(this->input_buffer->at(3)) ==  255))) 
            {
                this->encoding = System::Text::Encoding::get_BigEndianUTF32();
                return 4;
            }
            if((((int32_t)(this->input_buffer->at(0)) ==  255) && ((int32_t)(this->input_buffer->at(1)) ==  254))) 
            {
                if((((int32_t)(this->input_buffer->at(2)) ==  0) && ((int32_t)(this->input_buffer->at(3)) ==  0))) 
                {
                    this->encoding = System::Text::Encoding::get_UTF32();
                    return 4;
                }
                this->encoding = System::Text::Encoding::get_Unicode();
                return 2;
            }
        }
        return 0;
    }
    
    void StreamReader::DiscardBufferedData() {
        CheckState();
        this->pos = this->decoded_count = 0;
        this->mayBlock = false;
        this->decoder = this->encoding->GetDecoder_380c5e0c575e9cb5();
    }
    
    int32_t StreamReader::ReadBuffer() {
        this->pos = 0;
        int32_t cbEncoded = 0;
        this->decoded_count = 0;
        int32_t parse_start = 0;
        do {
            cbEncoded = this->base_stream->Read_c0d6dde3943b413e(this->input_buffer, 0, this->buffer_size);
            if((cbEncoded <= 0)) 
            {
                return 0;
            }
            this->mayBlock = (cbEncoded < this->buffer_size);
            if((this->do_checks > 0)) 
            {
                System::Text::Encoding *old = this->encoding;
                parse_start = DoChecks(cbEncoded);
                if((old != this->encoding)) 
                {
                    int32_t old_decoded_size = (old->GetMaxCharCount_4eba560ac1240518(this->buffer_size) + 1);
                    int32_t new_decoded_size = (this->encoding->GetMaxCharCount_4eba560ac1240518(this->buffer_size) + 1);
                    if((old_decoded_size != new_decoded_size)) 
                    {
                        this->decoded_buffer = (new cli::array<char16_t>(new_decoded_size));
                    }
                    this->decoder = this->encoding->GetDecoder_380c5e0c575e9cb5();
                }
                this->do_checks = 0;
                (cbEncoded = cbEncoded - parse_start);
            }
            (this->decoded_count = this->decoded_count + this->decoder->GetChars_beecc497fe0b7526(this->input_buffer, parse_start, cbEncoded, this->decoded_buffer, 0));
            parse_start = 0;
        }
        while((this->decoded_count ==  0));
        return this->decoded_count;
    }
    
    int32_t StreamReader::Peek_82f04bf3cd196dfd() {
        CheckState();
        if(((this->pos >= this->decoded_count) && (ReadBuffer() ==  0))) 
        {
            return -1;
        }
        return (int32_t)(this->decoded_buffer->at(this->pos));
    }
    
    bool StreamReader::DataAvailable() {
        return (this->pos < this->decoded_count);
    }
    
    int32_t StreamReader::Read_1d437d5ac2290f2b() {
        CheckState();
        if(((this->pos >= this->decoded_count) && (ReadBuffer() ==  0))) 
        {
            return -1;
        }
        return (int32_t)(this->decoded_buffer->at(this->pos++));
    }
    
    int32_t StreamReader::Read_24d2c98803d927e8(cli::array<char16_t>* buffer, int32_t index, int32_t count) {
        if((buffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("buffer"));
        }
        if((index < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("index"), _T("< 0"));
        }
        if((count < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("count"), _T("< 0"));
        }
        if((index > (buffer->get_Length() - count))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("index + count > buffer.Length"));
        }
        CheckState();
        int32_t chars_read = 0;
        while((count > 0)) {
            if(((this->pos >= this->decoded_count) && (ReadBuffer() ==  0))) 
            {
                return (chars_read > 0) ? chars_read : 0;
            }
            int32_t cch = System::Math::Min5((this->decoded_count - this->pos), count);
            System::Array::Copy2(this->decoded_buffer, this->pos, buffer, index, cch);
            (this->pos = this->pos + cch);
            (index = index + cch);
            (count = count - cch);
            (chars_read = chars_read + cch);
            if(this->mayBlock) 
            {
                break;
            }
        }
        return chars_read;
    }
    
    int32_t StreamReader::FindNextEOL() {
        char16_t c = u'\x0';
        for(; (this->pos < this->decoded_count); this->pos++){
            c = this->decoded_buffer->at(this->pos);
            if(((int32_t)(c) ==  10)) 
            {
                this->pos++;
                int32_t res = this->foundCR ? (this->pos - 2) : (this->pos - 1);
                if((res < 0)) 
                {
                    res = 0;
                }
                this->foundCR = false;
                return res;
            }
             else 
            {
                if(this->foundCR) 
                {
                    this->foundCR = false;
                    if((this->pos ==  0)) 
                    {
                        return -2;
                    }
                    return (this->pos - 1);
                }
            }
            this->foundCR = ((int32_t)(c) ==  13);
        }
        return -1;
    }
    
    System::String* StreamReader::ReadLine_51552a49261f929e() {
        CheckState();
        if(((this->pos >= this->decoded_count) && (ReadBuffer() ==  0))) 
        {
            return nullptr;
        }
        int32_t begin = this->pos;
        int32_t end = FindNextEOL();
        if(((end < this->decoded_count) && (end >= begin))) 
        {
            return cli::gcnew<System::String>(this->decoded_buffer, begin, (end - begin));
        }
         else 
        {
            if((end ==  -2)) 
            {
                return this->line_builder->ToString3(0, this->line_builder->get_Length());
            }
        }
        if((this->line_builder ==  nullptr)) 
        {
            this->line_builder = cli::gcnew<System::Text::StringBuilder>();
        }
         else 
        {
            this->line_builder->set_Length(0);
        }
        while(true) {
            if(this->foundCR) 
            {
                this->decoded_count--;
            }
            this->line_builder->Append18(this->decoded_buffer, begin, (this->decoded_count - begin));
            if((ReadBuffer() ==  0)) 
            {
                if((this->line_builder->get_Capacity() > 32768)) 
                {
                    System::Text::StringBuilder *sb = this->line_builder;
                    this->line_builder = nullptr;
                    return sb->ToString3(0, sb->get_Length());
                }
                return this->line_builder->ToString3(0, this->line_builder->get_Length());
            }
            begin = this->pos;
            end = FindNextEOL();
            if(((end < this->decoded_count) && (end >= begin))) 
            {
                this->line_builder->Append18(this->decoded_buffer, begin, (end - begin));
                if((this->line_builder->get_Capacity() > 32768)) 
                {
                    System::Text::StringBuilder *sb = this->line_builder;
                    this->line_builder = nullptr;
                    return sb->ToString3(0, sb->get_Length());
                }
                return this->line_builder->ToString3(0, this->line_builder->get_Length());
            }
             else 
            {
                if((end ==  -2)) 
                {
                    return this->line_builder->ToString3(0, this->line_builder->get_Length());
                }
            }
        }
    }
    
    System::String* StreamReader::ReadToEnd_f683943dd5002e1e() {
        CheckState();
        System::Text::StringBuilder *text = cli::gcnew<System::Text::StringBuilder>();
        int32_t size = this->decoded_buffer->get_Length();
        cli::array<char16_t> *buffer = (new cli::array<char16_t>(size));
        int32_t len;
        while(((len = TextReader::Read_24d2c98803d927e8(buffer, 0, size)) > (0))) text->Append18(buffer, 0, len);
        return text->ToString_1636a0751cb9ac11();
    }
    
    void StreamReader::CheckState() {
        if((this->base_stream ==  nullptr)) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("StreamReader"), _T("Cannot read from a closed StreamReader"));
        }
    }
    
    Stream* StreamReader::get_BaseStream_cbffc4235bf758d4() {
        return this->base_stream;
    }
    
    System::Text::Encoding* StreamReader::get_CurrentEncoding_b15371dbc6908554() {
        if((this->encoding ==  nullptr)) 
        {
            throw cli::gcnew<System::Exception>();
        }
        return this->encoding;
    }
    
    bool StreamReader::get_EndOfStream() {
        return (TextReader::Peek_82f04bf3cd196dfd() < 0);
    }
    
}}
namespace System { namespace IO {
    
    StreamWriter*  StreamWriter::Null2;
    
    StreamWriter::StreamWriter()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void StreamWriter::constructor(Stream* stream) {
    }
    
    void StreamWriter::constructor(Stream* stream, System::Text::Encoding* encoding) {
    }
    
    void StreamWriter::constructor(Stream* stream, System::Text::Encoding* encoding, int32_t bufferSize) {
        if((stream ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("stream"));
        }
        if((encoding ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("encoding"));
        }
        if((bufferSize <= 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("bufferSize"));
        }
        if(!(stream->get_CanWrite_c8955eadfc77124c())) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Can not write to stream"));
        }
        this->internalStream = stream;
        Initialize(encoding, bufferSize);
    }
    
    void StreamWriter::constructor(System::String* path) {
    }
    
    void StreamWriter::constructor(System::String* path, bool append) {
    }
    
    void StreamWriter::constructor(System::String* path, bool append, System::Text::Encoding* encoding) {
    }
    
    void StreamWriter::constructor(System::String* path, bool append, System::Text::Encoding* encoding, int32_t bufferSize) {
        if((encoding ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("encoding"));
        }
        if((bufferSize <= 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("bufferSize"));
        }
        FileMode mode;
        if(append) 
        {
            mode = FileMode::Append;
        }
         else 
        {
            mode = FileMode::Create;
        }
        this->internalStream = cli::gcnew<FileStream>(path, mode, FileAccess::Write, FileShare::Read);
        if(append) 
        {
            this->internalStream->set_Position_cfe1def757785ad(this->internalStream->get_Length_ddb8b0d061db5350());
        }
         else 
        {
            this->internalStream->SetLength_18d421048f3d4df5(0L);
        }
        Initialize(encoding, bufferSize);
    }
    
    void StreamWriter::static_constructor() {
    }
    
    void StreamWriter::Finalize_b7f7e65eab84c162() {
        {
            cli::finally_guard([&]() {
                Finalize_b946fbc32e26afd6();
            });
            TextWriter::Dispose_6868d8c2d2b3dfb7(false);
        }
    }
    
    void StreamWriter::Initialize(System::Text::Encoding* encoding, int32_t bufferSize) {
        this->internalEncoding = encoding;
        this->decode_pos = this->byte_pos = 0;
        int32_t BufferSize = System::Math::Max5(bufferSize, 256);
        this->decode_buf = (new cli::array<char16_t>(BufferSize));
        this->byte_buf = (new cli::array<unsigned char>(encoding->GetMaxByteCount_5bd2cee34757a0d4(BufferSize)));
        if((this->internalStream->get_CanSeek_8c8861ce02c6bdeb() && (this->internalStream->get_Position_5e75d5c458401f13() > 0L))) 
        {
            this->preamble_done = true;
        }
    }
    
    void StreamWriter::Dispose_6868d8c2d2b3dfb7(bool disposing) {
        System::Exception *exc = nullptr;
        if((((!(this->DisposedAlready) && disposing) && (this->internalStream != nullptr)) && true)) 
        {
            try {
                TextWriter::Flush_c8220c56815bfd56();
            }
            catch(System::Exception* e) {
                exc = e;
            }
            this->DisposedAlready = true;
            try {
                this->internalStream->Close_59c62ed53ef2a481();
            }
            catch(System::Exception* e) {
                if((exc ==  nullptr)) 
                {
                    exc = e;
                }
            }
        }
        this->internalStream = nullptr;
        this->byte_buf = nullptr;
        this->internalEncoding = nullptr;
        this->decode_buf = nullptr;
        if((exc != nullptr)) 
        {
            throw exc;
        }
    }
    
    void StreamWriter::Flush_c8220c56815bfd56() {
        CheckState();
        Decode();
        if((this->byte_pos > 0)) 
        {
            FlushBytes();
            this->internalStream->Flush_132821400030c993();
        }
    }
    
    void StreamWriter::FlushBytes() {
        if((!(this->preamble_done) && (this->byte_pos > 0))) 
        {
            cli::array<unsigned char> *preamble = this->internalEncoding->GetPreamble_15ff85f00c460f87();
            if((preamble->get_Length() > 0)) 
            {
                this->internalStream->Write_1f8a1dbe71b0eb89(preamble, 0, preamble->get_Length());
            }
            this->preamble_done = true;
        }
        this->internalStream->Write_1f8a1dbe71b0eb89(this->byte_buf, 0, this->byte_pos);
        this->byte_pos = 0;
    }
    
    void StreamWriter::Decode() {
        if((this->byte_pos > 0)) 
        {
            FlushBytes();
        }
        if((this->decode_pos > 0)) 
        {
            int32_t len = this->internalEncoding->GetBytes_90650b3cf924e5e2(this->decode_buf, 0, this->decode_pos, this->byte_buf, this->byte_pos);
            (this->byte_pos = this->byte_pos + len);
            this->decode_pos = 0;
        }
    }
    
    void StreamWriter::Write_61da934607a8065a(cli::array<char16_t>* buffer, int32_t index, int32_t count) {
        if((buffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("buffer"));
        }
        if((index < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("index"), _T("< 0"));
        }
        if((count < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("count"), _T("< 0"));
        }
        if((index > (buffer->get_Length() - count))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("index + count > buffer.Length"));
        }
        CheckState();
        LowLevelWrite(buffer, index, count);
        if(this->iflush) 
        {
            TextWriter::Flush_c8220c56815bfd56();
        }
    }
    
    void StreamWriter::LowLevelWrite(cli::array<char16_t>* buffer, int32_t index, int32_t count) {
        while((count > 0)) {
            int32_t todo = (this->decode_buf->get_Length() - this->decode_pos);
            if((todo ==  0)) 
            {
                Decode();
                todo = this->decode_buf->get_Length();
            }
            if((todo > count)) 
            {
                todo = count;
            }
            System::Buffer::BlockCopy(buffer, (index * 2), this->decode_buf, (this->decode_pos * 2), (todo * 2));
            (count = count - todo);
            (index = index + todo);
            (this->decode_pos = this->decode_pos + todo);
        }
    }
    
    void StreamWriter::LowLevelWrite2(System::String* s) {
        int32_t count = s->get_Length();
        int32_t index = 0;
        while((count > 0)) {
            int32_t todo = (this->decode_buf->get_Length() - this->decode_pos);
            if((todo ==  0)) 
            {
                Decode();
                todo = this->decode_buf->get_Length();
            }
            if((todo > count)) 
            {
                todo = count;
            }
            for(int32_t i = 0; (i < todo); i++) {
                this->decode_buf->at((i + this->decode_pos)) = s->get_Chars((i + index));
            }
            (count = count - todo);
            (index = index + todo);
            (this->decode_pos = this->decode_pos + todo);
        }
    }
    
    void StreamWriter::Write_96ccae6b0b267024(char16_t value) {
        CheckState();
        if((this->decode_pos >= this->decode_buf->get_Length())) 
        {
            Decode();
        }
        this->decode_buf->at(this->decode_pos++) = value;
        if(this->iflush) 
        {
            TextWriter::Flush_c8220c56815bfd56();
        }
    }
    
    void StreamWriter::Write_6d89396c0c5b77c4(cli::array<char16_t>* buffer) {
        CheckState();
        if((buffer != nullptr)) 
        {
            LowLevelWrite(buffer, 0, buffer->get_Length());
        }
        if(this->iflush) 
        {
            TextWriter::Flush_c8220c56815bfd56();
        }
    }
    
    void StreamWriter::Write_dcf5e45abd9e11c4(System::String* value) {
        CheckState();
        if((value != nullptr)) 
        {
            LowLevelWrite2(value);
        }
        if(this->iflush) 
        {
            TextWriter::Flush_c8220c56815bfd56();
        }
    }
    
    void StreamWriter::Close_745be624b802d9f6() {
        TextWriter::Dispose_6868d8c2d2b3dfb7(true);
    }
    
    void StreamWriter::CheckState() {
        if(this->DisposedAlready) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("StreamWriter"));
        }
    }
    
    bool StreamWriter::get_AutoFlush_84cda26e8ae50ae1() {
        return this->iflush;
    }
    
    bool StreamWriter::set_AutoFlush_12a815ad7ffc54a(bool value) {
        this->iflush = value;
        if(this->iflush) 
        {
            TextWriter::Flush_c8220c56815bfd56();
        }
        return get_AutoFlush_84cda26e8ae50ae1();
    }
    
    Stream* StreamWriter::get_BaseStream_2c967ce883c8b975() {
        return this->internalStream;
    }
    
    System::Text::Encoding* StreamWriter::get_Encoding_55955d94411af675() {
        return this->internalEncoding;
    }
    
}}
namespace System { namespace IO {
    
    cli::array<char16_t>*  StringReader::cr_lf;
    
    void StringReader::constructor(System::String* s) {
        if((s ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("s"));
        }
        this->source = s;
        this->nextChar = 0;
        this->sourceLength = s->get_Length();
    }
    
    void StringReader::Close_7c5ccd5fb8dfeba3() {
        TextReader::Dispose_6de32a3267835eb1(true);
    }
    
    void StringReader::Dispose_6de32a3267835eb1(bool disposing) {
        this->source = nullptr;
        TextReader::Dispose_6de32a3267835eb1(disposing);
    }
    
    int32_t StringReader::Peek_82f04bf3cd196dfd() {
        if((this->source ==  nullptr)) 
        {
            ObjectDisposedException2();
        }
        if((this->nextChar >= this->sourceLength)) 
        {
            return -1;
        }
        return (int32_t)(this->source->get_Chars(this->nextChar));
    }
    
    int32_t StringReader::Read_1d437d5ac2290f2b() {
        if((this->source ==  nullptr)) 
        {
            ObjectDisposedException2();
        }
        if((this->nextChar >= this->sourceLength)) 
        {
            return -1;
        }
        return (int32_t)(this->source->get_Chars(this->nextChar++));
    }
    
    int32_t StringReader::Read_24d2c98803d927e8(cli::array<char16_t>* buffer, int32_t index, int32_t count) {
        if((this->source ==  nullptr)) 
        {
            ObjectDisposedException2();
        }
        if((buffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("buffer"));
        }
        if(((buffer->get_Length() - index) < count)) 
        {
            throw cli::gcnew<System::ArgumentException>();
        }
        if(((index < 0) || (count < 0))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>();
        }
        int32_t charsToRead;
        if((this->nextChar > (this->sourceLength - count))) 
        {
            charsToRead = (this->sourceLength - this->nextChar);
        }
         else 
        {
            charsToRead = count;
        }
        this->source->CopyTo(this->nextChar, buffer, index, charsToRead);
        (this->nextChar = this->nextChar + charsToRead);
        return charsToRead;
    }
    
    System::String* StringReader::ReadLine_51552a49261f929e() {
        if((this->source ==  nullptr)) 
        {
            ObjectDisposedException2();
        }
        if((this->nextChar >= this->source->get_Length())) 
        {
            return nullptr;
        }
        if((cr_lf ==  nullptr)) 
        {
            cr_lf = (new cli::array<char16_t>({u'\xa', u'\xd'}));
        }
        int32_t readto = this->source->IndexOfAny2(cr_lf, this->nextChar);
        if((readto ==  -1)) 
        {
            return TextReader::ReadToEnd_f683943dd5002e1e();
        }
        bool consecutive = ((((int32_t)(this->source->get_Chars(readto)) ==  13) && ((readto + 1) < this->source->get_Length())) && ((int32_t)(this->source->get_Chars((readto + 1))) ==  10));
        System::String *nextLine = this->source->Substring2(this->nextChar, (readto - this->nextChar));
        this->nextChar = (readto + consecutive ? 2 : 1);
        return nextLine;
    }
    
    System::String* StringReader::ReadToEnd_f683943dd5002e1e() {
        if((this->source ==  nullptr)) 
        {
            ObjectDisposedException2();
        }
        System::String *toEnd = this->source->Substring2(this->nextChar, (this->sourceLength - this->nextChar));
        this->nextChar = this->sourceLength;
        return toEnd;
    }
    
    void StringReader::ObjectDisposedException2() {
        throw cli::gcnew<System::ObjectDisposedException>(_T("StringReader"), Locale::GetText(_T("Cannot read from a closed StringReader")));
    }
    
}}
namespace System { namespace IO {
    
    
    void StringWriter::constructor() {
    }
    
    void StringWriter::constructor(System::IFormatProvider* formatProvider) {
    }
    
    void StringWriter::constructor(System::Text::StringBuilder* sb) {
    }
    
    void StringWriter::constructor(System::Text::StringBuilder* sb, System::IFormatProvider* formatProvider) {
        if((sb ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("sb"));
        }
        this->internalString = sb;
        this->internalFormatProvider = formatProvider;
    }
    
    void StringWriter::Close_745be624b802d9f6() {
        TextWriter::Dispose_6868d8c2d2b3dfb7(true);
        this->disposed = true;
    }
    
    void StringWriter::Dispose_6868d8c2d2b3dfb7(bool disposing) {
        TextWriter::Dispose_6868d8c2d2b3dfb7(disposing);
        this->disposed = true;
    }
    
    System::Text::StringBuilder* StringWriter::GetStringBuilder_dca6edbf4154476b() {
        return this->internalString;
    }
    
    System::String* StringWriter::ToString_1636a0751cb9ac11() {
        return this->internalString->ToString_1636a0751cb9ac11();
    }
    
    void StringWriter::Write_96ccae6b0b267024(char16_t value) {
        if(this->disposed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("StringReader"), Locale::GetText(_T("Cannot write to a closed StringWriter")));
        }
        this->internalString->Append16(value);
    }
    
    void StringWriter::Write_dcf5e45abd9e11c4(System::String* value) {
        if(this->disposed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("StringReader"), Locale::GetText(_T("Cannot write to a closed StringWriter")));
        }
        this->internalString->Append2(value);
    }
    
    void StringWriter::Write_61da934607a8065a(cli::array<char16_t>* buffer, int32_t index, int32_t count) {
        if(this->disposed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("StringReader"), Locale::GetText(_T("Cannot write to a closed StringWriter")));
        }
        if((buffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("buffer"));
        }
        if((index < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("index"), _T("< 0"));
        }
        if((count < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("count"), _T("< 0"));
        }
        if((index > (buffer->get_Length() - count))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("index + count > buffer.Length"));
        }
        this->internalString->Append18(buffer, index, count);
    }
    
    System::Text::Encoding* StringWriter::get_Encoding_55955d94411af675() {
        return System::Text::Encoding::get_Unicode();
    }
    
}}
namespace System { namespace IO {
    
    
    void NullTextReader::constructor() {
    }
    
    System::String* NullTextReader::ReadLine_51552a49261f929e() {
        return nullptr;
    }
    
    System::String* NullTextReader::ReadToEnd_f683943dd5002e1e() {
        return System::String::Empty;
    }
    
}}
namespace System { namespace IO {
    
    TextReader*  TextReader::Null;
    
    TextReader::TextReader()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void TextReader::constructor() {
    }
    
    void TextReader::static_constructor() {
    }
    
    void TextReader::Close_7c5ccd5fb8dfeba3() {
        Dispose_6de32a3267835eb1(true);
    }
    
    void TextReader::Dispose() {
        Dispose_6de32a3267835eb1(true);
    }
    
    void TextReader::Dispose_6de32a3267835eb1(bool disposing) {
        if(disposing) 
        {
            System::GC::SuppressFinalize(this);
        }
        return;
    }
    
    int32_t TextReader::Peek_82f04bf3cd196dfd() {
        return -1;
    }
    
    int32_t TextReader::Read_1d437d5ac2290f2b() {
        return -1;
    }
    
    int32_t TextReader::Read_24d2c98803d927e8(cli::array<char16_t>* buffer, int32_t index, int32_t count) {
        int32_t c, i;
        for(i = 0; (i < count); i++){
            if(((c = Read_1d437d5ac2290f2b()) ==  (-1))) 
            {
                return i;
            }
            buffer->at((index + i)) = (char16_t)c;
        }
        return i;
    }
    
    int32_t TextReader::ReadBlock_f3ca37abea795c97(cli::array<char16_t>* buffer, int32_t index, int32_t count) {
        int32_t total_read_count = 0;
        int32_t current_read_count = 0;
        do {
            current_read_count = Read_24d2c98803d927e8(buffer, index, count);
            (index = index + current_read_count);
            (total_read_count = total_read_count + current_read_count);
            (count = count - current_read_count);
        }
        while(((current_read_count != 0) && (count > 0)));
        return total_read_count;
    }
    
    System::String* TextReader::ReadLine_51552a49261f929e() {
        System::Text::StringBuilder *result = cli::gcnew<System::Text::StringBuilder>();
        int32_t c;
        while(((c = Read_1d437d5ac2290f2b()) != (-1))) {
            if((c ==  10)) 
            {
                break;
            }
            if((c ==  13)) 
            {
                if((Peek_82f04bf3cd196dfd() ==  10)) 
                {
                    Read_1d437d5ac2290f2b();
                }
                break;
            }
            result->Append16((char16_t)c);
        }
        if(((c ==  -1) && (result->get_Length() ==  0))) 
        {
            return nullptr;
        }
        return result->ToString_1636a0751cb9ac11();
    }
    
    System::String* TextReader::ReadToEnd_f683943dd5002e1e() {
        System::Text::StringBuilder *result = cli::gcnew<System::Text::StringBuilder>();
        int32_t c;
        while(((c = Read_1d437d5ac2290f2b()) != (-1))) result->Append16((char16_t)c);
        return result->ToString_1636a0751cb9ac11();
    }
    
    TextReader* TextReader::Synchronized(TextReader* reader) {
        if((reader ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("reader is null"));
        }
        if(cli::is<SynchronizedReader>(reader)) 
        {
            return reader;
        }
        return cli::gcnew<SynchronizedReader>(reader);
    }
    
}}
namespace System { namespace IO {
    
    
    void SynchronizedReader::constructor(TextReader* reader) {
        this->reader = reader;
    }
    
    void SynchronizedReader::Close_7c5ccd5fb8dfeba3() {
        {
            cli::lock_guard{this};
            this->reader->Close_7c5ccd5fb8dfeba3();
        }
    }
    
    int32_t SynchronizedReader::Peek_82f04bf3cd196dfd() {
        {
            cli::lock_guard{this};
            return this->reader->Peek_82f04bf3cd196dfd();
        }
    }
    
    int32_t SynchronizedReader::ReadBlock_f3ca37abea795c97(cli::array<char16_t>* buffer, int32_t index, int32_t count) {
        {
            cli::lock_guard{this};
            return this->reader->ReadBlock_f3ca37abea795c97(buffer, index, count);
        }
    }
    
    System::String* SynchronizedReader::ReadLine_51552a49261f929e() {
        {
            cli::lock_guard{this};
            return this->reader->ReadLine_51552a49261f929e();
        }
    }
    
    System::String* SynchronizedReader::ReadToEnd_f683943dd5002e1e() {
        {
            cli::lock_guard{this};
            return this->reader->ReadToEnd_f683943dd5002e1e();
        }
    }
    
    int32_t SynchronizedReader::Read_1d437d5ac2290f2b() {
        {
            cli::lock_guard{this};
            return this->reader->Read_1d437d5ac2290f2b();
        }
    }
    
    int32_t SynchronizedReader::Read_24d2c98803d927e8(cli::array<char16_t>* buffer, int32_t index, int32_t count) {
        {
            cli::lock_guard{this};
            return this->reader->Read_24d2c98803d927e8(buffer, index, count);
        }
    }
    
}}
namespace System { namespace IO {
    
    
    void NullTextWriter::constructor() {
    }
    
    void NullTextWriter::Write_dcf5e45abd9e11c4(System::String* s) {
    }
    
    void NullTextWriter::Write_96ccae6b0b267024(char16_t value) {
    }
    
    void NullTextWriter::Write_61da934607a8065a(cli::array<char16_t>* value, int32_t index, int32_t count) {
    }
    
    System::Text::Encoding* NullTextWriter::get_Encoding_55955d94411af675() {
        return System::Text::Encoding::get_Default();
    }
    
}}
namespace System { namespace IO {
    
    TextWriter*  TextWriter::Null;
    
    TextWriter::TextWriter()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void TextWriter::constructor() {
        this->CoreNewLine = System::Environment::get_NewLine()->ToCharArray();
    }
    
    void TextWriter::constructor(System::IFormatProvider* formatProvider) {
        this->CoreNewLine = System::Environment::get_NewLine()->ToCharArray();
        this->internalFormatProvider = formatProvider;
    }
    
    void TextWriter::static_constructor() {
    }
    
    void TextWriter::Close_745be624b802d9f6() {
        Dispose_6868d8c2d2b3dfb7(true);
    }
    
    void TextWriter::Dispose_6868d8c2d2b3dfb7(bool disposing) {
        if(disposing) 
        {
            System::GC::SuppressFinalize(this);
        }
    }
    
    void TextWriter::Dispose2() {
        Dispose_6868d8c2d2b3dfb7(true);
        System::GC::SuppressFinalize(this);
    }
    
    void TextWriter::Flush_c8220c56815bfd56() {
    }
    
    TextWriter* TextWriter::Synchronized(TextWriter* writer) {
        return Synchronized2(writer, false);
    }
    
    TextWriter* TextWriter::Synchronized2(TextWriter* writer, bool neverClose) {
        if((writer ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("writer is null"));
        }
        if(cli::is<SynchronizedWriter>(writer)) 
        {
            return writer;
        }
        return cli::gcnew<SynchronizedWriter>(writer, neverClose);
    }
    
    void TextWriter::Write_443a7a25c054668(bool value) {
        Write_dcf5e45abd9e11c4(cli::import(value)->ToString_1636a0751cb9ac11());
    }
    
    void TextWriter::Write_96ccae6b0b267024(char16_t value) {
    }
    
    void TextWriter::Write_6d89396c0c5b77c4(cli::array<char16_t>* buffer) {
        if((buffer ==  nullptr)) 
        {
            return;
        }
        Write_61da934607a8065a(buffer, 0, buffer->get_Length());
    }
    
    void TextWriter::Write_222d042b1869986(System::Decimal value) {
        Write_dcf5e45abd9e11c4(value->ToString5(this->internalFormatProvider));
    }
    
    void TextWriter::Write_31466a0eb6072a4a(double value) {
        Write_dcf5e45abd9e11c4(cli::import(value)->ToString3(this->internalFormatProvider));
    }
    
    void TextWriter::Write_12c6f74b27421524(int32_t value) {
        Write_dcf5e45abd9e11c4(cli::import(value)->ToString3(this->internalFormatProvider));
    }
    
    void TextWriter::Write_bda7727b5cfc5345(int64_t value) {
        Write_dcf5e45abd9e11c4(cli::import(value)->ToString3(this->internalFormatProvider));
    }
    
    void TextWriter::Write_55565de44c1e3104(System::Object* value) {
        if((value != nullptr)) 
        {
            Write_dcf5e45abd9e11c4(value->ToString_1636a0751cb9ac11());
        }
    }
    
    void TextWriter::Write_3945ee193bccdd42(float value) {
        Write_dcf5e45abd9e11c4(cli::import(value)->ToString3(this->internalFormatProvider));
    }
    
    void TextWriter::Write_dcf5e45abd9e11c4(System::String* value) {
        if((value != nullptr)) 
        {
            Write_6d89396c0c5b77c4(value->ToCharArray());
        }
    }
    
    void TextWriter::Write_8d2ce38f16ef9fe3(uint32_t value) {
        Write_dcf5e45abd9e11c4(cli::import(value)->ToString3(this->internalFormatProvider));
    }
    
    void TextWriter::Write_bed5c65a22d487e6(uint64_t value) {
        Write_dcf5e45abd9e11c4(cli::import(value)->ToString3(this->internalFormatProvider));
    }
    
    void TextWriter::Write_f2bf6875dbaeba6a(System::String* format, System::Object* arg0) {
        Write_dcf5e45abd9e11c4(System::String::Format2(format, arg0));
    }
    
    void TextWriter::Write_e2bf1f4b5968ab9(System::String* format, cli::array<System::Object*>* arg) {
        Write_dcf5e45abd9e11c4(System::String::Format5(format, arg));
    }
    
    void TextWriter::Write_61da934607a8065a(cli::array<char16_t>* buffer, int32_t index, int32_t count) {
        if((buffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("buffer"));
        }
        if(((index < 0) || (index > buffer->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("index"));
        }
        if(((count < 0) || (index > (buffer->get_Length() - count)))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("count"));
        }
        for(; (count > 0); --count, ++index){
            Write_96ccae6b0b267024(buffer->at(index));
        }
    }
    
    void TextWriter::Write_d1ec280d8f085d73(System::String* format, System::Object* arg0, System::Object* arg1) {
        Write_dcf5e45abd9e11c4(System::String::Format3(format, arg0, arg1));
    }
    
    void TextWriter::Write_4d2ac9c7b9e5e3b6(System::String* format, System::Object* arg0, System::Object* arg1, System::Object* arg2) {
        Write_dcf5e45abd9e11c4(System::String::Format4(format, arg0, arg1, arg2));
    }
    
    void TextWriter::WriteLine_f0ca76dc02634177() {
        Write_6d89396c0c5b77c4(this->CoreNewLine);
    }
    
    void TextWriter::WriteLine_711f0f7d57a6b9ec(bool value) {
        Write_443a7a25c054668(value);
        WriteLine_f0ca76dc02634177();
    }
    
    void TextWriter::WriteLine_5db503756aad6b7e(char16_t value) {
        Write_96ccae6b0b267024(value);
        WriteLine_f0ca76dc02634177();
    }
    
    void TextWriter::WriteLine_4e1d057f0df9eb1f(cli::array<char16_t>* buffer) {
        Write_6d89396c0c5b77c4(buffer);
        WriteLine_f0ca76dc02634177();
    }
    
    void TextWriter::WriteLine_7215ae0192c985c9(System::Decimal value) {
        Write_222d042b1869986(value);
        WriteLine_f0ca76dc02634177();
    }
    
    void TextWriter::WriteLine_e88c356ba9c2db75(double value) {
        Write_31466a0eb6072a4a(value);
        WriteLine_f0ca76dc02634177();
    }
    
    void TextWriter::WriteLine_4f98173db23c2ff8(int32_t value) {
        Write_12c6f74b27421524(value);
        WriteLine_f0ca76dc02634177();
    }
    
    void TextWriter::WriteLine_79f607f527127dc5(int64_t value) {
        Write_bda7727b5cfc5345(value);
        WriteLine_f0ca76dc02634177();
    }
    
    void TextWriter::WriteLine_dfd9dff343620f4d(System::Object* value) {
        Write_55565de44c1e3104(value);
        WriteLine_f0ca76dc02634177();
    }
    
    void TextWriter::WriteLine_1fcb4a3f9e16c04c(float value) {
        Write_3945ee193bccdd42(value);
        WriteLine_f0ca76dc02634177();
    }
    
    void TextWriter::WriteLine_27fb29d2c5b390c7(System::String* value) {
        Write_dcf5e45abd9e11c4(value);
        WriteLine_f0ca76dc02634177();
    }
    
    void TextWriter::WriteLine_cf4ece46b08b7fc4(uint32_t value) {
        Write_8d2ce38f16ef9fe3(value);
        WriteLine_f0ca76dc02634177();
    }
    
    void TextWriter::WriteLine_ee19bfc9492f25dd(uint64_t value) {
        Write_bed5c65a22d487e6(value);
        WriteLine_f0ca76dc02634177();
    }
    
    void TextWriter::WriteLine_5eb6d2f1667d4085(System::String* format, System::Object* arg0) {
        Write_f2bf6875dbaeba6a(format, arg0);
        WriteLine_f0ca76dc02634177();
    }
    
    void TextWriter::WriteLine_b743f1a08f47f965(System::String* format, cli::array<System::Object*>* arg) {
        Write_e2bf1f4b5968ab9(format, arg);
        WriteLine_f0ca76dc02634177();
    }
    
    void TextWriter::WriteLine_9dea657622eb9bf4(cli::array<char16_t>* buffer, int32_t index, int32_t count) {
        Write_61da934607a8065a(buffer, index, count);
        WriteLine_f0ca76dc02634177();
    }
    
    void TextWriter::WriteLine_b33fb6632b99859a(System::String* format, System::Object* arg0, System::Object* arg1) {
        Write_d1ec280d8f085d73(format, arg0, arg1);
        WriteLine_f0ca76dc02634177();
    }
    
    void TextWriter::WriteLine_10ed8cd26a3939e1(System::String* format, System::Object* arg0, System::Object* arg1, System::Object* arg2) {
        Write_4d2ac9c7b9e5e3b6(format, arg0, arg1, arg2);
        WriteLine_f0ca76dc02634177();
    }
    
    System::IFormatProvider* TextWriter::get_FormatProvider_5878562ed72ff523() {
        return this->internalFormatProvider;
    }
    
    System::String* TextWriter::get_NewLine_22799fa26f7999ac() {
        return cli::gcnew<System::String>(this->CoreNewLine);
    }
    
    System::String* TextWriter::set_NewLine_7d29519e1b46fe0b(System::String* value) {
        if((value ==  nullptr)) 
        {
            value = System::Environment::get_NewLine();
        }
        this->CoreNewLine = value->ToCharArray();
        return get_NewLine_22799fa26f7999ac();
    }
    
}}
namespace System { namespace IO {
    
    
    void SynchronizedWriter::constructor(TextWriter* writer) {
    }
    
    void SynchronizedWriter::constructor(TextWriter* writer, bool neverClose) {
        this->writer = writer;
        this->neverClose = neverClose;
    }
    
    void SynchronizedWriter::Close_745be624b802d9f6() {
        if(this->neverClose) 
        {
            return;
        }
        {
            cli::lock_guard{this};
            this->writer->Close_745be624b802d9f6();
        }
    }
    
    void SynchronizedWriter::Flush_c8220c56815bfd56() {
        {
            cli::lock_guard{this};
            this->writer->Flush_c8220c56815bfd56();
        }
    }
    
    void SynchronizedWriter::Write_443a7a25c054668(bool value) {
        {
            cli::lock_guard{this};
            this->writer->Write_443a7a25c054668(value);
        }
    }
    
    void SynchronizedWriter::Write_96ccae6b0b267024(char16_t value) {
        {
            cli::lock_guard{this};
            this->writer->Write_96ccae6b0b267024(value);
        }
    }
    
    void SynchronizedWriter::Write_6d89396c0c5b77c4(cli::array<char16_t>* value) {
        {
            cli::lock_guard{this};
            this->writer->Write_6d89396c0c5b77c4(value);
        }
    }
    
    void SynchronizedWriter::Write_222d042b1869986(System::Decimal value) {
        {
            cli::lock_guard{this};
            this->writer->Write_222d042b1869986(value);
        }
    }
    
    void SynchronizedWriter::Write_12c6f74b27421524(int32_t value) {
        {
            cli::lock_guard{this};
            this->writer->Write_12c6f74b27421524(value);
        }
    }
    
    void SynchronizedWriter::Write_bda7727b5cfc5345(int64_t value) {
        {
            cli::lock_guard{this};
            this->writer->Write_bda7727b5cfc5345(value);
        }
    }
    
    void SynchronizedWriter::Write_55565de44c1e3104(System::Object* value) {
        {
            cli::lock_guard{this};
            this->writer->Write_55565de44c1e3104(value);
        }
    }
    
    void SynchronizedWriter::Write_3945ee193bccdd42(float value) {
        {
            cli::lock_guard{this};
            this->writer->Write_3945ee193bccdd42(value);
        }
    }
    
    void SynchronizedWriter::Write_dcf5e45abd9e11c4(System::String* value) {
        {
            cli::lock_guard{this};
            this->writer->Write_dcf5e45abd9e11c4(value);
        }
    }
    
    void SynchronizedWriter::Write_8d2ce38f16ef9fe3(uint32_t value) {
        {
            cli::lock_guard{this};
            this->writer->Write_8d2ce38f16ef9fe3(value);
        }
    }
    
    void SynchronizedWriter::Write_bed5c65a22d487e6(uint64_t value) {
        {
            cli::lock_guard{this};
            this->writer->Write_bed5c65a22d487e6(value);
        }
    }
    
    void SynchronizedWriter::Write_f2bf6875dbaeba6a(System::String* format, System::Object* value) {
        {
            cli::lock_guard{this};
            this->writer->Write_f2bf6875dbaeba6a(format, value);
        }
    }
    
    void SynchronizedWriter::Write_e2bf1f4b5968ab9(System::String* format, cli::array<System::Object*>* value) {
        {
            cli::lock_guard{this};
            this->writer->Write_e2bf1f4b5968ab9(format, value);
        }
    }
    
    void SynchronizedWriter::Write_61da934607a8065a(cli::array<char16_t>* buffer, int32_t index, int32_t count) {
        {
            cli::lock_guard{this};
            this->writer->Write_61da934607a8065a(buffer, index, count);
        }
    }
    
    void SynchronizedWriter::Write_d1ec280d8f085d73(System::String* format, System::Object* arg0, System::Object* arg1) {
        {
            cli::lock_guard{this};
            this->writer->Write_d1ec280d8f085d73(format, arg0, arg1);
        }
    }
    
    void SynchronizedWriter::Write_4d2ac9c7b9e5e3b6(System::String* format, System::Object* arg0, System::Object* arg1, System::Object* arg2) {
        {
            cli::lock_guard{this};
            this->writer->Write_4d2ac9c7b9e5e3b6(format, arg0, arg1, arg2);
        }
    }
    
    void SynchronizedWriter::WriteLine_f0ca76dc02634177() {
        {
            cli::lock_guard{this};
            this->writer->WriteLine_f0ca76dc02634177();
        }
    }
    
    void SynchronizedWriter::WriteLine_711f0f7d57a6b9ec(bool value) {
        {
            cli::lock_guard{this};
            this->writer->WriteLine_711f0f7d57a6b9ec(value);
        }
    }
    
    void SynchronizedWriter::WriteLine_5db503756aad6b7e(char16_t value) {
        {
            cli::lock_guard{this};
            this->writer->WriteLine_5db503756aad6b7e(value);
        }
    }
    
    void SynchronizedWriter::WriteLine_4e1d057f0df9eb1f(cli::array<char16_t>* value) {
        {
            cli::lock_guard{this};
            this->writer->WriteLine_4e1d057f0df9eb1f(value);
        }
    }
    
    void SynchronizedWriter::WriteLine_7215ae0192c985c9(System::Decimal value) {
        {
            cli::lock_guard{this};
            this->writer->WriteLine_7215ae0192c985c9(value);
        }
    }
    
    void SynchronizedWriter::WriteLine_e88c356ba9c2db75(double value) {
        {
            cli::lock_guard{this};
            this->writer->WriteLine_e88c356ba9c2db75(value);
        }
    }
    
    void SynchronizedWriter::WriteLine_4f98173db23c2ff8(int32_t value) {
        {
            cli::lock_guard{this};
            this->writer->WriteLine_4f98173db23c2ff8(value);
        }
    }
    
    void SynchronizedWriter::WriteLine_79f607f527127dc5(int64_t value) {
        {
            cli::lock_guard{this};
            this->writer->WriteLine_79f607f527127dc5(value);
        }
    }
    
    void SynchronizedWriter::WriteLine_dfd9dff343620f4d(System::Object* value) {
        {
            cli::lock_guard{this};
            this->writer->WriteLine_dfd9dff343620f4d(value);
        }
    }
    
    void SynchronizedWriter::WriteLine_1fcb4a3f9e16c04c(float value) {
        {
            cli::lock_guard{this};
            this->writer->WriteLine_1fcb4a3f9e16c04c(value);
        }
    }
    
    void SynchronizedWriter::WriteLine_27fb29d2c5b390c7(System::String* value) {
        {
            cli::lock_guard{this};
            this->writer->WriteLine_27fb29d2c5b390c7(value);
        }
    }
    
    void SynchronizedWriter::WriteLine_cf4ece46b08b7fc4(uint32_t value) {
        {
            cli::lock_guard{this};
            this->writer->WriteLine_cf4ece46b08b7fc4(value);
        }
    }
    
    void SynchronizedWriter::WriteLine_ee19bfc9492f25dd(uint64_t value) {
        {
            cli::lock_guard{this};
            this->writer->WriteLine_ee19bfc9492f25dd(value);
        }
    }
    
    void SynchronizedWriter::WriteLine_5eb6d2f1667d4085(System::String* format, System::Object* value) {
        {
            cli::lock_guard{this};
            this->writer->WriteLine_5eb6d2f1667d4085(format, value);
        }
    }
    
    void SynchronizedWriter::WriteLine_b743f1a08f47f965(System::String* format, cli::array<System::Object*>* value) {
        {
            cli::lock_guard{this};
            this->writer->WriteLine_b743f1a08f47f965(format, value);
        }
    }
    
    void SynchronizedWriter::WriteLine_9dea657622eb9bf4(cli::array<char16_t>* buffer, int32_t index, int32_t count) {
        {
            cli::lock_guard{this};
            this->writer->WriteLine_9dea657622eb9bf4(buffer, index, count);
        }
    }
    
    void SynchronizedWriter::WriteLine_b33fb6632b99859a(System::String* format, System::Object* arg0, System::Object* arg1) {
        {
            cli::lock_guard{this};
            this->writer->WriteLine_b33fb6632b99859a(format, arg0, arg1);
        }
    }
    
    void SynchronizedWriter::WriteLine_10ed8cd26a3939e1(System::String* format, System::Object* arg0, System::Object* arg1, System::Object* arg2) {
        {
            cli::lock_guard{this};
            this->writer->WriteLine_10ed8cd26a3939e1(format, arg0, arg1, arg2);
        }
    }
    
    System::Text::Encoding* SynchronizedWriter::get_Encoding_55955d94411af675() {
        {
            cli::lock_guard{this};
            return this->writer->get_Encoding_55955d94411af675();
        }
    }
    
    System::IFormatProvider* SynchronizedWriter::get_FormatProvider_5878562ed72ff523() {
        {
            cli::lock_guard{this};
            return this->writer->get_FormatProvider_5878562ed72ff523();
        }
    }
    
    System::String* SynchronizedWriter::get_NewLine_22799fa26f7999ac() {
        {
            cli::lock_guard{this};
            return this->writer->get_NewLine_22799fa26f7999ac();
        }
    }
    
    System::String* SynchronizedWriter::set_NewLine_7d29519e1b46fe0b(System::String* value) {
        {
            cli::lock_guard{this};
            this->writer->set_NewLine_7d29519e1b46fe0b(value);
        }
        return get_NewLine_22799fa26f7999ac();
    }
    
}}
namespace System { namespace IO {
    
    cli::array<bool>*  UnexceptionalStreamReader::newline;
    char16_t  UnexceptionalStreamReader::newlineChar;
    
    UnexceptionalStreamReader::UnexceptionalStreamReader()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void UnexceptionalStreamReader::static_constructor() {
        System::String *n = System::Environment::get_NewLine();
        if((n->get_Length() ==  1)) 
        {
            newlineChar = n->get_Chars(0);
        }
    }
    
    void UnexceptionalStreamReader::constructor(Stream* stream, System::Text::Encoding* encoding) {
    }
    
    int32_t UnexceptionalStreamReader::Peek_82f04bf3cd196dfd() {
        try {
            return StreamReader::Peek_82f04bf3cd196dfd();
        }
        catch(IOException*) {
        }
        return -1;
    }
    
    int32_t UnexceptionalStreamReader::Read_1d437d5ac2290f2b() {
        try {
            return StreamReader::Read_1d437d5ac2290f2b();
        }
        catch(IOException*) {
        }
        return -1;
    }
    
    int32_t UnexceptionalStreamReader::Read_24d2c98803d927e8(cli::array<char16_t>* dest_buffer, int32_t index, int32_t count) {
        if((dest_buffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("dest_buffer"));
        }
        if((index < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("index"), _T("< 0"));
        }
        if((count < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("count"), _T("< 0"));
        }
        if((index > (dest_buffer->get_Length() - count))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("index + count > dest_buffer.Length"));
        }
        int32_t chars_read = 0;
        char16_t nl = newlineChar;
        try {
            while((count > 0)) {
                int32_t c = StreamReader::Read_1d437d5ac2290f2b();
                if((c < 0)) 
                {
                    break;
                }
                chars_read++;
                count--;
                dest_buffer->at(index) = (char16_t)c;
                if(((int32_t)(nl) != 0)) 
                {
                    if(((int32_t)((char16_t)c) ==  (int32_t)(nl))) 
                    {
                        return chars_read;
                    }
                }
                 else 
                {
                    if(CheckEOL((char16_t)c)) 
                    {
                        return chars_read;
                    }
                }
                index++;
            }
        }
        catch(IOException*) {
        }
        return chars_read;
    }
    
    bool UnexceptionalStreamReader::CheckEOL(char16_t current) {
        for(int32_t i = 0; (i < newline->get_Length()); i++){
            if(!(newline->at(i))) 
            {
                if(((int32_t)(current) ==  (int32_t)(System::Environment::get_NewLine()->get_Chars(i)))) 
                {
                    newline->at(i) = true;
                    return (i ==  (newline->get_Length() - 1));
                }
                break;
            }
        }
        for(int32_t j = 0; (j < newline->get_Length()); j++) {
            newline->at(j) = false;
        }
        return false;
    }
    
    System::String* UnexceptionalStreamReader::ReadLine_51552a49261f929e() {
        try {
            return StreamReader::ReadLine_51552a49261f929e();
        }
        catch(IOException*) {
        }
        return nullptr;
    }
    
    System::String* UnexceptionalStreamReader::ReadToEnd_f683943dd5002e1e() {
        try {
            return StreamReader::ReadToEnd_f683943dd5002e1e();
        }
        catch(IOException*) {
        }
        return nullptr;
    }
    
}}
namespace System { namespace IO {
    
    
    void UnexceptionalStreamWriter::constructor(Stream* stream, System::Text::Encoding* encoding) {
    }
    
    void UnexceptionalStreamWriter::Flush_c8220c56815bfd56() {
        try {
            StreamWriter::Flush_c8220c56815bfd56();
        }
        catch(System::Exception*) {
        }
    }
    
    void UnexceptionalStreamWriter::Write_61da934607a8065a(cli::array<char16_t>* buffer, int32_t index, int32_t count) {
        try {
            StreamWriter::Write_61da934607a8065a(buffer, index, count);
        }
        catch(System::Exception*) {
        }
    }
    
    void UnexceptionalStreamWriter::Write_96ccae6b0b267024(char16_t value) {
        try {
            StreamWriter::Write_96ccae6b0b267024(value);
        }
        catch(System::Exception*) {
        }
    }
    
    void UnexceptionalStreamWriter::Write_6d89396c0c5b77c4(cli::array<char16_t>* value) {
        try {
            StreamWriter::Write_6d89396c0c5b77c4(value);
        }
        catch(System::Exception*) {
        }
    }
    
    void UnexceptionalStreamWriter::Write_dcf5e45abd9e11c4(System::String* value) {
        try {
            StreamWriter::Write_dcf5e45abd9e11c4(value);
        }
        catch(System::Exception*) {
        }
    }
    
}}
namespace System { namespace IO {
    
    
    void UnmanagedMemoryAccessor::constructor() {
    }
    
    void UnmanagedMemoryAccessor::constructor(System::Runtime::InteropServices::SafeBuffer* buffer, int64_t offset, int64_t capacity) {
        Initialize(buffer, offset, capacity, FileAccess::ReadWrite);
    }
    
    void UnmanagedMemoryAccessor::constructor(System::Runtime::InteropServices::SafeBuffer* buffer, int64_t offset, int64_t capacity, FileAccess access) {
        Initialize(buffer, offset, capacity, access);
    }
    
    void UnmanagedMemoryAccessor::Initialize(System::Runtime::InteropServices::SafeBuffer* buffer, int64_t offset, int64_t capacity, FileAccess access) {
        if((buffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("buffer"));
        }
        if((offset < 0L)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("offset"));
        }
        if((capacity < 0L)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("capacity"));
        }
        if((((int32_t)(access) ==  1) || ((int32_t)(access) ==  3))) 
        {
            this->canread = true;
        }
        if((((int32_t)(access) ==  2) || ((int32_t)(access) ==  3))) 
        {
            this->canwrite = true;
        }
        if((this->buffer != nullptr)) 
        {
            Dispose_fa22ed4101a7af38(true);
        }
        this->buffer = buffer;
        this->offset = offset;
        this->capacity = capacity;
    }
    
    void UnmanagedMemoryAccessor::Dispose() {
        Dispose_fa22ed4101a7af38(true);
        System::GC::SuppressFinalize(this);
    }
    
    void UnmanagedMemoryAccessor::Dispose_fa22ed4101a7af38(bool disposing) {
        if((this->buffer != nullptr)) 
        {
            if(disposing) 
            {
                this->buffer->Dispose();
            }
        }
        this->buffer = nullptr;
    }
    
    unsigned char UnmanagedMemoryAccessor::ReadByte(int64_t position) {
        if(!(this->canread)) 
        {
            throw cli::gcnew<System::NotSupportedException>();
        }
        if((this->buffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("buffer"));
        }
        if((position < 0L)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>();
        }
        return this->buffer->template Read_1<unsigned char>((uint64_t)position);
    }
    
    bool UnmanagedMemoryAccessor::ReadBoolean(int64_t position) {
        if(!(this->canread)) 
        {
            throw cli::gcnew<System::NotSupportedException>();
        }
        if((this->buffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("buffer"));
        }
        if((position < 0L)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>();
        }
        return this->buffer->template Read_1<bool>((uint64_t)position);
    }
    
    char16_t UnmanagedMemoryAccessor::ReadChar(int64_t position) {
        if(!(this->canread)) 
        {
            throw cli::gcnew<System::NotSupportedException>();
        }
        if((this->buffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("buffer"));
        }
        if((position < 0L)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>();
        }
        return this->buffer->template Read_1<char16_t>((uint64_t)position);
    }
    
    System::Decimal UnmanagedMemoryAccessor::ReadDecimal(int64_t position) {
        if(!(this->canread)) 
        {
            throw cli::gcnew<System::NotSupportedException>();
        }
        if((this->buffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("buffer"));
        }
        if((position < 0L)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>();
        }
        return this->buffer->template Read_1<System::Decimal>((uint64_t)position);
    }
    
    double UnmanagedMemoryAccessor::ReadDouble(int64_t position) {
        if(!(this->canread)) 
        {
            throw cli::gcnew<System::NotSupportedException>();
        }
        if((this->buffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("buffer"));
        }
        if((position < 0L)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>();
        }
        return this->buffer->template Read_1<double>((uint64_t)position);
    }
    
    int16_t UnmanagedMemoryAccessor::ReadInt16(int64_t position) {
        if(!(this->canread)) 
        {
            throw cli::gcnew<System::NotSupportedException>();
        }
        if((this->buffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("buffer"));
        }
        if((position < 0L)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>();
        }
        return this->buffer->template Read_1<int16_t>((uint64_t)position);
    }
    
    int32_t UnmanagedMemoryAccessor::ReadInt32(int64_t position) {
        if(!(this->canread)) 
        {
            throw cli::gcnew<System::NotSupportedException>();
        }
        if((this->buffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("buffer"));
        }
        if((position < 0L)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>();
        }
        return this->buffer->template Read_1<int32_t>((uint64_t)position);
    }
    
    int64_t UnmanagedMemoryAccessor::ReadInt64(int64_t position) {
        if(!(this->canread)) 
        {
            throw cli::gcnew<System::NotSupportedException>();
        }
        if((this->buffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("buffer"));
        }
        if((position < 0L)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>();
        }
        return this->buffer->template Read_1<int64_t>((uint64_t)position);
    }
    
    signed char UnmanagedMemoryAccessor::ReadSByte(int64_t position) {
        if(!(this->canread)) 
        {
            throw cli::gcnew<System::NotSupportedException>();
        }
        if((this->buffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("buffer"));
        }
        if((position < 0L)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>();
        }
        return this->buffer->template Read_1<signed char>((uint64_t)position);
    }
    
    float UnmanagedMemoryAccessor::ReadSingle(int64_t position) {
        if(!(this->canread)) 
        {
            throw cli::gcnew<System::NotSupportedException>();
        }
        if((this->buffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("buffer"));
        }
        if((position < 0L)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>();
        }
        return this->buffer->template Read_1<float>((uint64_t)position);
    }
    
    uint16_t UnmanagedMemoryAccessor::ReadUInt16(int64_t position) {
        if(!(this->canread)) 
        {
            throw cli::gcnew<System::NotSupportedException>();
        }
        if((this->buffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("buffer"));
        }
        if((position < 0L)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>();
        }
        return this->buffer->template Read_1<uint16_t>((uint64_t)position);
    }
    
    uint32_t UnmanagedMemoryAccessor::ReadUInt32(int64_t position) {
        if(!(this->canread)) 
        {
            throw cli::gcnew<System::NotSupportedException>();
        }
        if((this->buffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("buffer"));
        }
        if((position < 0L)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>();
        }
        return this->buffer->template Read_1<uint32_t>((uint64_t)position);
    }
    
    uint64_t UnmanagedMemoryAccessor::ReadUInt64(int64_t position) {
        if(!(this->canread)) 
        {
            throw cli::gcnew<System::NotSupportedException>();
        }
        if((this->buffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("buffer"));
        }
        if((position < 0L)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>();
        }
        return this->buffer->template Read_1<uint64_t>((uint64_t)position);
    }
    
    void UnmanagedMemoryAccessor::Write(int64_t position, bool value) {
        if(!(this->canwrite)) 
        {
            throw cli::gcnew<System::NotSupportedException>();
        }
        if((this->buffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("buffer"));
        }
        if((position < 0L)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>();
        }
        this->buffer->template Write_1<bool>((uint64_t)position, value);
    }
    
    void UnmanagedMemoryAccessor::Write2(int64_t position, unsigned char value) {
        if(!(this->canwrite)) 
        {
            throw cli::gcnew<System::NotSupportedException>();
        }
        if((this->buffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("buffer"));
        }
        if((position < 0L)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>();
        }
        this->buffer->template Write_1<unsigned char>((uint64_t)position, value);
    }
    
    void UnmanagedMemoryAccessor::Write3(int64_t position, char16_t value) {
        if(!(this->canwrite)) 
        {
            throw cli::gcnew<System::NotSupportedException>();
        }
        if((this->buffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("buffer"));
        }
        if((position < 0L)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>();
        }
        this->buffer->template Write_1<char16_t>((uint64_t)position, value);
    }
    
    void UnmanagedMemoryAccessor::Write4(int64_t position, System::Decimal value) {
        if(!(this->canwrite)) 
        {
            throw cli::gcnew<System::NotSupportedException>();
        }
        if((this->buffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("buffer"));
        }
        if((position < 0L)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>();
        }
        this->buffer->template Write_1<System::Decimal>((uint64_t)position, value);
    }
    
    void UnmanagedMemoryAccessor::Write5(int64_t position, double value) {
        if(!(this->canwrite)) 
        {
            throw cli::gcnew<System::NotSupportedException>();
        }
        if((this->buffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("buffer"));
        }
        if((position < 0L)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>();
        }
        this->buffer->template Write_1<double>((uint64_t)position, value);
    }
    
    void UnmanagedMemoryAccessor::Write6(int64_t position, int16_t value) {
        if(!(this->canwrite)) 
        {
            throw cli::gcnew<System::NotSupportedException>();
        }
        if((this->buffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("buffer"));
        }
        if((position < 0L)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>();
        }
        this->buffer->template Write_1<int16_t>((uint64_t)position, value);
    }
    
    void UnmanagedMemoryAccessor::Write7(int64_t position, int32_t value) {
        if(!(this->canwrite)) 
        {
            throw cli::gcnew<System::NotSupportedException>();
        }
        if((this->buffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("buffer"));
        }
        if((position < 0L)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>();
        }
        this->buffer->template Write_1<int32_t>((uint64_t)position, value);
    }
    
    void UnmanagedMemoryAccessor::Write8(int64_t position, int64_t value) {
        if(!(this->canwrite)) 
        {
            throw cli::gcnew<System::NotSupportedException>();
        }
        if((this->buffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("buffer"));
        }
        if((position < 0L)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>();
        }
        this->buffer->template Write_1<int64_t>((uint64_t)position, value);
    }
    
    void UnmanagedMemoryAccessor::Write9(int64_t position, signed char value) {
        if(!(this->canwrite)) 
        {
            throw cli::gcnew<System::NotSupportedException>();
        }
        if((this->buffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("buffer"));
        }
        if((position < 0L)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>();
        }
        this->buffer->template Write_1<signed char>((uint64_t)position, value);
    }
    
    void UnmanagedMemoryAccessor::Write10(int64_t position, float value) {
        if(!(this->canwrite)) 
        {
            throw cli::gcnew<System::NotSupportedException>();
        }
        if((this->buffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("buffer"));
        }
        if((position < 0L)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>();
        }
        this->buffer->template Write_1<float>((uint64_t)position, value);
    }
    
    void UnmanagedMemoryAccessor::Write11(int64_t position, uint16_t value) {
        if(!(this->canwrite)) 
        {
            throw cli::gcnew<System::NotSupportedException>();
        }
        if((this->buffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("buffer"));
        }
        if((position < 0L)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>();
        }
        this->buffer->template Write_1<uint16_t>((uint64_t)position, value);
    }
    
    void UnmanagedMemoryAccessor::Write12(int64_t position, uint32_t value) {
        if(!(this->canwrite)) 
        {
            throw cli::gcnew<System::NotSupportedException>();
        }
        if((this->buffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("buffer"));
        }
        if((position < 0L)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>();
        }
        this->buffer->template Write_1<uint32_t>((uint64_t)position, value);
    }
    
    void UnmanagedMemoryAccessor::Write13(int64_t position, uint64_t value) {
        if(!(this->canwrite)) 
        {
            throw cli::gcnew<System::NotSupportedException>();
        }
        if((this->buffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("buffer"));
        }
        if((position < 0L)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>();
        }
        this->buffer->template Write_1<uint64_t>((uint64_t)position, value);
    }
    
    bool UnmanagedMemoryAccessor::get_CanRead() {
        return this->canread;
    }
    
    bool UnmanagedMemoryAccessor::get_CanWrite() {
        return this->canwrite;
    }
    
    int64_t UnmanagedMemoryAccessor::get_Capacity() {
        return this->capacity;
    }
    
    bool UnmanagedMemoryAccessor::get_IsOpen() {
        return (this->buffer != nullptr);
    }
    
}}
namespace System { namespace IO {
    
    
    void UnmanagedMemoryStream::constructor() {
        this->closed = true;
    }
    
    void UnmanagedMemoryStream::constructor(unsigned char* pointer, int64_t length) {
    }
    
    void UnmanagedMemoryStream::constructor(unsigned char* pointer, int64_t length, int64_t capacity, FileAccess access) {
        this->closed = true;
        Initialize(pointer, length, capacity, access);
    }
    
    void UnmanagedMemoryStream::constructor(System::Runtime::InteropServices::SafeBuffer* buffer, int64_t offset, int64_t length) {
    }
    
    void UnmanagedMemoryStream::constructor(System::Runtime::InteropServices::SafeBuffer* buffer, int64_t offset, int64_t length, FileAccess access) {
        this->closed = true;
        Initialize2(buffer, offset, length, access);
    }
    
    int32_t UnmanagedMemoryStream::Read_c0d6dde3943b413e(cli::array<unsigned char>* buffer, int32_t offset, int32_t count) {
        if(this->closed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("The stream is closed"));
        }
        if((buffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("buffer"));
        }
        if((offset < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("offset"), _T("Non-negative number required."));
        }
        if((count < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("count"), _T("Non-negative number required."));
        }
        if(((buffer->get_Length() - offset) < count)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("The length of the buffer array minus the offset parameter is less than the count parameter"));
        }
        if(((int32_t)(this->fileaccess) ==  2)) 
        {
            throw cli::gcnew<System::NotSupportedException>(_T("Stream does not support reading"));
        }
        if((this->current_position >= this->length)) 
        {
            return 0;
        }
        int32_t progress = ((this->current_position + (int64_t)(count)) < this->length) ? count : (int32_t)(this->length - this->current_position);
        if((this->safebuffer != nullptr)) 
        {
            unsigned char *ptr = nullptr;
            {
                cli::finally_guard([&]() {
                    if((ptr != nullptr)) 
                    {
                        this->safebuffer->ReleasePointer();
                    }
                });
                this->safebuffer->AcquirePointer(ptr);
                System::Runtime::InteropServices::Marshal::Copy9(cli::ctor<::System::IntPtr>((void*)((ptr + (int64_t)(this->current_position)))), buffer, offset, progress);
            }
        }
         else 
        {
            System::Runtime::InteropServices::Marshal::Copy9(cli::ctor<::System::IntPtr>((cli::import(this->initial_pointer)->ToInt64() + this->current_position)), buffer, offset, progress);
        }
        (this->current_position = this->current_position + (int64_t)(progress));
        return progress;
    }
    
    int32_t UnmanagedMemoryStream::ReadByte_61a294e42318f99() {
        if(this->closed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("The stream is closed"));
        }
        if(((int32_t)(this->fileaccess) ==  2)) 
        {
            throw cli::gcnew<System::NotSupportedException>(_T("Stream does not support reading"));
        }
        if((this->current_position >= this->length)) 
        {
            return -1;
        }
        if((this->safebuffer != nullptr)) 
        {
            unsigned char *ptr = nullptr;
            {
                cli::finally_guard([&]() {
                    if((ptr != nullptr)) 
                    {
                        this->safebuffer->ReleasePointer();
                    }
                });
                this->safebuffer->AcquirePointer(ptr);
                return (int32_t)(System::Runtime::InteropServices::Marshal::ReadByte2(cli::ctor<::System::IntPtr>((void*)(ptr)), (int32_t)this->current_position++));
            }
        }
         else 
        {
            return (int32_t)(System::Runtime::InteropServices::Marshal::ReadByte2(this->initial_pointer, (int32_t)this->current_position++));
        }
    }
    
    int64_t UnmanagedMemoryStream::Seek_df5b3eadfe9adf31(int64_t offset, SeekOrigin loc) {
        if(this->closed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("The stream is closed"));
        }
        int64_t refpoint;
        switch(loc) {
            case SeekOrigin::Begin: case_1146: {
                if((offset < 0L)) 
                {
                    throw cli::gcnew<IOException>(_T("An attempt was made to seek before the beginning of the stream"));
                }
                refpoint = this->initial_position;
                break;
            }
            case SeekOrigin::Current: case_1147: {
                refpoint = this->current_position;
                break;
            }
            case SeekOrigin::End: case_1148: {
                refpoint = this->length;
                break;
            }
            default: case_1149: {
                throw cli::gcnew<System::ArgumentException>(_T("Invalid SeekOrigin option"));
            }
        }
        (refpoint = refpoint + offset);
        if((refpoint < this->initial_position)) 
        {
            throw cli::gcnew<IOException>(_T("An attempt was made to seek before the beginning of the stream"));
        }
        this->current_position = refpoint;
        return this->current_position;
    }
    
    void UnmanagedMemoryStream::SetLength_18d421048f3d4df5(int64_t value) {
        if((this->safebuffer != nullptr)) 
        {
            throw cli::gcnew<System::NotSupportedException>(_T("Not supported when using SafeBuffer"));
        }
        if(this->closed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("The stream is closed"));
        }
        if((value < 0L)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("length"), _T("Non-negative number required."));
        }
        if((value > this->capacity)) 
        {
            throw cli::gcnew<IOException>(_T("Unable to expand length of this stream beyond its capacity."));
        }
        if(((int32_t)(this->fileaccess) ==  1)) 
        {
            throw cli::gcnew<System::NotSupportedException>(_T("Stream does not support writing."));
        }
        this->length = value;
        if((this->length < this->current_position)) 
        {
            this->current_position = this->length;
        }
    }
    
    void UnmanagedMemoryStream::Flush_132821400030c993() {
        if(this->closed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("The stream is closed"));
        }
    }
    
    void UnmanagedMemoryStream::Dispose_b215be19126499b0(bool disposing) {
        if(this->closed) 
        {
            return;
        }
        this->closed = true;
        if((this->Closed != nullptr)) 
        {
            this->Closed->Invoke(this, nullptr);
        }
    }
    
    void UnmanagedMemoryStream::Write_1f8a1dbe71b0eb89(cli::array<unsigned char>* buffer, int32_t offset, int32_t count) {
        if(this->closed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("The stream is closed"));
        }
        if((buffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("The buffer parameter is a null reference"));
        }
        if((offset < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("offset"), _T("Non-negative number required."));
        }
        if((count < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("count"), _T("Non-negative number required."));
        }
        if(((buffer->get_Length() - offset) < count)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("The length of the buffer array minus the offset parameter is less than the count parameter"));
        }
        if((this->current_position > (this->capacity - (int64_t)(count)))) 
        {
            throw cli::gcnew<System::NotSupportedException>(_T("Unable to expand length of this stream beyond its capacity."));
        }
        if(((int32_t)(this->fileaccess) ==  1)) 
        {
            throw cli::gcnew<System::NotSupportedException>(_T("Stream does not support writing."));
        }
        if((this->safebuffer != nullptr)) 
        {
            unsigned char *dest = nullptr;
            {
                cli::finally_guard([&]() {
                    if((dest != nullptr)) 
                    {
                        this->safebuffer->ReleasePointer();
                    }
                });
                this->safebuffer->AcquirePointer(dest);
                {
                    /* FIXED - BLOCK */
                    unsigned char* src = cli::fixed_guard(((buffer ==  nullptr) || (buffer->get_Length() ==  0)) ? nullptr : buffer);
                    (dest = (dest += (int64_t)(this->current_position)));
                    System::String::memcpy(dest, (src + (int32_t)(offset)), count);
                }
            }
        }
         else 
        {
            {
                /* FIXED - BLOCK */
                unsigned char* src = cli::fixed_guard(((buffer ==  nullptr) || (buffer->get_Length() ==  0)) ? nullptr : buffer);
                unsigned char *dest = ((unsigned char*)((void*)this->initial_pointer) + (int64_t)(this->current_position));
                System::String::memcpy(dest, (src + (int32_t)(offset)), count);
            }
        }
        (this->current_position = this->current_position + (int64_t)(count));
        if((this->current_position > this->length)) 
        {
            this->length = this->current_position;
        }
    }
    
    void UnmanagedMemoryStream::WriteByte_4404d6329af3b6d5(unsigned char value) {
        if(this->closed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("The stream is closed"));
        }
        if((this->current_position ==  this->capacity)) 
        {
            throw cli::gcnew<System::NotSupportedException>(_T("The current position is at the end of the capacity of the stream"));
        }
        if(((int32_t)(this->fileaccess) ==  1)) 
        {
            throw cli::gcnew<System::NotSupportedException>(_T("Stream does not support writing."));
        }
        if((this->safebuffer != nullptr)) 
        {
            unsigned char *dest = nullptr;
            {
                cli::finally_guard([&]() {
                    if((dest != nullptr)) 
                    {
                        this->safebuffer->ReleasePointer();
                    }
                });
                this->safebuffer->AcquirePointer(dest);
                (dest = (dest += (int64_t)(this->current_position++)));
                (*dest) = value;
            }
        }
         else 
        {
            unsigned char *dest = ((unsigned char*)((void*)this->initial_pointer) + (int32_t)((int32_t)this->current_position++));
            (*dest) = value;
        }
        if((this->current_position > this->length)) 
        {
            this->length = this->current_position;
        }
    }
    
    void UnmanagedMemoryStream::Initialize(unsigned char* pointer, int64_t length, int64_t capacity, FileAccess access) {
        if((pointer ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("pointer"));
        }
        if((length < 0L)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("length"), _T("Non-negative number required."));
        }
        if((capacity < 0L)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("capacity"), _T("Non-negative number required."));
        }
        if((length > capacity)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("length"), _T("The length cannot be greater than the capacity."));
        }
        if((((int32_t)(access) < 1) || ((int32_t)(access) > 3))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("access"), _T("Enum value was out of legal range."));
        }
        if(!(this->closed)) 
        {
            throw cli::gcnew<System::InvalidOperationException>(_T("Called Initialize twice"));
        }
        this->fileaccess = access;
        this->length = length;
        this->capacity = capacity;
        this->initial_position = 0L;
        this->current_position = this->initial_position;
        this->initial_pointer = cli::ctor<::System::IntPtr>((void*)(pointer));
        this->closed = false;
    }
    
    void UnmanagedMemoryStream::Initialize2(System::Runtime::InteropServices::SafeBuffer* buffer, int64_t offset, int64_t length, FileAccess access) {
        if((buffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("buffer"));
        }
        if((offset < 0L)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("offset"));
        }
        if((length < 0L)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("length"));
        }
        uint64_t blength = buffer->get_ByteLength();
        if(((blength - (uint64_t)length) < (uint64_t)offset)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Invalid offset and/or length"));
        }
        if((((int32_t)(access) < 1) || ((int32_t)(access) > 3))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("access"));
        }
        if(!(this->closed)) 
        {
            throw cli::gcnew<System::InvalidOperationException>(_T("Called Initialize twice"));
        }
        this->length = length;
        this->capacity = length;
        this->fileaccess = access;
        this->safebuffer = buffer;
        this->initial_position = offset;
        this->current_position = offset;
        this->closed = false;
    }
    
    bool UnmanagedMemoryStream::get_CanRead_50a10d564be8aaa2() {
        return (!(this->closed) && ((int32_t)(this->fileaccess) != 2));
    }
    
    bool UnmanagedMemoryStream::get_CanSeek_8c8861ce02c6bdeb() {
        return !(this->closed);
    }
    
    bool UnmanagedMemoryStream::get_CanWrite_c8955eadfc77124c() {
        return (!(this->closed) && ((int32_t)(this->fileaccess) != 1));
    }
    
    int64_t UnmanagedMemoryStream::get_Capacity() {
        if(this->closed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("The stream is closed"));
        }
         else 
        {
            return this->capacity;
        }
    }
    
    int64_t UnmanagedMemoryStream::get_Length_ddb8b0d061db5350() {
        if(this->closed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("The stream is closed"));
        }
         else 
        {
            return this->length;
        }
    }
    
    int64_t UnmanagedMemoryStream::get_Position_5e75d5c458401f13() {
        if(this->closed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("The stream is closed"));
        }
        return this->current_position;
    }
    
    int64_t UnmanagedMemoryStream::set_Position_cfe1def757785ad(int64_t value) {
        if(this->closed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("The stream is closed"));
        }
        if((value < 0L)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("value"), _T("Non-negative number required."));
        }
        if((value > 2147483647L)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("value"), _T("The position is larger than Int32.MaxValue."));
        }
        this->current_position = value;
        return get_Position_5e75d5c458401f13();
    }
    
    unsigned char* UnmanagedMemoryStream::get_PositionPointer() {
        if((this->safebuffer != nullptr)) 
        {
            throw cli::gcnew<System::NotSupportedException>(_T("Not supported when using SafeBuffer"));
        }
        if(this->closed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("The stream is closed"));
        }
        if((this->current_position >= this->length)) 
        {
            throw cli::gcnew<System::IndexOutOfRangeException>(_T("value"));
        }
        return ((unsigned char*)((void*)this->initial_pointer) + (int64_t)(this->current_position));
    }
    
    unsigned char* UnmanagedMemoryStream::set_PositionPointer(unsigned char* value) {
        if((this->safebuffer != nullptr)) 
        {
            throw cli::gcnew<System::NotSupportedException>(_T("Not supported when using SafeBuffer"));
        }
        if(this->closed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("The stream is closed"));
        }
        if((value < (unsigned char*)((void*)this->initial_pointer))) 
        {
            throw cli::gcnew<IOException>(_T("Address is below the inital address"));
        }
        this->set_Position_cfe1def757785ad((value - (unsigned char*)((void*)this->initial_pointer)));
        return get_PositionPointer();
    }
    
    void UnmanagedMemoryStream::add_Closed(System::EventHandler* value) {
      // TODO: "Implement automatic events!"
    }
    
    void UnmanagedMemoryStream::remove_Closed(System::EventHandler* value) {
      // TODO: "Implement automatic events!"
    }
    
}}
namespace System { namespace IO { namespace IsolatedStorage {
    
    
    void IsolatedStorage::constructor() {
    }
    
    void IsolatedStorage::InitStore(IsolatedStorageScope scope, System::Type* domainEvidenceType, System::Type* assemblyEvidenceType) {
        switch(scope) {
            case (IsolatedStorageScope)5L: case (IsolatedStorageScope)7L: case_1150: {
                throw cli::gcnew<System::NotImplementedException>(cli::import(scope)->ToString_1636a0751cb9ac11());
            }
            default: case_1151: {
                throw cli::gcnew<System::ArgumentException>(cli::import(scope)->ToString_1636a0751cb9ac11());
            }
        }
    }
    
    void IsolatedStorage::InitStore2(IsolatedStorageScope scope, System::Type* appEvidenceType) {
        if((System::AppDomain::get_CurrentDomain()->get_ApplicationIdentity() ==  nullptr)) 
        {
            throw cli::gcnew<IsolatedStorageException>(Locale::GetText(_T("No ApplicationIdentity available for AppDomain.")));
        }
        if(System::Type::op_Equality2(appEvidenceType, nullptr)) 
        {
        }
        this->storage_scope = scope;
    }
    
    bool IsolatedStorage::IncreaseQuotaTo_ede0fdcdc0552a87(int64_t newQuotaSize) {
        return false;
    }
    
    System::Object* IsolatedStorage::get_ApplicationIdentity() {
        if(((int32_t)(((int32_t)(this->storage_scope) & 32)) ==  0)) 
        {
            throw cli::gcnew<System::InvalidOperationException>(Locale::GetText(_T("Invalid Isolation Scope.")));
        }
        if((this->_applicationIdentity ==  nullptr)) 
        {
            throw cli::gcnew<System::InvalidOperationException>(Locale::GetText(_T("Identity unavailable.")));
        }
        throw cli::gcnew<System::NotImplementedException>(Locale::GetText(_T("CAS related")));
    }
    
    System::Object* IsolatedStorage::get_AssemblyIdentity() {
        if(((int32_t)(((int32_t)(this->storage_scope) & 4)) ==  0)) 
        {
            throw cli::gcnew<System::InvalidOperationException>(Locale::GetText(_T("Invalid Isolation Scope.")));
        }
        if((this->_assemblyIdentity ==  nullptr)) 
        {
            throw cli::gcnew<System::InvalidOperationException>(Locale::GetText(_T("Identity unavailable.")));
        }
        return this->_assemblyIdentity;
    }
    
    uint64_t IsolatedStorage::get_CurrentSize_c4d8b3e65a826a34() {
        throw cli::gcnew<System::InvalidOperationException>(Locale::GetText(_T("IsolatedStorage does not have a preset CurrentSize.")));
    }
    
    System::Object* IsolatedStorage::get_DomainIdentity() {
        if(((int32_t)(((int32_t)(this->storage_scope) & 2)) ==  0)) 
        {
            throw cli::gcnew<System::InvalidOperationException>(Locale::GetText(_T("Invalid Isolation Scope.")));
        }
        if((this->_domainIdentity ==  nullptr)) 
        {
            throw cli::gcnew<System::InvalidOperationException>(Locale::GetText(_T("Identity unavailable.")));
        }
        return this->_domainIdentity;
    }
    
    uint64_t IsolatedStorage::get_MaximumSize_bf42d10b1bbb7a25() {
        throw cli::gcnew<System::InvalidOperationException>(Locale::GetText(_T("IsolatedStorage does not have a preset MaximumSize.")));
    }
    
    IsolatedStorageScope IsolatedStorage::get_Scope() {
        return this->storage_scope;
    }
    
    int64_t IsolatedStorage::get_AvailableFreeSpace_18d9a80c1eecd236() {
        throw cli::gcnew<System::InvalidOperationException>(_T("This property is not defined for this store."));
    }
    
    int64_t IsolatedStorage::get_Quota_3816cb7ba1196819() {
        throw cli::gcnew<System::InvalidOperationException>(_T("This property is not defined for this store."));
    }
    
    int64_t IsolatedStorage::get_UsedSize_673e5c0d6520fff9() {
        throw cli::gcnew<System::InvalidOperationException>(_T("This property is not defined for this store."));
    }
    
    char16_t IsolatedStorage::get_SeparatorExternal_f44feaab38d1f088() {
        return System::IO::Path::DirectorySeparatorChar;
    }
    
    char16_t IsolatedStorage::get_SeparatorInternal_58b8fdacb2da10bf() {
        return u'.';
    }
    
}}}
namespace System { namespace IO { namespace IsolatedStorage {
    
    
    void IsolatedStorageException::constructor() {
    }
    
    void IsolatedStorageException::constructor(System::String* message) {
    }
    
    void IsolatedStorageException::constructor(System::String* message, System::Exception* inner) {
    }
    
    void IsolatedStorageException::constructor(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
    }
    
}}}
namespace System { namespace IO { namespace IsolatedStorage {
    
    System::Threading::Mutex*  IsolatedStorageFile::mutex;
    
    IsolatedStorageFile::IsolatedStorageFile()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void IsolatedStorageFile::constructor(IsolatedStorageScope scope) {
        this->storage_scope = scope;
    }
    
    void IsolatedStorageFile::constructor(IsolatedStorageScope scope, System::String* location) {
        this->storage_scope = scope;
        this->directory = cli::gcnew<System::IO::DirectoryInfo>(location);
        if(!(this->directory->get_Exists_44ccb569427c51d7())) 
        {
            System::String *msg = Locale::GetText(_T("Invalid storage."));
            throw cli::gcnew<IsolatedStorageException>(msg);
        }
    }
    
    void IsolatedStorageFile::static_constructor() {
    }
    
    void IsolatedStorageFile::Finalize_7a689dd73f4448e9() {
        {
            cli::finally_guard([&]() {
                Finalize_b946fbc32e26afd6();
            });
        }
    }
    
    System::Collections::IEnumerator* IsolatedStorageFile::GetEnumerator(IsolatedStorageScope scope) {
        Demand(scope);
        switch(scope) {
            case IsolatedStorageScope::User: case (IsolatedStorageScope)9L: case IsolatedStorageScope::Machine: case_1152: {
                break;
            }
            default: case_1153: {
                System::String *msg = Locale::GetText(_T("Invalid scope, only User, User|Roaming and Machine are valid"));
                throw cli::gcnew<System::ArgumentException>(msg);
            }
        }
        return cli::gcnew<IsolatedStorageFileEnumerator>(scope, GetIsolatedStorageRoot(scope));
    }
    
    IsolatedStorageFile* IsolatedStorageFile::GetStore(IsolatedStorageScope scope, System::Security::Policy::Evidence* domainEvidence, System::Type* domainEvidenceType, System::Security::Policy::Evidence* assemblyEvidence, System::Type* assemblyEvidenceType) {
        Demand(scope);
        bool domain = ((int32_t)(((int32_t)(scope) & 2)) != 0);
        if((domain && (domainEvidence ==  nullptr))) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("domainEvidence"));
        }
        bool assembly = ((int32_t)(((int32_t)(scope) & 4)) != 0);
        if((assembly && (assemblyEvidence ==  nullptr))) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("assemblyEvidence"));
        }
        IsolatedStorageFile *storageFile = cli::gcnew<IsolatedStorageFile>(scope);
        if(domain) 
        {
            if(System::Type::op_Equality2(domainEvidenceType, nullptr)) 
            {
                storageFile->_domainIdentity = GetDomainIdentityFromEvidence(domainEvidence);
            }
             else 
            {
                storageFile->_domainIdentity = GetTypeFromEvidence(domainEvidence, domainEvidenceType);
            }
            if((storageFile->_domainIdentity ==  nullptr)) 
            {
                throw cli::gcnew<IsolatedStorageException>(Locale::GetText(_T("Couldn\'t find domain identity.")));
            }
        }
        if(assembly) 
        {
            if(System::Type::op_Equality2(assemblyEvidenceType, nullptr)) 
            {
                storageFile->_assemblyIdentity = GetAssemblyIdentityFromEvidence(assemblyEvidence);
            }
             else 
            {
                storageFile->_assemblyIdentity = GetTypeFromEvidence(assemblyEvidence, assemblyEvidenceType);
            }
            if((storageFile->_assemblyIdentity ==  nullptr)) 
            {
                throw cli::gcnew<IsolatedStorageException>(Locale::GetText(_T("Couldn\'t find assembly identity.")));
            }
        }
        storageFile->PostInit();
        return storageFile;
    }
    
    IsolatedStorageFile* IsolatedStorageFile::GetStore2(IsolatedStorageScope scope, System::Object* domainIdentity, System::Object* assemblyIdentity) {
        Demand(scope);
        if((((int32_t)(((int32_t)(scope) & 2)) != 0) && (domainIdentity ==  nullptr))) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("domainIdentity"));
        }
        bool assembly = ((int32_t)(((int32_t)(scope) & 4)) != 0);
        if((assembly && (assemblyIdentity ==  nullptr))) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("assemblyIdentity"));
        }
        IsolatedStorageFile *storageFile = cli::gcnew<IsolatedStorageFile>(scope);
        if(assembly) 
        {
            storageFile->_fullEvidences = System::Reflection::Assembly::GetCallingAssembly()->UnprotectedGetEvidence();
        }
        storageFile->_domainIdentity = domainIdentity;
        storageFile->_assemblyIdentity = assemblyIdentity;
        storageFile->PostInit();
        return storageFile;
    }
    
    IsolatedStorageFile* IsolatedStorageFile::GetStore3(IsolatedStorageScope scope, System::Type* domainEvidenceType, System::Type* assemblyEvidenceType) {
        Demand(scope);
        IsolatedStorageFile *storageFile = cli::gcnew<IsolatedStorageFile>(scope);
        if(((int32_t)(((int32_t)(scope) & 2)) != 0)) 
        {
            if(System::Type::op_Equality2(domainEvidenceType, nullptr)) 
            {
                domainEvidenceType = cli::typeof<System::Type>::info;
            }
            storageFile->_domainIdentity = GetTypeFromEvidence(System::AppDomain::get_CurrentDomain()->get_Evidence(), domainEvidenceType);
        }
        if(((int32_t)(((int32_t)(scope) & 4)) != 0)) 
        {
            System::Security::Policy::Evidence *e = System::Reflection::Assembly::GetCallingAssembly()->UnprotectedGetEvidence();
            storageFile->_fullEvidences = e;
            if(((int32_t)(((int32_t)(scope) & 2)) != 0)) 
            {
                if(System::Type::op_Equality2(assemblyEvidenceType, nullptr)) 
                {
                    assemblyEvidenceType = cli::typeof<System::Type>::info;
                }
                storageFile->_assemblyIdentity = GetTypeFromEvidence(e, assemblyEvidenceType);
            }
             else 
            {
                storageFile->_assemblyIdentity = GetAssemblyIdentityFromEvidence(e);
            }
        }
        storageFile->PostInit();
        return storageFile;
    }
    
    IsolatedStorageFile* IsolatedStorageFile::GetStore4(IsolatedStorageScope scope, System::Object* applicationIdentity) {
        Demand(scope);
        if((applicationIdentity ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("applicationIdentity"));
        }
        IsolatedStorageFile *storageFile = cli::gcnew<IsolatedStorageFile>(scope);
        storageFile->_applicationIdentity = applicationIdentity;
        storageFile->_fullEvidences = System::Reflection::Assembly::GetCallingAssembly()->UnprotectedGetEvidence();
        storageFile->PostInit();
        return storageFile;
    }
    
    IsolatedStorageFile* IsolatedStorageFile::GetStore5(IsolatedStorageScope scope, System::Type* applicationEvidenceType) {
        Demand(scope);
        IsolatedStorageFile *storageFile = cli::gcnew<IsolatedStorageFile>(scope);
        storageFile->InitStore2(scope, applicationEvidenceType);
        storageFile->_fullEvidences = System::Reflection::Assembly::GetCallingAssembly()->UnprotectedGetEvidence();
        storageFile->PostInit();
        return storageFile;
    }
    
    IsolatedStorageFile* IsolatedStorageFile::GetMachineStoreForApplication() {
        IsolatedStorageScope scope = (IsolatedStorageScope)48L;
        IsolatedStorageFile *storageFile = cli::gcnew<IsolatedStorageFile>(scope);
        storageFile->InitStore2(scope, nullptr);
        storageFile->_fullEvidences = System::Reflection::Assembly::GetCallingAssembly()->UnprotectedGetEvidence();
        storageFile->PostInit();
        return storageFile;
    }
    
    IsolatedStorageFile* IsolatedStorageFile::GetMachineStoreForAssembly() {
        IsolatedStorageScope scope = (IsolatedStorageScope)20L;
        IsolatedStorageFile *storageFile = cli::gcnew<IsolatedStorageFile>(scope);
        System::Security::Policy::Evidence *e = System::Reflection::Assembly::GetCallingAssembly()->UnprotectedGetEvidence();
        storageFile->_fullEvidences = e;
        storageFile->_assemblyIdentity = GetAssemblyIdentityFromEvidence(e);
        storageFile->PostInit();
        return storageFile;
    }
    
    IsolatedStorageFile* IsolatedStorageFile::GetMachineStoreForDomain() {
        IsolatedStorageScope scope = (IsolatedStorageScope)22L;
        IsolatedStorageFile *storageFile = cli::gcnew<IsolatedStorageFile>(scope);
        storageFile->_domainIdentity = GetDomainIdentityFromEvidence(System::AppDomain::get_CurrentDomain()->get_Evidence());
        System::Security::Policy::Evidence *e = System::Reflection::Assembly::GetCallingAssembly()->UnprotectedGetEvidence();
        storageFile->_fullEvidences = e;
        storageFile->_assemblyIdentity = GetAssemblyIdentityFromEvidence(e);
        storageFile->PostInit();
        return storageFile;
    }
    
    IsolatedStorageFile* IsolatedStorageFile::GetUserStoreForApplication() {
        IsolatedStorageScope scope = (IsolatedStorageScope)33L;
        IsolatedStorageFile *storageFile = cli::gcnew<IsolatedStorageFile>(scope);
        storageFile->InitStore2(scope, nullptr);
        storageFile->_fullEvidences = System::Reflection::Assembly::GetCallingAssembly()->UnprotectedGetEvidence();
        storageFile->PostInit();
        return storageFile;
    }
    
    IsolatedStorageFile* IsolatedStorageFile::GetUserStoreForAssembly() {
        IsolatedStorageScope scope = (IsolatedStorageScope)5L;
        IsolatedStorageFile *storageFile = cli::gcnew<IsolatedStorageFile>(scope);
        System::Security::Policy::Evidence *e = System::Reflection::Assembly::GetCallingAssembly()->UnprotectedGetEvidence();
        storageFile->_fullEvidences = e;
        storageFile->_assemblyIdentity = GetAssemblyIdentityFromEvidence(e);
        storageFile->PostInit();
        return storageFile;
    }
    
    IsolatedStorageFile* IsolatedStorageFile::GetUserStoreForDomain() {
        IsolatedStorageScope scope = (IsolatedStorageScope)7L;
        IsolatedStorageFile *storageFile = cli::gcnew<IsolatedStorageFile>(scope);
        storageFile->_domainIdentity = GetDomainIdentityFromEvidence(System::AppDomain::get_CurrentDomain()->get_Evidence());
        System::Security::Policy::Evidence *e = System::Reflection::Assembly::GetCallingAssembly()->UnprotectedGetEvidence();
        storageFile->_fullEvidences = e;
        storageFile->_assemblyIdentity = GetAssemblyIdentityFromEvidence(e);
        storageFile->PostInit();
        return storageFile;
    }
    
    IsolatedStorageFile* IsolatedStorageFile::GetUserStoreForSite() {
        throw cli::gcnew<System::NotSupportedException>();
    }
    
    void IsolatedStorageFile::Remove2(IsolatedStorageScope scope) {
        System::String *dir = GetIsolatedStorageRoot(scope);
        if(!(System::IO::Directory::Exists(dir))) 
        {
            return;
        }
        try {
            System::IO::Directory::Delete2(dir, true);
        }
        catch(System::IO::IOException*) {
            throw cli::gcnew<IsolatedStorageException>(_T("Could not remove storage."));
        }
    }
    
    System::String* IsolatedStorageFile::GetIsolatedStorageRoot(IsolatedStorageScope scope) {
        System::String *root = nullptr;
        if(((int32_t)(((int32_t)(scope) & 1)) != 0)) 
        {
            if(((int32_t)(((int32_t)(scope) & 8)) != 0)) 
            {
                root = System::Environment::UnixGetFolderPath(System::SpecialFolder::LocalApplicationData, System::SpecialFolderOption::Create);
            }
             else 
            {
                root = System::Environment::UnixGetFolderPath(System::SpecialFolder::ApplicationData, System::SpecialFolderOption::Create);
            }
        }
         else 
        {
            if(((int32_t)(((int32_t)(scope) & 16)) != 0)) 
            {
                root = System::Environment::UnixGetFolderPath(System::SpecialFolder::CommonApplicationData, System::SpecialFolderOption::Create);
            }
        }
        if((root ==  nullptr)) 
        {
            System::String *msg = Locale::GetText(_T("Couldn\'t access storage location for \'{0}\'."));
            throw cli::gcnew<IsolatedStorageException>(System::String::Format2(msg, cli::box(scope)));
        }
        return System::IO::Path::Combine(root, _T(".isolated-storage"));
    }
    
    void IsolatedStorageFile::Demand(IsolatedStorageScope scope) {
        if(System::Security::SecurityManager::get_SecurityEnabled()) 
        {
            System::Security::Permissions::IsolatedStorageFilePermission *isfp = cli::gcnew<System::Security::Permissions::IsolatedStorageFilePermission>(System::Security::Permissions::PermissionState::None);
            isfp->set_UsageAllowed(ScopeToContainment(scope));
            isfp->Demand();
        }
    }
    
    System::Security::Permissions::IsolatedStorageContainment IsolatedStorageFile::ScopeToContainment(IsolatedStorageScope scope) {
        switch(scope) {
            case (IsolatedStorageScope)7L: case_1154: {
                return System::Security::Permissions::IsolatedStorageContainment::DomainIsolationByUser;
            }
            case (IsolatedStorageScope)5L: case_1155: {
                return System::Security::Permissions::IsolatedStorageContainment::AssemblyIsolationByUser;
            }
            case (IsolatedStorageScope)15L: case_1156: {
                return System::Security::Permissions::IsolatedStorageContainment::DomainIsolationByRoamingUser;
            }
            case (IsolatedStorageScope)13L: case_1157: {
                return System::Security::Permissions::IsolatedStorageContainment::AssemblyIsolationByRoamingUser;
            }
            case (IsolatedStorageScope)33L: case_1158: {
                return System::Security::Permissions::IsolatedStorageContainment::ApplicationIsolationByUser;
            }
            case (IsolatedStorageScope)22L: case_1159: {
                return System::Security::Permissions::IsolatedStorageContainment::DomainIsolationByMachine;
            }
            case (IsolatedStorageScope)20L: case_1160: {
                return System::Security::Permissions::IsolatedStorageContainment::AssemblyIsolationByMachine;
            }
            case (IsolatedStorageScope)48L: case_1161: {
                return System::Security::Permissions::IsolatedStorageContainment::ApplicationIsolationByMachine;
            }
            case (IsolatedStorageScope)41L: case_1162: {
                return System::Security::Permissions::IsolatedStorageContainment::ApplicationIsolationByRoamingUser;
            }
            default: case_1163: {
                return System::Security::Permissions::IsolatedStorageContainment::UnrestrictedIsolatedStorage;
            }
        }
    }
    
    uint64_t IsolatedStorageFile::GetDirectorySize(System::IO::DirectoryInfo* di) {
        uint64_t size = 0UL;
        for(auto tmp_250 : di->GetFiles()) {
            auto fi = cli::cast<System::IO::FileInfo*>(tmp_250);
            (size = size + (uint64_t)fi->get_Length());
        }
        for(auto tmp_251 : di->GetDirectories()) {
            auto d = cli::cast<System::IO::DirectoryInfo*>(tmp_251);
            (size = size + GetDirectorySize(d));
        }
        return size;
    }
    
    void IsolatedStorageFile::PostInit() {
        System::String *root = GetIsolatedStorageRoot(this->get_Scope());
        System::String *dir = nullptr;
        if((this->_applicationIdentity != nullptr)) 
        {
            dir = System::String::Format3(_T("a{0}{1}"), cli::box(this->get_SeparatorInternal_58b8fdacb2da10bf()), GetNameFromIdentity(this->_applicationIdentity));
        }
         else 
        {
            if((this->_domainIdentity != nullptr)) 
            {
                dir = System::String::Format4(_T("d{0}{1}{0}{2}"), cli::box(this->get_SeparatorInternal_58b8fdacb2da10bf()), GetNameFromIdentity(this->_domainIdentity), GetNameFromIdentity(this->_assemblyIdentity));
            }
             else 
            {
                if((this->_assemblyIdentity != nullptr)) 
                {
                    dir = System::String::Format3(_T("d{0}none{0}{1}"), cli::box(this->get_SeparatorInternal_58b8fdacb2da10bf()), GetNameFromIdentity(this->_assemblyIdentity));
                }
                 else 
                {
                    throw cli::gcnew<IsolatedStorageException>(Locale::GetText(_T("No code identity available.")));
                }
            }
        }
        root = System::IO::Path::Combine(root, dir);
        this->directory = cli::gcnew<System::IO::DirectoryInfo>(root);
        if(!(this->directory->get_Exists_44ccb569427c51d7())) 
        {
            try {
                this->directory->Create();
                SaveIdentities(root);
            }
            catch(System::IO::IOException*) {
            }
        }
    }
    
    void IsolatedStorageFile::Close() {
        this->closed = true;
    }
    
    void IsolatedStorageFile::CreateDirectory(System::String* dir) {
        if((dir ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("dir"));
        }
        if((dir->IndexOfAny(System::IO::Path::PathSeparatorChars) < 0)) 
        {
            if((this->directory->GetFiles2(dir)->get_Length() > 0)) 
            {
                throw cli::gcnew<IsolatedStorageException>(_T("Unable to create directory."));
            }
            this->directory->CreateSubdirectory(dir);
        }
         else 
        {
            cli::array<System::String*> *dirs = dir->Split(System::IO::Path::PathSeparatorChars);
            System::IO::DirectoryInfo *dinfo = this->directory;
            for(int32_t i = 0; (i < dirs->get_Length()); i++){
                if((dinfo->GetFiles2(dirs->at(i))->get_Length() > 0)) 
                {
                    throw cli::gcnew<IsolatedStorageException>(_T("Unable to create directory."));
                }
                dinfo = dinfo->CreateSubdirectory(dirs->at(i));
            }
        }
    }
    
    void IsolatedStorageFile::CopyFile(System::String* sourceFileName, System::String* destinationFileName) {
        CopyFile2(sourceFileName, destinationFileName, false);
    }
    
    void IsolatedStorageFile::CopyFile2(System::String* sourceFileName, System::String* destinationFileName, bool overwrite) {
        if((sourceFileName ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("sourceFileName"));
        }
        if((destinationFileName ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("destinationFileName"));
        }
        if((sourceFileName->Trim()->get_Length() ==  0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("An empty file name is not valid."), _T("sourceFileName"));
        }
        if((destinationFileName->Trim()->get_Length() ==  0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("An empty file name is not valid."), _T("destinationFileName"));
        }
        CheckOpen();
        System::String *source_full_path = System::IO::Path::Combine(this->directory->get_FullName_3d8989b544082b48(), sourceFileName);
        System::String *dest_full_path = System::IO::Path::Combine(this->directory->get_FullName_3d8989b544082b48(), destinationFileName);
        if((!(IsPathInStorage(source_full_path)) || !(IsPathInStorage(dest_full_path)))) 
        {
            throw cli::gcnew<IsolatedStorageException>(_T("Operation not allowed."));
        }
        if(!(System::IO::Directory::Exists(System::IO::Path::GetDirectoryName(source_full_path)))) 
        {
            throw cli::gcnew<System::IO::DirectoryNotFoundException>(cli::concat(_T("Could not find a part of path \'"), sourceFileName));
        }
        if(!(System::IO::File::Exists(source_full_path))) 
        {
            throw cli::gcnew<System::IO::FileNotFoundException>(cli::concat(_T("Could not find a part of path \'"), sourceFileName));
        }
        if((System::IO::File::Exists(dest_full_path) && !(overwrite))) 
        {
            throw cli::gcnew<IsolatedStorageException>(_T("Operation not allowed."));
        }
        try {
            System::IO::File::Copy2(source_full_path, dest_full_path, overwrite);
        }
        catch(System::IO::IOException*) {
            throw cli::gcnew<IsolatedStorageException>(_T("Operation not allowed."));
        }
    }
    
    IsolatedStorageFileStream* IsolatedStorageFile::CreateFile(System::String* path) {
        return cli::gcnew<IsolatedStorageFileStream>(path, System::IO::FileMode::Create, System::IO::FileAccess::ReadWrite, System::IO::FileShare::None, this);
    }
    
    void IsolatedStorageFile::DeleteDirectory(System::String* dir) {
        try {
            System::IO::DirectoryInfo *subdir = this->directory->CreateSubdirectory(dir);
            subdir->Delete_2d3445237ba2ed66();
        }
        catch(...) {
            throw cli::gcnew<IsolatedStorageException>(Locale::GetText2(_T("Could not delete directory \'{0}\'"), (new cli::array<System::Object*>({dir}))));
        }
    }
    
    void IsolatedStorageFile::DeleteFile(System::String* file) {
        if((file ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("file"));
        }
        System::String *full_path = System::IO::Path::Combine(this->directory->get_FullName_3d8989b544082b48(), file);
        if(!(System::IO::File::Exists(full_path))) 
        {
            throw cli::gcnew<IsolatedStorageException>(Locale::GetText2(_T("Could not delete file \'{0}\'"), (new cli::array<System::Object*>({file}))));
        }
        try {
            System::IO::File::Delete(System::IO::Path::Combine(this->directory->get_FullName_3d8989b544082b48(), file));
        }
        catch(...) {
            throw cli::gcnew<IsolatedStorageException>(Locale::GetText2(_T("Could not delete file \'{0}\'"), (new cli::array<System::Object*>({file}))));
        }
    }
    
    void IsolatedStorageFile::Dispose() {
        this->disposed = true;
        System::GC::SuppressFinalize(this);
    }
    
    bool IsolatedStorageFile::DirectoryExists(System::String* path) {
        if((path ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("path"));
        }
        CheckOpen();
        System::String *full_path = System::IO::Path::Combine(this->directory->get_FullName_3d8989b544082b48(), path);
        if(!(IsPathInStorage(full_path))) 
        {
            return false;
        }
        return System::IO::Directory::Exists(full_path);
    }
    
    bool IsolatedStorageFile::FileExists(System::String* path) {
        if((path ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("path"));
        }
        CheckOpen();
        System::String *full_path = System::IO::Path::Combine(this->directory->get_FullName_3d8989b544082b48(), path);
        if(!(IsPathInStorage(full_path))) 
        {
            return false;
        }
        return System::IO::File::Exists(full_path);
    }
    
    System::DateTimeOffset IsolatedStorageFile::GetCreationTime(System::String* path) {
        if((path ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("path"));
        }
        if((path->Trim()->get_Length() ==  0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("An empty path is not valid."));
        }
        CheckOpen();
        System::String *full_path = System::IO::Path::Combine(this->directory->get_FullName_3d8989b544082b48(), path);
        if(System::IO::File::Exists(full_path)) 
        {
            return System::DateTimeOffset::op_Implicit(System::IO::File::GetCreationTime(full_path));
        }
        return System::DateTimeOffset::op_Implicit(System::IO::Directory::GetCreationTime(full_path));
    }
    
    System::DateTimeOffset IsolatedStorageFile::GetLastAccessTime(System::String* path) {
        if((path ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("path"));
        }
        if((path->Trim()->get_Length() ==  0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("An empty path is not valid."));
        }
        CheckOpen();
        System::String *full_path = System::IO::Path::Combine(this->directory->get_FullName_3d8989b544082b48(), path);
        if(System::IO::File::Exists(full_path)) 
        {
            return System::DateTimeOffset::op_Implicit(System::IO::File::GetLastAccessTime(full_path));
        }
        return System::DateTimeOffset::op_Implicit(System::IO::Directory::GetLastAccessTime(full_path));
    }
    
    System::DateTimeOffset IsolatedStorageFile::GetLastWriteTime(System::String* path) {
        if((path ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("path"));
        }
        if((path->Trim()->get_Length() ==  0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("An empty path is not valid."));
        }
        CheckOpen();
        System::String *full_path = System::IO::Path::Combine(this->directory->get_FullName_3d8989b544082b48(), path);
        if(System::IO::File::Exists(full_path)) 
        {
            return System::DateTimeOffset::op_Implicit(System::IO::File::GetLastWriteTime(full_path));
        }
        return System::DateTimeOffset::op_Implicit(System::IO::Directory::GetLastWriteTime(full_path));
    }
    
    cli::array<System::String*>* IsolatedStorageFile::GetDirectoryNames(System::String* searchPattern) {
        if((searchPattern ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("searchPattern"));
        }
        if(searchPattern->Contains(_T(".."))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Search pattern cannot contain \'..\' to move up directories."), _T("searchPattern"));
        }
        System::String *path = System::IO::Path::GetDirectoryName(searchPattern);
        System::String *pattern = System::IO::Path::GetFileName(searchPattern);
        cli::array<System::IO::DirectoryInfo*> *adi = nullptr;
        if(((path ==  nullptr) || (path->get_Length() ==  0))) 
        {
            adi = this->directory->GetDirectories2(searchPattern);
        }
         else 
        {
            cli::array<System::IO::DirectoryInfo*> *subdirs = this->directory->GetDirectories2(path);
            if((((subdirs->get_Length() ==  1) && System::String::op_Equality(subdirs->at(0)->get_Name_34b64716a6d0afcd(), path)) && (subdirs->at(0)->get_FullName_3d8989b544082b48()->IndexOf7(this->directory->get_FullName_3d8989b544082b48()) >= 0))) 
            {
                adi = subdirs->at(0)->GetDirectories2(pattern);
            }
             else 
            {
                throw cli::gcnew<System::Security::SecurityException>();
            }
        }
        return GetNames(adi->template CovariantCast<System::IO::FileSystemInfo*>());
    }
    
    cli::array<System::String*>* IsolatedStorageFile::GetDirectoryNames2() {
        return GetDirectoryNames(_T("*"));
    }
    
    cli::array<System::String*>* IsolatedStorageFile::GetNames(cli::array<System::IO::FileSystemInfo*>* afsi) {
        cli::array<System::String*> *r = (new cli::array<System::String*>(afsi->get_Length()));
        for(int32_t i = 0; (i != afsi->get_Length()); ++i) {
            r->at(i) = afsi->at(i)->get_Name_34b64716a6d0afcd();
        }
        return r;
    }
    
    cli::array<System::String*>* IsolatedStorageFile::GetFileNames(System::String* searchPattern) {
        if((searchPattern ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("searchPattern"));
        }
        if(searchPattern->Contains(_T(".."))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Search pattern cannot contain \'..\' to move up directories."), _T("searchPattern"));
        }
        System::String *path = System::IO::Path::GetDirectoryName(searchPattern);
        System::String *pattern = System::IO::Path::GetFileName(searchPattern);
        cli::array<System::IO::FileInfo*> *afi = nullptr;
        if(((path ==  nullptr) || (path->get_Length() ==  0))) 
        {
            afi = this->directory->GetFiles2(searchPattern);
        }
         else 
        {
            cli::array<System::IO::DirectoryInfo*> *subdirs = this->directory->GetDirectories2(path);
            if((((subdirs->get_Length() ==  1) && System::String::op_Equality(subdirs->at(0)->get_Name_34b64716a6d0afcd(), path)) && (subdirs->at(0)->get_FullName_3d8989b544082b48()->IndexOf7(this->directory->get_FullName_3d8989b544082b48()) >= 0))) 
            {
                afi = subdirs->at(0)->GetFiles2(pattern);
            }
             else 
            {
                throw cli::gcnew<System::Security::SecurityException>();
            }
        }
        return GetNames(afi->template CovariantCast<System::IO::FileSystemInfo*>());
    }
    
    cli::array<System::String*>* IsolatedStorageFile::GetFileNames2() {
        return GetFileNames(_T("*"));
    }
    
    bool IsolatedStorageFile::IncreaseQuotaTo_ede0fdcdc0552a87(int64_t newQuotaSize) {
        if((newQuotaSize < this->get_Quota_3816cb7ba1196819())) 
        {
            throw cli::gcnew<System::ArgumentException>();
        }
        CheckOpen();
        return false;
    }
    
    void IsolatedStorageFile::MoveDirectory(System::String* sourceDirectoryName, System::String* destinationDirectoryName) {
        if((sourceDirectoryName ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("sourceDirectoryName"));
        }
        if((destinationDirectoryName ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("sourceDirectoryName"));
        }
        if((sourceDirectoryName->Trim()->get_Length() ==  0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("An empty directory name is not valid."), _T("sourceDirectoryName"));
        }
        if((destinationDirectoryName->Trim()->get_Length() ==  0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("An empty directory name is not valid."), _T("destinationDirectoryName"));
        }
        CheckOpen();
        System::String *src_full_path = System::IO::Path::Combine(this->directory->get_FullName_3d8989b544082b48(), sourceDirectoryName);
        System::String *dest_full_path = System::IO::Path::Combine(this->directory->get_FullName_3d8989b544082b48(), destinationDirectoryName);
        if((!(IsPathInStorage(src_full_path)) || !(IsPathInStorage(dest_full_path)))) 
        {
            throw cli::gcnew<IsolatedStorageException>(_T("Operation not allowed."));
        }
        if(!(System::IO::Directory::Exists(src_full_path))) 
        {
            throw cli::gcnew<System::IO::DirectoryNotFoundException>(cli::concat(_T("Could not find a part of path \'"), sourceDirectoryName));
        }
        if(!(System::IO::Directory::Exists(System::IO::Path::GetDirectoryName(dest_full_path)))) 
        {
            throw cli::gcnew<System::IO::DirectoryNotFoundException>(cli::concat(_T("Could not find a part of path \'"), destinationDirectoryName));
        }
        try {
            System::IO::Directory::Move(src_full_path, dest_full_path);
        }
        catch(System::IO::IOException*) {
            throw cli::gcnew<IsolatedStorageException>(_T("Operation not allowed."));
        }
    }
    
    void IsolatedStorageFile::MoveFile(System::String* sourceFileName, System::String* destinationFileName) {
        if((sourceFileName ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("sourceFileName"));
        }
        if((destinationFileName ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("sourceFileName"));
        }
        if((sourceFileName->Trim()->get_Length() ==  0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("An empty file name is not valid."), _T("sourceFileName"));
        }
        if((destinationFileName->Trim()->get_Length() ==  0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("An empty file name is not valid."), _T("destinationFileName"));
        }
        CheckOpen();
        System::String *source_full_path = System::IO::Path::Combine(this->directory->get_FullName_3d8989b544082b48(), sourceFileName);
        System::String *dest_full_path = System::IO::Path::Combine(this->directory->get_FullName_3d8989b544082b48(), destinationFileName);
        if((!(IsPathInStorage(source_full_path)) || !(IsPathInStorage(dest_full_path)))) 
        {
            throw cli::gcnew<IsolatedStorageException>(_T("Operation not allowed."));
        }
        if(!(System::IO::File::Exists(source_full_path))) 
        {
            throw cli::gcnew<System::IO::FileNotFoundException>(cli::concat(_T("Could not find a part of path \'"), sourceFileName));
        }
        if(!(System::IO::Directory::Exists(System::IO::Path::GetDirectoryName(dest_full_path)))) 
        {
            throw cli::gcnew<IsolatedStorageException>(_T("Operation not allowed."));
        }
        try {
            System::IO::File::Move(source_full_path, dest_full_path);
        }
        catch(System::IO::IOException*) {
            throw cli::gcnew<IsolatedStorageException>(_T("Operation not allowed."));
        }
    }
    
    IsolatedStorageFileStream* IsolatedStorageFile::OpenFile(System::String* path, System::IO::FileMode mode) {
        return cli::gcnew<IsolatedStorageFileStream>(path, mode, this);
    }
    
    IsolatedStorageFileStream* IsolatedStorageFile::OpenFile2(System::String* path, System::IO::FileMode mode, System::IO::FileAccess access) {
        return cli::gcnew<IsolatedStorageFileStream>(path, mode, access, this);
    }
    
    IsolatedStorageFileStream* IsolatedStorageFile::OpenFile3(System::String* path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share) {
        return cli::gcnew<IsolatedStorageFileStream>(path, mode, access, share, this);
    }
    
    void IsolatedStorageFile::Remove_b3e3f72785a30fc() {
        CheckOpen2(false);
        try {
            this->directory->Delete3(true);
        }
        catch(...) {
            throw cli::gcnew<IsolatedStorageException>(_T("Could not remove storage."));
        }
        Close();
    }
    
    System::Security::Permissions::IsolatedStoragePermission* IsolatedStorageFile::GetPermission_bd95612ebfcb7e7e(System::Security::PermissionSet* ps) {
        if((ps ==  nullptr)) 
        {
            return nullptr;
        }
        return cli::cast<System::Security::Permissions::IsolatedStoragePermission*>(ps->GetPermission(cli::typeof<System::Type>::info));
    }
    
    void IsolatedStorageFile::CheckOpen() {
        CheckOpen2(true);
    }
    
    void IsolatedStorageFile::CheckOpen2(bool checkDirExists) {
        if(this->disposed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("IsolatedStorageFile"));
        }
        if(this->closed) 
        {
            throw cli::gcnew<System::InvalidOperationException>(_T("Storage needs to be open for this operation."));
        }
        if((checkDirExists && !(System::IO::Directory::Exists(this->directory->get_FullName_3d8989b544082b48())))) 
        {
            throw cli::gcnew<IsolatedStorageException>(_T("Isolated storage has been removed or disabled."));
        }
    }
    
    bool IsolatedStorageFile::IsPathInStorage(System::String* path) {
        return System::IO::Path::GetFullPath(path)->StartsWith(this->directory->get_FullName_3d8989b544082b48());
    }
    
    System::String* IsolatedStorageFile::GetNameFromIdentity(System::Object* identity) {
        cli::array<unsigned char> *id = System::Text::Encoding::get_UTF8()->GetBytes_49806e8e98b1c1db(identity->ToString_1636a0751cb9ac11());
        System::Security::Cryptography::SHA1 *hash = System::Security::Cryptography::SHA1::Create3();
        cli::array<unsigned char> *full = hash->ComputeHash2(id, 0, id->get_Length());
        cli::array<unsigned char> *half = (new cli::array<unsigned char>(10));
        System::Buffer::BlockCopy(full, 0, half, 0, half->get_Length());
        return Mono::Security::Cryptography::CryptoConvert::ToHex(half);
    }
    
    System::Object* IsolatedStorageFile::GetTypeFromEvidence(System::Security::Policy::Evidence* e, System::Type* t) {
        for(auto tmp_252 : e) {
            auto o = cli::cast<System::Object*>(tmp_252);
            {
                if(System::Type::op_Equality2(o->GetType(), t)) 
                {
                    return o;
                }
            }
        }
        return nullptr;
    }
    
    System::Object* IsolatedStorageFile::GetAssemblyIdentityFromEvidence(System::Security::Policy::Evidence* e) {
        System::Object *identity = GetTypeFromEvidence(e, cli::typeof<System::Type>::info);
        if((identity != nullptr)) 
        {
            return identity;
        }
        identity = GetTypeFromEvidence(e, cli::typeof<System::Type>::info);
        if((identity != nullptr)) 
        {
            return identity;
        }
        return GetTypeFromEvidence(e, cli::typeof<System::Type>::info);
    }
    
    System::Object* IsolatedStorageFile::GetDomainIdentityFromEvidence(System::Security::Policy::Evidence* e) {
        System::Object *identity = GetTypeFromEvidence(e, cli::typeof<System::Type>::info);
        if((identity != nullptr)) 
        {
            return identity;
        }
        return GetTypeFromEvidence(e, cli::typeof<System::Type>::info);
    }
    
    void IsolatedStorageFile::SaveIdentities(System::String* root) {
        Identities identities = cli::ctor<Identities>(this->_applicationIdentity, this->_assemblyIdentity, this->_domainIdentity);
        System::Runtime::Serialization::Formatters::Binary::BinaryFormatter *formatter = cli::gcnew<System::Runtime::Serialization::Formatters::Binary::BinaryFormatter>();
        mutex->WaitOne_a04a6b7360612836();
        {
            cli::finally_guard([&]() {
                mutex->ReleaseMutex();
            });
            {
                /* USING - BLOCK */
                auto fs = System::IO::File::Create(cli::concat(root, _T(".storage")));
                cli::using_guard{fs};
                formatter->Serialize(fs, cli::box(identities));
            }
        }
    }
    
    uint64_t IsolatedStorageFile::get_CurrentSize_c4d8b3e65a826a34() {
        return GetDirectorySize(this->directory);
    }
    
    uint64_t IsolatedStorageFile::get_MaximumSize_bf42d10b1bbb7a25() {
        if(!(System::Security::SecurityManager::get_SecurityEnabled())) 
        {
            return 9223372036854775807UL;
        }
        if(this->_resolved) 
        {
            return this->_maxSize;
        }
        System::Security::Policy::Evidence *e = nullptr;
        if((this->_fullEvidences != nullptr)) 
        {
            e = this->_fullEvidences;
        }
         else 
        {
            e = cli::gcnew<System::Security::Policy::Evidence>();
            if((this->_assemblyIdentity != nullptr)) 
            {
                e->AddHost(this->_assemblyIdentity);
            }
        }
        if((e->get_Count() < 1)) 
        {
            throw cli::gcnew<System::InvalidOperationException>(Locale::GetText(_T("Couldn\'t get the quota from the available evidences.")));
        }
        System::Security::PermissionSet *denied = nullptr;
        System::Security::PermissionSet *ps = System::Security::SecurityManager::ResolvePolicy3(e, nullptr, nullptr, nullptr, denied);
        System::Security::Permissions::IsolatedStoragePermission *isp = IsolatedStorageFile::GetPermission_bd95612ebfcb7e7e(ps);
        if((isp ==  nullptr)) 
        {
            if(ps->IsUnrestricted()) 
            {
                this->_maxSize = 9223372036854775807UL;
            }
             else 
            {
                throw cli::gcnew<System::InvalidOperationException>(Locale::GetText(_T("No quota from the available evidences.")));
            }
        }
         else 
        {
            this->_maxSize = (uint64_t)isp->get_UserQuota();
        }
        this->_resolved = true;
        return this->_maxSize;
    }
    
    System::String* IsolatedStorageFile::get_Root() {
        return this->directory->get_FullName_3d8989b544082b48();
    }
    
    int64_t IsolatedStorageFile::get_AvailableFreeSpace_18d9a80c1eecd236() {
        CheckOpen();
        return 9223372036854775807L;
    }
    
    int64_t IsolatedStorageFile::get_Quota_3816cb7ba1196819() {
        CheckOpen();
        return (int64_t)this->get_MaximumSize_bf42d10b1bbb7a25();
    }
    
    int64_t IsolatedStorageFile::get_UsedSize_673e5c0d6520fff9() {
        CheckOpen();
        return (int64_t)GetDirectorySize(this->directory);
    }
    
    bool IsolatedStorageFile::get_IsEnabled() {
        return true;
    }
    
    bool IsolatedStorageFile::get_IsClosed() {
        return this->closed;
    }
    
    bool IsolatedStorageFile::get_IsDisposed() {
        return this->disposed;
    }
    
}}}
namespace System { namespace IO { namespace IsolatedStorage {
    
    
    void IsolatedStorageFileEnumerator::constructor(IsolatedStorageScope scope, System::String* root) {
        this->_scope = scope;
        if(System::IO::Directory::Exists(root)) 
        {
            this->_storages = System::IO::Directory::GetDirectories2(root, _T("d.*"));
        }
        this->_pos = -1;
    }
    
    bool IsolatedStorageFileEnumerator::MoveNext() {
        if((this->_storages ==  nullptr)) 
        {
            return false;
        }
        return (++this->_pos < this->_storages->get_Length());
    }
    
    void IsolatedStorageFileEnumerator::Reset() {
        this->_pos = -1;
    }
    
    System::Object* IsolatedStorageFileEnumerator::get_Current() {
        if((((this->_pos < 0) || (this->_storages ==  nullptr)) || (this->_pos >= this->_storages->get_Length()))) 
        {
            return nullptr;
        }
        return cli::gcnew<IsolatedStorageFile>(this->_scope, this->_storages->at(this->_pos));
    }
    
}}}
namespace System { namespace IO { namespace IsolatedStorage {
    
    
    void IsolatedStorageFileStream::constructor(System::String* path, System::IO::FileMode mode) {
    }
    
    void IsolatedStorageFileStream::constructor(System::String* path, System::IO::FileMode mode, System::IO::FileAccess access) {
    }
    
    void IsolatedStorageFileStream::constructor(System::String* path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share) {
    }
    
    void IsolatedStorageFileStream::constructor(System::String* path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int32_t bufferSize) {
    }
    
    void IsolatedStorageFileStream::constructor(System::String* path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int32_t bufferSize, IsolatedStorageFile* isf) {
    }
    
    void IsolatedStorageFileStream::constructor(System::String* path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, IsolatedStorageFile* isf) {
    }
    
    void IsolatedStorageFileStream::constructor(System::String* path, System::IO::FileMode mode, System::IO::FileAccess access, IsolatedStorageFile* isf) {
    }
    
    void IsolatedStorageFileStream::constructor(System::String* path, System::IO::FileMode mode, IsolatedStorageFile* isf) {
    }
    
    System::String* IsolatedStorageFileStream::CreateIsolatedPath(IsolatedStorageFile* isf, System::String* path, System::IO::FileMode mode) {
        if((path ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("path"));
        }
        if(!(System::Enum::IsDefined(cli::typeof<System::Type>::info, cli::box(mode)))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("mode"));
        }
        if((isf ==  nullptr)) 
        {
            System::Diagnostics::StackFrame *sf = cli::gcnew<System::Diagnostics::StackFrame>(3);
            isf = IsolatedStorageFile::GetStore2((IsolatedStorageScope)7L, IsolatedStorageFile::GetDomainIdentityFromEvidence(System::AppDomain::get_CurrentDomain()->get_Evidence()), IsolatedStorageFile::GetAssemblyIdentityFromEvidence(sf->GetMethod_c520bf4862e6a796()->get_ReflectedType_bf4971c0f442b9dc()->get_Assembly_3aae0acbf2a6d696()->UnprotectedGetEvidence()));
        }
        if(isf->get_IsDisposed()) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("IsolatedStorageFile"));
        }
        if(isf->get_IsClosed()) 
        {
            throw cli::gcnew<System::InvalidOperationException>(_T("Storage needs to be open for this operation."));
        }
        System::IO::FileInfo *fi = cli::gcnew<System::IO::FileInfo>(isf->get_Root());
        if(!(fi->get_Directory()->get_Exists_44ccb569427c51d7())) 
        {
            fi->get_Directory()->Create();
        }
        if(System::IO::Path::IsPathRooted(path)) 
        {
            System::String *root = System::IO::Path::GetPathRoot(path);
            path = path->Remove2(0, root->get_Length());
        }
        System::String *file = System::IO::Path::Combine(isf->get_Root(), path);
        System::String *full = System::IO::Path::GetFullPath(file);
        full = System::IO::Path::GetFullPath(file);
        if(!(full->StartsWith(isf->get_Root()))) 
        {
            throw cli::gcnew<IsolatedStorageException>();
        }
        fi = cli::gcnew<System::IO::FileInfo>(file);
        if(!(fi->get_Directory()->get_Exists_44ccb569427c51d7())) 
        {
            System::String *msg = Locale::GetText(_T("Could not find a part of the path \"{0}\"."));
            throw cli::gcnew<System::IO::DirectoryNotFoundException>(System::String::Format2(msg, path));
        }
        return file;
    }
    
    System::IAsyncResult* IsolatedStorageFileStream::BeginRead_783f127b729b2f0a(cli::array<unsigned char>* buffer, int32_t offset, int32_t numBytes, System::AsyncCallback* userCallback, System::Object* stateObject) {
        return System::IO::FileStream::BeginRead_783f127b729b2f0a(buffer, offset, numBytes, userCallback, stateObject);
    }
    
    System::IAsyncResult* IsolatedStorageFileStream::BeginWrite_85b245acef3a8d4a(cli::array<unsigned char>* buffer, int32_t offset, int32_t numBytes, System::AsyncCallback* userCallback, System::Object* stateObject) {
        return System::IO::FileStream::BeginWrite_85b245acef3a8d4a(buffer, offset, numBytes, userCallback, stateObject);
    }
    
    int32_t IsolatedStorageFileStream::EndRead_fffd36c36fbcca5b(System::IAsyncResult* asyncResult) {
        return System::IO::FileStream::EndRead_fffd36c36fbcca5b(asyncResult);
    }
    
    void IsolatedStorageFileStream::EndWrite_4a9b8c2a22f9c4e3(System::IAsyncResult* asyncResult) {
        System::IO::FileStream::EndWrite_4a9b8c2a22f9c4e3(asyncResult);
    }
    
    void IsolatedStorageFileStream::Flush_132821400030c993() {
        System::IO::FileStream::Flush_132821400030c993();
    }
    
    void IsolatedStorageFileStream::Flush_45c7245c20dbb092(bool flushToDisk) {
        System::IO::FileStream::Flush_45c7245c20dbb092(flushToDisk);
    }
    
    int32_t IsolatedStorageFileStream::Read_c0d6dde3943b413e(cli::array<unsigned char>* buffer, int32_t offset, int32_t count) {
        return System::IO::FileStream::Read_c0d6dde3943b413e(buffer, offset, count);
    }
    
    int32_t IsolatedStorageFileStream::ReadByte_61a294e42318f99() {
        return System::IO::FileStream::ReadByte_61a294e42318f99();
    }
    
    int64_t IsolatedStorageFileStream::Seek_df5b3eadfe9adf31(int64_t offset, System::IO::SeekOrigin origin) {
        return System::IO::FileStream::Seek_df5b3eadfe9adf31(offset, origin);
    }
    
    void IsolatedStorageFileStream::SetLength_18d421048f3d4df5(int64_t value) {
        System::IO::FileStream::SetLength_18d421048f3d4df5(value);
    }
    
    void IsolatedStorageFileStream::Write_1f8a1dbe71b0eb89(cli::array<unsigned char>* buffer, int32_t offset, int32_t count) {
        System::IO::FileStream::Write_1f8a1dbe71b0eb89(buffer, offset, count);
    }
    
    void IsolatedStorageFileStream::WriteByte_4404d6329af3b6d5(unsigned char value) {
        System::IO::FileStream::WriteByte_4404d6329af3b6d5(value);
    }
    
    void IsolatedStorageFileStream::Dispose_b215be19126499b0(bool disposing) {
        System::IO::FileStream::Dispose_b215be19126499b0(disposing);
    }
    
    bool IsolatedStorageFileStream::get_CanRead_50a10d564be8aaa2() {
        return System::IO::FileStream::get_CanRead_50a10d564be8aaa2();
    }
    
    bool IsolatedStorageFileStream::get_CanSeek_8c8861ce02c6bdeb() {
        return System::IO::FileStream::get_CanSeek_8c8861ce02c6bdeb();
    }
    
    bool IsolatedStorageFileStream::get_CanWrite_c8955eadfc77124c() {
        return System::IO::FileStream::get_CanWrite_c8955eadfc77124c();
    }
    
    Microsoft::Win32::SafeHandles::SafeFileHandle* IsolatedStorageFileStream::get_SafeFileHandle_b919aff741b12494() {
        throw cli::gcnew<IsolatedStorageException>(Locale::GetText(_T("Information is restricted")));
    }
    
    void* IsolatedStorageFileStream::get_Handle_74aea2418d83b5a0() {
        throw cli::gcnew<IsolatedStorageException>(Locale::GetText(_T("Information is restricted")));
    }
    
    bool IsolatedStorageFileStream::get_IsAsync_f1144e989e0e63e() {
        return System::IO::FileStream::get_IsAsync_f1144e989e0e63e();
    }
    
    int64_t IsolatedStorageFileStream::get_Length_ddb8b0d061db5350() {
        return System::IO::FileStream::get_Length_ddb8b0d061db5350();
    }
    
    int64_t IsolatedStorageFileStream::get_Position_5e75d5c458401f13() {
        return System::IO::FileStream::get_Position_5e75d5c458401f13();
    }
    
    int64_t IsolatedStorageFileStream::set_Position_cfe1def757785ad(int64_t value) {
        System::IO::FileStream::set_Position_cfe1def757785ad(value);
        return get_Position_5e75d5c458401f13();
    }
    
}}}
namespace System { namespace IO { namespace IsolatedStorage {
    
    
    void IsolatedStorageSecurityState::constructor() {
    }
    
    void IsolatedStorageSecurityState::EnsureState_61529bd496462ad() {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    IsolatedStorageSecurityOptions IsolatedStorageSecurityState::get_Options() {
        return IsolatedStorageSecurityOptions::IncreaseQuotaForApplication;
    }
    
    int64_t IsolatedStorageSecurityState::get_Quota() {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    int64_t IsolatedStorageSecurityState::set_Quota(int64_t value) {
        return get_Quota();
    }
    
    int64_t IsolatedStorageSecurityState::get_UsedSize() {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
}}}
namespace System { namespace Reflection {
    
    
    void AmbiguousMatchException::constructor() {
    }
    
    void AmbiguousMatchException::constructor(System::String* message) {
    }
    
    void AmbiguousMatchException::constructor(System::String* message, System::Exception* inner) {
    }
    
    void AmbiguousMatchException::constructor(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
    }
    
}}
namespace System { namespace Reflection {
    
    
    void ResolveEventHolder::constructor() {
    }
    
    void ResolveEventHolder::add_ModuleResolve(ModuleResolveEventHandler* value) {
      // TODO: "Implement automatic events!"
    }
    
    void ResolveEventHolder::remove_ModuleResolve(ModuleResolveEventHandler* value) {
      // TODO: "Implement automatic events!"
    }
    
}}
namespace System { namespace Reflection {
    
    
    void ResourceCloseHandler::constructor(Module* module) {
        this->module = module;
    }
    
    void ResourceCloseHandler::OnClose(System::Object* sender, System::EventArgs* e) {
        this->module = nullptr;
    }
    
}}
namespace System { namespace Reflection {
    
    
    void Assembly::constructor() {
        this->resolve_event_holder = cli::gcnew<ResolveEventHolder>();
    }
    
    System::String* Assembly::get_code_base(bool escaped) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    System::String* Assembly::get_fullname() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    System::String* Assembly::get_location() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    System::String* Assembly::InternalImageRuntimeVersion() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    System::String* Assembly::GetCodeBase(bool escaped) {
        System::String *cb = get_code_base(escaped);
        if(System::Security::SecurityManager::get_SecurityEnabled()) 
        {
            if((System::String::Compare6(_T("FILE://"), 0, cb, 0, 7, true, System::Globalization::CultureInfo::get_InvariantCulture()) ==  0)) 
            {
                System::String *file = cb->Substring(7);
                cli::gcnew<System::Security::Permissions::FileIOPermission>(System::Security::Permissions::FileIOPermissionAccess::PathDiscovery, file)->Demand();
            }
        }
        return cb;
    }
    
    System::Security::Policy::Evidence* Assembly::UnprotectedGetEvidence() {
        if((this->_evidence ==  nullptr)) 
        {
            {
                cli::lock_guard{this};
                this->_evidence = System::Security::Policy::Evidence::GetDefaultHostEvidence(this);
            }
        }
        return this->_evidence;
    }
    
    bool Assembly::get_global_assembly_cache() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Assembly::GetObjectData_6b61218d0e15f122(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        if((info ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("info"));
        }
        System::UnitySerializationHolder::GetAssemblyData(this, info, context);
    }
    
    bool Assembly::IsDefined_42f87feac494b032(System::Type* attributeType, bool inherit) {
        return System::MonoCustomAttrs::IsDefined(this, attributeType, inherit);
    }
    
    cli::array<System::Object*>* Assembly::GetCustomAttributes_887544480e7ebe63(bool inherit) {
        return System::MonoCustomAttrs::GetCustomAttributes2(this, inherit);
    }
    
    cli::array<System::Object*>* Assembly::GetCustomAttributes_30a143c7dfd48919(System::Type* attributeType, bool inherit) {
        return System::MonoCustomAttrs::GetCustomAttributes(this, attributeType, inherit);
    }
    
    System::Object* Assembly::GetFilesInternal(System::String* name, bool getResourceModules) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    cli::array<System::IO::FileStream*>* Assembly::GetFiles_4f893757e6a7c4b6() {
        return GetFiles_4b160752c34b70d5(false);
    }
    
    cli::array<System::IO::FileStream*>* Assembly::GetFiles_4b160752c34b70d5(bool getResourceModules) {
        cli::array<System::String*> *names = cli::cast<cli::array<System::String*>*>(GetFilesInternal(nullptr, getResourceModules));
        if((names ==  nullptr)) 
        {
            return (new cli::array<System::IO::FileStream*>(0));
        }
        System::String *location = this->get_Location_3a7779d7eb72fa50();
        cli::array<System::IO::FileStream*> *res;
        if(System::String::op_Inequality(location, System::String::Empty)) 
        {
            res = (new cli::array<System::IO::FileStream*>((names->get_Length() + 1)));
            res->at(0) = cli::gcnew<System::IO::FileStream>(location, System::IO::FileMode::Open, System::IO::FileAccess::Read);
            for(int32_t i = 0; (i < names->get_Length()); ++i) {
                res->at((i + 1)) = cli::gcnew<System::IO::FileStream>(names->at(i), System::IO::FileMode::Open, System::IO::FileAccess::Read);
            }
        }
         else 
        {
            res = (new cli::array<System::IO::FileStream*>(names->get_Length()));
            for(int32_t i = 0; (i < names->get_Length()); ++i) {
                res->at(i) = cli::gcnew<System::IO::FileStream>(names->at(i), System::IO::FileMode::Open, System::IO::FileAccess::Read);
            }
        }
        return res;
    }
    
    System::IO::FileStream* Assembly::GetFile_321baf5b87b86022(System::String* name) {
        if((name ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(nullptr, _T("Name cannot be null."));
        }
        if((name->get_Length() ==  0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Empty name is not valid"));
        }
        System::String *filename = cli::cast<System::String*>(GetFilesInternal(name, true));
        if((filename != nullptr)) 
        {
            return cli::gcnew<System::IO::FileStream>(filename, System::IO::FileMode::Open, System::IO::FileAccess::Read);
        }
         else 
        {
            return nullptr;
        }
    }
    
    void* Assembly::GetManifestResourceInternal(System::String* name, int32_t size, Module* module) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    System::IO::Stream* Assembly::GetManifestResourceStream_b395b331908084e(System::String* name) {
        if((name ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("name"));
        }
        if((name->get_Length() ==  0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("String cannot have zero length."), _T("name"));
        }
        ManifestResourceInfo *info = GetManifestResourceInfo_2cc36efdd5a68bdc(name);
        if((info ==  nullptr)) 
        {
            Assembly *a = System::AppDomain::get_CurrentDomain()->DoResourceResolve(name, this);
            if((op_Inequality(a, nullptr) && op_Inequality(a, this))) 
            {
                return a->GetManifestResourceStream_b395b331908084e(name);
            }
             else 
            {
                return nullptr;
            }
        }
        if(op_Inequality(info->get_ReferencedAssembly_2b9a0b794797dde5(), nullptr)) 
        {
            return info->get_ReferencedAssembly_2b9a0b794797dde5()->GetManifestResourceStream_b395b331908084e(name);
        }
        if(((info->get_FileName_7c119b8b7cfba9b7() != nullptr) && ((int32_t)(info->get_ResourceLocation_4683f601004b7d5c()) ==  0))) 
        {
            if(this->fromByteArray) 
            {
                throw cli::gcnew<System::IO::FileNotFoundException>(info->get_FileName_7c119b8b7cfba9b7());
            }
            System::String *location = System::IO::Path::GetDirectoryName(this->get_Location_3a7779d7eb72fa50());
            System::String *filename = System::IO::Path::Combine(location, info->get_FileName_7c119b8b7cfba9b7());
            return cli::gcnew<System::IO::FileStream>(filename, System::IO::FileMode::Open, System::IO::FileAccess::Read);
        }
        int32_t size;
        Module *module;
        void *data = GetManifestResourceInternal(name, size, module);
        if(::System::IntPtr::op_Equality(data, (void*)0)) 
        {
            return nullptr;
        }
         else 
        {
            System::IO::UnmanagedMemoryStream *stream;
            stream = cli::gcnew<System::IO::UnmanagedMemoryStream>((unsigned char*)((void*)data), (int64_t)(size));
            stream->add_Closed(cli::bind(cli::gcnew<ResourceCloseHandler>(module), &ResourceCloseHandler::OnClose));
            return stream;
        }
    }
    
    System::IO::Stream* Assembly::GetManifestResourceStream_6ad572412eedcffd(System::Type* type, System::String* name) {
        System::String *ns;
        if(System::Type::op_Inequality2(type, nullptr)) 
        {
            ns = type->get_Namespace_cb4ed37007083e7f();
        }
         else 
        {
            if((name ==  nullptr)) 
            {
                throw cli::gcnew<System::ArgumentNullException>(_T("type"));
            }
            ns = nullptr;
        }
        if(((ns ==  nullptr) || (ns->get_Length() ==  0))) 
        {
            return GetManifestResourceStream_b395b331908084e(name);
        }
         else 
        {
            return GetManifestResourceStream_b395b331908084e(cli::concat(ns, _T(".")));
        }
    }
    
    cli::array<System::Type*>* Assembly::GetTypes_7d5d1df2c0939ee2(bool exportedOnly) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    cli::array<System::Type*>* Assembly::GetTypes_596eee17684f649() {
        return GetTypes_7d5d1df2c0939ee2(false);
    }
    
    cli::array<System::Type*>* Assembly::GetExportedTypes_4dc21035aef13039() {
        return GetTypes_7d5d1df2c0939ee2(true);
    }
    
    System::Type* Assembly::GetType_cce33183e0cab1ba(System::String* name, bool throwOnError) {
        return GetType_30e9b2dcc4956479(name, throwOnError, false);
    }
    
    System::Type* Assembly::GetType_99cbfcc4e094eb08(System::String* name) {
        return GetType_30e9b2dcc4956479(name, false, false);
    }
    
    System::Type* Assembly::InternalGetType(Module* module, System::String* name, bool throwOnError, bool ignoreCase) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Assembly::InternalGetAssemblyName(System::String* assemblyFile, AssemblyName* aname) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Assembly::FillName(Assembly* ass, AssemblyName* aname) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    AssemblyName* Assembly::GetName_7bcd94721bb29265(bool copiedName) {
        if(System::Security::SecurityManager::get_SecurityEnabled()) 
        {
            GetCodeBase(true);
        }
        return UnprotectedGetName_b11b135b2412c023();
    }
    
    AssemblyName* Assembly::GetName_7088a38b93d0dcc5() {
        return GetName_7bcd94721bb29265(false);
    }
    
    AssemblyName* Assembly::UnprotectedGetName_b11b135b2412c023() {
        AssemblyName *aname = cli::gcnew<AssemblyName>();
        FillName(this, aname);
        return aname;
    }
    
    System::String* Assembly::ToString_1636a0751cb9ac11() {
        if((this->assemblyName != nullptr)) 
        {
            return this->assemblyName;
        }
        this->assemblyName = get_fullname();
        return this->assemblyName;
    }
    
    System::String* Assembly::CreateQualifiedName(System::String* assemblyName, System::String* typeName) {
        return cli::concat(typeName, _T(", "));
    }
    
    Assembly* Assembly::GetAssembly(System::Type* type) {
        if(System::Type::op_Inequality2(type, nullptr)) 
        {
            return type->get_Assembly_3aae0acbf2a6d696();
        }
        throw cli::gcnew<System::ArgumentNullException>(_T("type"));
    }
    
    Assembly* Assembly::GetEntryAssembly() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    Assembly* Assembly::GetSatelliteAssemblyNoThrow(System::Globalization::CultureInfo* culture, System::Version* version) {
        return GetSatelliteAssembly(culture, version, false);
    }
    
    Assembly* Assembly::GetSatelliteAssembly(System::Globalization::CultureInfo* culture, System::Version* version, bool throwOnError) {
        if((culture ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("culture"));
        }
        AssemblyName *aname = GetName_7bcd94721bb29265(true);
        if(System::Version::op_Inequality(version, nullptr)) 
        {
            aname->set_Version(version);
        }
        aname->set_CultureInfo(culture);
        aname->set_Name(cli::concat(aname->get_Name(), _T(".resources")));
        Assembly *assembly;
        try {
            assembly = System::AppDomain::get_CurrentDomain()->LoadSatellite(aname, false);
            if(op_Inequality(assembly, nullptr)) 
            {
                return assembly;
            }
        }
        catch(System::IO::FileNotFoundException*) {
            assembly = nullptr;
        }
        System::String *location = System::IO::Path::GetDirectoryName(this->get_Location_3a7779d7eb72fa50());
        System::String *fullName = System::IO::Path::Combine(location, System::IO::Path::Combine(culture->get_Name_7a59bd1b86cfacd3(), cli::concat(aname->get_Name(), _T(".dll"))));
        if((!(throwOnError) && !(System::IO::File::Exists(fullName)))) 
        {
            return nullptr;
        }
        return LoadFrom2(fullName);
    }
    
    Assembly* Assembly::LoadFrom(System::String* assemblyFile, bool refonly) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    Assembly* Assembly::LoadFrom2(System::String* assemblyFile) {
        return LoadFrom(assemblyFile, false);
    }
    
    Assembly* Assembly::LoadFrom3(System::String* assemblyFile, System::Security::Policy::Evidence* securityEvidence) {
        Assembly *a = LoadFrom(assemblyFile, false);
        if((op_Inequality(a, nullptr) && (securityEvidence != nullptr))) 
        {
            a->get_Evidence_4f4a60b88ffe9545()->Merge(securityEvidence);
        }
        return a;
    }
    
    Assembly* Assembly::LoadFrom4(System::String* assemblyFile, System::Security::Policy::Evidence* securityEvidence, cli::array<unsigned char>* hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    Assembly* Assembly::LoadFrom5(System::String* assemblyFile, cli::array<unsigned char>* hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    Assembly* Assembly::UnsafeLoadFrom(System::String* assemblyFile) {
        return LoadFrom2(assemblyFile);
    }
    
    Assembly* Assembly::LoadFile(System::String* path, System::Security::Policy::Evidence* securityEvidence) {
        if((path ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("path"));
        }
        if(System::String::op_Equality(path, System::String::Empty)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Path can\'t be empty"), _T("path"));
        }
        return LoadFrom3(path, securityEvidence);
    }
    
    Assembly* Assembly::LoadFile2(System::String* path) {
        return LoadFile(path, nullptr);
    }
    
    Assembly* Assembly::Load(System::String* assemblyString) {
        return System::AppDomain::get_CurrentDomain()->Load3(assemblyString);
    }
    
    Assembly* Assembly::Load2(System::String* assemblyString, System::Security::Policy::Evidence* assemblySecurity) {
        return System::AppDomain::get_CurrentDomain()->Load4(assemblyString, assemblySecurity);
    }
    
    Assembly* Assembly::Load3(AssemblyName* assemblyRef) {
        return System::AppDomain::get_CurrentDomain()->Load(assemblyRef);
    }
    
    Assembly* Assembly::Load4(AssemblyName* assemblyRef, System::Security::Policy::Evidence* assemblySecurity) {
        return System::AppDomain::get_CurrentDomain()->Load2(assemblyRef, assemblySecurity);
    }
    
    Assembly* Assembly::Load5(cli::array<unsigned char>* rawAssembly) {
        return System::AppDomain::get_CurrentDomain()->Load6(rawAssembly);
    }
    
    Assembly* Assembly::Load6(cli::array<unsigned char>* rawAssembly, cli::array<unsigned char>* rawSymbolStore) {
        return System::AppDomain::get_CurrentDomain()->Load7(rawAssembly, rawSymbolStore);
    }
    
    Assembly* Assembly::Load7(cli::array<unsigned char>* rawAssembly, cli::array<unsigned char>* rawSymbolStore, System::Security::Policy::Evidence* securityEvidence) {
        return System::AppDomain::get_CurrentDomain()->Load8(rawAssembly, rawSymbolStore, securityEvidence);
    }
    
    Assembly* Assembly::Load8(cli::array<unsigned char>* rawAssembly, cli::array<unsigned char>* rawSymbolStore, System::Security::SecurityContextSource securityContextSource) {
        return System::AppDomain::get_CurrentDomain()->Load7(rawAssembly, rawSymbolStore);
    }
    
    Assembly* Assembly::ReflectionOnlyLoad(cli::array<unsigned char>* rawAssembly) {
        return System::AppDomain::get_CurrentDomain()->Load9(rawAssembly, nullptr, nullptr, true);
    }
    
    Assembly* Assembly::ReflectionOnlyLoad2(System::String* assemblyString) {
        return System::AppDomain::get_CurrentDomain()->Load5(assemblyString, nullptr, true);
    }
    
    Assembly* Assembly::ReflectionOnlyLoadFrom(System::String* assemblyFile) {
        if((assemblyFile ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("assemblyFile"));
        }
        return LoadFrom(assemblyFile, true);
    }
    
    Assembly* Assembly::LoadWithPartialName(System::String* partialName) {
        return LoadWithPartialName2(partialName, nullptr);
    }
    
    Module* Assembly::LoadModule(System::String* moduleName, cli::array<unsigned char>* rawModule) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    Module* Assembly::LoadModule_87df81afaaa787f6(System::String* moduleName, cli::array<unsigned char>* rawModule, cli::array<unsigned char>* rawSymbolStore) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    Assembly* Assembly::load_with_partial_name(System::String* name, System::Security::Policy::Evidence* e) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    Assembly* Assembly::LoadWithPartialName2(System::String* partialName, System::Security::Policy::Evidence* securityEvidence) {
        return LoadWithPartialName3(partialName, securityEvidence, true);
    }
    
    Assembly* Assembly::LoadWithPartialName3(System::String* partialName, System::Security::Policy::Evidence* securityEvidence, bool oldBehavior) {
        if(!(oldBehavior)) 
        {
            throw cli::gcnew<System::NotImplementedException>();
        }
        if((partialName ==  nullptr)) 
        {
            throw cli::gcnew<System::NullReferenceException>();
        }
        return load_with_partial_name(partialName, securityEvidence);
    }
    
    System::Object* Assembly::CreateInstance(System::String* typeName) {
        return CreateInstance2(typeName, false);
    }
    
    System::Object* Assembly::CreateInstance2(System::String* typeName, bool ignoreCase) {
        System::Type *t = GetType_30e9b2dcc4956479(typeName, false, ignoreCase);
        if(System::Type::op_Equality2(t, nullptr)) 
        {
            return nullptr;
        }
        try {
            return System::Activator::CreateInstance8(t);
        }
        catch(System::InvalidOperationException*) {
            throw cli::gcnew<System::ArgumentException>(_T("It is illegal to invoke a method on a Type loaded via ReflectionOnly methods."));
        }
    }
    
    System::Object* Assembly::CreateInstance_d07d9768930f5848(System::String* typeName, bool ignoreCase, BindingFlags bindingAttr, Binder* binder, cli::array<System::Object*>* args, System::Globalization::CultureInfo* culture, cli::array<System::Object*>* activationAttributes) {
        System::Type *t = GetType_30e9b2dcc4956479(typeName, false, ignoreCase);
        if(System::Type::op_Equality2(t, nullptr)) 
        {
            return nullptr;
        }
        try {
            return System::Activator::CreateInstance12(t, bindingAttr, binder, args, culture, activationAttributes);
        }
        catch(System::InvalidOperationException*) {
            throw cli::gcnew<System::ArgumentException>(_T("It is illegal to invoke a method on a Type loaded via ReflectionOnly methods."));
        }
    }
    
    cli::array<Module*>* Assembly::GetLoadedModules() {
        return GetLoadedModules_db6b585bebc1ac2e(false);
    }
    
    cli::array<Module*>* Assembly::GetModules() {
        return GetModules_1ce70abfc6e0d050(false);
    }
    
    cli::array<Module*>* Assembly::GetModulesInternal_ea568dcc02539ffb() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    cli::array<System::String*>* Assembly::GetNamespaces() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    cli::array<System::String*>* Assembly::GetManifestResourceNames_d63b24d819c7a44d() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    Assembly* Assembly::GetExecutingAssembly() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    Assembly* Assembly::GetCallingAssembly() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    cli::array<AssemblyName*>* Assembly::GetReferencedAssemblies(Assembly* module) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool Assembly::GetManifestResourceInfoInternal(System::String* name, ManifestResourceInfo* info) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    ManifestResourceInfo* Assembly::GetManifestResourceInfo_2cc36efdd5a68bdc(System::String* resourceName) {
        if((resourceName ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("resourceName"));
        }
        if((resourceName->get_Length() ==  0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("String cannot have zero length."));
        }
        ManifestResourceInfo *result = cli::gcnew<ManifestResourceInfo>();
        bool found = GetManifestResourceInfoInternal(resourceName, result);
        if(found) 
        {
            return result;
        }
         else 
        {
            return nullptr;
        }
    }
    
    int32_t Assembly::MonoDebugger_GetMethodToken(MethodBase* method) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    Module* Assembly::GetManifestModule_e233b7576740b3d7() {
        return GetManifestModuleInternal();
    }
    
    Module* Assembly::GetManifestModuleInternal() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t Assembly::GetHashCode_6648aef0f235ee6c() {
        return System::Object::GetHashCode_6648aef0f235ee6c();
    }
    
    bool Assembly::Equals_ed975d2f4a7d193e(System::Object* o) {
        if((cli::cast<System::Object*>(this) ==  o)) 
        {
            return true;
        }
        if((o ==  nullptr)) 
        {
            return false;
        }
        Assembly *other = cli::cast<Assembly*>(o);
        return ::System::IntPtr::op_Equality(other->_mono_assembly, this->_mono_assembly);
    }
    
    void Assembly::Resolve() {
        {
            cli::lock_guard{this};
            LoadAssemblyPermissions();
            System::Security::Policy::Evidence *e = cli::gcnew<System::Security::Policy::Evidence>(UnprotectedGetEvidence());
            e->AddHost(cli::gcnew<System::Security::Policy::PermissionRequestEvidence>(this->_minimum, this->_optional, this->_refuse));
            this->_granted = System::Security::SecurityManager::ResolvePolicy3(e, this->_minimum, this->_optional, this->_refuse, this->_denied);
        }
    }
    
    bool Assembly::LoadPermissions(Assembly* a, void* minimum, int32_t minLength, void* optional, int32_t optLength, void* refused, int32_t refLength) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Assembly::LoadAssemblyPermissions() {
        void *minimum = (*::System::IntPtr::Zero), *optional = (*::System::IntPtr::Zero), *refused = (*::System::IntPtr::Zero);
        int32_t minLength = 0, optLength = 0, refLength = 0;
        if(LoadPermissions(this, minimum, minLength, optional, optLength, refused, refLength)) 
        {
            if((minLength > 0)) 
            {
                cli::array<unsigned char> *data = (new cli::array<unsigned char>(minLength));
                System::Runtime::InteropServices::Marshal::Copy9(minimum, data, 0, minLength);
                this->_minimum = System::Security::SecurityManager::Decode2(data);
            }
            if((optLength > 0)) 
            {
                cli::array<unsigned char> *data = (new cli::array<unsigned char>(optLength));
                System::Runtime::InteropServices::Marshal::Copy9(optional, data, 0, optLength);
                this->_optional = System::Security::SecurityManager::Decode2(data);
            }
            if((refLength > 0)) 
            {
                cli::array<unsigned char> *data = (new cli::array<unsigned char>(refLength));
                System::Runtime::InteropServices::Marshal::Copy9(refused, data, 0, refLength);
                this->_refuse = System::Security::SecurityManager::Decode2(data);
            }
        }
    }
    
    System::Exception* Assembly::CreateNIE() {
        return cli::gcnew<System::NotImplementedException>(_T("Derived classes must implement it"));
    }
    
    System::Collections::Generic::IList2<CustomAttributeData*>* Assembly::GetCustomAttributesData_b7ccb5bba4dfdbe4() {
        return CustomAttributeData::GetCustomAttributes(this);
    }
    
    System::Type* Assembly::GetType_30e9b2dcc4956479(System::String* name, bool throwOnError, bool ignoreCase) {
        throw CreateNIE();
    }
    
    Module* Assembly::GetModule_d3e09c815c6ebd46(System::String* name) {
        throw CreateNIE();
    }
    
    cli::array<AssemblyName*>* Assembly::GetReferencedAssemblies_c967ce8a0efd4c58() {
        throw CreateNIE();
    }
    
    cli::array<Module*>* Assembly::GetModules_1ce70abfc6e0d050(bool getResourceModules) {
        throw CreateNIE();
    }
    
    cli::array<Module*>* Assembly::GetLoadedModules_db6b585bebc1ac2e(bool getResourceModules) {
        throw CreateNIE();
    }
    
    Assembly* Assembly::GetSatelliteAssembly_995bfc41ec1f61b8(System::Globalization::CultureInfo* culture) {
        throw CreateNIE();
    }
    
    Assembly* Assembly::GetSatelliteAssembly_22d0b12d929a333c(System::Globalization::CultureInfo* culture, System::Version* version) {
        throw CreateNIE();
    }
    
    bool Assembly::op_Equality(Assembly* left, Assembly* right) {
        if((cli::cast<System::Object*>(left) ==  cli::cast<System::Object*>(right))) 
        {
            return true;
        }
        if(((cli::cast<System::Object*>(left) ==  nullptr) ^ (cli::cast<System::Object*>(right) ==  nullptr))) 
        {
            return false;
        }
        return left->Equals_ed975d2f4a7d193e(right);
    }
    
    bool Assembly::op_Inequality(Assembly* left, Assembly* right) {
        if((cli::cast<System::Object*>(left) ==  cli::cast<System::Object*>(right))) 
        {
            return false;
        }
        if(((cli::cast<System::Object*>(left) ==  nullptr) ^ (cli::cast<System::Object*>(right) ==  nullptr))) 
        {
            return true;
        }
        return !(left->Equals_ed975d2f4a7d193e(right));
    }
    
    System::String* Assembly::get_CodeBase_5e12949b795c9d90() {
        return GetCodeBase(false);
    }
    
    System::String* Assembly::get_EscapedCodeBase_2cc20f2402d62395() {
        return GetCodeBase(true);
    }
    
    System::String* Assembly::get_FullName_abd52da7f47cce07() {
        return System::Object::ToString_1636a0751cb9ac11();
    }
    
    MethodInfo* Assembly::get_EntryPoint_63c1ef73cc6df57c() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    System::Security::Policy::Evidence* Assembly::get_Evidence_4f4a60b88ffe9545() {
        return UnprotectedGetEvidence();
    }
    
    void Assembly::set_FromByteArray(bool value) {
        this->fromByteArray = value;
        return;
    }
    
    System::String* Assembly::get_Location_3a7779d7eb72fa50() {
        if(this->fromByteArray) 
        {
            return System::String::Empty;
        }
        System::String *loc = get_location();
        if((System::String::op_Inequality(loc, System::String::Empty) && System::Security::SecurityManager::get_SecurityEnabled())) 
        {
            cli::gcnew<System::Security::Permissions::FileIOPermission>(System::Security::Permissions::FileIOPermissionAccess::PathDiscovery, loc)->Demand();
        }
        return loc;
    }
    
    System::String* Assembly::get_ImageRuntimeVersion_3e077bddac126c9() {
        return InternalImageRuntimeVersion();
    }
    
    int64_t Assembly::get_HostContext_132922c4e02b90db() {
        return 0L;
    }
    
    bool Assembly::get_ReflectionOnly_b2af717d1dca672() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    System::Security::PermissionSet* Assembly::get_GrantedPermissionSet() {
        if((this->_granted ==  nullptr)) 
        {
            if((System::Security::SecurityManager::get_ResolvingPolicyLevel() != nullptr)) 
            {
                if(System::Security::SecurityManager::get_ResolvingPolicyLevel()->IsFullTrustAssembly(this)) 
                {
                    return System::Security::Policy::DefaultPolicies::get_FullTrust();
                }
                 else 
                {
                    return nullptr;
                }
            }
            Resolve();
        }
        return this->_granted;
    }
    
    System::Security::PermissionSet* Assembly::get_DeniedPermissionSet() {
        if((this->_granted ==  nullptr)) 
        {
            if((System::Security::SecurityManager::get_ResolvingPolicyLevel() != nullptr)) 
            {
                if(System::Security::SecurityManager::get_ResolvingPolicyLevel()->IsFullTrustAssembly(this)) 
                {
                    return nullptr;
                }
                 else 
                {
                    return System::Security::Policy::DefaultPolicies::get_FullTrust();
                }
            }
            Resolve();
        }
        return this->_denied;
    }
    
    System::Security::PermissionSet* Assembly::get_PermissionSet_8b84f92b47b6d274() {
        return this->get_GrantedPermissionSet();
    }
    
    System::Security::SecurityRuleSet Assembly::get_SecurityRuleSet_7821afdcdf547360() {
        throw CreateNIE();
    }
    
    bool Assembly::get_IsFullyTrusted() {
        return true;
    }
    
    Module* Assembly::get_ManifestModule_238a73903fb58278() {
        throw CreateNIE();
    }
    
    bool Assembly::get_GlobalAssemblyCache_db80d4f5ee2824e7() {
        throw CreateNIE();
    }
    
    bool Assembly::get_IsDynamic_a494841e91ae4bbb() {
        return false;
    }
    
    void Assembly::add_ModuleResolve(ModuleResolveEventHandler* value) {
        this->resolve_event_holder->add_ModuleResolve(value);
    }
    
    void Assembly::remove_ModuleResolve(ModuleResolveEventHandler* value) {
        this->resolve_event_holder->remove_ModuleResolve(value);
    }
    
}}
