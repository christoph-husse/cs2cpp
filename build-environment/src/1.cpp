#include "stdafx_mscorlib.hpp"

namespace System { namespace Threading {
    
    
    void _Register_c__AnonStorey1B::constructor() {
    }
    
    void _Register_c__AnonStorey1B::__m__14() {
         callback->Invoke(state);
    }
    
}}
namespace System { namespace Collections { namespace Concurrent { namespace Partitioners {
    
    
    void _GetOrderablePartitions_c__AnonStorey16::constructor() {
    }
    
    int32_t _GetOrderablePartitions_c__AnonStorey16::__m__B() {
        return (System::Threading::Interlocked::Increment(currentIndex) - 1);
    }
    
}}}}
namespace System { namespace Collections { namespace Concurrent { namespace Partitioners {
    
    
    void _GetOrderablePartitions_c__AnonStorey17::constructor() {
    }
    
    int64_t _GetOrderablePartitions_c__AnonStorey17::__m__C() {
        return (System::Threading::Interlocked::Increment2(currentIndex) - 1L);
    }
    
}}}}
namespace System { namespace IO {
    
    
    void _InternalGetFileSystemInfos_c__AnonStorey18::constructor() {
    }
    
    void _InternalGetFileSystemInfos_c__AnonStorey18::__m__D(System::String* dir) {
        infos->Add(cli::gcnew<DirectoryInfo>(dir));
    }
    
    void _InternalGetFileSystemInfos_c__AnonStorey18::__m__E(System::String* file) {
        infos->Add(cli::gcnew<FileInfo>(file));
    }
    
}}
namespace System { namespace Resources {
    
    
    void _ResourceValueAsStream_c__AnonStorey19::constructor() {
    }
    
    void _ResourceValueAsStream_c__AnonStorey19::__m__F(System::Object* o, System::EventArgs* e) {
        System::Runtime::InteropServices::Marshal::FreeHGlobal(ptr);
    }
    
}}
namespace System { namespace Runtime { namespace Serialization {
    
    
    void _RegisterObject_c__AnonStorey1A::constructor() {
    }
    
    void _RegisterObject_c__AnonStorey1A::__m__13(StreamingContext ctx) {
        sc->RaiseOnSerialized(obj, ctx);
    }
    
}}}
namespace System { namespace Threading {
    
    
    void _Wait_c__AnonStorey1C::constructor() {
    }
    
    bool _Wait_c__AnonStorey1C::__m__15() {
        return ((millisecondsTimeout >= 0) && (sw->get_ElapsedMilliseconds() > (int64_t)(millisecondsTimeout)));
    }
    
}}
namespace System { namespace Threading { namespace Tasks {
    
    
    void _For_c__AnonStorey1D::constructor() {
    }
    
    void _For_c__AnonStorey1D::__m__16(int32_t index, ParallelLoopState* state) {
         body->Invoke(index);
    }
    
}}}
namespace System { namespace Threading { namespace Tasks {
    
    
    void _For_c__AnonStorey1E::constructor() {
    }
    
    System::Object* _For_c__AnonStorey1E::__m__18(int32_t i, ParallelLoopState* s, System::Object* l) {
        body->Invoke(i, s);
        return nullptr;
    }
    
}}}
namespace System { namespace Threading { namespace Tasks {
    
    
    void _For_c__AnonStorey20::constructor() {
    }
    
    void _For_c__AnonStorey20::__m__1B(int64_t index, ParallelLoopState* state) {
         body->Invoke(index);
    }
    
}}}
namespace System { namespace Threading { namespace Tasks {
    
    
    void _For_c__AnonStorey21::constructor() {
    }
    
    System::Object* _For_c__AnonStorey21::__m__1D(int64_t i, ParallelLoopState* s, System::Object* l) {
        body->Invoke(i, s);
        return nullptr;
    }
    
}}}
namespace System { namespace Threading { namespace Tasks {
    
    
    void _SpawnBestNumber_c__AnonStorey30::constructor() {
    }
    
    void _SpawnBestNumber_c__AnonStorey30::__m__45() {
        action->Invoke();
        evt->Signal();
        if(((callback != nullptr) && evt->get_IsSet())) 
        {
            callback->Invoke();
        }
    }
    
}}}
namespace System { namespace Threading { namespace Tasks {
    
    
    void _FromAsync_c__AnonStorey35::constructor() {
    }
    
    System::Object* _FromAsync_c__AnonStorey35::__m__50(System::IAsyncResult* l) {
        endMethod->Invoke(asyncResult);
        return nullptr;
    }
    
}}}
namespace System { namespace Threading { namespace Tasks {
    
    
    void _FromAsync_c__AnonStorey36::constructor() {
    }
    
    System::Object* _FromAsync_c__AnonStorey36::__m__51(System::IAsyncResult* l) {
        endMethod->Invoke(l);
        return nullptr;
    }
    
}}}
namespace System {
}
namespace System {
    // Automatically generated method stub
    int32_t Boolean::CompareTo_ed9d39205b7812f0(Object* obj) {
        return CompareTo(obj);
    }
    
    // Automatically generated method stub
    int32_t Boolean::CompareTo_8a8b7d6c83beb422(bool value) {
        return CompareTo2(value);
    }
    
    // Automatically generated method stub
    bool Boolean::Equals_ea48fd0c13a733fe(bool obj) {
        return Equals2(obj);
    }
    
    // Automatically generated method stub
    TypeCode Boolean::GetTypeCode_701c52aeb2913904() {
        return GetTypeCode();
    }
    
    // Automatically generated method stub
    Object* Boolean::ToType_bf083accfb52550a(Type* targetType, IFormatProvider* provider) {
        return ToType(targetType, provider);
    }
    
    // Automatically generated method stub
    bool Boolean::ToBoolean_f2ed021e3648bfba(IFormatProvider* provider) {
        return ToBoolean(provider);
    }
    
    // Automatically generated method stub
    unsigned char Boolean::ToByte_ce47dcc06c443b11(IFormatProvider* provider) {
        return ToByte(provider);
    }
    
    // Automatically generated method stub
    char16_t Boolean::ToChar_12adc960e23347fe(IFormatProvider* provider) {
        return ToChar(provider);
    }
    
    // Automatically generated method stub
    DateTime Boolean::ToDateTime_86b01e143a29eff2(IFormatProvider* provider) {
        return ToDateTime(provider);
    }
    
    // Automatically generated method stub
    Decimal Boolean::ToDecimal_9c02fd5cdb5f6a0c(IFormatProvider* provider) {
        return ToDecimal(provider);
    }
    
    // Automatically generated method stub
    double Boolean::ToDouble_bf8714f37f489c82(IFormatProvider* provider) {
        return ToDouble(provider);
    }
    
    // Automatically generated method stub
    int16_t Boolean::ToInt16_5e1de9bafa245bf2(IFormatProvider* provider) {
        return ToInt16(provider);
    }
    
    // Automatically generated method stub
    int32_t Boolean::ToInt32_9e7108d4c09b7e42(IFormatProvider* provider) {
        return ToInt32(provider);
    }
    
    // Automatically generated method stub
    int64_t Boolean::ToInt64_9801f9765e5301f6(IFormatProvider* provider) {
        return ToInt64(provider);
    }
    
    // Automatically generated method stub
    signed char Boolean::ToSByte_e1f09487d48936db(IFormatProvider* provider) {
        return ToSByte(provider);
    }
    
    // Automatically generated method stub
    float Boolean::ToSingle_1cfd1ce472f9fad6(IFormatProvider* provider) {
        return ToSingle(provider);
    }
    
    // Automatically generated method stub
    String* Boolean::ToString_f121fe9e066b5628(IFormatProvider* provider) {
        return ToString3(provider);
    }
    
    // Automatically generated method stub
    uint16_t Boolean::ToUInt16_1e02ae7e2827241a(IFormatProvider* provider) {
        return ToUInt16(provider);
    }
    
    // Automatically generated method stub
    uint32_t Boolean::ToUInt32_9a72f29c26115cfd(IFormatProvider* provider) {
        return ToUInt32(provider);
    }
    
    // Automatically generated method stub
    uint64_t Boolean::ToUInt64_fe563f2a802e4265(IFormatProvider* provider) {
        return ToUInt64(provider);
    }
    
}
namespace System {
    // Automatically generated method stub
    int32_t Byte::CompareTo_ed9d39205b7812f0(Object* value) {
        return CompareTo(value);
    }
    
    // Automatically generated method stub
    int32_t Byte::CompareTo_8a8b7d6c83beb422(unsigned char value) {
        return CompareTo2(value);
    }
    
    // Automatically generated method stub
    bool Byte::Equals_ea48fd0c13a733fe(unsigned char obj) {
        return Equals2(obj);
    }
    
    // Automatically generated method stub
    String* Byte::ToString_f121fe9e066b5628(IFormatProvider* provider) {
        return ToString4(provider);
    }
    
    // Automatically generated method stub
    String* Byte::ToString_91ad8e2580555a25(String* format, IFormatProvider* provider) {
        return ToString5(format, provider);
    }
    
    // Automatically generated method stub
    TypeCode Byte::GetTypeCode_701c52aeb2913904() {
        return GetTypeCode();
    }
    
    // Automatically generated method stub
    Object* Byte::ToType_bf083accfb52550a(Type* targetType, IFormatProvider* provider) {
        return ToType(targetType, provider);
    }
    
    // Automatically generated method stub
    bool Byte::ToBoolean_f2ed021e3648bfba(IFormatProvider* provider) {
        return ToBoolean(provider);
    }
    
    // Automatically generated method stub
    unsigned char Byte::ToByte_ce47dcc06c443b11(IFormatProvider* provider) {
        return ToByte(provider);
    }
    
    // Automatically generated method stub
    char16_t Byte::ToChar_12adc960e23347fe(IFormatProvider* provider) {
        return ToChar(provider);
    }
    
    // Automatically generated method stub
    DateTime Byte::ToDateTime_86b01e143a29eff2(IFormatProvider* provider) {
        return ToDateTime(provider);
    }
    
    // Automatically generated method stub
    Decimal Byte::ToDecimal_9c02fd5cdb5f6a0c(IFormatProvider* provider) {
        return ToDecimal(provider);
    }
    
    // Automatically generated method stub
    double Byte::ToDouble_bf8714f37f489c82(IFormatProvider* provider) {
        return ToDouble(provider);
    }
    
    // Automatically generated method stub
    int16_t Byte::ToInt16_5e1de9bafa245bf2(IFormatProvider* provider) {
        return ToInt16(provider);
    }
    
    // Automatically generated method stub
    int32_t Byte::ToInt32_9e7108d4c09b7e42(IFormatProvider* provider) {
        return ToInt32(provider);
    }
    
    // Automatically generated method stub
    int64_t Byte::ToInt64_9801f9765e5301f6(IFormatProvider* provider) {
        return ToInt64(provider);
    }
    
    // Automatically generated method stub
    signed char Byte::ToSByte_e1f09487d48936db(IFormatProvider* provider) {
        return ToSByte(provider);
    }
    
    // Automatically generated method stub
    float Byte::ToSingle_1cfd1ce472f9fad6(IFormatProvider* provider) {
        return ToSingle(provider);
    }
    
    // Automatically generated method stub
    uint16_t Byte::ToUInt16_1e02ae7e2827241a(IFormatProvider* provider) {
        return ToUInt16(provider);
    }
    
    // Automatically generated method stub
    uint32_t Byte::ToUInt32_9a72f29c26115cfd(IFormatProvider* provider) {
        return ToUInt32(provider);
    }
    
    // Automatically generated method stub
    uint64_t Byte::ToUInt64_fe563f2a802e4265(IFormatProvider* provider) {
        return ToUInt64(provider);
    }
    
}
namespace System {
    // Automatically generated method stub
    int32_t Char::CompareTo_ed9d39205b7812f0(Object* value) {
        return CompareTo(value);
    }
    
    // Automatically generated method stub
    int32_t Char::CompareTo_8a8b7d6c83beb422(char16_t value) {
        return CompareTo2(value);
    }
    
    // Automatically generated method stub
    bool Char::Equals_ea48fd0c13a733fe(char16_t obj) {
        return Equals2(obj);
    }
    
    // Automatically generated method stub
    String* Char::ToString_f121fe9e066b5628(IFormatProvider* provider) {
        return ToString4(provider);
    }
    
    // Automatically generated method stub
    TypeCode Char::GetTypeCode_701c52aeb2913904() {
        return GetTypeCode();
    }
    
    // Automatically generated method stub
    Object* Char::ToType_bf083accfb52550a(Type* targetType, IFormatProvider* provider) {
        return ToType(targetType, provider);
    }
    
    // Automatically generated method stub
    bool Char::ToBoolean_f2ed021e3648bfba(IFormatProvider* provider) {
        return ToBoolean(provider);
    }
    
    // Automatically generated method stub
    unsigned char Char::ToByte_ce47dcc06c443b11(IFormatProvider* provider) {
        return ToByte(provider);
    }
    
    // Automatically generated method stub
    char16_t Char::ToChar_12adc960e23347fe(IFormatProvider* provider) {
        return ToChar(provider);
    }
    
    // Automatically generated method stub
    DateTime Char::ToDateTime_86b01e143a29eff2(IFormatProvider* provider) {
        return ToDateTime(provider);
    }
    
    // Automatically generated method stub
    Decimal Char::ToDecimal_9c02fd5cdb5f6a0c(IFormatProvider* provider) {
        return ToDecimal(provider);
    }
    
    // Automatically generated method stub
    double Char::ToDouble_bf8714f37f489c82(IFormatProvider* provider) {
        return ToDouble(provider);
    }
    
    // Automatically generated method stub
    int16_t Char::ToInt16_5e1de9bafa245bf2(IFormatProvider* provider) {
        return ToInt16(provider);
    }
    
    // Automatically generated method stub
    int32_t Char::ToInt32_9e7108d4c09b7e42(IFormatProvider* provider) {
        return ToInt32(provider);
    }
    
    // Automatically generated method stub
    int64_t Char::ToInt64_9801f9765e5301f6(IFormatProvider* provider) {
        return ToInt64(provider);
    }
    
    // Automatically generated method stub
    signed char Char::ToSByte_e1f09487d48936db(IFormatProvider* provider) {
        return ToSByte(provider);
    }
    
    // Automatically generated method stub
    float Char::ToSingle_1cfd1ce472f9fad6(IFormatProvider* provider) {
        return ToSingle(provider);
    }
    
    // Automatically generated method stub
    uint16_t Char::ToUInt16_1e02ae7e2827241a(IFormatProvider* provider) {
        return ToUInt16(provider);
    }
    
    // Automatically generated method stub
    uint32_t Char::ToUInt32_9a72f29c26115cfd(IFormatProvider* provider) {
        return ToUInt32(provider);
    }
    
    // Automatically generated method stub
    uint64_t Char::ToUInt64_fe563f2a802e4265(IFormatProvider* provider) {
        return ToUInt64(provider);
    }
    
}
namespace System {
    // Automatically generated method stub
    int32_t DateTime::CompareTo_ed9d39205b7812f0(Object* value) {
        return CompareTo(value);
    }
    
    // Automatically generated method stub
    int32_t DateTime::CompareTo_8a8b7d6c83beb422(DateTime value) {
        return CompareTo2(value);
    }
    
    // Automatically generated method stub
    bool DateTime::Equals_ea48fd0c13a733fe(DateTime value) {
        return Equals(value);
    }
    
    // Automatically generated method stub
    TypeCode DateTime::GetTypeCode_701c52aeb2913904() {
        return GetTypeCode();
    }
    
    // Automatically generated method stub
    String* DateTime::ToString_f121fe9e066b5628(IFormatProvider* provider) {
        return ToString3(provider);
    }
    
    // Automatically generated method stub
    String* DateTime::ToString_91ad8e2580555a25(String* format, IFormatProvider* provider) {
        return ToString5(format, provider);
    }
    
    // Automatically generated method stub
    bool DateTime::ToBoolean_f2ed021e3648bfba(IFormatProvider* provider) {
        return ToBoolean(provider);
    }
    
    // Automatically generated method stub
    unsigned char DateTime::ToByte_ce47dcc06c443b11(IFormatProvider* provider) {
        return ToByte(provider);
    }
    
    // Automatically generated method stub
    char16_t DateTime::ToChar_12adc960e23347fe(IFormatProvider* provider) {
        return ToChar(provider);
    }
    
    // Automatically generated method stub
    DateTime DateTime::ToDateTime_86b01e143a29eff2(IFormatProvider* provider) {
        return ToDateTime(provider);
    }
    
    // Automatically generated method stub
    Decimal DateTime::ToDecimal_9c02fd5cdb5f6a0c(IFormatProvider* provider) {
        return ToDecimal(provider);
    }
    
    // Automatically generated method stub
    double DateTime::ToDouble_bf8714f37f489c82(IFormatProvider* provider) {
        return ToDouble(provider);
    }
    
    // Automatically generated method stub
    int16_t DateTime::ToInt16_5e1de9bafa245bf2(IFormatProvider* provider) {
        return ToInt16(provider);
    }
    
    // Automatically generated method stub
    int32_t DateTime::ToInt32_9e7108d4c09b7e42(IFormatProvider* provider) {
        return ToInt32(provider);
    }
    
    // Automatically generated method stub
    int64_t DateTime::ToInt64_9801f9765e5301f6(IFormatProvider* provider) {
        return ToInt64(provider);
    }
    
    // Automatically generated method stub
    signed char DateTime::ToSByte_e1f09487d48936db(IFormatProvider* provider) {
        return ToSByte(provider);
    }
    
    // Automatically generated method stub
    float DateTime::ToSingle_1cfd1ce472f9fad6(IFormatProvider* provider) {
        return ToSingle(provider);
    }
    
    // Automatically generated method stub
    Object* DateTime::ToType_bf083accfb52550a(Type* targetType, IFormatProvider* provider) {
        return ToType(targetType, provider);
    }
    
    // Automatically generated method stub
    uint16_t DateTime::ToUInt16_1e02ae7e2827241a(IFormatProvider* provider) {
        return ToUInt16(provider);
    }
    
    // Automatically generated method stub
    uint32_t DateTime::ToUInt32_9a72f29c26115cfd(IFormatProvider* provider) {
        return ToUInt32(provider);
    }
    
    // Automatically generated method stub
    uint64_t DateTime::ToUInt64_fe563f2a802e4265(IFormatProvider* provider) {
        return ToUInt64(provider);
    }
    
    // Automatically generated method stub
    void DateTime::GetObjectData_11b895a112e04409(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        return GetObjectData(info, context);
    }
    
}
namespace System {
    // Automatically generated method stub
    int32_t DateTimeOffset::CompareTo_8a8b7d6c83beb422(DateTimeOffset other) {
        return CompareTo(other);
    }
    
    // Automatically generated method stub
    int32_t DateTimeOffset::CompareTo_ed9d39205b7812f0(Object* obj) {
        return CompareTo2(obj);
    }
    
    // Automatically generated method stub
    bool DateTimeOffset::Equals_ea48fd0c13a733fe(DateTimeOffset other) {
        return Equals(other);
    }
    
    // Automatically generated method stub
    void DateTimeOffset::GetObjectData_11b895a112e04409(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        return GetObjectData(info, context);
    }
    
    // Automatically generated method stub
    void DateTimeOffset::OnDeserialization_e9ecfecba8df9754(Object* sender) {
        return OnDeserialization(sender);
    }
    
    // Automatically generated method stub
    String* DateTimeOffset::ToString_91ad8e2580555a25(String* format, IFormatProvider* formatProvider) {
        return ToString5(format, formatProvider);
    }
    
}
namespace System {
    // Automatically generated method stub
    int32_t Decimal::CompareTo_ed9d39205b7812f0(Object* value) {
        return CompareTo(value);
    }
    
    // Automatically generated method stub
    int32_t Decimal::CompareTo_8a8b7d6c83beb422(Decimal value) {
        return CompareTo2(value);
    }
    
    // Automatically generated method stub
    bool Decimal::Equals_ea48fd0c13a733fe(Decimal value) {
        return Equals4(value);
    }
    
    // Automatically generated method stub
    TypeCode Decimal::GetTypeCode_701c52aeb2913904() {
        return GetTypeCode();
    }
    
    // Automatically generated method stub
    Object* Decimal::ToType_bf083accfb52550a(Type* targetType, IFormatProvider* provider) {
        return ToType(targetType, provider);
    }
    
    // Automatically generated method stub
    bool Decimal::ToBoolean_f2ed021e3648bfba(IFormatProvider* provider) {
        return ToBoolean(provider);
    }
    
    // Automatically generated method stub
    unsigned char Decimal::ToByte_ce47dcc06c443b11(IFormatProvider* provider) {
        return ToByte2(provider);
    }
    
    // Automatically generated method stub
    char16_t Decimal::ToChar_12adc960e23347fe(IFormatProvider* provider) {
        return ToChar(provider);
    }
    
    // Automatically generated method stub
    DateTime Decimal::ToDateTime_86b01e143a29eff2(IFormatProvider* provider) {
        return ToDateTime(provider);
    }
    
    // Automatically generated method stub
    Decimal Decimal::ToDecimal_9c02fd5cdb5f6a0c(IFormatProvider* provider) {
        return ToDecimal(provider);
    }
    
    // Automatically generated method stub
    double Decimal::ToDouble_bf8714f37f489c82(IFormatProvider* provider) {
        return ToDouble2(provider);
    }
    
    // Automatically generated method stub
    int16_t Decimal::ToInt16_5e1de9bafa245bf2(IFormatProvider* provider) {
        return ToInt162(provider);
    }
    
    // Automatically generated method stub
    int32_t Decimal::ToInt32_9e7108d4c09b7e42(IFormatProvider* provider) {
        return ToInt322(provider);
    }
    
    // Automatically generated method stub
    int64_t Decimal::ToInt64_9801f9765e5301f6(IFormatProvider* provider) {
        return ToInt642(provider);
    }
    
    // Automatically generated method stub
    signed char Decimal::ToSByte_e1f09487d48936db(IFormatProvider* provider) {
        return ToSByte2(provider);
    }
    
    // Automatically generated method stub
    float Decimal::ToSingle_1cfd1ce472f9fad6(IFormatProvider* provider) {
        return ToSingle2(provider);
    }
    
    // Automatically generated method stub
    uint16_t Decimal::ToUInt16_1e02ae7e2827241a(IFormatProvider* provider) {
        return ToUInt162(provider);
    }
    
    // Automatically generated method stub
    uint32_t Decimal::ToUInt32_9a72f29c26115cfd(IFormatProvider* provider) {
        return ToUInt322(provider);
    }
    
    // Automatically generated method stub
    uint64_t Decimal::ToUInt64_fe563f2a802e4265(IFormatProvider* provider) {
        return ToUInt642(provider);
    }
    
    // Automatically generated method stub
    String* Decimal::ToString_91ad8e2580555a25(String* format, IFormatProvider* provider) {
        return ToString(format, provider);
    }
    
    // Automatically generated method stub
    String* Decimal::ToString_f121fe9e066b5628(IFormatProvider* provider) {
        return ToString5(provider);
    }
    
    // Automatically generated method stub
    void Decimal::OnDeserialization_e9ecfecba8df9754(Object* sender) {
        return OnDeserialization(sender);
    }
    
}
namespace System {
    // Automatically generated method stub
    int32_t Double::CompareTo_ed9d39205b7812f0(Object* value) {
        return CompareTo(value);
    }
    
    // Automatically generated method stub
    int32_t Double::CompareTo_8a8b7d6c83beb422(double value) {
        return CompareTo2(value);
    }
    
    // Automatically generated method stub
    bool Double::Equals_ea48fd0c13a733fe(double obj) {
        return Equals2(obj);
    }
    
    // Automatically generated method stub
    String* Double::ToString_f121fe9e066b5628(IFormatProvider* provider) {
        return ToString3(provider);
    }
    
    // Automatically generated method stub
    String* Double::ToString_91ad8e2580555a25(String* format, IFormatProvider* provider) {
        return ToString5(format, provider);
    }
    
    // Automatically generated method stub
    TypeCode Double::GetTypeCode_701c52aeb2913904() {
        return GetTypeCode();
    }
    
    // Automatically generated method stub
    Object* Double::ToType_bf083accfb52550a(Type* targetType, IFormatProvider* provider) {
        return ToType(targetType, provider);
    }
    
    // Automatically generated method stub
    bool Double::ToBoolean_f2ed021e3648bfba(IFormatProvider* provider) {
        return ToBoolean(provider);
    }
    
    // Automatically generated method stub
    unsigned char Double::ToByte_ce47dcc06c443b11(IFormatProvider* provider) {
        return ToByte(provider);
    }
    
    // Automatically generated method stub
    char16_t Double::ToChar_12adc960e23347fe(IFormatProvider* provider) {
        return ToChar(provider);
    }
    
    // Automatically generated method stub
    DateTime Double::ToDateTime_86b01e143a29eff2(IFormatProvider* provider) {
        return ToDateTime(provider);
    }
    
    // Automatically generated method stub
    Decimal Double::ToDecimal_9c02fd5cdb5f6a0c(IFormatProvider* provider) {
        return ToDecimal(provider);
    }
    
    // Automatically generated method stub
    double Double::ToDouble_bf8714f37f489c82(IFormatProvider* provider) {
        return ToDouble(provider);
    }
    
    // Automatically generated method stub
    int16_t Double::ToInt16_5e1de9bafa245bf2(IFormatProvider* provider) {
        return ToInt16(provider);
    }
    
    // Automatically generated method stub
    int32_t Double::ToInt32_9e7108d4c09b7e42(IFormatProvider* provider) {
        return ToInt32(provider);
    }
    
    // Automatically generated method stub
    int64_t Double::ToInt64_9801f9765e5301f6(IFormatProvider* provider) {
        return ToInt64(provider);
    }
    
    // Automatically generated method stub
    signed char Double::ToSByte_e1f09487d48936db(IFormatProvider* provider) {
        return ToSByte(provider);
    }
    
    // Automatically generated method stub
    float Double::ToSingle_1cfd1ce472f9fad6(IFormatProvider* provider) {
        return ToSingle(provider);
    }
    
    // Automatically generated method stub
    uint16_t Double::ToUInt16_1e02ae7e2827241a(IFormatProvider* provider) {
        return ToUInt16(provider);
    }
    
    // Automatically generated method stub
    uint32_t Double::ToUInt32_9a72f29c26115cfd(IFormatProvider* provider) {
        return ToUInt32(provider);
    }
    
    // Automatically generated method stub
    uint64_t Double::ToUInt64_fe563f2a802e4265(IFormatProvider* provider) {
        return ToUInt64(provider);
    }
    
}
namespace System {
    // Automatically generated method stub
    int32_t Guid::CompareTo_ed9d39205b7812f0(Object* value) {
        return CompareTo(value);
    }
    
    // Automatically generated method stub
    int32_t Guid::CompareTo_8a8b7d6c83beb422(Guid value) {
        return CompareTo2(value);
    }
    
    // Automatically generated method stub
    bool Guid::Equals_ea48fd0c13a733fe(Guid g) {
        return Equals2(g);
    }
    
    // Automatically generated method stub
    String* Guid::ToString_91ad8e2580555a25(String* format, IFormatProvider* provider) {
        return ToString4(format, provider);
    }
    
}
namespace System {
    // Automatically generated method stub
    int32_t Int16::CompareTo_ed9d39205b7812f0(Object* value) {
        return CompareTo(value);
    }
    
    // Automatically generated method stub
    int32_t Int16::CompareTo_8a8b7d6c83beb422(int16_t value) {
        return CompareTo2(value);
    }
    
    // Automatically generated method stub
    bool Int16::Equals_ea48fd0c13a733fe(int16_t obj) {
        return Equals2(obj);
    }
    
    // Automatically generated method stub
    String* Int16::ToString_f121fe9e066b5628(IFormatProvider* provider) {
        return ToString3(provider);
    }
    
    // Automatically generated method stub
    String* Int16::ToString_91ad8e2580555a25(String* format, IFormatProvider* provider) {
        return ToString5(format, provider);
    }
    
    // Automatically generated method stub
    TypeCode Int16::GetTypeCode_701c52aeb2913904() {
        return GetTypeCode();
    }
    
    // Automatically generated method stub
    bool Int16::ToBoolean_f2ed021e3648bfba(IFormatProvider* provider) {
        return ToBoolean(provider);
    }
    
    // Automatically generated method stub
    unsigned char Int16::ToByte_ce47dcc06c443b11(IFormatProvider* provider) {
        return ToByte(provider);
    }
    
    // Automatically generated method stub
    char16_t Int16::ToChar_12adc960e23347fe(IFormatProvider* provider) {
        return ToChar(provider);
    }
    
    // Automatically generated method stub
    DateTime Int16::ToDateTime_86b01e143a29eff2(IFormatProvider* provider) {
        return ToDateTime(provider);
    }
    
    // Automatically generated method stub
    Decimal Int16::ToDecimal_9c02fd5cdb5f6a0c(IFormatProvider* provider) {
        return ToDecimal(provider);
    }
    
    // Automatically generated method stub
    double Int16::ToDouble_bf8714f37f489c82(IFormatProvider* provider) {
        return ToDouble(provider);
    }
    
    // Automatically generated method stub
    int16_t Int16::ToInt16_5e1de9bafa245bf2(IFormatProvider* provider) {
        return ToInt16(provider);
    }
    
    // Automatically generated method stub
    int32_t Int16::ToInt32_9e7108d4c09b7e42(IFormatProvider* provider) {
        return ToInt32(provider);
    }
    
    // Automatically generated method stub
    int64_t Int16::ToInt64_9801f9765e5301f6(IFormatProvider* provider) {
        return ToInt64(provider);
    }
    
    // Automatically generated method stub
    signed char Int16::ToSByte_e1f09487d48936db(IFormatProvider* provider) {
        return ToSByte(provider);
    }
    
    // Automatically generated method stub
    float Int16::ToSingle_1cfd1ce472f9fad6(IFormatProvider* provider) {
        return ToSingle(provider);
    }
    
    // Automatically generated method stub
    Object* Int16::ToType_bf083accfb52550a(Type* targetType, IFormatProvider* provider) {
        return ToType(targetType, provider);
    }
    
    // Automatically generated method stub
    uint16_t Int16::ToUInt16_1e02ae7e2827241a(IFormatProvider* provider) {
        return ToUInt16(provider);
    }
    
    // Automatically generated method stub
    uint32_t Int16::ToUInt32_9a72f29c26115cfd(IFormatProvider* provider) {
        return ToUInt32(provider);
    }
    
    // Automatically generated method stub
    uint64_t Int16::ToUInt64_fe563f2a802e4265(IFormatProvider* provider) {
        return ToUInt64(provider);
    }
    
}
namespace System {
    // Automatically generated method stub
    int32_t Int32::CompareTo_ed9d39205b7812f0(Object* value) {
        return CompareTo(value);
    }
    
    // Automatically generated method stub
    int32_t Int32::CompareTo_8a8b7d6c83beb422(int32_t value) {
        return CompareTo2(value);
    }
    
    // Automatically generated method stub
    bool Int32::Equals_ea48fd0c13a733fe(int32_t obj) {
        return Equals2(obj);
    }
    
    // Automatically generated method stub
    String* Int32::ToString_f121fe9e066b5628(IFormatProvider* provider) {
        return ToString3(provider);
    }
    
    // Automatically generated method stub
    String* Int32::ToString_91ad8e2580555a25(String* format, IFormatProvider* provider) {
        return ToString5(format, provider);
    }
    
    // Automatically generated method stub
    TypeCode Int32::GetTypeCode_701c52aeb2913904() {
        return GetTypeCode();
    }
    
    // Automatically generated method stub
    bool Int32::ToBoolean_f2ed021e3648bfba(IFormatProvider* provider) {
        return ToBoolean(provider);
    }
    
    // Automatically generated method stub
    unsigned char Int32::ToByte_ce47dcc06c443b11(IFormatProvider* provider) {
        return ToByte(provider);
    }
    
    // Automatically generated method stub
    char16_t Int32::ToChar_12adc960e23347fe(IFormatProvider* provider) {
        return ToChar(provider);
    }
    
    // Automatically generated method stub
    DateTime Int32::ToDateTime_86b01e143a29eff2(IFormatProvider* provider) {
        return ToDateTime(provider);
    }
    
    // Automatically generated method stub
    Decimal Int32::ToDecimal_9c02fd5cdb5f6a0c(IFormatProvider* provider) {
        return ToDecimal(provider);
    }
    
    // Automatically generated method stub
    double Int32::ToDouble_bf8714f37f489c82(IFormatProvider* provider) {
        return ToDouble(provider);
    }
    
    // Automatically generated method stub
    int16_t Int32::ToInt16_5e1de9bafa245bf2(IFormatProvider* provider) {
        return ToInt16(provider);
    }
    
    // Automatically generated method stub
    int32_t Int32::ToInt32_9e7108d4c09b7e42(IFormatProvider* provider) {
        return ToInt32(provider);
    }
    
    // Automatically generated method stub
    int64_t Int32::ToInt64_9801f9765e5301f6(IFormatProvider* provider) {
        return ToInt64(provider);
    }
    
    // Automatically generated method stub
    signed char Int32::ToSByte_e1f09487d48936db(IFormatProvider* provider) {
        return ToSByte(provider);
    }
    
    // Automatically generated method stub
    float Int32::ToSingle_1cfd1ce472f9fad6(IFormatProvider* provider) {
        return ToSingle(provider);
    }
    
    // Automatically generated method stub
    Object* Int32::ToType_bf083accfb52550a(Type* targetType, IFormatProvider* provider) {
        return ToType(targetType, provider);
    }
    
    // Automatically generated method stub
    uint16_t Int32::ToUInt16_1e02ae7e2827241a(IFormatProvider* provider) {
        return ToUInt16(provider);
    }
    
    // Automatically generated method stub
    uint32_t Int32::ToUInt32_9a72f29c26115cfd(IFormatProvider* provider) {
        return ToUInt32(provider);
    }
    
    // Automatically generated method stub
    uint64_t Int32::ToUInt64_fe563f2a802e4265(IFormatProvider* provider) {
        return ToUInt64(provider);
    }
    
}
namespace System {
    // Automatically generated method stub
    int32_t Int64::CompareTo_ed9d39205b7812f0(Object* value) {
        return CompareTo(value);
    }
    
    // Automatically generated method stub
    int32_t Int64::CompareTo_8a8b7d6c83beb422(int64_t value) {
        return CompareTo2(value);
    }
    
    // Automatically generated method stub
    bool Int64::Equals_ea48fd0c13a733fe(int64_t obj) {
        return Equals2(obj);
    }
    
    // Automatically generated method stub
    String* Int64::ToString_f121fe9e066b5628(IFormatProvider* provider) {
        return ToString3(provider);
    }
    
    // Automatically generated method stub
    String* Int64::ToString_91ad8e2580555a25(String* format, IFormatProvider* provider) {
        return ToString5(format, provider);
    }
    
    // Automatically generated method stub
    TypeCode Int64::GetTypeCode_701c52aeb2913904() {
        return GetTypeCode();
    }
    
    // Automatically generated method stub
    bool Int64::ToBoolean_f2ed021e3648bfba(IFormatProvider* provider) {
        return ToBoolean(provider);
    }
    
    // Automatically generated method stub
    unsigned char Int64::ToByte_ce47dcc06c443b11(IFormatProvider* provider) {
        return ToByte(provider);
    }
    
    // Automatically generated method stub
    char16_t Int64::ToChar_12adc960e23347fe(IFormatProvider* provider) {
        return ToChar(provider);
    }
    
    // Automatically generated method stub
    DateTime Int64::ToDateTime_86b01e143a29eff2(IFormatProvider* provider) {
        return ToDateTime(provider);
    }
    
    // Automatically generated method stub
    Decimal Int64::ToDecimal_9c02fd5cdb5f6a0c(IFormatProvider* provider) {
        return ToDecimal(provider);
    }
    
    // Automatically generated method stub
    double Int64::ToDouble_bf8714f37f489c82(IFormatProvider* provider) {
        return ToDouble(provider);
    }
    
    // Automatically generated method stub
    int16_t Int64::ToInt16_5e1de9bafa245bf2(IFormatProvider* provider) {
        return ToInt16(provider);
    }
    
    // Automatically generated method stub
    int32_t Int64::ToInt32_9e7108d4c09b7e42(IFormatProvider* provider) {
        return ToInt32(provider);
    }
    
    // Automatically generated method stub
    int64_t Int64::ToInt64_9801f9765e5301f6(IFormatProvider* provider) {
        return ToInt64(provider);
    }
    
    // Automatically generated method stub
    signed char Int64::ToSByte_e1f09487d48936db(IFormatProvider* provider) {
        return ToSByte(provider);
    }
    
    // Automatically generated method stub
    float Int64::ToSingle_1cfd1ce472f9fad6(IFormatProvider* provider) {
        return ToSingle(provider);
    }
    
    // Automatically generated method stub
    Object* Int64::ToType_bf083accfb52550a(Type* targetType, IFormatProvider* provider) {
        return ToType(targetType, provider);
    }
    
    // Automatically generated method stub
    uint16_t Int64::ToUInt16_1e02ae7e2827241a(IFormatProvider* provider) {
        return ToUInt16(provider);
    }
    
    // Automatically generated method stub
    uint32_t Int64::ToUInt32_9a72f29c26115cfd(IFormatProvider* provider) {
        return ToUInt32(provider);
    }
    
    // Automatically generated method stub
    uint64_t Int64::ToUInt64_fe563f2a802e4265(IFormatProvider* provider) {
        return ToUInt64(provider);
    }
    
}
namespace System {
    // Automatically generated method stub
    void ::System::IntPtr::GetObjectData_11b895a112e04409(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        return GetObjectData(info, context);
    }
    
}
namespace System {
    // Automatically generated method stub
    void RuntimeFieldHandle::GetObjectData_11b895a112e04409(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        return GetObjectData(info, context);
    }
    
}
namespace System {
    // Automatically generated method stub
    void RuntimeMethodHandle::GetObjectData_11b895a112e04409(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        return GetObjectData(info, context);
    }
    
}
namespace System {
    // Automatically generated method stub
    void RuntimeTypeHandle::GetObjectData_11b895a112e04409(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        return GetObjectData(info, context);
    }
    
}
namespace System {
    // Automatically generated method stub
    int32_t SByte::CompareTo_ed9d39205b7812f0(Object* obj) {
        return CompareTo(obj);
    }
    
    // Automatically generated method stub
    int32_t SByte::CompareTo_8a8b7d6c83beb422(signed char value) {
        return CompareTo2(value);
    }
    
    // Automatically generated method stub
    bool SByte::Equals_ea48fd0c13a733fe(signed char obj) {
        return Equals2(obj);
    }
    
    // Automatically generated method stub
    String* SByte::ToString_f121fe9e066b5628(IFormatProvider* provider) {
        return ToString3(provider);
    }
    
    // Automatically generated method stub
    String* SByte::ToString_91ad8e2580555a25(String* format, IFormatProvider* provider) {
        return ToString5(format, provider);
    }
    
    // Automatically generated method stub
    TypeCode SByte::GetTypeCode_701c52aeb2913904() {
        return GetTypeCode();
    }
    
    // Automatically generated method stub
    bool SByte::ToBoolean_f2ed021e3648bfba(IFormatProvider* provider) {
        return ToBoolean(provider);
    }
    
    // Automatically generated method stub
    unsigned char SByte::ToByte_ce47dcc06c443b11(IFormatProvider* provider) {
        return ToByte(provider);
    }
    
    // Automatically generated method stub
    char16_t SByte::ToChar_12adc960e23347fe(IFormatProvider* provider) {
        return ToChar(provider);
    }
    
    // Automatically generated method stub
    DateTime SByte::ToDateTime_86b01e143a29eff2(IFormatProvider* provider) {
        return ToDateTime(provider);
    }
    
    // Automatically generated method stub
    Decimal SByte::ToDecimal_9c02fd5cdb5f6a0c(IFormatProvider* provider) {
        return ToDecimal(provider);
    }
    
    // Automatically generated method stub
    double SByte::ToDouble_bf8714f37f489c82(IFormatProvider* provider) {
        return ToDouble(provider);
    }
    
    // Automatically generated method stub
    int16_t SByte::ToInt16_5e1de9bafa245bf2(IFormatProvider* provider) {
        return ToInt16(provider);
    }
    
    // Automatically generated method stub
    int32_t SByte::ToInt32_9e7108d4c09b7e42(IFormatProvider* provider) {
        return ToInt32(provider);
    }
    
    // Automatically generated method stub
    int64_t SByte::ToInt64_9801f9765e5301f6(IFormatProvider* provider) {
        return ToInt64(provider);
    }
    
    // Automatically generated method stub
    signed char SByte::ToSByte_e1f09487d48936db(IFormatProvider* provider) {
        return ToSByte(provider);
    }
    
    // Automatically generated method stub
    float SByte::ToSingle_1cfd1ce472f9fad6(IFormatProvider* provider) {
        return ToSingle(provider);
    }
    
    // Automatically generated method stub
    Object* SByte::ToType_bf083accfb52550a(Type* targetType, IFormatProvider* provider) {
        return ToType(targetType, provider);
    }
    
    // Automatically generated method stub
    uint16_t SByte::ToUInt16_1e02ae7e2827241a(IFormatProvider* provider) {
        return ToUInt16(provider);
    }
    
    // Automatically generated method stub
    uint32_t SByte::ToUInt32_9a72f29c26115cfd(IFormatProvider* provider) {
        return ToUInt32(provider);
    }
    
    // Automatically generated method stub
    uint64_t SByte::ToUInt64_fe563f2a802e4265(IFormatProvider* provider) {
        return ToUInt64(provider);
    }
    
}
namespace System {
    // Automatically generated method stub
    int32_t Single::CompareTo_ed9d39205b7812f0(Object* value) {
        return CompareTo(value);
    }
    
    // Automatically generated method stub
    int32_t Single::CompareTo_8a8b7d6c83beb422(float value) {
        return CompareTo2(value);
    }
    
    // Automatically generated method stub
    bool Single::Equals_ea48fd0c13a733fe(float obj) {
        return Equals2(obj);
    }
    
    // Automatically generated method stub
    String* Single::ToString_f121fe9e066b5628(IFormatProvider* provider) {
        return ToString3(provider);
    }
    
    // Automatically generated method stub
    String* Single::ToString_91ad8e2580555a25(String* format, IFormatProvider* provider) {
        return ToString5(format, provider);
    }
    
    // Automatically generated method stub
    TypeCode Single::GetTypeCode_701c52aeb2913904() {
        return GetTypeCode();
    }
    
    // Automatically generated method stub
    bool Single::ToBoolean_f2ed021e3648bfba(IFormatProvider* provider) {
        return ToBoolean(provider);
    }
    
    // Automatically generated method stub
    unsigned char Single::ToByte_ce47dcc06c443b11(IFormatProvider* provider) {
        return ToByte(provider);
    }
    
    // Automatically generated method stub
    char16_t Single::ToChar_12adc960e23347fe(IFormatProvider* provider) {
        return ToChar(provider);
    }
    
    // Automatically generated method stub
    DateTime Single::ToDateTime_86b01e143a29eff2(IFormatProvider* provider) {
        return ToDateTime(provider);
    }
    
    // Automatically generated method stub
    Decimal Single::ToDecimal_9c02fd5cdb5f6a0c(IFormatProvider* provider) {
        return ToDecimal(provider);
    }
    
    // Automatically generated method stub
    double Single::ToDouble_bf8714f37f489c82(IFormatProvider* provider) {
        return ToDouble(provider);
    }
    
    // Automatically generated method stub
    int16_t Single::ToInt16_5e1de9bafa245bf2(IFormatProvider* provider) {
        return ToInt16(provider);
    }
    
    // Automatically generated method stub
    int32_t Single::ToInt32_9e7108d4c09b7e42(IFormatProvider* provider) {
        return ToInt32(provider);
    }
    
    // Automatically generated method stub
    int64_t Single::ToInt64_9801f9765e5301f6(IFormatProvider* provider) {
        return ToInt64(provider);
    }
    
    // Automatically generated method stub
    signed char Single::ToSByte_e1f09487d48936db(IFormatProvider* provider) {
        return ToSByte(provider);
    }
    
    // Automatically generated method stub
    float Single::ToSingle_1cfd1ce472f9fad6(IFormatProvider* provider) {
        return ToSingle(provider);
    }
    
    // Automatically generated method stub
    Object* Single::ToType_bf083accfb52550a(Type* targetType, IFormatProvider* provider) {
        return ToType(targetType, provider);
    }
    
    // Automatically generated method stub
    uint16_t Single::ToUInt16_1e02ae7e2827241a(IFormatProvider* provider) {
        return ToUInt16(provider);
    }
    
    // Automatically generated method stub
    uint32_t Single::ToUInt32_9a72f29c26115cfd(IFormatProvider* provider) {
        return ToUInt32(provider);
    }
    
    // Automatically generated method stub
    uint64_t Single::ToUInt64_fe563f2a802e4265(IFormatProvider* provider) {
        return ToUInt64(provider);
    }
    
}
namespace System {
    // Automatically generated method stub
    int32_t TimeSpan::CompareTo_ed9d39205b7812f0(Object* value) {
        return CompareTo(value);
    }
    
    // Automatically generated method stub
    int32_t TimeSpan::CompareTo_8a8b7d6c83beb422(TimeSpan value) {
        return CompareTo2(value);
    }
    
    // Automatically generated method stub
    bool TimeSpan::Equals_ea48fd0c13a733fe(TimeSpan obj) {
        return Equals(obj);
    }
    
    // Automatically generated method stub
    String* TimeSpan::ToString_91ad8e2580555a25(String* format, IFormatProvider* formatProvider) {
        return ToString4(format, formatProvider);
    }
    
}
namespace System {
    // Automatically generated method stub
    int32_t UInt16::CompareTo_ed9d39205b7812f0(Object* value) {
        return CompareTo(value);
    }
    
    // Automatically generated method stub
    int32_t UInt16::CompareTo_8a8b7d6c83beb422(uint16_t value) {
        return CompareTo2(value);
    }
    
    // Automatically generated method stub
    bool UInt16::Equals_ea48fd0c13a733fe(uint16_t obj) {
        return Equals2(obj);
    }
    
    // Automatically generated method stub
    String* UInt16::ToString_f121fe9e066b5628(IFormatProvider* provider) {
        return ToString3(provider);
    }
    
    // Automatically generated method stub
    String* UInt16::ToString_91ad8e2580555a25(String* format, IFormatProvider* provider) {
        return ToString5(format, provider);
    }
    
    // Automatically generated method stub
    TypeCode UInt16::GetTypeCode_701c52aeb2913904() {
        return GetTypeCode();
    }
    
    // Automatically generated method stub
    bool UInt16::ToBoolean_f2ed021e3648bfba(IFormatProvider* provider) {
        return ToBoolean(provider);
    }
    
    // Automatically generated method stub
    unsigned char UInt16::ToByte_ce47dcc06c443b11(IFormatProvider* provider) {
        return ToByte(provider);
    }
    
    // Automatically generated method stub
    char16_t UInt16::ToChar_12adc960e23347fe(IFormatProvider* provider) {
        return ToChar(provider);
    }
    
    // Automatically generated method stub
    DateTime UInt16::ToDateTime_86b01e143a29eff2(IFormatProvider* provider) {
        return ToDateTime(provider);
    }
    
    // Automatically generated method stub
    Decimal UInt16::ToDecimal_9c02fd5cdb5f6a0c(IFormatProvider* provider) {
        return ToDecimal(provider);
    }
    
    // Automatically generated method stub
    double UInt16::ToDouble_bf8714f37f489c82(IFormatProvider* provider) {
        return ToDouble(provider);
    }
    
    // Automatically generated method stub
    int16_t UInt16::ToInt16_5e1de9bafa245bf2(IFormatProvider* provider) {
        return ToInt16(provider);
    }
    
    // Automatically generated method stub
    int32_t UInt16::ToInt32_9e7108d4c09b7e42(IFormatProvider* provider) {
        return ToInt32(provider);
    }
    
    // Automatically generated method stub
    int64_t UInt16::ToInt64_9801f9765e5301f6(IFormatProvider* provider) {
        return ToInt64(provider);
    }
    
    // Automatically generated method stub
    signed char UInt16::ToSByte_e1f09487d48936db(IFormatProvider* provider) {
        return ToSByte(provider);
    }
    
    // Automatically generated method stub
    float UInt16::ToSingle_1cfd1ce472f9fad6(IFormatProvider* provider) {
        return ToSingle(provider);
    }
    
    // Automatically generated method stub
    Object* UInt16::ToType_bf083accfb52550a(Type* targetType, IFormatProvider* provider) {
        return ToType(targetType, provider);
    }
    
    // Automatically generated method stub
    uint16_t UInt16::ToUInt16_1e02ae7e2827241a(IFormatProvider* provider) {
        return ToUInt16(provider);
    }
    
    // Automatically generated method stub
    uint32_t UInt16::ToUInt32_9a72f29c26115cfd(IFormatProvider* provider) {
        return ToUInt32(provider);
    }
    
    // Automatically generated method stub
    uint64_t UInt16::ToUInt64_fe563f2a802e4265(IFormatProvider* provider) {
        return ToUInt64(provider);
    }
    
}
namespace System {
    // Automatically generated method stub
    int32_t UInt32::CompareTo_ed9d39205b7812f0(Object* value) {
        return CompareTo(value);
    }
    
    // Automatically generated method stub
    int32_t UInt32::CompareTo_8a8b7d6c83beb422(uint32_t value) {
        return CompareTo2(value);
    }
    
    // Automatically generated method stub
    bool UInt32::Equals_ea48fd0c13a733fe(uint32_t obj) {
        return Equals2(obj);
    }
    
    // Automatically generated method stub
    String* UInt32::ToString_f121fe9e066b5628(IFormatProvider* provider) {
        return ToString3(provider);
    }
    
    // Automatically generated method stub
    String* UInt32::ToString_91ad8e2580555a25(String* format, IFormatProvider* provider) {
        return ToString5(format, provider);
    }
    
    // Automatically generated method stub
    TypeCode UInt32::GetTypeCode_701c52aeb2913904() {
        return GetTypeCode();
    }
    
    // Automatically generated method stub
    bool UInt32::ToBoolean_f2ed021e3648bfba(IFormatProvider* provider) {
        return ToBoolean(provider);
    }
    
    // Automatically generated method stub
    unsigned char UInt32::ToByte_ce47dcc06c443b11(IFormatProvider* provider) {
        return ToByte(provider);
    }
    
    // Automatically generated method stub
    char16_t UInt32::ToChar_12adc960e23347fe(IFormatProvider* provider) {
        return ToChar(provider);
    }
    
    // Automatically generated method stub
    DateTime UInt32::ToDateTime_86b01e143a29eff2(IFormatProvider* provider) {
        return ToDateTime(provider);
    }
    
    // Automatically generated method stub
    Decimal UInt32::ToDecimal_9c02fd5cdb5f6a0c(IFormatProvider* provider) {
        return ToDecimal(provider);
    }
    
    // Automatically generated method stub
    double UInt32::ToDouble_bf8714f37f489c82(IFormatProvider* provider) {
        return ToDouble(provider);
    }
    
    // Automatically generated method stub
    int16_t UInt32::ToInt16_5e1de9bafa245bf2(IFormatProvider* provider) {
        return ToInt16(provider);
    }
    
    // Automatically generated method stub
    int32_t UInt32::ToInt32_9e7108d4c09b7e42(IFormatProvider* provider) {
        return ToInt32(provider);
    }
    
    // Automatically generated method stub
    int64_t UInt32::ToInt64_9801f9765e5301f6(IFormatProvider* provider) {
        return ToInt64(provider);
    }
    
    // Automatically generated method stub
    signed char UInt32::ToSByte_e1f09487d48936db(IFormatProvider* provider) {
        return ToSByte(provider);
    }
    
    // Automatically generated method stub
    float UInt32::ToSingle_1cfd1ce472f9fad6(IFormatProvider* provider) {
        return ToSingle(provider);
    }
    
    // Automatically generated method stub
    Object* UInt32::ToType_bf083accfb52550a(Type* targetType, IFormatProvider* provider) {
        return ToType(targetType, provider);
    }
    
    // Automatically generated method stub
    uint16_t UInt32::ToUInt16_1e02ae7e2827241a(IFormatProvider* provider) {
        return ToUInt16(provider);
    }
    
    // Automatically generated method stub
    uint32_t UInt32::ToUInt32_9a72f29c26115cfd(IFormatProvider* provider) {
        return ToUInt32(provider);
    }
    
    // Automatically generated method stub
    uint64_t UInt32::ToUInt64_fe563f2a802e4265(IFormatProvider* provider) {
        return ToUInt64(provider);
    }
    
}
namespace System {
    // Automatically generated method stub
    int32_t UInt64::CompareTo_ed9d39205b7812f0(Object* value) {
        return CompareTo(value);
    }
    
    // Automatically generated method stub
    int32_t UInt64::CompareTo_8a8b7d6c83beb422(uint64_t value) {
        return CompareTo2(value);
    }
    
    // Automatically generated method stub
    bool UInt64::Equals_ea48fd0c13a733fe(uint64_t obj) {
        return Equals2(obj);
    }
    
    // Automatically generated method stub
    String* UInt64::ToString_f121fe9e066b5628(IFormatProvider* provider) {
        return ToString3(provider);
    }
    
    // Automatically generated method stub
    String* UInt64::ToString_91ad8e2580555a25(String* format, IFormatProvider* provider) {
        return ToString5(format, provider);
    }
    
    // Automatically generated method stub
    TypeCode UInt64::GetTypeCode_701c52aeb2913904() {
        return GetTypeCode();
    }
    
    // Automatically generated method stub
    bool UInt64::ToBoolean_f2ed021e3648bfba(IFormatProvider* provider) {
        return ToBoolean(provider);
    }
    
    // Automatically generated method stub
    unsigned char UInt64::ToByte_ce47dcc06c443b11(IFormatProvider* provider) {
        return ToByte(provider);
    }
    
    // Automatically generated method stub
    char16_t UInt64::ToChar_12adc960e23347fe(IFormatProvider* provider) {
        return ToChar(provider);
    }
    
    // Automatically generated method stub
    DateTime UInt64::ToDateTime_86b01e143a29eff2(IFormatProvider* provider) {
        return ToDateTime(provider);
    }
    
    // Automatically generated method stub
    Decimal UInt64::ToDecimal_9c02fd5cdb5f6a0c(IFormatProvider* provider) {
        return ToDecimal(provider);
    }
    
    // Automatically generated method stub
    double UInt64::ToDouble_bf8714f37f489c82(IFormatProvider* provider) {
        return ToDouble(provider);
    }
    
    // Automatically generated method stub
    int16_t UInt64::ToInt16_5e1de9bafa245bf2(IFormatProvider* provider) {
        return ToInt16(provider);
    }
    
    // Automatically generated method stub
    int32_t UInt64::ToInt32_9e7108d4c09b7e42(IFormatProvider* provider) {
        return ToInt32(provider);
    }
    
    // Automatically generated method stub
    int64_t UInt64::ToInt64_9801f9765e5301f6(IFormatProvider* provider) {
        return ToInt64(provider);
    }
    
    // Automatically generated method stub
    signed char UInt64::ToSByte_e1f09487d48936db(IFormatProvider* provider) {
        return ToSByte(provider);
    }
    
    // Automatically generated method stub
    float UInt64::ToSingle_1cfd1ce472f9fad6(IFormatProvider* provider) {
        return ToSingle(provider);
    }
    
    // Automatically generated method stub
    Object* UInt64::ToType_bf083accfb52550a(Type* targetType, IFormatProvider* provider) {
        return ToType(targetType, provider);
    }
    
    // Automatically generated method stub
    uint16_t UInt64::ToUInt16_1e02ae7e2827241a(IFormatProvider* provider) {
        return ToUInt16(provider);
    }
    
    // Automatically generated method stub
    uint32_t UInt64::ToUInt32_9a72f29c26115cfd(IFormatProvider* provider) {
        return ToUInt32(provider);
    }
    
    // Automatically generated method stub
    uint64_t UInt64::ToUInt64_fe563f2a802e4265(IFormatProvider* provider) {
        return ToUInt64(provider);
    }
    
}
namespace System {
    // Automatically generated method stub
    void UIntPtr::GetObjectData_11b895a112e04409(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        return GetObjectData(info, context);
    }
    
}
namespace System { namespace Collections { namespace Generic {
}}}
namespace System { namespace Collections { namespace Generic {
}}}
namespace System { namespace Collections { namespace Generic {
}}}
namespace System { namespace Collections { namespace Generic {
}}}
namespace System { namespace Configuration { namespace Assemblies {
    // Automatically generated method stub
    System::Object* AssemblyHash::Clone_d5efb96d327809c8() {
        return Clone();
    }
    
}}}
namespace System { namespace Threading {
    // Automatically generated method stub
    void AsyncFlowControl::Dispose_95cb2516542c2f97() {
        return Dispose();
    }
    
}}
namespace System { namespace Threading {
    // Automatically generated method stub
    void CancellationTokenRegistration::Dispose_95cb2516542c2f97() {
        return Dispose();
    }
    
    // Automatically generated method stub
    bool CancellationTokenRegistration::Equals_ea48fd0c13a733fe(CancellationTokenRegistration other) {
        return Equals(other);
    }
    
}}
namespace System { namespace Threading {
    // Automatically generated method stub
    void CompressedStackSwitcher::Dispose_95cb2516542c2f97() {
        return Dispose();
    }
    
}}
namespace System { namespace Threading {
    // Automatically generated method stub
    void ExecutionContextSwitcher::Dispose_95cb2516542c2f97() {
        return Dispose();
    }
    
}}
namespace System { namespace Threading {
    // Automatically generated method stub
    void HostExecutionContextSwitcher::Dispose_95cb2516542c2f97() {
        return Dispose();
    }
    
}}
namespace System { namespace Threading {
    // Automatically generated method stub
    void SynchronizationContextSwitcher::Dispose_95cb2516542c2f97() {
        return Dispose();
    }
    
}}
namespace Microsoft { namespace Win32 {
    // Automatically generated method stub
    void RegistryKey::Dispose_95cb2516542c2f97() {
        return Dispose();
    }
    
}}
namespace Microsoft { namespace Win32 {
    // Automatically generated method stub
    RegistryKey* UnixRegistryApi::CreateSubKey_e3b01f557508b68f(RegistryKey* rkey, System::String* keyname) {
        return CreateSubKey(rkey, keyname);
    }
    
    // Automatically generated method stub
    RegistryKey* UnixRegistryApi::CreateSubKey_d59517498a7eff5a(RegistryKey* rkey, System::String* keyname, RegistryOptions options) {
        return CreateSubKey2(rkey, keyname, options);
    }
    
    // Automatically generated method stub
    RegistryKey* UnixRegistryApi::OpenRemoteBaseKey_f80fed951d8f34a6(RegistryHive hKey, System::String* machineName) {
        return OpenRemoteBaseKey(hKey, machineName);
    }
    
    // Automatically generated method stub
    RegistryKey* UnixRegistryApi::OpenSubKey_4d6bff263dc4c438(RegistryKey* rkey, System::String* keyname, bool writable) {
        return OpenSubKey(rkey, keyname, writable);
    }
    
    // Automatically generated method stub
    RegistryKey* UnixRegistryApi::FromHandle_46a059a7a448791a(SafeHandles::SafeRegistryHandle* handle) {
        return FromHandle(handle);
    }
    
    // Automatically generated method stub
    void UnixRegistryApi::Flush_53d355753283f224(RegistryKey* rkey) {
        return Flush(rkey);
    }
    
    // Automatically generated method stub
    void UnixRegistryApi::Close_7ab99d30db36a1fc(RegistryKey* rkey) {
        return Close(rkey);
    }
    
    // Automatically generated method stub
    System::Object* UnixRegistryApi::GetValue_e35c4dfdaf0e1cb4(RegistryKey* rkey, System::String* name, System::Object* default_value, RegistryValueOptions options) {
        return GetValue(rkey, name, default_value, options);
    }
    
    // Automatically generated method stub
    void UnixRegistryApi::SetValue_9e6c50dfb2e1c48(RegistryKey* rkey, System::String* name, System::Object* value) {
        return SetValue(rkey, name, value);
    }
    
    // Automatically generated method stub
    void UnixRegistryApi::SetValue_5d8b5cf92e3e050f(RegistryKey* rkey, System::String* name, System::Object* value, RegistryValueKind valueKind) {
        return SetValue2(rkey, name, value, valueKind);
    }
    
    // Automatically generated method stub
    int32_t UnixRegistryApi::SubKeyCount_2748a641640ffdf6(RegistryKey* rkey) {
        return SubKeyCount(rkey);
    }
    
    // Automatically generated method stub
    int32_t UnixRegistryApi::ValueCount_2062387fe7292f8d(RegistryKey* rkey) {
        return ValueCount(rkey);
    }
    
    // Automatically generated method stub
    void UnixRegistryApi::DeleteValue_8d736af9c68b135(RegistryKey* rkey, System::String* name, bool throw_if_missing) {
        return DeleteValue(rkey, name, throw_if_missing);
    }
    
    // Automatically generated method stub
    void UnixRegistryApi::DeleteKey_84e4c2cae50b1273(RegistryKey* rkey, System::String* keyname, bool throw_if_missing) {
        return DeleteKey(rkey, keyname, throw_if_missing);
    }
    
    // Automatically generated method stub
    cli::array<System::String*>* UnixRegistryApi::GetSubKeyNames_34dc199201a58ad7(RegistryKey* rkey) {
        return GetSubKeyNames(rkey);
    }
    
    // Automatically generated method stub
    cli::array<System::String*>* UnixRegistryApi::GetValueNames_1b2f3e2c26006c8d(RegistryKey* rkey) {
        return GetValueNames(rkey);
    }
    
    // Automatically generated method stub
    System::String* UnixRegistryApi::ToString_8a8e8752aa6cc828(RegistryKey* rkey) {
        return ToString2(rkey);
    }
    
    // Automatically generated method stub
    RegistryValueKind UnixRegistryApi::GetValueKind_c91458ed4ea1e91a(RegistryKey* rkey, System::String* name) {
        return GetValueKind(rkey, name);
    }
    
    // Automatically generated method stub
    void* UnixRegistryApi::GetHandle_1af66fc049eafa1e(RegistryKey* key) {
        return GetHandle(key);
    }
    
}}
namespace Microsoft { namespace Win32 {
    // Automatically generated method stub
    void* Win32RegistryApi::GetHandle_1af66fc049eafa1e(RegistryKey* key) {
        return GetHandle(key);
    }
    
    // Automatically generated method stub
    RegistryValueKind Win32RegistryApi::GetValueKind_c91458ed4ea1e91a(RegistryKey* rkey, System::String* name) {
        return GetValueKind(rkey, name);
    }
    
    // Automatically generated method stub
    System::Object* Win32RegistryApi::GetValue_e35c4dfdaf0e1cb4(RegistryKey* rkey, System::String* name, System::Object* defaultValue, RegistryValueOptions options) {
        return GetValue(rkey, name, defaultValue, options);
    }
    
    // Automatically generated method stub
    void Win32RegistryApi::SetValue_5d8b5cf92e3e050f(RegistryKey* rkey, System::String* name, System::Object* value, RegistryValueKind valueKind) {
        return SetValue(rkey, name, value, valueKind);
    }
    
    // Automatically generated method stub
    void Win32RegistryApi::SetValue_9e6c50dfb2e1c48(RegistryKey* rkey, System::String* name, System::Object* value) {
        return SetValue2(rkey, name, value);
    }
    
    // Automatically generated method stub
    int32_t Win32RegistryApi::SubKeyCount_2748a641640ffdf6(RegistryKey* rkey) {
        return SubKeyCount(rkey);
    }
    
    // Automatically generated method stub
    int32_t Win32RegistryApi::ValueCount_2062387fe7292f8d(RegistryKey* rkey) {
        return ValueCount(rkey);
    }
    
    // Automatically generated method stub
    RegistryKey* Win32RegistryApi::OpenRemoteBaseKey_f80fed951d8f34a6(RegistryHive hKey, System::String* machineName) {
        return OpenRemoteBaseKey(hKey, machineName);
    }
    
    // Automatically generated method stub
    RegistryKey* Win32RegistryApi::OpenSubKey_4d6bff263dc4c438(RegistryKey* rkey, System::String* keyName, bool writable) {
        return OpenSubKey(rkey, keyName, writable);
    }
    
    // Automatically generated method stub
    void Win32RegistryApi::Flush_53d355753283f224(RegistryKey* rkey) {
        return Flush(rkey);
    }
    
    // Automatically generated method stub
    void Win32RegistryApi::Close_7ab99d30db36a1fc(RegistryKey* rkey) {
        return Close(rkey);
    }
    
    // Automatically generated method stub
    RegistryKey* Win32RegistryApi::FromHandle_46a059a7a448791a(SafeHandles::SafeRegistryHandle* handle) {
        return FromHandle(handle);
    }
    
    // Automatically generated method stub
    RegistryKey* Win32RegistryApi::CreateSubKey_e3b01f557508b68f(RegistryKey* rkey, System::String* keyName) {
        return CreateSubKey(rkey, keyName);
    }
    
    // Automatically generated method stub
    RegistryKey* Win32RegistryApi::CreateSubKey_d59517498a7eff5a(RegistryKey* rkey, System::String* keyName, RegistryOptions options) {
        return CreateSubKey2(rkey, keyName, options);
    }
    
    // Automatically generated method stub
    void Win32RegistryApi::DeleteKey_84e4c2cae50b1273(RegistryKey* rkey, System::String* keyName, bool shouldThrowWhenKeyMissing) {
        return DeleteKey(rkey, keyName, shouldThrowWhenKeyMissing);
    }
    
    // Automatically generated method stub
    void Win32RegistryApi::DeleteValue_8d736af9c68b135(RegistryKey* rkey, System::String* value, bool shouldThrowWhenKeyMissing) {
        return DeleteValue(rkey, value, shouldThrowWhenKeyMissing);
    }
    
    // Automatically generated method stub
    cli::array<System::String*>* Win32RegistryApi::GetSubKeyNames_34dc199201a58ad7(RegistryKey* rkey) {
        return GetSubKeyNames(rkey);
    }
    
    // Automatically generated method stub
    cli::array<System::String*>* Win32RegistryApi::GetValueNames_1b2f3e2c26006c8d(RegistryKey* rkey) {
        return GetValueNames(rkey);
    }
    
    // Automatically generated method stub
    System::String* Win32RegistryApi::ToString_8a8e8752aa6cc828(RegistryKey* rkey) {
        return ToString2(rkey);
    }
    
}}
namespace Mono { namespace Globalization { namespace Unicode {
    // Automatically generated method stub
    int32_t ContractionComparer::Compare_451fd276747b629d(System::Object* o1, System::Object* o2) {
        return Compare(o1, o2);
    }
    
}}}
namespace Mono { namespace Globalization { namespace Unicode {
    // Automatically generated method stub
    int32_t Level2MapComparer::Compare_451fd276747b629d(System::Object* o1, System::Object* o2) {
        return Compare(o1, o2);
    }
    
}}}
namespace Mono { namespace Interop {
    // Automatically generated method stub
    bool ComInteropProxy::CanCastTo_7f8304fa142c3271(System::Type* fromType, System::Object* o) {
        return CanCastTo(fromType, o);
    }
    
    // Automatically generated method stub
    System::String* ComInteropProxy::get_TypeName_e368785a4c79e626() {
        return get_TypeName();
    }
    
    // Automatically generated method stub
    System::String* ComInteropProxy::set_TypeName_d3657f810af9c065(System::String* value) {
        return set_TypeName(value);
    }
    
}}
namespace Mono { namespace Security { namespace Cryptography {
    // Automatically generated method stub
    void SymmetricTransform::Dispose_95cb2516542c2f97() {
        return Dispose();
    }
    
    // Automatically generated method stub
    int32_t SymmetricTransform::TransformBlock_66947c2464acaa4b(cli::array<unsigned char>* inputBuffer, int32_t inputOffset, int32_t inputCount, cli::array<unsigned char>* outputBuffer, int32_t outputOffset) {
        return TransformBlock_ae7940e12ac19b2d(inputBuffer, inputOffset, inputCount, outputBuffer, outputOffset);
    }
    
    // Automatically generated method stub
    cli::array<unsigned char>* SymmetricTransform::TransformFinalBlock_24eabce3605cc4ff(cli::array<unsigned char>* inputBuffer, int32_t inputOffset, int32_t inputCount) {
        return TransformFinalBlock_b50acf58c03aba0a(inputBuffer, inputOffset, inputCount);
    }
    
    // Automatically generated method stub
    bool SymmetricTransform::get_CanTransformMultipleBlocks_711dcde861c62b70() {
        return get_CanTransformMultipleBlocks_6ab5f7b44ce018f3();
    }
    
    // Automatically generated method stub
    bool SymmetricTransform::get_CanReuseTransform_a8f6dfeea811518b() {
        return get_CanReuseTransform_dc6193f5d984ad67();
    }
    
    // Automatically generated method stub
    int32_t SymmetricTransform::get_InputBlockSize_96223a4af50041fd() {
        return get_InputBlockSize_ffe7482408103da5();
    }
    
    // Automatically generated method stub
    int32_t SymmetricTransform::get_OutputBlockSize_970895ff24f2d445() {
        return get_OutputBlockSize_97555d7a856ef43b();
    }
    
}}}
namespace Mono { namespace Security { namespace X509 {
    // Automatically generated method stub
    System::Object* PKCS12::Clone_d5efb96d327809c8() {
        return Clone();
    }
    
}}}
namespace Mono { namespace Security { namespace X509 {
    // Automatically generated method stub
    X509CertificateCollection* TrustAnchors::get_Anchors_d1264350bad2a64a() {
        return get_Anchors();
    }
    
}}}
namespace Mono { namespace Security { namespace X509 {
    // Automatically generated method stub
    void X509Certificate::GetObjectData_11b895a112e04409(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        return GetObjectData_d40d37eb78c2fb36(info, context);
    }
    
}}}
namespace Mono { namespace Security { namespace X509 {
    // Automatically generated method stub
    bool X509CertificateEnumerator::MoveNext_4e78e145935f5417() {
        return MoveNext();
    }
    
    // Automatically generated method stub
    void X509CertificateEnumerator::Reset_bcd82381eed41868() {
        return Reset();
    }
    
    // Automatically generated method stub
    System::Object* X509CertificateEnumerator::get_Current_8eca9b3da02b123a() {
        return get_Current2();
    }
    
}}}
namespace Mono { namespace Security { namespace X509 {
    // Automatically generated method stub
    System::Collections::IEnumerator* X509CertificateCollection::GetEnumerator_674ad93a972a4d67() {
        return GetEnumerator3();
    }
    
}}}
namespace Mono { namespace Security { namespace X509 {
    // Automatically generated method stub
    System::Collections::IEnumerator* X509ExtensionCollection::GetEnumerator_674ad93a972a4d67() {
        return GetEnumerator2();
    }
    
}}}
namespace Mono { namespace Xml {
    // Automatically generated method stub
    void SecurityParser::OnStartParsing_60c119bf90baa608(SmallXmlParser* parser) {
        return OnStartParsing(parser);
    }
    
    // Automatically generated method stub
    void SecurityParser::OnProcessingInstruction_eeedb82cbfe7ab40(System::String* name, System::String* text) {
        return OnProcessingInstruction(name, text);
    }
    
    // Automatically generated method stub
    void SecurityParser::OnIgnorableWhitespace_39f85fe38215782c(System::String* s) {
        return OnIgnorableWhitespace(s);
    }
    
    // Automatically generated method stub
    void SecurityParser::OnStartElement_431a5ecd1484562f(System::String* name, IAttrList* attrs) {
        return OnStartElement(name, attrs);
    }
    
    // Automatically generated method stub
    void SecurityParser::OnEndElement_47dd703957202fcd(System::String* name) {
        return OnEndElement(name);
    }
    
    // Automatically generated method stub
    void SecurityParser::OnChars_23545ef97e4c205b(System::String* ch) {
        return OnChars(ch);
    }
    
    // Automatically generated method stub
    void SecurityParser::OnEndParsing_ddf0252ce1c74235(SmallXmlParser* parser) {
        return OnEndParsing(parser);
    }
    
}}
namespace Mono { namespace Xml {
    // Automatically generated method stub
    void DefaultHandler::OnStartParsing_60c119bf90baa608(SmallXmlParser* parser) {
        return OnStartParsing(parser);
    }
    
    // Automatically generated method stub
    void DefaultHandler::OnEndParsing_ddf0252ce1c74235(SmallXmlParser* parser) {
        return OnEndParsing(parser);
    }
    
    // Automatically generated method stub
    void DefaultHandler::OnStartElement_431a5ecd1484562f(System::String* name, IAttrList* attrs) {
        return OnStartElement(name, attrs);
    }
    
    // Automatically generated method stub
    void DefaultHandler::OnEndElement_47dd703957202fcd(System::String* name) {
        return OnEndElement(name);
    }
    
    // Automatically generated method stub
    void DefaultHandler::OnChars_23545ef97e4c205b(System::String* s) {
        return OnChars(s);
    }
    
    // Automatically generated method stub
    void DefaultHandler::OnIgnorableWhitespace_39f85fe38215782c(System::String* s) {
        return OnIgnorableWhitespace(s);
    }
    
    // Automatically generated method stub
    void DefaultHandler::OnProcessingInstruction_eeedb82cbfe7ab40(System::String* name, System::String* text) {
        return OnProcessingInstruction(name, text);
    }
    
}}
namespace Mono { namespace Xml {
    // Automatically generated method stub
    System::String* AttrListImpl::GetName_71efa89033fbba85(int32_t i) {
        return GetName(i);
    }
    
    // Automatically generated method stub
    System::String* AttrListImpl::GetValue_e96b4d39015c72a4(int32_t i) {
        return GetValue(i);
    }
    
    // Automatically generated method stub
    System::String* AttrListImpl::GetValue_da157d9f297d63a4(System::String* name) {
        return GetValue2(name);
    }
    
    // Automatically generated method stub
    int32_t AttrListImpl::get_Length_4ee791fdf528d8a() {
        return get_Length();
    }
    
    // Automatically generated method stub
    bool AttrListImpl::get_IsEmpty_ffd3b9fc5868c6c7() {
        return get_IsEmpty();
    }
    
    // Automatically generated method stub
    cli::array<System::String*>* AttrListImpl::get_Names_9f5e761023ba0c63() {
        return get_Names();
    }
    
    // Automatically generated method stub
    cli::array<System::String*>* AttrListImpl::get_Values_56e80d7ef1a6a837() {
        return get_Values();
    }
    
}}
namespace System {
    // Automatically generated method stub
    void ActivationContext::Dispose_95cb2516542c2f97() {
        return Dispose();
    }
    
    // Automatically generated method stub
    void ActivationContext::GetObjectData_11b895a112e04409(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        return GetObjectData(info, context);
    }
    
}
namespace System {
    // Automatically generated method stub
    void Activator::GetIDsOfNames_48d015a76eb21be9(Guid riid, void* rgszNames, uint32_t cNames, uint32_t lcid, void* rgDispId) {
        return GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    }
    
    // Automatically generated method stub
    void Activator::GetTypeInfo_bd361ada0936d12d(uint32_t iTInfo, uint32_t lcid, void* ppTInfo) {
        return GetTypeInfo(iTInfo, lcid, ppTInfo);
    }
    
    // Automatically generated method stub
    void Activator::GetTypeInfoCount_d5a4067d5ef51f60(uint32_t pcTInfo) {
        return GetTypeInfoCount(pcTInfo);
    }
    
    // Automatically generated method stub
    void Activator::Invoke_d0a599bfce5b27ab(uint32_t dispIdMember, Guid riid, uint32_t lcid, int16_t wFlags, void* pDispParams, void* pVarResult, void* pExcepInfo, void* puArgErr) {
        return Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    }
    
}
namespace System {
    // Automatically generated method stub
    void AppDomain::AppendPrivatePath_b3ee2eec783a3754(String* path) {
        return AppendPrivatePath(path);
    }
    
    // Automatically generated method stub
    void AppDomain::ClearPrivatePath_bee8a0fbf4df9e1e() {
        return ClearPrivatePath();
    }
    
    // Automatically generated method stub
    void AppDomain::ClearShadowCopyPath_b0050824cd24a2b9() {
        return ClearShadowCopyPath();
    }
    
    // Automatically generated method stub
    Runtime::Remoting::ObjectHandle* AppDomain::CreateInstance_b0289026ebfffff7(String* assemblyName, String* typeName) {
        return CreateInstance(assemblyName, typeName);
    }
    
    // Automatically generated method stub
    Runtime::Remoting::ObjectHandle* AppDomain::CreateInstance_953176cf11400657(String* assemblyName, String* typeName, cli::array<Object*>* activationAttributes) {
        return CreateInstance2(assemblyName, typeName, activationAttributes);
    }
    
    // Automatically generated method stub
    Runtime::Remoting::ObjectHandle* AppDomain::CreateInstance_593e3b24df052556(String* assemblyName, String* typeName, bool ignoreCase, Reflection::BindingFlags bindingAttr, Reflection::Binder* binder, cli::array<Object*>* args, Globalization::CultureInfo* culture, cli::array<Object*>* activationAttributes, Security::Policy::Evidence* securityAttributes) {
        return CreateInstance3(assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes);
    }
    
    // Automatically generated method stub
    Runtime::Remoting::ObjectHandle* AppDomain::CreateInstanceFrom_a887219b218de75d(String* assemblyFile, String* typeName) {
        return CreateInstanceFrom2(assemblyFile, typeName);
    }
    
    // Automatically generated method stub
    Runtime::Remoting::ObjectHandle* AppDomain::CreateInstanceFrom_655dfdad722dba22(String* assemblyFile, String* typeName, cli::array<Object*>* activationAttributes) {
        return CreateInstanceFrom3(assemblyFile, typeName, activationAttributes);
    }
    
    // Automatically generated method stub
    Runtime::Remoting::ObjectHandle* AppDomain::CreateInstanceFrom_3090b41533c8c88c(String* assemblyFile, String* typeName, bool ignoreCase, Reflection::BindingFlags bindingAttr, Reflection::Binder* binder, cli::array<Object*>* args, Globalization::CultureInfo* culture, cli::array<Object*>* activationAttributes, Security::Policy::Evidence* securityAttributes) {
        return CreateInstanceFrom4(assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes);
    }
    
    // Automatically generated method stub
    Reflection::Emit::AssemblyBuilder* AppDomain::DefineDynamicAssembly_c3dc46d012ab6aeb(Reflection::AssemblyName* name, Reflection::Emit::AssemblyBuilderAccess access) {
        return DefineDynamicAssembly(name, access);
    }
    
    // Automatically generated method stub
    Reflection::Emit::AssemblyBuilder* AppDomain::DefineDynamicAssembly_627f226f06baa8b6(Reflection::AssemblyName* name, Reflection::Emit::AssemblyBuilderAccess access, Security::Policy::Evidence* evidence) {
        return DefineDynamicAssembly2(name, access, evidence);
    }
    
    // Automatically generated method stub
    Reflection::Emit::AssemblyBuilder* AppDomain::DefineDynamicAssembly_21f25a254658c094(Reflection::AssemblyName* name, Reflection::Emit::AssemblyBuilderAccess access, String* dir) {
        return DefineDynamicAssembly3(name, access, dir);
    }
    
    // Automatically generated method stub
    Reflection::Emit::AssemblyBuilder* AppDomain::DefineDynamicAssembly_604e078899c011f0(Reflection::AssemblyName* name, Reflection::Emit::AssemblyBuilderAccess access, String* dir, Security::Policy::Evidence* evidence) {
        return DefineDynamicAssembly4(name, access, dir, evidence);
    }
    
    // Automatically generated method stub
    Reflection::Emit::AssemblyBuilder* AppDomain::DefineDynamicAssembly_290276c209d2331(Reflection::AssemblyName* name, Reflection::Emit::AssemblyBuilderAccess access, Security::PermissionSet* requiredPermissions, Security::PermissionSet* optionalPermissions, Security::PermissionSet* refusedPermissions) {
        return DefineDynamicAssembly5(name, access, requiredPermissions, optionalPermissions, refusedPermissions);
    }
    
    // Automatically generated method stub
    Reflection::Emit::AssemblyBuilder* AppDomain::DefineDynamicAssembly_decd91a805fc8e1b(Reflection::AssemblyName* name, Reflection::Emit::AssemblyBuilderAccess access, Security::Policy::Evidence* evidence, Security::PermissionSet* requiredPermissions, Security::PermissionSet* optionalPermissions, Security::PermissionSet* refusedPermissions) {
        return DefineDynamicAssembly6(name, access, evidence, requiredPermissions, optionalPermissions, refusedPermissions);
    }
    
    // Automatically generated method stub
    Reflection::Emit::AssemblyBuilder* AppDomain::DefineDynamicAssembly_7102ce3e754e1ad3(Reflection::AssemblyName* name, Reflection::Emit::AssemblyBuilderAccess access, String* dir, Security::PermissionSet* requiredPermissions, Security::PermissionSet* optionalPermissions, Security::PermissionSet* refusedPermissions) {
        return DefineDynamicAssembly7(name, access, dir, requiredPermissions, optionalPermissions, refusedPermissions);
    }
    
    // Automatically generated method stub
    Reflection::Emit::AssemblyBuilder* AppDomain::DefineDynamicAssembly_3c294097a9c19c30(Reflection::AssemblyName* name, Reflection::Emit::AssemblyBuilderAccess access, String* dir, Security::Policy::Evidence* evidence, Security::PermissionSet* requiredPermissions, Security::PermissionSet* optionalPermissions, Security::PermissionSet* refusedPermissions) {
        return DefineDynamicAssembly8(name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions);
    }
    
    // Automatically generated method stub
    Reflection::Emit::AssemblyBuilder* AppDomain::DefineDynamicAssembly_3143681a2942300a(Reflection::AssemblyName* name, Reflection::Emit::AssemblyBuilderAccess access, String* dir, Security::Policy::Evidence* evidence, Security::PermissionSet* requiredPermissions, Security::PermissionSet* optionalPermissions, Security::PermissionSet* refusedPermissions, bool isSynchronized) {
        return DefineDynamicAssembly9(name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions, isSynchronized);
    }
    
    // Automatically generated method stub
    void AppDomain::DoCallBack_66db270a4ceffdfe(CrossAppDomainDelegate* callBackDelegate) {
        return DoCallBack(callBackDelegate);
    }
    
    // Automatically generated method stub
    int32_t AppDomain::ExecuteAssembly_aebf0fe3b56c1c6f(String* assemblyFile) {
        return ExecuteAssembly(assemblyFile);
    }
    
    // Automatically generated method stub
    int32_t AppDomain::ExecuteAssembly_7527301e547e9998(String* assemblyFile, Security::Policy::Evidence* assemblySecurity) {
        return ExecuteAssembly2(assemblyFile, assemblySecurity);
    }
    
    // Automatically generated method stub
    int32_t AppDomain::ExecuteAssembly_d0e79bc117cbb23c(String* assemblyFile, Security::Policy::Evidence* assemblySecurity, cli::array<String*>* args) {
        return ExecuteAssembly3(assemblyFile, assemblySecurity, args);
    }
    
    // Automatically generated method stub
    cli::array<Reflection::Assembly*>* AppDomain::GetAssemblies_2f2f24782e9bbaa1() {
        return GetAssemblies2();
    }
    
    // Automatically generated method stub
    Object* AppDomain::GetData_8d88d80779f39e8d(String* name) {
        return GetData(name);
    }
    
    // Automatically generated method stub
    Type* AppDomain::GetType_8770470dc313272b() {
        return GetType();
    }
    
    // Automatically generated method stub
    Object* AppDomain::InitializeLifetimeService_a5c5aadd1b06210b() {
        return InitializeLifetimeService_8f02e9c96ffbe30f();
    }
    
    // Automatically generated method stub
    Reflection::Assembly* AppDomain::Load_ca851dd254b4f361(Reflection::AssemblyName* assemblyRef) {
        return Load(assemblyRef);
    }
    
    // Automatically generated method stub
    Reflection::Assembly* AppDomain::Load_3da712896f486abc(Reflection::AssemblyName* assemblyRef, Security::Policy::Evidence* assemblySecurity) {
        return Load2(assemblyRef, assemblySecurity);
    }
    
    // Automatically generated method stub
    Reflection::Assembly* AppDomain::Load_d908dcc0864db1d3(String* assemblyString) {
        return Load3(assemblyString);
    }
    
    // Automatically generated method stub
    Reflection::Assembly* AppDomain::Load_fdea81560c002669(String* assemblyString, Security::Policy::Evidence* assemblySecurity) {
        return Load4(assemblyString, assemblySecurity);
    }
    
    // Automatically generated method stub
    Reflection::Assembly* AppDomain::Load_f3c3a9f63e02d7c7(cli::array<unsigned char>* rawAssembly) {
        return Load6(rawAssembly);
    }
    
    // Automatically generated method stub
    Reflection::Assembly* AppDomain::Load_dc2369822d808ae3(cli::array<unsigned char>* rawAssembly, cli::array<unsigned char>* rawSymbolStore) {
        return Load7(rawAssembly, rawSymbolStore);
    }
    
    // Automatically generated method stub
    Reflection::Assembly* AppDomain::Load_102c0f4f7d676d04(cli::array<unsigned char>* rawAssembly, cli::array<unsigned char>* rawSymbolStore, Security::Policy::Evidence* securityEvidence) {
        return Load8(rawAssembly, rawSymbolStore, securityEvidence);
    }
    
    // Automatically generated method stub
    void AppDomain::SetAppDomainPolicy_e0a2fcde2ca025e6(Security::Policy::PolicyLevel* domainPolicy) {
        return SetAppDomainPolicy(domainPolicy);
    }
    
    // Automatically generated method stub
    void AppDomain::SetCachePath_b899d77d9e3e4a1e(String* path) {
        return SetCachePath(path);
    }
    
    // Automatically generated method stub
    void AppDomain::SetPrincipalPolicy_d991a50e71ad558f(Security::Principal::PrincipalPolicy policy) {
        return SetPrincipalPolicy(policy);
    }
    
    // Automatically generated method stub
    void AppDomain::SetShadowCopyPath_33d17aa37e2073bf(String* path) {
        return SetShadowCopyPath(path);
    }
    
    // Automatically generated method stub
    void AppDomain::SetThreadPrincipal_61af26702d580521(Security::Principal::IPrincipal* principal) {
        return SetThreadPrincipal(principal);
    }
    
    // Automatically generated method stub
    void AppDomain::SetData_fae3a991137e9570(String* name, Object* data) {
        return SetData(name, data);
    }
    
    // Automatically generated method stub
    String* AppDomain::ToString_e621708666fbb83e() {
        return ToString_1636a0751cb9ac11();
    }
    
    // Automatically generated method stub
    void AppDomain::GetIDsOfNames_4870ff5d64d8c1f1(Guid riid, void* rgszNames, uint32_t cNames, uint32_t lcid, void* rgDispId) {
        return GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    }
    
    // Automatically generated method stub
    void AppDomain::GetTypeInfo_7e5828400406fc0a(uint32_t iTInfo, uint32_t lcid, void* ppTInfo) {
        return GetTypeInfo(iTInfo, lcid, ppTInfo);
    }
    
    // Automatically generated method stub
    void AppDomain::GetTypeInfoCount_9db5fe51658e3d38(uint32_t pcTInfo) {
        return GetTypeInfoCount(pcTInfo);
    }
    
    // Automatically generated method stub
    void AppDomain::Invoke_9fac458325d11ed4(uint32_t dispIdMember, Guid riid, uint32_t lcid, int16_t wFlags, void* pDispParams, void* pVarResult, void* pExcepInfo, void* puArgErr) {
        return Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    }
    
    // Automatically generated method stub
    String* AppDomain::get_BaseDirectory_950eba357d2ea91d() {
        return get_BaseDirectory();
    }
    
    // Automatically generated method stub
    String* AppDomain::get_RelativeSearchPath_6d86d21708d754c9() {
        return get_RelativeSearchPath();
    }
    
    // Automatically generated method stub
    String* AppDomain::get_DynamicDirectory_b9f183d81035af32() {
        return get_DynamicDirectory();
    }
    
    // Automatically generated method stub
    bool AppDomain::get_ShadowCopyFiles_c64e19b67830a0d6() {
        return get_ShadowCopyFiles();
    }
    
    // Automatically generated method stub
    String* AppDomain::get_FriendlyName_a7ea6ef61f96e4f0() {
        return get_FriendlyName();
    }
    
    // Automatically generated method stub
    Security::Policy::Evidence* AppDomain::get_Evidence_b29329a23899d3a1() {
        return get_Evidence();
    }
    
    // Automatically generated method stub
    Security::Policy::Evidence* AppDomain::get_Evidence_f1eadb7cf64a7592() {
        return get_Evidence();
    }
    
    // Automatically generated method stub
    void AppDomain::add_AssemblyLoad_d41608c4efde307d(AssemblyLoadEventHandler* value) {
        return add_AssemblyLoad(value);
    }
    
    // Automatically generated method stub
    void AppDomain::remove_AssemblyLoad_78edf16ad91a8170(AssemblyLoadEventHandler* value) {
        return remove_AssemblyLoad(value);
    }
    
    // Automatically generated method stub
    void AppDomain::add_AssemblyResolve_1bc6b8609d68da1(ResolveEventHandler* value) {
        return add_AssemblyResolve(value);
    }
    
    // Automatically generated method stub
    void AppDomain::remove_AssemblyResolve_b723f81b23087974(ResolveEventHandler* value) {
        return remove_AssemblyResolve(value);
    }
    
    // Automatically generated method stub
    void AppDomain::add_DomainUnload_d3cf45e1009e4e8a(EventHandler* value) {
        return add_DomainUnload(value);
    }
    
    // Automatically generated method stub
    void AppDomain::remove_DomainUnload_d67c5135e3e23c1(EventHandler* value) {
        return remove_DomainUnload(value);
    }
    
    // Automatically generated method stub
    void AppDomain::add_ProcessExit_1b1e458c957cc32f(EventHandler* value) {
        return add_ProcessExit(value);
    }
    
    // Automatically generated method stub
    void AppDomain::remove_ProcessExit_5709ece2c4ad927a(EventHandler* value) {
        return remove_ProcessExit(value);
    }
    
    // Automatically generated method stub
    void AppDomain::add_ResourceResolve_25585e4d513c6288(ResolveEventHandler* value) {
        return add_ResourceResolve(value);
    }
    
    // Automatically generated method stub
    void AppDomain::remove_ResourceResolve_4859b7f44cf2916(ResolveEventHandler* value) {
        return remove_ResourceResolve(value);
    }
    
    // Automatically generated method stub
    void AppDomain::add_TypeResolve_b86030308f849881(ResolveEventHandler* value) {
        return add_TypeResolve(value);
    }
    
    // Automatically generated method stub
    void AppDomain::remove_TypeResolve_14e72b551178582b(ResolveEventHandler* value) {
        return remove_TypeResolve(value);
    }
    
    // Automatically generated method stub
    void AppDomain::add_UnhandledException_eccab8e37f0236c3(UnhandledExceptionEventHandler* value) {
        return add_UnhandledException(value);
    }
    
    // Automatically generated method stub
    void AppDomain::remove_UnhandledException_8a9eff9b9b50b9b8(UnhandledExceptionEventHandler* value) {
        return remove_UnhandledException(value);
    }
    
    // Automatically generated method stub
    bool AppDomain::Equals_5e8e0f86a79f1d51(Object* obj) {
        return Equals_ed975d2f4a7d193e(obj);
    }
    
    // Automatically generated method stub
    int32_t AppDomain::GetHashCode_fd0ed3bf64cfe8f9() {
        return GetHashCode_6648aef0f235ee6c();
    }
    
    // Automatically generated method stub
    Object* AppDomain::GetLifetimeService_2b12bb4495bc713c() {
        return GetLifetimeService();
    }
    
}
namespace System {
    // Automatically generated method stub
    String* AppDomainSetup::get_ApplicationBase_9721289a5eae8836() {
        return get_ApplicationBase();
    }
    
    // Automatically generated method stub
    String* AppDomainSetup::set_ApplicationBase_4873b8c25c63c048(String* value) {
        return set_ApplicationBase(value);
    }
    
    // Automatically generated method stub
    String* AppDomainSetup::get_ApplicationName_e8fa5c72c612228c() {
        return get_ApplicationName();
    }
    
    // Automatically generated method stub
    String* AppDomainSetup::set_ApplicationName_ccc13d0847864819(String* value) {
        return set_ApplicationName(value);
    }
    
    // Automatically generated method stub
    String* AppDomainSetup::get_CachePath_c696e8dcfbd4017c() {
        return get_CachePath();
    }
    
    // Automatically generated method stub
    String* AppDomainSetup::set_CachePath_35f2a12bef0a32d0(String* value) {
        return set_CachePath(value);
    }
    
    // Automatically generated method stub
    String* AppDomainSetup::get_ConfigurationFile_9376e208dae3aba0() {
        return get_ConfigurationFile();
    }
    
    // Automatically generated method stub
    String* AppDomainSetup::set_ConfigurationFile_398471c00bb93ab1(String* value) {
        return set_ConfigurationFile(value);
    }
    
    // Automatically generated method stub
    String* AppDomainSetup::get_DynamicBase_755a2f189fc3f2ad() {
        return get_DynamicBase();
    }
    
    // Automatically generated method stub
    String* AppDomainSetup::set_DynamicBase_dc22b98e02191087(String* value) {
        return set_DynamicBase(value);
    }
    
    // Automatically generated method stub
    String* AppDomainSetup::get_LicenseFile_f73f0a4c53b13a1b() {
        return get_LicenseFile();
    }
    
    // Automatically generated method stub
    String* AppDomainSetup::set_LicenseFile_3d344cd71e3a0bbd(String* value) {
        return set_LicenseFile(value);
    }
    
    // Automatically generated method stub
    String* AppDomainSetup::get_PrivateBinPath_bef59c6818e17f4c() {
        return get_PrivateBinPath();
    }
    
    // Automatically generated method stub
    String* AppDomainSetup::set_PrivateBinPath_ebc4d24d2b23cc82(String* value) {
        return set_PrivateBinPath(value);
    }
    
    // Automatically generated method stub
    String* AppDomainSetup::get_PrivateBinPathProbe_8d247bd69349815a() {
        return get_PrivateBinPathProbe();
    }
    
    // Automatically generated method stub
    String* AppDomainSetup::set_PrivateBinPathProbe_d6b5308e90c21862(String* value) {
        return set_PrivateBinPathProbe(value);
    }
    
    // Automatically generated method stub
    String* AppDomainSetup::get_ShadowCopyDirectories_27b053b1a11ee820() {
        return get_ShadowCopyDirectories();
    }
    
    // Automatically generated method stub
    String* AppDomainSetup::set_ShadowCopyDirectories_d44cecd50c99c9e3(String* value) {
        return set_ShadowCopyDirectories(value);
    }
    
    // Automatically generated method stub
    String* AppDomainSetup::get_ShadowCopyFiles_c865b8136fa4fff5() {
        return get_ShadowCopyFiles();
    }
    
    // Automatically generated method stub
    String* AppDomainSetup::set_ShadowCopyFiles_e981770a6ada516e(String* value) {
        return set_ShadowCopyFiles(value);
    }
    
}
namespace System {
    // Automatically generated method stub
    void ApplicationIdentity::GetObjectData_11b895a112e04409(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        return GetObjectData(info, context);
    }
    
}
namespace System {
    // Automatically generated method stub
    bool SimpleEnumerator::MoveNext_4e78e145935f5417() {
        return MoveNext();
    }
    
    // Automatically generated method stub
    void SimpleEnumerator::Reset_bcd82381eed41868() {
        return Reset();
    }
    
    // Automatically generated method stub
    Object* SimpleEnumerator::Clone_d5efb96d327809c8() {
        return Clone();
    }
    
    // Automatically generated method stub
    Object* SimpleEnumerator::get_Current_8eca9b3da02b123a() {
        return get_Current();
    }
    
}
namespace System {
    // Automatically generated method stub
    int32_t Array::Add_985508e3bf9b7a73(Object* value) {
        return Add(value);
    }
    
    // Automatically generated method stub
    void Array::Clear_e0ee496065507a2f() {
        return Clear();
    }
    
    // Automatically generated method stub
    bool Array::Contains_2a2192a595869f4e(Object* value) {
        return Contains(value);
    }
    
    // Automatically generated method stub
    int32_t Array::IndexOf_7f6d78d7aa6d53e5(Object* value) {
        return IndexOf(value);
    }
    
    // Automatically generated method stub
    void Array::Insert_16e8bd69dfc603f4(int32_t index, Object* value) {
        return Insert(index, value);
    }
    
    // Automatically generated method stub
    void Array::Remove_69f1b1e57bb34112(Object* value) {
        return Remove(value);
    }
    
    // Automatically generated method stub
    void Array::RemoveAt_dce190584913328b(int32_t index) {
        return RemoveAt(index);
    }
    
    // Automatically generated method stub
    Collections::IEnumerator* Array::GetEnumerator_674ad93a972a4d67() {
        return GetEnumerator();
    }
    
    // Automatically generated method stub
    int32_t Array::CompareTo_6a6cfba1da2bec3b(Object* other, Collections::IComparer* comparer) {
        return CompareTo(other, comparer);
    }
    
    // Automatically generated method stub
    bool Array::Equals_2f89738462b0fb33(Object* other, Collections::IEqualityComparer* comparer) {
        return Equals3(other, comparer);
    }
    
    // Automatically generated method stub
    int32_t Array::GetHashCode_94e84ad7bccbc132(Collections::IEqualityComparer* comparer) {
        return GetHashCode2(comparer);
    }
    
    // Automatically generated method stub
    Object* Array::Clone_d5efb96d327809c8() {
        return Clone();
    }
    
    // Automatically generated method stub
    void Array::CopyTo_7065a6e3cf6a140(Array* array, int32_t index) {
        return CopyTo(array, index);
    }
    
    // Automatically generated method stub
    Object* Array::get_Item_8550d21996ef9dc5(int32_t index) {
        return get_Item(index);
    }
    
    // Automatically generated method stub
    Object* Array::set_Item_d57705373e0668e7(int32_t index, Object* value) {
        return set_Item(index, value);
    }
    
    // Automatically generated method stub
    int32_t Array::get_Count_8f254f3dd8e2403() {
        return get_Count();
    }
    
    // Automatically generated method stub
    bool Array::get_IsSynchronized_20926e7dabc53dbf() {
        return get_IsSynchronized();
    }
    
    // Automatically generated method stub
    Object* Array::get_SyncRoot_257108f45cc89e19() {
        return get_SyncRoot();
    }
    
    // Automatically generated method stub
    bool Array::get_IsFixedSize_4d3eaee3435ee591() {
        return get_IsFixedSize();
    }
    
    // Automatically generated method stub
    bool Array::get_IsReadOnly_53b6e02d46187790() {
        return get_IsReadOnly();
    }
    
}
namespace System {
    // Automatically generated method stub
    void Attribute::GetIDsOfNames_9cccc850c227cee4(Guid riid, void* rgszNames, uint32_t cNames, uint32_t lcid, void* rgDispId) {
        return GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    }
    
    // Automatically generated method stub
    void Attribute::GetTypeInfo_21411d803e85bbb9(uint32_t iTInfo, uint32_t lcid, void* ppTInfo) {
        return GetTypeInfo(iTInfo, lcid, ppTInfo);
    }
    
    // Automatically generated method stub
    void Attribute::GetTypeInfoCount_b9a92feca41bb40d(uint32_t pcTInfo) {
        return GetTypeInfoCount(pcTInfo);
    }
    
    // Automatically generated method stub
    void Attribute::Invoke_3474b6c87defe10(uint32_t dispIdMember, Guid riid, uint32_t lcid, int16_t wFlags, void* pDispParams, void* pVarResult, void* pExcepInfo, void* puArgErr) {
        return Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    }
    
}
namespace System {
    // Automatically generated method stub
    void CharEnumerator::Dispose_95cb2516542c2f97() {
        return Dispose();
    }
    
    // Automatically generated method stub
    Object* CharEnumerator::Clone_d5efb96d327809c8() {
        return Clone();
    }
    
    // Automatically generated method stub
    bool CharEnumerator::MoveNext_4e78e145935f5417() {
        return MoveNext();
    }
    
    // Automatically generated method stub
    void CharEnumerator::Reset_bcd82381eed41868() {
        return Reset();
    }
    
    // Automatically generated method stub
    char16_t CharEnumerator::get_Current_9be2a11682d08be8() {
        return get_Current();
    }
    
    // Automatically generated method stub
    Object* CharEnumerator::get_Current_8eca9b3da02b123a() {
        return get_Current2();
    }
    
}
namespace System {
    // Automatically generated method stub
    void DBNull::GetObjectData_11b895a112e04409(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        return GetObjectData(info, context);
    }
    
    // Automatically generated method stub
    TypeCode DBNull::GetTypeCode_701c52aeb2913904() {
        return GetTypeCode();
    }
    
    // Automatically generated method stub
    bool DBNull::ToBoolean_f2ed021e3648bfba(IFormatProvider* provider) {
        return ToBoolean(provider);
    }
    
    // Automatically generated method stub
    unsigned char DBNull::ToByte_ce47dcc06c443b11(IFormatProvider* provider) {
        return ToByte(provider);
    }
    
    // Automatically generated method stub
    char16_t DBNull::ToChar_12adc960e23347fe(IFormatProvider* provider) {
        return ToChar(provider);
    }
    
    // Automatically generated method stub
    DateTime DBNull::ToDateTime_86b01e143a29eff2(IFormatProvider* provider) {
        return ToDateTime(provider);
    }
    
    // Automatically generated method stub
    Decimal DBNull::ToDecimal_9c02fd5cdb5f6a0c(IFormatProvider* provider) {
        return ToDecimal(provider);
    }
    
    // Automatically generated method stub
    double DBNull::ToDouble_bf8714f37f489c82(IFormatProvider* provider) {
        return ToDouble(provider);
    }
    
    // Automatically generated method stub
    int16_t DBNull::ToInt16_5e1de9bafa245bf2(IFormatProvider* provider) {
        return ToInt16(provider);
    }
    
    // Automatically generated method stub
    int32_t DBNull::ToInt32_9e7108d4c09b7e42(IFormatProvider* provider) {
        return ToInt32(provider);
    }
    
    // Automatically generated method stub
    int64_t DBNull::ToInt64_9801f9765e5301f6(IFormatProvider* provider) {
        return ToInt64(provider);
    }
    
    // Automatically generated method stub
    signed char DBNull::ToSByte_e1f09487d48936db(IFormatProvider* provider) {
        return ToSByte(provider);
    }
    
    // Automatically generated method stub
    float DBNull::ToSingle_1cfd1ce472f9fad6(IFormatProvider* provider) {
        return ToSingle(provider);
    }
    
    // Automatically generated method stub
    Object* DBNull::ToType_bf083accfb52550a(Type* targetType, IFormatProvider* provider) {
        return ToType(targetType, provider);
    }
    
    // Automatically generated method stub
    uint16_t DBNull::ToUInt16_1e02ae7e2827241a(IFormatProvider* provider) {
        return ToUInt16(provider);
    }
    
    // Automatically generated method stub
    uint32_t DBNull::ToUInt32_9a72f29c26115cfd(IFormatProvider* provider) {
        return ToUInt32(provider);
    }
    
    // Automatically generated method stub
    uint64_t DBNull::ToUInt64_fe563f2a802e4265(IFormatProvider* provider) {
        return ToUInt64(provider);
    }
    
    // Automatically generated method stub
    String* DBNull::ToString_f121fe9e066b5628(IFormatProvider* provider) {
        return ToString3(provider);
    }
    
}
namespace System {
    // Automatically generated method stub
    Object* Delegate::Clone_d5efb96d327809c8() {
        return Clone_ea12f3f395dbfa01();
    }
    
    // Automatically generated method stub
    void Delegate::GetObjectData_11b895a112e04409(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        return GetObjectData_e87c6354ab1f5b0(info, context);
    }
    
}
namespace System {
    // Automatically generated method stub
    void DelegateSerializationHolder::GetObjectData_11b895a112e04409(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        return GetObjectData(info, context);
    }
    
    // Automatically generated method stub
    Object* DelegateSerializationHolder::GetRealObject_692566897a6926e4(Runtime::Serialization::StreamingContext context) {
        return GetRealObject(context);
    }
    
}
namespace System {
    // Automatically generated method stub
    int32_t SByteComparer::Compare_451fd276747b629d(Object* x, Object* y) {
        return Compare(x, y);
    }
    
    // Automatically generated method stub
    int32_t SByteComparer::Compare_5902559f67a8cefa(signed char ix, signed char iy) {
        return Compare2(ix, iy);
    }
    
}
namespace System {
    // Automatically generated method stub
    int32_t ShortComparer::Compare_451fd276747b629d(Object* x, Object* y) {
        return Compare(x, y);
    }
    
    // Automatically generated method stub
    int32_t ShortComparer::Compare_5902559f67a8cefa(int16_t ix, int16_t iy) {
        return Compare2(ix, iy);
    }
    
}
namespace System {
    // Automatically generated method stub
    int32_t IntComparer::Compare_451fd276747b629d(Object* x, Object* y) {
        return Compare(x, y);
    }
    
    // Automatically generated method stub
    int32_t IntComparer::Compare_5902559f67a8cefa(int32_t ix, int32_t iy) {
        return Compare2(ix, iy);
    }
    
}
namespace System {
    // Automatically generated method stub
    int32_t LongComparer::Compare_451fd276747b629d(Object* x, Object* y) {
        return Compare(x, y);
    }
    
    // Automatically generated method stub
    int32_t LongComparer::Compare_5902559f67a8cefa(int64_t ix, int64_t iy) {
        return Compare2(ix, iy);
    }
    
}
namespace System {
    // Automatically generated method stub
    TypeCode Enum::GetTypeCode_701c52aeb2913904() {
        return GetTypeCode();
    }
    
    // Automatically generated method stub
    bool Enum::ToBoolean_f2ed021e3648bfba(IFormatProvider* provider) {
        return ToBoolean(provider);
    }
    
    // Automatically generated method stub
    unsigned char Enum::ToByte_ce47dcc06c443b11(IFormatProvider* provider) {
        return ToByte(provider);
    }
    
    // Automatically generated method stub
    char16_t Enum::ToChar_12adc960e23347fe(IFormatProvider* provider) {
        return ToChar(provider);
    }
    
    // Automatically generated method stub
    DateTime Enum::ToDateTime_86b01e143a29eff2(IFormatProvider* provider) {
        return ToDateTime(provider);
    }
    
    // Automatically generated method stub
    Decimal Enum::ToDecimal_9c02fd5cdb5f6a0c(IFormatProvider* provider) {
        return ToDecimal(provider);
    }
    
    // Automatically generated method stub
    double Enum::ToDouble_bf8714f37f489c82(IFormatProvider* provider) {
        return ToDouble(provider);
    }
    
    // Automatically generated method stub
    int16_t Enum::ToInt16_5e1de9bafa245bf2(IFormatProvider* provider) {
        return ToInt16(provider);
    }
    
    // Automatically generated method stub
    int32_t Enum::ToInt32_9e7108d4c09b7e42(IFormatProvider* provider) {
        return ToInt32(provider);
    }
    
    // Automatically generated method stub
    int64_t Enum::ToInt64_9801f9765e5301f6(IFormatProvider* provider) {
        return ToInt64(provider);
    }
    
    // Automatically generated method stub
    signed char Enum::ToSByte_e1f09487d48936db(IFormatProvider* provider) {
        return ToSByte(provider);
    }
    
    // Automatically generated method stub
    float Enum::ToSingle_1cfd1ce472f9fad6(IFormatProvider* provider) {
        return ToSingle(provider);
    }
    
    // Automatically generated method stub
    Object* Enum::ToType_bf083accfb52550a(Type* targetType, IFormatProvider* provider) {
        return ToType(targetType, provider);
    }
    
    // Automatically generated method stub
    uint16_t Enum::ToUInt16_1e02ae7e2827241a(IFormatProvider* provider) {
        return ToUInt16(provider);
    }
    
    // Automatically generated method stub
    uint32_t Enum::ToUInt32_9a72f29c26115cfd(IFormatProvider* provider) {
        return ToUInt32(provider);
    }
    
    // Automatically generated method stub
    uint64_t Enum::ToUInt64_fe563f2a802e4265(IFormatProvider* provider) {
        return ToUInt64(provider);
    }
    
    // Automatically generated method stub
    int32_t Enum::CompareTo_ed9d39205b7812f0(Object* target) {
        return CompareTo(target);
    }
    
    // Automatically generated method stub
    String* Enum::ToString_f121fe9e066b5628(IFormatProvider* provider) {
        return ToString3(provider);
    }
    
    // Automatically generated method stub
    String* Enum::ToString_91ad8e2580555a25(String* format, IFormatProvider* provider) {
        return ToString5(format, provider);
    }
    
}
namespace System {
    // Automatically generated method stub
    Exception* Exception::GetBaseException_253c3eebfe2fed4a() {
        return GetBaseException_3c80088934e2347b();
    }
    
    // Automatically generated method stub
    void Exception::GetObjectData_11b895a112e04409(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        return GetObjectData_bc9b88d7eb43b6d8(info, context);
    }
    
    // Automatically generated method stub
    void Exception::GetObjectData_cacfaf455dbef0a5(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        return GetObjectData_bc9b88d7eb43b6d8(info, context);
    }
    
    // Automatically generated method stub
    String* Exception::ToString_118e365de8f6791a() {
        return ToString_1636a0751cb9ac11();
    }
    
    // Automatically generated method stub
    Type* Exception::GetType_74b1e7e5e0897ded() {
        return GetType2();
    }
    
    // Automatically generated method stub
    Exception* Exception::get_InnerException_fee5e87d6404fbbb() {
        return get_InnerException();
    }
    
    // Automatically generated method stub
    String* Exception::get_HelpLink_c746e07ff3b23b1d() {
        return get_HelpLink_523fb8e8db786972();
    }
    
    // Automatically generated method stub
    String* Exception::set_HelpLink_c6d532780c9a4ffa(String* value) {
        return set_HelpLink_dc2ca9999b121201(value);
    }
    
    // Automatically generated method stub
    String* Exception::get_Message_236e49c6b265ab9b() {
        return get_Message_d211df4045b57cbf();
    }
    
    // Automatically generated method stub
    String* Exception::get_Source_1ad0ababbacddeca() {
        return get_Source_fe63b25bfdf963b9();
    }
    
    // Automatically generated method stub
    String* Exception::set_Source_593b7183e562d37d(String* value) {
        return set_Source_4a11d6bd5ca37e45(value);
    }
    
    // Automatically generated method stub
    String* Exception::get_StackTrace_eedb0499938735b7() {
        return get_StackTrace_f3fc28619b4f921();
    }
    
    // Automatically generated method stub
    Reflection::MethodBase* Exception::get_TargetSite_d5a44210796e0db() {
        return get_TargetSite();
    }
    
    // Automatically generated method stub
    bool Exception::Equals_8745d1c324afa9f2(Object* obj) {
        return Equals_ed975d2f4a7d193e(obj);
    }
    
    // Automatically generated method stub
    int32_t Exception::GetHashCode_3274e1baccc4f8d1() {
        return GetHashCode_6648aef0f235ee6c();
    }
    
}
namespace System {
    // Automatically generated method stub
    bool MonoType::IsSubclassOf_875608a6f6bc1b50(Type* type) {
        return IsSubclassOf_5d7dbe0215a30fda(type);
    }
    
    // Automatically generated method stub
    int32_t MonoType::GetArrayRank_bde6428644f11785() {
        return GetArrayRank_fccf91da5e4acf4f();
    }
    
    // Automatically generated method stub
    void MonoType::GetObjectData_11b895a112e04409(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        return GetObjectData(info, context);
    }
    
    // Automatically generated method stub
    String* MonoType::ToString_7ae6b85e974ee75a() {
        return ToString_1636a0751cb9ac11();
    }
    
    // Automatically generated method stub
    Reflection::MemberTypes MonoType::get_MemberType_49298b8bb0d10a74() {
        return get_MemberType_cd521d320810c98f();
    }
    
    // Automatically generated method stub
    Reflection::Module* MonoType::get_Module_e878d08348938612() {
        return get_Module_ea7d65dc88202263();
    }
    
    // Automatically generated method stub
    Type* MonoType::get_DeclaringType_57e85ec7caa4a7e9() {
        return get_DeclaringType_6121cd6a84393166();
    }
    
    // Automatically generated method stub
    Type* MonoType::get_ReflectedType_338a78c0f78949() {
        return get_ReflectedType_bf4971c0f442b9dc();
    }
    
    // Automatically generated method stub
    RuntimeTypeHandle MonoType::get_TypeHandle_a660506a2c0cc3d5() {
        return get_TypeHandle_a14995fa9102936b();
    }
    
}
namespace System {
    // Automatically generated method stub
    void NullConsoleDriver::Beep_1da4596cc175b056(int32_t frequency, int32_t duration) {
        return Beep(frequency, duration);
    }
    
    // Automatically generated method stub
    void NullConsoleDriver::Clear_f1b4f6af283cc2c9() {
        return Clear();
    }
    
    // Automatically generated method stub
    void NullConsoleDriver::MoveBufferArea_5b90e28706eb2f21(int32_t sourceLeft, int32_t sourceTop, int32_t sourceWidth, int32_t sourceHeight, int32_t targetLeft, int32_t targetTop, char16_t sourceChar, ConsoleColor sourceForeColor, ConsoleColor sourceBackColor) {
        return MoveBufferArea(sourceLeft, sourceTop, sourceWidth, sourceHeight, targetLeft, targetTop, sourceChar, sourceForeColor, sourceBackColor);
    }
    
    // Automatically generated method stub
    void NullConsoleDriver::Init_c5426ee2900a294b() {
        return Init();
    }
    
    // Automatically generated method stub
    String* NullConsoleDriver::ReadLine_d9726d4d34f7f3c0() {
        return ReadLine();
    }
    
    // Automatically generated method stub
    ConsoleKeyInfo NullConsoleDriver::ReadKey_6a3b7aab317c85ed(bool intercept) {
        return ReadKey(intercept);
    }
    
    // Automatically generated method stub
    void NullConsoleDriver::ResetColor_8f6250a6a6d78789() {
        return ResetColor();
    }
    
    // Automatically generated method stub
    void NullConsoleDriver::SetBufferSize_343d697c2e12d0db(int32_t width, int32_t height) {
        return SetBufferSize(width, height);
    }
    
    // Automatically generated method stub
    void NullConsoleDriver::SetCursorPosition_1b5796b8c190ffa5(int32_t left, int32_t top) {
        return SetCursorPosition(left, top);
    }
    
    // Automatically generated method stub
    void NullConsoleDriver::SetWindowPosition_cd2b9c3f7be414da(int32_t left, int32_t top) {
        return SetWindowPosition(left, top);
    }
    
    // Automatically generated method stub
    void NullConsoleDriver::SetWindowSize_4cfb33f333b34cf(int32_t width, int32_t height) {
        return SetWindowSize(width, height);
    }
    
    // Automatically generated method stub
    ConsoleColor NullConsoleDriver::get_BackgroundColor_c9fafb327ddb8be6() {
        return get_BackgroundColor();
    }
    
    // Automatically generated method stub
    ConsoleColor NullConsoleDriver::set_BackgroundColor_344fac019c9386b1(ConsoleColor value) {
        return set_BackgroundColor(value);
    }
    
    // Automatically generated method stub
    int32_t NullConsoleDriver::get_BufferHeight_37934843c5ad875e() {
        return get_BufferHeight();
    }
    
    // Automatically generated method stub
    int32_t NullConsoleDriver::set_BufferHeight_5d535a7eaee8afa7(int32_t value) {
        return set_BufferHeight(value);
    }
    
    // Automatically generated method stub
    int32_t NullConsoleDriver::get_BufferWidth_4e39d049ce05cb10() {
        return get_BufferWidth();
    }
    
    // Automatically generated method stub
    int32_t NullConsoleDriver::set_BufferWidth_ba768a1fb5af86f3(int32_t value) {
        return set_BufferWidth(value);
    }
    
    // Automatically generated method stub
    bool NullConsoleDriver::get_CapsLock_5c626ee325707d5c() {
        return get_CapsLock();
    }
    
    // Automatically generated method stub
    int32_t NullConsoleDriver::get_CursorLeft_a1045160a5e0c167() {
        return get_CursorLeft();
    }
    
    // Automatically generated method stub
    int32_t NullConsoleDriver::set_CursorLeft_58812b936675567d(int32_t value) {
        return set_CursorLeft(value);
    }
    
    // Automatically generated method stub
    int32_t NullConsoleDriver::get_CursorSize_c23bb8efe316d434() {
        return get_CursorSize();
    }
    
    // Automatically generated method stub
    int32_t NullConsoleDriver::set_CursorSize_f0834eb8266a5be6(int32_t value) {
        return set_CursorSize(value);
    }
    
    // Automatically generated method stub
    int32_t NullConsoleDriver::get_CursorTop_529e091e36331015() {
        return get_CursorTop();
    }
    
    // Automatically generated method stub
    int32_t NullConsoleDriver::set_CursorTop_785544d75b1c0bee(int32_t value) {
        return set_CursorTop(value);
    }
    
    // Automatically generated method stub
    bool NullConsoleDriver::get_CursorVisible_56c3cc5601135b6f() {
        return get_CursorVisible();
    }
    
    // Automatically generated method stub
    bool NullConsoleDriver::set_CursorVisible_cf1ec653cdd99e69(bool value) {
        return set_CursorVisible(value);
    }
    
    // Automatically generated method stub
    ConsoleColor NullConsoleDriver::get_ForegroundColor_7612ec7b8c8aaaa5() {
        return get_ForegroundColor();
    }
    
    // Automatically generated method stub
    ConsoleColor NullConsoleDriver::set_ForegroundColor_940cb65e8fef1858(ConsoleColor value) {
        return set_ForegroundColor(value);
    }
    
    // Automatically generated method stub
    bool NullConsoleDriver::get_KeyAvailable_484cd75e08a09869() {
        return get_KeyAvailable();
    }
    
    // Automatically generated method stub
    bool NullConsoleDriver::get_Initialized_317ffc50d17896d3() {
        return get_Initialized();
    }
    
    // Automatically generated method stub
    int32_t NullConsoleDriver::get_LargestWindowHeight_e89fef87df5ea56d() {
        return get_LargestWindowHeight();
    }
    
    // Automatically generated method stub
    int32_t NullConsoleDriver::get_LargestWindowWidth_6d2cf275eb651738() {
        return get_LargestWindowWidth();
    }
    
    // Automatically generated method stub
    bool NullConsoleDriver::get_NumberLock_9e29453ae6b2f675() {
        return get_NumberLock();
    }
    
    // Automatically generated method stub
    String* NullConsoleDriver::get_Title_297f109429139f1f() {
        return get_Title();
    }
    
    // Automatically generated method stub
    String* NullConsoleDriver::set_Title_5ffd8093a2ce14e8(String* value) {
        return set_Title(value);
    }
    
    // Automatically generated method stub
    bool NullConsoleDriver::get_TreatControlCAsInput_724ae746e19a1372() {
        return get_TreatControlCAsInput();
    }
    
    // Automatically generated method stub
    bool NullConsoleDriver::set_TreatControlCAsInput_22e3ed8b8ed195e4(bool value) {
        return set_TreatControlCAsInput(value);
    }
    
    // Automatically generated method stub
    int32_t NullConsoleDriver::get_WindowHeight_d105cfc0640e021b() {
        return get_WindowHeight();
    }
    
    // Automatically generated method stub
    int32_t NullConsoleDriver::set_WindowHeight_762a4dd6c7316c83(int32_t value) {
        return set_WindowHeight(value);
    }
    
    // Automatically generated method stub
    int32_t NullConsoleDriver::get_WindowLeft_2e939ca75d6696f7() {
        return get_WindowLeft();
    }
    
    // Automatically generated method stub
    int32_t NullConsoleDriver::set_WindowLeft_6b1bb1c980db7ca6(int32_t value) {
        return set_WindowLeft(value);
    }
    
    // Automatically generated method stub
    int32_t NullConsoleDriver::get_WindowTop_869e53cfc4194ff6() {
        return get_WindowTop();
    }
    
    // Automatically generated method stub
    int32_t NullConsoleDriver::set_WindowTop_6ed3579f04406446(int32_t value) {
        return set_WindowTop(value);
    }
    
    // Automatically generated method stub
    int32_t NullConsoleDriver::get_WindowWidth_aaf18af655c54aa3() {
        return get_WindowWidth();
    }
    
    // Automatically generated method stub
    int32_t NullConsoleDriver::set_WindowWidth_34776e6c3b72e222(int32_t value) {
        return set_WindowWidth(value);
    }
    
}
namespace System {
    // Automatically generated method stub
    Object* OperatingSystem::Clone_d5efb96d327809c8() {
        return Clone();
    }
    
    // Automatically generated method stub
    void OperatingSystem::GetObjectData_11b895a112e04409(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        return GetObjectData(info, context);
    }
    
}
namespace System {
    // Automatically generated method stub
    bool String::Equals_ea48fd0c13a733fe(String* value) {
        return Equals5(value);
    }
    
    // Automatically generated method stub
    Object* String::Clone_d5efb96d327809c8() {
        return Clone();
    }
    
    // Automatically generated method stub
    TypeCode String::GetTypeCode_701c52aeb2913904() {
        return GetTypeCode();
    }
    
    // Automatically generated method stub
    int32_t String::CompareTo_ed9d39205b7812f0(Object* value) {
        return CompareTo(value);
    }
    
    // Automatically generated method stub
    int32_t String::CompareTo_8a8b7d6c83beb422(String* strB) {
        return CompareTo2(strB);
    }
    
    // Automatically generated method stub
    String* String::ToString_f121fe9e066b5628(IFormatProvider* provider) {
        return ToString3(provider);
    }
    
    // Automatically generated method stub
    bool String::ToBoolean_f2ed021e3648bfba(IFormatProvider* provider) {
        return ToBoolean(provider);
    }
    
    // Automatically generated method stub
    unsigned char String::ToByte_ce47dcc06c443b11(IFormatProvider* provider) {
        return ToByte(provider);
    }
    
    // Automatically generated method stub
    char16_t String::ToChar_12adc960e23347fe(IFormatProvider* provider) {
        return ToChar(provider);
    }
    
    // Automatically generated method stub
    DateTime String::ToDateTime_86b01e143a29eff2(IFormatProvider* provider) {
        return ToDateTime(provider);
    }
    
    // Automatically generated method stub
    Decimal String::ToDecimal_9c02fd5cdb5f6a0c(IFormatProvider* provider) {
        return ToDecimal(provider);
    }
    
    // Automatically generated method stub
    double String::ToDouble_bf8714f37f489c82(IFormatProvider* provider) {
        return ToDouble(provider);
    }
    
    // Automatically generated method stub
    int16_t String::ToInt16_5e1de9bafa245bf2(IFormatProvider* provider) {
        return ToInt16(provider);
    }
    
    // Automatically generated method stub
    int32_t String::ToInt32_9e7108d4c09b7e42(IFormatProvider* provider) {
        return ToInt32(provider);
    }
    
    // Automatically generated method stub
    int64_t String::ToInt64_9801f9765e5301f6(IFormatProvider* provider) {
        return ToInt64(provider);
    }
    
    // Automatically generated method stub
    signed char String::ToSByte_e1f09487d48936db(IFormatProvider* provider) {
        return ToSByte(provider);
    }
    
    // Automatically generated method stub
    float String::ToSingle_1cfd1ce472f9fad6(IFormatProvider* provider) {
        return ToSingle(provider);
    }
    
    // Automatically generated method stub
    Object* String::ToType_bf083accfb52550a(Type* targetType, IFormatProvider* provider) {
        return ToType(targetType, provider);
    }
    
    // Automatically generated method stub
    uint16_t String::ToUInt16_1e02ae7e2827241a(IFormatProvider* provider) {
        return ToUInt16(provider);
    }
    
    // Automatically generated method stub
    uint32_t String::ToUInt32_9a72f29c26115cfd(IFormatProvider* provider) {
        return ToUInt32(provider);
    }
    
    // Automatically generated method stub
    uint64_t String::ToUInt64_fe563f2a802e4265(IFormatProvider* provider) {
        return ToUInt64(provider);
    }
    
    // Automatically generated method stub
    Collections::Generic::IEnumerator2<char16_t>* String::GetEnumerator_ad4887f30f9e4c5() {
        return GetEnumerator2();
    }
    
    // Automatically generated method stub
    Collections::IEnumerator* String::GetEnumerator_674ad93a972a4d67() {
        return GetEnumerator3();
    }
    
}
namespace System {
    // Automatically generated method stub
    int32_t StringComparer::Compare_451fd276747b629d(Object* x, Object* y) {
        return Compare(x, y);
    }
    
    // Automatically generated method stub
    bool StringComparer::Equals_ad190887ea91ded(Object* x, Object* y) {
        return Equals3(x, y);
    }
    
    // Automatically generated method stub
    int32_t StringComparer::GetHashCode_f8793dfb2b096a5a(Object* obj) {
        return GetHashCode2(obj);
    }
    
    // Automatically generated method stub
    int32_t StringComparer::Compare_5902559f67a8cefa(String* x, String* y) {
        return Compare_aa3d1bf936762ace(x, y);
    }
    
    // Automatically generated method stub
    bool StringComparer::Equals_f783e5e22b72a1c0(String* x, String* y) {
        return Equals_34b0513c0e663568(x, y);
    }
    
    // Automatically generated method stub
    int32_t StringComparer::GetHashCode_74f46a6b01295dbe(String* obj) {
        return GetHashCode_c89a0097b5036ad3(obj);
    }
    
}
namespace System {
    // Automatically generated method stub
    void TermInfoDriver::Init_c5426ee2900a294b() {
        return Init();
    }
    
    // Automatically generated method stub
    void TermInfoDriver::Clear_f1b4f6af283cc2c9() {
        return Clear();
    }
    
    // Automatically generated method stub
    void TermInfoDriver::Beep_1da4596cc175b056(int32_t frequency, int32_t duration) {
        return Beep(frequency, duration);
    }
    
    // Automatically generated method stub
    void TermInfoDriver::MoveBufferArea_5b90e28706eb2f21(int32_t sourceLeft, int32_t sourceTop, int32_t sourceWidth, int32_t sourceHeight, int32_t targetLeft, int32_t targetTop, char16_t sourceChar, ConsoleColor sourceForeColor, ConsoleColor sourceBackColor) {
        return MoveBufferArea(sourceLeft, sourceTop, sourceWidth, sourceHeight, targetLeft, targetTop, sourceChar, sourceForeColor, sourceBackColor);
    }
    
    // Automatically generated method stub
    ConsoleKeyInfo TermInfoDriver::ReadKey_6a3b7aab317c85ed(bool intercept) {
        return ReadKey(intercept);
    }
    
    // Automatically generated method stub
    String* TermInfoDriver::ReadLine_d9726d4d34f7f3c0() {
        return ReadLine();
    }
    
    // Automatically generated method stub
    void TermInfoDriver::ResetColor_8f6250a6a6d78789() {
        return ResetColor();
    }
    
    // Automatically generated method stub
    void TermInfoDriver::SetBufferSize_343d697c2e12d0db(int32_t width, int32_t height) {
        return SetBufferSize(width, height);
    }
    
    // Automatically generated method stub
    void TermInfoDriver::SetCursorPosition_1b5796b8c190ffa5(int32_t left, int32_t top) {
        return SetCursorPosition(left, top);
    }
    
    // Automatically generated method stub
    void TermInfoDriver::SetWindowPosition_cd2b9c3f7be414da(int32_t left, int32_t top) {
        return SetWindowPosition(left, top);
    }
    
    // Automatically generated method stub
    void TermInfoDriver::SetWindowSize_4cfb33f333b34cf(int32_t width, int32_t height) {
        return SetWindowSize(width, height);
    }
    
    // Automatically generated method stub
    bool TermInfoDriver::get_Initialized_317ffc50d17896d3() {
        return get_Initialized();
    }
    
    // Automatically generated method stub
    ConsoleColor TermInfoDriver::get_BackgroundColor_c9fafb327ddb8be6() {
        return get_BackgroundColor();
    }
    
    // Automatically generated method stub
    ConsoleColor TermInfoDriver::set_BackgroundColor_344fac019c9386b1(ConsoleColor value) {
        return set_BackgroundColor(value);
    }
    
    // Automatically generated method stub
    ConsoleColor TermInfoDriver::get_ForegroundColor_7612ec7b8c8aaaa5() {
        return get_ForegroundColor();
    }
    
    // Automatically generated method stub
    ConsoleColor TermInfoDriver::set_ForegroundColor_940cb65e8fef1858(ConsoleColor value) {
        return set_ForegroundColor(value);
    }
    
    // Automatically generated method stub
    int32_t TermInfoDriver::get_BufferHeight_37934843c5ad875e() {
        return get_BufferHeight();
    }
    
    // Automatically generated method stub
    int32_t TermInfoDriver::set_BufferHeight_5d535a7eaee8afa7(int32_t value) {
        return set_BufferHeight(value);
    }
    
    // Automatically generated method stub
    int32_t TermInfoDriver::get_BufferWidth_4e39d049ce05cb10() {
        return get_BufferWidth();
    }
    
    // Automatically generated method stub
    int32_t TermInfoDriver::set_BufferWidth_ba768a1fb5af86f3(int32_t value) {
        return set_BufferWidth(value);
    }
    
    // Automatically generated method stub
    bool TermInfoDriver::get_CapsLock_5c626ee325707d5c() {
        return get_CapsLock();
    }
    
    // Automatically generated method stub
    int32_t TermInfoDriver::get_CursorLeft_a1045160a5e0c167() {
        return get_CursorLeft();
    }
    
    // Automatically generated method stub
    int32_t TermInfoDriver::set_CursorLeft_58812b936675567d(int32_t value) {
        return set_CursorLeft(value);
    }
    
    // Automatically generated method stub
    int32_t TermInfoDriver::get_CursorTop_529e091e36331015() {
        return get_CursorTop();
    }
    
    // Automatically generated method stub
    int32_t TermInfoDriver::set_CursorTop_785544d75b1c0bee(int32_t value) {
        return set_CursorTop(value);
    }
    
    // Automatically generated method stub
    bool TermInfoDriver::get_CursorVisible_56c3cc5601135b6f() {
        return get_CursorVisible();
    }
    
    // Automatically generated method stub
    bool TermInfoDriver::set_CursorVisible_cf1ec653cdd99e69(bool value) {
        return set_CursorVisible(value);
    }
    
    // Automatically generated method stub
    int32_t TermInfoDriver::get_CursorSize_c23bb8efe316d434() {
        return get_CursorSize();
    }
    
    // Automatically generated method stub
    int32_t TermInfoDriver::set_CursorSize_f0834eb8266a5be6(int32_t value) {
        return set_CursorSize(value);
    }
    
    // Automatically generated method stub
    bool TermInfoDriver::get_KeyAvailable_484cd75e08a09869() {
        return get_KeyAvailable();
    }
    
    // Automatically generated method stub
    int32_t TermInfoDriver::get_LargestWindowHeight_e89fef87df5ea56d() {
        return get_LargestWindowHeight();
    }
    
    // Automatically generated method stub
    int32_t TermInfoDriver::get_LargestWindowWidth_6d2cf275eb651738() {
        return get_LargestWindowWidth();
    }
    
    // Automatically generated method stub
    bool TermInfoDriver::get_NumberLock_9e29453ae6b2f675() {
        return get_NumberLock();
    }
    
    // Automatically generated method stub
    String* TermInfoDriver::get_Title_297f109429139f1f() {
        return get_Title();
    }
    
    // Automatically generated method stub
    String* TermInfoDriver::set_Title_5ffd8093a2ce14e8(String* value) {
        return set_Title(value);
    }
    
    // Automatically generated method stub
    bool TermInfoDriver::get_TreatControlCAsInput_724ae746e19a1372() {
        return get_TreatControlCAsInput();
    }
    
    // Automatically generated method stub
    bool TermInfoDriver::set_TreatControlCAsInput_22e3ed8b8ed195e4(bool value) {
        return set_TreatControlCAsInput(value);
    }
    
    // Automatically generated method stub
    int32_t TermInfoDriver::get_WindowHeight_d105cfc0640e021b() {
        return get_WindowHeight();
    }
    
    // Automatically generated method stub
    int32_t TermInfoDriver::set_WindowHeight_762a4dd6c7316c83(int32_t value) {
        return set_WindowHeight(value);
    }
    
    // Automatically generated method stub
    int32_t TermInfoDriver::get_WindowLeft_2e939ca75d6696f7() {
        return get_WindowLeft();
    }
    
    // Automatically generated method stub
    int32_t TermInfoDriver::set_WindowLeft_6b1bb1c980db7ca6(int32_t value) {
        return set_WindowLeft(value);
    }
    
    // Automatically generated method stub
    int32_t TermInfoDriver::get_WindowTop_869e53cfc4194ff6() {
        return get_WindowTop();
    }
    
    // Automatically generated method stub
    int32_t TermInfoDriver::set_WindowTop_6ed3579f04406446(int32_t value) {
        return set_WindowTop(value);
    }
    
    // Automatically generated method stub
    int32_t TermInfoDriver::get_WindowWidth_aaf18af655c54aa3() {
        return get_WindowWidth();
    }
    
    // Automatically generated method stub
    int32_t TermInfoDriver::set_WindowWidth_34776e6c3b72e222(int32_t value) {
        return set_WindowWidth(value);
    }
    
}
namespace System {
    // Automatically generated method stub
    void CurrentSystemTimeZone::OnDeserialization_e9ecfecba8df9754(Object* sender) {
        return OnDeserialization(sender);
    }
    
}
namespace System {
}
namespace System {
}
namespace System {
}
namespace System {
}
namespace System {
}
namespace System {
}
namespace System {
}
namespace System {
}
namespace System {
    // Automatically generated method stub
    bool Type::Equals_b601c5aff370bd09(Object* o) {
        return Equals_ed975d2f4a7d193e(o);
    }
    
    // Automatically generated method stub
    bool Type::Equals_fbde14dc9bfbbb61(Type* o) {
        return Equals_f28141a5881cf9e3(o);
    }
    
    // Automatically generated method stub
    Type* Type::GetType_23d99c756b44b0a3() {
        return GetType7();
    }
    
    // Automatically generated method stub
    bool Type::IsSubclassOf_875608a6f6bc1b50(Type* c) {
        return IsSubclassOf_5d7dbe0215a30fda(c);
    }
    
    // Automatically generated method stub
    cli::array<Type*>* Type::FindInterfaces_cc61f456dced52b8(Reflection::TypeFilter* filter, Object* filterCriteria) {
        return FindInterfaces_7c9fc57cf4c9255f(filter, filterCriteria);
    }
    
    // Automatically generated method stub
    Type* Type::GetInterface_ac6ba302ad01659f(String* name) {
        return GetInterface(name);
    }
    
    // Automatically generated method stub
    Type* Type::GetInterface_7be137fec4604233(String* name, bool ignoreCase) {
        return GetInterface_55c1d0ec3ece6104(name, ignoreCase);
    }
    
    // Automatically generated method stub
    Reflection::InterfaceMapping Type::GetInterfaceMap_1dcbd2012c18f488(Type* interfaceType) {
        return GetInterfaceMap_26193b1c1167fea4(interfaceType);
    }
    
    // Automatically generated method stub
    cli::array<Type*>* Type::GetInterfaces_f4761baf7daf0c63() {
        return GetInterfaces_52a89380e2c4a725();
    }
    
    // Automatically generated method stub
    bool Type::IsAssignableFrom_9a1536c9f0047a78(Type* c) {
        return IsAssignableFrom_e3aa32d778e63a90(c);
    }
    
    // Automatically generated method stub
    bool Type::IsInstanceOfType_8a17c36f331ce12e(Object* o) {
        return IsInstanceOfType_bd709d8c55b4333d(o);
    }
    
    // Automatically generated method stub
    int32_t Type::GetArrayRank_bde6428644f11785() {
        return GetArrayRank_fccf91da5e4acf4f();
    }
    
    // Automatically generated method stub
    Type* Type::GetElementType_7c511ae38a3cf1dd() {
        return GetElementType_ab5070dbbfe66f5f();
    }
    
    // Automatically generated method stub
    Reflection::EventInfo* Type::GetEvent_76dff11bf999273b(String* name) {
        return GetEvent(name);
    }
    
    // Automatically generated method stub
    Reflection::EventInfo* Type::GetEvent_f4929934b063c380(String* name, Reflection::BindingFlags bindingAttr) {
        return GetEvent_7f053fa54114e387(name, bindingAttr);
    }
    
    // Automatically generated method stub
    cli::array<Reflection::EventInfo*>* Type::GetEvents_1787f024dc60b66d() {
        return GetEvents_e6858c959b77de38();
    }
    
    // Automatically generated method stub
    cli::array<Reflection::EventInfo*>* Type::GetEvents_3631c7eff1e31bf4(Reflection::BindingFlags bindingAttr) {
        return GetEvents_a960b087e4d67be2(bindingAttr);
    }
    
    // Automatically generated method stub
    Reflection::FieldInfo* Type::GetField_730851a2c91db280(String* name) {
        return GetField(name);
    }
    
    // Automatically generated method stub
    Reflection::FieldInfo* Type::GetField_a38d5b9730c691a2(String* name, Reflection::BindingFlags bindingAttr) {
        return GetField_fb08cba9d1a4bc84(name, bindingAttr);
    }
    
    // Automatically generated method stub
    Reflection::FieldInfo* Type::GetField_32b52cad7c24495e(String* name, Reflection::BindingFlags bindingAttr) {
        return GetField_fb08cba9d1a4bc84(name, bindingAttr);
    }
    
    // Automatically generated method stub
    cli::array<Reflection::FieldInfo*>* Type::GetFields_824511730a8c3391() {
        return GetFields();
    }
    
    // Automatically generated method stub
    cli::array<Reflection::FieldInfo*>* Type::GetFields_102264d5de9b86f1(Reflection::BindingFlags bindingAttr) {
        return GetFields_369be5ac49d99f8(bindingAttr);
    }
    
    // Automatically generated method stub
    cli::array<Reflection::FieldInfo*>* Type::GetFields_3b6671910689216f(Reflection::BindingFlags bindingAttr) {
        return GetFields_369be5ac49d99f8(bindingAttr);
    }
    
    // Automatically generated method stub
    int32_t Type::GetHashCode_4319178217300f32() {
        return GetHashCode_6648aef0f235ee6c();
    }
    
    // Automatically generated method stub
    cli::array<Reflection::MemberInfo*>* Type::GetMember_e42ea39164747c31(String* name) {
        return GetMember(name);
    }
    
    // Automatically generated method stub
    cli::array<Reflection::MemberInfo*>* Type::GetMember_751a2f44650ce57a(String* name, Reflection::BindingFlags bindingAttr) {
        return GetMember_1a3f3c5f72801016(name, bindingAttr);
    }
    
    // Automatically generated method stub
    cli::array<Reflection::MemberInfo*>* Type::GetMember_26f247b06fc8dab4(String* name, Reflection::BindingFlags bindingAttr) {
        return GetMember_1a3f3c5f72801016(name, bindingAttr);
    }
    
    // Automatically generated method stub
    cli::array<Reflection::MemberInfo*>* Type::GetMember_aba72a46394724d6(String* name, Reflection::MemberTypes type, Reflection::BindingFlags bindingAttr) {
        return GetMember_9c934e7384b805e1(name, type, bindingAttr);
    }
    
    // Automatically generated method stub
    cli::array<Reflection::MemberInfo*>* Type::GetMembers_ceb13fc59a9ba706() {
        return GetMembers();
    }
    
    // Automatically generated method stub
    cli::array<Reflection::MemberInfo*>* Type::GetMembers_2f15454515090881(Reflection::BindingFlags bindingAttr) {
        return GetMembers_54432b0ff6e99174(bindingAttr);
    }
    
    // Automatically generated method stub
    cli::array<Reflection::MemberInfo*>* Type::GetMembers_e9c5edc4e36bff42(Reflection::BindingFlags bindingAttr) {
        return GetMembers_54432b0ff6e99174(bindingAttr);
    }
    
    // Automatically generated method stub
    Reflection::MethodInfo* Type::GetMethod_ef3f1bc04f29b7c7(String* name) {
        return GetMethod(name);
    }
    
    // Automatically generated method stub
    Reflection::MethodInfo* Type::GetMethod_4cb6db7e284e0ff0(String* name, Reflection::BindingFlags bindingAttr) {
        return GetMethod2(name, bindingAttr);
    }
    
    // Automatically generated method stub
    Reflection::MethodInfo* Type::GetMethod_20d1acffc16ce2dd(String* name, Reflection::BindingFlags bindingAttr) {
        return GetMethod2(name, bindingAttr);
    }
    
    // Automatically generated method stub
    Reflection::MethodInfo* Type::GetMethod_5f5fb2fe366cd5a1(String* name, cli::array<Type*>* types) {
        return GetMethod3(name, types);
    }
    
    // Automatically generated method stub
    Reflection::MethodInfo* Type::GetMethod_10845bf939e924bf(String* name, cli::array<Type*>* types, cli::array<Reflection::ParameterModifier>* modifiers) {
        return GetMethod4(name, types, modifiers);
    }
    
    // Automatically generated method stub
    Reflection::MethodInfo* Type::GetMethod_2a24f5133b340750(String* name, Reflection::BindingFlags bindingAttr, Reflection::Binder* binder, cli::array<Type*>* types, cli::array<Reflection::ParameterModifier>* modifiers) {
        return GetMethod5(name, bindingAttr, binder, types, modifiers);
    }
    
    // Automatically generated method stub
    Reflection::MethodInfo* Type::GetMethod_4d293e0e4590fe7d(String* name, Reflection::BindingFlags bindingAttr, Reflection::Binder* binder, cli::array<Type*>* types, cli::array<Reflection::ParameterModifier>* modifiers) {
        return GetMethod5(name, bindingAttr, binder, types, modifiers);
    }
    
    // Automatically generated method stub
    Reflection::MethodInfo* Type::GetMethod_5f9f14eaeb118d7b(String* name, Reflection::BindingFlags bindingAttr, Reflection::Binder* binder, Reflection::CallingConventions callConvention, cli::array<Type*>* types, cli::array<Reflection::ParameterModifier>* modifiers) {
        return GetMethod6(name, bindingAttr, binder, callConvention, types, modifiers);
    }
    
    // Automatically generated method stub
    cli::array<Reflection::MethodInfo*>* Type::GetMethods_58a478b465f48979() {
        return GetMethods();
    }
    
    // Automatically generated method stub
    cli::array<Reflection::MethodInfo*>* Type::GetMethods_f9b63250be2babdf(Reflection::BindingFlags bindingAttr) {
        return GetMethods_c5b4e5d4877e6672(bindingAttr);
    }
    
    // Automatically generated method stub
    cli::array<Reflection::MethodInfo*>* Type::GetMethods_96cc2e24fcfb6e62(Reflection::BindingFlags bindingAttr) {
        return GetMethods_c5b4e5d4877e6672(bindingAttr);
    }
    
    // Automatically generated method stub
    Type* Type::GetNestedType_f4393ee24e74e70b(String* name) {
        return GetNestedType(name);
    }
    
    // Automatically generated method stub
    Type* Type::GetNestedType_e1baae72ba6bf4ba(String* name, Reflection::BindingFlags bindingAttr) {
        return GetNestedType_31962c16c0c85df9(name, bindingAttr);
    }
    
    // Automatically generated method stub
    cli::array<Type*>* Type::GetNestedTypes_d3461c94611a386d() {
        return GetNestedTypes();
    }
    
    // Automatically generated method stub
    cli::array<Type*>* Type::GetNestedTypes_28d6d3c45672aa03(Reflection::BindingFlags bindingAttr) {
        return GetNestedTypes_bb6ee40b0fa4052d(bindingAttr);
    }
    
    // Automatically generated method stub
    cli::array<Reflection::PropertyInfo*>* Type::GetProperties_524e20c86b55e01b() {
        return GetProperties();
    }
    
    // Automatically generated method stub
    cli::array<Reflection::PropertyInfo*>* Type::GetProperties_fdc96296e396cb0a(Reflection::BindingFlags bindingAttr) {
        return GetProperties_9fb6c40e3662fdd7(bindingAttr);
    }
    
    // Automatically generated method stub
    cli::array<Reflection::PropertyInfo*>* Type::GetProperties_258aba425d2e86c3(Reflection::BindingFlags bindingAttr) {
        return GetProperties_9fb6c40e3662fdd7(bindingAttr);
    }
    
    // Automatically generated method stub
    Reflection::PropertyInfo* Type::GetProperty_d627a5a0d51dd70b(String* name) {
        return GetProperty(name);
    }
    
    // Automatically generated method stub
    Reflection::PropertyInfo* Type::GetProperty_31c8ed7c4a9fe18(String* name, Reflection::BindingFlags bindingAttr) {
        return GetProperty2(name, bindingAttr);
    }
    
    // Automatically generated method stub
    Reflection::PropertyInfo* Type::GetProperty_b31c91fe8fcd19f(String* name, Reflection::BindingFlags bindingAttr) {
        return GetProperty2(name, bindingAttr);
    }
    
    // Automatically generated method stub
    Reflection::PropertyInfo* Type::GetProperty_62acdac6dfff671d(String* name, Type* returnType) {
        return GetProperty3(name, returnType);
    }
    
    // Automatically generated method stub
    Reflection::PropertyInfo* Type::GetProperty_3a45ef4884be27fe(String* name, cli::array<Type*>* types) {
        return GetProperty4(name, types);
    }
    
    // Automatically generated method stub
    Reflection::PropertyInfo* Type::GetProperty_5051f9f79bcf85eb(String* name, Type* returnType, cli::array<Type*>* types) {
        return GetProperty5(name, returnType, types);
    }
    
    // Automatically generated method stub
    Reflection::PropertyInfo* Type::GetProperty_f0ce52c3a74ba259(String* name, Type* returnType, cli::array<Type*>* types, cli::array<Reflection::ParameterModifier>* modifiers) {
        return GetProperty6(name, returnType, types, modifiers);
    }
    
    // Automatically generated method stub
    Reflection::PropertyInfo* Type::GetProperty_30e763aad46f8c31(String* name, Reflection::BindingFlags bindingAttr, Reflection::Binder* binder, Type* returnType, cli::array<Type*>* types, cli::array<Reflection::ParameterModifier>* modifiers) {
        return GetProperty7(name, bindingAttr, binder, returnType, types, modifiers);
    }
    
    // Automatically generated method stub
    Reflection::PropertyInfo* Type::GetProperty_af47392d20071603(String* name, Reflection::BindingFlags bindingAttr, Reflection::Binder* binder, Type* returnType, cli::array<Type*>* types, cli::array<Reflection::ParameterModifier>* modifiers) {
        return GetProperty7(name, bindingAttr, binder, returnType, types, modifiers);
    }
    
    // Automatically generated method stub
    Reflection::ConstructorInfo* Type::GetConstructor_7676b5cd22df9bc5(cli::array<Type*>* types) {
        return GetConstructor2(types);
    }
    
    // Automatically generated method stub
    Reflection::ConstructorInfo* Type::GetConstructor_615af0546552ac12(Reflection::BindingFlags bindingAttr, Reflection::Binder* binder, cli::array<Type*>* types, cli::array<Reflection::ParameterModifier>* modifiers) {
        return GetConstructor3(bindingAttr, binder, types, modifiers);
    }
    
    // Automatically generated method stub
    Reflection::ConstructorInfo* Type::GetConstructor_ac50bab303a728a7(Reflection::BindingFlags bindingAttr, Reflection::Binder* binder, Reflection::CallingConventions callConvention, cli::array<Type*>* types, cli::array<Reflection::ParameterModifier>* modifiers) {
        return GetConstructor4(bindingAttr, binder, callConvention, types, modifiers);
    }
    
    // Automatically generated method stub
    cli::array<Reflection::ConstructorInfo*>* Type::GetConstructors_20b9769ece0e442b() {
        return GetConstructors();
    }
    
    // Automatically generated method stub
    cli::array<Reflection::ConstructorInfo*>* Type::GetConstructors_f24cc6cf9c6f79c6(Reflection::BindingFlags bindingAttr) {
        return GetConstructors_736b6e990b94b352(bindingAttr);
    }
    
    // Automatically generated method stub
    cli::array<Reflection::MemberInfo*>* Type::GetDefaultMembers_727bd9381d293316() {
        return GetDefaultMembers_d0a4a4222b9683ff();
    }
    
    // Automatically generated method stub
    cli::array<Reflection::MemberInfo*>* Type::FindMembers_4910effe19de98a7(Reflection::MemberTypes memberType, Reflection::BindingFlags bindingAttr, Reflection::MemberFilter* filter, Object* filterCriteria) {
        return FindMembers_cae113425644ab26(memberType, bindingAttr, filter, filterCriteria);
    }
    
    // Automatically generated method stub
    Object* Type::InvokeMember_d2a724320e8ef589(String* name, Reflection::BindingFlags invokeAttr, Reflection::Binder* binder, Object* target, cli::array<Object*>* args) {
        return InvokeMember(name, invokeAttr, binder, target, args);
    }
    
    // Automatically generated method stub
    Object* Type::InvokeMember_c3a4caa7e37f34b1(String* name, Reflection::BindingFlags invokeAttr, Reflection::Binder* binder, Object* target, cli::array<Object*>* args, Globalization::CultureInfo* culture) {
        return InvokeMember2(name, invokeAttr, binder, target, args, culture);
    }
    
    // Automatically generated method stub
    Object* Type::InvokeMember_9f3df0d7b60ab9f0(String* name, Reflection::BindingFlags invokeAttr, Reflection::Binder* binder, Object* target, cli::array<Object*>* args, cli::array<Reflection::ParameterModifier>* modifiers, Globalization::CultureInfo* culture, cli::array<String*>* namedParameters) {
        return InvokeMember_70c4601d847070a2(name, invokeAttr, binder, target, args, modifiers, culture, namedParameters);
    }
    
    // Automatically generated method stub
    Object* Type::InvokeMember_8ebb9e0e6d78ba5a(String* name, Reflection::BindingFlags invokeAttr, Reflection::Binder* binder, Object* target, cli::array<Object*>* args, cli::array<Reflection::ParameterModifier>* modifiers, Globalization::CultureInfo* culture, cli::array<String*>* namedParameters) {
        return InvokeMember_70c4601d847070a2(name, invokeAttr, binder, target, args, modifiers, culture, namedParameters);
    }
    
    // Automatically generated method stub
    String* Type::ToString_7ae6b85e974ee75a() {
        return ToString_1636a0751cb9ac11();
    }
    
    // Automatically generated method stub
    void Type::GetIDsOfNames_1da4b71924d852c0(Guid riid, void* rgszNames, uint32_t cNames, uint32_t lcid, void* rgDispId) {
        return GetIDsOfNames2(riid, rgszNames, cNames, lcid, rgDispId);
    }
    
    // Automatically generated method stub
    void Type::GetTypeInfo_b4a9bd9efa232f89(uint32_t iTInfo, uint32_t lcid, void* ppTInfo) {
        return GetTypeInfo2(iTInfo, lcid, ppTInfo);
    }
    
    // Automatically generated method stub
    void Type::GetTypeInfoCount_6b9f06a4fb498bd3(uint32_t pcTInfo) {
        return GetTypeInfoCount2(pcTInfo);
    }
    
    // Automatically generated method stub
    void Type::Invoke_67109d5273366daf(uint32_t dispIdMember, Guid riid, uint32_t lcid, int16_t wFlags, void* pDispParams, void* pVarResult, void* pExcepInfo, void* puArgErr) {
        return Invoke2(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    }
    
    // Automatically generated method stub
    Reflection::Assembly* Type::get_Assembly_de424b6590183868() {
        return get_Assembly_3aae0acbf2a6d696();
    }
    
    // Automatically generated method stub
    String* Type::get_AssemblyQualifiedName_63c3dd8ef06f5e45() {
        return get_AssemblyQualifiedName_cea373c2171bd483();
    }
    
    // Automatically generated method stub
    Reflection::TypeAttributes Type::get_Attributes_bed7bd9dd753da57() {
        return get_Attributes();
    }
    
    // Automatically generated method stub
    Type* Type::get_BaseType_b398eaad0c8c79e2() {
        return get_BaseType_6a0646ae880055f6();
    }
    
    // Automatically generated method stub
    Type* Type::get_DeclaringType_57e85ec7caa4a7e9() {
        return get_DeclaringType_6121cd6a84393166();
    }
    
    // Automatically generated method stub
    String* Type::get_FullName_773444c2f90eecd() {
        return get_FullName_7e8fa72ba225e1a4();
    }
    
    // Automatically generated method stub
    Guid Type::get_GUID_4d00162e8efb54a7() {
        return get_GUID_bdb6b630c3237a21();
    }
    
    // Automatically generated method stub
    bool Type::get_HasElementType_754bebcc1b786422() {
        return get_HasElementType();
    }
    
    // Automatically generated method stub
    bool Type::get_IsAbstract_5dcfab57b6ff095() {
        return get_IsAbstract();
    }
    
    // Automatically generated method stub
    bool Type::get_IsAnsiClass_d7f01d12eb51d710() {
        return get_IsAnsiClass();
    }
    
    // Automatically generated method stub
    bool Type::get_IsArray_9a85c8065d1ab324() {
        return get_IsArray();
    }
    
    // Automatically generated method stub
    bool Type::get_IsAutoClass_14b7883b9d76be37() {
        return get_IsAutoClass();
    }
    
    // Automatically generated method stub
    bool Type::get_IsAutoLayout_cd96e8a6fef98d97() {
        return get_IsAutoLayout();
    }
    
    // Automatically generated method stub
    bool Type::get_IsByRef_2f4ef2ab1e7d3788() {
        return get_IsByRef();
    }
    
    // Automatically generated method stub
    bool Type::get_IsClass_bc4f9c45e087f317() {
        return get_IsClass();
    }
    
    // Automatically generated method stub
    bool Type::get_IsCOMObject_22277b5ad648345f() {
        return get_IsCOMObject();
    }
    
    // Automatically generated method stub
    bool Type::get_IsContextful_1a446b1f672d7424() {
        return get_IsContextful();
    }
    
    // Automatically generated method stub
    bool Type::get_IsEnum_59290f0923c47901() {
        return get_IsEnum_bc85ea7b0a749db();
    }
    
    // Automatically generated method stub
    bool Type::get_IsExplicitLayout_a0f1b1afb779c5f() {
        return get_IsExplicitLayout();
    }
    
    // Automatically generated method stub
    bool Type::get_IsImport_79d05e25159073af() {
        return get_IsImport();
    }
    
    // Automatically generated method stub
    bool Type::get_IsInterface_d9be9b69e04cf7d2() {
        return get_IsInterface();
    }
    
    // Automatically generated method stub
    bool Type::get_IsLayoutSequential_6068218a76af8d15() {
        return get_IsLayoutSequential();
    }
    
    // Automatically generated method stub
    bool Type::get_IsMarshalByRef_ebd9c7fa09db17d2() {
        return get_IsMarshalByRef();
    }
    
    // Automatically generated method stub
    bool Type::get_IsNestedAssembly_38350089c99e6eb4() {
        return get_IsNestedAssembly();
    }
    
    // Automatically generated method stub
    bool Type::get_IsNestedFamANDAssem_fbb3d63f801f0e26() {
        return get_IsNestedFamANDAssem();
    }
    
    // Automatically generated method stub
    bool Type::get_IsNestedFamily_94e83bc2facfce0a() {
        return get_IsNestedFamily();
    }
    
    // Automatically generated method stub
    bool Type::get_IsNestedFamORAssem_ee3008d87f75f225() {
        return get_IsNestedFamORAssem();
    }
    
    // Automatically generated method stub
    bool Type::get_IsNestedPrivate_8ecb6c70205b5ba8() {
        return get_IsNestedPrivate();
    }
    
    // Automatically generated method stub
    bool Type::get_IsNestedPublic_1fc26cd17482207b() {
        return get_IsNestedPublic();
    }
    
    // Automatically generated method stub
    bool Type::get_IsNotPublic_311ea9f86ac6330a() {
        return get_IsNotPublic();
    }
    
    // Automatically generated method stub
    bool Type::get_IsPointer_5a4f6004b270a9d() {
        return get_IsPointer();
    }
    
    // Automatically generated method stub
    bool Type::get_IsPrimitive_842be52a04be213c() {
        return get_IsPrimitive();
    }
    
    // Automatically generated method stub
    bool Type::get_IsPublic_dd1336b6f1c99e24() {
        return get_IsPublic();
    }
    
    // Automatically generated method stub
    bool Type::get_IsSealed_4ffa7a05948334aa() {
        return get_IsSealed();
    }
    
    // Automatically generated method stub
    bool Type::get_IsSerializable_ee155a21678a6b08() {
        return get_IsSerializable_54e7f398ebfc9468();
    }
    
    // Automatically generated method stub
    bool Type::get_IsSpecialName_9f0da6e67f068528() {
        return get_IsSpecialName();
    }
    
    // Automatically generated method stub
    bool Type::get_IsUnicodeClass_d35ccc782a67e4f4() {
        return get_IsUnicodeClass();
    }
    
    // Automatically generated method stub
    bool Type::get_IsValueType_ab705a389c7af1d8() {
        return get_IsValueType();
    }
    
    // Automatically generated method stub
    Reflection::MemberTypes Type::get_MemberType_49298b8bb0d10a74() {
        return get_MemberType_cd521d320810c98f();
    }
    
    // Automatically generated method stub
    Reflection::Module* Type::get_Module_e878d08348938612() {
        return get_Module_ea7d65dc88202263();
    }
    
    // Automatically generated method stub
    String* Type::get_Namespace_4a78ab8fbbf66619() {
        return get_Namespace_cb4ed37007083e7f();
    }
    
    // Automatically generated method stub
    Type* Type::get_ReflectedType_338a78c0f78949() {
        return get_ReflectedType_bf4971c0f442b9dc();
    }
    
    // Automatically generated method stub
    RuntimeTypeHandle Type::get_TypeHandle_a660506a2c0cc3d5() {
        return get_TypeHandle_a14995fa9102936b();
    }
    
    // Automatically generated method stub
    Reflection::ConstructorInfo* Type::get_TypeInitializer_1a4653d737922696() {
        return get_TypeInitializer();
    }
    
    // Automatically generated method stub
    Type* Type::get_UnderlyingSystemType_489064e38cffeff() {
        return get_UnderlyingSystemType_9ccb7bb8385521f6();
    }
    
    // Automatically generated method stub
    Type* Type::get_UnderlyingSystemType_c5f7e8bc4888131f() {
        return get_UnderlyingSystemType_9ccb7bb8385521f6();
    }
    
    // Automatically generated method stub
    cli::array<Object*>* Type::GetCustomAttributes_15e7120d7361e983(bool inherit) {
        return GetCustomAttributes_b790992b66049291(inherit);
    }
    
    // Automatically generated method stub
    cli::array<Object*>* Type::GetCustomAttributes_32081d39648cff5f(Type* attributeType, bool inherit) {
        return GetCustomAttributes_90419687cfa65ef7(attributeType, inherit);
    }
    
    // Automatically generated method stub
    bool Type::IsDefined_16c540b5a4e1ff66(Type* attributeType, bool inherit) {
        return IsDefined_91943a8ac363f11f(attributeType, inherit);
    }
    
    // Automatically generated method stub
    String* Type::get_Name_e4f201ea08eb3ef2() {
        return get_Name_50fad5fa936c3ae2();
    }
    
}
namespace System {
    // Automatically generated method stub
    void UnitySerializationHolder::GetObjectData_11b895a112e04409(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        return GetObjectData_e37fac8b2d7c8b4f(info, context);
    }
    
    // Automatically generated method stub
    Object* UnitySerializationHolder::GetRealObject_692566897a6926e4(Runtime::Serialization::StreamingContext context) {
        return GetRealObject_81b2ad0a9e261bd8(context);
    }
    
}
namespace System {
    // Automatically generated method stub
    Object* Version::Clone_d5efb96d327809c8() {
        return Clone();
    }
    
    // Automatically generated method stub
    int32_t Version::CompareTo_ed9d39205b7812f0(Object* version) {
        return CompareTo(version);
    }
    
    // Automatically generated method stub
    int32_t Version::CompareTo_8a8b7d6c83beb422(Version* value) {
        return CompareTo2(value);
    }
    
    // Automatically generated method stub
    bool Version::Equals_ea48fd0c13a733fe(Version* obj) {
        return Equals4(obj);
    }
    
}
namespace System {
    // Automatically generated method stub
    void WeakReference::GetObjectData_11b895a112e04409(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        return GetObjectData_d18af1d641fa5d4e(info, context);
    }
    
}
namespace System {
    // Automatically generated method stub
    void WindowsConsoleDriver::Beep_1da4596cc175b056(int32_t frequency, int32_t duration) {
        return Beep(frequency, duration);
    }
    
    // Automatically generated method stub
    void WindowsConsoleDriver::Clear_f1b4f6af283cc2c9() {
        return Clear();
    }
    
    // Automatically generated method stub
    void WindowsConsoleDriver::MoveBufferArea_5b90e28706eb2f21(int32_t sourceLeft, int32_t sourceTop, int32_t sourceWidth, int32_t sourceHeight, int32_t targetLeft, int32_t targetTop, char16_t sourceChar, ConsoleColor sourceForeColor, ConsoleColor sourceBackColor) {
        return MoveBufferArea(sourceLeft, sourceTop, sourceWidth, sourceHeight, targetLeft, targetTop, sourceChar, sourceForeColor, sourceBackColor);
    }
    
    // Automatically generated method stub
    void WindowsConsoleDriver::Init_c5426ee2900a294b() {
        return Init();
    }
    
    // Automatically generated method stub
    String* WindowsConsoleDriver::ReadLine_d9726d4d34f7f3c0() {
        return ReadLine();
    }
    
    // Automatically generated method stub
    ConsoleKeyInfo WindowsConsoleDriver::ReadKey_6a3b7aab317c85ed(bool intercept) {
        return ReadKey(intercept);
    }
    
    // Automatically generated method stub
    void WindowsConsoleDriver::ResetColor_8f6250a6a6d78789() {
        return ResetColor();
    }
    
    // Automatically generated method stub
    void WindowsConsoleDriver::SetBufferSize_343d697c2e12d0db(int32_t width, int32_t height) {
        return SetBufferSize(width, height);
    }
    
    // Automatically generated method stub
    void WindowsConsoleDriver::SetCursorPosition_1b5796b8c190ffa5(int32_t left, int32_t top) {
        return SetCursorPosition(left, top);
    }
    
    // Automatically generated method stub
    void WindowsConsoleDriver::SetWindowPosition_cd2b9c3f7be414da(int32_t left, int32_t top) {
        return SetWindowPosition(left, top);
    }
    
    // Automatically generated method stub
    void WindowsConsoleDriver::SetWindowSize_4cfb33f333b34cf(int32_t width, int32_t height) {
        return SetWindowSize(width, height);
    }
    
    // Automatically generated method stub
    ConsoleColor WindowsConsoleDriver::get_BackgroundColor_c9fafb327ddb8be6() {
        return get_BackgroundColor();
    }
    
    // Automatically generated method stub
    ConsoleColor WindowsConsoleDriver::set_BackgroundColor_344fac019c9386b1(ConsoleColor value) {
        return set_BackgroundColor(value);
    }
    
    // Automatically generated method stub
    int32_t WindowsConsoleDriver::get_BufferHeight_37934843c5ad875e() {
        return get_BufferHeight();
    }
    
    // Automatically generated method stub
    int32_t WindowsConsoleDriver::set_BufferHeight_5d535a7eaee8afa7(int32_t value) {
        return set_BufferHeight(value);
    }
    
    // Automatically generated method stub
    int32_t WindowsConsoleDriver::get_BufferWidth_4e39d049ce05cb10() {
        return get_BufferWidth();
    }
    
    // Automatically generated method stub
    int32_t WindowsConsoleDriver::set_BufferWidth_ba768a1fb5af86f3(int32_t value) {
        return set_BufferWidth(value);
    }
    
    // Automatically generated method stub
    bool WindowsConsoleDriver::get_CapsLock_5c626ee325707d5c() {
        return get_CapsLock();
    }
    
    // Automatically generated method stub
    int32_t WindowsConsoleDriver::get_CursorLeft_a1045160a5e0c167() {
        return get_CursorLeft();
    }
    
    // Automatically generated method stub
    int32_t WindowsConsoleDriver::set_CursorLeft_58812b936675567d(int32_t value) {
        return set_CursorLeft(value);
    }
    
    // Automatically generated method stub
    int32_t WindowsConsoleDriver::get_CursorSize_c23bb8efe316d434() {
        return get_CursorSize();
    }
    
    // Automatically generated method stub
    int32_t WindowsConsoleDriver::set_CursorSize_f0834eb8266a5be6(int32_t value) {
        return set_CursorSize(value);
    }
    
    // Automatically generated method stub
    int32_t WindowsConsoleDriver::get_CursorTop_529e091e36331015() {
        return get_CursorTop();
    }
    
    // Automatically generated method stub
    int32_t WindowsConsoleDriver::set_CursorTop_785544d75b1c0bee(int32_t value) {
        return set_CursorTop(value);
    }
    
    // Automatically generated method stub
    bool WindowsConsoleDriver::get_CursorVisible_56c3cc5601135b6f() {
        return get_CursorVisible();
    }
    
    // Automatically generated method stub
    bool WindowsConsoleDriver::set_CursorVisible_cf1ec653cdd99e69(bool value) {
        return set_CursorVisible(value);
    }
    
    // Automatically generated method stub
    ConsoleColor WindowsConsoleDriver::get_ForegroundColor_7612ec7b8c8aaaa5() {
        return get_ForegroundColor();
    }
    
    // Automatically generated method stub
    ConsoleColor WindowsConsoleDriver::set_ForegroundColor_940cb65e8fef1858(ConsoleColor value) {
        return set_ForegroundColor(value);
    }
    
    // Automatically generated method stub
    bool WindowsConsoleDriver::get_KeyAvailable_484cd75e08a09869() {
        return get_KeyAvailable();
    }
    
    // Automatically generated method stub
    bool WindowsConsoleDriver::get_Initialized_317ffc50d17896d3() {
        return get_Initialized();
    }
    
    // Automatically generated method stub
    int32_t WindowsConsoleDriver::get_LargestWindowHeight_e89fef87df5ea56d() {
        return get_LargestWindowHeight();
    }
    
    // Automatically generated method stub
    int32_t WindowsConsoleDriver::get_LargestWindowWidth_6d2cf275eb651738() {
        return get_LargestWindowWidth();
    }
    
    // Automatically generated method stub
    bool WindowsConsoleDriver::get_NumberLock_9e29453ae6b2f675() {
        return get_NumberLock();
    }
    
    // Automatically generated method stub
    String* WindowsConsoleDriver::get_Title_297f109429139f1f() {
        return get_Title();
    }
    
    // Automatically generated method stub
    String* WindowsConsoleDriver::set_Title_5ffd8093a2ce14e8(String* value) {
        return set_Title(value);
    }
    
    // Automatically generated method stub
    bool WindowsConsoleDriver::get_TreatControlCAsInput_724ae746e19a1372() {
        return get_TreatControlCAsInput();
    }
    
    // Automatically generated method stub
    bool WindowsConsoleDriver::set_TreatControlCAsInput_22e3ed8b8ed195e4(bool value) {
        return set_TreatControlCAsInput(value);
    }
    
    // Automatically generated method stub
    int32_t WindowsConsoleDriver::get_WindowHeight_d105cfc0640e021b() {
        return get_WindowHeight();
    }
    
    // Automatically generated method stub
    int32_t WindowsConsoleDriver::set_WindowHeight_762a4dd6c7316c83(int32_t value) {
        return set_WindowHeight(value);
    }
    
    // Automatically generated method stub
    int32_t WindowsConsoleDriver::get_WindowLeft_2e939ca75d6696f7() {
        return get_WindowLeft();
    }
    
    // Automatically generated method stub
    int32_t WindowsConsoleDriver::set_WindowLeft_6b1bb1c980db7ca6(int32_t value) {
        return set_WindowLeft(value);
    }
    
    // Automatically generated method stub
    int32_t WindowsConsoleDriver::get_WindowTop_869e53cfc4194ff6() {
        return get_WindowTop();
    }
    
    // Automatically generated method stub
    int32_t WindowsConsoleDriver::set_WindowTop_6ed3579f04406446(int32_t value) {
        return set_WindowTop(value);
    }
    
    // Automatically generated method stub
    int32_t WindowsConsoleDriver::get_WindowWidth_aaf18af655c54aa3() {
        return get_WindowWidth();
    }
    
    // Automatically generated method stub
    int32_t WindowsConsoleDriver::set_WindowWidth_34776e6c3b72e222(int32_t value) {
        return set_WindowWidth(value);
    }
    
}
namespace System { namespace Collections {
    // Automatically generated method stub
    System::Object* ArrayListEnumerator::Clone_d5efb96d327809c8() {
        return Clone();
    }
    
    // Automatically generated method stub
    bool ArrayListEnumerator::MoveNext_4e78e145935f5417() {
        return MoveNext();
    }
    
    // Automatically generated method stub
    void ArrayListEnumerator::Reset_bcd82381eed41868() {
        return Reset();
    }
    
    // Automatically generated method stub
    System::Object* ArrayListEnumerator::get_Current_8eca9b3da02b123a() {
        return get_Current();
    }
    
}}
namespace System { namespace Collections {
    // Automatically generated method stub
    System::Object* SimpleEnumerator2::Clone_d5efb96d327809c8() {
        return Clone();
    }
    
    // Automatically generated method stub
    bool SimpleEnumerator2::MoveNext_4e78e145935f5417() {
        return MoveNext();
    }
    
    // Automatically generated method stub
    void SimpleEnumerator2::Reset_bcd82381eed41868() {
        return Reset();
    }
    
    // Automatically generated method stub
    System::Object* SimpleEnumerator2::get_Current_8eca9b3da02b123a() {
        return get_Current();
    }
    
}}
namespace System { namespace Collections {
    // Automatically generated method stub
    System::Object* EnumeratorWithRange::Clone_d5efb96d327809c8() {
        return Clone();
    }
    
    // Automatically generated method stub
    bool EnumeratorWithRange::MoveNext_4e78e145935f5417() {
        return MoveNext();
    }
    
    // Automatically generated method stub
    void EnumeratorWithRange::Reset_bcd82381eed41868() {
        return Reset();
    }
    
    // Automatically generated method stub
    System::Object* EnumeratorWithRange::get_Current_8eca9b3da02b123a() {
        return get_Current();
    }
    
}}
namespace System { namespace Collections {
    // Automatically generated method stub
    int32_t ListWrapper::Add_985508e3bf9b7a73(System::Object* value) {
        return Add_bcf09ba25e62648f(value);
    }
    
    // Automatically generated method stub
    void ListWrapper::Clear_e0ee496065507a2f() {
        return Clear_77f454011f626479();
    }
    
    // Automatically generated method stub
    bool ListWrapper::Contains_2a2192a595869f4e(System::Object* value) {
        return Contains_f9107b57b0828239(value);
    }
    
    // Automatically generated method stub
    int32_t ListWrapper::IndexOf_7f6d78d7aa6d53e5(System::Object* value) {
        return IndexOf_e6724c0395a3dad0(value);
    }
    
    // Automatically generated method stub
    void ListWrapper::Insert_16e8bd69dfc603f4(int32_t index, System::Object* value) {
        return Insert_290942a010dce429(index, value);
    }
    
    // Automatically generated method stub
    void ListWrapper::Remove_69f1b1e57bb34112(System::Object* value) {
        return Remove_f0670db65479e773(value);
    }
    
    // Automatically generated method stub
    void ListWrapper::RemoveAt_dce190584913328b(int32_t index) {
        return RemoveAt_a5bebe22efe6f1a7(index);
    }
    
    // Automatically generated method stub
    void ListWrapper::CopyTo_7065a6e3cf6a140(System::Array* array, int32_t index) {
        return CopyTo_91752f56f47af7f3(array, index);
    }
    
    // Automatically generated method stub
    IEnumerator* ListWrapper::GetEnumerator_674ad93a972a4d67() {
        return GetEnumerator_6e025ed1cc117836();
    }
    
    // Automatically generated method stub
    System::Object* ListWrapper::get_Item_8550d21996ef9dc5(int32_t index) {
        return get_Item_896a441a7363c710(index);
    }
    
    // Automatically generated method stub
    System::Object* ListWrapper::set_Item_d57705373e0668e7(int32_t index, System::Object* value) {
        return set_Item_a9ec2ce7dfe8dea5(index, value);
    }
    
    // Automatically generated method stub
    int32_t ListWrapper::get_Count_8f254f3dd8e2403() {
        return get_Count_614a2abb891f748b();
    }
    
    // Automatically generated method stub
    bool ListWrapper::get_IsSynchronized_20926e7dabc53dbf() {
        return get_IsSynchronized_23e3b7993e71d737();
    }
    
    // Automatically generated method stub
    System::Object* ListWrapper::get_SyncRoot_257108f45cc89e19() {
        return get_SyncRoot_a3def0e51eeaf8d9();
    }
    
    // Automatically generated method stub
    bool ListWrapper::get_IsFixedSize_4d3eaee3435ee591() {
        return get_IsFixedSize_3444cf8f8ef3efa4();
    }
    
    // Automatically generated method stub
    bool ListWrapper::get_IsReadOnly_53b6e02d46187790() {
        return get_IsReadOnly_fe00057b4a1798ff();
    }
    
}}
namespace System { namespace Collections {
    // Automatically generated method stub
    int32_t ArrayList::Add_985508e3bf9b7a73(System::Object* value) {
        return Add_e6a92085999ce388(value);
    }
    
    // Automatically generated method stub
    void ArrayList::Clear_e0ee496065507a2f() {
        return Clear_cd6654e5a40f5056();
    }
    
    // Automatically generated method stub
    bool ArrayList::Contains_2a2192a595869f4e(System::Object* item) {
        return Contains_f1c198d01147f1ee(item);
    }
    
    // Automatically generated method stub
    int32_t ArrayList::IndexOf_7f6d78d7aa6d53e5(System::Object* value) {
        return IndexOf_7e9811d6771f771d(value);
    }
    
    // Automatically generated method stub
    void ArrayList::Insert_16e8bd69dfc603f4(int32_t index, System::Object* value) {
        return Insert_59557a2615bf3b8e(index, value);
    }
    
    // Automatically generated method stub
    void ArrayList::Remove_69f1b1e57bb34112(System::Object* obj) {
        return Remove_2225381aaf812c6d(obj);
    }
    
    // Automatically generated method stub
    void ArrayList::RemoveAt_dce190584913328b(int32_t index) {
        return RemoveAt_2abea768d3273318(index);
    }
    
    // Automatically generated method stub
    void ArrayList::CopyTo_7065a6e3cf6a140(System::Array* array, int32_t arrayIndex) {
        return CopyTo_2bc540dad3c25b9e(array, arrayIndex);
    }
    
    // Automatically generated method stub
    IEnumerator* ArrayList::GetEnumerator_674ad93a972a4d67() {
        return GetEnumerator_84e3ba8f2fdefd62();
    }
    
    // Automatically generated method stub
    System::Object* ArrayList::Clone_d5efb96d327809c8() {
        return Clone_5d610374e21ea7b0();
    }
    
    // Automatically generated method stub
    System::Object* ArrayList::get_Item_8550d21996ef9dc5(int32_t index) {
        return get_Item_fd0155f142ae570(index);
    }
    
    // Automatically generated method stub
    System::Object* ArrayList::set_Item_d57705373e0668e7(int32_t index, System::Object* value) {
        return set_Item_9f12782653a34813(index, value);
    }
    
    // Automatically generated method stub
    int32_t ArrayList::get_Count_8f254f3dd8e2403() {
        return get_Count_2354963792616712();
    }
    
    // Automatically generated method stub
    bool ArrayList::get_IsFixedSize_4d3eaee3435ee591() {
        return get_IsFixedSize_97a42a087785251();
    }
    
    // Automatically generated method stub
    bool ArrayList::get_IsReadOnly_53b6e02d46187790() {
        return get_IsReadOnly_671df7b1908db8ee();
    }
    
    // Automatically generated method stub
    bool ArrayList::get_IsSynchronized_20926e7dabc53dbf() {
        return get_IsSynchronized_ffa26be0a148c3c0();
    }
    
    // Automatically generated method stub
    System::Object* ArrayList::get_SyncRoot_257108f45cc89e19() {
        return get_SyncRoot_edb1ba826807b569();
    }
    
}}
namespace System { namespace Collections {
    // Automatically generated method stub
    System::Object* BitArrayEnumerator::Clone_d5efb96d327809c8() {
        return Clone();
    }
    
    // Automatically generated method stub
    bool BitArrayEnumerator::MoveNext_4e78e145935f5417() {
        return MoveNext();
    }
    
    // Automatically generated method stub
    void BitArrayEnumerator::Reset_bcd82381eed41868() {
        return Reset();
    }
    
    // Automatically generated method stub
    System::Object* BitArrayEnumerator::get_Current_8eca9b3da02b123a() {
        return get_Current();
    }
    
}}
namespace System { namespace Collections {
    // Automatically generated method stub
    System::Object* BitArray::Clone_d5efb96d327809c8() {
        return Clone();
    }
    
    // Automatically generated method stub
    void BitArray::CopyTo_7065a6e3cf6a140(System::Array* array, int32_t index) {
        return CopyTo(array, index);
    }
    
    // Automatically generated method stub
    IEnumerator* BitArray::GetEnumerator_674ad93a972a4d67() {
        return GetEnumerator();
    }
    
    // Automatically generated method stub
    int32_t BitArray::get_Count_8f254f3dd8e2403() {
        return get_Count();
    }
    
    // Automatically generated method stub
    bool BitArray::get_IsSynchronized_20926e7dabc53dbf() {
        return get_IsSynchronized();
    }
    
    // Automatically generated method stub
    System::Object* BitArray::get_SyncRoot_257108f45cc89e19() {
        return get_SyncRoot();
    }
    
}}
namespace System { namespace Collections {
    // Automatically generated method stub
    int32_t CaseInsensitiveComparer::Compare_451fd276747b629d(System::Object* a, System::Object* b) {
        return Compare(a, b);
    }
    
}}
namespace System { namespace Collections {
    // Automatically generated method stub
    int32_t CaseInsensitiveHashCodeProvider::GetHashCode_5d8a358493971efd(System::Object* obj) {
        return GetHashCode2(obj);
    }
    
}}
namespace System { namespace Collections {
    // Automatically generated method stub
    IEnumerator* CollectionBase::GetEnumerator_674ad93a972a4d67() {
        return GetEnumerator();
    }
    
    // Automatically generated method stub
    void CollectionBase::Clear_e0ee496065507a2f() {
        return Clear();
    }
    
    // Automatically generated method stub
    void CollectionBase::RemoveAt_dce190584913328b(int32_t index) {
        return RemoveAt(index);
    }
    
    // Automatically generated method stub
    void CollectionBase::CopyTo_7065a6e3cf6a140(System::Array* array, int32_t index) {
        return CopyTo(array, index);
    }
    
    // Automatically generated method stub
    int32_t CollectionBase::Add_985508e3bf9b7a73(System::Object* value) {
        return Add(value);
    }
    
    // Automatically generated method stub
    bool CollectionBase::Contains_2a2192a595869f4e(System::Object* value) {
        return Contains(value);
    }
    
    // Automatically generated method stub
    int32_t CollectionBase::IndexOf_7f6d78d7aa6d53e5(System::Object* value) {
        return IndexOf(value);
    }
    
    // Automatically generated method stub
    void CollectionBase::Insert_16e8bd69dfc603f4(int32_t index, System::Object* value) {
        return Insert(index, value);
    }
    
    // Automatically generated method stub
    void CollectionBase::Remove_69f1b1e57bb34112(System::Object* value) {
        return Remove(value);
    }
    
    // Automatically generated method stub
    int32_t CollectionBase::get_Count_8f254f3dd8e2403() {
        return get_Count();
    }
    
    // Automatically generated method stub
    System::Object* CollectionBase::get_SyncRoot_257108f45cc89e19() {
        return get_SyncRoot();
    }
    
    // Automatically generated method stub
    bool CollectionBase::get_IsSynchronized_20926e7dabc53dbf() {
        return get_IsSynchronized();
    }
    
    // Automatically generated method stub
    bool CollectionBase::get_IsFixedSize_4d3eaee3435ee591() {
        return get_IsFixedSize();
    }
    
    // Automatically generated method stub
    bool CollectionBase::get_IsReadOnly_53b6e02d46187790() {
        return get_IsReadOnly();
    }
    
    // Automatically generated method stub
    System::Object* CollectionBase::get_Item_8550d21996ef9dc5(int32_t index) {
        return get_Item(index);
    }
    
    // Automatically generated method stub
    System::Object* CollectionBase::set_Item_d57705373e0668e7(int32_t index, System::Object* value) {
        return set_Item(index, value);
    }
    
}}
namespace System { namespace Collections {
    // Automatically generated method stub
    int32_t Comparer::Compare_451fd276747b629d(System::Object* a, System::Object* b) {
        return Compare(a, b);
    }
    
    // Automatically generated method stub
    void Comparer::GetObjectData_11b895a112e04409(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        return GetObjectData(info, context);
    }
    
}}
namespace System { namespace Collections {
    // Automatically generated method stub
    void DictionaryBase::Clear_23091c63869f817f() {
        return Clear();
    }
    
    // Automatically generated method stub
    void DictionaryBase::CopyTo_7065a6e3cf6a140(System::Array* array, int32_t index) {
        return CopyTo(array, index);
    }
    
    // Automatically generated method stub
    IDictionaryEnumerator* DictionaryBase::GetEnumerator_40657fcb15842551() {
        return GetEnumerator();
    }
    
    // Automatically generated method stub
    void DictionaryBase::Add_642542cf7a4cae38(System::Object* key, System::Object* value) {
        return Add(key, value);
    }
    
    // Automatically generated method stub
    void DictionaryBase::Remove_f212b96e00d6aaed(System::Object* key) {
        return Remove(key);
    }
    
    // Automatically generated method stub
    bool DictionaryBase::Contains_32eba6643fe7ee4b(System::Object* key) {
        return Contains(key);
    }
    
    // Automatically generated method stub
    IEnumerator* DictionaryBase::GetEnumerator_674ad93a972a4d67() {
        return GetEnumerator2();
    }
    
    // Automatically generated method stub
    int32_t DictionaryBase::get_Count_8f254f3dd8e2403() {
        return get_Count();
    }
    
    // Automatically generated method stub
    bool DictionaryBase::get_IsFixedSize_9b77ca904d42a211() {
        return get_IsFixedSize();
    }
    
    // Automatically generated method stub
    bool DictionaryBase::get_IsReadOnly_faaa94fe854aaa5f() {
        return get_IsReadOnly();
    }
    
    // Automatically generated method stub
    System::Object* DictionaryBase::get_Item_95688dd349c069c0(System::Object* key) {
        return get_Item(key);
    }
    
    // Automatically generated method stub
    System::Object* DictionaryBase::set_Item_a0c4aaef01cc13c2(System::Object* key, System::Object* value) {
        return set_Item(key, value);
    }
    
    // Automatically generated method stub
    ICollection* DictionaryBase::get_Keys_d809cadac60b140a() {
        return get_Keys();
    }
    
    // Automatically generated method stub
    ICollection* DictionaryBase::get_Values_ef6ae5cda2bdcf40() {
        return get_Values();
    }
    
    // Automatically generated method stub
    bool DictionaryBase::get_IsSynchronized_20926e7dabc53dbf() {
        return get_IsSynchronized();
    }
    
    // Automatically generated method stub
    System::Object* DictionaryBase::get_SyncRoot_257108f45cc89e19() {
        return get_SyncRoot();
    }
    
}}
namespace System { namespace Collections {
    // Automatically generated method stub
    System::Object* KeyMarker::GetRealObject_692566897a6926e4(System::Runtime::Serialization::StreamingContext context) {
        return GetRealObject(context);
    }
    
}}
namespace System { namespace Collections {
    // Automatically generated method stub
    void Enumerator::Reset_bcd82381eed41868() {
        return Reset();
    }
    
    // Automatically generated method stub
    bool Enumerator::MoveNext_4e78e145935f5417() {
        return MoveNext();
    }
    
    // Automatically generated method stub
    DictionaryEntry Enumerator::get_Entry_7d036eca1ef8d5f4() {
        return get_Entry();
    }
    
    // Automatically generated method stub
    System::Object* Enumerator::get_Key_ed7954531cb20258() {
        return get_Key();
    }
    
    // Automatically generated method stub
    System::Object* Enumerator::get_Value_889e0f410f0d67ef() {
        return get_Value();
    }
    
    // Automatically generated method stub
    System::Object* Enumerator::get_Current_8eca9b3da02b123a() {
        return get_Current();
    }
    
}}
namespace System { namespace Collections {
    // Automatically generated method stub
    void HashKeys::CopyTo_7065a6e3cf6a140(System::Array* array, int32_t arrayIndex) {
        return CopyTo_26b7b563095a6a78(array, arrayIndex);
    }
    
    // Automatically generated method stub
    IEnumerator* HashKeys::GetEnumerator_674ad93a972a4d67() {
        return GetEnumerator_d0848c73b0d4ba7e();
    }
    
    // Automatically generated method stub
    int32_t HashKeys::get_Count_8f254f3dd8e2403() {
        return get_Count_870e31a32a0811da();
    }
    
    // Automatically generated method stub
    bool HashKeys::get_IsSynchronized_20926e7dabc53dbf() {
        return get_IsSynchronized_1b4048350ba18310();
    }
    
    // Automatically generated method stub
    System::Object* HashKeys::get_SyncRoot_257108f45cc89e19() {
        return get_SyncRoot_2b118fba429beabc();
    }
    
}}
namespace System { namespace Collections {
    // Automatically generated method stub
    void HashValues::CopyTo_7065a6e3cf6a140(System::Array* array, int32_t arrayIndex) {
        return CopyTo_3dedcd2541c30c5b(array, arrayIndex);
    }
    
    // Automatically generated method stub
    IEnumerator* HashValues::GetEnumerator_674ad93a972a4d67() {
        return GetEnumerator_76e01e69f9d79a21();
    }
    
    // Automatically generated method stub
    int32_t HashValues::get_Count_8f254f3dd8e2403() {
        return get_Count_7bc0b9b088d0f437();
    }
    
    // Automatically generated method stub
    bool HashValues::get_IsSynchronized_20926e7dabc53dbf() {
        return get_IsSynchronized_124b5400ee4ed680();
    }
    
    // Automatically generated method stub
    System::Object* HashValues::get_SyncRoot_257108f45cc89e19() {
        return get_SyncRoot_aa8e50be6f68d1c8();
    }
    
}}
namespace System { namespace Collections {
    // Automatically generated method stub
    void SyncHashtable::GetObjectData_11b895a112e04409(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        return GetObjectData_f5c8af3d5979ea57(info, context);
    }
    
    // Automatically generated method stub
    IEnumerator* SyncHashtable::GetEnumerator_674ad93a972a4d67() {
        return GetEnumerator3();
    }
    
    // Automatically generated method stub
    void SyncHashtable::CopyTo_7065a6e3cf6a140(System::Array* array, int32_t arrayIndex) {
        return CopyTo_2ceaf225ee09f8a(array, arrayIndex);
    }
    
    // Automatically generated method stub
    void SyncHashtable::Add_642542cf7a4cae38(System::Object* key, System::Object* value) {
        return Add_3f7ab157bcb41156(key, value);
    }
    
    // Automatically generated method stub
    void SyncHashtable::Clear_23091c63869f817f() {
        return Clear_f1f405c8fa63a059();
    }
    
    // Automatically generated method stub
    bool SyncHashtable::Contains_32eba6643fe7ee4b(System::Object* key) {
        return Contains_be7d0f2741618cb4(key);
    }
    
    // Automatically generated method stub
    IDictionaryEnumerator* SyncHashtable::GetEnumerator_40657fcb15842551() {
        return GetEnumerator_47df71de9b680069();
    }
    
    // Automatically generated method stub
    void SyncHashtable::Remove_f212b96e00d6aaed(System::Object* key) {
        return Remove_fd653674dd8a5ac4(key);
    }
    
    // Automatically generated method stub
    System::Object* SyncHashtable::Clone_d5efb96d327809c8() {
        return Clone_7f5df2dba23978b();
    }
    
    // Automatically generated method stub
    int32_t SyncHashtable::get_Count_8f254f3dd8e2403() {
        return get_Count_40aff81471a60b4c();
    }
    
    // Automatically generated method stub
    bool SyncHashtable::get_IsSynchronized_20926e7dabc53dbf() {
        return get_IsSynchronized_6d887770284f3341();
    }
    
    // Automatically generated method stub
    System::Object* SyncHashtable::get_SyncRoot_257108f45cc89e19() {
        return get_SyncRoot_2d1e4aa44bab8a0d();
    }
    
    // Automatically generated method stub
    bool SyncHashtable::get_IsFixedSize_9b77ca904d42a211() {
        return get_IsFixedSize_984422caf0fb996a();
    }
    
    // Automatically generated method stub
    bool SyncHashtable::get_IsReadOnly_faaa94fe854aaa5f() {
        return get_IsReadOnly_4faf7104d0e98623();
    }
    
    // Automatically generated method stub
    ICollection* SyncHashtable::get_Keys_d809cadac60b140a() {
        return get_Keys_8171dfd94447fa93();
    }
    
    // Automatically generated method stub
    ICollection* SyncHashtable::get_Values_ef6ae5cda2bdcf40() {
        return get_Values_4ed88b5f6e59ef25();
    }
    
    // Automatically generated method stub
    System::Object* SyncHashtable::get_Item_95688dd349c069c0(System::Object* key) {
        return get_Item_d75c6e706b965758(key);
    }
    
    // Automatically generated method stub
    System::Object* SyncHashtable::set_Item_a0c4aaef01cc13c2(System::Object* key, System::Object* value) {
        return set_Item_84c7e24d9caa09(key, value);
    }
    
}}
namespace System { namespace Collections {
    // Automatically generated method stub
    IEnumerator* Hashtable::GetEnumerator_674ad93a972a4d67() {
        return GetEnumerator();
    }
    
    // Automatically generated method stub
    void Hashtable::CopyTo_7065a6e3cf6a140(System::Array* array, int32_t arrayIndex) {
        return CopyTo_2ceaf225ee09f8a(array, arrayIndex);
    }
    
    // Automatically generated method stub
    void Hashtable::Add_642542cf7a4cae38(System::Object* key, System::Object* value) {
        return Add_3f7ab157bcb41156(key, value);
    }
    
    // Automatically generated method stub
    void Hashtable::Clear_23091c63869f817f() {
        return Clear_f1f405c8fa63a059();
    }
    
    // Automatically generated method stub
    bool Hashtable::Contains_32eba6643fe7ee4b(System::Object* key) {
        return Contains_be7d0f2741618cb4(key);
    }
    
    // Automatically generated method stub
    IDictionaryEnumerator* Hashtable::GetEnumerator_40657fcb15842551() {
        return GetEnumerator_47df71de9b680069();
    }
    
    // Automatically generated method stub
    void Hashtable::Remove_f212b96e00d6aaed(System::Object* key) {
        return Remove_fd653674dd8a5ac4(key);
    }
    
    // Automatically generated method stub
    System::Object* Hashtable::Clone_d5efb96d327809c8() {
        return Clone_7f5df2dba23978b();
    }
    
    // Automatically generated method stub
    void Hashtable::GetObjectData_11b895a112e04409(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        return GetObjectData_f5c8af3d5979ea57(info, context);
    }
    
    // Automatically generated method stub
    void Hashtable::OnDeserialization_e9ecfecba8df9754(System::Object* sender) {
        return OnDeserialization_868d234d4d762260(sender);
    }
    
    // Automatically generated method stub
    int32_t Hashtable::get_Count_8f254f3dd8e2403() {
        return get_Count_40aff81471a60b4c();
    }
    
    // Automatically generated method stub
    bool Hashtable::get_IsSynchronized_20926e7dabc53dbf() {
        return get_IsSynchronized_6d887770284f3341();
    }
    
    // Automatically generated method stub
    System::Object* Hashtable::get_SyncRoot_257108f45cc89e19() {
        return get_SyncRoot_2d1e4aa44bab8a0d();
    }
    
    // Automatically generated method stub
    bool Hashtable::get_IsFixedSize_9b77ca904d42a211() {
        return get_IsFixedSize_984422caf0fb996a();
    }
    
    // Automatically generated method stub
    bool Hashtable::get_IsReadOnly_faaa94fe854aaa5f() {
        return get_IsReadOnly_4faf7104d0e98623();
    }
    
    // Automatically generated method stub
    ICollection* Hashtable::get_Keys_d809cadac60b140a() {
        return get_Keys_8171dfd94447fa93();
    }
    
    // Automatically generated method stub
    ICollection* Hashtable::get_Values_ef6ae5cda2bdcf40() {
        return get_Values_4ed88b5f6e59ef25();
    }
    
    // Automatically generated method stub
    System::Object* Hashtable::get_Item_95688dd349c069c0(System::Object* key) {
        return get_Item_d75c6e706b965758(key);
    }
    
    // Automatically generated method stub
    System::Object* Hashtable::set_Item_a0c4aaef01cc13c2(System::Object* key, System::Object* value) {
        return set_Item_84c7e24d9caa09(key, value);
    }
    
}}
namespace System { namespace Collections {
    // Automatically generated method stub
    System::Object* QueueEnumerator::Clone_d5efb96d327809c8() {
        return Clone();
    }
    
    // Automatically generated method stub
    bool QueueEnumerator::MoveNext_4e78e145935f5417() {
        return MoveNext_e38147317beb6367();
    }
    
    // Automatically generated method stub
    void QueueEnumerator::Reset_bcd82381eed41868() {
        return Reset_f399ddbfb4a26238();
    }
    
    // Automatically generated method stub
    System::Object* QueueEnumerator::get_Current_8eca9b3da02b123a() {
        return get_Current_dfd4e333254568bd();
    }
    
}}
namespace System { namespace Collections {
    // Automatically generated method stub
    void Queue::CopyTo_7065a6e3cf6a140(System::Array* array, int32_t index) {
        return CopyTo_a242f31c9e5a44f6(array, index);
    }
    
    // Automatically generated method stub
    IEnumerator* Queue::GetEnumerator_674ad93a972a4d67() {
        return GetEnumerator_9c4544dfc8024fc3();
    }
    
    // Automatically generated method stub
    System::Object* Queue::Clone_d5efb96d327809c8() {
        return Clone_bcf06e67c65a40c7();
    }
    
    // Automatically generated method stub
    int32_t Queue::get_Count_8f254f3dd8e2403() {
        return get_Count_d68471db5ed73aae();
    }
    
    // Automatically generated method stub
    bool Queue::get_IsSynchronized_20926e7dabc53dbf() {
        return get_IsSynchronized_c60381663baf0d11();
    }
    
    // Automatically generated method stub
    System::Object* Queue::get_SyncRoot_257108f45cc89e19() {
        return get_SyncRoot_d7b361956ed7602e();
    }
    
}}
namespace System { namespace Collections {
    // Automatically generated method stub
    IEnumerator* ReadOnlyCollectionBase::GetEnumerator_674ad93a972a4d67() {
        return GetEnumerator2();
    }
    
    // Automatically generated method stub
    void ReadOnlyCollectionBase::CopyTo_7065a6e3cf6a140(System::Array* array, int32_t index) {
        return CopyTo(array, index);
    }
    
    // Automatically generated method stub
    int32_t ReadOnlyCollectionBase::get_Count_8f254f3dd8e2403() {
        return get_Count_d1f8482d32e8ef54();
    }
    
    // Automatically generated method stub
    System::Object* ReadOnlyCollectionBase::get_SyncRoot_257108f45cc89e19() {
        return get_SyncRoot();
    }
    
    // Automatically generated method stub
    bool ReadOnlyCollectionBase::get_IsSynchronized_20926e7dabc53dbf() {
        return get_IsSynchronized();
    }
    
}}
namespace System { namespace Collections {
    // Automatically generated method stub
    void Enumerator2::Reset_bcd82381eed41868() {
        return Reset();
    }
    
    // Automatically generated method stub
    bool Enumerator2::MoveNext_4e78e145935f5417() {
        return MoveNext();
    }
    
    // Automatically generated method stub
    System::Object* Enumerator2::Clone_d5efb96d327809c8() {
        return Clone();
    }
    
    // Automatically generated method stub
    DictionaryEntry Enumerator2::get_Entry_7d036eca1ef8d5f4() {
        return get_Entry();
    }
    
    // Automatically generated method stub
    System::Object* Enumerator2::get_Key_ed7954531cb20258() {
        return get_Key();
    }
    
    // Automatically generated method stub
    System::Object* Enumerator2::get_Value_889e0f410f0d67ef() {
        return get_Value();
    }
    
    // Automatically generated method stub
    System::Object* Enumerator2::get_Current_8eca9b3da02b123a() {
        return get_Current();
    }
    
}}
namespace System { namespace Collections {
    // Automatically generated method stub
    void ListKeys::CopyTo_7065a6e3cf6a140(System::Array* array, int32_t arrayIndex) {
        return CopyTo_ab674e4725a04dd5(array, arrayIndex);
    }
    
    // Automatically generated method stub
    int32_t ListKeys::Add_985508e3bf9b7a73(System::Object* value) {
        return Add_c75566abdfd3f1dc(value);
    }
    
    // Automatically generated method stub
    void ListKeys::Clear_e0ee496065507a2f() {
        return Clear_de8b60e6daa645fa();
    }
    
    // Automatically generated method stub
    bool ListKeys::Contains_2a2192a595869f4e(System::Object* key) {
        return Contains_a17f9f0078013e59(key);
    }
    
    // Automatically generated method stub
    int32_t ListKeys::IndexOf_7f6d78d7aa6d53e5(System::Object* key) {
        return IndexOf_1478511550cde2ad(key);
    }
    
    // Automatically generated method stub
    void ListKeys::Insert_16e8bd69dfc603f4(int32_t index, System::Object* value) {
        return Insert_1f210e681eab810a(index, value);
    }
    
    // Automatically generated method stub
    void ListKeys::Remove_69f1b1e57bb34112(System::Object* value) {
        return Remove_96c7b29ece8e3105(value);
    }
    
    // Automatically generated method stub
    void ListKeys::RemoveAt_dce190584913328b(int32_t index) {
        return RemoveAt_acef67f8944a5305(index);
    }
    
    // Automatically generated method stub
    IEnumerator* ListKeys::GetEnumerator_674ad93a972a4d67() {
        return GetEnumerator_cfd57c074767b6cf();
    }
    
    // Automatically generated method stub
    int32_t ListKeys::get_Count_8f254f3dd8e2403() {
        return get_Count_8dbd9d9efdb630c7();
    }
    
    // Automatically generated method stub
    bool ListKeys::get_IsSynchronized_20926e7dabc53dbf() {
        return get_IsSynchronized_30c043785c3848e1();
    }
    
    // Automatically generated method stub
    System::Object* ListKeys::get_SyncRoot_257108f45cc89e19() {
        return get_SyncRoot_d7cb07b3d3ac34f9();
    }
    
    // Automatically generated method stub
    bool ListKeys::get_IsFixedSize_4d3eaee3435ee591() {
        return get_IsFixedSize_de999dd589b62794();
    }
    
    // Automatically generated method stub
    bool ListKeys::get_IsReadOnly_53b6e02d46187790() {
        return get_IsReadOnly_ef714023f662889b();
    }
    
    // Automatically generated method stub
    System::Object* ListKeys::get_Item_8550d21996ef9dc5(int32_t index) {
        return get_Item_9b384f79b2a8f442(index);
    }
    
    // Automatically generated method stub
    System::Object* ListKeys::set_Item_d57705373e0668e7(int32_t index, System::Object* value) {
        return set_Item_766478b9723d0685(index, value);
    }
    
}}
namespace System { namespace Collections {
    // Automatically generated method stub
    void ListValues::CopyTo_7065a6e3cf6a140(System::Array* array, int32_t arrayIndex) {
        return CopyTo_5c11843f30416058(array, arrayIndex);
    }
    
    // Automatically generated method stub
    int32_t ListValues::Add_985508e3bf9b7a73(System::Object* value) {
        return Add_b209d72c1dbda305(value);
    }
    
    // Automatically generated method stub
    void ListValues::Clear_e0ee496065507a2f() {
        return Clear_5f40b3c399928145();
    }
    
    // Automatically generated method stub
    bool ListValues::Contains_2a2192a595869f4e(System::Object* value) {
        return Contains_1431cca1be25e62e(value);
    }
    
    // Automatically generated method stub
    int32_t ListValues::IndexOf_7f6d78d7aa6d53e5(System::Object* value) {
        return IndexOf_4988cb7302341a9d(value);
    }
    
    // Automatically generated method stub
    void ListValues::Insert_16e8bd69dfc603f4(int32_t index, System::Object* value) {
        return Insert_7e27e989df4a7c98(index, value);
    }
    
    // Automatically generated method stub
    void ListValues::Remove_69f1b1e57bb34112(System::Object* value) {
        return Remove_bbb8a6a15af4657f(value);
    }
    
    // Automatically generated method stub
    void ListValues::RemoveAt_dce190584913328b(int32_t index) {
        return RemoveAt_3e80344965f12590(index);
    }
    
    // Automatically generated method stub
    IEnumerator* ListValues::GetEnumerator_674ad93a972a4d67() {
        return GetEnumerator_9e0ab377ed68f679();
    }
    
    // Automatically generated method stub
    int32_t ListValues::get_Count_8f254f3dd8e2403() {
        return get_Count_2968b09a1d64f9e5();
    }
    
    // Automatically generated method stub
    bool ListValues::get_IsSynchronized_20926e7dabc53dbf() {
        return get_IsSynchronized_625d34d3b10e142e();
    }
    
    // Automatically generated method stub
    System::Object* ListValues::get_SyncRoot_257108f45cc89e19() {
        return get_SyncRoot_ecf4ff86be0f7dc5();
    }
    
    // Automatically generated method stub
    bool ListValues::get_IsFixedSize_4d3eaee3435ee591() {
        return get_IsFixedSize_7509d66a3ff49ce6();
    }
    
    // Automatically generated method stub
    bool ListValues::get_IsReadOnly_53b6e02d46187790() {
        return get_IsReadOnly_216abd3d5aa2f510();
    }
    
    // Automatically generated method stub
    System::Object* ListValues::get_Item_8550d21996ef9dc5(int32_t index) {
        return get_Item_d6a462476dd6db5b(index);
    }
    
    // Automatically generated method stub
    System::Object* ListValues::set_Item_d57705373e0668e7(int32_t index, System::Object* value) {
        return set_Item_5e0f725cf069c7d2(index, value);
    }
    
}}
namespace System { namespace Collections {
    // Automatically generated method stub
    IEnumerator* SortedList::GetEnumerator_674ad93a972a4d67() {
        return GetEnumerator();
    }
    
    // Automatically generated method stub
    void SortedList::Add_642542cf7a4cae38(System::Object* key, System::Object* value) {
        return Add_73ffb8be47e034c5(key, value);
    }
    
    // Automatically generated method stub
    void SortedList::Clear_23091c63869f817f() {
        return Clear_5308a33218829a30();
    }
    
    // Automatically generated method stub
    bool SortedList::Contains_32eba6643fe7ee4b(System::Object* key) {
        return Contains_34d44683dd1aa8bd(key);
    }
    
    // Automatically generated method stub
    IDictionaryEnumerator* SortedList::GetEnumerator_40657fcb15842551() {
        return GetEnumerator_958c16317aeb4444();
    }
    
    // Automatically generated method stub
    void SortedList::Remove_f212b96e00d6aaed(System::Object* key) {
        return Remove_61abf193a3ae1d2b(key);
    }
    
    // Automatically generated method stub
    void SortedList::CopyTo_7065a6e3cf6a140(System::Array* array, int32_t arrayIndex) {
        return CopyTo_8484dba7aeba95d9(array, arrayIndex);
    }
    
    // Automatically generated method stub
    System::Object* SortedList::Clone_d5efb96d327809c8() {
        return Clone_e04bc1da0532c023();
    }
    
    // Automatically generated method stub
    int32_t SortedList::get_Count_8f254f3dd8e2403() {
        return get_Count_78ce60b82e5a007();
    }
    
    // Automatically generated method stub
    bool SortedList::get_IsSynchronized_20926e7dabc53dbf() {
        return get_IsSynchronized_766878a892ebabf4();
    }
    
    // Automatically generated method stub
    System::Object* SortedList::get_SyncRoot_257108f45cc89e19() {
        return get_SyncRoot_d4fc4c9fde3847f6();
    }
    
    // Automatically generated method stub
    bool SortedList::get_IsFixedSize_9b77ca904d42a211() {
        return get_IsFixedSize_8ae72e21b9352319();
    }
    
    // Automatically generated method stub
    bool SortedList::get_IsReadOnly_faaa94fe854aaa5f() {
        return get_IsReadOnly_1c2de291a8a6bf90();
    }
    
    // Automatically generated method stub
    ICollection* SortedList::get_Keys_d809cadac60b140a() {
        return get_Keys_2962390e8ff57dd6();
    }
    
    // Automatically generated method stub
    ICollection* SortedList::get_Values_ef6ae5cda2bdcf40() {
        return get_Values_cb1c2f63e58da7b3();
    }
    
    // Automatically generated method stub
    System::Object* SortedList::get_Item_95688dd349c069c0(System::Object* key) {
        return get_Item_c9a994fdd927bead(key);
    }
    
    // Automatically generated method stub
    System::Object* SortedList::set_Item_a0c4aaef01cc13c2(System::Object* key, System::Object* value) {
        return set_Item_1ba4748ac76411aa(key, value);
    }
    
}}
namespace System { namespace Collections {
    // Automatically generated method stub
    System::Object* Enumerator3::Clone_d5efb96d327809c8() {
        return Clone();
    }
    
    // Automatically generated method stub
    bool Enumerator3::MoveNext_4e78e145935f5417() {
        return MoveNext_95653590660ca25b();
    }
    
    // Automatically generated method stub
    void Enumerator3::Reset_bcd82381eed41868() {
        return Reset_f5f37e29637be803();
    }
    
    // Automatically generated method stub
    System::Object* Enumerator3::get_Current_8eca9b3da02b123a() {
        return get_Current_9c1f38e77bf983c1();
    }
    
}}
namespace System { namespace Collections {
    // Automatically generated method stub
    System::Object* Stack::Clone_d5efb96d327809c8() {
        return Clone_be99069adbf1961c();
    }
    
    // Automatically generated method stub
    void Stack::CopyTo_7065a6e3cf6a140(System::Array* array, int32_t index) {
        return CopyTo_f10714ed2802c46b(array, index);
    }
    
    // Automatically generated method stub
    IEnumerator* Stack::GetEnumerator_674ad93a972a4d67() {
        return GetEnumerator_ae53897f8a2f577a();
    }
    
    // Automatically generated method stub
    int32_t Stack::get_Count_8f254f3dd8e2403() {
        return get_Count_a768d394e63a6b27();
    }
    
    // Automatically generated method stub
    bool Stack::get_IsSynchronized_20926e7dabc53dbf() {
        return get_IsSynchronized_d5977c6adec21cc3();
    }
    
    // Automatically generated method stub
    System::Object* Stack::get_SyncRoot_257108f45cc89e19() {
        return get_SyncRoot_d19ca4cd2e3adde6();
    }
    
}}
namespace System { namespace Collections {
    // Automatically generated method stub
    int32_t ComparerImpl::Compare_451fd276747b629d(System::Object* x, System::Object* y) {
        return Compare(x, y);
    }
    
    // Automatically generated method stub
    int32_t ComparerImpl::GetHashCode_f8793dfb2b096a5a(System::Object* obj) {
        return GetHashCode2(obj);
    }
    
    // Automatically generated method stub
    bool ComparerImpl::Equals_ad190887ea91ded(System::Object* x, System::Object* y) {
        return Equals3(x, y);
    }
    
}}
namespace System { namespace Collections { namespace Concurrent {
}}}
namespace System { namespace Collections { namespace Concurrent {
}}}
namespace System { namespace Collections { namespace Concurrent {
}}}
namespace System { namespace Collections { namespace Concurrent {
}}}
namespace System { namespace Collections { namespace Concurrent {
}}}
namespace System { namespace Collections { namespace Concurrent {
}}}
namespace System { namespace Collections { namespace Generic {
}}}
namespace System { namespace Collections { namespace Generic {
}}}
namespace System { namespace Collections { namespace Generic {
}}}
namespace System { namespace Collections { namespace Generic {
}}}
namespace System { namespace Collections { namespace Generic {
}}}
namespace System { namespace Collections { namespace Generic {
}}}
namespace System { namespace Collections { namespace Generic {
}}}
namespace System { namespace Collections { namespace ObjectModel {
}}}
namespace System { namespace Collections { namespace ObjectModel {
}}}
namespace System { namespace Globalization {
    // Automatically generated method stub
    System::Object* Calendar::Clone_d5efb96d327809c8() {
        return Clone_15536a878f1b8fa9();
    }
    
}}
namespace System { namespace Globalization {
    // Automatically generated method stub
    void CompareInfo::OnDeserialization_e9ecfecba8df9754(System::Object* sender) {
        return OnDeserialization(sender);
    }
    
}}
namespace System { namespace Globalization {
    // Automatically generated method stub
    System::Object* CultureInfo::Clone_d5efb96d327809c8() {
        return Clone_490644fd8134e39b();
    }
    
    // Automatically generated method stub
    System::Object* CultureInfo::GetFormat_b67414a65453cc7e(System::Type* formatType) {
        return GetFormat_49958c0908ff1d8f(formatType);
    }
    
}}
namespace System { namespace Globalization {
    // Automatically generated method stub
    void CultureNotFoundException::GetObjectData_11b895a112e04409(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        return GetObjectData_bc9b88d7eb43b6d8(info, context);
    }
    
    // Automatically generated method stub
    System::String* CultureNotFoundException::get_Message_236e49c6b265ab9b() {
        return get_Message_d211df4045b57cbf();
    }
    
}}
namespace System { namespace Globalization {
    // Automatically generated method stub
    System::Object* DateTimeFormatInfo::Clone_d5efb96d327809c8() {
        return Clone();
    }
    
    // Automatically generated method stub
    System::Object* DateTimeFormatInfo::GetFormat_b67414a65453cc7e(System::Type* formatType) {
        return GetFormat(formatType);
    }
    
}}
namespace System { namespace Globalization {
    // Automatically generated method stub
    System::Object* NumberFormatInfo::GetFormat_b67414a65453cc7e(System::Type* formatType) {
        return GetFormat(formatType);
    }
    
    // Automatically generated method stub
    System::Object* NumberFormatInfo::Clone_d5efb96d327809c8() {
        return Clone();
    }
    
}}
namespace System { namespace Globalization {
    // Automatically generated method stub
    bool TextElementEnumerator::MoveNext_4e78e145935f5417() {
        return MoveNext();
    }
    
    // Automatically generated method stub
    void TextElementEnumerator::Reset_bcd82381eed41868() {
        return Reset();
    }
    
    // Automatically generated method stub
    System::Object* TextElementEnumerator::get_Current_8eca9b3da02b123a() {
        return get_Current();
    }
    
}}
namespace System { namespace Globalization {
    // Automatically generated method stub
    void TextInfo::OnDeserialization_e9ecfecba8df9754(System::Object* sender) {
        return OnDeserialization(sender);
    }
    
    // Automatically generated method stub
    System::Object* TextInfo::Clone_d5efb96d327809c8() {
        return Clone_44be9aa808ba92d();
    }
    
}}
namespace System { namespace IO {
    // Automatically generated method stub
    void BinaryReader::Dispose_95cb2516542c2f97() {
        return Dispose2();
    }
    
}}
namespace System { namespace IO {
    // Automatically generated method stub
    void BinaryWriter::Dispose_95cb2516542c2f97() {
        return Dispose();
    }
    
}}
namespace System { namespace IO {
    // Automatically generated method stub
    void DriveInfo::GetObjectData_11b895a112e04409(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        return GetObjectData(info, context);
    }
    
}}
namespace System { namespace IO {
    // Automatically generated method stub
    System::Object* FileStreamAsyncResult::get_AsyncState_edfadcd905632437() {
        return get_AsyncState();
    }
    
    // Automatically generated method stub
    bool FileStreamAsyncResult::get_CompletedSynchronously_2176ca6518f7b5dc() {
        return get_CompletedSynchronously();
    }
    
    // Automatically generated method stub
    System::Threading::WaitHandle* FileStreamAsyncResult::get_AsyncWaitHandle_7620505c49d113f3() {
        return get_AsyncWaitHandle();
    }
    
    // Automatically generated method stub
    bool FileStreamAsyncResult::get_IsCompleted_908b07d70649b7ff() {
        return get_IsCompleted();
    }
    
}}
namespace System { namespace IO {
    // Automatically generated method stub
    void FileSystemInfo::GetObjectData_11b895a112e04409(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        return GetObjectData_e22ded754991345d(info, context);
    }
    
}}
namespace System { namespace IO {
    // Automatically generated method stub
    void Stream::Dispose_95cb2516542c2f97() {
        return Dispose();
    }
    
}}
namespace System { namespace IO {
    // Automatically generated method stub
    void TextReader::Dispose_95cb2516542c2f97() {
        return Dispose();
    }
    
}}
namespace System { namespace IO {
    // Automatically generated method stub
    void TextWriter::Dispose_95cb2516542c2f97() {
        return Dispose2();
    }
    
}}
namespace System { namespace IO {
    // Automatically generated method stub
    void UnmanagedMemoryAccessor::Dispose_95cb2516542c2f97() {
        return Dispose();
    }
    
}}
namespace System { namespace IO { namespace IsolatedStorage {
    // Automatically generated method stub
    void IsolatedStorageFile::Dispose_95cb2516542c2f97() {
        return Dispose();
    }
    
}}}
namespace System { namespace IO { namespace IsolatedStorage {
    // Automatically generated method stub
    bool IsolatedStorageFileEnumerator::MoveNext_4e78e145935f5417() {
        return MoveNext();
    }
    
    // Automatically generated method stub
    void IsolatedStorageFileEnumerator::Reset_bcd82381eed41868() {
        return Reset();
    }
    
    // Automatically generated method stub
    System::Object* IsolatedStorageFileEnumerator::get_Current_8eca9b3da02b123a() {
        return get_Current();
    }
    
}}}
namespace System { namespace Reflection {
    // Automatically generated method stub
    void Assembly::GetObjectData_ae6d7ff8b3644797(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        return GetObjectData_6b61218d0e15f122(info, context);
    }
    
    // Automatically generated method stub
    void Assembly::GetObjectData_11b895a112e04409(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        return GetObjectData_6b61218d0e15f122(info, context);
    }
    
    // Automatically generated method stub
    bool Assembly::IsDefined_3200a5511fa7cc68(System::Type* attributeType, bool inherit) {
        return IsDefined_42f87feac494b032(attributeType, inherit);
    }
    
    // Automatically generated method stub
    bool Assembly::IsDefined_8c9afbc5cd24386a(System::Type* attributeType, bool inherit) {
        return IsDefined_42f87feac494b032(attributeType, inherit);
    }
    
    // Automatically generated method stub
    cli::array<System::Object*>* Assembly::GetCustomAttributes_c6789c4338e26d2b(bool inherit) {
        return GetCustomAttributes_887544480e7ebe63(inherit);
    }
    
    // Automatically generated method stub
    cli::array<System::Object*>* Assembly::GetCustomAttributes_24af6ad180c3735(bool inherit) {
        return GetCustomAttributes_887544480e7ebe63(inherit);
    }
    
    // Automatically generated method stub
    cli::array<System::Object*>* Assembly::GetCustomAttributes_a458b60110eb1adc(System::Type* attributeType, bool inherit) {
        return GetCustomAttributes_30a143c7dfd48919(attributeType, inherit);
    }
    
    // Automatically generated method stub
    cli::array<System::Object*>* Assembly::GetCustomAttributes_5ff69fa11191e1b5(System::Type* attributeType, bool inherit) {
        return GetCustomAttributes_30a143c7dfd48919(attributeType, inherit);
    }
    
    // Automatically generated method stub
    cli::array<System::IO::FileStream*>* Assembly::GetFiles_6c517f2273715467() {
        return GetFiles_4f893757e6a7c4b6();
    }
    
    // Automatically generated method stub
    cli::array<System::IO::FileStream*>* Assembly::GetFiles_83c5197d3be9ba99(bool getResourceModules) {
        return GetFiles_4b160752c34b70d5(getResourceModules);
    }
    
    // Automatically generated method stub
    System::IO::FileStream* Assembly::GetFile_6615c487c2ac205(System::String* name) {
        return GetFile_321baf5b87b86022(name);
    }
    
    // Automatically generated method stub
    System::IO::Stream* Assembly::GetManifestResourceStream_c4c4dd7ea9b411f6(System::String* name) {
        return GetManifestResourceStream_b395b331908084e(name);
    }
    
    // Automatically generated method stub
    System::IO::Stream* Assembly::GetManifestResourceStream_20b4219e40c67fdc(System::Type* type, System::String* name) {
        return GetManifestResourceStream_6ad572412eedcffd(type, name);
    }
    
    // Automatically generated method stub
    cli::array<System::Type*>* Assembly::GetTypes_ab49a096d38726a7() {
        return GetTypes_596eee17684f649();
    }
    
    // Automatically generated method stub
    cli::array<System::Type*>* Assembly::GetExportedTypes_ee0adeac46d6ab34() {
        return GetExportedTypes_4dc21035aef13039();
    }
    
    // Automatically generated method stub
    System::Type* Assembly::GetType_d55779600806b0d2(System::String* name, bool throwOnError) {
        return GetType_cce33183e0cab1ba(name, throwOnError);
    }
    
    // Automatically generated method stub
    System::Type* Assembly::GetType_7162ad856792a116(System::String* name) {
        return GetType_99cbfcc4e094eb08(name);
    }
    
    // Automatically generated method stub
    AssemblyName* Assembly::GetName_7ef5b4b80c448759(bool copiedName) {
        return GetName_7bcd94721bb29265(copiedName);
    }
    
    // Automatically generated method stub
    AssemblyName* Assembly::GetName_62e3f693cd2ffb23() {
        return GetName_7088a38b93d0dcc5();
    }
    
    // Automatically generated method stub
    System::String* Assembly::ToString_3f4baa3ff40b0198() {
        return ToString_1636a0751cb9ac11();
    }
    
    // Automatically generated method stub
    Module* Assembly::LoadModule_f73be9448f7656b4(System::String* moduleName, cli::array<unsigned char>* rawModule) {
        return LoadModule(moduleName, rawModule);
    }
    
    // Automatically generated method stub
    Module* Assembly::LoadModule_6024c0019defdb86(System::String* moduleName, cli::array<unsigned char>* rawModule, cli::array<unsigned char>* rawSymbolStore) {
        return LoadModule_87df81afaaa787f6(moduleName, rawModule, rawSymbolStore);
    }
    
    // Automatically generated method stub
    System::Object* Assembly::CreateInstance_2b8fb34696040934(System::String* typeName) {
        return CreateInstance(typeName);
    }
    
    // Automatically generated method stub
    System::Object* Assembly::CreateInstance_9c79205ac6f0875a(System::String* typeName, bool ignoreCase) {
        return CreateInstance2(typeName, ignoreCase);
    }
    
    // Automatically generated method stub
    System::Object* Assembly::CreateInstance_86d37a2e814be153(System::String* typeName, bool ignoreCase, BindingFlags bindingAttr, Binder* binder, cli::array<System::Object*>* args, System::Globalization::CultureInfo* culture, cli::array<System::Object*>* activationAttributes) {
        return CreateInstance_d07d9768930f5848(typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes);
    }
    
    // Automatically generated method stub
    cli::array<Module*>* Assembly::GetLoadedModules_7e45bd270ba0508e() {
        return GetLoadedModules();
    }
    
    // Automatically generated method stub
    cli::array<Module*>* Assembly::GetModules_6cc1dd291a7a622() {
        return GetModules();
    }
    
    // Automatically generated method stub
    cli::array<System::String*>* Assembly::GetManifestResourceNames_a76da541e39a6687() {
        return GetManifestResourceNames_d63b24d819c7a44d();
    }
    
    // Automatically generated method stub
    ManifestResourceInfo* Assembly::GetManifestResourceInfo_bcc15dc0035eec0a(System::String* resourceName) {
        return GetManifestResourceInfo_2cc36efdd5a68bdc(resourceName);
    }
    
    // Automatically generated method stub
    int32_t Assembly::GetHashCode_20a08aead0d6820a() {
        return GetHashCode_6648aef0f235ee6c();
    }
    
    // Automatically generated method stub
    bool Assembly::Equals_56ec287b8d40063b(System::Object* o) {
        return Equals_ed975d2f4a7d193e(o);
    }
    
    // Automatically generated method stub
    System::Type* Assembly::GetType_4f7329f347090d49(System::String* name, bool throwOnError, bool ignoreCase) {
        return GetType_30e9b2dcc4956479(name, throwOnError, ignoreCase);
    }
    
    // Automatically generated method stub
    Module* Assembly::GetModule_a7906997a13617a7(System::String* name) {
        return GetModule_d3e09c815c6ebd46(name);
    }
    
    // Automatically generated method stub
    cli::array<AssemblyName*>* Assembly::GetReferencedAssemblies_1e24baa3c5838f22() {
        return GetReferencedAssemblies_c967ce8a0efd4c58();
    }
    
    // Automatically generated method stub
    cli::array<Module*>* Assembly::GetModules_70286f2f0a1cfacc(bool getResourceModules) {
        return GetModules_1ce70abfc6e0d050(getResourceModules);
    }
    
    // Automatically generated method stub
    cli::array<Module*>* Assembly::GetLoadedModules_f8ba3198d02efd9f(bool getResourceModules) {
        return GetLoadedModules_db6b585bebc1ac2e(getResourceModules);
    }
    
    // Automatically generated method stub
    Assembly* Assembly::GetSatelliteAssembly_ba2feb006a3fcaa4(System::Globalization::CultureInfo* culture) {
        return GetSatelliteAssembly_995bfc41ec1f61b8(culture);
    }
    
    // Automatically generated method stub
    Assembly* Assembly::GetSatelliteAssembly_f069f89f4969cda7(System::Globalization::CultureInfo* culture, System::Version* version) {
        return GetSatelliteAssembly_22d0b12d929a333c(culture, version);
    }
    
    // Automatically generated method stub
    System::String* Assembly::get_CodeBase_dc45d01428f64731() {
        return get_CodeBase_5e12949b795c9d90();
    }
    
    // Automatically generated method stub
    System::String* Assembly::get_EscapedCodeBase_14607f27139752e7() {
        return get_EscapedCodeBase_2cc20f2402d62395();
    }
    
    // Automatically generated method stub
    System::String* Assembly::get_FullName_f0e20ee2bbdaa1a9() {
        return get_FullName_abd52da7f47cce07();
    }
    
    // Automatically generated method stub
    MethodInfo* Assembly::get_EntryPoint_2f6c2f38d51e8a4a() {
        return get_EntryPoint_63c1ef73cc6df57c();
    }
    
    // Automatically generated method stub
    System::Security::Policy::Evidence* Assembly::get_Evidence_d7f857b710104664() {
        return get_Evidence_4f4a60b88ffe9545();
    }
    
    // Automatically generated method stub
    System::Security::Policy::Evidence* Assembly::get_Evidence_f1eadb7cf64a7592() {
        return get_Evidence_4f4a60b88ffe9545();
    }
    
    // Automatically generated method stub
    System::String* Assembly::get_Location_b64a656d361bdd61() {
        return get_Location_3a7779d7eb72fa50();
    }
    
    // Automatically generated method stub
    bool Assembly::get_GlobalAssemblyCache_dace09e2d2af9909() {
        return get_GlobalAssemblyCache_db80d4f5ee2824e7();
    }
    
    // Automatically generated method stub
    void Assembly::add_ModuleResolve_d5a251350234170b(ModuleResolveEventHandler* value) {
        return add_ModuleResolve(value);
    }
    
    // Automatically generated method stub
    void Assembly::remove_ModuleResolve_e6556aa4bfb257ed(ModuleResolveEventHandler* value) {
        return remove_ModuleResolve(value);
    }
    
    // Automatically generated method stub
    System::Type* Assembly::GetType_c52017a01d9d8f63() {
        return GetType();
    }
    
}}
namespace System { namespace Reflection {
    // Automatically generated method stub
    void AssemblyName::GetObjectData_11b895a112e04409(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        return GetObjectData(info, context);
    }
    
    // Automatically generated method stub
    System::Object* AssemblyName::Clone_d5efb96d327809c8() {
        return Clone();
    }
    
    // Automatically generated method stub
    void AssemblyName::OnDeserialization_e9ecfecba8df9754(System::Object* sender) {
        return OnDeserialization(sender);
    }
    
    // Automatically generated method stub
    void AssemblyName::GetIDsOfNames_95a76c89ebfee4d(System::Guid riid, void* rgszNames, uint32_t cNames, uint32_t lcid, void* rgDispId) {
        return GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    }
    
    // Automatically generated method stub
    void AssemblyName::GetTypeInfo_9ad68d87655154c4(uint32_t iTInfo, uint32_t lcid, void* ppTInfo) {
        return GetTypeInfo(iTInfo, lcid, ppTInfo);
    }
    
    // Automatically generated method stub
    void AssemblyName::GetTypeInfoCount_d37b4bcf885883cd(uint32_t pcTInfo) {
        return GetTypeInfoCount(pcTInfo);
    }
    
    // Automatically generated method stub
    void AssemblyName::Invoke_fc10cebd8e601a2b(uint32_t dispIdMember, System::Guid riid, uint32_t lcid, int16_t wFlags, void* pDispParams, void* pVarResult, void* pExcepInfo, void* puArgErr) {
        return Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    }
    
}}
namespace System { namespace Reflection {
    // Automatically generated method stub
    void ConstructorInfo::GetIDsOfNames_c6568bbd8217c026(System::Guid riid, void* rgszNames, uint32_t cNames, uint32_t lcid, void* rgDispId) {
        return GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    }
    
    // Automatically generated method stub
    void ConstructorInfo::GetTypeInfo_6480748fd8ab715e(uint32_t iTInfo, uint32_t lcid, void* ppTInfo) {
        return GetTypeInfo(iTInfo, lcid, ppTInfo);
    }
    
    // Automatically generated method stub
    void ConstructorInfo::GetTypeInfoCount_687ea54167dc994f(uint32_t pcTInfo) {
        return GetTypeInfoCount(pcTInfo);
    }
    
    // Automatically generated method stub
    void ConstructorInfo::Invoke_e82f3d71479774ad(uint32_t dispIdMember, System::Guid riid, uint32_t lcid, int16_t wFlags, void* pDispParams, void* pVarResult, void* pExcepInfo, void* puArgErr) {
        return Invoke6(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    }
    
    // Automatically generated method stub
    System::Object* ConstructorInfo::Invoke_2_14438888c13b8089(System::Object* obj, BindingFlags invokeAttr, Binder* binder, cli::array<System::Object*>* parameters, System::Globalization::CultureInfo* culture) {
        return Invoke_2(obj, invokeAttr, binder, parameters, culture);
    }
    
    // Automatically generated method stub
    System::Object* ConstructorInfo::Invoke_3_e668ab16fb388f95(System::Object* obj, cli::array<System::Object*>* parameters) {
        return Invoke_3(obj, parameters);
    }
    
    // Automatically generated method stub
    System::Object* ConstructorInfo::Invoke_4_5502ea7285269681(BindingFlags invokeAttr, Binder* binder, cli::array<System::Object*>* parameters, System::Globalization::CultureInfo* culture) {
        return Invoke_4(invokeAttr, binder, parameters, culture);
    }
    
    // Automatically generated method stub
    System::Object* ConstructorInfo::Invoke_5_e3382599d6c7cceb(cli::array<System::Object*>* parameters) {
        return Invoke_5(parameters);
    }
    
    // Automatically generated method stub
    bool ConstructorInfo::Equals_67213e4a572bc930(System::Object* obj) {
        return Equals_ed975d2f4a7d193e(obj);
    }
    
    // Automatically generated method stub
    int32_t ConstructorInfo::GetHashCode_528f3df200ed9cf9() {
        return GetHashCode_6648aef0f235ee6c();
    }
    
    // Automatically generated method stub
    MemberTypes ConstructorInfo::get_MemberType_70d1fdc4531f4ea4() {
        return get_MemberType_cd521d320810c98f();
    }
    
    // Automatically generated method stub
    cli::array<System::Object*>* ConstructorInfo::GetCustomAttributes_909f5c802320f2c6(bool inherit) {
        return GetCustomAttributes_b790992b66049291(inherit);
    }
    
    // Automatically generated method stub
    cli::array<System::Object*>* ConstructorInfo::GetCustomAttributes_ddf21a2a0e530872(System::Type* attributeType, bool inherit) {
        return GetCustomAttributes_90419687cfa65ef7(attributeType, inherit);
    }
    
    // Automatically generated method stub
    MethodImplAttributes ConstructorInfo::GetMethodImplementationFlags_f9d0009b54342b06() {
        return GetMethodImplementationFlags_34d93dba8c4849e8();
    }
    
    // Automatically generated method stub
    cli::array<ParameterInfo*>* ConstructorInfo::GetParameters_315d4cfcd47e1490() {
        return GetParameters_9d17bcb549474c9();
    }
    
    // Automatically generated method stub
    System::Type* ConstructorInfo::GetType_2f67a2a342d63d5f() {
        return GetType();
    }
    
    // Automatically generated method stub
    bool ConstructorInfo::IsDefined_d9b1dc794b1ab365(System::Type* attributeType, bool inherit) {
        return IsDefined_91943a8ac363f11f(attributeType, inherit);
    }
    
    // Automatically generated method stub
    System::String* ConstructorInfo::ToString_a95e215a60192892() {
        return ToString_1636a0751cb9ac11();
    }
    
    // Automatically generated method stub
    MethodAttributes ConstructorInfo::get_Attributes_add5cbc0ca209cb4() {
        return get_Attributes_b3976e6a55c088be();
    }
    
    // Automatically generated method stub
    CallingConventions ConstructorInfo::get_CallingConvention_a50132e872765544() {
        return get_CallingConvention_309cf574b58a053a();
    }
    
    // Automatically generated method stub
    System::Type* ConstructorInfo::get_DeclaringType_8b35019cb974f3b1() {
        return get_DeclaringType_6121cd6a84393166();
    }
    
    // Automatically generated method stub
    bool ConstructorInfo::get_IsAbstract_9d2bdd8154847129() {
        return get_IsAbstract();
    }
    
    // Automatically generated method stub
    bool ConstructorInfo::get_IsAssembly_395fd16440c057f5() {
        return get_IsAssembly();
    }
    
    // Automatically generated method stub
    bool ConstructorInfo::get_IsConstructor_1807a2d9ec103a6d() {
        return get_IsConstructor();
    }
    
    // Automatically generated method stub
    bool ConstructorInfo::get_IsFamily_7e3a06dd49ba1d52() {
        return get_IsFamily();
    }
    
    // Automatically generated method stub
    bool ConstructorInfo::get_IsFamilyAndAssembly_89cd687b074d26c4() {
        return get_IsFamilyAndAssembly();
    }
    
    // Automatically generated method stub
    bool ConstructorInfo::get_IsFamilyOrAssembly_90f959a01432cea6() {
        return get_IsFamilyOrAssembly();
    }
    
    // Automatically generated method stub
    bool ConstructorInfo::get_IsFinal_8c6c57491692dd9a() {
        return get_IsFinal();
    }
    
    // Automatically generated method stub
    bool ConstructorInfo::get_IsHideBySig_be7fcdcfe8827c6e() {
        return get_IsHideBySig();
    }
    
    // Automatically generated method stub
    bool ConstructorInfo::get_IsPrivate_8eacdf2fa9e4b9c5() {
        return get_IsPrivate();
    }
    
    // Automatically generated method stub
    bool ConstructorInfo::get_IsPublic_32e3a6d67086bb9d() {
        return get_IsPublic();
    }
    
    // Automatically generated method stub
    bool ConstructorInfo::get_IsSpecialName_e3c4ca4e8c7625() {
        return get_IsSpecialName();
    }
    
    // Automatically generated method stub
    bool ConstructorInfo::get_IsStatic_129345b6fd10cac8() {
        return get_IsStatic();
    }
    
    // Automatically generated method stub
    bool ConstructorInfo::get_IsVirtual_dd87e32e57ef90b8() {
        return get_IsVirtual();
    }
    
    // Automatically generated method stub
    System::RuntimeMethodHandle ConstructorInfo::get_MethodHandle_b017ef7fbcec2e84() {
        return get_MethodHandle_a92ba3e25e0a5ec8();
    }
    
    // Automatically generated method stub
    System::String* ConstructorInfo::get_Name_22e38b3f8832b162() {
        return get_Name_50fad5fa936c3ae2();
    }
    
    // Automatically generated method stub
    System::Type* ConstructorInfo::get_ReflectedType_126e247c32a10788() {
        return get_ReflectedType_bf4971c0f442b9dc();
    }
    
}}
namespace System { namespace Reflection {
    // Automatically generated method stub
    void EventInfo::AddEventHandler_43d8c94497c03223(System::Object* target, System::Delegate* handler) {
        return AddEventHandler_ad88f4bed9d5ff3c(target, handler);
    }
    
    // Automatically generated method stub
    MethodInfo* EventInfo::GetAddMethod_b8ad5c9a0997b299() {
        return GetAddMethod();
    }
    
    // Automatically generated method stub
    MethodInfo* EventInfo::GetAddMethod_603de97606b6f9ba(bool nonPublic) {
        return GetAddMethod_e6ed2f5f0e24f59f(nonPublic);
    }
    
    // Automatically generated method stub
    MethodInfo* EventInfo::GetRaiseMethod_b646ee39c81574e3() {
        return GetRaiseMethod();
    }
    
    // Automatically generated method stub
    MethodInfo* EventInfo::GetRaiseMethod_6b206823316c0c3(bool nonPublic) {
        return GetRaiseMethod_da2f94f17ce18705(nonPublic);
    }
    
    // Automatically generated method stub
    MethodInfo* EventInfo::GetRemoveMethod_5c784be17c5066d3() {
        return GetRemoveMethod();
    }
    
    // Automatically generated method stub
    MethodInfo* EventInfo::GetRemoveMethod_da0b684fb4d4c4a0(bool nonPublic) {
        return GetRemoveMethod_2709ba07e73fded4(nonPublic);
    }
    
    // Automatically generated method stub
    void EventInfo::RemoveEventHandler_20b46eba63f124c5(System::Object* target, System::Delegate* handler) {
        return RemoveEventHandler_3607721c5f918cf8(target, handler);
    }
    
    // Automatically generated method stub
    bool EventInfo::Equals_74589a42728bf90e(System::Object* obj) {
        return Equals_ed975d2f4a7d193e(obj);
    }
    
    // Automatically generated method stub
    int32_t EventInfo::GetHashCode_b17eaacfd022126a() {
        return GetHashCode_6648aef0f235ee6c();
    }
    
    // Automatically generated method stub
    void EventInfo::GetIDsOfNames_23802a60f491840e(System::Guid riid, void* rgszNames, uint32_t cNames, uint32_t lcid, void* rgDispId) {
        return GetIDsOfNames2(riid, rgszNames, cNames, lcid, rgDispId);
    }
    
    // Automatically generated method stub
    void EventInfo::GetTypeInfo_f3ce2c87f102b967(uint32_t iTInfo, uint32_t lcid, void* ppTInfo) {
        return GetTypeInfo2(iTInfo, lcid, ppTInfo);
    }
    
    // Automatically generated method stub
    void EventInfo::GetTypeInfoCount_fa070d4fce2714f5(uint32_t pcTInfo) {
        return GetTypeInfoCount2(pcTInfo);
    }
    
    // Automatically generated method stub
    void EventInfo::Invoke_8ea6ee7f8b34ed83(uint32_t dispIdMember, System::Guid riid, uint32_t lcid, int16_t wFlags, void* pDispParams, void* pVarResult, void* pExcepInfo, void* puArgErr) {
        return Invoke2(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    }
    
    // Automatically generated method stub
    EventAttributes EventInfo::get_Attributes_91126e6e9bda9278() {
        return get_Attributes_3412d62533ff880();
    }
    
    // Automatically generated method stub
    System::Type* EventInfo::get_EventHandlerType_394adbc6331a2c50() {
        return get_EventHandlerType_814bf5fc85dc0978();
    }
    
    // Automatically generated method stub
    bool EventInfo::get_IsMulticast_f3825bb24df5079f() {
        return get_IsMulticast_acc4249946776471();
    }
    
    // Automatically generated method stub
    bool EventInfo::get_IsSpecialName_7600c5d3a63b1be9() {
        return get_IsSpecialName();
    }
    
    // Automatically generated method stub
    MemberTypes EventInfo::get_MemberType_7f92432e8d28a37() {
        return get_MemberType_cd521d320810c98f();
    }
    
    // Automatically generated method stub
    cli::array<System::Object*>* EventInfo::GetCustomAttributes_fa63d0ff32ae5fc8(bool inherit) {
        return GetCustomAttributes_b790992b66049291(inherit);
    }
    
    // Automatically generated method stub
    cli::array<System::Object*>* EventInfo::GetCustomAttributes_d3fde144b6b8ae22(System::Type* attributeType, bool inherit) {
        return GetCustomAttributes_90419687cfa65ef7(attributeType, inherit);
    }
    
    // Automatically generated method stub
    System::Type* EventInfo::GetType_5dcc5daa0b76d62() {
        return GetType();
    }
    
    // Automatically generated method stub
    bool EventInfo::IsDefined_7f2e7c95c1a2697(System::Type* attributeType, bool inherit) {
        return IsDefined_91943a8ac363f11f(attributeType, inherit);
    }
    
    // Automatically generated method stub
    System::String* EventInfo::ToString_7bb73a9f3918b46f() {
        return ToString_1636a0751cb9ac11();
    }
    
    // Automatically generated method stub
    System::Type* EventInfo::get_DeclaringType_b190790d6bb5c6f8() {
        return get_DeclaringType_6121cd6a84393166();
    }
    
    // Automatically generated method stub
    System::String* EventInfo::get_Name_34bcf56a8cc37ed8() {
        return get_Name_50fad5fa936c3ae2();
    }
    
    // Automatically generated method stub
    System::Type* EventInfo::get_ReflectedType_324d464fdf876c3() {
        return get_ReflectedType_bf4971c0f442b9dc();
    }
    
}}
namespace System { namespace Reflection {
    // Automatically generated method stub
    System::Object* FieldInfo::GetValue_95ea295e93d9c205(System::Object* obj) {
        return GetValue_57ad13b528e8b8a5(obj);
    }
    
    // Automatically generated method stub
    void FieldInfo::SetValue_14cd561b90357660(System::Object* obj, System::Object* value, BindingFlags invokeAttr, Binder* binder, System::Globalization::CultureInfo* culture) {
        return SetValue_b73df766c23f1507(obj, value, invokeAttr, binder, culture);
    }
    
    // Automatically generated method stub
    void FieldInfo::SetValue_bff43279853da815(System::Object* obj, System::Object* value) {
        return SetValue2(obj, value);
    }
    
    // Automatically generated method stub
    System::Object* FieldInfo::GetValueDirect_667c004c43af2df7(System::TypedReference obj) {
        return GetValueDirect_fe94b812363b7da5(obj);
    }
    
    // Automatically generated method stub
    void FieldInfo::SetValueDirect_a9c4f4eec2bc7475(System::TypedReference obj, System::Object* value) {
        return SetValueDirect_6c2dbfe9e649b416(obj, value);
    }
    
    // Automatically generated method stub
    bool FieldInfo::Equals_9460c999c7a56206(System::Object* obj) {
        return Equals_ed975d2f4a7d193e(obj);
    }
    
    // Automatically generated method stub
    int32_t FieldInfo::GetHashCode_5a649ad5c5c43cca() {
        return GetHashCode_6648aef0f235ee6c();
    }
    
    // Automatically generated method stub
    void FieldInfo::GetIDsOfNames_bc4e4af5039b7c20(System::Guid riid, void* rgszNames, uint32_t cNames, uint32_t lcid, void* rgDispId) {
        return GetIDsOfNames2(riid, rgszNames, cNames, lcid, rgDispId);
    }
    
    // Automatically generated method stub
    void FieldInfo::GetTypeInfo_8134a221284f4ba5(uint32_t iTInfo, uint32_t lcid, void* ppTInfo) {
        return GetTypeInfo2(iTInfo, lcid, ppTInfo);
    }
    
    // Automatically generated method stub
    void FieldInfo::GetTypeInfoCount_81bba0bef18b5824(uint32_t pcTInfo) {
        return GetTypeInfoCount2(pcTInfo);
    }
    
    // Automatically generated method stub
    void FieldInfo::Invoke_ef3e075c01706822(uint32_t dispIdMember, System::Guid riid, uint32_t lcid, int16_t wFlags, void* pDispParams, void* pVarResult, void* pExcepInfo, void* puArgErr) {
        return Invoke2(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    }
    
    // Automatically generated method stub
    FieldAttributes FieldInfo::get_Attributes_adffe146267d1214() {
        return get_Attributes_ecc2fe2071b9c047();
    }
    
    // Automatically generated method stub
    System::RuntimeFieldHandle FieldInfo::get_FieldHandle_1992b90454f55bf5() {
        return get_FieldHandle_43fbd13b33ef15a8();
    }
    
    // Automatically generated method stub
    System::Type* FieldInfo::get_FieldType_95a03f2dcf5511a9() {
        return get_FieldType_1dab4079098d7fff();
    }
    
    // Automatically generated method stub
    MemberTypes FieldInfo::get_MemberType_dc52cdbb2693a23a() {
        return get_MemberType_cd521d320810c98f();
    }
    
    // Automatically generated method stub
    bool FieldInfo::get_IsLiteral_28466bffcbcd522() {
        return get_IsLiteral();
    }
    
    // Automatically generated method stub
    bool FieldInfo::get_IsStatic_a14ccf83b632c9b4() {
        return get_IsStatic();
    }
    
    // Automatically generated method stub
    bool FieldInfo::get_IsInitOnly_92c94432c489bd06() {
        return get_IsInitOnly();
    }
    
    // Automatically generated method stub
    bool FieldInfo::get_IsPublic_de3389d9f6383193() {
        return get_IsPublic();
    }
    
    // Automatically generated method stub
    bool FieldInfo::get_IsPrivate_eafc38c3d2a23aaa() {
        return get_IsPrivate();
    }
    
    // Automatically generated method stub
    bool FieldInfo::get_IsFamily_7a1a19e876496230() {
        return get_IsFamily();
    }
    
    // Automatically generated method stub
    bool FieldInfo::get_IsAssembly_7b632c06d77bf7f9() {
        return get_IsAssembly();
    }
    
    // Automatically generated method stub
    bool FieldInfo::get_IsFamilyAndAssembly_863e9b0f875c7704() {
        return get_IsFamilyAndAssembly();
    }
    
    // Automatically generated method stub
    bool FieldInfo::get_IsFamilyOrAssembly_19cc6861b480a8ed() {
        return get_IsFamilyOrAssembly();
    }
    
    // Automatically generated method stub
    bool FieldInfo::get_IsPinvokeImpl_db85c58b7a196918() {
        return get_IsPinvokeImpl();
    }
    
    // Automatically generated method stub
    bool FieldInfo::get_IsSpecialName_eaaed4f25dea5d2f() {
        return get_IsSpecialName();
    }
    
    // Automatically generated method stub
    bool FieldInfo::get_IsNotSerialized_24ecbaffa59651c8() {
        return get_IsNotSerialized();
    }
    
    // Automatically generated method stub
    cli::array<System::Object*>* FieldInfo::GetCustomAttributes_575e5069ebfca34f(bool inherit) {
        return GetCustomAttributes_b790992b66049291(inherit);
    }
    
    // Automatically generated method stub
    cli::array<System::Object*>* FieldInfo::GetCustomAttributes_5acdc1cb26d1261f(System::Type* attributeType, bool inherit) {
        return GetCustomAttributes_90419687cfa65ef7(attributeType, inherit);
    }
    
    // Automatically generated method stub
    System::Type* FieldInfo::GetType_3c93304fd89a812b() {
        return GetType();
    }
    
    // Automatically generated method stub
    bool FieldInfo::IsDefined_d05f61558bec5ed2(System::Type* attributeType, bool inherit) {
        return IsDefined_91943a8ac363f11f(attributeType, inherit);
    }
    
    // Automatically generated method stub
    System::String* FieldInfo::ToString_f22c3c4f8be6702d() {
        return ToString_1636a0751cb9ac11();
    }
    
    // Automatically generated method stub
    System::Type* FieldInfo::get_DeclaringType_c4f8b59fa02e7a62() {
        return get_DeclaringType_6121cd6a84393166();
    }
    
    // Automatically generated method stub
    System::String* FieldInfo::get_Name_1e5ba9be5de44c4a() {
        return get_Name_50fad5fa936c3ae2();
    }
    
    // Automatically generated method stub
    System::Type* FieldInfo::get_ReflectedType_127893312bd5a2c0() {
        return get_ReflectedType_bf4971c0f442b9dc();
    }
    
}}
namespace System { namespace Reflection {
    // Automatically generated method stub
    bool MemberInfo::IsDefined_3200a5511fa7cc68(System::Type* attributeType, bool inherit) {
        return IsDefined_91943a8ac363f11f(attributeType, inherit);
    }
    
    // Automatically generated method stub
    bool MemberInfo::IsDefined_9a29baf351241ea8(System::Type* attributeType, bool inherit) {
        return IsDefined_91943a8ac363f11f(attributeType, inherit);
    }
    
    // Automatically generated method stub
    cli::array<System::Object*>* MemberInfo::GetCustomAttributes_c6789c4338e26d2b(bool inherit) {
        return GetCustomAttributes_b790992b66049291(inherit);
    }
    
    // Automatically generated method stub
    cli::array<System::Object*>* MemberInfo::GetCustomAttributes_1e9c83be1d923116(bool inherit) {
        return GetCustomAttributes_b790992b66049291(inherit);
    }
    
    // Automatically generated method stub
    cli::array<System::Object*>* MemberInfo::GetCustomAttributes_a458b60110eb1adc(System::Type* attributeType, bool inherit) {
        return GetCustomAttributes_90419687cfa65ef7(attributeType, inherit);
    }
    
    // Automatically generated method stub
    cli::array<System::Object*>* MemberInfo::GetCustomAttributes_3f972bb24bf44f4e(System::Type* attributeType, bool inherit) {
        return GetCustomAttributes_90419687cfa65ef7(attributeType, inherit);
    }
    
    // Automatically generated method stub
    bool MemberInfo::Equals_e3e2ad51cac823cf(System::Object* obj) {
        return Equals_ed975d2f4a7d193e(obj);
    }
    
    // Automatically generated method stub
    int32_t MemberInfo::GetHashCode_aec47076d35c126c() {
        return GetHashCode_6648aef0f235ee6c();
    }
    
    // Automatically generated method stub
    void MemberInfo::GetIDsOfNames_728279314ddde699(System::Guid riid, void* rgszNames, uint32_t cNames, uint32_t lcid, void* rgDispId) {
        return GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    }
    
    // Automatically generated method stub
    void MemberInfo::GetTypeInfo_c9dc23100dd864c7(uint32_t iTInfo, uint32_t lcid, void* ppTInfo) {
        return GetTypeInfo(iTInfo, lcid, ppTInfo);
    }
    
    // Automatically generated method stub
    void MemberInfo::GetTypeInfoCount_74162cfe932123cb(uint32_t pcTInfo) {
        return GetTypeInfoCount(pcTInfo);
    }
    
    // Automatically generated method stub
    void MemberInfo::Invoke_dc29eb2afa4cd141(uint32_t dispIdMember, System::Guid riid, uint32_t lcid, int16_t wFlags, void* pDispParams, void* pVarResult, void* pExcepInfo, void* puArgErr) {
        return Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    }
    
    // Automatically generated method stub
    System::Type* MemberInfo::get_DeclaringType_45ac98b183897971() {
        return get_DeclaringType_6121cd6a84393166();
    }
    
    // Automatically generated method stub
    MemberTypes MemberInfo::get_MemberType_fb536638b8ed56c7() {
        return get_MemberType_cd521d320810c98f();
    }
    
    // Automatically generated method stub
    System::String* MemberInfo::get_Name_70a7d5287f19ebf8() {
        return get_Name_50fad5fa936c3ae2();
    }
    
    // Automatically generated method stub
    System::Type* MemberInfo::get_ReflectedType_b357cb7ff6b67a77() {
        return get_ReflectedType_bf4971c0f442b9dc();
    }
    
    // Automatically generated method stub
    System::Type* MemberInfo::GetType_291272aa21703927() {
        return GetType();
    }
    
    // Automatically generated method stub
    System::String* MemberInfo::ToString_bbdca41cc47e5d27() {
        return ToString_1636a0751cb9ac11();
    }
    
}}
namespace System { namespace Reflection {
    // Automatically generated method stub
    void MemberInfoSerializationHolder::GetObjectData_11b895a112e04409(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        return GetObjectData(info, context);
    }
    
    // Automatically generated method stub
    System::Object* MemberInfoSerializationHolder::GetRealObject_692566897a6926e4(System::Runtime::Serialization::StreamingContext context) {
        return GetRealObject(context);
    }
    
}}
namespace System { namespace Reflection {
    // Automatically generated method stub
    MethodImplAttributes MethodBase::GetMethodImplementationFlags_814f2d9055c5e3f0() {
        return GetMethodImplementationFlags_34d93dba8c4849e8();
    }
    
    // Automatically generated method stub
    cli::array<ParameterInfo*>* MethodBase::GetParameters_ab7269a35b115074() {
        return GetParameters_9d17bcb549474c9();
    }
    
    // Automatically generated method stub
    System::Object* MethodBase::Invoke_53b572f36e795bf7(System::Object* obj, cli::array<System::Object*>* parameters) {
        return Invoke2(obj, parameters);
    }
    
    // Automatically generated method stub
    System::Object* MethodBase::Invoke_26dd0cb2b98af8a7(System::Object* obj, BindingFlags invokeAttr, Binder* binder, cli::array<System::Object*>* parameters, System::Globalization::CultureInfo* culture) {
        return Invoke_ba5f4e14507fdb95(obj, invokeAttr, binder, parameters, culture);
    }
    
    // Automatically generated method stub
    bool MethodBase::Equals_40cb186ce0df4494(System::Object* obj) {
        return Equals_ed975d2f4a7d193e(obj);
    }
    
    // Automatically generated method stub
    int32_t MethodBase::GetHashCode_500c457e110796c() {
        return GetHashCode_6648aef0f235ee6c();
    }
    
    // Automatically generated method stub
    void MethodBase::GetIDsOfNames_2a1bcdee1bef14ae(System::Guid riid, void* rgszNames, uint32_t cNames, uint32_t lcid, void* rgDispId) {
        return GetIDsOfNames2(riid, rgszNames, cNames, lcid, rgDispId);
    }
    
    // Automatically generated method stub
    void MethodBase::GetTypeInfo_e95f8864a8b4dee1(uint32_t iTInfo, uint32_t lcid, void* ppTInfo) {
        return GetTypeInfo2(iTInfo, lcid, ppTInfo);
    }
    
    // Automatically generated method stub
    void MethodBase::GetTypeInfoCount_b94bcd4bce9387aa(uint32_t pcTInfo) {
        return GetTypeInfoCount2(pcTInfo);
    }
    
    // Automatically generated method stub
    void MethodBase::Invoke_f90d995426760012(uint32_t dispIdMember, System::Guid riid, uint32_t lcid, int16_t wFlags, void* pDispParams, void* pVarResult, void* pExcepInfo, void* puArgErr) {
        return Invoke4(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    }
    
    // Automatically generated method stub
    System::RuntimeMethodHandle MethodBase::get_MethodHandle_67a441d308d5bdc9() {
        return get_MethodHandle_a92ba3e25e0a5ec8();
    }
    
    // Automatically generated method stub
    MethodAttributes MethodBase::get_Attributes_834ca72eefacb0bd() {
        return get_Attributes_b3976e6a55c088be();
    }
    
    // Automatically generated method stub
    CallingConventions MethodBase::get_CallingConvention_1674d1fe4ad1e34e() {
        return get_CallingConvention_309cf574b58a053a();
    }
    
    // Automatically generated method stub
    bool MethodBase::get_IsPublic_1c6a14b9c1ddb3f5() {
        return get_IsPublic();
    }
    
    // Automatically generated method stub
    bool MethodBase::get_IsPrivate_177db4f7934a595a() {
        return get_IsPrivate();
    }
    
    // Automatically generated method stub
    bool MethodBase::get_IsFamily_fcf1926f66141f44() {
        return get_IsFamily();
    }
    
    // Automatically generated method stub
    bool MethodBase::get_IsAssembly_f7d9c32268907cdc() {
        return get_IsAssembly();
    }
    
    // Automatically generated method stub
    bool MethodBase::get_IsFamilyAndAssembly_34671eb788f57d0b() {
        return get_IsFamilyAndAssembly();
    }
    
    // Automatically generated method stub
    bool MethodBase::get_IsFamilyOrAssembly_915fd33863bef97e() {
        return get_IsFamilyOrAssembly();
    }
    
    // Automatically generated method stub
    bool MethodBase::get_IsStatic_280bee21a683e29c() {
        return get_IsStatic();
    }
    
    // Automatically generated method stub
    bool MethodBase::get_IsFinal_26ad179ceb0609b5() {
        return get_IsFinal();
    }
    
    // Automatically generated method stub
    bool MethodBase::get_IsVirtual_7120132dcf43b827() {
        return get_IsVirtual();
    }
    
    // Automatically generated method stub
    bool MethodBase::get_IsHideBySig_c27a18b0abb31987() {
        return get_IsHideBySig();
    }
    
    // Automatically generated method stub
    bool MethodBase::get_IsAbstract_de0ff4f1d2087910() {
        return get_IsAbstract();
    }
    
    // Automatically generated method stub
    bool MethodBase::get_IsSpecialName_e092294531426238() {
        return get_IsSpecialName();
    }
    
    // Automatically generated method stub
    bool MethodBase::get_IsConstructor_6eb1b3801f865555() {
        return get_IsConstructor();
    }
    
    // Automatically generated method stub
    cli::array<System::Object*>* MethodBase::GetCustomAttributes_9acb43cc08958c3c(bool inherit) {
        return GetCustomAttributes_b790992b66049291(inherit);
    }
    
    // Automatically generated method stub
    cli::array<System::Object*>* MethodBase::GetCustomAttributes_bcf9f5a3895b278a(System::Type* attributeType, bool inherit) {
        return GetCustomAttributes_90419687cfa65ef7(attributeType, inherit);
    }
    
    // Automatically generated method stub
    System::Type* MethodBase::GetType_75d3f421672cd6ae() {
        return GetType();
    }
    
    // Automatically generated method stub
    bool MethodBase::IsDefined_546d947518082fbd(System::Type* attributeType, bool inherit) {
        return IsDefined_91943a8ac363f11f(attributeType, inherit);
    }
    
    // Automatically generated method stub
    System::String* MethodBase::ToString_21503bff1b89098b() {
        return ToString_1636a0751cb9ac11();
    }
    
    // Automatically generated method stub
    System::Type* MethodBase::get_DeclaringType_b92021fbacc99856() {
        return get_DeclaringType_6121cd6a84393166();
    }
    
    // Automatically generated method stub
    MemberTypes MethodBase::get_MemberType_871696f84e650fc6() {
        return get_MemberType_cd521d320810c98f();
    }
    
    // Automatically generated method stub
    System::String* MethodBase::get_Name_2ca1b8185aa6eb66() {
        return get_Name_50fad5fa936c3ae2();
    }
    
    // Automatically generated method stub
    System::Type* MethodBase::get_ReflectedType_80c44a42bf1581d3() {
        return get_ReflectedType_bf4971c0f442b9dc();
    }
    
}}
namespace System { namespace Reflection {
    // Automatically generated method stub
    MethodInfo* MethodInfo::GetBaseDefinition_af2e03a6fca2b5f5() {
        return GetBaseDefinition_b00937f21f1a7556();
    }
    
    // Automatically generated method stub
    void MethodInfo::GetIDsOfNames_fb630358bd563602(System::Guid riid, void* rgszNames, uint32_t cNames, uint32_t lcid, void* rgDispId) {
        return GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    }
    
    // Automatically generated method stub
    void MethodInfo::GetTypeInfo_715dd0bbf360bfdc(uint32_t iTInfo, uint32_t lcid, void* ppTInfo) {
        return GetTypeInfo(iTInfo, lcid, ppTInfo);
    }
    
    // Automatically generated method stub
    void MethodInfo::GetTypeInfoCount_672b699f844b0f79(uint32_t pcTInfo) {
        return GetTypeInfoCount(pcTInfo);
    }
    
    // Automatically generated method stub
    void MethodInfo::Invoke_61193eeaa05ba815(uint32_t dispIdMember, System::Guid riid, uint32_t lcid, int16_t wFlags, void* pDispParams, void* pVarResult, void* pExcepInfo, void* puArgErr) {
        return Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    }
    
    // Automatically generated method stub
    bool MethodInfo::Equals_2e806c000b792995(System::Object* obj) {
        return Equals_ed975d2f4a7d193e(obj);
    }
    
    // Automatically generated method stub
    int32_t MethodInfo::GetHashCode_2ee4600b266274f0() {
        return GetHashCode_6648aef0f235ee6c();
    }
    
    // Automatically generated method stub
    MemberTypes MethodInfo::get_MemberType_21580ff491280cb() {
        return get_MemberType_cd521d320810c98f();
    }
    
    // Automatically generated method stub
    System::Type* MethodInfo::get_ReturnType_4452cb3548281551() {
        return get_ReturnType_832339e848f448fe();
    }
    
    // Automatically generated method stub
    ICustomAttributeProvider* MethodInfo::get_ReturnTypeCustomAttributes_3d661eb3a8c541b9() {
        return get_ReturnTypeCustomAttributes_da3feb150ffa13fb();
    }
    
    // Automatically generated method stub
    cli::array<System::Object*>* MethodInfo::GetCustomAttributes_c810ec1500ff935b(bool inherit) {
        return GetCustomAttributes_b790992b66049291(inherit);
    }
    
    // Automatically generated method stub
    cli::array<System::Object*>* MethodInfo::GetCustomAttributes_74e25ee727105f87(System::Type* attributeType, bool inherit) {
        return GetCustomAttributes_90419687cfa65ef7(attributeType, inherit);
    }
    
    // Automatically generated method stub
    MethodImplAttributes MethodInfo::GetMethodImplementationFlags_808f7fd1c940f559() {
        return GetMethodImplementationFlags_34d93dba8c4849e8();
    }
    
    // Automatically generated method stub
    cli::array<ParameterInfo*>* MethodInfo::GetParameters_8eb86cd704bfbf54() {
        return GetParameters_9d17bcb549474c9();
    }
    
    // Automatically generated method stub
    System::Type* MethodInfo::GetType_74742789cd106f3b() {
        return GetType();
    }
    
    // Automatically generated method stub
    System::Object* MethodInfo::Invoke_a63db6373340494c(System::Object* obj, cli::array<System::Object*>* parameters) {
        return Invoke2(obj, parameters);
    }
    
    // Automatically generated method stub
    System::Object* MethodInfo::Invoke_80c9283e0c4ab089(System::Object* obj, BindingFlags invokeAttr, Binder* binder, cli::array<System::Object*>* parameters, System::Globalization::CultureInfo* culture) {
        return Invoke_ba5f4e14507fdb95(obj, invokeAttr, binder, parameters, culture);
    }
    
    // Automatically generated method stub
    bool MethodInfo::IsDefined_d50f51251cd2eb14(System::Type* attributeType, bool inherit) {
        return IsDefined_91943a8ac363f11f(attributeType, inherit);
    }
    
    // Automatically generated method stub
    System::String* MethodInfo::ToString_344d714047f59070() {
        return ToString_1636a0751cb9ac11();
    }
    
    // Automatically generated method stub
    MethodAttributes MethodInfo::get_Attributes_2f77059d8bc07693() {
        return get_Attributes_b3976e6a55c088be();
    }
    
    // Automatically generated method stub
    CallingConventions MethodInfo::get_CallingConvention_1d365159f80ff2b() {
        return get_CallingConvention_309cf574b58a053a();
    }
    
    // Automatically generated method stub
    System::Type* MethodInfo::get_DeclaringType_7629c4fffe34fb94() {
        return get_DeclaringType_6121cd6a84393166();
    }
    
    // Automatically generated method stub
    bool MethodInfo::get_IsAbstract_e474de6aca69fbd1() {
        return get_IsAbstract();
    }
    
    // Automatically generated method stub
    bool MethodInfo::get_IsAssembly_f6f652b6dc8ceb3e() {
        return get_IsAssembly();
    }
    
    // Automatically generated method stub
    bool MethodInfo::get_IsConstructor_41436fb10360f9a7() {
        return get_IsConstructor();
    }
    
    // Automatically generated method stub
    bool MethodInfo::get_IsFamily_2ffd1b4f99fa1412() {
        return get_IsFamily();
    }
    
    // Automatically generated method stub
    bool MethodInfo::get_IsFamilyAndAssembly_7a5b9089ab64f38b() {
        return get_IsFamilyAndAssembly();
    }
    
    // Automatically generated method stub
    bool MethodInfo::get_IsFamilyOrAssembly_b20b6def57f63d17() {
        return get_IsFamilyOrAssembly();
    }
    
    // Automatically generated method stub
    bool MethodInfo::get_IsFinal_3d88f163015f613d() {
        return get_IsFinal();
    }
    
    // Automatically generated method stub
    bool MethodInfo::get_IsHideBySig_da9279be9a634726() {
        return get_IsHideBySig();
    }
    
    // Automatically generated method stub
    bool MethodInfo::get_IsPrivate_8b2fd624f51dbfcc() {
        return get_IsPrivate();
    }
    
    // Automatically generated method stub
    bool MethodInfo::get_IsPublic_7e6e93fbf4211998() {
        return get_IsPublic();
    }
    
    // Automatically generated method stub
    bool MethodInfo::get_IsSpecialName_12d4e8400a966832() {
        return get_IsSpecialName();
    }
    
    // Automatically generated method stub
    bool MethodInfo::get_IsStatic_c628a54558fdd884() {
        return get_IsStatic();
    }
    
    // Automatically generated method stub
    bool MethodInfo::get_IsVirtual_4155281c459f2c6b() {
        return get_IsVirtual();
    }
    
    // Automatically generated method stub
    System::RuntimeMethodHandle MethodInfo::get_MethodHandle_bdcb739875527a32() {
        return get_MethodHandle_a92ba3e25e0a5ec8();
    }
    
    // Automatically generated method stub
    System::String* MethodInfo::get_Name_ff50b1dd5dfb28f9() {
        return get_Name_50fad5fa936c3ae2();
    }
    
    // Automatically generated method stub
    System::Type* MethodInfo::get_ReflectedType_93898c8dc71eef39() {
        return get_ReflectedType_bf4971c0f442b9dc();
    }
    
}}
namespace System { namespace Reflection {
    // Automatically generated method stub
    void Missing::GetObjectData_11b895a112e04409(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        return GetObjectData(info, context);
    }
    
}}
namespace System { namespace Reflection {
    // Automatically generated method stub
    void Module::GetObjectData_11b895a112e04409(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        return GetObjectData_e90fa704d41e9612(info, context);
    }
    
    // Automatically generated method stub
    void Module::GetIDsOfNames_21b152fbff43d289(System::Guid riid, void* rgszNames, uint32_t cNames, uint32_t lcid, void* rgDispId) {
        return GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    }
    
    // Automatically generated method stub
    void Module::GetTypeInfo_260aa4f867fd6fd5(uint32_t iTInfo, uint32_t lcid, void* ppTInfo) {
        return GetTypeInfo(iTInfo, lcid, ppTInfo);
    }
    
    // Automatically generated method stub
    void Module::GetTypeInfoCount_c80374543020238f(uint32_t pcTInfo) {
        return GetTypeInfoCount(pcTInfo);
    }
    
    // Automatically generated method stub
    void Module::Invoke_686f3a72f7a8e22(uint32_t dispIdMember, System::Guid riid, uint32_t lcid, int16_t wFlags, void* pDispParams, void* pVarResult, void* pExcepInfo, void* puArgErr) {
        return Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    }
    
    // Automatically generated method stub
    cli::array<System::Object*>* Module::GetCustomAttributes_c6789c4338e26d2b(bool inherit) {
        return GetCustomAttributes_60f12c5b82d89770(inherit);
    }
    
    // Automatically generated method stub
    cli::array<System::Object*>* Module::GetCustomAttributes_a458b60110eb1adc(System::Type* attributeType, bool inherit) {
        return GetCustomAttributes_2d26f4bf11dda1f5(attributeType, inherit);
    }
    
    // Automatically generated method stub
    bool Module::IsDefined_3200a5511fa7cc68(System::Type* attributeType, bool inherit) {
        return IsDefined_658453ecd0c3c72(attributeType, inherit);
    }
    
}}
namespace System { namespace Reflection {
    // Automatically generated method stub
    System::String* MonoEvent::ToString_7bb73a9f3918b46f() {
        return ToString_1636a0751cb9ac11();
    }
    
    // Automatically generated method stub
    void MonoEvent::GetObjectData_11b895a112e04409(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        return GetObjectData(info, context);
    }
    
}}
namespace System { namespace Reflection {
    // Automatically generated method stub
    System::String* MonoField::ToString_f22c3c4f8be6702d() {
        return ToString_1636a0751cb9ac11();
    }
    
    // Automatically generated method stub
    void MonoField::GetObjectData_11b895a112e04409(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        return GetObjectData(info, context);
    }
    
}}
namespace System { namespace Reflection {
    // Automatically generated method stub
    System::String* MonoMethod::ToString_344d714047f59070() {
        return ToString_1636a0751cb9ac11();
    }
    
    // Automatically generated method stub
    void MonoMethod::GetObjectData_11b895a112e04409(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        return GetObjectData(info, context);
    }
    
    // Automatically generated method stub
    System::Type* MonoMethod::get_ReturnType_4452cb3548281551() {
        return get_ReturnType_832339e848f448fe();
    }
    
    // Automatically generated method stub
    CallingConventions MonoMethod::get_CallingConvention_1d365159f80ff2b() {
        return get_CallingConvention_309cf574b58a053a();
    }
    
}}
namespace System { namespace Reflection {
    // Automatically generated method stub
    System::String* MonoCMethod::ToString_a95e215a60192892() {
        return ToString_1636a0751cb9ac11();
    }
    
    // Automatically generated method stub
    void MonoCMethod::GetObjectData_11b895a112e04409(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        return GetObjectData(info, context);
    }
    
    // Automatically generated method stub
    CallingConventions MonoCMethod::get_CallingConvention_a50132e872765544() {
        return get_CallingConvention_309cf574b58a053a();
    }
    
}}
namespace System { namespace Reflection {
    // Automatically generated method stub
    System::Object* MonoProperty::GetValue_2c0ea8f469169d57(System::Object* obj, cli::array<System::Object*>* index) {
        return GetValue_5fb57c5b502dc8d8(obj, index);
    }
    
    // Automatically generated method stub
    System::String* MonoProperty::ToString_23ebaa63b8f17cf6() {
        return ToString_1636a0751cb9ac11();
    }
    
    // Automatically generated method stub
    void MonoProperty::GetObjectData_11b895a112e04409(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        return GetObjectData(info, context);
    }
    
}}
namespace System { namespace Reflection {
    // Automatically generated method stub
    cli::array<System::Object*>* ParameterInfo::GetCustomAttributes_c6789c4338e26d2b(bool inherit) {
        return GetCustomAttributes_fa76a8481b122aa(inherit);
    }
    
    // Automatically generated method stub
    cli::array<System::Object*>* ParameterInfo::GetCustomAttributes_a458b60110eb1adc(System::Type* attributeType, bool inherit) {
        return GetCustomAttributes_1c88eb3824a80dfa(attributeType, inherit);
    }
    
    // Automatically generated method stub
    bool ParameterInfo::IsDefined_3200a5511fa7cc68(System::Type* attributeType, bool inherit) {
        return IsDefined_f77a22c7742d1e97(attributeType, inherit);
    }
    
    // Automatically generated method stub
    void ParameterInfo::GetIDsOfNames_4283527bc2e9c90c(System::Guid riid, void* rgszNames, uint32_t cNames, uint32_t lcid, void* rgDispId) {
        return GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    }
    
    // Automatically generated method stub
    void ParameterInfo::GetTypeInfo_810b7e55fcaab9e9(uint32_t iTInfo, uint32_t lcid, void* ppTInfo) {
        return GetTypeInfo(iTInfo, lcid, ppTInfo);
    }
    
    // Automatically generated method stub
    void ParameterInfo::GetTypeInfoCount_cf26089fea501d0(uint32_t pcTInfo) {
        return GetTypeInfoCount(pcTInfo);
    }
    
    // Automatically generated method stub
    void ParameterInfo::Invoke_4b0fe4a4b992b2d2(uint32_t dispIdMember, System::Guid riid, uint32_t lcid, int16_t wFlags, void* pDispParams, void* pVarResult, void* pExcepInfo, void* puArgErr) {
        return Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    }
    
}}
namespace System { namespace Reflection {
    // Automatically generated method stub
    void Pointer::GetObjectData_11b895a112e04409(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        return GetObjectData(info, context);
    }
    
}}
namespace System { namespace Reflection {
    // Automatically generated method stub
    cli::array<MethodInfo*>* PropertyInfo::GetAccessors_da9e2ca6e4dd3482() {
        return GetAccessors();
    }
    
    // Automatically generated method stub
    cli::array<MethodInfo*>* PropertyInfo::GetAccessors_59a0bfdaedb007c(bool nonPublic) {
        return GetAccessors_9a7eb6d477c42a6d(nonPublic);
    }
    
    // Automatically generated method stub
    MethodInfo* PropertyInfo::GetGetMethod_22dbc42ee812754c() {
        return GetGetMethod();
    }
    
    // Automatically generated method stub
    MethodInfo* PropertyInfo::GetGetMethod_6968d1fbf893caf2(bool nonPublic) {
        return GetGetMethod_598f563fd3755017(nonPublic);
    }
    
    // Automatically generated method stub
    cli::array<ParameterInfo*>* PropertyInfo::GetIndexParameters_14483f59bc20265() {
        return GetIndexParameters_66437e9b713ac629();
    }
    
    // Automatically generated method stub
    MethodInfo* PropertyInfo::GetSetMethod_ab92dfa716a7aa22() {
        return GetSetMethod();
    }
    
    // Automatically generated method stub
    MethodInfo* PropertyInfo::GetSetMethod_bc66033ddce9efa0(bool nonPublic) {
        return GetSetMethod_8896cb22c4f8d900(nonPublic);
    }
    
    // Automatically generated method stub
    System::Object* PropertyInfo::GetValue_2c0ea8f469169d57(System::Object* obj, cli::array<System::Object*>* index) {
        return GetValue_5fb57c5b502dc8d8(obj, index);
    }
    
    // Automatically generated method stub
    System::Object* PropertyInfo::GetValue_5c4287abeb0e7d6e(System::Object* obj, BindingFlags invokeAttr, Binder* binder, cli::array<System::Object*>* index, System::Globalization::CultureInfo* culture) {
        return GetValue_e428a2cef74e332d(obj, invokeAttr, binder, index, culture);
    }
    
    // Automatically generated method stub
    void PropertyInfo::SetValue_42dc5b3a16b3868c(System::Object* obj, System::Object* value, cli::array<System::Object*>* index) {
        return SetValue_1695ad6de909516e(obj, value, index);
    }
    
    // Automatically generated method stub
    void PropertyInfo::SetValue_6668f5b0d61ae93b(System::Object* obj, System::Object* value, BindingFlags invokeAttr, Binder* binder, cli::array<System::Object*>* index, System::Globalization::CultureInfo* culture) {
        return SetValue_54b056b52d2524f7(obj, value, invokeAttr, binder, index, culture);
    }
    
    // Automatically generated method stub
    bool PropertyInfo::Equals_35205ed1d0d24667(System::Object* obj) {
        return Equals_ed975d2f4a7d193e(obj);
    }
    
    // Automatically generated method stub
    int32_t PropertyInfo::GetHashCode_f63a3941a1dc75bc() {
        return GetHashCode_6648aef0f235ee6c();
    }
    
    // Automatically generated method stub
    void PropertyInfo::GetIDsOfNames_543d0db39ba3c944(System::Guid riid, void* rgszNames, uint32_t cNames, uint32_t lcid, void* rgDispId) {
        return GetIDsOfNames2(riid, rgszNames, cNames, lcid, rgDispId);
    }
    
    // Automatically generated method stub
    void PropertyInfo::GetTypeInfo_a3cbba6cae9ec8b4(uint32_t iTInfo, uint32_t lcid, void* ppTInfo) {
        return GetTypeInfo2(iTInfo, lcid, ppTInfo);
    }
    
    // Automatically generated method stub
    void PropertyInfo::GetTypeInfoCount_87d5dfef26ae0dd2(uint32_t pcTInfo) {
        return GetTypeInfoCount2(pcTInfo);
    }
    
    // Automatically generated method stub
    void PropertyInfo::Invoke_2658e83a6cb776b7(uint32_t dispIdMember, System::Guid riid, uint32_t lcid, int16_t wFlags, void* pDispParams, void* pVarResult, void* pExcepInfo, void* puArgErr) {
        return Invoke2(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    }
    
    // Automatically generated method stub
    PropertyAttributes PropertyInfo::get_Attributes_1bea9714c54419aa() {
        return get_Attributes_44d275d722218b81();
    }
    
    // Automatically generated method stub
    bool PropertyInfo::get_CanRead_ef8e9b1025a3b21a() {
        return get_CanRead_f4dae9b567f6ce33();
    }
    
    // Automatically generated method stub
    bool PropertyInfo::get_CanWrite_375056fcc54af0b8() {
        return get_CanWrite_a9c71933951c9826();
    }
    
    // Automatically generated method stub
    bool PropertyInfo::get_IsSpecialName_136ed05fe7cb7256() {
        return get_IsSpecialName();
    }
    
    // Automatically generated method stub
    MemberTypes PropertyInfo::get_MemberType_f062e4acbf7ce28d() {
        return get_MemberType_cd521d320810c98f();
    }
    
    // Automatically generated method stub
    System::Type* PropertyInfo::get_PropertyType_31b54c84f8684bd3() {
        return get_PropertyType_68b4b04678fe4f8a();
    }
    
    // Automatically generated method stub
    cli::array<System::Object*>* PropertyInfo::GetCustomAttributes_eefb51d8f72617fa(bool inherit) {
        return GetCustomAttributes_b790992b66049291(inherit);
    }
    
    // Automatically generated method stub
    cli::array<System::Object*>* PropertyInfo::GetCustomAttributes_855d2e1478057365(System::Type* attributeType, bool inherit) {
        return GetCustomAttributes_90419687cfa65ef7(attributeType, inherit);
    }
    
    // Automatically generated method stub
    System::Type* PropertyInfo::GetType_adcc73cb09269a4b() {
        return GetType();
    }
    
    // Automatically generated method stub
    bool PropertyInfo::IsDefined_e028345db151e511(System::Type* attributeType, bool inherit) {
        return IsDefined_91943a8ac363f11f(attributeType, inherit);
    }
    
    // Automatically generated method stub
    System::String* PropertyInfo::ToString_23ebaa63b8f17cf6() {
        return ToString_1636a0751cb9ac11();
    }
    
    // Automatically generated method stub
    System::Type* PropertyInfo::get_DeclaringType_c6040d00ca0e5f1a() {
        return get_DeclaringType_6121cd6a84393166();
    }
    
    // Automatically generated method stub
    System::String* PropertyInfo::get_Name_2ec41f95ff7a8b17() {
        return get_Name_50fad5fa936c3ae2();
    }
    
    // Automatically generated method stub
    System::Type* PropertyInfo::get_ReflectedType_c368bf8f01d9ffdc() {
        return get_ReflectedType_bf4971c0f442b9dc();
    }
    
}}
namespace System { namespace Reflection {
    // Automatically generated method stub
    void StrongNameKeyPair::GetObjectData_11b895a112e04409(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        return GetObjectData(info, context);
    }
    
    // Automatically generated method stub
    void StrongNameKeyPair::OnDeserialization_e9ecfecba8df9754(System::Object* sender) {
        return OnDeserialization(sender);
    }
    
}}
namespace System { namespace Reflection { namespace Emit {
    // Automatically generated method stub
    cli::array<System::Type*>* AssemblyBuilder::GetExportedTypes_ee0adeac46d6ab34() {
        return GetExportedTypes_4dc21035aef13039();
    }
    
    // Automatically generated method stub
    System::IO::FileStream* AssemblyBuilder::GetFile_6615c487c2ac205(System::String* name) {
        return GetFile_321baf5b87b86022(name);
    }
    
    // Automatically generated method stub
    cli::array<System::IO::FileStream*>* AssemblyBuilder::GetFiles_83c5197d3be9ba99(bool getResourceModules) {
        return GetFiles_4b160752c34b70d5(getResourceModules);
    }
    
    // Automatically generated method stub
    System::Reflection::ManifestResourceInfo* AssemblyBuilder::GetManifestResourceInfo_bcc15dc0035eec0a(System::String* resourceName) {
        return GetManifestResourceInfo_2cc36efdd5a68bdc(resourceName);
    }
    
    // Automatically generated method stub
    cli::array<System::String*>* AssemblyBuilder::GetManifestResourceNames_a76da541e39a6687() {
        return GetManifestResourceNames_d63b24d819c7a44d();
    }
    
    // Automatically generated method stub
    System::IO::Stream* AssemblyBuilder::GetManifestResourceStream_c4c4dd7ea9b411f6(System::String* name) {
        return GetManifestResourceStream_b395b331908084e(name);
    }
    
    // Automatically generated method stub
    System::IO::Stream* AssemblyBuilder::GetManifestResourceStream_20b4219e40c67fdc(System::Type* type, System::String* name) {
        return GetManifestResourceStream_6ad572412eedcffd(type, name);
    }
    
    // Automatically generated method stub
    void AssemblyBuilder::GetIDsOfNames_716ecff340e1bcb1(System::Guid riid, void* rgszNames, uint32_t cNames, uint32_t lcid, void* rgDispId) {
        return GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    }
    
    // Automatically generated method stub
    void AssemblyBuilder::GetTypeInfo_8f3e600b1a4df338(uint32_t iTInfo, uint32_t lcid, void* ppTInfo) {
        return GetTypeInfo(iTInfo, lcid, ppTInfo);
    }
    
    // Automatically generated method stub
    void AssemblyBuilder::GetTypeInfoCount_b1477651be42f933(uint32_t pcTInfo) {
        return GetTypeInfoCount(pcTInfo);
    }
    
    // Automatically generated method stub
    void AssemblyBuilder::Invoke_6b5294c027a9dacb(uint32_t dispIdMember, System::Guid riid, uint32_t lcid, int16_t wFlags, void* pDispParams, void* pVarResult, void* pExcepInfo, void* puArgErr) {
        return Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    }
    
    // Automatically generated method stub
    System::Type* AssemblyBuilder::GetType_4f7329f347090d49(System::String* name, bool throwOnError, bool ignoreCase) {
        return GetType_30e9b2dcc4956479(name, throwOnError, ignoreCase);
    }
    
    // Automatically generated method stub
    System::Reflection::Module* AssemblyBuilder::GetModule_a7906997a13617a7(System::String* name) {
        return GetModule_d3e09c815c6ebd46(name);
    }
    
    // Automatically generated method stub
    cli::array<System::Reflection::Module*>* AssemblyBuilder::GetModules_70286f2f0a1cfacc(bool getResourceModules) {
        return GetModules_1ce70abfc6e0d050(getResourceModules);
    }
    
    // Automatically generated method stub
    System::Reflection::AssemblyName* AssemblyBuilder::GetName_7ef5b4b80c448759(bool copiedName) {
        return GetName_7bcd94721bb29265(copiedName);
    }
    
    // Automatically generated method stub
    cli::array<System::Reflection::AssemblyName*>* AssemblyBuilder::GetReferencedAssemblies_1e24baa3c5838f22() {
        return GetReferencedAssemblies_c967ce8a0efd4c58();
    }
    
    // Automatically generated method stub
    cli::array<System::Reflection::Module*>* AssemblyBuilder::GetLoadedModules_f8ba3198d02efd9f(bool getResourceModules) {
        return GetLoadedModules_db6b585bebc1ac2e(getResourceModules);
    }
    
    // Automatically generated method stub
    System::Reflection::Assembly* AssemblyBuilder::GetSatelliteAssembly_ba2feb006a3fcaa4(System::Globalization::CultureInfo* culture) {
        return GetSatelliteAssembly_995bfc41ec1f61b8(culture);
    }
    
    // Automatically generated method stub
    System::Reflection::Assembly* AssemblyBuilder::GetSatelliteAssembly_f069f89f4969cda7(System::Globalization::CultureInfo* culture, System::Version* version) {
        return GetSatelliteAssembly_22d0b12d929a333c(culture, version);
    }
    
    // Automatically generated method stub
    bool AssemblyBuilder::Equals_56ec287b8d40063b(System::Object* obj) {
        return Equals_ed975d2f4a7d193e(obj);
    }
    
    // Automatically generated method stub
    int32_t AssemblyBuilder::GetHashCode_20a08aead0d6820a() {
        return GetHashCode_6648aef0f235ee6c();
    }
    
    // Automatically generated method stub
    bool AssemblyBuilder::IsDefined_3200a5511fa7cc68(System::Type* attributeType, bool inherit) {
        return IsDefined_42f87feac494b032(attributeType, inherit);
    }
    
    // Automatically generated method stub
    cli::array<System::Object*>* AssemblyBuilder::GetCustomAttributes_c6789c4338e26d2b(bool inherit) {
        return GetCustomAttributes_887544480e7ebe63(inherit);
    }
    
    // Automatically generated method stub
    cli::array<System::Object*>* AssemblyBuilder::GetCustomAttributes_a458b60110eb1adc(System::Type* attributeType, bool inherit) {
        return GetCustomAttributes_30a143c7dfd48919(attributeType, inherit);
    }
    
    // Automatically generated method stub
    System::String* AssemblyBuilder::get_CodeBase_dc45d01428f64731() {
        return get_CodeBase_5e12949b795c9d90();
    }
    
    // Automatically generated method stub
    System::Reflection::MethodInfo* AssemblyBuilder::get_EntryPoint_2f6c2f38d51e8a4a() {
        return get_EntryPoint_63c1ef73cc6df57c();
    }
    
    // Automatically generated method stub
    System::String* AssemblyBuilder::get_Location_b64a656d361bdd61() {
        return get_Location_3a7779d7eb72fa50();
    }
    
    // Automatically generated method stub
    bool AssemblyBuilder::get_GlobalAssemblyCache_dace09e2d2af9909() {
        return get_GlobalAssemblyCache_db80d4f5ee2824e7();
    }
    
    // Automatically generated method stub
    System::String* AssemblyBuilder::get_FullName_f0e20ee2bbdaa1a9() {
        return get_FullName_abd52da7f47cce07();
    }
    
}}}
namespace System { namespace Reflection { namespace Emit {
    // Automatically generated method stub
    System::String* ConstructorBuilder::ToString_a95e215a60192892() {
        return ToString_1636a0751cb9ac11();
    }
    
    // Automatically generated method stub
    void ConstructorBuilder::GetIDsOfNames_a94971402772136c(System::Guid riid, void* rgszNames, uint32_t cNames, uint32_t lcid, void* rgDispId) {
        return GetIDsOfNames2(riid, rgszNames, cNames, lcid, rgDispId);
    }
    
    // Automatically generated method stub
    void ConstructorBuilder::GetTypeInfo_daa5d56ccfb3f499(uint32_t iTInfo, uint32_t lcid, void* ppTInfo) {
        return GetTypeInfo2(iTInfo, lcid, ppTInfo);
    }
    
    // Automatically generated method stub
    void ConstructorBuilder::GetTypeInfoCount_2bceeff5d59a252e(uint32_t pcTInfo) {
        return GetTypeInfoCount2(pcTInfo);
    }
    
    // Automatically generated method stub
    void ConstructorBuilder::Invoke_9c9bca8549c0c755(uint32_t dispIdMember, System::Guid riid, uint32_t lcid, int16_t wFlags, void* pDispParams, void* pVarResult, void* pExcepInfo, void* puArgErr) {
        return Invoke4(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    }
    
    // Automatically generated method stub
    System::Reflection::CallingConventions ConstructorBuilder::get_CallingConvention_a50132e872765544() {
        return get_CallingConvention_309cf574b58a053a();
    }
    
}}}
namespace System { namespace Reflection { namespace Emit {
    // Automatically generated method stub
    void CustomAttributeBuilder::GetIDsOfNames_c21c44540ffdbb5f(System::Guid riid, void* rgszNames, uint32_t cNames, uint32_t lcid, void* rgDispId) {
        return GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    }
    
    // Automatically generated method stub
    void CustomAttributeBuilder::GetTypeInfo_2c3ebc106b1684a4(uint32_t iTInfo, uint32_t lcid, void* ppTInfo) {
        return GetTypeInfo(iTInfo, lcid, ppTInfo);
    }
    
    // Automatically generated method stub
    void CustomAttributeBuilder::GetTypeInfoCount_4a41fb8f79c152d6(uint32_t pcTInfo) {
        return GetTypeInfoCount(pcTInfo);
    }
    
    // Automatically generated method stub
    void CustomAttributeBuilder::Invoke_25a09bf1f54f831c(uint32_t dispIdMember, System::Guid riid, uint32_t lcid, int16_t wFlags, void* pDispParams, void* pVarResult, void* pExcepInfo, void* puArgErr) {
        return Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    }
    
}}}
namespace System { namespace Reflection { namespace Emit {
    // Automatically generated method stub
    int32_t DynamicMethodTokenGenerator::GetToken_25c90de716173dc6(System::String* str) {
        return GetToken(str);
    }
    
    // Automatically generated method stub
    int32_t DynamicMethodTokenGenerator::GetToken_9da014b90fcfd506(System::Reflection::MethodInfo* method, cli::array<System::Type*>* opt_param_types) {
        return GetToken2(method, opt_param_types);
    }
    
    // Automatically generated method stub
    int32_t DynamicMethodTokenGenerator::GetToken_10bcc90da5b44782(System::Reflection::MemberInfo* member, bool create_open_instance) {
        return GetToken3(member, create_open_instance);
    }
    
    // Automatically generated method stub
    int32_t DynamicMethodTokenGenerator::GetToken_dc01c561a484101(SignatureHelper* helper) {
        return GetToken4(helper);
    }
    
}}}
namespace System { namespace Reflection { namespace Emit {
    // Automatically generated method stub
    cli::array<System::Reflection::EventInfo*>* EnumBuilder::GetEvents_1787f024dc60b66d() {
        return GetEvents_e6858c959b77de38();
    }
    
    // Automatically generated method stub
    System::Reflection::InterfaceMapping EnumBuilder::GetInterfaceMap_1dcbd2012c18f488(System::Type* interfaceType) {
        return GetInterfaceMap_26193b1c1167fea4(interfaceType);
    }
    
    // Automatically generated method stub
    cli::array<System::Reflection::MemberInfo*>* EnumBuilder::GetMember_aba72a46394724d6(System::String* name, System::Reflection::MemberTypes type, System::Reflection::BindingFlags bindingAttr) {
        return GetMember_9c934e7384b805e1(name, type, bindingAttr);
    }
    
    // Automatically generated method stub
    void EnumBuilder::GetIDsOfNames_c589a61053617268(System::Guid riid, void* rgszNames, uint32_t cNames, uint32_t lcid, void* rgDispId) {
        return GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    }
    
    // Automatically generated method stub
    void EnumBuilder::GetTypeInfo_4569c5bef9234cda(uint32_t iTInfo, uint32_t lcid, void* ppTInfo) {
        return GetTypeInfo(iTInfo, lcid, ppTInfo);
    }
    
    // Automatically generated method stub
    void EnumBuilder::GetTypeInfoCount_6ad7237d71a849b0(uint32_t pcTInfo) {
        return GetTypeInfoCount(pcTInfo);
    }
    
    // Automatically generated method stub
    void EnumBuilder::Invoke_bb691d3276b024bf(uint32_t dispIdMember, System::Guid riid, uint32_t lcid, int16_t wFlags, void* pDispParams, void* pVarResult, void* pExcepInfo, void* puArgErr) {
        return Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    }
    
    // Automatically generated method stub
    System::Type* EnumBuilder::get_DeclaringType_57e85ec7caa4a7e9() {
        return get_DeclaringType_6121cd6a84393166();
    }
    
    // Automatically generated method stub
    System::Reflection::Module* EnumBuilder::get_Module_e878d08348938612() {
        return get_Module_ea7d65dc88202263();
    }
    
    // Automatically generated method stub
    System::Type* EnumBuilder::get_ReflectedType_338a78c0f78949() {
        return get_ReflectedType_bf4971c0f442b9dc();
    }
    
    // Automatically generated method stub
    System::RuntimeTypeHandle EnumBuilder::get_TypeHandle_a660506a2c0cc3d5() {
        return get_TypeHandle_a14995fa9102936b();
    }
    
}}}
namespace System { namespace Reflection { namespace Emit {
    // Automatically generated method stub
    void EventBuilder::GetIDsOfNames_3050f219d9ee6281(System::Guid riid, void* rgszNames, uint32_t cNames, uint32_t lcid, void* rgDispId) {
        return GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    }
    
    // Automatically generated method stub
    void EventBuilder::GetTypeInfo_c88e6f1eebfb78c2(uint32_t iTInfo, uint32_t lcid, void* ppTInfo) {
        return GetTypeInfo(iTInfo, lcid, ppTInfo);
    }
    
    // Automatically generated method stub
    void EventBuilder::GetTypeInfoCount_f810c10738bdafb7(uint32_t pcTInfo) {
        return GetTypeInfoCount(pcTInfo);
    }
    
    // Automatically generated method stub
    void EventBuilder::Invoke_8b71d77ae75751d1(uint32_t dispIdMember, System::Guid riid, uint32_t lcid, int16_t wFlags, void* pDispParams, void* pVarResult, void* pExcepInfo, void* puArgErr) {
        return Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    }
    
}}}
namespace System { namespace Reflection { namespace Emit {
    // Automatically generated method stub
    void FieldBuilder::GetIDsOfNames_4cc89c7b2b2c1221(System::Guid riid, void* rgszNames, uint32_t cNames, uint32_t lcid, void* rgDispId) {
        return GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    }
    
    // Automatically generated method stub
    void FieldBuilder::GetTypeInfo_9a7463b590b674bf(uint32_t iTInfo, uint32_t lcid, void* ppTInfo) {
        return GetTypeInfo(iTInfo, lcid, ppTInfo);
    }
    
    // Automatically generated method stub
    void FieldBuilder::GetTypeInfoCount_a35a410b1df51e31(uint32_t pcTInfo) {
        return GetTypeInfoCount(pcTInfo);
    }
    
    // Automatically generated method stub
    void FieldBuilder::Invoke_b525b37e6ef7a0c4(uint32_t dispIdMember, System::Guid riid, uint32_t lcid, int16_t wFlags, void* pDispParams, void* pVarResult, void* pExcepInfo, void* puArgErr) {
        return Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    }
    
}}}
namespace System { namespace Reflection { namespace Emit {
    // Automatically generated method stub
    void ILGenerator::GetIDsOfNames_2ab91765d99b9239(System::Guid riid, void* rgszNames, uint32_t cNames, uint32_t lcid, void* rgDispId) {
        return GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    }
    
    // Automatically generated method stub
    void ILGenerator::GetTypeInfo_6d549fcfb1b28dbc(uint32_t iTInfo, uint32_t lcid, void* ppTInfo) {
        return GetTypeInfo(iTInfo, lcid, ppTInfo);
    }
    
    // Automatically generated method stub
    void ILGenerator::GetTypeInfoCount_2a10ec9331579a6b(uint32_t pcTInfo) {
        return GetTypeInfoCount(pcTInfo);
    }
    
    // Automatically generated method stub
    void ILGenerator::Invoke_94872a016b6b5770(uint32_t dispIdMember, System::Guid riid, uint32_t lcid, int16_t wFlags, void* pDispParams, void* pVarResult, void* pExcepInfo, void* puArgErr) {
        return Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    }
    
}}}
namespace System { namespace Reflection { namespace Emit {
    // Automatically generated method stub
    void LocalBuilder::GetIDsOfNames_d2e6179bbbf6f7d1(System::Guid riid, void* rgszNames, uint32_t cNames, uint32_t lcid, void* rgDispId) {
        return GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    }
    
    // Automatically generated method stub
    void LocalBuilder::GetTypeInfo_735b3565b064b15(uint32_t iTInfo, uint32_t lcid, void* ppTInfo) {
        return GetTypeInfo(iTInfo, lcid, ppTInfo);
    }
    
    // Automatically generated method stub
    void LocalBuilder::GetTypeInfoCount_9a28c2b9adf9b672(uint32_t pcTInfo) {
        return GetTypeInfoCount(pcTInfo);
    }
    
    // Automatically generated method stub
    void LocalBuilder::Invoke_a07e8a441e6d5bd0(uint32_t dispIdMember, System::Guid riid, uint32_t lcid, int16_t wFlags, void* pDispParams, void* pVarResult, void* pExcepInfo, void* puArgErr) {
        return Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    }
    
}}}
namespace System { namespace Reflection { namespace Emit {
    // Automatically generated method stub
    System::String* MethodBuilder::ToString_344d714047f59070() {
        return ToString_1636a0751cb9ac11();
    }
    
    // Automatically generated method stub
    bool MethodBuilder::Equals_2e806c000b792995(System::Object* obj) {
        return Equals_ed975d2f4a7d193e(obj);
    }
    
    // Automatically generated method stub
    int32_t MethodBuilder::GetHashCode_2ee4600b266274f0() {
        return GetHashCode_6648aef0f235ee6c();
    }
    
    // Automatically generated method stub
    void MethodBuilder::GetIDsOfNames_c81e466ceb37a395(System::Guid riid, void* rgszNames, uint32_t cNames, uint32_t lcid, void* rgDispId) {
        return GetIDsOfNames2(riid, rgszNames, cNames, lcid, rgDispId);
    }
    
    // Automatically generated method stub
    void MethodBuilder::GetTypeInfo_29cbebb5e5c35fed(uint32_t iTInfo, uint32_t lcid, void* ppTInfo) {
        return GetTypeInfo2(iTInfo, lcid, ppTInfo);
    }
    
    // Automatically generated method stub
    void MethodBuilder::GetTypeInfoCount_f9f8d039bab656aa(uint32_t pcTInfo) {
        return GetTypeInfoCount2(pcTInfo);
    }
    
    // Automatically generated method stub
    void MethodBuilder::Invoke_2c80ebce31979f5d(uint32_t dispIdMember, System::Guid riid, uint32_t lcid, int16_t wFlags, void* pDispParams, void* pVarResult, void* pExcepInfo, void* puArgErr) {
        return Invoke3(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    }
    
    // Automatically generated method stub
    System::Type* MethodBuilder::get_ReturnType_4452cb3548281551() {
        return get_ReturnType_832339e848f448fe();
    }
    
    // Automatically generated method stub
    System::Reflection::CallingConventions MethodBuilder::get_CallingConvention_1d365159f80ff2b() {
        return get_CallingConvention_309cf574b58a053a();
    }
    
}}}
namespace System { namespace Reflection { namespace Emit {
    // Automatically generated method stub
    void MethodRental::GetIDsOfNames_f32788164aaaacff(System::Guid riid, void* rgszNames, uint32_t cNames, uint32_t lcid, void* rgDispId) {
        return GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    }
    
    // Automatically generated method stub
    void MethodRental::GetTypeInfo_d336c5839cab41d4(uint32_t iTInfo, uint32_t lcid, void* ppTInfo) {
        return GetTypeInfo(iTInfo, lcid, ppTInfo);
    }
    
    // Automatically generated method stub
    void MethodRental::GetTypeInfoCount_5f816dc6d67e1185(uint32_t pcTInfo) {
        return GetTypeInfoCount(pcTInfo);
    }
    
    // Automatically generated method stub
    void MethodRental::Invoke_16bf00b9457164c(uint32_t dispIdMember, System::Guid riid, uint32_t lcid, int16_t wFlags, void* pDispParams, void* pVarResult, void* pExcepInfo, void* puArgErr) {
        return Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    }
    
}}}
namespace System { namespace Reflection { namespace Emit {
    // Automatically generated method stub
    void ModuleBuilder::GetIDsOfNames_b5eeb00633ee180d(System::Guid riid, void* rgszNames, uint32_t cNames, uint32_t lcid, void* rgDispId) {
        return GetIDsOfNames2(riid, rgszNames, cNames, lcid, rgDispId);
    }
    
    // Automatically generated method stub
    void ModuleBuilder::GetTypeInfo_6b82fa62633497dc(uint32_t iTInfo, uint32_t lcid, void* ppTInfo) {
        return GetTypeInfo2(iTInfo, lcid, ppTInfo);
    }
    
    // Automatically generated method stub
    void ModuleBuilder::GetTypeInfoCount_919dffef8bc20d32(uint32_t pcTInfo) {
        return GetTypeInfoCount2(pcTInfo);
    }
    
    // Automatically generated method stub
    void ModuleBuilder::Invoke_4a627a0727f5913(uint32_t dispIdMember, System::Guid riid, uint32_t lcid, int16_t wFlags, void* pDispParams, void* pVarResult, void* pExcepInfo, void* puArgErr) {
        return Invoke2(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    }
    
    // Automatically generated method stub
    bool ModuleBuilder::IsDefined_3200a5511fa7cc68(System::Type* attributeType, bool inherit) {
        return IsDefined_658453ecd0c3c72(attributeType, inherit);
    }
    
    // Automatically generated method stub
    cli::array<System::Object*>* ModuleBuilder::GetCustomAttributes_c6789c4338e26d2b(bool inherit) {
        return GetCustomAttributes_60f12c5b82d89770(inherit);
    }
    
    // Automatically generated method stub
    cli::array<System::Object*>* ModuleBuilder::GetCustomAttributes_a458b60110eb1adc(System::Type* attributeType, bool inherit) {
        return GetCustomAttributes_2d26f4bf11dda1f5(attributeType, inherit);
    }
    
}}}
namespace System { namespace Reflection { namespace Emit {
    // Automatically generated method stub
    int32_t ModuleBuilderTokenGenerator::GetToken_25c90de716173dc6(System::String* str) {
        return GetToken(str);
    }
    
    // Automatically generated method stub
    int32_t ModuleBuilderTokenGenerator::GetToken_10bcc90da5b44782(System::Reflection::MemberInfo* member, bool create_open_instance) {
        return GetToken2(member, create_open_instance);
    }
    
    // Automatically generated method stub
    int32_t ModuleBuilderTokenGenerator::GetToken_9da014b90fcfd506(System::Reflection::MethodInfo* method, cli::array<System::Type*>* opt_param_types) {
        return GetToken3(method, opt_param_types);
    }
    
    // Automatically generated method stub
    int32_t ModuleBuilderTokenGenerator::GetToken_dc01c561a484101(SignatureHelper* helper) {
        return GetToken4(helper);
    }
    
}}}
namespace System { namespace Reflection { namespace Emit {
    // Automatically generated method stub
    void ParameterBuilder::GetIDsOfNames_8d906f6d37441d7c(System::Guid riid, void* rgszNames, uint32_t cNames, uint32_t lcid, void* rgDispId) {
        return GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    }
    
    // Automatically generated method stub
    void ParameterBuilder::GetTypeInfo_dc79acc00c7841a(uint32_t iTInfo, uint32_t lcid, void* ppTInfo) {
        return GetTypeInfo(iTInfo, lcid, ppTInfo);
    }
    
    // Automatically generated method stub
    void ParameterBuilder::GetTypeInfoCount_ca9ef6243f77d10e(uint32_t pcTInfo) {
        return GetTypeInfoCount(pcTInfo);
    }
    
    // Automatically generated method stub
    void ParameterBuilder::Invoke_ee3a08d633f41d32(uint32_t dispIdMember, System::Guid riid, uint32_t lcid, int16_t wFlags, void* pDispParams, void* pVarResult, void* pExcepInfo, void* puArgErr) {
        return Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    }
    
}}}
namespace System { namespace Reflection { namespace Emit {
    // Automatically generated method stub
    System::Object* PropertyBuilder::GetValue_2c0ea8f469169d57(System::Object* obj, cli::array<System::Object*>* index) {
        return GetValue_5fb57c5b502dc8d8(obj, index);
    }
    
    // Automatically generated method stub
    void PropertyBuilder::SetValue_42dc5b3a16b3868c(System::Object* obj, System::Object* value, cli::array<System::Object*>* index) {
        return SetValue_1695ad6de909516e(obj, value, index);
    }
    
    // Automatically generated method stub
    void PropertyBuilder::GetIDsOfNames_faa2940ec0c854b6(System::Guid riid, void* rgszNames, uint32_t cNames, uint32_t lcid, void* rgDispId) {
        return GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    }
    
    // Automatically generated method stub
    void PropertyBuilder::GetTypeInfo_7f36c44ea722d64(uint32_t iTInfo, uint32_t lcid, void* ppTInfo) {
        return GetTypeInfo(iTInfo, lcid, ppTInfo);
    }
    
    // Automatically generated method stub
    void PropertyBuilder::GetTypeInfoCount_64e3fad5407a69b0(uint32_t pcTInfo) {
        return GetTypeInfoCount(pcTInfo);
    }
    
    // Automatically generated method stub
    void PropertyBuilder::Invoke_eb1f540198acef11(uint32_t dispIdMember, System::Guid riid, uint32_t lcid, int16_t wFlags, void* pDispParams, void* pVarResult, void* pExcepInfo, void* puArgErr) {
        return Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    }
    
}}}
namespace System { namespace Reflection { namespace Emit {
    // Automatically generated method stub
    void SignatureHelper::GetIDsOfNames_63d5038940a76397(System::Guid riid, void* rgszNames, uint32_t cNames, uint32_t lcid, void* rgDispId) {
        return GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    }
    
    // Automatically generated method stub
    void SignatureHelper::GetTypeInfo_65f52795e9f5dec4(uint32_t iTInfo, uint32_t lcid, void* ppTInfo) {
        return GetTypeInfo(iTInfo, lcid, ppTInfo);
    }
    
    // Automatically generated method stub
    void SignatureHelper::GetTypeInfoCount_3492155c34a71e8a(uint32_t pcTInfo) {
        return GetTypeInfoCount(pcTInfo);
    }
    
    // Automatically generated method stub
    void SignatureHelper::Invoke_2f7d24d0932ca178(uint32_t dispIdMember, System::Guid riid, uint32_t lcid, int16_t wFlags, void* pDispParams, void* pVarResult, void* pExcepInfo, void* puArgErr) {
        return Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    }
    
}}}
namespace System { namespace Reflection { namespace Emit {
    // Automatically generated method stub
    bool TypeBuilder::IsSubclassOf_875608a6f6bc1b50(System::Type* c) {
        return IsSubclassOf_5d7dbe0215a30fda(c);
    }
    
    // Automatically generated method stub
    cli::array<System::Reflection::EventInfo*>* TypeBuilder::GetEvents_1787f024dc60b66d() {
        return GetEvents_e6858c959b77de38();
    }
    
    // Automatically generated method stub
    cli::array<System::Reflection::MemberInfo*>* TypeBuilder::GetMember_aba72a46394724d6(System::String* name, System::Reflection::MemberTypes type, System::Reflection::BindingFlags bindingAttr) {
        return GetMember_9c934e7384b805e1(name, type, bindingAttr);
    }
    
    // Automatically generated method stub
    System::Reflection::InterfaceMapping TypeBuilder::GetInterfaceMap_1dcbd2012c18f488(System::Type* interfaceType) {
        return GetInterfaceMap_26193b1c1167fea4(interfaceType);
    }
    
    // Automatically generated method stub
    System::String* TypeBuilder::ToString_7ae6b85e974ee75a() {
        return ToString_1636a0751cb9ac11();
    }
    
    // Automatically generated method stub
    bool TypeBuilder::IsAssignableFrom_9a1536c9f0047a78(System::Type* c) {
        return IsAssignableFrom_e3aa32d778e63a90(c);
    }
    
    // Automatically generated method stub
    void TypeBuilder::GetIDsOfNames_def76ee942c4824f(System::Guid riid, void* rgszNames, uint32_t cNames, uint32_t lcid, void* rgDispId) {
        return GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    }
    
    // Automatically generated method stub
    void TypeBuilder::GetTypeInfo_a55b188a8c4e4ae1(uint32_t iTInfo, uint32_t lcid, void* ppTInfo) {
        return GetTypeInfo(iTInfo, lcid, ppTInfo);
    }
    
    // Automatically generated method stub
    void TypeBuilder::GetTypeInfoCount_bfdd8b57afa1b5e3(uint32_t pcTInfo) {
        return GetTypeInfoCount(pcTInfo);
    }
    
    // Automatically generated method stub
    void TypeBuilder::Invoke_6ea95a7f5e37a6db(uint32_t dispIdMember, System::Guid riid, uint32_t lcid, int16_t wFlags, void* pDispParams, void* pVarResult, void* pExcepInfo, void* puArgErr) {
        return Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    }
    
    // Automatically generated method stub
    System::Type* TypeBuilder::get_DeclaringType_57e85ec7caa4a7e9() {
        return get_DeclaringType_6121cd6a84393166();
    }
    
    // Automatically generated method stub
    System::Reflection::Module* TypeBuilder::get_Module_e878d08348938612() {
        return get_Module_ea7d65dc88202263();
    }
    
    // Automatically generated method stub
    System::Type* TypeBuilder::get_ReflectedType_338a78c0f78949() {
        return get_ReflectedType_bf4971c0f442b9dc();
    }
    
    // Automatically generated method stub
    System::RuntimeTypeHandle TypeBuilder::get_TypeHandle_a660506a2c0cc3d5() {
        return get_TypeHandle_a14995fa9102936b();
    }
    
}}}
namespace System { namespace Resources {
    // Automatically generated method stub
    bool ResourceEnumerator::MoveNext_4e78e145935f5417() {
        return MoveNext();
    }
    
    // Automatically generated method stub
    void ResourceEnumerator::Reset_bcd82381eed41868() {
        return Reset();
    }
    
    // Automatically generated method stub
    System::Collections::DictionaryEntry ResourceEnumerator::get_Entry_7d036eca1ef8d5f4() {
        return get_Entry();
    }
    
    // Automatically generated method stub
    System::Object* ResourceEnumerator::get_Key_ed7954531cb20258() {
        return get_Key();
    }
    
    // Automatically generated method stub
    System::Object* ResourceEnumerator::get_Value_889e0f410f0d67ef() {
        return get_Value();
    }
    
    // Automatically generated method stub
    System::Object* ResourceEnumerator::get_Current_8eca9b3da02b123a() {
        return get_Current();
    }
    
}}
namespace System { namespace Resources {
    // Automatically generated method stub
    void ResourceReader::Close_9051b9e2cc8ad458() {
        return Close();
    }
    
    // Automatically generated method stub
    void ResourceReader::Dispose_95cb2516542c2f97() {
        return Dispose();
    }
    
    // Automatically generated method stub
    System::Collections::IDictionaryEnumerator* ResourceReader::GetEnumerator_5461f24f4ddc9df4() {
        return GetEnumerator();
    }
    
    // Automatically generated method stub
    System::Collections::IEnumerator* ResourceReader::GetEnumerator_674ad93a972a4d67() {
        return GetEnumerator2();
    }
    
}}
namespace System { namespace Resources {
    // Automatically generated method stub
    void ResourceSet::Dispose_95cb2516542c2f97() {
        return Dispose();
    }
    
    // Automatically generated method stub
    System::Collections::IEnumerator* ResourceSet::GetEnumerator_674ad93a972a4d67() {
        return GetEnumerator2();
    }
    
}}
namespace System { namespace Resources {
    // Automatically generated method stub
    void ResourceWriter::AddResource_9538446dc281eb76(System::String* name, cli::array<unsigned char>* value) {
        return AddResource(name, value);
    }
    
    // Automatically generated method stub
    void ResourceWriter::AddResource_4d7d112bfae77d9f(System::String* name, System::Object* value) {
        return AddResource2(name, value);
    }
    
    // Automatically generated method stub
    void ResourceWriter::AddResource_84237ae847b43967(System::String* name, System::String* value) {
        return AddResource3(name, value);
    }
    
    // Automatically generated method stub
    void ResourceWriter::Close_b9951e614539ebeb() {
        return Close();
    }
    
    // Automatically generated method stub
    void ResourceWriter::Dispose_95cb2516542c2f97() {
        return Dispose();
    }
    
    // Automatically generated method stub
    void ResourceWriter::Generate_fe5750179d21610b() {
        return Generate();
    }
    
}}
namespace System { namespace Runtime {
    // Automatically generated method stub
    void MemoryFailPoint::Dispose_95cb2516542c2f97() {
        return Dispose();
    }
    
}}
namespace System { namespace Runtime { namespace InteropServices {
    // Automatically generated method stub
    void CriticalHandle::Dispose_95cb2516542c2f97() {
        return Dispose();
    }
    
}}}
namespace System { namespace Runtime { namespace InteropServices {
    // Automatically generated method stub
    System::Guid RegistrationServices::GetManagedCategoryGuid_8927f525ca26383a() {
        return GetManagedCategoryGuid_38cd596c2f9eb851();
    }
    
    // Automatically generated method stub
    System::String* RegistrationServices::GetProgIdForType_13a54d045ed226a9(System::Type* type) {
        return GetProgIdForType_22a055997192433f(type);
    }
    
    // Automatically generated method stub
    cli::array<System::Type*>* RegistrationServices::GetRegistrableTypesInAssembly_9e06182253e9c8f4(System::Reflection::Assembly* assembly) {
        return GetRegistrableTypesInAssembly_f4832afc86edb77b(assembly);
    }
    
    // Automatically generated method stub
    bool RegistrationServices::RegisterAssembly_e4a461988cb7fb93(System::Reflection::Assembly* assembly, AssemblyRegistrationFlags flags) {
        return RegisterAssembly_4649f445e61234bc(assembly, flags);
    }
    
    // Automatically generated method stub
    void RegistrationServices::RegisterTypeForComClients_3563ef6caa412442(System::Type* type, System::Guid g) {
        return RegisterTypeForComClients_aa8d2fcc118d895b(type, g);
    }
    
    // Automatically generated method stub
    bool RegistrationServices::TypeRepresentsComType_def149588555fd9c(System::Type* type) {
        return TypeRepresentsComType_d8c47394bee95d97(type);
    }
    
    // Automatically generated method stub
    bool RegistrationServices::TypeRequiresRegistration_f80e9ffb5f2fed68(System::Type* type) {
        return TypeRequiresRegistration_1fc479ac880dcd46(type);
    }
    
    // Automatically generated method stub
    bool RegistrationServices::UnregisterAssembly_1073a3de66ae5fb6(System::Reflection::Assembly* assembly) {
        return UnregisterAssembly_5b40456f5b95206b(assembly);
    }
    
}}}
namespace System { namespace Runtime { namespace InteropServices {
    // Automatically generated method stub
    void SafeHandle::Dispose_95cb2516542c2f97() {
        return Dispose();
    }
    
}}}
namespace System { namespace Runtime { namespace InteropServices {
    // Automatically generated method stub
    System::Object* TypeLibConverter::ConvertAssemblyToTypeLib_390df3378aae48c(System::Reflection::Assembly* assembly, System::String* strTypeLibName, TypeLibExporterFlags flags, ITypeLibExporterNotifySink* notifySink) {
        return ConvertAssemblyToTypeLib(assembly, strTypeLibName, flags, notifySink);
    }
    
    // Automatically generated method stub
    System::Reflection::Emit::AssemblyBuilder* TypeLibConverter::ConvertTypeLibToAssembly_5e8aed5d722abc3e(System::Object* typeLib, System::String* asmFileName, int32_t flags, ITypeLibImporterNotifySink* notifySink, cli::array<unsigned char>* publicKey, System::Reflection::StrongNameKeyPair* keyPair, bool unsafeInterfaces) {
        return ConvertTypeLibToAssembly(typeLib, asmFileName, flags, notifySink, publicKey, keyPair, unsafeInterfaces);
    }
    
    // Automatically generated method stub
    System::Reflection::Emit::AssemblyBuilder* TypeLibConverter::ConvertTypeLibToAssembly_30894f5fe1326176(System::Object* typeLib, System::String* asmFileName, TypeLibImporterFlags flags, ITypeLibImporterNotifySink* notifySink, cli::array<unsigned char>* publicKey, System::Reflection::StrongNameKeyPair* keyPair, System::String* asmNamespace, System::Version* asmVersion) {
        return ConvertTypeLibToAssembly2(typeLib, asmFileName, flags, notifySink, publicKey, keyPair, asmNamespace, asmVersion);
    }
    
    // Automatically generated method stub
    bool TypeLibConverter::GetPrimaryInteropAssembly_2c8039286792eafc(System::Guid g, int32_t major, int32_t minor, int32_t lcid, System::String* asmName, System::String* asmCodeBase) {
        return GetPrimaryInteropAssembly(g, major, minor, lcid, asmName, asmCodeBase);
    }
    
}}}
namespace System { namespace Runtime { namespace Remoting {
    // Automatically generated method stub
    Messaging::IMessageSink* EnvoyInfo::get_EnvoySinks_1c0ed1452ceaf245() {
        return get_EnvoySinks();
    }
    
    // Automatically generated method stub
    Messaging::IMessageSink* EnvoyInfo::set_EnvoySinks_8e6de85a9061c891(Messaging::IMessageSink* value) {
        return set_EnvoySinks(value);
    }
    
}}}
namespace System { namespace Runtime { namespace Remoting {
    // Automatically generated method stub
    System::Object* ObjectHandle::Unwrap_c10aed64a454bc6f() {
        return Unwrap();
    }
    
}}}
namespace System { namespace Runtime { namespace Remoting {
    // Automatically generated method stub
    void ObjRef::GetObjectData_11b895a112e04409(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        return GetObjectData_ee660fdbddbfb758(info, context);
    }
    
    // Automatically generated method stub
    System::Object* ObjRef::GetRealObject_692566897a6926e4(System::Runtime::Serialization::StreamingContext context) {
        return GetRealObject_95f064ae72c47655(context);
    }
    
}}}
namespace System { namespace Runtime { namespace Remoting {
    // Automatically generated method stub
    void ConfigHandler::OnStartParsing_60c119bf90baa608(Mono::Xml::SmallXmlParser* parser) {
        return OnStartParsing(parser);
    }
    
    // Automatically generated method stub
    void ConfigHandler::OnProcessingInstruction_eeedb82cbfe7ab40(System::String* name, System::String* text) {
        return OnProcessingInstruction(name, text);
    }
    
    // Automatically generated method stub
    void ConfigHandler::OnIgnorableWhitespace_39f85fe38215782c(System::String* s) {
        return OnIgnorableWhitespace(s);
    }
    
    // Automatically generated method stub
    void ConfigHandler::OnStartElement_431a5ecd1484562f(System::String* name, Mono::Xml::IAttrList* attrs) {
        return OnStartElement(name, attrs);
    }
    
    // Automatically generated method stub
    void ConfigHandler::OnEndElement_47dd703957202fcd(System::String* name) {
        return OnEndElement(name);
    }
    
    // Automatically generated method stub
    void ConfigHandler::OnChars_23545ef97e4c205b(System::String* ch) {
        return OnChars(ch);
    }
    
    // Automatically generated method stub
    void ConfigHandler::OnEndParsing_ddf0252ce1c74235(Mono::Xml::SmallXmlParser* parser) {
        return OnEndParsing(parser);
    }
    
}}}
namespace System { namespace Runtime { namespace Remoting {
    // Automatically generated method stub
    Messaging::IMessage* DisposerReplySink::SyncProcessMessage_d4949581639d4872(Messaging::IMessage* msg) {
        return SyncProcessMessage(msg);
    }
    
    // Automatically generated method stub
    Messaging::IMessageCtrl* DisposerReplySink::AsyncProcessMessage_3d553dfedc95e36f(Messaging::IMessage* msg, Messaging::IMessageSink* replySink) {
        return AsyncProcessMessage(msg, replySink);
    }
    
    // Automatically generated method stub
    Messaging::IMessageSink* DisposerReplySink::get_NextSink_e70f5bac1f0d1245() {
        return get_NextSink();
    }
    
}}}
namespace System { namespace Runtime { namespace Remoting {
    // Automatically generated method stub
    bool TypeInfo2::CanCastTo_7f8304fa142c3271(System::Type* fromType, System::Object* o) {
        return CanCastTo(fromType, o);
    }
    
    // Automatically generated method stub
    System::String* TypeInfo2::get_TypeName_e368785a4c79e626() {
        return get_TypeName();
    }
    
    // Automatically generated method stub
    System::String* TypeInfo2::set_TypeName_d3657f810af9c065(System::String* value) {
        return set_TypeName(value);
    }
    
}}}
namespace System { namespace Runtime { namespace Remoting { namespace Activation {
    // Automatically generated method stub
    IConstructionReturnMessage* AppDomainLevelActivator::Activate_49ae602ff2f2ec37(IConstructionCallMessage* ctorCall) {
        return Activate(ctorCall);
    }
    
    // Automatically generated method stub
    ActivatorLevel AppDomainLevelActivator::get_Level_ca7e6f0a04053a94() {
        return get_Level();
    }
    
    // Automatically generated method stub
    IActivator* AppDomainLevelActivator::get_NextActivator_d6b0fab3e3c1398b() {
        return get_NextActivator();
    }
    
    // Automatically generated method stub
    IActivator* AppDomainLevelActivator::set_NextActivator_d4b9338a5d7c4775(IActivator* value) {
        return set_NextActivator(value);
    }
    
}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Activation {
    // Automatically generated method stub
    IConstructionReturnMessage* ConstructionLevelActivator::Activate_49ae602ff2f2ec37(IConstructionCallMessage* msg) {
        return Activate(msg);
    }
    
    // Automatically generated method stub
    ActivatorLevel ConstructionLevelActivator::get_Level_ca7e6f0a04053a94() {
        return get_Level();
    }
    
    // Automatically generated method stub
    IActivator* ConstructionLevelActivator::get_NextActivator_d6b0fab3e3c1398b() {
        return get_NextActivator();
    }
    
    // Automatically generated method stub
    IActivator* ConstructionLevelActivator::set_NextActivator_d4b9338a5d7c4775(IActivator* value) {
        return set_NextActivator(value);
    }
    
}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Activation {
    // Automatically generated method stub
    IConstructionReturnMessage* ContextLevelActivator::Activate_49ae602ff2f2ec37(IConstructionCallMessage* ctorCall) {
        return Activate(ctorCall);
    }
    
    // Automatically generated method stub
    ActivatorLevel ContextLevelActivator::get_Level_ca7e6f0a04053a94() {
        return get_Level();
    }
    
    // Automatically generated method stub
    IActivator* ContextLevelActivator::get_NextActivator_d6b0fab3e3c1398b() {
        return get_NextActivator();
    }
    
    // Automatically generated method stub
    IActivator* ContextLevelActivator::set_NextActivator_d4b9338a5d7c4775(IActivator* value) {
        return set_NextActivator(value);
    }
    
}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Activation {
    // Automatically generated method stub
    bool RemoteActivationAttribute::IsContextOK_c0cd4400710cc315(System::Runtime::Remoting::Contexts::Context2* ctx, IConstructionCallMessage* ctor) {
        return IsContextOK(ctx, ctor);
    }
    
    // Automatically generated method stub
    void RemoteActivationAttribute::GetPropertiesForNewContext_98ae344cb00933c3(IConstructionCallMessage* ctor) {
        return GetPropertiesForNewContext(ctor);
    }
    
}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Activation {
    // Automatically generated method stub
    IConstructionReturnMessage* RemoteActivator::Activate_49ae602ff2f2ec37(IConstructionCallMessage* msg) {
        return Activate(msg);
    }
    
    // Automatically generated method stub
    ActivatorLevel RemoteActivator::get_Level_ca7e6f0a04053a94() {
        return get_Level();
    }
    
    // Automatically generated method stub
    IActivator* RemoteActivator::get_NextActivator_d6b0fab3e3c1398b() {
        return get_NextActivator();
    }
    
    // Automatically generated method stub
    IActivator* RemoteActivator::set_NextActivator_d4b9338a5d7c4775(IActivator* value) {
        return set_NextActivator(value);
    }
    
}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Channels {
    // Automatically generated method stub
    void AggregateDictionary::Add_642542cf7a4cae38(System::Object* key, System::Object* value) {
        return Add(key, value);
    }
    
    // Automatically generated method stub
    void AggregateDictionary::Clear_23091c63869f817f() {
        return Clear();
    }
    
    // Automatically generated method stub
    bool AggregateDictionary::Contains_32eba6643fe7ee4b(System::Object* ob) {
        return Contains(ob);
    }
    
    // Automatically generated method stub
    System::Collections::IDictionaryEnumerator* AggregateDictionary::GetEnumerator_40657fcb15842551() {
        return GetEnumerator();
    }
    
    // Automatically generated method stub
    System::Collections::IEnumerator* AggregateDictionary::GetEnumerator_674ad93a972a4d67() {
        return GetEnumerator2();
    }
    
    // Automatically generated method stub
    void AggregateDictionary::Remove_f212b96e00d6aaed(System::Object* ob) {
        return Remove(ob);
    }
    
    // Automatically generated method stub
    void AggregateDictionary::CopyTo_7065a6e3cf6a140(System::Array* array, int32_t index) {
        return CopyTo(array, index);
    }
    
    // Automatically generated method stub
    bool AggregateDictionary::get_IsFixedSize_9b77ca904d42a211() {
        return get_IsFixedSize();
    }
    
    // Automatically generated method stub
    bool AggregateDictionary::get_IsReadOnly_faaa94fe854aaa5f() {
        return get_IsReadOnly();
    }
    
    // Automatically generated method stub
    System::Object* AggregateDictionary::get_Item_95688dd349c069c0(System::Object* key) {
        return get_Item(key);
    }
    
    // Automatically generated method stub
    System::Object* AggregateDictionary::set_Item_a0c4aaef01cc13c2(System::Object* key, System::Object* value) {
        return set_Item(key, value);
    }
    
    // Automatically generated method stub
    System::Collections::ICollection* AggregateDictionary::get_Keys_d809cadac60b140a() {
        return get_Keys();
    }
    
    // Automatically generated method stub
    System::Collections::ICollection* AggregateDictionary::get_Values_ef6ae5cda2bdcf40() {
        return get_Values();
    }
    
    // Automatically generated method stub
    int32_t AggregateDictionary::get_Count_8f254f3dd8e2403() {
        return get_Count();
    }
    
    // Automatically generated method stub
    bool AggregateDictionary::get_IsSynchronized_20926e7dabc53dbf() {
        return get_IsSynchronized();
    }
    
    // Automatically generated method stub
    System::Object* AggregateDictionary::get_SyncRoot_257108f45cc89e19() {
        return get_SyncRoot();
    }
    
}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Channels {
    // Automatically generated method stub
    bool AggregateEnumerator::MoveNext_4e78e145935f5417() {
        return MoveNext();
    }
    
    // Automatically generated method stub
    void AggregateEnumerator::Reset_bcd82381eed41868() {
        return Reset();
    }
    
    // Automatically generated method stub
    System::Collections::DictionaryEntry AggregateEnumerator::get_Entry_7d036eca1ef8d5f4() {
        return get_Entry();
    }
    
    // Automatically generated method stub
    System::Object* AggregateEnumerator::get_Key_ed7954531cb20258() {
        return get_Key();
    }
    
    // Automatically generated method stub
    System::Object* AggregateEnumerator::get_Value_889e0f410f0d67ef() {
        return get_Value();
    }
    
    // Automatically generated method stub
    System::Object* AggregateEnumerator::get_Current_8eca9b3da02b123a() {
        return get_Current();
    }
    
}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Channels {
    // Automatically generated method stub
    void BaseChannelObjectWithProperties::Add_642542cf7a4cae38(System::Object* key, System::Object* value) {
        return Add_2e0cc46b6f5b39af(key, value);
    }
    
    // Automatically generated method stub
    void BaseChannelObjectWithProperties::Clear_23091c63869f817f() {
        return Clear_8ffd4fa1ec43d480();
    }
    
    // Automatically generated method stub
    bool BaseChannelObjectWithProperties::Contains_32eba6643fe7ee4b(System::Object* key) {
        return Contains_71330cff12df5547(key);
    }
    
    // Automatically generated method stub
    void BaseChannelObjectWithProperties::CopyTo_7065a6e3cf6a140(System::Array* array, int32_t index) {
        return CopyTo_7fd02345ed41791b(array, index);
    }
    
    // Automatically generated method stub
    System::Collections::IDictionaryEnumerator* BaseChannelObjectWithProperties::GetEnumerator_40657fcb15842551() {
        return GetEnumerator_c7500511247ec59();
    }
    
    // Automatically generated method stub
    System::Collections::IEnumerator* BaseChannelObjectWithProperties::GetEnumerator_674ad93a972a4d67() {
        return GetEnumerator2();
    }
    
    // Automatically generated method stub
    void BaseChannelObjectWithProperties::Remove_f212b96e00d6aaed(System::Object* key) {
        return Remove_b53f91745646ed6a(key);
    }
    
    // Automatically generated method stub
    int32_t BaseChannelObjectWithProperties::get_Count_8f254f3dd8e2403() {
        return get_Count_71041d0495b6ff46();
    }
    
    // Automatically generated method stub
    bool BaseChannelObjectWithProperties::get_IsFixedSize_9b77ca904d42a211() {
        return get_IsFixedSize_6395df2c82d6b9f7();
    }
    
    // Automatically generated method stub
    bool BaseChannelObjectWithProperties::get_IsReadOnly_faaa94fe854aaa5f() {
        return get_IsReadOnly_ebb68688cdc55cb2();
    }
    
    // Automatically generated method stub
    bool BaseChannelObjectWithProperties::get_IsSynchronized_20926e7dabc53dbf() {
        return get_IsSynchronized_c68490f579af4c3();
    }
    
    // Automatically generated method stub
    System::Object* BaseChannelObjectWithProperties::get_Item_95688dd349c069c0(System::Object* key) {
        return get_Item_593a2a34dd2c3a91(key);
    }
    
    // Automatically generated method stub
    System::Object* BaseChannelObjectWithProperties::set_Item_a0c4aaef01cc13c2(System::Object* key, System::Object* value) {
        return set_Item_e97df2a7db730e1a(key, value);
    }
    
    // Automatically generated method stub
    System::Collections::ICollection* BaseChannelObjectWithProperties::get_Keys_d809cadac60b140a() {
        return get_Keys_9678cd4a10400c88();
    }
    
    // Automatically generated method stub
    System::Object* BaseChannelObjectWithProperties::get_SyncRoot_257108f45cc89e19() {
        return get_SyncRoot_d3ef26010f2a22ec();
    }
    
    // Automatically generated method stub
    System::Collections::ICollection* BaseChannelObjectWithProperties::get_Values_ef6ae5cda2bdcf40() {
        return get_Values_cb1640740b4b52b2();
    }
    
}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Channels {
    // Automatically generated method stub
    cli::array<System::String*>* ChannelDataStore::get_ChannelUris_ea291fabcbfe8aaa() {
        return get_ChannelUris();
    }
    
    // Automatically generated method stub
    System::Object* ChannelDataStore::get_Item_e760c8b72e46bb27(System::Object* key) {
        return get_Item(key);
    }
    
    // Automatically generated method stub
    System::Object* ChannelDataStore::set_Item_1ecebca6bd3e41cb(System::Object* key, System::Object* value) {
        return set_Item(key, value);
    }
    
}}}}
namespace System { namespace Runtime { namespace Remoting {
    // Automatically generated method stub
    cli::array<System::Object*>* ChannelInfo::get_ChannelData_a0d7a480581057f3() {
        return get_ChannelData();
    }
    
    // Automatically generated method stub
    cli::array<System::Object*>* ChannelInfo::set_ChannelData_bfc7444492100e65(cli::array<System::Object*>* value) {
        return set_ChannelData(value);
    }
    
}}}
namespace System { namespace Runtime { namespace Remoting { namespace Channels {
    // Automatically generated method stub
    System::Runtime::Remoting::Messaging::IMessage* ExceptionFilterSink::SyncProcessMessage_d4949581639d4872(System::Runtime::Remoting::Messaging::IMessage* msg) {
        return SyncProcessMessage(msg);
    }
    
    // Automatically generated method stub
    System::Runtime::Remoting::Messaging::IMessageCtrl* ExceptionFilterSink::AsyncProcessMessage_3d553dfedc95e36f(System::Runtime::Remoting::Messaging::IMessage* msg, System::Runtime::Remoting::Messaging::IMessageSink* replySink) {
        return AsyncProcessMessage(msg, replySink);
    }
    
    // Automatically generated method stub
    System::Runtime::Remoting::Messaging::IMessageSink* ExceptionFilterSink::get_NextSink_e70f5bac1f0d1245() {
        return get_NextSink();
    }
    
}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Channels {
    // Automatically generated method stub
    void ClientChannelSinkStack::AsyncProcessResponse_d672fc10cee61823(ITransportHeaders* headers, System::IO::Stream* stream) {
        return AsyncProcessResponse(headers, stream);
    }
    
    // Automatically generated method stub
    void ClientChannelSinkStack::DispatchException_7c329149bbfd27eb(System::Exception* e) {
        return DispatchException(e);
    }
    
    // Automatically generated method stub
    void ClientChannelSinkStack::DispatchReplyMessage_3379ae4985e4327c(System::Runtime::Remoting::Messaging::IMessage* msg) {
        return DispatchReplyMessage(msg);
    }
    
    // Automatically generated method stub
    System::Object* ClientChannelSinkStack::Pop_4550bb7de7b65554(IClientChannelSink* sink) {
        return Pop(sink);
    }
    
    // Automatically generated method stub
    void ClientChannelSinkStack::Push_47f6a51bfc8d8965(IClientChannelSink* sink, System::Object* state) {
        return Push(sink, state);
    }
    
}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Channels {
    // Automatically generated method stub
    System::String* CrossAppDomainChannel::Parse_f03b6e6bc4217a25(System::String* url, System::String* objectURI) {
        return Parse(url, objectURI);
    }
    
    // Automatically generated method stub
    cli::array<System::String*>* CrossAppDomainChannel::GetUrlsForUri_3e77808f3d9020c7(System::String* objectURI) {
        return GetUrlsForUri_d686284f037feab3(objectURI);
    }
    
    // Automatically generated method stub
    void CrossAppDomainChannel::StartListening_a568e860f5c12098(System::Object* data) {
        return StartListening_facefd345f0460a1(data);
    }
    
    // Automatically generated method stub
    void CrossAppDomainChannel::StopListening_77f3993d6f40946f(System::Object* data) {
        return StopListening_baaf88d837ccab5c(data);
    }
    
    // Automatically generated method stub
    System::Runtime::Remoting::Messaging::IMessageSink* CrossAppDomainChannel::CreateMessageSink_66e723ef8344d1c9(System::String* url, System::Object* data, System::String* uri) {
        return CreateMessageSink_16a9a5ea63020929(url, data, uri);
    }
    
    // Automatically generated method stub
    System::String* CrossAppDomainChannel::get_ChannelName_92306725eef18163() {
        return get_ChannelName_377a03c7204ade87();
    }
    
    // Automatically generated method stub
    int32_t CrossAppDomainChannel::get_ChannelPriority_b96d903fee110f5d() {
        return get_ChannelPriority_6555198b7b654a77();
    }
    
    // Automatically generated method stub
    System::Object* CrossAppDomainChannel::get_ChannelData_bd2f3a6812b5fc88() {
        return get_ChannelData_c2e668c6c3bac5a2();
    }
    
}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Channels {
    // Automatically generated method stub
    System::Runtime::Remoting::Messaging::IMessage* CrossAppDomainSink::SyncProcessMessage_d4949581639d4872(System::Runtime::Remoting::Messaging::IMessage* msgRequest) {
        return SyncProcessMessage_68a690daafdab562(msgRequest);
    }
    
    // Automatically generated method stub
    System::Runtime::Remoting::Messaging::IMessageCtrl* CrossAppDomainSink::AsyncProcessMessage_3d553dfedc95e36f(System::Runtime::Remoting::Messaging::IMessage* reqMsg, System::Runtime::Remoting::Messaging::IMessageSink* replySink) {
        return AsyncProcessMessage_6cb8c8ebc3c3ec7c(reqMsg, replySink);
    }
    
    // Automatically generated method stub
    System::Runtime::Remoting::Messaging::IMessageSink* CrossAppDomainSink::get_NextSink_e70f5bac1f0d1245() {
        return get_NextSink();
    }
    
}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Channels {
    // Automatically generated method stub
    System::IO::Stream* ServerChannelSinkStack::GetResponseStream_e19a69cdcfbe6e70(System::Runtime::Remoting::Messaging::IMessage* msg, ITransportHeaders* headers) {
        return GetResponseStream(msg, headers);
    }
    
    // Automatically generated method stub
    System::Object* ServerChannelSinkStack::Pop_86e374140ce04b4a(IServerChannelSink* sink) {
        return Pop(sink);
    }
    
    // Automatically generated method stub
    void ServerChannelSinkStack::Push_4e4c6597fd9aae15(IServerChannelSink* sink, System::Object* state) {
        return Push(sink, state);
    }
    
    // Automatically generated method stub
    void ServerChannelSinkStack::ServerCallback_997eeaf298842004(System::IAsyncResult* ar) {
        return ServerCallback(ar);
    }
    
    // Automatically generated method stub
    void ServerChannelSinkStack::Store_1327911ba6e60262(IServerChannelSink* sink, System::Object* state) {
        return Store(sink, state);
    }
    
    // Automatically generated method stub
    void ServerChannelSinkStack::StoreAndDispatch_ecff62ebd0a78b8c(IServerChannelSink* sink, System::Object* state) {
        return StoreAndDispatch(sink, state);
    }
    
    // Automatically generated method stub
    void ServerChannelSinkStack::AsyncProcessResponse_49e84a50b456f300(System::Runtime::Remoting::Messaging::IMessage* msg, ITransportHeaders* headers, System::IO::Stream* stream) {
        return AsyncProcessResponse(msg, headers, stream);
    }
    
}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Channels {
    // Automatically generated method stub
    void ServerDispatchSink::AsyncProcessResponse_de8d5b38a27d9262(IServerResponseChannelSinkStack* sinkStack, System::Object* state, System::Runtime::Remoting::Messaging::IMessage* msg, ITransportHeaders* headers, System::IO::Stream* stream) {
        return AsyncProcessResponse(sinkStack, state, msg, headers, stream);
    }
    
    // Automatically generated method stub
    System::IO::Stream* ServerDispatchSink::GetResponseStream_226ecebab7f1ae4a(IServerResponseChannelSinkStack* sinkStack, System::Object* state, System::Runtime::Remoting::Messaging::IMessage* msg, ITransportHeaders* headers) {
        return GetResponseStream(sinkStack, state, msg, headers);
    }
    
    // Automatically generated method stub
    ServerProcessing ServerDispatchSink::ProcessMessage_f903a2d50825660b(IServerChannelSinkStack* sinkStack, System::Runtime::Remoting::Messaging::IMessage* requestMsg, ITransportHeaders* requestHeaders, System::IO::Stream* requestStream, System::Runtime::Remoting::Messaging::IMessage* responseMsg, ITransportHeaders* responseHeaders, System::IO::Stream* responseStream) {
        return ProcessMessage(sinkStack, requestMsg, requestHeaders, requestStream, responseMsg, responseHeaders, responseStream);
    }
    
    // Automatically generated method stub
    IServerChannelSink* ServerDispatchSink::get_NextChannelSink_6e269c53e50789c7() {
        return get_NextChannelSink();
    }
    
    // Automatically generated method stub
    System::Collections::IDictionary* ServerDispatchSink::get_Properties_381d7d7a86286003() {
        return get_Properties();
    }
    
}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Channels {
    // Automatically generated method stub
    IServerChannelSink* ServerDispatchSinkProvider::CreateSink_393aa9e6f3a19f60(IChannelReceiver* channel) {
        return CreateSink(channel);
    }
    
    // Automatically generated method stub
    void ServerDispatchSinkProvider::GetChannelData_ddcc0792026c6379(IChannelDataStore* channelData) {
        return GetChannelData(channelData);
    }
    
    // Automatically generated method stub
    IServerChannelSinkProvider* ServerDispatchSinkProvider::get_Next_c6272a298f936a9f() {
        return get_Next();
    }
    
    // Automatically generated method stub
    IServerChannelSinkProvider* ServerDispatchSinkProvider::set_Next_3f72cebde871a137(IServerChannelSinkProvider* value) {
        return set_Next(value);
    }
    
}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Channels {
    // Automatically generated method stub
    System::Collections::IEnumerator* TransportHeaders::GetEnumerator_3a76a2c7ca35933f() {
        return GetEnumerator();
    }
    
    // Automatically generated method stub
    System::Object* TransportHeaders::get_Item_720a0b389493f59a(System::Object* key) {
        return get_Item(key);
    }
    
    // Automatically generated method stub
    System::Object* TransportHeaders::set_Item_6a9ed7422eb40f13(System::Object* key, System::Object* value) {
        return set_Item(key, value);
    }
    
}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Contexts {
    // Automatically generated method stub
    void ContextAttribute::Freeze_15e6c602de21dea(Context2* newContext) {
        return Freeze_ee06f0cc6fc5f1f(newContext);
    }
    
    // Automatically generated method stub
    void ContextAttribute::GetPropertiesForNewContext_98ae344cb00933c3(System::Runtime::Remoting::Activation::IConstructionCallMessage* ctorMsg) {
        return GetPropertiesForNewContext_f6e9f6568c456816(ctorMsg);
    }
    
    // Automatically generated method stub
    bool ContextAttribute::IsContextOK_c0cd4400710cc315(Context2* ctx, System::Runtime::Remoting::Activation::IConstructionCallMessage* ctorMsg) {
        return IsContextOK_7837aaab12d993b6(ctx, ctorMsg);
    }
    
    // Automatically generated method stub
    bool ContextAttribute::IsNewContextOK_d441173b4713767c(Context2* newCtx) {
        return IsNewContextOK_19a054e462d56b73(newCtx);
    }
    
    // Automatically generated method stub
    System::String* ContextAttribute::get_Name_c8dae2189d434839() {
        return get_Name_2c4efe01fcf96d3();
    }
    
}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Contexts {
    // Automatically generated method stub
    System::Runtime::Remoting::Messaging::IMessage* ContextRestoreSink::SyncProcessMessage_d4949581639d4872(System::Runtime::Remoting::Messaging::IMessage* msg) {
        return SyncProcessMessage(msg);
    }
    
    // Automatically generated method stub
    System::Runtime::Remoting::Messaging::IMessageCtrl* ContextRestoreSink::AsyncProcessMessage_3d553dfedc95e36f(System::Runtime::Remoting::Messaging::IMessage* msg, System::Runtime::Remoting::Messaging::IMessageSink* replySink) {
        return AsyncProcessMessage(msg, replySink);
    }
    
    // Automatically generated method stub
    System::Runtime::Remoting::Messaging::IMessageSink* ContextRestoreSink::get_NextSink_e70f5bac1f0d1245() {
        return get_NextSink();
    }
    
}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Contexts {
    // Automatically generated method stub
    System::Runtime::Remoting::Messaging::IMessage* CrossContextChannel::SyncProcessMessage_d4949581639d4872(System::Runtime::Remoting::Messaging::IMessage* msg) {
        return SyncProcessMessage(msg);
    }
    
    // Automatically generated method stub
    System::Runtime::Remoting::Messaging::IMessageCtrl* CrossContextChannel::AsyncProcessMessage_3d553dfedc95e36f(System::Runtime::Remoting::Messaging::IMessage* msg, System::Runtime::Remoting::Messaging::IMessageSink* replySink) {
        return AsyncProcessMessage(msg, replySink);
    }
    
    // Automatically generated method stub
    System::Runtime::Remoting::Messaging::IMessageSink* CrossContextChannel::get_NextSink_e70f5bac1f0d1245() {
        return get_NextSink();
    }
    
}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Contexts {
    // Automatically generated method stub
    void SynchronizationAttribute::GetPropertiesForNewContext_98ae344cb00933c3(System::Runtime::Remoting::Activation::IConstructionCallMessage* ctorMsg) {
        return GetPropertiesForNewContext_f6e9f6568c456816(ctorMsg);
    }
    
    // Automatically generated method stub
    System::Runtime::Remoting::Messaging::IMessageSink* SynchronizationAttribute::GetClientContextSink_4901bfa17250fabc(System::Runtime::Remoting::Messaging::IMessageSink* nextSink) {
        return GetClientContextSink_d46a0dc375cfe814(nextSink);
    }
    
    // Automatically generated method stub
    System::Runtime::Remoting::Messaging::IMessageSink* SynchronizationAttribute::GetServerContextSink_1f6bff576bbda(System::Runtime::Remoting::Messaging::IMessageSink* nextSink) {
        return GetServerContextSink_b934956cce20f850(nextSink);
    }
    
    // Automatically generated method stub
    bool SynchronizationAttribute::IsContextOK_c0cd4400710cc315(Context2* ctx, System::Runtime::Remoting::Activation::IConstructionCallMessage* msg) {
        return IsContextOK_7837aaab12d993b6(ctx, msg);
    }
    
}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Contexts {
    // Automatically generated method stub
    System::Runtime::Remoting::Messaging::IMessageCtrl* SynchronizedClientContextSink::AsyncProcessMessage_3d553dfedc95e36f(System::Runtime::Remoting::Messaging::IMessage* msg, System::Runtime::Remoting::Messaging::IMessageSink* replySink) {
        return AsyncProcessMessage(msg, replySink);
    }
    
    // Automatically generated method stub
    System::Runtime::Remoting::Messaging::IMessage* SynchronizedClientContextSink::SyncProcessMessage_d4949581639d4872(System::Runtime::Remoting::Messaging::IMessage* msg) {
        return SyncProcessMessage(msg);
    }
    
    // Automatically generated method stub
    System::Runtime::Remoting::Messaging::IMessageSink* SynchronizedClientContextSink::get_NextSink_e70f5bac1f0d1245() {
        return get_NextSink();
    }
    
}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Contexts {
    // Automatically generated method stub
    System::Runtime::Remoting::Messaging::IMessageCtrl* SynchronizedServerContextSink::AsyncProcessMessage_3d553dfedc95e36f(System::Runtime::Remoting::Messaging::IMessage* msg, System::Runtime::Remoting::Messaging::IMessageSink* replySink) {
        return AsyncProcessMessage(msg, replySink);
    }
    
    // Automatically generated method stub
    System::Runtime::Remoting::Messaging::IMessage* SynchronizedServerContextSink::SyncProcessMessage_d4949581639d4872(System::Runtime::Remoting::Messaging::IMessage* msg) {
        return SyncProcessMessage(msg);
    }
    
    // Automatically generated method stub
    System::Runtime::Remoting::Messaging::IMessageSink* SynchronizedServerContextSink::get_NextSink_e70f5bac1f0d1245() {
        return get_NextSink();
    }
    
}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Contexts {
    // Automatically generated method stub
    System::Runtime::Remoting::Messaging::IMessageCtrl* SynchronizedContextReplySink::AsyncProcessMessage_3d553dfedc95e36f(System::Runtime::Remoting::Messaging::IMessage* msg, System::Runtime::Remoting::Messaging::IMessageSink* replySink) {
        return AsyncProcessMessage(msg, replySink);
    }
    
    // Automatically generated method stub
    System::Runtime::Remoting::Messaging::IMessage* SynchronizedContextReplySink::SyncProcessMessage_d4949581639d4872(System::Runtime::Remoting::Messaging::IMessage* msg) {
        return SyncProcessMessage(msg);
    }
    
    // Automatically generated method stub
    System::Runtime::Remoting::Messaging::IMessageSink* SynchronizedContextReplySink::get_NextSink_e70f5bac1f0d1245() {
        return get_NextSink();
    }
    
}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Lifetime {
    // Automatically generated method stub
    System::TimeSpan ClientSponsor::Renewal_eed03694f8483857(ILease* lease) {
        return Renewal(lease);
    }
    
}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Lifetime {
    // Automatically generated method stub
    void Lease::Register_29cd33cb094da73(ISponsor* obj) {
        return Register(obj);
    }
    
    // Automatically generated method stub
    void Lease::Register_a287b3a68d0f3c8a(ISponsor* obj, System::TimeSpan renewalTime) {
        return Register2(obj, renewalTime);
    }
    
    // Automatically generated method stub
    System::TimeSpan Lease::Renew_ac41c9e01b454d0a(System::TimeSpan renewalTime) {
        return Renew(renewalTime);
    }
    
    // Automatically generated method stub
    void Lease::Unregister_8ceee2c7f59bf148(ISponsor* obj) {
        return Unregister(obj);
    }
    
    // Automatically generated method stub
    System::TimeSpan Lease::get_CurrentLeaseTime_495da45221ea9c91() {
        return get_CurrentLeaseTime();
    }
    
    // Automatically generated method stub
    LeaseState Lease::get_CurrentState_c1fd61e427ff7162() {
        return get_CurrentState();
    }
    
    // Automatically generated method stub
    System::TimeSpan Lease::get_InitialLeaseTime_aa84660515c07bca() {
        return get_InitialLeaseTime();
    }
    
    // Automatically generated method stub
    System::TimeSpan Lease::set_InitialLeaseTime_ba2e7f8774a51a3f(System::TimeSpan value) {
        return set_InitialLeaseTime(value);
    }
    
    // Automatically generated method stub
    System::TimeSpan Lease::get_RenewOnCallTime_d513f7649eedc4() {
        return get_RenewOnCallTime();
    }
    
    // Automatically generated method stub
    System::TimeSpan Lease::set_RenewOnCallTime_ed741ebcdf794d2f(System::TimeSpan value) {
        return set_RenewOnCallTime(value);
    }
    
    // Automatically generated method stub
    System::TimeSpan Lease::get_SponsorshipTimeout_21865f97c16cd67d() {
        return get_SponsorshipTimeout();
    }
    
    // Automatically generated method stub
    System::TimeSpan Lease::set_SponsorshipTimeout_43c4b2fd11e77e17(System::TimeSpan value) {
        return set_SponsorshipTimeout(value);
    }
    
}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Lifetime {
    // Automatically generated method stub
    System::Runtime::Remoting::Messaging::IMessage* LeaseSink::SyncProcessMessage_d4949581639d4872(System::Runtime::Remoting::Messaging::IMessage* msg) {
        return SyncProcessMessage(msg);
    }
    
    // Automatically generated method stub
    System::Runtime::Remoting::Messaging::IMessageCtrl* LeaseSink::AsyncProcessMessage_3d553dfedc95e36f(System::Runtime::Remoting::Messaging::IMessage* msg, System::Runtime::Remoting::Messaging::IMessageSink* replySink) {
        return AsyncProcessMessage(msg, replySink);
    }
    
    // Automatically generated method stub
    System::Runtime::Remoting::Messaging::IMessageSink* LeaseSink::get_NextSink_e70f5bac1f0d1245() {
        return get_NextSink();
    }
    
}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Messaging {
    // Automatically generated method stub
    IMessageCtrl* AsyncResult::AsyncProcessMessage_3d553dfedc95e36f(IMessage* msg, IMessageSink* replySink) {
        return AsyncProcessMessage_a01f2a1b514d028d(msg, replySink);
    }
    
    // Automatically generated method stub
    IMessage* AsyncResult::SyncProcessMessage_d4949581639d4872(IMessage* msg) {
        return SyncProcessMessage_3a1c0f460fa2243a(msg);
    }
    
    // Automatically generated method stub
    System::Object* AsyncResult::get_AsyncState_edfadcd905632437() {
        return get_AsyncState_aad5ef5e6cedee67();
    }
    
    // Automatically generated method stub
    System::Threading::WaitHandle* AsyncResult::get_AsyncWaitHandle_7620505c49d113f3() {
        return get_AsyncWaitHandle_f4b3f8abdd4ea96a();
    }
    
    // Automatically generated method stub
    bool AsyncResult::get_CompletedSynchronously_2176ca6518f7b5dc() {
        return get_CompletedSynchronously_86fab18081573bcb();
    }
    
    // Automatically generated method stub
    bool AsyncResult::get_IsCompleted_908b07d70649b7ff() {
        return get_IsCompleted_6b14984a80e30c47();
    }
    
    // Automatically generated method stub
    IMessageSink* AsyncResult::get_NextSink_e70f5bac1f0d1245() {
        return get_NextSink();
    }
    
}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Messaging {
    // Automatically generated method stub
    IMessage* ClientContextTerminatorSink::SyncProcessMessage_d4949581639d4872(IMessage* msg) {
        return SyncProcessMessage(msg);
    }
    
    // Automatically generated method stub
    IMessageCtrl* ClientContextTerminatorSink::AsyncProcessMessage_3d553dfedc95e36f(IMessage* msg, IMessageSink* replySink) {
        return AsyncProcessMessage(msg, replySink);
    }
    
    // Automatically generated method stub
    IMessageSink* ClientContextTerminatorSink::get_NextSink_e70f5bac1f0d1245() {
        return get_NextSink();
    }
    
}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Messaging {
    // Automatically generated method stub
    IMessage* ClientContextReplySink::SyncProcessMessage_d4949581639d4872(IMessage* msg) {
        return SyncProcessMessage(msg);
    }
    
    // Automatically generated method stub
    IMessageCtrl* ClientContextReplySink::AsyncProcessMessage_3d553dfedc95e36f(IMessage* msg, IMessageSink* replySink) {
        return AsyncProcessMessage(msg, replySink);
    }
    
    // Automatically generated method stub
    IMessageSink* ClientContextReplySink::get_NextSink_e70f5bac1f0d1245() {
        return get_NextSink();
    }
    
}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Messaging {
    // Automatically generated method stub
    void ConstructionCall::GetObjectData_11b895a112e04409(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        return GetObjectData_972cb159043c8ab0(info, context);
    }
    
    // Automatically generated method stub
    System::Type* ConstructionCall::get_ActivationType_84a662e1d53c6b9a() {
        return get_ActivationType();
    }
    
    // Automatically generated method stub
    System::String* ConstructionCall::get_ActivationTypeName_1af5753a691619eb() {
        return get_ActivationTypeName();
    }
    
    // Automatically generated method stub
    System::Runtime::Remoting::Activation::IActivator* ConstructionCall::get_Activator_e0d47498ed580034() {
        return get_Activator();
    }
    
    // Automatically generated method stub
    System::Runtime::Remoting::Activation::IActivator* ConstructionCall::set_Activator_f69a6bba41c9ebf3(System::Runtime::Remoting::Activation::IActivator* value) {
        return set_Activator(value);
    }
    
    // Automatically generated method stub
    cli::array<System::Object*>* ConstructionCall::get_CallSiteActivationAttributes_87621fd6aed1643f() {
        return get_CallSiteActivationAttributes();
    }
    
    // Automatically generated method stub
    System::Collections::IList* ConstructionCall::get_ContextProperties_6d65d78ae4ed4d3() {
        return get_ContextProperties();
    }
    
    // Automatically generated method stub
    System::Collections::IDictionary* ConstructionCall::get_Properties_d88088440249f163() {
        return get_Properties_c453f36b3f043bdc();
    }
    
    // Automatically generated method stub
    System::Object* ConstructionCall::GetInArg_1fc884e43e06ea98(int32_t argNum) {
        return GetInArg(argNum);
    }
    
    // Automatically generated method stub
    System::String* ConstructionCall::GetInArgName_602a2e2cf6d07514(int32_t index) {
        return GetInArgName(index);
    }
    
    // Automatically generated method stub
    int32_t ConstructionCall::get_InArgCount_cb2e74281a598234() {
        return get_InArgCount();
    }
    
    // Automatically generated method stub
    cli::array<System::Object*>* ConstructionCall::get_InArgs_f63ad3f1c81c6020() {
        return get_InArgs();
    }
    
    // Automatically generated method stub
    System::Object* ConstructionCall::GetArg_b08c2cf8a17399d(int32_t argNum) {
        return GetArg(argNum);
    }
    
    // Automatically generated method stub
    System::String* ConstructionCall::GetArgName_fe0b5c1914782402(int32_t index) {
        return GetArgName(index);
    }
    
    // Automatically generated method stub
    int32_t ConstructionCall::get_ArgCount_c4a9c359c4fe1d8e() {
        return get_ArgCount();
    }
    
    // Automatically generated method stub
    cli::array<System::Object*>* ConstructionCall::get_Args_1b1b87289e375adf() {
        return get_Args();
    }
    
    // Automatically generated method stub
    bool ConstructionCall::get_HasVarArgs_554adf133c756bdc() {
        return get_HasVarArgs();
    }
    
    // Automatically generated method stub
    LogicalCallContext* ConstructionCall::get_LogicalCallContext_a19aeadfaffa89b7() {
        return get_LogicalCallContext();
    }
    
    // Automatically generated method stub
    System::Reflection::MethodBase* ConstructionCall::get_MethodBase_be82dccd2d92b9f6() {
        return get_MethodBase();
    }
    
    // Automatically generated method stub
    System::String* ConstructionCall::get_MethodName_f32f67fc5b4be3b1() {
        return get_MethodName();
    }
    
    // Automatically generated method stub
    System::Object* ConstructionCall::get_MethodSignature_a58bc01e7b3e43ec() {
        return get_MethodSignature();
    }
    
    // Automatically generated method stub
    System::String* ConstructionCall::get_TypeName_2c092df7327c2af5() {
        return get_TypeName();
    }
    
    // Automatically generated method stub
    System::String* ConstructionCall::get_Uri_a772cc17d83f8740() {
        return get_Uri();
    }
    
}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Messaging {
    // Automatically generated method stub
    System::Collections::IDictionary* ConstructionResponse::get_Properties_d88088440249f163() {
        return get_Properties_42e9af5b3d4ade59();
    }
    
    // Automatically generated method stub
    System::Object* ConstructionResponse::GetOutArg_abbed15c9b7ee2b5(int32_t argNum) {
        return GetOutArg(argNum);
    }
    
    // Automatically generated method stub
    System::String* ConstructionResponse::GetOutArgName_e9e9f1a7b6d2a002(int32_t index) {
        return GetOutArgName(index);
    }
    
    // Automatically generated method stub
    System::Exception* ConstructionResponse::get_Exception_f355b7f547514947() {
        return get_Exception();
    }
    
    // Automatically generated method stub
    int32_t ConstructionResponse::get_OutArgCount_9615a7b9f4b303a6() {
        return get_OutArgCount();
    }
    
    // Automatically generated method stub
    cli::array<System::Object*>* ConstructionResponse::get_OutArgs_4ed1102750ba8a44() {
        return get_OutArgs();
    }
    
    // Automatically generated method stub
    System::Object* ConstructionResponse::get_ReturnValue_5e8804a33ce4fa71() {
        return get_ReturnValue();
    }
    
    // Automatically generated method stub
    System::Object* ConstructionResponse::GetArg_b08c2cf8a17399d(int32_t argNum) {
        return GetArg(argNum);
    }
    
    // Automatically generated method stub
    System::String* ConstructionResponse::GetArgName_fe0b5c1914782402(int32_t index) {
        return GetArgName(index);
    }
    
    // Automatically generated method stub
    int32_t ConstructionResponse::get_ArgCount_c4a9c359c4fe1d8e() {
        return get_ArgCount();
    }
    
    // Automatically generated method stub
    cli::array<System::Object*>* ConstructionResponse::get_Args_1b1b87289e375adf() {
        return get_Args();
    }
    
    // Automatically generated method stub
    bool ConstructionResponse::get_HasVarArgs_554adf133c756bdc() {
        return get_HasVarArgs();
    }
    
    // Automatically generated method stub
    LogicalCallContext* ConstructionResponse::get_LogicalCallContext_a19aeadfaffa89b7() {
        return get_LogicalCallContext();
    }
    
    // Automatically generated method stub
    System::Reflection::MethodBase* ConstructionResponse::get_MethodBase_be82dccd2d92b9f6() {
        return get_MethodBase();
    }
    
    // Automatically generated method stub
    System::String* ConstructionResponse::get_MethodName_f32f67fc5b4be3b1() {
        return get_MethodName();
    }
    
    // Automatically generated method stub
    System::Object* ConstructionResponse::get_MethodSignature_a58bc01e7b3e43ec() {
        return get_MethodSignature();
    }
    
    // Automatically generated method stub
    System::String* ConstructionResponse::get_TypeName_2c092df7327c2af5() {
        return get_TypeName();
    }
    
    // Automatically generated method stub
    System::String* ConstructionResponse::get_Uri_a772cc17d83f8740() {
        return get_Uri();
    }
    
}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Messaging {
    // Automatically generated method stub
    IMessage* EnvoyTerminatorSink::SyncProcessMessage_d4949581639d4872(IMessage* msg) {
        return SyncProcessMessage(msg);
    }
    
    // Automatically generated method stub
    IMessageCtrl* EnvoyTerminatorSink::AsyncProcessMessage_3d553dfedc95e36f(IMessage* msg, IMessageSink* replySink) {
        return AsyncProcessMessage(msg, replySink);
    }
    
    // Automatically generated method stub
    IMessageSink* EnvoyTerminatorSink::get_NextSink_e70f5bac1f0d1245() {
        return get_NextSink();
    }
    
}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Messaging {
    // Automatically generated method stub
    System::Object* ErrorMessage::GetArg_b08c2cf8a17399d(int32_t arg_num) {
        return GetArg(arg_num);
    }
    
    // Automatically generated method stub
    System::String* ErrorMessage::GetArgName_fe0b5c1914782402(int32_t arg_num) {
        return GetArgName(arg_num);
    }
    
    // Automatically generated method stub
    System::String* ErrorMessage::GetInArgName_602a2e2cf6d07514(int32_t index) {
        return GetInArgName(index);
    }
    
    // Automatically generated method stub
    System::Object* ErrorMessage::GetInArg_1fc884e43e06ea98(int32_t argNum) {
        return GetInArg(argNum);
    }
    
    // Automatically generated method stub
    int32_t ErrorMessage::get_ArgCount_c4a9c359c4fe1d8e() {
        return get_ArgCount();
    }
    
    // Automatically generated method stub
    cli::array<System::Object*>* ErrorMessage::get_Args_1b1b87289e375adf() {
        return get_Args();
    }
    
    // Automatically generated method stub
    bool ErrorMessage::get_HasVarArgs_554adf133c756bdc() {
        return get_HasVarArgs();
    }
    
    // Automatically generated method stub
    System::Reflection::MethodBase* ErrorMessage::get_MethodBase_be82dccd2d92b9f6() {
        return get_MethodBase();
    }
    
    // Automatically generated method stub
    System::String* ErrorMessage::get_MethodName_f32f67fc5b4be3b1() {
        return get_MethodName();
    }
    
    // Automatically generated method stub
    System::Object* ErrorMessage::get_MethodSignature_a58bc01e7b3e43ec() {
        return get_MethodSignature();
    }
    
    // Automatically generated method stub
    System::Collections::IDictionary* ErrorMessage::get_Properties_d88088440249f163() {
        return get_Properties_e96fc16c3b175f50();
    }
    
    // Automatically generated method stub
    System::String* ErrorMessage::get_TypeName_2c092df7327c2af5() {
        return get_TypeName();
    }
    
    // Automatically generated method stub
    System::String* ErrorMessage::get_Uri_a772cc17d83f8740() {
        return get_Uri();
    }
    
    // Automatically generated method stub
    int32_t ErrorMessage::get_InArgCount_cb2e74281a598234() {
        return get_InArgCount();
    }
    
    // Automatically generated method stub
    cli::array<System::Object*>* ErrorMessage::get_InArgs_f63ad3f1c81c6020() {
        return get_InArgs();
    }
    
    // Automatically generated method stub
    LogicalCallContext* ErrorMessage::get_LogicalCallContext_a19aeadfaffa89b7() {
        return get_LogicalCallContext();
    }
    
}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Messaging {
    // Automatically generated method stub
    void LogicalCallContext::GetObjectData_11b895a112e04409(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        return GetObjectData(info, context);
    }
    
    // Automatically generated method stub
    System::Object* LogicalCallContext::Clone_d5efb96d327809c8() {
        return Clone();
    }
    
}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Messaging {
    // Automatically generated method stub
    System::Object* CallContextRemotingData::Clone_d5efb96d327809c8() {
        return Clone();
    }
    
}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Messaging {
    // Automatically generated method stub
    void MethodCall::GetObjectData_11b895a112e04409(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        return GetObjectData_972cb159043c8ab0(info, context);
    }
    
    // Automatically generated method stub
    System::Object* MethodCall::GetArg_b08c2cf8a17399d(int32_t argNum) {
        return GetArg(argNum);
    }
    
    // Automatically generated method stub
    System::String* MethodCall::GetArgName_fe0b5c1914782402(int32_t index) {
        return GetArgName(index);
    }
    
    // Automatically generated method stub
    System::Object* MethodCall::GetInArg_1fc884e43e06ea98(int32_t argNum) {
        return GetInArg(argNum);
    }
    
    // Automatically generated method stub
    System::String* MethodCall::GetInArgName_602a2e2cf6d07514(int32_t index) {
        return GetInArgName(index);
    }
    
    // Automatically generated method stub
    void MethodCall::RootSetObjectData_9389585d3660e24c(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext ctx) {
        return RootSetObjectData(info, ctx);
    }
    
    // Automatically generated method stub
    int32_t MethodCall::get_ArgCount_c4a9c359c4fe1d8e() {
        return get_ArgCount();
    }
    
    // Automatically generated method stub
    cli::array<System::Object*>* MethodCall::get_Args_1b1b87289e375adf() {
        return get_Args();
    }
    
    // Automatically generated method stub
    bool MethodCall::get_HasVarArgs_554adf133c756bdc() {
        return get_HasVarArgs();
    }
    
    // Automatically generated method stub
    int32_t MethodCall::get_InArgCount_cb2e74281a598234() {
        return get_InArgCount();
    }
    
    // Automatically generated method stub
    cli::array<System::Object*>* MethodCall::get_InArgs_f63ad3f1c81c6020() {
        return get_InArgs();
    }
    
    // Automatically generated method stub
    LogicalCallContext* MethodCall::get_LogicalCallContext_a19aeadfaffa89b7() {
        return get_LogicalCallContext();
    }
    
    // Automatically generated method stub
    System::Reflection::MethodBase* MethodCall::get_MethodBase_be82dccd2d92b9f6() {
        return get_MethodBase();
    }
    
    // Automatically generated method stub
    System::String* MethodCall::get_MethodName_f32f67fc5b4be3b1() {
        return get_MethodName();
    }
    
    // Automatically generated method stub
    System::Object* MethodCall::get_MethodSignature_a58bc01e7b3e43ec() {
        return get_MethodSignature();
    }
    
    // Automatically generated method stub
    System::Collections::IDictionary* MethodCall::get_Properties_d88088440249f163() {
        return get_Properties_c453f36b3f043bdc();
    }
    
    // Automatically generated method stub
    System::String* MethodCall::get_TypeName_2c092df7327c2af5() {
        return get_TypeName();
    }
    
    // Automatically generated method stub
    System::String* MethodCall::get_Uri_a772cc17d83f8740() {
        return get_Uri();
    }
    
    // Automatically generated method stub
    System::String* MethodCall::get_Uri_39a650ec2a69ead0() {
        return get_Uri2();
    }
    
    // Automatically generated method stub
    System::String* MethodCall::set_Uri_96dc10f55685ba70(System::String* value) {
        return set_Uri2(value);
    }
    
    // Automatically generated method stub
    System::Runtime::Remoting::Identity* MethodCall::get_TargetIdentity_462ebd8041156d75() {
        return get_TargetIdentity();
    }
    
    // Automatically generated method stub
    System::Runtime::Remoting::Identity* MethodCall::set_TargetIdentity_8fbc4984471e7e77(System::Runtime::Remoting::Identity* value) {
        return set_TargetIdentity(value);
    }
    
}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Messaging {
    // Automatically generated method stub
    System::Object* MethodCallMessageWrapper::GetArg_b08c2cf8a17399d(int32_t argNum) {
        return GetArg_1f9d01a7e6a18550(argNum);
    }
    
    // Automatically generated method stub
    System::String* MethodCallMessageWrapper::GetArgName_fe0b5c1914782402(int32_t index) {
        return GetArgName_bc718af36a33c0c1(index);
    }
    
    // Automatically generated method stub
    System::Object* MethodCallMessageWrapper::GetInArg_1fc884e43e06ea98(int32_t argNum) {
        return GetInArg_5630004eabcafb5b(argNum);
    }
    
    // Automatically generated method stub
    System::String* MethodCallMessageWrapper::GetInArgName_602a2e2cf6d07514(int32_t index) {
        return GetInArgName_c4a055b5e097804f(index);
    }
    
    // Automatically generated method stub
    int32_t MethodCallMessageWrapper::get_ArgCount_c4a9c359c4fe1d8e() {
        return get_ArgCount_bdf2e5e89f94e4c();
    }
    
    // Automatically generated method stub
    cli::array<System::Object*>* MethodCallMessageWrapper::get_Args_1b1b87289e375adf() {
        return get_Args_2ff00dd9adf0aac();
    }
    
    // Automatically generated method stub
    bool MethodCallMessageWrapper::get_HasVarArgs_554adf133c756bdc() {
        return get_HasVarArgs_d495f2ebd8875cd6();
    }
    
    // Automatically generated method stub
    int32_t MethodCallMessageWrapper::get_InArgCount_cb2e74281a598234() {
        return get_InArgCount_e2a9ce7753c03b43();
    }
    
    // Automatically generated method stub
    cli::array<System::Object*>* MethodCallMessageWrapper::get_InArgs_f63ad3f1c81c6020() {
        return get_InArgs_5f027e6743eedd22();
    }
    
    // Automatically generated method stub
    LogicalCallContext* MethodCallMessageWrapper::get_LogicalCallContext_a19aeadfaffa89b7() {
        return get_LogicalCallContext_9cf8fb9aa5344653();
    }
    
    // Automatically generated method stub
    System::Reflection::MethodBase* MethodCallMessageWrapper::get_MethodBase_be82dccd2d92b9f6() {
        return get_MethodBase_53947153fd1c478();
    }
    
    // Automatically generated method stub
    System::String* MethodCallMessageWrapper::get_MethodName_f32f67fc5b4be3b1() {
        return get_MethodName_afa3ecbf1d1fd47e();
    }
    
    // Automatically generated method stub
    System::Object* MethodCallMessageWrapper::get_MethodSignature_a58bc01e7b3e43ec() {
        return get_MethodSignature_eb88f90a35806f25();
    }
    
    // Automatically generated method stub
    System::Collections::IDictionary* MethodCallMessageWrapper::get_Properties_d88088440249f163() {
        return get_Properties_238987309ecc3b13();
    }
    
    // Automatically generated method stub
    System::String* MethodCallMessageWrapper::get_TypeName_2c092df7327c2af5() {
        return get_TypeName_f0575dd68a53967();
    }
    
    // Automatically generated method stub
    System::String* MethodCallMessageWrapper::get_Uri_a772cc17d83f8740() {
        return get_Uri_5eaefe698d6d5cd6();
    }
    
}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Messaging {
    // Automatically generated method stub
    bool DictionaryEnumerator::MoveNext_4e78e145935f5417() {
        return MoveNext();
    }
    
    // Automatically generated method stub
    void DictionaryEnumerator::Reset_bcd82381eed41868() {
        return Reset();
    }
    
    // Automatically generated method stub
    System::Object* DictionaryEnumerator::get_Current_8eca9b3da02b123a() {
        return get_Current();
    }
    
    // Automatically generated method stub
    System::Collections::DictionaryEntry DictionaryEnumerator::get_Entry_7d036eca1ef8d5f4() {
        return get_Entry();
    }
    
    // Automatically generated method stub
    System::Object* DictionaryEnumerator::get_Key_ed7954531cb20258() {
        return get_Key();
    }
    
    // Automatically generated method stub
    System::Object* DictionaryEnumerator::get_Value_889e0f410f0d67ef() {
        return get_Value();
    }
    
}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Messaging {
    // Automatically generated method stub
    void MethodDictionary::Add_642542cf7a4cae38(System::Object* key, System::Object* value) {
        return Add(key, value);
    }
    
    // Automatically generated method stub
    void MethodDictionary::Clear_23091c63869f817f() {
        return Clear();
    }
    
    // Automatically generated method stub
    bool MethodDictionary::Contains_32eba6643fe7ee4b(System::Object* key) {
        return Contains(key);
    }
    
    // Automatically generated method stub
    void MethodDictionary::Remove_f212b96e00d6aaed(System::Object* key) {
        return Remove(key);
    }
    
    // Automatically generated method stub
    void MethodDictionary::CopyTo_7065a6e3cf6a140(System::Array* array, int32_t index) {
        return CopyTo(array, index);
    }
    
    // Automatically generated method stub
    System::Collections::IEnumerator* MethodDictionary::GetEnumerator_674ad93a972a4d67() {
        return GetEnumerator();
    }
    
    // Automatically generated method stub
    System::Collections::IDictionaryEnumerator* MethodDictionary::GetEnumerator_40657fcb15842551() {
        return GetEnumerator2();
    }
    
    // Automatically generated method stub
    bool MethodDictionary::get_IsFixedSize_9b77ca904d42a211() {
        return get_IsFixedSize();
    }
    
    // Automatically generated method stub
    bool MethodDictionary::get_IsReadOnly_faaa94fe854aaa5f() {
        return get_IsReadOnly();
    }
    
    // Automatically generated method stub
    System::Object* MethodDictionary::get_Item_95688dd349c069c0(System::Object* key) {
        return get_Item(key);
    }
    
    // Automatically generated method stub
    System::Object* MethodDictionary::set_Item_a0c4aaef01cc13c2(System::Object* key, System::Object* value) {
        return set_Item(key, value);
    }
    
    // Automatically generated method stub
    System::Collections::ICollection* MethodDictionary::get_Keys_d809cadac60b140a() {
        return get_Keys();
    }
    
    // Automatically generated method stub
    System::Collections::ICollection* MethodDictionary::get_Values_ef6ae5cda2bdcf40() {
        return get_Values();
    }
    
    // Automatically generated method stub
    int32_t MethodDictionary::get_Count_8f254f3dd8e2403() {
        return get_Count();
    }
    
    // Automatically generated method stub
    bool MethodDictionary::get_IsSynchronized_20926e7dabc53dbf() {
        return get_IsSynchronized();
    }
    
    // Automatically generated method stub
    System::Object* MethodDictionary::get_SyncRoot_257108f45cc89e19() {
        return get_SyncRoot();
    }
    
}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Messaging {
    // Automatically generated method stub
    System::Object* MethodResponse::GetArg_b08c2cf8a17399d(int32_t argNum) {
        return GetArg(argNum);
    }
    
    // Automatically generated method stub
    System::String* MethodResponse::GetArgName_fe0b5c1914782402(int32_t index) {
        return GetArgName(index);
    }
    
    // Automatically generated method stub
    void MethodResponse::GetObjectData_11b895a112e04409(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        return GetObjectData_1ee8033ec9301158(info, context);
    }
    
    // Automatically generated method stub
    System::Object* MethodResponse::GetOutArg_abbed15c9b7ee2b5(int32_t argNum) {
        return GetOutArg(argNum);
    }
    
    // Automatically generated method stub
    System::String* MethodResponse::GetOutArgName_e9e9f1a7b6d2a002(int32_t index) {
        return GetOutArgName(index);
    }
    
    // Automatically generated method stub
    void MethodResponse::RootSetObjectData_9389585d3660e24c(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext ctx) {
        return RootSetObjectData(info, ctx);
    }
    
    // Automatically generated method stub
    int32_t MethodResponse::get_ArgCount_c4a9c359c4fe1d8e() {
        return get_ArgCount();
    }
    
    // Automatically generated method stub
    cli::array<System::Object*>* MethodResponse::get_Args_1b1b87289e375adf() {
        return get_Args();
    }
    
    // Automatically generated method stub
    System::Exception* MethodResponse::get_Exception_f355b7f547514947() {
        return get_Exception();
    }
    
    // Automatically generated method stub
    bool MethodResponse::get_HasVarArgs_554adf133c756bdc() {
        return get_HasVarArgs();
    }
    
    // Automatically generated method stub
    LogicalCallContext* MethodResponse::get_LogicalCallContext_a19aeadfaffa89b7() {
        return get_LogicalCallContext();
    }
    
    // Automatically generated method stub
    System::Reflection::MethodBase* MethodResponse::get_MethodBase_be82dccd2d92b9f6() {
        return get_MethodBase();
    }
    
    // Automatically generated method stub
    System::String* MethodResponse::get_MethodName_f32f67fc5b4be3b1() {
        return get_MethodName();
    }
    
    // Automatically generated method stub
    System::Object* MethodResponse::get_MethodSignature_a58bc01e7b3e43ec() {
        return get_MethodSignature();
    }
    
    // Automatically generated method stub
    int32_t MethodResponse::get_OutArgCount_9615a7b9f4b303a6() {
        return get_OutArgCount();
    }
    
    // Automatically generated method stub
    cli::array<System::Object*>* MethodResponse::get_OutArgs_4ed1102750ba8a44() {
        return get_OutArgs();
    }
    
    // Automatically generated method stub
    System::Collections::IDictionary* MethodResponse::get_Properties_d88088440249f163() {
        return get_Properties_42e9af5b3d4ade59();
    }
    
    // Automatically generated method stub
    System::Object* MethodResponse::get_ReturnValue_5e8804a33ce4fa71() {
        return get_ReturnValue();
    }
    
    // Automatically generated method stub
    System::String* MethodResponse::get_TypeName_2c092df7327c2af5() {
        return get_TypeName();
    }
    
    // Automatically generated method stub
    System::String* MethodResponse::get_Uri_a772cc17d83f8740() {
        return get_Uri();
    }
    
    // Automatically generated method stub
    System::String* MethodResponse::get_Uri_39a650ec2a69ead0() {
        return get_Uri2();
    }
    
    // Automatically generated method stub
    System::String* MethodResponse::set_Uri_96dc10f55685ba70(System::String* value) {
        return set_Uri2(value);
    }
    
    // Automatically generated method stub
    System::Runtime::Remoting::Identity* MethodResponse::get_TargetIdentity_462ebd8041156d75() {
        return get_TargetIdentity();
    }
    
    // Automatically generated method stub
    System::Runtime::Remoting::Identity* MethodResponse::set_TargetIdentity_8fbc4984471e7e77(System::Runtime::Remoting::Identity* value) {
        return set_TargetIdentity(value);
    }
    
}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Messaging {
    // Automatically generated method stub
    System::Object* MethodReturnMessageWrapper::GetArg_b08c2cf8a17399d(int32_t argNum) {
        return GetArg_99407870c0a11bde(argNum);
    }
    
    // Automatically generated method stub
    System::String* MethodReturnMessageWrapper::GetArgName_fe0b5c1914782402(int32_t index) {
        return GetArgName_e73597c4d5d9642b(index);
    }
    
    // Automatically generated method stub
    System::Object* MethodReturnMessageWrapper::GetOutArg_abbed15c9b7ee2b5(int32_t argNum) {
        return GetOutArg_574514e67d145e3b(argNum);
    }
    
    // Automatically generated method stub
    System::String* MethodReturnMessageWrapper::GetOutArgName_e9e9f1a7b6d2a002(int32_t index) {
        return GetOutArgName_d257e979435a25c2(index);
    }
    
    // Automatically generated method stub
    int32_t MethodReturnMessageWrapper::get_ArgCount_c4a9c359c4fe1d8e() {
        return get_ArgCount_a9845951d951911d();
    }
    
    // Automatically generated method stub
    cli::array<System::Object*>* MethodReturnMessageWrapper::get_Args_1b1b87289e375adf() {
        return get_Args_32591b6b0d32b695();
    }
    
    // Automatically generated method stub
    System::Exception* MethodReturnMessageWrapper::get_Exception_f355b7f547514947() {
        return get_Exception_532b585a2ea6623e();
    }
    
    // Automatically generated method stub
    bool MethodReturnMessageWrapper::get_HasVarArgs_554adf133c756bdc() {
        return get_HasVarArgs_b72c87182c49e83d();
    }
    
    // Automatically generated method stub
    LogicalCallContext* MethodReturnMessageWrapper::get_LogicalCallContext_a19aeadfaffa89b7() {
        return get_LogicalCallContext_ea80d780b51c3cd9();
    }
    
    // Automatically generated method stub
    System::Reflection::MethodBase* MethodReturnMessageWrapper::get_MethodBase_be82dccd2d92b9f6() {
        return get_MethodBase_61a9a4b8069a5514();
    }
    
    // Automatically generated method stub
    System::String* MethodReturnMessageWrapper::get_MethodName_f32f67fc5b4be3b1() {
        return get_MethodName_f2186ba17c86255e();
    }
    
    // Automatically generated method stub
    System::Object* MethodReturnMessageWrapper::get_MethodSignature_a58bc01e7b3e43ec() {
        return get_MethodSignature_5c18eb338cb7d4b0();
    }
    
    // Automatically generated method stub
    int32_t MethodReturnMessageWrapper::get_OutArgCount_9615a7b9f4b303a6() {
        return get_OutArgCount_e027a0d935f171bf();
    }
    
    // Automatically generated method stub
    cli::array<System::Object*>* MethodReturnMessageWrapper::get_OutArgs_4ed1102750ba8a44() {
        return get_OutArgs_fa7599485c150173();
    }
    
    // Automatically generated method stub
    System::Collections::IDictionary* MethodReturnMessageWrapper::get_Properties_d88088440249f163() {
        return get_Properties_892057f5a1f5b6d4();
    }
    
    // Automatically generated method stub
    System::Object* MethodReturnMessageWrapper::get_ReturnValue_5e8804a33ce4fa71() {
        return get_ReturnValue_90df0be5d7725988();
    }
    
    // Automatically generated method stub
    System::String* MethodReturnMessageWrapper::get_TypeName_2c092df7327c2af5() {
        return get_TypeName_f3750a15f7d822c3();
    }
    
    // Automatically generated method stub
    System::String* MethodReturnMessageWrapper::get_Uri_a772cc17d83f8740() {
        return get_Uri();
    }
    
}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Messaging {
    // Automatically generated method stub
    System::Object* MonoMethodMessage::GetArg_b08c2cf8a17399d(int32_t arg_num) {
        return GetArg(arg_num);
    }
    
    // Automatically generated method stub
    System::String* MonoMethodMessage::GetArgName_fe0b5c1914782402(int32_t arg_num) {
        return GetArgName(arg_num);
    }
    
    // Automatically generated method stub
    System::Object* MonoMethodMessage::GetInArg_1fc884e43e06ea98(int32_t arg_num) {
        return GetInArg(arg_num);
    }
    
    // Automatically generated method stub
    System::String* MonoMethodMessage::GetInArgName_602a2e2cf6d07514(int32_t arg_num) {
        return GetInArgName(arg_num);
    }
    
    // Automatically generated method stub
    System::Object* MonoMethodMessage::GetOutArg_abbed15c9b7ee2b5(int32_t arg_num) {
        return GetOutArg(arg_num);
    }
    
    // Automatically generated method stub
    System::String* MonoMethodMessage::GetOutArgName_e9e9f1a7b6d2a002(int32_t arg_num) {
        return GetOutArgName(arg_num);
    }
    
    // Automatically generated method stub
    System::Collections::IDictionary* MonoMethodMessage::get_Properties_d88088440249f163() {
        return get_Properties();
    }
    
    // Automatically generated method stub
    int32_t MonoMethodMessage::get_ArgCount_c4a9c359c4fe1d8e() {
        return get_ArgCount();
    }
    
    // Automatically generated method stub
    cli::array<System::Object*>* MonoMethodMessage::get_Args_1b1b87289e375adf() {
        return get_Args();
    }
    
    // Automatically generated method stub
    bool MonoMethodMessage::get_HasVarArgs_554adf133c756bdc() {
        return get_HasVarArgs();
    }
    
    // Automatically generated method stub
    LogicalCallContext* MonoMethodMessage::get_LogicalCallContext_a19aeadfaffa89b7() {
        return get_LogicalCallContext();
    }
    
    // Automatically generated method stub
    System::Reflection::MethodBase* MonoMethodMessage::get_MethodBase_be82dccd2d92b9f6() {
        return get_MethodBase();
    }
    
    // Automatically generated method stub
    System::String* MonoMethodMessage::get_MethodName_f32f67fc5b4be3b1() {
        return get_MethodName();
    }
    
    // Automatically generated method stub
    System::Object* MonoMethodMessage::get_MethodSignature_a58bc01e7b3e43ec() {
        return get_MethodSignature();
    }
    
    // Automatically generated method stub
    System::String* MonoMethodMessage::get_TypeName_2c092df7327c2af5() {
        return get_TypeName();
    }
    
    // Automatically generated method stub
    System::String* MonoMethodMessage::get_Uri_a772cc17d83f8740() {
        return get_Uri();
    }
    
    // Automatically generated method stub
    System::String* MonoMethodMessage::get_Uri_39a650ec2a69ead0() {
        return get_Uri();
    }
    
    // Automatically generated method stub
    System::String* MonoMethodMessage::set_Uri_96dc10f55685ba70(System::String* value) {
        return set_Uri(value);
    }
    
    // Automatically generated method stub
    int32_t MonoMethodMessage::get_InArgCount_cb2e74281a598234() {
        return get_InArgCount();
    }
    
    // Automatically generated method stub
    cli::array<System::Object*>* MonoMethodMessage::get_InArgs_f63ad3f1c81c6020() {
        return get_InArgs();
    }
    
    // Automatically generated method stub
    System::Exception* MonoMethodMessage::get_Exception_f355b7f547514947() {
        return get_Exception();
    }
    
    // Automatically generated method stub
    int32_t MonoMethodMessage::get_OutArgCount_9615a7b9f4b303a6() {
        return get_OutArgCount();
    }
    
    // Automatically generated method stub
    cli::array<System::Object*>* MonoMethodMessage::get_OutArgs_4ed1102750ba8a44() {
        return get_OutArgs();
    }
    
    // Automatically generated method stub
    System::Object* MonoMethodMessage::get_ReturnValue_5e8804a33ce4fa71() {
        return get_ReturnValue();
    }
    
    // Automatically generated method stub
    System::Runtime::Remoting::Identity* MonoMethodMessage::get_TargetIdentity_462ebd8041156d75() {
        return get_TargetIdentity();
    }
    
    // Automatically generated method stub
    System::Runtime::Remoting::Identity* MonoMethodMessage::set_TargetIdentity_8fbc4984471e7e77(System::Runtime::Remoting::Identity* value) {
        return set_TargetIdentity(value);
    }
    
}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Messaging {
    // Automatically generated method stub
    void RemotingSurrogate::GetObjectData_fb9d539912329654(System::Object* obj, System::Runtime::Serialization::SerializationInfo* si, System::Runtime::Serialization::StreamingContext sc) {
        return GetObjectData_ea2423204af32b20(obj, si, sc);
    }
    
    // Automatically generated method stub
    System::Object* RemotingSurrogate::SetObjectData_3af7d8e77dbcc1d2(System::Object* obj, System::Runtime::Serialization::SerializationInfo* si, System::Runtime::Serialization::StreamingContext sc, System::Runtime::Serialization::ISurrogateSelector* selector) {
        return SetObjectData_e0569319b2d26b8b(obj, si, sc, selector);
    }
    
}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Messaging {
    // Automatically generated method stub
    void ObjRefSurrogate::GetObjectData_fb9d539912329654(System::Object* obj, System::Runtime::Serialization::SerializationInfo* si, System::Runtime::Serialization::StreamingContext sc) {
        return GetObjectData_df250ced87a9c363(obj, si, sc);
    }
    
    // Automatically generated method stub
    System::Object* ObjRefSurrogate::SetObjectData_3af7d8e77dbcc1d2(System::Object* obj, System::Runtime::Serialization::SerializationInfo* si, System::Runtime::Serialization::StreamingContext sc, System::Runtime::Serialization::ISurrogateSelector* selector) {
        return SetObjectData_bce92449b9ba77d2(obj, si, sc, selector);
    }
    
}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Messaging {
    // Automatically generated method stub
    void RemotingSurrogateSelector::ChainSelector_b4bf6e9847cd4bb0(System::Runtime::Serialization::ISurrogateSelector* selector) {
        return ChainSelector_31362a36d95c626c(selector);
    }
    
    // Automatically generated method stub
    System::Runtime::Serialization::ISurrogateSelector* RemotingSurrogateSelector::GetNextSelector_f0732f882be06ccb() {
        return GetNextSelector_857a1e27cf1e9a83();
    }
    
    // Automatically generated method stub
    System::Runtime::Serialization::ISerializationSurrogate* RemotingSurrogateSelector::GetSurrogate_9d3ffd4061f81ca8(System::Type* type, System::Runtime::Serialization::StreamingContext context, System::Runtime::Serialization::ISurrogateSelector* ssout) {
        return GetSurrogate_43b010380df30464(type, context, ssout);
    }
    
}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Messaging {
    // Automatically generated method stub
    System::Object* ReturnMessage::GetArg_b08c2cf8a17399d(int32_t argNum) {
        return GetArg(argNum);
    }
    
    // Automatically generated method stub
    System::String* ReturnMessage::GetArgName_fe0b5c1914782402(int32_t index) {
        return GetArgName(index);
    }
    
    // Automatically generated method stub
    System::Object* ReturnMessage::GetOutArg_abbed15c9b7ee2b5(int32_t argNum) {
        return GetOutArg(argNum);
    }
    
    // Automatically generated method stub
    System::String* ReturnMessage::GetOutArgName_e9e9f1a7b6d2a002(int32_t index) {
        return GetOutArgName(index);
    }
    
    // Automatically generated method stub
    int32_t ReturnMessage::get_ArgCount_c4a9c359c4fe1d8e() {
        return get_ArgCount();
    }
    
    // Automatically generated method stub
    cli::array<System::Object*>* ReturnMessage::get_Args_1b1b87289e375adf() {
        return get_Args();
    }
    
    // Automatically generated method stub
    bool ReturnMessage::get_HasVarArgs_554adf133c756bdc() {
        return get_HasVarArgs();
    }
    
    // Automatically generated method stub
    LogicalCallContext* ReturnMessage::get_LogicalCallContext_a19aeadfaffa89b7() {
        return get_LogicalCallContext();
    }
    
    // Automatically generated method stub
    System::Reflection::MethodBase* ReturnMessage::get_MethodBase_be82dccd2d92b9f6() {
        return get_MethodBase();
    }
    
    // Automatically generated method stub
    System::String* ReturnMessage::get_MethodName_f32f67fc5b4be3b1() {
        return get_MethodName();
    }
    
    // Automatically generated method stub
    System::Object* ReturnMessage::get_MethodSignature_a58bc01e7b3e43ec() {
        return get_MethodSignature();
    }
    
    // Automatically generated method stub
    System::Collections::IDictionary* ReturnMessage::get_Properties_d88088440249f163() {
        return get_Properties_74f84dd6944b322b();
    }
    
    // Automatically generated method stub
    System::String* ReturnMessage::get_TypeName_2c092df7327c2af5() {
        return get_TypeName();
    }
    
    // Automatically generated method stub
    System::String* ReturnMessage::get_Uri_a772cc17d83f8740() {
        return get_Uri();
    }
    
    // Automatically generated method stub
    System::String* ReturnMessage::get_Uri_39a650ec2a69ead0() {
        return get_Uri2();
    }
    
    // Automatically generated method stub
    System::String* ReturnMessage::set_Uri_96dc10f55685ba70(System::String* value) {
        return set_Uri2(value);
    }
    
    // Automatically generated method stub
    System::Exception* ReturnMessage::get_Exception_f355b7f547514947() {
        return get_Exception();
    }
    
    // Automatically generated method stub
    int32_t ReturnMessage::get_OutArgCount_9615a7b9f4b303a6() {
        return get_OutArgCount();
    }
    
    // Automatically generated method stub
    cli::array<System::Object*>* ReturnMessage::get_OutArgs_4ed1102750ba8a44() {
        return get_OutArgs();
    }
    
    // Automatically generated method stub
    System::Object* ReturnMessage::get_ReturnValue_5e8804a33ce4fa71() {
        return get_ReturnValue_248109c7ac83a397();
    }
    
    // Automatically generated method stub
    System::Runtime::Remoting::Identity* ReturnMessage::get_TargetIdentity_462ebd8041156d75() {
        return get_TargetIdentity();
    }
    
    // Automatically generated method stub
    System::Runtime::Remoting::Identity* ReturnMessage::set_TargetIdentity_8fbc4984471e7e77(System::Runtime::Remoting::Identity* value) {
        return set_TargetIdentity(value);
    }
    
}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Messaging {
    // Automatically generated method stub
    IMessage* ServerContextTerminatorSink::SyncProcessMessage_d4949581639d4872(IMessage* msg) {
        return SyncProcessMessage(msg);
    }
    
    // Automatically generated method stub
    IMessageCtrl* ServerContextTerminatorSink::AsyncProcessMessage_3d553dfedc95e36f(IMessage* msg, IMessageSink* replySink) {
        return AsyncProcessMessage(msg, replySink);
    }
    
    // Automatically generated method stub
    IMessageSink* ServerContextTerminatorSink::get_NextSink_e70f5bac1f0d1245() {
        return get_NextSink();
    }
    
}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Messaging {
    // Automatically generated method stub
    IMessage* ServerObjectTerminatorSink::SyncProcessMessage_d4949581639d4872(IMessage* msg) {
        return SyncProcessMessage(msg);
    }
    
    // Automatically generated method stub
    IMessageCtrl* ServerObjectTerminatorSink::AsyncProcessMessage_3d553dfedc95e36f(IMessage* msg, IMessageSink* replySink) {
        return AsyncProcessMessage(msg, replySink);
    }
    
    // Automatically generated method stub
    IMessageSink* ServerObjectTerminatorSink::get_NextSink_e70f5bac1f0d1245() {
        return get_NextSink();
    }
    
}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Messaging {
    // Automatically generated method stub
    IMessage* ServerObjectReplySink::SyncProcessMessage_d4949581639d4872(IMessage* msg) {
        return SyncProcessMessage(msg);
    }
    
    // Automatically generated method stub
    IMessageCtrl* ServerObjectReplySink::AsyncProcessMessage_3d553dfedc95e36f(IMessage* msg, IMessageSink* replySink) {
        return AsyncProcessMessage(msg, replySink);
    }
    
    // Automatically generated method stub
    IMessageSink* ServerObjectReplySink::get_NextSink_e70f5bac1f0d1245() {
        return get_NextSink();
    }
    
}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Messaging {
    // Automatically generated method stub
    IMessage* StackBuilderSink::SyncProcessMessage_d4949581639d4872(IMessage* msg) {
        return SyncProcessMessage(msg);
    }
    
    // Automatically generated method stub
    IMessageCtrl* StackBuilderSink::AsyncProcessMessage_3d553dfedc95e36f(IMessage* msg, IMessageSink* replySink) {
        return AsyncProcessMessage(msg, replySink);
    }
    
    // Automatically generated method stub
    IMessageSink* StackBuilderSink::get_NextSink_e70f5bac1f0d1245() {
        return get_NextSink();
    }
    
}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Metadata { namespace W3cXsd2001 {
    // Automatically generated method stub
    System::String* SoapAnyUri::GetXsdType_206f3057f651893() {
        return GetXsdType();
    }
    
}}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Metadata { namespace W3cXsd2001 {
    // Automatically generated method stub
    System::String* SoapBase64Binary::GetXsdType_206f3057f651893() {
        return GetXsdType();
    }
    
}}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Metadata { namespace W3cXsd2001 {
    // Automatically generated method stub
    System::String* SoapDate::GetXsdType_206f3057f651893() {
        return GetXsdType();
    }
    
}}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Metadata { namespace W3cXsd2001 {
    // Automatically generated method stub
    System::String* SoapDay::GetXsdType_206f3057f651893() {
        return GetXsdType();
    }
    
}}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Metadata { namespace W3cXsd2001 {
    // Automatically generated method stub
    System::String* SoapEntities::GetXsdType_206f3057f651893() {
        return GetXsdType();
    }
    
}}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Metadata { namespace W3cXsd2001 {
    // Automatically generated method stub
    System::String* SoapEntity::GetXsdType_206f3057f651893() {
        return GetXsdType();
    }
    
}}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Metadata { namespace W3cXsd2001 {
    // Automatically generated method stub
    System::String* SoapHexBinary::GetXsdType_206f3057f651893() {
        return GetXsdType();
    }
    
}}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Metadata { namespace W3cXsd2001 {
    // Automatically generated method stub
    System::String* SoapId::GetXsdType_206f3057f651893() {
        return GetXsdType();
    }
    
}}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Metadata { namespace W3cXsd2001 {
    // Automatically generated method stub
    System::String* SoapIdref::GetXsdType_206f3057f651893() {
        return GetXsdType();
    }
    
}}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Metadata { namespace W3cXsd2001 {
    // Automatically generated method stub
    System::String* SoapIdrefs::GetXsdType_206f3057f651893() {
        return GetXsdType();
    }
    
}}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Metadata { namespace W3cXsd2001 {
    // Automatically generated method stub
    System::String* SoapInteger::GetXsdType_206f3057f651893() {
        return GetXsdType();
    }
    
}}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Metadata { namespace W3cXsd2001 {
    // Automatically generated method stub
    System::String* SoapLanguage::GetXsdType_206f3057f651893() {
        return GetXsdType();
    }
    
}}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Metadata { namespace W3cXsd2001 {
    // Automatically generated method stub
    System::String* SoapMonth::GetXsdType_206f3057f651893() {
        return GetXsdType();
    }
    
}}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Metadata { namespace W3cXsd2001 {
    // Automatically generated method stub
    System::String* SoapMonthDay::GetXsdType_206f3057f651893() {
        return GetXsdType();
    }
    
}}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Metadata { namespace W3cXsd2001 {
    // Automatically generated method stub
    System::String* SoapName::GetXsdType_206f3057f651893() {
        return GetXsdType();
    }
    
}}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Metadata { namespace W3cXsd2001 {
    // Automatically generated method stub
    System::String* SoapNcName::GetXsdType_206f3057f651893() {
        return GetXsdType();
    }
    
}}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Metadata { namespace W3cXsd2001 {
    // Automatically generated method stub
    System::String* SoapNegativeInteger::GetXsdType_206f3057f651893() {
        return GetXsdType();
    }
    
}}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Metadata { namespace W3cXsd2001 {
    // Automatically generated method stub
    System::String* SoapNmtoken::GetXsdType_206f3057f651893() {
        return GetXsdType();
    }
    
}}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Metadata { namespace W3cXsd2001 {
    // Automatically generated method stub
    System::String* SoapNmtokens::GetXsdType_206f3057f651893() {
        return GetXsdType();
    }
    
}}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Metadata { namespace W3cXsd2001 {
    // Automatically generated method stub
    System::String* SoapNonNegativeInteger::GetXsdType_206f3057f651893() {
        return GetXsdType();
    }
    
}}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Metadata { namespace W3cXsd2001 {
    // Automatically generated method stub
    System::String* SoapNonPositiveInteger::GetXsdType_206f3057f651893() {
        return GetXsdType();
    }
    
}}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Metadata { namespace W3cXsd2001 {
    // Automatically generated method stub
    System::String* SoapNormalizedString::GetXsdType_206f3057f651893() {
        return GetXsdType();
    }
    
}}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Metadata { namespace W3cXsd2001 {
    // Automatically generated method stub
    System::String* SoapNotation::GetXsdType_206f3057f651893() {
        return GetXsdType();
    }
    
}}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Metadata { namespace W3cXsd2001 {
    // Automatically generated method stub
    System::String* SoapPositiveInteger::GetXsdType_206f3057f651893() {
        return GetXsdType();
    }
    
}}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Metadata { namespace W3cXsd2001 {
    // Automatically generated method stub
    System::String* SoapQName::GetXsdType_206f3057f651893() {
        return GetXsdType();
    }
    
}}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Metadata { namespace W3cXsd2001 {
    // Automatically generated method stub
    System::String* SoapTime::GetXsdType_206f3057f651893() {
        return GetXsdType();
    }
    
}}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Metadata { namespace W3cXsd2001 {
    // Automatically generated method stub
    System::String* SoapToken::GetXsdType_206f3057f651893() {
        return GetXsdType();
    }
    
}}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Metadata { namespace W3cXsd2001 {
    // Automatically generated method stub
    System::String* SoapYear::GetXsdType_206f3057f651893() {
        return GetXsdType();
    }
    
}}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Metadata { namespace W3cXsd2001 {
    // Automatically generated method stub
    System::String* SoapYearMonth::GetXsdType_206f3057f651893() {
        return GetXsdType();
    }
    
}}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Proxies {
    // Automatically generated method stub
    void ProxyAttribute::GetPropertiesForNewContext_98ae344cb00933c3(System::Runtime::Remoting::Activation::IConstructionCallMessage* msg) {
        return GetPropertiesForNewContext(msg);
    }
    
    // Automatically generated method stub
    bool ProxyAttribute::IsContextOK_c0cd4400710cc315(System::Runtime::Remoting::Contexts::Context2* ctx, System::Runtime::Remoting::Activation::IConstructionCallMessage* msg) {
        return IsContextOK(ctx, msg);
    }
    
}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Proxies {
    // Automatically generated method stub
    bool RemotingProxy::CanCastTo_7f8304fa142c3271(System::Type* fromType, System::Object* o) {
        return CanCastTo(fromType, o);
    }
    
    // Automatically generated method stub
    System::String* RemotingProxy::get_TypeName_e368785a4c79e626() {
        return get_TypeName();
    }
    
    // Automatically generated method stub
    System::String* RemotingProxy::set_TypeName_d3657f810af9c065(System::String* value) {
        return set_TypeName(value);
    }
    
}}}}
namespace System { namespace Runtime { namespace Serialization {
    // Automatically generated method stub
    System::Object* Formatter::Deserialize_19aeb6df512c35cb(System::IO::Stream* serializationStream) {
        return Deserialize_e1bd73439c8677d8(serializationStream);
    }
    
    // Automatically generated method stub
    void Formatter::Serialize_617c75444546bb4e(System::IO::Stream* serializationStream, System::Object* graph) {
        return Serialize_bd505a344058dedf(serializationStream, graph);
    }
    
    // Automatically generated method stub
    SerializationBinder* Formatter::get_Binder_215d8b515173b805() {
        return get_Binder_b052343f946ec6d1();
    }
    
    // Automatically generated method stub
    SerializationBinder* Formatter::set_Binder_175460eb6e1d50d5(SerializationBinder* value) {
        return set_Binder_af0ecbbfe2ab147(value);
    }
    
    // Automatically generated method stub
    StreamingContext Formatter::get_Context_dcb6fe59b19e8322() {
        return get_Context_60e3c3df669fd39c();
    }
    
    // Automatically generated method stub
    StreamingContext Formatter::set_Context_c7b1865dbad539b2(StreamingContext value) {
        return set_Context_2074917beb6b2079(value);
    }
    
    // Automatically generated method stub
    ISurrogateSelector* Formatter::get_SurrogateSelector_7fa2a47b11b30ba1() {
        return get_SurrogateSelector_6cacd6acd3c44209();
    }
    
    // Automatically generated method stub
    ISurrogateSelector* Formatter::set_SurrogateSelector_671af517157aed76(ISurrogateSelector* value) {
        return set_SurrogateSelector_7c1d3951a9fbe8a3(value);
    }
    
}}}
namespace System { namespace Runtime { namespace Serialization {
    // Automatically generated method stub
    System::Object* FormatterConverter::Convert_f36db21f5899e115(System::Object* value, System::Type* type) {
        return Convert2(value, type);
    }
    
    // Automatically generated method stub
    System::Object* FormatterConverter::Convert_fd69ce9fde44c7c9(System::Object* value, System::TypeCode typeCode) {
        return Convert3(value, typeCode);
    }
    
    // Automatically generated method stub
    bool FormatterConverter::ToBoolean_f78384850964024e(System::Object* value) {
        return ToBoolean(value);
    }
    
    // Automatically generated method stub
    unsigned char FormatterConverter::ToByte_b08e1092296aced(System::Object* value) {
        return ToByte(value);
    }
    
    // Automatically generated method stub
    char16_t FormatterConverter::ToChar_a90c87eb392f5c6b(System::Object* value) {
        return ToChar(value);
    }
    
    // Automatically generated method stub
    System::DateTime FormatterConverter::ToDateTime_db18bc4d36988ffe(System::Object* value) {
        return ToDateTime(value);
    }
    
    // Automatically generated method stub
    System::Decimal FormatterConverter::ToDecimal_91c52c2b2c34226d(System::Object* value) {
        return ToDecimal(value);
    }
    
    // Automatically generated method stub
    double FormatterConverter::ToDouble_c26b3a04c5b5c6c3(System::Object* value) {
        return ToDouble(value);
    }
    
    // Automatically generated method stub
    int16_t FormatterConverter::ToInt16_4c5e98cc2a24107a(System::Object* value) {
        return ToInt16(value);
    }
    
    // Automatically generated method stub
    int32_t FormatterConverter::ToInt32_70f32a0ca9af7aec(System::Object* value) {
        return ToInt32(value);
    }
    
    // Automatically generated method stub
    int64_t FormatterConverter::ToInt64_f60f3bd2c6d66487(System::Object* value) {
        return ToInt64(value);
    }
    
    // Automatically generated method stub
    float FormatterConverter::ToSingle_85c5ebe23a43ef7b(System::Object* value) {
        return ToSingle(value);
    }
    
    // Automatically generated method stub
    System::String* FormatterConverter::ToString_60d64e3cd2e84237(System::Object* value) {
        return ToString2(value);
    }
    
    // Automatically generated method stub
    signed char FormatterConverter::ToSByte_f5271c6436d3339a(System::Object* value) {
        return ToSByte(value);
    }
    
    // Automatically generated method stub
    uint16_t FormatterConverter::ToUInt16_66a4df810f9b2648(System::Object* value) {
        return ToUInt16(value);
    }
    
    // Automatically generated method stub
    uint32_t FormatterConverter::ToUInt32_c19d156d0b0e4179(System::Object* value) {
        return ToUInt32(value);
    }
    
    // Automatically generated method stub
    uint64_t FormatterConverter::ToUInt64_30dc7f167b1e482a(System::Object* value) {
        return ToUInt64(value);
    }
    
}}}
namespace System { namespace Runtime { namespace Serialization {
    // Automatically generated method stub
    int32_t InstanceComparer::Compare_451fd276747b629d(System::Object* o1, System::Object* o2) {
        return Compare(o1, o2);
    }
    
    // Automatically generated method stub
    int32_t InstanceComparer::GetHashCode_5d8a358493971efd(System::Object* o) {
        return GetHashCode2(o);
    }
    
}}}
namespace System { namespace Runtime { namespace Serialization {
    // Automatically generated method stub
    bool SerializationInfoEnumerator::MoveNext_4e78e145935f5417() {
        return MoveNext();
    }
    
    // Automatically generated method stub
    void SerializationInfoEnumerator::Reset_bcd82381eed41868() {
        return Reset();
    }
    
    // Automatically generated method stub
    System::Object* SerializationInfoEnumerator::get_Current_8eca9b3da02b123a() {
        return get_Current2();
    }
    
}}}
namespace System { namespace Runtime { namespace Serialization {
    // Automatically generated method stub
    int32_t HashHelper::GetHashCode_5d8a358493971efd(System::Object* obj) {
        return GetHashCode2(obj);
    }
    
    // Automatically generated method stub
    int32_t HashHelper::Compare_451fd276747b629d(System::Object* x, System::Object* y) {
        return Compare(x, y);
    }
    
}}}
namespace System { namespace Runtime { namespace Serialization {
    // Automatically generated method stub
    void SurrogateSelector::ChainSelector_b4bf6e9847cd4bb0(ISurrogateSelector* selector) {
        return ChainSelector_2005e7a460c04cd7(selector);
    }
    
    // Automatically generated method stub
    ISurrogateSelector* SurrogateSelector::GetNextSelector_f0732f882be06ccb() {
        return GetNextSelector_69e5cfddbf651b28();
    }
    
    // Automatically generated method stub
    ISerializationSurrogate* SurrogateSelector::GetSurrogate_9d3ffd4061f81ca8(System::Type* type, StreamingContext context, ISurrogateSelector* selector) {
        return GetSurrogate_7d9c3bc2abb037e8(type, context, selector);
    }
    
}}}
namespace System { namespace Runtime { namespace Serialization { namespace Formatters {
    // Automatically generated method stub
    void SoapFault::GetObjectData_11b895a112e04409(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        return GetObjectData(info, context);
    }
    
}}}}
namespace System { namespace Runtime { namespace Serialization { namespace Formatters {
    // Automatically generated method stub
    cli::array<System::Runtime::Remoting::Messaging::Header*>* SoapMessage::get_Headers_96b7bb51a0261db9() {
        return get_Headers();
    }
    
    // Automatically generated method stub
    cli::array<System::Runtime::Remoting::Messaging::Header*>* SoapMessage::set_Headers_96978db47415955e(cli::array<System::Runtime::Remoting::Messaging::Header*>* value) {
        return set_Headers(value);
    }
    
    // Automatically generated method stub
    System::String* SoapMessage::get_MethodName_28298dbe5631c29a() {
        return get_MethodName();
    }
    
    // Automatically generated method stub
    System::String* SoapMessage::set_MethodName_17a43f56cb082426(System::String* value) {
        return set_MethodName(value);
    }
    
    // Automatically generated method stub
    cli::array<System::String*>* SoapMessage::get_ParamNames_5982ddec287d0ab5() {
        return get_ParamNames();
    }
    
    // Automatically generated method stub
    cli::array<System::String*>* SoapMessage::set_ParamNames_ba43c410fccdd7e0(cli::array<System::String*>* value) {
        return set_ParamNames(value);
    }
    
    // Automatically generated method stub
    cli::array<System::Type*>* SoapMessage::get_ParamTypes_dfa28901a900c9e6() {
        return get_ParamTypes();
    }
    
    // Automatically generated method stub
    cli::array<System::Type*>* SoapMessage::set_ParamTypes_e393ddee8f239cb8(cli::array<System::Type*>* value) {
        return set_ParamTypes(value);
    }
    
    // Automatically generated method stub
    cli::array<System::Object*>* SoapMessage::get_ParamValues_a628ac3701d143a3() {
        return get_ParamValues();
    }
    
    // Automatically generated method stub
    cli::array<System::Object*>* SoapMessage::set_ParamValues_393afb0f84c346e9(cli::array<System::Object*>* value) {
        return set_ParamValues(value);
    }
    
    // Automatically generated method stub
    System::String* SoapMessage::get_XmlNameSpace_3b8ec03f5216958() {
        return get_XmlNameSpace();
    }
    
    // Automatically generated method stub
    System::String* SoapMessage::set_XmlNameSpace_6e306b61b433828(System::String* value) {
        return set_XmlNameSpace(value);
    }
    
}}}}
namespace System { namespace Runtime { namespace Serialization { namespace Formatters { namespace Binary {
    // Automatically generated method stub
    System::Object* BinaryFormatter::Deserialize_19aeb6df512c35cb(System::IO::Stream* serializationStream) {
        return Deserialize(serializationStream);
    }
    
    // Automatically generated method stub
    System::Object* BinaryFormatter::Deserialize_25413fb95ff81880(System::IO::Stream* serializationStream, System::Runtime::Remoting::Messaging::HeaderHandler* handler) {
        return Deserialize2(serializationStream, handler);
    }
    
    // Automatically generated method stub
    void BinaryFormatter::Serialize_617c75444546bb4e(System::IO::Stream* serializationStream, System::Object* graph) {
        return Serialize(serializationStream, graph);
    }
    
    // Automatically generated method stub
    void BinaryFormatter::Serialize_b2dd80326413fce6(System::IO::Stream* serializationStream, System::Object* graph, cli::array<System::Runtime::Remoting::Messaging::Header*>* headers) {
        return Serialize2(serializationStream, graph, headers);
    }
    
    // Automatically generated method stub
    System::Runtime::Serialization::SerializationBinder* BinaryFormatter::get_Binder_215d8b515173b805() {
        return get_Binder();
    }
    
    // Automatically generated method stub
    System::Runtime::Serialization::SerializationBinder* BinaryFormatter::set_Binder_175460eb6e1d50d5(System::Runtime::Serialization::SerializationBinder* value) {
        return set_Binder(value);
    }
    
    // Automatically generated method stub
    System::Runtime::Serialization::StreamingContext BinaryFormatter::get_Context_dcb6fe59b19e8322() {
        return get_Context();
    }
    
    // Automatically generated method stub
    System::Runtime::Serialization::StreamingContext BinaryFormatter::set_Context_c7b1865dbad539b2(System::Runtime::Serialization::StreamingContext value) {
        return set_Context(value);
    }
    
    // Automatically generated method stub
    System::Runtime::Serialization::ISurrogateSelector* BinaryFormatter::get_SurrogateSelector_7fa2a47b11b30ba1() {
        return get_SurrogateSelector();
    }
    
    // Automatically generated method stub
    System::Runtime::Serialization::ISurrogateSelector* BinaryFormatter::set_SurrogateSelector_671af517157aed76(System::Runtime::Serialization::ISurrogateSelector* value) {
        return set_SurrogateSelector(value);
    }
    
}}}}}
namespace System { namespace Security {
    // Automatically generated method stub
    void CodeAccessPermission::Assert_e1a4f90c372da24c() {
        return Assert();
    }
    
    // Automatically generated method stub
    IPermission* CodeAccessPermission::Copy_e6fdf74d8dfaca72() {
        return Copy_d1e925db301dc53f();
    }
    
    // Automatically generated method stub
    void CodeAccessPermission::Demand_6a8bc305f8dfa903() {
        return Demand();
    }
    
    // Automatically generated method stub
    void CodeAccessPermission::Demand_55e1408892730c3e() {
        return Demand();
    }
    
    // Automatically generated method stub
    void CodeAccessPermission::Deny_db68b9e52373af22() {
        return Deny();
    }
    
    // Automatically generated method stub
    void CodeAccessPermission::FromXml_1053a148f0375461(SecurityElement* elem) {
        return FromXml_ec3b425a66b43072(elem);
    }
    
    // Automatically generated method stub
    IPermission* CodeAccessPermission::Intersect_593562530728a967(IPermission* target) {
        return Intersect_7dbf5aef702b16af(target);
    }
    
    // Automatically generated method stub
    bool CodeAccessPermission::IsSubsetOf_1923c54e11db177f(IPermission* target) {
        return IsSubsetOf_76947f8575c4d81(target);
    }
    
    // Automatically generated method stub
    SecurityElement* CodeAccessPermission::ToXml_4868e697107d327() {
        return ToXml_9ee4cd8af8e8f747();
    }
    
    // Automatically generated method stub
    IPermission* CodeAccessPermission::Union_ecfa27115d58cb44(IPermission* other) {
        return Union_b0ddcab6cb9c8441(other);
    }
    
    // Automatically generated method stub
    void CodeAccessPermission::PermitOnly_a57179fb262ef034() {
        return PermitOnly();
    }
    
}}
namespace System { namespace Security {
    // Automatically generated method stub
    void PermissionSet::Assert_e1a4f90c372da24c() {
        return Assert();
    }
    
    // Automatically generated method stub
    void PermissionSet::CopyTo_7065a6e3cf6a140(System::Array* array, int32_t index) {
        return CopyTo_732d1dab1e90fd5a(array, index);
    }
    
    // Automatically generated method stub
    void PermissionSet::Demand_55e1408892730c3e() {
        return Demand();
    }
    
    // Automatically generated method stub
    void PermissionSet::Deny_db68b9e52373af22() {
        return Deny();
    }
    
    // Automatically generated method stub
    void PermissionSet::FromXml_1053a148f0375461(SecurityElement* et) {
        return FromXml_2ac858dba9ca352b(et);
    }
    
    // Automatically generated method stub
    System::Collections::IEnumerator* PermissionSet::GetEnumerator_674ad93a972a4d67() {
        return GetEnumerator();
    }
    
    // Automatically generated method stub
    void PermissionSet::PermitOnly_a57179fb262ef034() {
        return PermitOnly();
    }
    
    // Automatically generated method stub
    SecurityElement* PermissionSet::ToXml_4868e697107d327() {
        return ToXml_c2a66662101c88c3();
    }
    
    // Automatically generated method stub
    void PermissionSet::OnDeserialization_e9ecfecba8df9754(System::Object* sender) {
        return OnDeserialization(sender);
    }
    
    // Automatically generated method stub
    int32_t PermissionSet::get_Count_8f254f3dd8e2403() {
        return get_Count_db378507423fcdb();
    }
    
    // Automatically generated method stub
    bool PermissionSet::get_IsSynchronized_20926e7dabc53dbf() {
        return get_IsSynchronized_14b476662929a566();
    }
    
    // Automatically generated method stub
    System::Object* PermissionSet::get_SyncRoot_257108f45cc89e19() {
        return get_SyncRoot_8a019b52a35087b9();
    }
    
}}
namespace System { namespace Security {
    // Automatically generated method stub
    void PermissionSetCollection::CopyTo_7065a6e3cf6a140(System::Array* array, int32_t index) {
        return CopyTo2(array, index);
    }
    
    // Automatically generated method stub
    System::Collections::IEnumerator* PermissionSetCollection::GetEnumerator_674ad93a972a4d67() {
        return GetEnumerator();
    }
    
    // Automatically generated method stub
    int32_t PermissionSetCollection::get_Count_8f254f3dd8e2403() {
        return get_Count();
    }
    
    // Automatically generated method stub
    bool PermissionSetCollection::get_IsSynchronized_20926e7dabc53dbf() {
        return get_IsSynchronized();
    }
    
    // Automatically generated method stub
    System::Object* PermissionSetCollection::get_SyncRoot_257108f45cc89e19() {
        return get_SyncRoot();
    }
    
}}
namespace System { namespace Security {
    // Automatically generated method stub
    void SecureString::Dispose_95cb2516542c2f97() {
        return Dispose();
    }
    
}}
namespace System { namespace Security {
    // Automatically generated method stub
    void SecurityContext::Dispose_95cb2516542c2f97() {
        return Dispose();
    }
    
}}
namespace System { namespace Security { namespace AccessControl {
    // Automatically generated method stub
    bool AceEnumerator::MoveNext_4e78e145935f5417() {
        return MoveNext();
    }
    
    // Automatically generated method stub
    void AceEnumerator::Reset_bcd82381eed41868() {
        return Reset();
    }
    
    // Automatically generated method stub
    System::Object* AceEnumerator::get_Current_8eca9b3da02b123a() {
        return get_Current2();
    }
    
}}}
namespace System { namespace Security { namespace AccessControl {
    // Automatically generated method stub
    void GenericAcl::CopyTo_7065a6e3cf6a140(System::Array* array, int32_t index) {
        return CopyTo2(array, index);
    }
    
    // Automatically generated method stub
    System::Collections::IEnumerator* GenericAcl::GetEnumerator_674ad93a972a4d67() {
        return GetEnumerator2();
    }
    
    // Automatically generated method stub
    int32_t GenericAcl::get_Count_8f254f3dd8e2403() {
        return get_Count_5cd77c86ebcd1b2c();
    }
    
    // Automatically generated method stub
    bool GenericAcl::get_IsSynchronized_20926e7dabc53dbf() {
        return get_IsSynchronized();
    }
    
    // Automatically generated method stub
    System::Object* GenericAcl::get_SyncRoot_257108f45cc89e19() {
        return get_SyncRoot();
    }
    
}}}
namespace System { namespace Security { namespace AccessControl {
    // Automatically generated method stub
    void PrivilegeNotHeldException::GetObjectData_11b895a112e04409(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        return GetObjectData_bc9b88d7eb43b6d8(info, context);
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    // Automatically generated method stub
    void AsymmetricAlgorithm::Dispose_95cb2516542c2f97() {
        return Dispose();
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    // Automatically generated method stub
    void CryptoAPITransform::Dispose_95cb2516542c2f97() {
        return Dispose();
    }
    
    // Automatically generated method stub
    int32_t CryptoAPITransform::TransformBlock_66947c2464acaa4b(cli::array<unsigned char>* inputBuffer, int32_t inputOffset, int32_t inputCount, cli::array<unsigned char>* outputBuffer, int32_t outputOffset) {
        return TransformBlock(inputBuffer, inputOffset, inputCount, outputBuffer, outputOffset);
    }
    
    // Automatically generated method stub
    cli::array<unsigned char>* CryptoAPITransform::TransformFinalBlock_24eabce3605cc4ff(cli::array<unsigned char>* inputBuffer, int32_t inputOffset, int32_t inputCount) {
        return TransformFinalBlock(inputBuffer, inputOffset, inputCount);
    }
    
    // Automatically generated method stub
    bool CryptoAPITransform::get_CanReuseTransform_a8f6dfeea811518b() {
        return get_CanReuseTransform();
    }
    
    // Automatically generated method stub
    bool CryptoAPITransform::get_CanTransformMultipleBlocks_711dcde861c62b70() {
        return get_CanTransformMultipleBlocks();
    }
    
    // Automatically generated method stub
    int32_t CryptoAPITransform::get_InputBlockSize_96223a4af50041fd() {
        return get_InputBlockSize();
    }
    
    // Automatically generated method stub
    int32_t CryptoAPITransform::get_OutputBlockSize_970895ff24f2d445() {
        return get_OutputBlockSize();
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    // Automatically generated method stub
    void CryptoHandler::OnStartParsing_60c119bf90baa608(Mono::Xml::SmallXmlParser* parser) {
        return OnStartParsing(parser);
    }
    
    // Automatically generated method stub
    void CryptoHandler::OnEndParsing_ddf0252ce1c74235(Mono::Xml::SmallXmlParser* parser) {
        return OnEndParsing(parser);
    }
    
    // Automatically generated method stub
    void CryptoHandler::OnStartElement_431a5ecd1484562f(System::String* name, Mono::Xml::IAttrList* attrs) {
        return OnStartElement(name, attrs);
    }
    
    // Automatically generated method stub
    void CryptoHandler::OnEndElement_47dd703957202fcd(System::String* name) {
        return OnEndElement(name);
    }
    
    // Automatically generated method stub
    void CryptoHandler::OnProcessingInstruction_eeedb82cbfe7ab40(System::String* name, System::String* text) {
        return OnProcessingInstruction(name, text);
    }
    
    // Automatically generated method stub
    void CryptoHandler::OnChars_23545ef97e4c205b(System::String* text) {
        return OnChars(text);
    }
    
    // Automatically generated method stub
    void CryptoHandler::OnIgnorableWhitespace_39f85fe38215782c(System::String* text) {
        return OnIgnorableWhitespace(text);
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    // Automatically generated method stub
    void DeriveBytes2::Dispose_95cb2516542c2f97() {
        return Dispose();
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    // Automatically generated method stub
    cli::array<unsigned char>* DSACryptoServiceProvider::ExportCspBlob_9a31ab9dad32d592(bool includePrivateParameters) {
        return ExportCspBlob(includePrivateParameters);
    }
    
    // Automatically generated method stub
    void DSACryptoServiceProvider::ImportCspBlob_4dc0b4a93c0b22fd(cli::array<unsigned char>* keyBlob) {
        return ImportCspBlob(keyBlob);
    }
    
    // Automatically generated method stub
    CspKeyContainerInfo* DSACryptoServiceProvider::get_CspKeyContainerInfo_e0b6cc9127ecfec0() {
        return get_CspKeyContainerInfo();
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    // Automatically generated method stub
    void FromBase64Transform::Dispose_95cb2516542c2f97() {
        return Dispose();
    }
    
    // Automatically generated method stub
    int32_t FromBase64Transform::TransformBlock_66947c2464acaa4b(cli::array<unsigned char>* inputBuffer, int32_t inputOffset, int32_t inputCount, cli::array<unsigned char>* outputBuffer, int32_t outputOffset) {
        return TransformBlock(inputBuffer, inputOffset, inputCount, outputBuffer, outputOffset);
    }
    
    // Automatically generated method stub
    cli::array<unsigned char>* FromBase64Transform::TransformFinalBlock_24eabce3605cc4ff(cli::array<unsigned char>* inputBuffer, int32_t inputOffset, int32_t inputCount) {
        return TransformFinalBlock(inputBuffer, inputOffset, inputCount);
    }
    
    // Automatically generated method stub
    bool FromBase64Transform::get_CanTransformMultipleBlocks_711dcde861c62b70() {
        return get_CanTransformMultipleBlocks();
    }
    
    // Automatically generated method stub
    bool FromBase64Transform::get_CanReuseTransform_a8f6dfeea811518b() {
        return get_CanReuseTransform_8fc1dde1dff87aad();
    }
    
    // Automatically generated method stub
    int32_t FromBase64Transform::get_InputBlockSize_96223a4af50041fd() {
        return get_InputBlockSize();
    }
    
    // Automatically generated method stub
    int32_t FromBase64Transform::get_OutputBlockSize_970895ff24f2d445() {
        return get_OutputBlockSize();
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    // Automatically generated method stub
    void HashAlgorithm::Dispose_95cb2516542c2f97() {
        return Dispose2();
    }
    
    // Automatically generated method stub
    int32_t HashAlgorithm::TransformBlock_66947c2464acaa4b(cli::array<unsigned char>* inputBuffer, int32_t inputOffset, int32_t inputCount, cli::array<unsigned char>* outputBuffer, int32_t outputOffset) {
        return TransformBlock(inputBuffer, inputOffset, inputCount, outputBuffer, outputOffset);
    }
    
    // Automatically generated method stub
    cli::array<unsigned char>* HashAlgorithm::TransformFinalBlock_24eabce3605cc4ff(cli::array<unsigned char>* inputBuffer, int32_t inputOffset, int32_t inputCount) {
        return TransformFinalBlock(inputBuffer, inputOffset, inputCount);
    }
    
    // Automatically generated method stub
    bool HashAlgorithm::get_CanTransformMultipleBlocks_711dcde861c62b70() {
        return get_CanTransformMultipleBlocks_fb3bd2c8e857f691();
    }
    
    // Automatically generated method stub
    bool HashAlgorithm::get_CanReuseTransform_a8f6dfeea811518b() {
        return get_CanReuseTransform_19ba0450c5bf43f9();
    }
    
    // Automatically generated method stub
    int32_t HashAlgorithm::get_InputBlockSize_96223a4af50041fd() {
        return get_InputBlockSize_76e25e14b1426491();
    }
    
    // Automatically generated method stub
    int32_t HashAlgorithm::get_OutputBlockSize_970895ff24f2d445() {
        return get_OutputBlockSize_ade2f52ae475c349();
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    // Automatically generated method stub
    void RandomNumberGenerator::Dispose_95cb2516542c2f97() {
        return Dispose();
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    // Automatically generated method stub
    void RijndaelManagedTransform::Dispose_95cb2516542c2f97() {
        return Dispose();
    }
    
    // Automatically generated method stub
    int32_t RijndaelManagedTransform::TransformBlock_66947c2464acaa4b(cli::array<unsigned char>* inputBuffer, int32_t inputOffset, int32_t inputCount, cli::array<unsigned char>* outputBuffer, int32_t outputOffset) {
        return TransformBlock(inputBuffer, inputOffset, inputCount, outputBuffer, outputOffset);
    }
    
    // Automatically generated method stub
    cli::array<unsigned char>* RijndaelManagedTransform::TransformFinalBlock_24eabce3605cc4ff(cli::array<unsigned char>* inputBuffer, int32_t inputOffset, int32_t inputCount) {
        return TransformFinalBlock(inputBuffer, inputOffset, inputCount);
    }
    
    // Automatically generated method stub
    bool RijndaelManagedTransform::get_CanTransformMultipleBlocks_711dcde861c62b70() {
        return get_CanTransformMultipleBlocks();
    }
    
    // Automatically generated method stub
    bool RijndaelManagedTransform::get_CanReuseTransform_a8f6dfeea811518b() {
        return get_CanReuseTransform();
    }
    
    // Automatically generated method stub
    int32_t RijndaelManagedTransform::get_InputBlockSize_96223a4af50041fd() {
        return get_InputBlockSize();
    }
    
    // Automatically generated method stub
    int32_t RijndaelManagedTransform::get_OutputBlockSize_970895ff24f2d445() {
        return get_OutputBlockSize();
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    // Automatically generated method stub
    cli::array<unsigned char>* RSACryptoServiceProvider::ExportCspBlob_9a31ab9dad32d592(bool includePrivateParameters) {
        return ExportCspBlob(includePrivateParameters);
    }
    
    // Automatically generated method stub
    void RSACryptoServiceProvider::ImportCspBlob_4dc0b4a93c0b22fd(cli::array<unsigned char>* keyBlob) {
        return ImportCspBlob(keyBlob);
    }
    
    // Automatically generated method stub
    CspKeyContainerInfo* RSACryptoServiceProvider::get_CspKeyContainerInfo_e0b6cc9127ecfec0() {
        return get_CspKeyContainerInfo();
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    // Automatically generated method stub
    void SymmetricAlgorithm::Dispose_95cb2516542c2f97() {
        return Dispose();
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    // Automatically generated method stub
    void ToBase64Transform::Dispose_95cb2516542c2f97() {
        return Dispose();
    }
    
    // Automatically generated method stub
    int32_t ToBase64Transform::TransformBlock_66947c2464acaa4b(cli::array<unsigned char>* inputBuffer, int32_t inputOffset, int32_t inputCount, cli::array<unsigned char>* outputBuffer, int32_t outputOffset) {
        return TransformBlock(inputBuffer, inputOffset, inputCount, outputBuffer, outputOffset);
    }
    
    // Automatically generated method stub
    cli::array<unsigned char>* ToBase64Transform::TransformFinalBlock_24eabce3605cc4ff(cli::array<unsigned char>* inputBuffer, int32_t inputOffset, int32_t inputCount) {
        return TransformFinalBlock(inputBuffer, inputOffset, inputCount);
    }
    
    // Automatically generated method stub
    bool ToBase64Transform::get_CanTransformMultipleBlocks_711dcde861c62b70() {
        return get_CanTransformMultipleBlocks();
    }
    
    // Automatically generated method stub
    bool ToBase64Transform::get_CanReuseTransform_a8f6dfeea811518b() {
        return get_CanReuseTransform_ab8331e898b19c7c();
    }
    
    // Automatically generated method stub
    int32_t ToBase64Transform::get_InputBlockSize_96223a4af50041fd() {
        return get_InputBlockSize();
    }
    
    // Automatically generated method stub
    int32_t ToBase64Transform::get_OutputBlockSize_970895ff24f2d445() {
        return get_OutputBlockSize();
    }
    
}}}
namespace System { namespace Security { namespace Cryptography { namespace X509Certificates {
    // Automatically generated method stub
    void X509Certificate2::OnDeserialization_e9ecfecba8df9754(System::Object* sender) {
        return OnDeserialization(sender);
    }
    
    // Automatically generated method stub
    void X509Certificate2::GetObjectData_11b895a112e04409(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        return GetObjectData(info, context);
    }
    
}}}}
namespace System { namespace Security { namespace Permissions {
    // Automatically generated method stub
    bool EnvironmentPermission::IsUnrestricted_c7d55a1eabc43262() {
        return IsUnrestricted2();
    }
    
    // Automatically generated method stub
    System::Security::IPermission* EnvironmentPermission::Union_ecfa27115d58cb44(System::Security::IPermission* other) {
        return Union_b0ddcab6cb9c8441(other);
    }
    
    // Automatically generated method stub
    int32_t EnvironmentPermission::GetTokenIndex_3e653e1a6127921() {
        return GetTokenIndex();
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    // Automatically generated method stub
    bool FileDialogPermission::IsUnrestricted_c7d55a1eabc43262() {
        return IsUnrestricted2();
    }
    
    // Automatically generated method stub
    System::Security::IPermission* FileDialogPermission::Union_ecfa27115d58cb44(System::Security::IPermission* target) {
        return Union_b0ddcab6cb9c8441(target);
    }
    
    // Automatically generated method stub
    int32_t FileDialogPermission::GetTokenIndex_3e653e1a6127921() {
        return GetTokenIndex();
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    // Automatically generated method stub
    bool FileIOPermission::IsUnrestricted_c7d55a1eabc43262() {
        return IsUnrestricted2();
    }
    
    // Automatically generated method stub
    System::Security::IPermission* FileIOPermission::Union_ecfa27115d58cb44(System::Security::IPermission* other) {
        return Union_b0ddcab6cb9c8441(other);
    }
    
    // Automatically generated method stub
    int32_t FileIOPermission::GetTokenIndex_3e653e1a6127921() {
        return GetTokenIndex();
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    // Automatically generated method stub
    System::Security::IPermission* GacIdentityPermission::Union_ecfa27115d58cb44(System::Security::IPermission* target) {
        return Union_b0ddcab6cb9c8441(target);
    }
    
    // Automatically generated method stub
    int32_t GacIdentityPermission::GetTokenIndex_3e653e1a6127921() {
        return GetTokenIndex();
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    // Automatically generated method stub
    System::Security::IPermission* HostProtectionPermission::Union_ecfa27115d58cb44(System::Security::IPermission* target) {
        return Union_b0ddcab6cb9c8441(target);
    }
    
    // Automatically generated method stub
    bool HostProtectionPermission::IsUnrestricted_c7d55a1eabc43262() {
        return IsUnrestricted2();
    }
    
    // Automatically generated method stub
    int32_t HostProtectionPermission::GetTokenIndex_3e653e1a6127921() {
        return GetTokenIndex();
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    // Automatically generated method stub
    int32_t IsolatedStorageFilePermission::GetTokenIndex_3e653e1a6127921() {
        return GetTokenIndex();
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    // Automatically generated method stub
    bool IsolatedStoragePermission::IsUnrestricted_c7d55a1eabc43262() {
        return IsUnrestricted2();
    }
    
    // Automatically generated method stub
    System::Security::SecurityElement* IsolatedStoragePermission::ToXml_4868e697107d327() {
        return ToXml_9ee4cd8af8e8f747();
    }
    
    // Automatically generated method stub
    void IsolatedStoragePermission::FromXml_1053a148f0375461(System::Security::SecurityElement* esd) {
        return FromXml_ec3b425a66b43072(esd);
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    // Automatically generated method stub
    bool KeyContainerPermission::IsUnrestricted_c7d55a1eabc43262() {
        return IsUnrestricted2();
    }
    
    // Automatically generated method stub
    System::Security::IPermission* KeyContainerPermission::Union_ecfa27115d58cb44(System::Security::IPermission* target) {
        return Union_b0ddcab6cb9c8441(target);
    }
    
    // Automatically generated method stub
    int32_t KeyContainerPermission::GetTokenIndex_3e653e1a6127921() {
        return GetTokenIndex();
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    // Automatically generated method stub
    void KeyContainerPermissionAccessEntryCollection::CopyTo_7065a6e3cf6a140(System::Array* array, int32_t index) {
        return CopyTo2(array, index);
    }
    
    // Automatically generated method stub
    System::Collections::IEnumerator* KeyContainerPermissionAccessEntryCollection::GetEnumerator_674ad93a972a4d67() {
        return GetEnumerator2();
    }
    
    // Automatically generated method stub
    int32_t KeyContainerPermissionAccessEntryCollection::get_Count_8f254f3dd8e2403() {
        return get_Count();
    }
    
    // Automatically generated method stub
    bool KeyContainerPermissionAccessEntryCollection::get_IsSynchronized_20926e7dabc53dbf() {
        return get_IsSynchronized();
    }
    
    // Automatically generated method stub
    System::Object* KeyContainerPermissionAccessEntryCollection::get_SyncRoot_257108f45cc89e19() {
        return get_SyncRoot();
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    // Automatically generated method stub
    bool KeyContainerPermissionAccessEntryEnumerator::MoveNext_4e78e145935f5417() {
        return MoveNext();
    }
    
    // Automatically generated method stub
    void KeyContainerPermissionAccessEntryEnumerator::Reset_bcd82381eed41868() {
        return Reset();
    }
    
    // Automatically generated method stub
    System::Object* KeyContainerPermissionAccessEntryEnumerator::get_Current_8eca9b3da02b123a() {
        return get_Current2();
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    // Automatically generated method stub
    System::Security::IPermission* PrincipalPermission::Copy_e6fdf74d8dfaca72() {
        return Copy();
    }
    
    // Automatically generated method stub
    void PrincipalPermission::Demand_6a8bc305f8dfa903() {
        return Demand();
    }
    
    // Automatically generated method stub
    void PrincipalPermission::FromXml_1053a148f0375461(System::Security::SecurityElement* elem) {
        return FromXml(elem);
    }
    
    // Automatically generated method stub
    System::Security::IPermission* PrincipalPermission::Intersect_593562530728a967(System::Security::IPermission* target) {
        return Intersect(target);
    }
    
    // Automatically generated method stub
    bool PrincipalPermission::IsSubsetOf_1923c54e11db177f(System::Security::IPermission* target) {
        return IsSubsetOf(target);
    }
    
    // Automatically generated method stub
    bool PrincipalPermission::IsUnrestricted_c7d55a1eabc43262() {
        return IsUnrestricted();
    }
    
    // Automatically generated method stub
    System::Security::SecurityElement* PrincipalPermission::ToXml_4868e697107d327() {
        return ToXml();
    }
    
    // Automatically generated method stub
    System::Security::IPermission* PrincipalPermission::Union_ecfa27115d58cb44(System::Security::IPermission* other) {
        return Union(other);
    }
    
    // Automatically generated method stub
    int32_t PrincipalPermission::GetTokenIndex_3e653e1a6127921() {
        return GetTokenIndex();
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    // Automatically generated method stub
    System::Security::IPermission* PublisherIdentityPermission::Union_ecfa27115d58cb44(System::Security::IPermission* target) {
        return Union_b0ddcab6cb9c8441(target);
    }
    
    // Automatically generated method stub
    int32_t PublisherIdentityPermission::GetTokenIndex_3e653e1a6127921() {
        return GetTokenIndex();
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    // Automatically generated method stub
    bool ReflectionPermission::IsUnrestricted_c7d55a1eabc43262() {
        return IsUnrestricted2();
    }
    
    // Automatically generated method stub
    System::Security::IPermission* ReflectionPermission::Union_ecfa27115d58cb44(System::Security::IPermission* other) {
        return Union_b0ddcab6cb9c8441(other);
    }
    
    // Automatically generated method stub
    int32_t ReflectionPermission::GetTokenIndex_3e653e1a6127921() {
        return GetTokenIndex();
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    // Automatically generated method stub
    bool RegistryPermission::IsUnrestricted_c7d55a1eabc43262() {
        return IsUnrestricted2();
    }
    
    // Automatically generated method stub
    System::Security::IPermission* RegistryPermission::Union_ecfa27115d58cb44(System::Security::IPermission* other) {
        return Union_b0ddcab6cb9c8441(other);
    }
    
    // Automatically generated method stub
    int32_t RegistryPermission::GetTokenIndex_3e653e1a6127921() {
        return GetTokenIndex();
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    // Automatically generated method stub
    bool SecurityPermission::IsUnrestricted_c7d55a1eabc43262() {
        return IsUnrestricted2();
    }
    
    // Automatically generated method stub
    System::Security::IPermission* SecurityPermission::Union_ecfa27115d58cb44(System::Security::IPermission* target) {
        return Union_b0ddcab6cb9c8441(target);
    }
    
    // Automatically generated method stub
    int32_t SecurityPermission::GetTokenIndex_3e653e1a6127921() {
        return GetTokenIndex();
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    // Automatically generated method stub
    System::Security::IPermission* SiteIdentityPermission::Union_ecfa27115d58cb44(System::Security::IPermission* target) {
        return Union_b0ddcab6cb9c8441(target);
    }
    
    // Automatically generated method stub
    int32_t SiteIdentityPermission::GetTokenIndex_3e653e1a6127921() {
        return GetTokenIndex();
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    // Automatically generated method stub
    System::Security::IPermission* StrongNameIdentityPermission::Union_ecfa27115d58cb44(System::Security::IPermission* target) {
        return Union_b0ddcab6cb9c8441(target);
    }
    
    // Automatically generated method stub
    int32_t StrongNameIdentityPermission::GetTokenIndex_3e653e1a6127921() {
        return GetTokenIndex();
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    // Automatically generated method stub
    bool UIPermission::IsUnrestricted_c7d55a1eabc43262() {
        return IsUnrestricted2();
    }
    
    // Automatically generated method stub
    System::Security::IPermission* UIPermission::Union_ecfa27115d58cb44(System::Security::IPermission* target) {
        return Union_b0ddcab6cb9c8441(target);
    }
    
    // Automatically generated method stub
    int32_t UIPermission::GetTokenIndex_3e653e1a6127921() {
        return GetTokenIndex();
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    // Automatically generated method stub
    System::Security::IPermission* UrlIdentityPermission::Union_ecfa27115d58cb44(System::Security::IPermission* target) {
        return Union_b0ddcab6cb9c8441(target);
    }
    
    // Automatically generated method stub
    int32_t UrlIdentityPermission::GetTokenIndex_3e653e1a6127921() {
        return GetTokenIndex();
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    // Automatically generated method stub
    System::Security::IPermission* ZoneIdentityPermission::Union_ecfa27115d58cb44(System::Security::IPermission* target) {
        return Union_b0ddcab6cb9c8441(target);
    }
    
    // Automatically generated method stub
    int32_t ZoneIdentityPermission::GetTokenIndex_3e653e1a6127921() {
        return GetTokenIndex();
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    // Automatically generated method stub
    bool AllMembershipCondition::Check_40359438a47300d0(Evidence* evidence) {
        return Check(evidence);
    }
    
    // Automatically generated method stub
    IMembershipCondition* AllMembershipCondition::Copy_44d120d5c8a6f573() {
        return Copy();
    }
    
    // Automatically generated method stub
    bool AllMembershipCondition::Equals_4b738171fe6c9984(System::Object* o) {
        return Equals_ed975d2f4a7d193e(o);
    }
    
    // Automatically generated method stub
    void AllMembershipCondition::FromXml_1053a148f0375461(System::Security::SecurityElement* e) {
        return FromXml(e);
    }
    
    // Automatically generated method stub
    void AllMembershipCondition::FromXml_d33f37a1ca3b24b6(System::Security::SecurityElement* e, PolicyLevel* level) {
        return FromXml2(e, level);
    }
    
    // Automatically generated method stub
    System::String* AllMembershipCondition::ToString_427da0d8da742df9() {
        return ToString_1636a0751cb9ac11();
    }
    
    // Automatically generated method stub
    System::Security::SecurityElement* AllMembershipCondition::ToXml_4868e697107d327() {
        return ToXml();
    }
    
    // Automatically generated method stub
    System::Security::SecurityElement* AllMembershipCondition::ToXml_7ef261149cc39102(PolicyLevel* level) {
        return ToXml2(level);
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    // Automatically generated method stub
    int32_t ApplicationDirectory::GetRequiredSize_d6a347da59603f2e(bool verbose) {
        return GetRequiredSize(verbose);
    }
    
    // Automatically generated method stub
    int32_t ApplicationDirectory::InitFromBuffer_c92c70723ded1d45(cli::array<char16_t>* buffer, int32_t position) {
        return InitFromBuffer(buffer, position);
    }
    
    // Automatically generated method stub
    int32_t ApplicationDirectory::OutputToBuffer_c67224525da6df65(cli::array<char16_t>* buffer, int32_t position, bool verbose) {
        return OutputToBuffer(buffer, position, verbose);
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    // Automatically generated method stub
    bool ApplicationDirectoryMembershipCondition::Check_40359438a47300d0(Evidence* evidence) {
        return Check(evidence);
    }
    
    // Automatically generated method stub
    IMembershipCondition* ApplicationDirectoryMembershipCondition::Copy_44d120d5c8a6f573() {
        return Copy();
    }
    
    // Automatically generated method stub
    bool ApplicationDirectoryMembershipCondition::Equals_4b738171fe6c9984(System::Object* o) {
        return Equals_ed975d2f4a7d193e(o);
    }
    
    // Automatically generated method stub
    void ApplicationDirectoryMembershipCondition::FromXml_1053a148f0375461(System::Security::SecurityElement* e) {
        return FromXml(e);
    }
    
    // Automatically generated method stub
    void ApplicationDirectoryMembershipCondition::FromXml_d33f37a1ca3b24b6(System::Security::SecurityElement* e, PolicyLevel* level) {
        return FromXml2(e, level);
    }
    
    // Automatically generated method stub
    System::String* ApplicationDirectoryMembershipCondition::ToString_427da0d8da742df9() {
        return ToString_1636a0751cb9ac11();
    }
    
    // Automatically generated method stub
    System::Security::SecurityElement* ApplicationDirectoryMembershipCondition::ToXml_4868e697107d327() {
        return ToXml();
    }
    
    // Automatically generated method stub
    System::Security::SecurityElement* ApplicationDirectoryMembershipCondition::ToXml_7ef261149cc39102(PolicyLevel* level) {
        return ToXml2(level);
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    // Automatically generated method stub
    bool ApplicationMembershipCondition::Check_40359438a47300d0(Evidence* evidence) {
        return Check(evidence);
    }
    
    // Automatically generated method stub
    IMembershipCondition* ApplicationMembershipCondition::Copy_44d120d5c8a6f573() {
        return Copy();
    }
    
    // Automatically generated method stub
    bool ApplicationMembershipCondition::Equals_4b738171fe6c9984(System::Object* o) {
        return Equals_ed975d2f4a7d193e(o);
    }
    
    // Automatically generated method stub
    void ApplicationMembershipCondition::FromXml_1053a148f0375461(System::Security::SecurityElement* e) {
        return FromXml(e);
    }
    
    // Automatically generated method stub
    void ApplicationMembershipCondition::FromXml_d33f37a1ca3b24b6(System::Security::SecurityElement* e, PolicyLevel* level) {
        return FromXml2(e, level);
    }
    
    // Automatically generated method stub
    System::String* ApplicationMembershipCondition::ToString_427da0d8da742df9() {
        return ToString_1636a0751cb9ac11();
    }
    
    // Automatically generated method stub
    System::Security::SecurityElement* ApplicationMembershipCondition::ToXml_4868e697107d327() {
        return ToXml();
    }
    
    // Automatically generated method stub
    System::Security::SecurityElement* ApplicationMembershipCondition::ToXml_7ef261149cc39102(PolicyLevel* level) {
        return ToXml2(level);
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    // Automatically generated method stub
    void ApplicationTrust::FromXml_1053a148f0375461(System::Security::SecurityElement* element) {
        return FromXml(element);
    }
    
    // Automatically generated method stub
    System::Security::SecurityElement* ApplicationTrust::ToXml_4868e697107d327() {
        return ToXml();
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    // Automatically generated method stub
    void ApplicationTrustCollection::CopyTo_7065a6e3cf6a140(System::Array* array, int32_t index) {
        return CopyTo2(array, index);
    }
    
    // Automatically generated method stub
    System::Collections::IEnumerator* ApplicationTrustCollection::GetEnumerator_674ad93a972a4d67() {
        return GetEnumerator2();
    }
    
    // Automatically generated method stub
    int32_t ApplicationTrustCollection::get_Count_8f254f3dd8e2403() {
        return get_Count();
    }
    
    // Automatically generated method stub
    bool ApplicationTrustCollection::get_IsSynchronized_20926e7dabc53dbf() {
        return get_IsSynchronized();
    }
    
    // Automatically generated method stub
    System::Object* ApplicationTrustCollection::get_SyncRoot_257108f45cc89e19() {
        return get_SyncRoot();
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    // Automatically generated method stub
    bool ApplicationTrustEnumerator::MoveNext_4e78e145935f5417() {
        return MoveNext();
    }
    
    // Automatically generated method stub
    void ApplicationTrustEnumerator::Reset_bcd82381eed41868() {
        return Reset();
    }
    
    // Automatically generated method stub
    System::Object* ApplicationTrustEnumerator::get_Current_8eca9b3da02b123a() {
        return get_Current2();
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    // Automatically generated method stub
    bool DomainApplicationMembershipCondition::Check_40359438a47300d0(Evidence* evidence) {
        return Check(evidence);
    }
    
    // Automatically generated method stub
    IMembershipCondition* DomainApplicationMembershipCondition::Copy_44d120d5c8a6f573() {
        return Copy();
    }
    
    // Automatically generated method stub
    bool DomainApplicationMembershipCondition::Equals_4b738171fe6c9984(System::Object* o) {
        return Equals_ed975d2f4a7d193e(o);
    }
    
    // Automatically generated method stub
    void DomainApplicationMembershipCondition::FromXml_1053a148f0375461(System::Security::SecurityElement* e) {
        return FromXml(e);
    }
    
    // Automatically generated method stub
    void DomainApplicationMembershipCondition::FromXml_d33f37a1ca3b24b6(System::Security::SecurityElement* e, PolicyLevel* level) {
        return FromXml2(e, level);
    }
    
    // Automatically generated method stub
    System::String* DomainApplicationMembershipCondition::ToString_427da0d8da742df9() {
        return ToString_1636a0751cb9ac11();
    }
    
    // Automatically generated method stub
    System::Security::SecurityElement* DomainApplicationMembershipCondition::ToXml_4868e697107d327() {
        return ToXml();
    }
    
    // Automatically generated method stub
    System::Security::SecurityElement* DomainApplicationMembershipCondition::ToXml_7ef261149cc39102(PolicyLevel* level) {
        return ToXml2(level);
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    // Automatically generated method stub
    bool EvidenceEnumerator::MoveNext_4e78e145935f5417() {
        return MoveNext();
    }
    
    // Automatically generated method stub
    void EvidenceEnumerator::Reset_bcd82381eed41868() {
        return Reset();
    }
    
    // Automatically generated method stub
    System::Object* EvidenceEnumerator::get_Current_8eca9b3da02b123a() {
        return get_Current();
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    // Automatically generated method stub
    void Evidence::CopyTo_7065a6e3cf6a140(System::Array* array, int32_t index) {
        return CopyTo(array, index);
    }
    
    // Automatically generated method stub
    System::Collections::IEnumerator* Evidence::GetEnumerator_674ad93a972a4d67() {
        return GetEnumerator();
    }
    
    // Automatically generated method stub
    int32_t Evidence::get_Count_8f254f3dd8e2403() {
        return get_Count();
    }
    
    // Automatically generated method stub
    bool Evidence::get_IsSynchronized_20926e7dabc53dbf() {
        return get_IsSynchronized();
    }
    
    // Automatically generated method stub
    System::Object* Evidence::get_SyncRoot_257108f45cc89e19() {
        return get_SyncRoot();
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    // Automatically generated method stub
    System::Security::IPermission* GacInstalled::CreateIdentityPermission_889b07b8aadbac79(Evidence* evidence) {
        return CreateIdentityPermission(evidence);
    }
    
    // Automatically generated method stub
    int32_t GacInstalled::GetRequiredSize_d6a347da59603f2e(bool verbose) {
        return GetRequiredSize(verbose);
    }
    
    // Automatically generated method stub
    int32_t GacInstalled::InitFromBuffer_c92c70723ded1d45(cli::array<char16_t>* buffer, int32_t position) {
        return InitFromBuffer(buffer, position);
    }
    
    // Automatically generated method stub
    int32_t GacInstalled::OutputToBuffer_c67224525da6df65(cli::array<char16_t>* buffer, int32_t position, bool verbose) {
        return OutputToBuffer(buffer, position, verbose);
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    // Automatically generated method stub
    bool GacMembershipCondition::Check_40359438a47300d0(Evidence* evidence) {
        return Check(evidence);
    }
    
    // Automatically generated method stub
    IMembershipCondition* GacMembershipCondition::Copy_44d120d5c8a6f573() {
        return Copy();
    }
    
    // Automatically generated method stub
    bool GacMembershipCondition::Equals_4b738171fe6c9984(System::Object* o) {
        return Equals_ed975d2f4a7d193e(o);
    }
    
    // Automatically generated method stub
    void GacMembershipCondition::FromXml_1053a148f0375461(System::Security::SecurityElement* e) {
        return FromXml(e);
    }
    
    // Automatically generated method stub
    void GacMembershipCondition::FromXml_d33f37a1ca3b24b6(System::Security::SecurityElement* e, PolicyLevel* level) {
        return FromXml2(e, level);
    }
    
    // Automatically generated method stub
    System::String* GacMembershipCondition::ToString_427da0d8da742df9() {
        return ToString_1636a0751cb9ac11();
    }
    
    // Automatically generated method stub
    System::Security::SecurityElement* GacMembershipCondition::ToXml_4868e697107d327() {
        return ToXml();
    }
    
    // Automatically generated method stub
    System::Security::SecurityElement* GacMembershipCondition::ToXml_7ef261149cc39102(PolicyLevel* level) {
        return ToXml2(level);
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    // Automatically generated method stub
    void Hash::GetObjectData_11b895a112e04409(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        return GetObjectData(info, context);
    }
    
    // Automatically generated method stub
    int32_t Hash::GetRequiredSize_d6a347da59603f2e(bool verbose) {
        return GetRequiredSize(verbose);
    }
    
    // Automatically generated method stub
    int32_t Hash::InitFromBuffer_c92c70723ded1d45(cli::array<char16_t>* buffer, int32_t position) {
        return InitFromBuffer(buffer, position);
    }
    
    // Automatically generated method stub
    int32_t Hash::OutputToBuffer_c67224525da6df65(cli::array<char16_t>* buffer, int32_t position, bool verbose) {
        return OutputToBuffer(buffer, position, verbose);
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    // Automatically generated method stub
    bool HashMembershipCondition::Check_40359438a47300d0(Evidence* evidence) {
        return Check(evidence);
    }
    
    // Automatically generated method stub
    IMembershipCondition* HashMembershipCondition::Copy_44d120d5c8a6f573() {
        return Copy();
    }
    
    // Automatically generated method stub
    bool HashMembershipCondition::Equals_4b738171fe6c9984(System::Object* o) {
        return Equals_ed975d2f4a7d193e(o);
    }
    
    // Automatically generated method stub
    System::Security::SecurityElement* HashMembershipCondition::ToXml_4868e697107d327() {
        return ToXml();
    }
    
    // Automatically generated method stub
    System::Security::SecurityElement* HashMembershipCondition::ToXml_7ef261149cc39102(PolicyLevel* level) {
        return ToXml2(level);
    }
    
    // Automatically generated method stub
    void HashMembershipCondition::FromXml_1053a148f0375461(System::Security::SecurityElement* e) {
        return FromXml(e);
    }
    
    // Automatically generated method stub
    void HashMembershipCondition::FromXml_d33f37a1ca3b24b6(System::Security::SecurityElement* e, PolicyLevel* level) {
        return FromXml2(e, level);
    }
    
    // Automatically generated method stub
    System::String* HashMembershipCondition::ToString_427da0d8da742df9() {
        return ToString_1636a0751cb9ac11();
    }
    
    // Automatically generated method stub
    void HashMembershipCondition::OnDeserialization_e9ecfecba8df9754(System::Object* sender) {
        return OnDeserialization(sender);
    }
    
    // Automatically generated method stub
    void HashMembershipCondition::GetObjectData_11b895a112e04409(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        return GetObjectData(info, context);
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    // Automatically generated method stub
    ApplicationTrust* MonoTrustManager::DetermineApplicationTrust_29a1102f04ee3483(System::ActivationContext* activationContext, TrustManagerContext* context) {
        return DetermineApplicationTrust(activationContext, context);
    }
    
    // Automatically generated method stub
    void MonoTrustManager::FromXml_1053a148f0375461(System::Security::SecurityElement* e) {
        return FromXml(e);
    }
    
    // Automatically generated method stub
    System::Security::SecurityElement* MonoTrustManager::ToXml_4868e697107d327() {
        return ToXml();
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    // Automatically generated method stub
    int32_t PermissionRequestEvidence::GetRequiredSize_d6a347da59603f2e(bool verbose) {
        return GetRequiredSize(verbose);
    }
    
    // Automatically generated method stub
    int32_t PermissionRequestEvidence::InitFromBuffer_c92c70723ded1d45(cli::array<char16_t>* buffer, int32_t position) {
        return InitFromBuffer(buffer, position);
    }
    
    // Automatically generated method stub
    int32_t PermissionRequestEvidence::OutputToBuffer_c67224525da6df65(cli::array<char16_t>* buffer, int32_t position, bool verbose) {
        return OutputToBuffer(buffer, position, verbose);
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    // Automatically generated method stub
    void PolicyStatement::FromXml_1053a148f0375461(System::Security::SecurityElement* et) {
        return FromXml(et);
    }
    
    // Automatically generated method stub
    void PolicyStatement::FromXml_d33f37a1ca3b24b6(System::Security::SecurityElement* et, PolicyLevel* level) {
        return FromXml2(et, level);
    }
    
    // Automatically generated method stub
    System::Security::SecurityElement* PolicyStatement::ToXml_4868e697107d327() {
        return ToXml();
    }
    
    // Automatically generated method stub
    System::Security::SecurityElement* PolicyStatement::ToXml_7ef261149cc39102(PolicyLevel* level) {
        return ToXml2(level);
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    // Automatically generated method stub
    System::Security::IPermission* Publisher::CreateIdentityPermission_889b07b8aadbac79(Evidence* evidence) {
        return CreateIdentityPermission(evidence);
    }
    
    // Automatically generated method stub
    int32_t Publisher::GetRequiredSize_d6a347da59603f2e(bool verbose) {
        return GetRequiredSize(verbose);
    }
    
    // Automatically generated method stub
    int32_t Publisher::InitFromBuffer_c92c70723ded1d45(cli::array<char16_t>* buffer, int32_t position) {
        return InitFromBuffer(buffer, position);
    }
    
    // Automatically generated method stub
    int32_t Publisher::OutputToBuffer_c67224525da6df65(cli::array<char16_t>* buffer, int32_t position, bool verbose) {
        return OutputToBuffer(buffer, position, verbose);
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    // Automatically generated method stub
    bool PublisherMembershipCondition::Check_40359438a47300d0(Evidence* evidence) {
        return Check(evidence);
    }
    
    // Automatically generated method stub
    IMembershipCondition* PublisherMembershipCondition::Copy_44d120d5c8a6f573() {
        return Copy();
    }
    
    // Automatically generated method stub
    bool PublisherMembershipCondition::Equals_4b738171fe6c9984(System::Object* o) {
        return Equals_ed975d2f4a7d193e(o);
    }
    
    // Automatically generated method stub
    void PublisherMembershipCondition::FromXml_1053a148f0375461(System::Security::SecurityElement* e) {
        return FromXml(e);
    }
    
    // Automatically generated method stub
    void PublisherMembershipCondition::FromXml_d33f37a1ca3b24b6(System::Security::SecurityElement* e, PolicyLevel* level) {
        return FromXml2(e, level);
    }
    
    // Automatically generated method stub
    System::String* PublisherMembershipCondition::ToString_427da0d8da742df9() {
        return ToString_1636a0751cb9ac11();
    }
    
    // Automatically generated method stub
    System::Security::SecurityElement* PublisherMembershipCondition::ToXml_4868e697107d327() {
        return ToXml();
    }
    
    // Automatically generated method stub
    System::Security::SecurityElement* PublisherMembershipCondition::ToXml_7ef261149cc39102(PolicyLevel* level) {
        return ToXml2(level);
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    // Automatically generated method stub
    System::Security::IPermission* Site::CreateIdentityPermission_889b07b8aadbac79(Evidence* evidence) {
        return CreateIdentityPermission(evidence);
    }
    
    // Automatically generated method stub
    int32_t Site::GetRequiredSize_d6a347da59603f2e(bool verbose) {
        return GetRequiredSize(verbose);
    }
    
    // Automatically generated method stub
    int32_t Site::InitFromBuffer_c92c70723ded1d45(cli::array<char16_t>* buffer, int32_t position) {
        return InitFromBuffer(buffer, position);
    }
    
    // Automatically generated method stub
    int32_t Site::OutputToBuffer_c67224525da6df65(cli::array<char16_t>* buffer, int32_t position, bool verbose) {
        return OutputToBuffer(buffer, position, verbose);
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    // Automatically generated method stub
    bool SiteMembershipCondition::Check_40359438a47300d0(Evidence* evidence) {
        return Check(evidence);
    }
    
    // Automatically generated method stub
    IMembershipCondition* SiteMembershipCondition::Copy_44d120d5c8a6f573() {
        return Copy();
    }
    
    // Automatically generated method stub
    bool SiteMembershipCondition::Equals_4b738171fe6c9984(System::Object* o) {
        return Equals_ed975d2f4a7d193e(o);
    }
    
    // Automatically generated method stub
    void SiteMembershipCondition::FromXml_1053a148f0375461(System::Security::SecurityElement* e) {
        return FromXml(e);
    }
    
    // Automatically generated method stub
    void SiteMembershipCondition::FromXml_d33f37a1ca3b24b6(System::Security::SecurityElement* e, PolicyLevel* level) {
        return FromXml2(e, level);
    }
    
    // Automatically generated method stub
    System::String* SiteMembershipCondition::ToString_427da0d8da742df9() {
        return ToString_1636a0751cb9ac11();
    }
    
    // Automatically generated method stub
    System::Security::SecurityElement* SiteMembershipCondition::ToXml_4868e697107d327() {
        return ToXml();
    }
    
    // Automatically generated method stub
    System::Security::SecurityElement* SiteMembershipCondition::ToXml_7ef261149cc39102(PolicyLevel* level) {
        return ToXml2(level);
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    // Automatically generated method stub
    System::Security::IPermission* StrongName2::CreateIdentityPermission_889b07b8aadbac79(Evidence* evidence) {
        return CreateIdentityPermission(evidence);
    }
    
    // Automatically generated method stub
    int32_t StrongName2::GetRequiredSize_d6a347da59603f2e(bool verbose) {
        return GetRequiredSize(verbose);
    }
    
    // Automatically generated method stub
    int32_t StrongName2::InitFromBuffer_c92c70723ded1d45(cli::array<char16_t>* buffer, int32_t position) {
        return InitFromBuffer(buffer, position);
    }
    
    // Automatically generated method stub
    int32_t StrongName2::OutputToBuffer_c67224525da6df65(cli::array<char16_t>* buffer, int32_t position, bool verbose) {
        return OutputToBuffer(buffer, position, verbose);
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    // Automatically generated method stub
    bool StrongNameMembershipCondition::Check_40359438a47300d0(Evidence* evidence) {
        return Check(evidence);
    }
    
    // Automatically generated method stub
    IMembershipCondition* StrongNameMembershipCondition::Copy_44d120d5c8a6f573() {
        return Copy();
    }
    
    // Automatically generated method stub
    bool StrongNameMembershipCondition::Equals_4b738171fe6c9984(System::Object* o) {
        return Equals_ed975d2f4a7d193e(o);
    }
    
    // Automatically generated method stub
    void StrongNameMembershipCondition::FromXml_1053a148f0375461(System::Security::SecurityElement* e) {
        return FromXml(e);
    }
    
    // Automatically generated method stub
    void StrongNameMembershipCondition::FromXml_d33f37a1ca3b24b6(System::Security::SecurityElement* e, PolicyLevel* level) {
        return FromXml2(e, level);
    }
    
    // Automatically generated method stub
    System::String* StrongNameMembershipCondition::ToString_427da0d8da742df9() {
        return ToString_1636a0751cb9ac11();
    }
    
    // Automatically generated method stub
    System::Security::SecurityElement* StrongNameMembershipCondition::ToXml_4868e697107d327() {
        return ToXml();
    }
    
    // Automatically generated method stub
    System::Security::SecurityElement* StrongNameMembershipCondition::ToXml_7ef261149cc39102(PolicyLevel* level) {
        return ToXml2(level);
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    // Automatically generated method stub
    System::Security::IPermission* Url::CreateIdentityPermission_889b07b8aadbac79(Evidence* evidence) {
        return CreateIdentityPermission(evidence);
    }
    
    // Automatically generated method stub
    int32_t Url::GetRequiredSize_d6a347da59603f2e(bool verbose) {
        return GetRequiredSize(verbose);
    }
    
    // Automatically generated method stub
    int32_t Url::InitFromBuffer_c92c70723ded1d45(cli::array<char16_t>* buffer, int32_t position) {
        return InitFromBuffer(buffer, position);
    }
    
    // Automatically generated method stub
    int32_t Url::OutputToBuffer_c67224525da6df65(cli::array<char16_t>* buffer, int32_t position, bool verbose) {
        return OutputToBuffer(buffer, position, verbose);
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    // Automatically generated method stub
    bool UrlMembershipCondition::Check_40359438a47300d0(Evidence* evidence) {
        return Check(evidence);
    }
    
    // Automatically generated method stub
    IMembershipCondition* UrlMembershipCondition::Copy_44d120d5c8a6f573() {
        return Copy();
    }
    
    // Automatically generated method stub
    bool UrlMembershipCondition::Equals_4b738171fe6c9984(System::Object* o) {
        return Equals_ed975d2f4a7d193e(o);
    }
    
    // Automatically generated method stub
    void UrlMembershipCondition::FromXml_1053a148f0375461(System::Security::SecurityElement* e) {
        return FromXml(e);
    }
    
    // Automatically generated method stub
    void UrlMembershipCondition::FromXml_d33f37a1ca3b24b6(System::Security::SecurityElement* e, PolicyLevel* level) {
        return FromXml2(e, level);
    }
    
    // Automatically generated method stub
    System::String* UrlMembershipCondition::ToString_427da0d8da742df9() {
        return ToString_1636a0751cb9ac11();
    }
    
    // Automatically generated method stub
    System::Security::SecurityElement* UrlMembershipCondition::ToXml_4868e697107d327() {
        return ToXml();
    }
    
    // Automatically generated method stub
    System::Security::SecurityElement* UrlMembershipCondition::ToXml_7ef261149cc39102(PolicyLevel* level) {
        return ToXml2(level);
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    // Automatically generated method stub
    System::Security::IPermission* Zone::CreateIdentityPermission_889b07b8aadbac79(Evidence* evidence) {
        return CreateIdentityPermission(evidence);
    }
    
    // Automatically generated method stub
    int32_t Zone::GetRequiredSize_d6a347da59603f2e(bool verbose) {
        return GetRequiredSize(verbose);
    }
    
    // Automatically generated method stub
    int32_t Zone::InitFromBuffer_c92c70723ded1d45(cli::array<char16_t>* buffer, int32_t position) {
        return InitFromBuffer(buffer, position);
    }
    
    // Automatically generated method stub
    int32_t Zone::OutputToBuffer_c67224525da6df65(cli::array<char16_t>* buffer, int32_t position, bool verbose) {
        return OutputToBuffer(buffer, position, verbose);
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    // Automatically generated method stub
    bool ZoneMembershipCondition::Check_40359438a47300d0(Evidence* evidence) {
        return Check(evidence);
    }
    
    // Automatically generated method stub
    IMembershipCondition* ZoneMembershipCondition::Copy_44d120d5c8a6f573() {
        return Copy();
    }
    
    // Automatically generated method stub
    bool ZoneMembershipCondition::Equals_4b738171fe6c9984(System::Object* o) {
        return Equals_ed975d2f4a7d193e(o);
    }
    
    // Automatically generated method stub
    void ZoneMembershipCondition::FromXml_1053a148f0375461(System::Security::SecurityElement* e) {
        return FromXml(e);
    }
    
    // Automatically generated method stub
    void ZoneMembershipCondition::FromXml_d33f37a1ca3b24b6(System::Security::SecurityElement* e, PolicyLevel* level) {
        return FromXml2(e, level);
    }
    
    // Automatically generated method stub
    System::String* ZoneMembershipCondition::ToString_427da0d8da742df9() {
        return ToString_1636a0751cb9ac11();
    }
    
    // Automatically generated method stub
    System::Security::SecurityElement* ZoneMembershipCondition::ToXml_4868e697107d327() {
        return ToXml();
    }
    
    // Automatically generated method stub
    System::Security::SecurityElement* ZoneMembershipCondition::ToXml_7ef261149cc39102(PolicyLevel* level) {
        return ToXml2(level);
    }
    
}}}
namespace System { namespace Security { namespace Principal {
    // Automatically generated method stub
    System::String* GenericIdentity::get_AuthenticationType_fde3461ee63fdcbc() {
        return get_AuthenticationType_cb7e4615cad01a4c();
    }
    
    // Automatically generated method stub
    System::String* GenericIdentity::get_Name_b724867acffa5fcd() {
        return get_Name_e32680458218f597();
    }
    
    // Automatically generated method stub
    bool GenericIdentity::get_IsAuthenticated_3494858dba7d3668() {
        return get_IsAuthenticated_d3ad26d9503a0e79();
    }
    
}}}
namespace System { namespace Security { namespace Principal {
    // Automatically generated method stub
    bool GenericPrincipal::IsInRole_3999c98ebfe5d242(System::String* role) {
        return IsInRole_230762285381dcaa(role);
    }
    
    // Automatically generated method stub
    IIdentity* GenericPrincipal::get_Identity_8451efd6a7a604b6() {
        return get_Identity_ace87d10090e7749();
    }
    
}}}
namespace System { namespace Security { namespace Principal {
    // Automatically generated method stub
    void IdentityReferenceCollection::Add_a6fc54bc2aa3c029(IdentityReference* identity) {
        return Add(identity);
    }
    
    // Automatically generated method stub
    void IdentityReferenceCollection::Clear_16ef3c35b14f77a2() {
        return Clear();
    }
    
    // Automatically generated method stub
    bool IdentityReferenceCollection::Contains_ca946a648e63e62e(IdentityReference* identity) {
        return Contains(identity);
    }
    
    // Automatically generated method stub
    void IdentityReferenceCollection::CopyTo_e6884c04285bc976(cli::array<IdentityReference*>* array, int32_t offset) {
        return CopyTo(array, offset);
    }
    
    // Automatically generated method stub
    System::Collections::Generic::IEnumerator2<IdentityReference*>* IdentityReferenceCollection::GetEnumerator_ad4887f30f9e4c5() {
        return GetEnumerator();
    }
    
    // Automatically generated method stub
    System::Collections::IEnumerator* IdentityReferenceCollection::GetEnumerator_674ad93a972a4d67() {
        return GetEnumerator2();
    }
    
    // Automatically generated method stub
    bool IdentityReferenceCollection::Remove_67948971902d0cce(IdentityReference* identity) {
        return Remove(identity);
    }
    
    // Automatically generated method stub
    int32_t IdentityReferenceCollection::get_Count_a9c25d5c244affb9() {
        return get_Count();
    }
    
    // Automatically generated method stub
    bool IdentityReferenceCollection::get_IsReadOnly_9569eb0bb1daa9b5() {
        return get_IsReadOnly();
    }
    
}}}
namespace System { namespace Security { namespace Principal {
    // Automatically generated method stub
    int32_t SecurityIdentifier::CompareTo_8a8b7d6c83beb422(SecurityIdentifier* sid) {
        return CompareTo(sid);
    }
    
}}}
namespace System { namespace Security { namespace Principal {
    // Automatically generated method stub
    void WindowsIdentity::Dispose_95cb2516542c2f97() {
        return Dispose();
    }
    
    // Automatically generated method stub
    void WindowsIdentity::OnDeserialization_e9ecfecba8df9754(System::Object* sender) {
        return OnDeserialization(sender);
    }
    
    // Automatically generated method stub
    void WindowsIdentity::GetObjectData_11b895a112e04409(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        return GetObjectData(info, context);
    }
    
    // Automatically generated method stub
    System::String* WindowsIdentity::get_AuthenticationType_fde3461ee63fdcbc() {
        return get_AuthenticationType();
    }
    
    // Automatically generated method stub
    bool WindowsIdentity::get_IsAuthenticated_3494858dba7d3668() {
        return get_IsAuthenticated_f18be2c360fd9fab();
    }
    
    // Automatically generated method stub
    System::String* WindowsIdentity::get_Name_b724867acffa5fcd() {
        return get_Name_4712160195308583();
    }
    
}}}
namespace System { namespace Security { namespace Principal {
    // Automatically generated method stub
    void WindowsImpersonationContext::Dispose_95cb2516542c2f97() {
        return Dispose();
    }
    
}}}
namespace System { namespace Security { namespace Principal {
    // Automatically generated method stub
    bool WindowsPrincipal::IsInRole_3999c98ebfe5d242(System::String* role) {
        return IsInRole_60b2cbc4fd38dbd6(role);
    }
    
    // Automatically generated method stub
    IIdentity* WindowsPrincipal::get_Identity_8451efd6a7a604b6() {
        return get_Identity_d9c071c6a431dde4();
    }
    
}}}
namespace System { namespace Text {
    // Automatically generated method stub
    void Decoder::GetObjectData_11b895a112e04409(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        return GetObjectData(info, context);
    }
    
    // Automatically generated method stub
    System::Object* Decoder::GetRealObject_692566897a6926e4(System::Runtime::Serialization::StreamingContext context) {
        return GetRealObject(context);
    }
    
}}
namespace System { namespace Text {
    // Automatically generated method stub
    void CodePageEncoding::GetObjectData_11b895a112e04409(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        return GetObjectData(info, context);
    }
    
    // Automatically generated method stub
    System::Object* CodePageEncoding::GetRealObject_692566897a6926e4(System::Runtime::Serialization::StreamingContext context) {
        return GetRealObject(context);
    }
    
}}
namespace System { namespace Text {
    // Automatically generated method stub
    System::Object* Encoding::Clone_d5efb96d327809c8() {
        return Clone_c7ab6a38a8e4176e();
    }
    
}}
namespace System { namespace Text {
    // Automatically generated method stub
    void MLangEncoder::GetObjectData_11b895a112e04409(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        return GetObjectData(info, context);
    }
    
    // Automatically generated method stub
    System::Object* MLangEncoder::GetRealObject_692566897a6926e4(System::Runtime::Serialization::StreamingContext context) {
        return GetRealObject(context);
    }
    
}}
namespace System { namespace Text {
    // Automatically generated method stub
    void MLangDecoder::GetObjectData_11b895a112e04409(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        return GetObjectData(info, context);
    }
    
    // Automatically generated method stub
    System::Object* MLangDecoder::GetRealObject_692566897a6926e4(System::Runtime::Serialization::StreamingContext context) {
        return GetRealObject(context);
    }
    
}}
namespace System { namespace Text {
    // Automatically generated method stub
    void MLangCodePageEncoding::GetObjectData_11b895a112e04409(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        return GetObjectData(info, context);
    }
    
    // Automatically generated method stub
    System::Object* MLangCodePageEncoding::GetRealObject_692566897a6926e4(System::Runtime::Serialization::StreamingContext context) {
        return GetRealObject(context);
    }
    
}}
namespace System { namespace Text {
    // Automatically generated method stub
    void StringBuilder::GetObjectData_11b895a112e04409(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        return GetObjectData(info, context);
    }
    
}}
namespace System { namespace Text {
    // Automatically generated method stub
    void SurrogateEncoder::GetObjectData_11b895a112e04409(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        return GetObjectData(info, context);
    }
    
    // Automatically generated method stub
    System::Object* SurrogateEncoder::GetRealObject_692566897a6926e4(System::Runtime::Serialization::StreamingContext context) {
        return GetRealObject(context);
    }
    
}}
namespace System { namespace Threading {
    // Automatically generated method stub
    void CancellationTokenSource::Dispose_95cb2516542c2f97() {
        return Dispose();
    }
    
}}
namespace System { namespace Threading {
    // Automatically generated method stub
    void CompressedStack::GetObjectData_11b895a112e04409(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        return GetObjectData(info, context);
    }
    
}}
namespace System { namespace Threading {
    // Automatically generated method stub
    void CountdownEvent::Dispose_95cb2516542c2f97() {
        return Dispose();
    }
    
}}
namespace System { namespace Threading {
    // Automatically generated method stub
    void ExecutionContext::Dispose_95cb2516542c2f97() {
        return Dispose();
    }
    
    // Automatically generated method stub
    void ExecutionContext::GetObjectData_11b895a112e04409(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        return GetObjectData(info, context);
    }
    
}}
namespace System { namespace Threading {
    // Automatically generated method stub
    void ManualResetEventSlim::Dispose_95cb2516542c2f97() {
        return Dispose();
    }
    
}}
namespace System { namespace Threading {
    // Automatically generated method stub
    void SemaphoreSlim::Dispose_95cb2516542c2f97() {
        return Dispose();
    }
    
}}
namespace System { namespace Threading {
    // Automatically generated method stub
    void Thread::GetIDsOfNames_bfbc2a83417e35a7(System::Guid riid, void* rgszNames, uint32_t cNames, uint32_t lcid, void* rgDispId) {
        return GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    }
    
    // Automatically generated method stub
    void Thread::GetTypeInfo_a6b1b13433ae4421(uint32_t iTInfo, uint32_t lcid, void* ppTInfo) {
        return GetTypeInfo(iTInfo, lcid, ppTInfo);
    }
    
    // Automatically generated method stub
    void Thread::GetTypeInfoCount_6bfe4438aac4352c(uint32_t pcTInfo) {
        return GetTypeInfoCount(pcTInfo);
    }
    
    // Automatically generated method stub
    void Thread::Invoke_961292518f6793ed(uint32_t dispIdMember, System::Guid riid, uint32_t lcid, int16_t wFlags, void* pDispParams, void* pVarResult, void* pExcepInfo, void* puArgErr) {
        return Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    }
    
}}
namespace System { namespace Threading {
}}
namespace System { namespace Threading {
    // Automatically generated method stub
    int32_t TimerComparer::Compare_451fd276747b629d(System::Object* x, System::Object* y) {
        return Compare(x, y);
    }
    
}}
namespace System { namespace Threading {
    // Automatically generated method stub
    void Timer::Dispose_95cb2516542c2f97() {
        return Dispose();
    }
    
}}
namespace System { namespace Threading {
    // Automatically generated method stub
    void WaitHandle::Dispose_95cb2516542c2f97() {
        return Dispose();
    }
    
}}
namespace System { namespace Threading { namespace Tasks {
}}}
namespace System { namespace Threading { namespace Tasks {
    // Automatically generated method stub
    void ManualEventSlot::Execute_e0ae61e6f450d11e() {
        return Execute();
    }
    
}}}
namespace System { namespace Threading { namespace Tasks {
    // Automatically generated method stub
    void CountdownEventSlot::Execute_e0ae61e6f450d11e() {
        return Execute();
    }
    
}}}
namespace System { namespace Threading { namespace Tasks {
    // Automatically generated method stub
    void Task::Dispose_95cb2516542c2f97() {
        return Dispose();
    }
    
    // Automatically generated method stub
    bool Task::get_IsCompleted_908b07d70649b7ff() {
        return get_IsCompleted();
    }
    
    // Automatically generated method stub
    System::Object* Task::get_AsyncState_edfadcd905632437() {
        return get_AsyncState();
    }
    
    // Automatically generated method stub
    bool Task::get_CompletedSynchronously_2176ca6518f7b5dc() {
        return get_CompletedSynchronously();
    }
    
    // Automatically generated method stub
    System::Threading::WaitHandle* Task::get_AsyncWaitHandle_7620505c49d113f3() {
        return get_AsyncWaitHandle();
    }
    
}}}
namespace System { namespace Threading { namespace Tasks {
    // Automatically generated method stub
    void TaskContinuation::Execute_e0ae61e6f450d11e() {
        return Execute();
    }
    
}}}
namespace System { namespace Threading { namespace Tasks {
    // Automatically generated method stub
    void ActionContinuation::Execute_e0ae61e6f450d11e() {
        return Execute();
    }
    
}}}
namespace System { namespace Threading { namespace Tasks {
    // Automatically generated method stub
    void SynchronizationContextContinuation::Execute_e0ae61e6f450d11e() {
        return Execute();
    }
    
}}}
namespace Microsoft { namespace Win32 { namespace SafeHandles {
    // Automatically generated method stub
    void CriticalHandleMinusOneIsInvalid::Dispose_95cb2516542c2f97() {
        return Dispose();
    }
    
}}}
namespace Microsoft { namespace Win32 { namespace SafeHandles {
    // Automatically generated method stub
    void CriticalHandleZeroOrMinusOneIsInvalid::Dispose_95cb2516542c2f97() {
        return Dispose();
    }
    
}}}
namespace Microsoft { namespace Win32 { namespace SafeHandles {
    // Automatically generated method stub
    void SafeHandleMinusOneIsInvalid::Dispose_95cb2516542c2f97() {
        return Dispose();
    }
    
}}}
namespace Microsoft { namespace Win32 { namespace SafeHandles {
    // Automatically generated method stub
    void SafeHandleZeroOrMinusOneIsInvalid::Dispose_95cb2516542c2f97() {
        return Dispose();
    }
    
}}}
namespace Microsoft { namespace Win32 { namespace SafeHandles {
    // Automatically generated method stub
    void SafeRegistryHandle::Dispose_95cb2516542c2f97() {
        return Dispose();
    }
    
}}}
namespace System { namespace Collections { namespace Generic {
    // Automatically generated method stub
    void KeyNotFoundException::GetObjectData_11b895a112e04409(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        return GetObjectData_bc9b88d7eb43b6d8(info, context);
    }
    
}}}
namespace System { namespace Runtime { namespace InteropServices {
    // Automatically generated method stub
    void SafeBuffer::Dispose_95cb2516542c2f97() {
        return Dispose();
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    // Automatically generated method stub
    bool CryptographicException::Equals_8745d1c324afa9f2(System::Object* obj) {
        return Equals_ed975d2f4a7d193e(obj);
    }
    
    // Automatically generated method stub
    System::Exception* CryptographicException::GetBaseException_253c3eebfe2fed4a() {
        return GetBaseException_3c80088934e2347b();
    }
    
    // Automatically generated method stub
    int32_t CryptographicException::GetHashCode_3274e1baccc4f8d1() {
        return GetHashCode_6648aef0f235ee6c();
    }
    
    // Automatically generated method stub
    void CryptographicException::GetObjectData_cacfaf455dbef0a5(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        return GetObjectData_bc9b88d7eb43b6d8(info, context);
    }
    
    // Automatically generated method stub
    System::Type* CryptographicException::GetType_74b1e7e5e0897ded() {
        return GetType2();
    }
    
    // Automatically generated method stub
    System::String* CryptographicException::ToString_118e365de8f6791a() {
        return ToString_1636a0751cb9ac11();
    }
    
    // Automatically generated method stub
    System::String* CryptographicException::get_HelpLink_c746e07ff3b23b1d() {
        return get_HelpLink_523fb8e8db786972();
    }
    
    // Automatically generated method stub
    System::String* CryptographicException::set_HelpLink_c6d532780c9a4ffa(System::String* value) {
        return set_HelpLink_dc2ca9999b121201(value);
    }
    
    // Automatically generated method stub
    System::Exception* CryptographicException::get_InnerException_fee5e87d6404fbbb() {
        return get_InnerException();
    }
    
    // Automatically generated method stub
    System::String* CryptographicException::get_Message_236e49c6b265ab9b() {
        return get_Message_d211df4045b57cbf();
    }
    
    // Automatically generated method stub
    System::String* CryptographicException::get_Source_1ad0ababbacddeca() {
        return get_Source_fe63b25bfdf963b9();
    }
    
    // Automatically generated method stub
    System::String* CryptographicException::set_Source_593b7183e562d37d(System::String* value) {
        return set_Source_4a11d6bd5ca37e45(value);
    }
    
    // Automatically generated method stub
    System::String* CryptographicException::get_StackTrace_eedb0499938735b7() {
        return get_StackTrace_f3fc28619b4f921();
    }
    
    // Automatically generated method stub
    System::Reflection::MethodBase* CryptographicException::get_TargetSite_d5a44210796e0db() {
        return get_TargetSite();
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    // Automatically generated method stub
    bool PolicyException::Equals_8745d1c324afa9f2(System::Object* obj) {
        return Equals_ed975d2f4a7d193e(obj);
    }
    
    // Automatically generated method stub
    System::Exception* PolicyException::GetBaseException_253c3eebfe2fed4a() {
        return GetBaseException_3c80088934e2347b();
    }
    
    // Automatically generated method stub
    int32_t PolicyException::GetHashCode_3274e1baccc4f8d1() {
        return GetHashCode_6648aef0f235ee6c();
    }
    
    // Automatically generated method stub
    void PolicyException::GetObjectData_cacfaf455dbef0a5(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        return GetObjectData_bc9b88d7eb43b6d8(info, context);
    }
    
    // Automatically generated method stub
    System::Type* PolicyException::GetType_74b1e7e5e0897ded() {
        return GetType2();
    }
    
    // Automatically generated method stub
    System::String* PolicyException::ToString_118e365de8f6791a() {
        return ToString_1636a0751cb9ac11();
    }
    
    // Automatically generated method stub
    System::String* PolicyException::get_HelpLink_c746e07ff3b23b1d() {
        return get_HelpLink_523fb8e8db786972();
    }
    
    // Automatically generated method stub
    System::String* PolicyException::set_HelpLink_c6d532780c9a4ffa(System::String* value) {
        return set_HelpLink_dc2ca9999b121201(value);
    }
    
    // Automatically generated method stub
    System::Exception* PolicyException::get_InnerException_fee5e87d6404fbbb() {
        return get_InnerException();
    }
    
    // Automatically generated method stub
    System::String* PolicyException::get_Message_236e49c6b265ab9b() {
        return get_Message_d211df4045b57cbf();
    }
    
    // Automatically generated method stub
    System::String* PolicyException::get_Source_1ad0ababbacddeca() {
        return get_Source_fe63b25bfdf963b9();
    }
    
    // Automatically generated method stub
    System::String* PolicyException::set_Source_593b7183e562d37d(System::String* value) {
        return set_Source_4a11d6bd5ca37e45(value);
    }
    
    // Automatically generated method stub
    System::String* PolicyException::get_StackTrace_eedb0499938735b7() {
        return get_StackTrace_f3fc28619b4f921();
    }
    
    // Automatically generated method stub
    System::Reflection::MethodBase* PolicyException::get_TargetSite_d5a44210796e0db() {
        return get_TargetSite();
    }
    
}}}
namespace Mono { namespace Globalization { namespace Unicode {
    
    
    void TableRange::constructor(int32_t start, int32_t end, int32_t indexStart) {
        (*this)->Start = start;
        (*this)->End = end;
        (*this)->Count = ((*this)->End - (*this)->Start);
        (*this)->IndexStart = indexStart;
        (*this)->IndexEnd = ((*this)->IndexStart + (*this)->Count);
    }
    
}}}
namespace Mono { namespace Globalization { namespace Unicode {
    
    
    void SortKeyValue::constructor(bool alt, uint16_t v1, unsigned char v2, unsigned char v3, int32_t v4) {
        (*this)->Alt = alt;
        (*this)->Primary = v1;
        (*this)->Secondary = v2;
        (*this)->Thirtiary = v3;
        (*this)->Quarternary = v4;
    }
    
}}}
namespace Mono { namespace Globalization { namespace Unicode {
    
    
    void Context::constructor(System::Globalization::CompareOptions opt, unsigned char* alwaysMatchFlags, unsigned char* neverMatchFlags, unsigned char* buffer1, unsigned char* buffer2, unsigned char* prev1, bool quickCheckPossible) {
        (*this)->Option = opt;
        (*this)->AlwaysMatchFlags = alwaysMatchFlags;
        (*this)->NeverMatchFlags = neverMatchFlags;
        (*this)->Buffer1 = buffer1;
        (*this)->Buffer2 = buffer2;
        (*this)->PrevSortKey = prev1;
        (*this)->PrevCode = -1;
        (*this)->QuickCheckPossible = quickCheckPossible;
    }
    
    void Context::ClearPrevInfo() {
        (*this)->PrevCode = -1;
        (*this)->PrevSortKey = nullptr;
    }
    
}}}
namespace Mono { namespace Globalization { namespace Unicode {
    
    
    void PreviousInfo::constructor(bool dummy) {
        (*this)->Code = -1;
        (*this)->SortKey2 = nullptr;
    }
    
}}}
namespace Mono { namespace Globalization { namespace Unicode {
    
    
}}}
namespace Mono { namespace Security {
    
    
    void UriScheme::constructor(System::String* s, System::String* d, int32_t p) {
        (*this)->scheme = s;
        (*this)->delimiter = d;
        (*this)->defaultPort = p;
    }
    
}}
namespace System {
    
    
    void ArgIterator::constructor(RuntimeArgumentHandle arglist) {
        (*this)->sig = (*::System::IntPtr::Zero);
        (*this)->args = (*::System::IntPtr::Zero);
        (*this)->next_arg = (*this)->num_args = 0;
        Setup(arglist->args, (*::System::IntPtr::Zero));
    }
    
    void ArgIterator::constructor(RuntimeArgumentHandle arglist, void* ptr) {
        (*this)->sig = (*::System::IntPtr::Zero);
        (*this)->args = (*::System::IntPtr::Zero);
        (*this)->next_arg = (*this)->num_args = 0;
        Setup(arglist->args, (void*)ptr);
    }
    
    void ArgIterator::Setup(void* argsp, void* start) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void ArgIterator::End() {
        (*this)->next_arg = (*this)->num_args;
    }
    
    bool ArgIterator::Equals_ed975d2f4a7d193e(Object* o) {
        throw cli::gcnew<NotSupportedException>(Locale::GetText(_T("ArgIterator does not support Equals.")));
    }
    
    int32_t ArgIterator::GetHashCode_6648aef0f235ee6c() {
        return cli::import((*this)->sig)->GetHashCode_6648aef0f235ee6c();
    }
    
    TypedReference ArgIterator::GetNextArg() {
        if(((*this)->num_args ==  (*this)->next_arg)) 
        {
            throw cli::gcnew<InvalidOperationException>(Locale::GetText(_T("Invalid iterator position.")));
        }
        return IntGetNextArg();
    }
    
    TypedReference ArgIterator::IntGetNextArg() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    TypedReference ArgIterator::GetNextArg2(RuntimeTypeHandle rth) {
        if(((*this)->num_args ==  (*this)->next_arg)) 
        {
            throw cli::gcnew<InvalidOperationException>(Locale::GetText(_T("Invalid iterator position.")));
        }
        return IntGetNextArg2(rth->get_Value());
    }
    
    TypedReference ArgIterator::IntGetNextArg2(void* rth) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    RuntimeTypeHandle ArgIterator::GetNextArgType() {
        if(((*this)->num_args ==  (*this)->next_arg)) 
        {
            throw cli::gcnew<InvalidOperationException>(Locale::GetText(_T("Invalid iterator position.")));
        }
        return cli::ctor<RuntimeTypeHandle>(IntGetNextArgType());
    }
    
    void* ArgIterator::IntGetNextArgType() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t ArgIterator::GetRemainingCount() {
        return ((*this)->num_args - (*this)->next_arg);
    }
    
}
namespace System {
    
    
}
namespace System {
    
    
}
namespace System {
    
    String*  Boolean::FalseString;
    String*  Boolean::TrueString;
    
    void Boolean::static_constructor() {
    }
    
    int32_t Boolean::CompareTo(Object* obj) {
        if((obj ==  nullptr)) 
        {
            return 1;
        }
        if(!(cli::is<Boolean>(obj))) 
        {
            throw cli::gcnew<ArgumentException>(Locale::GetText(_T("Object is not a Boolean.")));
        }
        bool value = cli::unbox<bool>(obj);
        if((cli::import((*this))->m_value && !(value))) 
        {
            return 1;
        }
        return (cli::import((*this))->m_value ==  value) ? 0 : -1;
    }
    
    bool Boolean::Equals_ed975d2f4a7d193e(Object* obj) {
        if(((obj ==  nullptr) || !(cli::is<Boolean>(obj)))) 
        {
            return false;
        }
        bool value = cli::unbox<bool>(obj);
        return cli::import((*this))->m_value ? value : !(value);
    }
    
    int32_t Boolean::CompareTo2(bool value) {
        if((cli::import((*this))->m_value ==  value)) 
        {
            return 0;
        }
        return !(cli::import((*this))->m_value) ? -1 : 1;
    }
    
    bool Boolean::Equals2(bool obj) {
        return (cli::import((*this))->m_value ==  obj);
    }
    
    int32_t Boolean::GetHashCode_6648aef0f235ee6c() {
        return cli::import((*this))->m_value ? 1 : 0;
    }
    
    bool Boolean::Parse(String* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("value"));
        }
        value = value->Trim();
        if((String::Compare3(value, TrueString, true, Globalization::CultureInfo::get_InvariantCulture()) ==  0)) 
        {
            return true;
        }
        if((String::Compare3(value, FalseString, true, Globalization::CultureInfo::get_InvariantCulture()) ==  0)) 
        {
            return false;
        }
        throw cli::gcnew<FormatException>(Locale::GetText(_T("Value is not equivalent to either TrueString or FalseString.")));
    }
    
    bool Boolean::TryParse(String* value, bool result) {
        result = false;
        if((value ==  nullptr)) 
        {
            return false;
        }
        value = value->Trim();
        if((String::Compare3(value, TrueString, true, Globalization::CultureInfo::get_InvariantCulture()) ==  0)) 
        {
            result = true;
            return true;
        }
        if((String::Compare3(value, FalseString, true, Globalization::CultureInfo::get_InvariantCulture()) ==  0)) 
        {
            return true;
        }
        return false;
    }
    
    String* Boolean::ToString_1636a0751cb9ac11() {
        return cli::import((*this))->m_value ? TrueString : FalseString;
    }
    
    TypeCode Boolean::GetTypeCode() {
        return TypeCode::Boolean2;
    }
    
    Object* Boolean::ToType(Type* targetType, IFormatProvider* provider) {
        if(Type::op_Equality2(targetType, nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("targetType"));
        }
        return Convert::ToType(cli::box(cli::import((*this))->m_value), targetType, provider, false);
    }
    
    bool Boolean::ToBoolean(IFormatProvider* provider) {
        return cli::import((*this))->m_value;
    }
    
    unsigned char Boolean::ToByte(IFormatProvider* provider) {
        return Convert::ToByte(cli::import((*this))->m_value);
    }
    
    char16_t Boolean::ToChar(IFormatProvider* provider) {
        throw cli::gcnew<InvalidCastException>();
    }
    
    DateTime Boolean::ToDateTime(IFormatProvider* provider) {
        throw cli::gcnew<InvalidCastException>();
    }
    
    Decimal Boolean::ToDecimal(IFormatProvider* provider) {
        return Convert::ToDecimal(cli::import((*this))->m_value);
    }
    
    double Boolean::ToDouble(IFormatProvider* provider) {
        return Convert::ToDouble(cli::import((*this))->m_value);
    }
    
    int16_t Boolean::ToInt16(IFormatProvider* provider) {
        return Convert::ToInt16(cli::import((*this))->m_value);
    }
    
    int32_t Boolean::ToInt32(IFormatProvider* provider) {
        return Convert::ToInt32(cli::import((*this))->m_value);
    }
    
    int64_t Boolean::ToInt64(IFormatProvider* provider) {
        return Convert::ToInt64(cli::import((*this))->m_value);
    }
    
    signed char Boolean::ToSByte(IFormatProvider* provider) {
        return Convert::ToSByte(cli::import((*this))->m_value);
    }
    
    float Boolean::ToSingle(IFormatProvider* provider) {
        return Convert::ToSingle(cli::import((*this))->m_value);
    }
    
    String* Boolean::ToString3(IFormatProvider* provider) {
        return Object::ToString_1636a0751cb9ac11();
    }
    
    uint16_t Boolean::ToUInt16(IFormatProvider* provider) {
        return Convert::ToUInt16(cli::import((*this))->m_value);
    }
    
    uint32_t Boolean::ToUInt32(IFormatProvider* provider) {
        return Convert::ToUInt32(cli::import((*this))->m_value);
    }
    
    uint64_t Boolean::ToUInt64(IFormatProvider* provider) {
        return Convert::ToUInt64(cli::import((*this))->m_value);
    }
    
}
namespace System {
    
    
    int32_t Byte::CompareTo(Object* value) {
        if((value ==  nullptr)) 
        {
            return 1;
        }
        if(!(cli::is<Byte>(value))) 
        {
            throw cli::gcnew<ArgumentException>(Locale::GetText(_T("Value is not a System.Byte.")));
        }
        unsigned char xv = cli::unbox<unsigned char>(value);
        if(((int32_t)(cli::import((*this))->m_value) ==  (int32_t)(xv))) 
        {
            return 0;
        }
        if(((int32_t)(cli::import((*this))->m_value) > (int32_t)(xv))) 
        {
            return 1;
        }
         else 
        {
            return -1;
        }
    }
    
    bool Byte::Equals_ed975d2f4a7d193e(Object* obj) {
        if(!(cli::is<Byte>(obj))) 
        {
            return false;
        }
        return ((int32_t)(cli::unbox<unsigned char>(obj)) ==  (int32_t)(cli::import((*this))->m_value));
    }
    
    int32_t Byte::GetHashCode_6648aef0f235ee6c() {
        return (int32_t)(cli::import((*this))->m_value);
    }
    
    int32_t Byte::CompareTo2(unsigned char value) {
        if(((int32_t)(cli::import((*this))->m_value) ==  (int32_t)(value))) 
        {
            return 0;
        }
        if(((int32_t)(cli::import((*this))->m_value) > (int32_t)(value))) 
        {
            return 1;
        }
         else 
        {
            return -1;
        }
    }
    
    bool Byte::Equals2(unsigned char obj) {
        return ((int32_t)(cli::import((*this))->m_value) ==  (int32_t)(obj));
    }
    
    unsigned char Byte::Parse(String* s, IFormatProvider* provider) {
        return Parse3(s, Globalization::NumberStyles::Integer, provider);
    }
    
    unsigned char Byte::Parse2(String* s, Globalization::NumberStyles style) {
        return Parse3(s, style, nullptr);
    }
    
    unsigned char Byte::Parse3(String* s, Globalization::NumberStyles style, IFormatProvider* provider) {
        uint32_t tmpResult = UInt32::Parse4(s, style, provider);
        if((tmpResult > 255U)) 
        {
            throw cli::gcnew<OverflowException>(Locale::GetText(_T("Value too large.")));
        }
        return (unsigned char)tmpResult;
    }
    
    unsigned char Byte::Parse4(String* s) {
        return Parse3(s, Globalization::NumberStyles::Integer, nullptr);
    }
    
    bool Byte::TryParse(String* s, unsigned char result) {
        return TryParse2(s, Globalization::NumberStyles::Integer, nullptr, result);
    }
    
    bool Byte::TryParse2(String* s, Globalization::NumberStyles style, IFormatProvider* provider, unsigned char result) {
        uint32_t tmpResult;
        result = 0;
        if(!(UInt32::TryParse2(s, style, provider, tmpResult))) 
        {
            return false;
        }
        if((tmpResult > 255U)) 
        {
            return false;
        }
        result = (unsigned char)tmpResult;
        return true;
    }
    
    String* Byte::ToString_1636a0751cb9ac11() {
        return NumberFormatter::NumberToString13((int32_t)(cli::import((*this))->m_value), nullptr);
    }
    
    String* Byte::ToString3(String* format) {
        return ToString5(format, nullptr);
    }
    
    String* Byte::ToString4(IFormatProvider* provider) {
        return NumberFormatter::NumberToString13((int32_t)(cli::import((*this))->m_value), provider);
    }
    
    String* Byte::ToString5(String* format, IFormatProvider* provider) {
        return NumberFormatter::NumberToString2(format, cli::import((*this))->m_value, provider);
    }
    
    TypeCode Byte::GetTypeCode() {
        return TypeCode::Byte2;
    }
    
    Object* Byte::ToType(Type* targetType, IFormatProvider* provider) {
        if(Type::op_Equality2(targetType, nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("targetType"));
        }
        return Convert::ToType(cli::box(cli::import((*this))->m_value), targetType, provider, false);
    }
    
    bool Byte::ToBoolean(IFormatProvider* provider) {
        return Convert::ToBoolean2(cli::import((*this))->m_value);
    }
    
    unsigned char Byte::ToByte(IFormatProvider* provider) {
        return cli::import((*this))->m_value;
    }
    
    char16_t Byte::ToChar(IFormatProvider* provider) {
        return Convert::ToChar2(cli::import((*this))->m_value);
    }
    
    DateTime Byte::ToDateTime(IFormatProvider* provider) {
        throw cli::gcnew<InvalidCastException>();
    }
    
    Decimal Byte::ToDecimal(IFormatProvider* provider) {
        return Convert::ToDecimal2(cli::import((*this))->m_value);
    }
    
    double Byte::ToDouble(IFormatProvider* provider) {
        return Convert::ToDouble2(cli::import((*this))->m_value);
    }
    
    int16_t Byte::ToInt16(IFormatProvider* provider) {
        return Convert::ToInt162(cli::import((*this))->m_value);
    }
    
    int32_t Byte::ToInt32(IFormatProvider* provider) {
        return Convert::ToInt322(cli::import((*this))->m_value);
    }
    
    int64_t Byte::ToInt64(IFormatProvider* provider) {
        return Convert::ToInt642(cli::import((*this))->m_value);
    }
    
    signed char Byte::ToSByte(IFormatProvider* provider) {
        return Convert::ToSByte2(cli::import((*this))->m_value);
    }
    
    float Byte::ToSingle(IFormatProvider* provider) {
        return Convert::ToSingle2(cli::import((*this))->m_value);
    }
    
    uint16_t Byte::ToUInt16(IFormatProvider* provider) {
        return Convert::ToUInt162(cli::import((*this))->m_value);
    }
    
    uint32_t Byte::ToUInt32(IFormatProvider* provider) {
        return Convert::ToUInt322(cli::import((*this))->m_value);
    }
    
    uint64_t Byte::ToUInt64(IFormatProvider* provider) {
        return Convert::ToUInt642(cli::import((*this))->m_value);
    }
    
}
namespace System {
    
    unsigned char*  Char::category_data;
    uint16_t*  Char::category_astral_index;
    unsigned char*  Char::numeric_data;
    double*  Char::numeric_data_values;
    uint16_t*  Char::to_lower_data_low;
    uint16_t*  Char::to_lower_data_high;
    uint16_t*  Char::to_upper_data_low;
    uint16_t*  Char::to_upper_data_high;
    unsigned char  Char::category_check_pair;
    
    void Char::static_constructor() {
        GetDataTablePointers(4, category_data, category_astral_index, numeric_data, numeric_data_values, to_lower_data_low, to_lower_data_high, to_upper_data_low, to_upper_data_high);
        category_check_pair = (category_astral_index != nullptr) ? 16 : 255;
    }
    
    void Char::GetDataTablePointers(int32_t category_data_version, unsigned char* category_data, uint16_t* category_astral_index, unsigned char* numeric_data, double* numeric_data_values, uint16_t* to_lower_data_low, uint16_t* to_lower_data_high, uint16_t* to_upper_data_low, uint16_t* to_upper_data_high) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t Char::CompareTo(Object* value) {
        if((value ==  nullptr)) 
        {
            return 1;
        }
        if(!(cli::is<Char>(value))) 
        {
            throw cli::gcnew<ArgumentException>(Locale::GetText(_T("Value is not a System.Char")));
        }
        char16_t xv = cli::unbox<char16_t>(value);
        if(((int32_t)(cli::import((*this))->m_value) ==  (int32_t)(xv))) 
        {
            return 0;
        }
        if(((int32_t)(cli::import((*this))->m_value) > (int32_t)(xv))) 
        {
            return 1;
        }
         else 
        {
            return -1;
        }
    }
    
    bool Char::Equals_ed975d2f4a7d193e(Object* obj) {
        if(!(cli::is<Char>(obj))) 
        {
            return false;
        }
        return ((int32_t)(cli::unbox<char16_t>(obj)) ==  (int32_t)(cli::import((*this))->m_value));
    }
    
    int32_t Char::CompareTo2(char16_t value) {
        if(((int32_t)(cli::import((*this))->m_value) ==  (int32_t)(value))) 
        {
            return 0;
        }
        if(((int32_t)(cli::import((*this))->m_value) > (int32_t)(value))) 
        {
            return 1;
        }
         else 
        {
            return -1;
        }
    }
    
    String* Char::ConvertFromUtf32(int32_t utf32) {
        if(((utf32 < 0) || (utf32 > 1114111))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("utf32"), _T("The argument must be from 0 to 0x10FFFF."));
        }
        if(((55296 <= utf32) && (utf32 <= 57343))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("utf32"), _T("The argument must not be in surrogate pair range."));
        }
        if((utf32 < 65536)) 
        {
            return cli::gcnew<String>((char16_t)utf32, 1);
        }
        (utf32 = utf32 - 65536);
        return cli::gcnew<String>((new cli::array<char16_t>({(Char)((utf32 >> 10) + 55296), (Char)((utf32 % 1024) + 56320)})));
    }
    
    int32_t Char::ConvertToUtf32(char16_t highSurrogate, char16_t lowSurrogate) {
        if((((int32_t)(highSurrogate) < 55296) || (56319 < (int32_t)(highSurrogate)))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("highSurrogate"));
        }
        if((((int32_t)(lowSurrogate) < 56320) || (57343 < (int32_t)(lowSurrogate)))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("lowSurrogate"));
        }
        return ((65536 + (((int32_t)(highSurrogate) - 55296) << 10)) + ((int32_t)(lowSurrogate) - 56320));
    }
    
    int32_t Char::ConvertToUtf322(String* s, int32_t index) {
        CheckParameter(s, index);
        if(!(Char::IsSurrogate(s->get_Chars(index)))) 
        {
            return (int32_t)(s->get_Chars(index));
        }
        if(((!(Char::IsHighSurrogate(s->get_Chars(index))) || (index ==  (s->get_Length() - 1))) || !(Char::IsLowSurrogate(s->get_Chars((index + 1)))))) 
        {
            throw cli::gcnew<ArgumentException>(String::Format2(_T("The string contains invalid surrogate pair character at {0}"), cli::box(index)));
        }
        return ConvertToUtf32(s->get_Chars(index), s->get_Chars((index + 1)));
    }
    
    bool Char::Equals2(char16_t obj) {
        return ((int32_t)(cli::import((*this))->m_value) ==  (int32_t)(obj));
    }
    
    bool Char::IsSurrogatePair(char16_t highSurrogate, char16_t lowSurrogate) {
        return ((((55296 <= (int32_t)(highSurrogate)) && ((int32_t)(highSurrogate) <= 56319)) && (56320 <= (int32_t)(lowSurrogate))) && ((int32_t)(lowSurrogate) <= 57343));
    }
    
    bool Char::IsSurrogatePair2(String* s, int32_t index) {
        CheckParameter(s, index);
        return (((index + 1) < s->get_Length()) && IsSurrogatePair(s->get_Chars(index), s->get_Chars((index + 1))));
    }
    
    int32_t Char::GetHashCode_6648aef0f235ee6c() {
        return (int32_t)(cli::import((*this))->m_value);
    }
    
    double Char::GetNumericValue(char16_t c) {
        if(((int32_t)(c) > 12937)) 
        {
            if((((int32_t)(c) >= 65296) && ((int32_t)(c) <= 65305))) 
            {
                return (double)(((int32_t)(c) - 65296));
            }
            return std::numeric_limits<double>::epsilon();
        }
         else 
        {
            return (*(numeric_data_values + (*(numeric_data + c))));
        }
    }
    
    double Char::GetNumericValue2(String* s, int32_t index) {
        CheckParameter(s, index);
        return GetNumericValue(s->get_Chars(index));
    }
    
    Globalization::UnicodeCategory Char::GetUnicodeCategory(char16_t c) {
        return (Globalization::UnicodeCategory)((*(category_data + c)));
    }
    
    Globalization::UnicodeCategory Char::GetUnicodeCategory2(String* s, int32_t index) {
        CheckParameter(s, index);
        Globalization::UnicodeCategory c = GetUnicodeCategory(s->get_Chars(index));
        if((((int32_t)((unsigned char)(int32_t)(c)) ==  (int32_t)(category_check_pair)) && IsSurrogatePair2(s, index))) 
        {
            int32_t u = ConvertToUtf32(s->get_Chars(index), s->get_Chars((index + 1)));
            int32_t x = (((int32_t)((*(category_astral_index + ((u - 65536) >> 8)))) << 8) + (u & 255));
            c = (Globalization::UnicodeCategory)((*(category_data + x)));
        }
        return c;
    }
    
    bool Char::IsControl(char16_t c) {
        return ((int32_t)((*(category_data + c))) ==  14);
    }
    
    bool Char::IsControl2(String* s, int32_t index) {
        CheckParameter(s, index);
        return IsControl(s->get_Chars(index));
    }
    
    bool Char::IsDigit(char16_t c) {
        return ((int32_t)((*(category_data + c))) ==  8);
    }
    
    bool Char::IsDigit2(String* s, int32_t index) {
        CheckParameter(s, index);
        return IsDigit(s->get_Chars(index));
    }
    
    bool Char::IsHighSurrogate(char16_t c) {
        return (((int32_t)(c) >= 55296) && ((int32_t)(c) <= 56319));
    }
    
    bool Char::IsHighSurrogate2(String* s, int32_t index) {
        CheckParameter(s, index);
        return IsHighSurrogate(s->get_Chars(index));
    }
    
    bool Char::IsLetter(char16_t c) {
        return ((int32_t)((*(category_data + c))) <= 4);
    }
    
    bool Char::IsLetter2(String* s, int32_t index) {
        CheckParameter(s, index);
        return IsLetter(s->get_Chars(index));
    }
    
    bool Char::IsLetterOrDigit(char16_t c) {
        int32_t category = (int32_t)((*(category_data + c)));
        return ((category <= 4) || (category ==  8));
    }
    
    bool Char::IsLetterOrDigit2(String* s, int32_t index) {
        CheckParameter(s, index);
        return IsLetterOrDigit(s->get_Chars(index));
    }
    
    bool Char::IsLower(char16_t c) {
        return ((int32_t)((*(category_data + c))) ==  1);
    }
    
    bool Char::IsLower2(String* s, int32_t index) {
        CheckParameter(s, index);
        return IsLower(s->get_Chars(index));
    }
    
    bool Char::IsLowSurrogate(char16_t c) {
        return (((int32_t)(c) >= 56320) && ((int32_t)(c) <= 57343));
    }
    
    bool Char::IsLowSurrogate2(String* s, int32_t index) {
        CheckParameter(s, index);
        return IsLowSurrogate(s->get_Chars(index));
    }
    
    bool Char::IsNumber(char16_t c) {
        int32_t category = (int32_t)((*(category_data + c)));
        return ((category >= 8) && (category <= 10));
    }
    
    bool Char::IsNumber2(String* s, int32_t index) {
        CheckParameter(s, index);
        return IsNumber(s->get_Chars(index));
    }
    
    bool Char::IsPunctuation(char16_t c) {
        int32_t category = (int32_t)((*(category_data + c)));
        return ((category >= 18) && (category <= 24));
    }
    
    bool Char::IsPunctuation2(String* s, int32_t index) {
        CheckParameter(s, index);
        return IsPunctuation(s->get_Chars(index));
    }
    
    bool Char::IsSeparator(char16_t c) {
        int32_t category = (int32_t)((*(category_data + c)));
        return ((category >= 11) && (category <= 13));
    }
    
    bool Char::IsSeparator2(String* s, int32_t index) {
        CheckParameter(s, index);
        return IsSeparator(s->get_Chars(index));
    }
    
    bool Char::IsSurrogate(char16_t c) {
        return ((int32_t)((*(category_data + c))) ==  16);
    }
    
    bool Char::IsSurrogate2(String* s, int32_t index) {
        CheckParameter(s, index);
        return IsSurrogate(s->get_Chars(index));
    }
    
    bool Char::IsSymbol(char16_t c) {
        int32_t category = (int32_t)((*(category_data + c)));
        return ((category >= 25) && (category <= 28));
    }
    
    bool Char::IsSymbol2(String* s, int32_t index) {
        CheckParameter(s, index);
        return IsSymbol(s->get_Chars(index));
    }
    
    bool Char::IsUpper(char16_t c) {
        return ((int32_t)((*(category_data + c))) ==  0);
    }
    
    bool Char::IsUpper2(String* s, int32_t index) {
        CheckParameter(s, index);
        return IsUpper(s->get_Chars(index));
    }
    
    bool Char::IsWhiteSpace(char16_t c) {
        if(((int32_t)(c) < 5760)) 
        {
            return (((((int32_t)(c) ==  32) || (((int32_t)(c) >= 9) && ((int32_t)(c) <= 13))) || ((int32_t)(c) ==  133)) || ((int32_t)(c) ==  160));
        }
        int32_t category = (int32_t)((*(category_data + c)));
        return ((category > 10) && (category <= 13));
    }
    
    bool Char::IsWhiteSpace2(String* s, int32_t index) {
        CheckParameter(s, index);
        return IsWhiteSpace(s->get_Chars(index));
    }
    
    void Char::CheckParameter(String* s, int32_t index) {
        if((s ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("s"));
        }
        if(((index < 0) || (index >= s->get_Length()))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(Locale::GetText(_T("The value of index is less than zero, or greater than or equal to the length of s.")));
        }
    }
    
    bool Char::TryParse(String* s, char16_t result) {
        if(((s ==  nullptr) || (s->get_Length() != 1))) 
        {
            result = u'\x0';
            return false;
        }
        result = s->get_Chars(0);
        return true;
    }
    
    char16_t Char::Parse(String* s) {
        if((s ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("s"));
        }
        if((s->get_Length() != 1)) 
        {
            throw cli::gcnew<FormatException>(Locale::GetText(_T("s contains more than one character.")));
        }
        return s->get_Chars(0);
    }
    
    char16_t Char::ToLower(char16_t c) {
        return Globalization::CultureInfo::get_CurrentCulture()->get_TextInfo_63dfa6e5f11a61f0()->ToLower_6b32dfb00a24a852(c);
    }
    
    char16_t Char::ToLowerInvariant(char16_t c) {
        if(((int32_t)(c) <= 9423)) 
        {
            return (char16_t)(*(to_lower_data_low + c));
        }
        if(((int32_t)(c) >= 65313)) 
        {
            return (char16_t)(*(to_lower_data_high + ((int32_t)(c) - 65313)));
        }
        return c;
    }
    
    char16_t Char::ToLower2(char16_t c, Globalization::CultureInfo* culture) {
        if((culture ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("culture"));
        }
        if((culture->get_LCID_f4b9bc9d0bf0db86() ==  127)) 
        {
            return ToLowerInvariant(c);
        }
        return culture->get_TextInfo_63dfa6e5f11a61f0()->ToLower_6b32dfb00a24a852(c);
    }
    
    char16_t Char::ToUpper(char16_t c) {
        return Globalization::CultureInfo::get_CurrentCulture()->get_TextInfo_63dfa6e5f11a61f0()->ToUpper_d4d54a4b5ef4f4c7(c);
    }
    
    char16_t Char::ToUpperInvariant(char16_t c) {
        if(((int32_t)(c) <= 9449)) 
        {
            return (char16_t)(*(to_upper_data_low + c));
        }
        if(((int32_t)(c) >= 65313)) 
        {
            return (char16_t)(*(to_upper_data_high + ((int32_t)(c) - 65313)));
        }
        return c;
    }
    
    char16_t Char::ToUpper2(char16_t c, Globalization::CultureInfo* culture) {
        if((culture ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("culture"));
        }
        if((culture->get_LCID_f4b9bc9d0bf0db86() ==  127)) 
        {
            return ToUpperInvariant(c);
        }
        return culture->get_TextInfo_63dfa6e5f11a61f0()->ToUpper_d4d54a4b5ef4f4c7(c);
    }
    
    String* Char::ToString_1636a0751cb9ac11() {
        return cli::gcnew<String>(cli::import((*this))->m_value, 1);
    }
    
    String* Char::ToString3(char16_t c) {
        return cli::gcnew<String>(c, 1);
    }
    
    String* Char::ToString4(IFormatProvider* provider) {
        return cli::gcnew<String>(cli::import((*this))->m_value, 1);
    }
    
    TypeCode Char::GetTypeCode() {
        return TypeCode::Char2;
    }
    
    Object* Char::ToType(Type* targetType, IFormatProvider* provider) {
        if(Type::op_Equality2(targetType, nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("targetType"));
        }
        return Convert::ToType(cli::box(cli::import((*this))->m_value), targetType, provider, false);
    }
    
    bool Char::ToBoolean(IFormatProvider* provider) {
        throw cli::gcnew<InvalidCastException>();
    }
    
    unsigned char Char::ToByte(IFormatProvider* provider) {
        return Convert::ToByte3(cli::import((*this))->m_value);
    }
    
    char16_t Char::ToChar(IFormatProvider* provider) {
        return cli::import((*this))->m_value;
    }
    
    DateTime Char::ToDateTime(IFormatProvider* provider) {
        throw cli::gcnew<InvalidCastException>();
    }
    
    Decimal Char::ToDecimal(IFormatProvider* provider) {
        throw cli::gcnew<InvalidCastException>();
    }
    
    double Char::ToDouble(IFormatProvider* provider) {
        throw cli::gcnew<InvalidCastException>();
    }
    
    int16_t Char::ToInt16(IFormatProvider* provider) {
        return Convert::ToInt163(cli::import((*this))->m_value);
    }
    
    int32_t Char::ToInt32(IFormatProvider* provider) {
        return Convert::ToInt323(cli::import((*this))->m_value);
    }
    
    int64_t Char::ToInt64(IFormatProvider* provider) {
        return Convert::ToInt643(cli::import((*this))->m_value);
    }
    
    signed char Char::ToSByte(IFormatProvider* provider) {
        return Convert::ToSByte3(cli::import((*this))->m_value);
    }
    
    float Char::ToSingle(IFormatProvider* provider) {
        throw cli::gcnew<InvalidCastException>();
    }
    
    uint16_t Char::ToUInt16(IFormatProvider* provider) {
        return Convert::ToUInt163(cli::import((*this))->m_value);
    }
    
    uint32_t Char::ToUInt32(IFormatProvider* provider) {
        return Convert::ToUInt323(cli::import((*this))->m_value);
    }
    
    uint64_t Char::ToUInt64(IFormatProvider* provider) {
        return Convert::ToUInt643(cli::import((*this))->m_value);
    }
    
}
namespace System {
    
    ConsoleKeyInfo*  ConsoleKeyInfo::Empty;
    
    void ConsoleKeyInfo::constructor(char16_t keyChar, ConsoleKey key, bool shift, bool alt, bool control) {
        (*this)->key = key;
        (*this)->keychar = keyChar;
        (*this)->modifiers = (ConsoleModifiers)0L;
        SetModifiers(shift, alt, control);
    }
    
    void ConsoleKeyInfo::constructor(ConsoleKeyInfo other) {
        (*this)->key = other->key;
        (*this)->keychar = other->keychar;
        (*this)->modifiers = other->modifiers;
    }
    
    void ConsoleKeyInfo::static_constructor() {
    }
    
    void ConsoleKeyInfo::SetKey(ConsoleKey key) {
        (*this)->key = key;
    }
    
    void ConsoleKeyInfo::SetKeyChar(char16_t keyChar) {
        (*this)->keychar = keyChar;
    }
    
    void ConsoleKeyInfo::SetModifiers(bool shift, bool alt, bool control) {
        (*this)->modifiers = shift ? ConsoleModifiers::Shift : (ConsoleModifiers)0L;
        ((*this)->modifiers = (ConsoleModifiers)(((int32_t)((*this)->modifiers) | (int32_t)(alt ? ConsoleModifiers::Alt : (ConsoleModifiers)0L))));
        ((*this)->modifiers = (ConsoleModifiers)(((int32_t)((*this)->modifiers) | (int32_t)(control ? ConsoleModifiers::Control : (ConsoleModifiers)0L))));
    }
    
    bool ConsoleKeyInfo::Equals_ed975d2f4a7d193e(Object* value) {
        if(!(cli::is<ConsoleKeyInfo>(value))) 
        {
            return false;
        }
        return Equals2(cli::unbox<ConsoleKeyInfo>(value));
    }
    
    bool ConsoleKeyInfo::Equals2(ConsoleKeyInfo obj) {
        return ((((int32_t)((*this)->key) ==  (int32_t)(obj->key)) && ((int32_t)(obj->keychar) ==  (int32_t)((*this)->keychar))) && ((int32_t)(obj->modifiers) ==  (int32_t)((*this)->modifiers)));
    }
    
    int32_t ConsoleKeyInfo::GetHashCode_6648aef0f235ee6c() {
        return ((cli::import((*this)->key)->GetHashCode_6648aef0f235ee6c() ^ cli::import((*this)->keychar)->GetHashCode_6648aef0f235ee6c()) ^ cli::import((*this)->modifiers)->GetHashCode_6648aef0f235ee6c());
    }
    
    bool ConsoleKeyInfo::op_Equality(ConsoleKeyInfo a, ConsoleKeyInfo b) {
        return a->Equals2(b);
    }
    
    bool ConsoleKeyInfo::op_Inequality(ConsoleKeyInfo a, ConsoleKeyInfo b) {
        return !(a->Equals2(b));
    }
    
    ConsoleKey ConsoleKeyInfo::get_Key() {
        return (*this)->key;
    }
    
    char16_t ConsoleKeyInfo::get_KeyChar() {
        return (*this)->keychar;
    }
    
    ConsoleModifiers ConsoleKeyInfo::get_Modifiers() {
        return (*this)->modifiers;
    }
    
}
namespace System {
    
    DateTime*  DateTime::MaxValue;
    DateTime*  DateTime::MinValue;
    cli::array<String*>*  DateTime::ParseTimeFormats;
    cli::array<String*>*  DateTime::ParseYearDayMonthFormats;
    cli::array<String*>*  DateTime::ParseYearMonthDayFormats;
    cli::array<String*>*  DateTime::ParseDayMonthYearFormats;
    cli::array<String*>*  DateTime::ParseMonthDayYearFormats;
    cli::array<String*>*  DateTime::ParseGenericYearMonthDayFormats;
    cli::array<String*>*  DateTime::MonthDayShortFormats;
    cli::array<String*>*  DateTime::DayMonthShortFormats;
    cli::array<int32_t>*  DateTime::daysmonth;
    cli::array<int32_t>*  DateTime::daysmonthleap;
    Object*  DateTime::to_local_time_span_object;
    int64_t  DateTime::last_now;
    
    void DateTime::constructor(int64_t ticks) {
        if(((ticks < 0L) || (ticks > 3155378975999999999L))) 
        {
            InvalidTickValue(ticks);
        }
        (*this)->encoded = ticks;
    }
    
    void DateTime::constructor(int32_t year, int32_t month, int32_t day) {
    }
    
    void DateTime::constructor(int32_t year, int32_t month, int32_t day, int32_t hour, int32_t minute, int32_t second) {
    }
    
    void DateTime::constructor(int32_t year, int32_t month, int32_t day, int32_t hour, int32_t minute, int32_t second, int32_t millisecond) {
        if(((((((((((((((year < 1) || (year > 9999)) || (month < 1)) || (month > 12)) || (day < 1)) || (day > DaysInMonth(year, month))) || (hour < 0)) || (hour > 23)) || (minute < 0)) || (minute > 59)) || (second < 0)) || (second > 59)) || (millisecond < 0)) || (millisecond > 999))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("Parameters describe an unrepresentable DateTime."));
        }
        (*this)->encoded = cli::ctor<TimeSpan>(AbsoluteDays(year, month, day), hour, minute, second, millisecond)->get_Ticks();
    }
    
    void DateTime::constructor(int32_t year, int32_t month, int32_t day, Globalization::Calendar* calendar) {
    }
    
    void DateTime::constructor(int32_t year, int32_t month, int32_t day, int32_t hour, int32_t minute, int32_t second, Globalization::Calendar* calendar) {
    }
    
    void DateTime::constructor(int32_t year, int32_t month, int32_t day, int32_t hour, int32_t minute, int32_t second, int32_t millisecond, Globalization::Calendar* calendar) {
        if((calendar ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("calendar"));
        }
        (*this)->encoded = calendar->ToDateTime_1fb5be79b550c0bc(year, month, day, hour, minute, second, millisecond)->encoded;
    }
    
    void DateTime::constructor(int64_t ticks, DateTimeKind kind) {
        if(((ticks < 0L) || (ticks > 3155378975999999999L))) 
        {
            InvalidTickValue(ticks);
        }
        if((((int32_t)(kind) < 0) || ((int32_t)(kind) > 2))) 
        {
            throw cli::gcnew<ArgumentException>(_T("Invalid DateTimeKind value."), _T("kind"));
        }
        (*this)->encoded = (((int64_t)((int64_t)((int32_t)(kind))) << 62) | ticks);
    }
    
    void DateTime::constructor(int32_t year, int32_t month, int32_t day, int32_t hour, int32_t minute, int32_t second, DateTimeKind kind) {
        if((((int32_t)(kind) < 0) || ((int32_t)(kind) > 2))) 
        {
            throw cli::gcnew<ArgumentException>(_T("Invalid DateTimeKind value."), _T("kind"));
        }
        ((*this)->encoded = (*this)->encoded | ((int64_t)((int64_t)((int32_t)(kind))) << 62));
    }
    
    void DateTime::constructor(int32_t year, int32_t month, int32_t day, int32_t hour, int32_t minute, int32_t second, int32_t millisecond, DateTimeKind kind) {
        if((((int32_t)(kind) < 0) || ((int32_t)(kind) > 2))) 
        {
            throw cli::gcnew<ArgumentException>(_T("Invalid DateTimeKind value."), _T("kind"));
        }
        ((*this)->encoded = (*this)->encoded | ((int64_t)((int64_t)((int32_t)(kind))) << 62));
    }
    
    void DateTime::constructor(int32_t year, int32_t month, int32_t day, int32_t hour, int32_t minute, int32_t second, int32_t millisecond, Globalization::Calendar* calendar, DateTimeKind kind) {
        if((((int32_t)(kind) < 0) || ((int32_t)(kind) > 2))) 
        {
            throw cli::gcnew<ArgumentException>(_T("Invalid DateTimeKind value."), _T("kind"));
        }
        ((*this)->encoded = (*this)->encoded | ((int64_t)((int64_t)((int32_t)(kind))) << 62));
    }
    
    void DateTime::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        if(info->HasKey(_T("dateData"))) 
        {
            (*this)->encoded = info->GetInt64(_T("dateData"));
        }
         else 
        {
            if(info->HasKey(_T("ticks"))) 
            {
                (*this)->encoded = (info->GetInt64(_T("ticks")) & 4611686018427387903L);
            }
             else 
            {
                (*this)->encoded = 0L;
            }
        }
    }
    
    void DateTime::static_constructor() {
    }
    
    int32_t DateTime::AbsoluteDays(int32_t year, int32_t month, int32_t day) {
        cli::array<int32_t> *days;
        int32_t temp = 0, m = 1;
        days = IsLeapYear(year) ? daysmonthleap : daysmonth;
        while((m < month)) (temp = temp + days->at(m++));
        return ((((((day - 1) + temp) + (365 * (year - 1))) + ((year - 1) / 4)) - ((year - 1) / 100)) + ((year - 1) / 400));
    }
    
    int32_t DateTime::FromTicks(Which what) {
        int32_t num400, num100, num4, numyears;
        int32_t M = 1;
        cli::array<int32_t> *days = daysmonth;
        int32_t totaldays = (int32_t)(((*this)->encoded & 4611686018427387903L) / 864000000000L);
        num400 = (totaldays / 146097);
        (totaldays = totaldays - (num400 * 146097));
        num100 = (totaldays / 36524);
        if((num100 ==  4)) 
        {
            num100 = 3;
        }
        (totaldays = totaldays - (num100 * 36524));
        num4 = (totaldays / 1461);
        (totaldays = totaldays - (num4 * 1461));
        numyears = (totaldays / 365);
        if((numyears ==  4)) 
        {
            numyears = 3;
        }
        if(((int32_t)(what) ==  3)) 
        {
            return (((((num400 * 400) + (num100 * 100)) + (num4 * 4)) + numyears) + 1);
        }
        (totaldays = totaldays - (numyears * 365));
        if(((int32_t)(what) ==  1)) 
        {
            return (totaldays + 1);
        }
        if(((numyears ==  3) && ((num100 ==  3) || !((num4 ==  24))))) 
        {
            days = daysmonthleap;
        }
        while((totaldays >= days->at(M))) (totaldays = totaldays - days->at(M++));
        if(((int32_t)(what) ==  2)) 
        {
            return M;
        }
        return (totaldays + 1);
    }
    
    void DateTime::InvalidTickValue(int64_t ticks) {
        String *msg = Locale::GetText2(_T("Value {0} is outside the valid range [0,{1}]."), (new cli::array<Object*>({cli::box(ticks), cli::box(3155378975999999999L)})));
        throw cli::gcnew<ArgumentOutOfRangeException>(_T("ticks"), msg);
    }
    
    int64_t DateTime::GetTimeMonotonic() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int64_t DateTime::GetNow() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    DateTime DateTime::Add(TimeSpan value) {
        DateTime ret = AddTicks(value->get_Ticks());
        return ret;
    }
    
    DateTime DateTime::AddDays(double value) {
        return AddMilliseconds(Math::Round5((value * 86400000.)));
    }
    
    DateTime DateTime::AddTicks(int64_t value) {
        int64_t res = (value + ((*this)->encoded & 4611686018427387903L));
        if(((res < 0L) || (res > 3155378975999999999L))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>();
        }
        DateTime ret = cli::ctor<DateTime>(res);
        (ret->encoded = ret->encoded | ((*this)->encoded & -4611686018427387904L));
        return ret;
    }
    
    DateTime DateTime::AddHours(double value) {
        return AddMilliseconds((value * 3600000.));
    }
    
    DateTime DateTime::AddMilliseconds(double value) {
        if((((value * 10000.) > 9.22337203685478E+18) || ((value * 10000.) < std::numeric_limits<double>::epsilon()))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>();
        }
        int64_t msticks = (int64_t)Math::Round5((value * 10000.));
        return AddTicks(msticks);
    }
    
    DateTime DateTime::AddRoundedMilliseconds(double ms) {
        if((((ms * 10000.) > 9.22337203685478E+18) || ((ms * 10000.) < std::numeric_limits<double>::epsilon()))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>();
        }
        int64_t msticks = ((int64_t)(ms = ms + (ms > std::numeric_limits<double>::epsilon()) ? 0.5 : std::numeric_limits<double>::epsilon()) * 10000L);
        return AddTicks(msticks);
    }
    
    DateTime DateTime::AddMinutes(double value) {
        return AddMilliseconds((value * 60000.));
    }
    
    DateTime DateTime::AddMonths(int32_t months) {
        int32_t day, month, year, maxday;
        DateTime temp;
        day = (*this)->get_Day();
        month = ((*this)->get_Month() + (months % 12));
        year = ((*this)->get_Year() + (months / 12));
        if((month < 1)) 
        {
            month = (12 + month);
            year--;
        }
         else 
        {
            if((month > 12)) 
            {
                month = (month - 12);
                year++;
            }
        }
        maxday = DaysInMonth(year, month);
        if((day > maxday)) 
        {
            day = maxday;
        }
        temp = cli::ctor<DateTime>(year, month, day);
        (temp->encoded = temp->encoded | ((*this)->encoded & -4611686018427387904L));
        return temp->Add((*this)->get_TimeOfDay());
    }
    
    DateTime DateTime::AddSeconds(double value) {
        return AddMilliseconds((value * 1000.));
    }
    
    DateTime DateTime::AddYears(int32_t value) {
        return AddMonths((value * 12));
    }
    
    int32_t DateTime::Compare(DateTime t1, DateTime t2) {
        int64_t t1t = (t1->encoded & 4611686018427387903L);
        int64_t t2t = (t2->encoded & 4611686018427387903L);
        if((t1t < t2t)) 
        {
            return -1;
        }
         else 
        {
            if((t1t > t2t)) 
            {
                return 1;
            }
             else 
            {
                return 0;
            }
        }
    }
    
    int32_t DateTime::CompareTo(Object* value) {
        if((value ==  nullptr)) 
        {
            return 1;
        }
        if(!(cli::is<DateTime>(value))) 
        {
            throw cli::gcnew<ArgumentException>(Locale::GetText(_T("Value is not a System.DateTime")));
        }
        return Compare((*this), cli::unbox<DateTime>(value));
    }
    
    bool DateTime::IsDaylightSavingTime() {
        if(((int32_t)((uint64_t)(*this)->encoded >> 62) ==  1)) 
        {
            return false;
        }
        return TimeZone::get_CurrentTimeZone()->IsDaylightSavingTime_3bdf7ceedb2508ce((*this));
    }
    
    int32_t DateTime::CompareTo2(DateTime value) {
        return Compare((*this), value);
    }
    
    bool DateTime::Equals(DateTime value) {
        return ((value->encoded & 4611686018427387903L) ==  ((*this)->encoded & 4611686018427387903L));
    }
    
    int64_t DateTime::ToBinary() {
        if((((*this)->encoded & (-9223372036854775807L - 1)) != 0L)) 
        {
            return (int64_t)((uint64_t)ToUniversalTime()->get_Ticks() | 9223372036854775808UL);
        }
        return (*this)->encoded;
    }
    
    DateTime DateTime::FromBinary(int64_t dateData) {
        switch(((uint64_t)dateData >> 62)) {
            case 1UL: case_1: {
                return cli::ctor<DateTime>((dateData & 4611686018427387903L), DateTimeKind::Utc);
            }
            case 0UL: case_2: {
                return cli::ctor<DateTime>(dateData, DateTimeKind::Unspecified);
            }
            default: case_3: {
                return cli::ctor<DateTime>((dateData & 4611686018427387903L), DateTimeKind::Utc)->ToLocalTime();
            }
        }
    }
    
    DateTime DateTime::SpecifyKind(DateTime value, DateTimeKind kind) {
        return cli::ctor<DateTime>(value->get_Ticks(), kind);
    }
    
    int32_t DateTime::DaysInMonth(int32_t year, int32_t month) {
        cli::array<int32_t> *days;
        if(((month < 1) || (month > 12))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>();
        }
        if(((year < 1) || (year > 9999))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>();
        }
        days = IsLeapYear(year) ? daysmonthleap : daysmonth;
        return days->at(month);
    }
    
    bool DateTime::Equals_ed975d2f4a7d193e(Object* value) {
        if(!(cli::is<DateTime>(value))) 
        {
            return false;
        }
        return ((cli::unbox<DateTime>(value)->encoded & 4611686018427387903L) ==  ((*this)->encoded & 4611686018427387903L));
    }
    
    bool DateTime::Equals4(DateTime t1, DateTime t2) {
        return ((t1->encoded & 4611686018427387903L) ==  (t2->encoded & 4611686018427387903L));
    }
    
    DateTime DateTime::FromFileTime(int64_t fileTime) {
        if((fileTime < 0L)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("fileTime"), _T("< 0"));
        }
        return cli::ctor<DateTime>((504911232000000000L + fileTime))->ToLocalTime();
    }
    
    DateTime DateTime::FromFileTimeUtc(int64_t fileTime) {
        if((fileTime < 0L)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("fileTime"), _T("< 0"));
        }
        return cli::ctor<DateTime>((504911232000000000L + fileTime), DateTimeKind::Utc);
    }
    
    DateTime DateTime::FromOADate(double d) {
        if(((d <= std::numeric_limits<double>::epsilon()) || (d >= 2958466.))) 
        {
            throw cli::gcnew<ArgumentException>(_T("d"), _T("[-657435,2958466]"));
        }
        DateTime dt = cli::ctor<DateTime>(599264352000000000L);
        if((d < std::numeric_limits<double>::epsilon())) 
        {
            double days = Math::Ceiling2(d);
            dt = dt->AddRoundedMilliseconds((days * 86400000.));
            double hours = (days - d);
            dt = dt->AddRoundedMilliseconds((hours * 86400000.));
        }
         else 
        {
            dt = dt->AddRoundedMilliseconds((d * 86400000.));
        }
        return dt;
    }
    
    cli::array<String*>* DateTime::GetDateTimeFormats() {
        return GetDateTimeFormats3(Globalization::CultureInfo::get_CurrentCulture());
    }
    
    cli::array<String*>* DateTime::GetDateTimeFormats2(char16_t format) {
        if((_T("dDgGfFmMrRstTuUyY")->IndexOf4(format) < 0)) 
        {
            throw cli::gcnew<FormatException>(_T("Invalid format character."));
        }
        cli::array<String*> *result = (new cli::array<String*>(1));
        result->at(0) = (*this)->ToString4(cli::import(format)->ToString_1636a0751cb9ac11());
        return result;
    }
    
    cli::array<String*>* DateTime::GetDateTimeFormats3(IFormatProvider* provider) {
        Globalization::DateTimeFormatInfo *info = cli::cast<Globalization::DateTimeFormatInfo*>(provider->GetFormat_b67414a65453cc7e(cli::typeof<Type>::info));
        Collections::Generic::List<String*> *l = cli::gcnew<Collections::Generic::List<String*>>();
        for(auto tmp_0 : _T("dDgGfFmMrRstTuUyY")) {
            auto c = cli::cast<char16_t>(tmp_0);
            l->AddRange(GetDateTimeFormats4(c, info));
        }
        return l->ToArray();
    }
    
    cli::array<String*>* DateTime::GetDateTimeFormats4(char16_t format, IFormatProvider* provider) {
        if((_T("dDgGfFmMrRstTuUyY")->IndexOf4(format) < 0)) 
        {
            throw cli::gcnew<FormatException>(_T("Invalid format character."));
        }
        bool adjustutc = false;
        switch(format) {
            case u'U': case_4: {
                adjustutc = true;
                break;
            }
        }
        Globalization::DateTimeFormatInfo *info = cli::cast<Globalization::DateTimeFormatInfo*>(provider->GetFormat_b67414a65453cc7e(cli::typeof<Type>::info));
        return GetDateTimeFormats5(adjustutc, info->GetAllRawDateTimePatterns(format), info);
    }
    
    cli::array<String*>* DateTime::GetDateTimeFormats5(bool adjustutc, cli::array<String*>* patterns, Globalization::DateTimeFormatInfo* dfi) {
        cli::array<String*> *results = (new cli::array<String*>(patterns->get_Length()));
        DateTime val = adjustutc ? ToUniversalTime() : (*this);
        for(int32_t i = 0; (i < results->get_Length()); i++) {
            results->at(i) = DateTimeUtils::ToString2(val, patterns->at(i), dfi);
        }
        return results;
    }
    
    int32_t DateTime::GetHashCode_6648aef0f235ee6c() {
        return (int32_t)(*this)->encoded;
    }
    
    TypeCode DateTime::GetTypeCode() {
        return TypeCode::DateTime2;
    }
    
    bool DateTime::IsLeapYear(int32_t year) {
        if(((year < 1) || (year > 9999))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>();
        }
        return ((((year % 4) ==  0) && ((year % 100) != 0)) || ((year % 400) ==  0));
    }
    
    DateTime DateTime::Parse(String* s) {
        return Parse2(s, nullptr);
    }
    
    DateTime DateTime::Parse2(String* s, IFormatProvider* provider) {
        return Parse3(s, provider, Globalization::DateTimeStyles::AllowWhiteSpaces);
    }
    
    DateTime DateTime::Parse3(String* s, IFormatProvider* provider, Globalization::DateTimeStyles styles) {
        if((s ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("s"));
        }
        DateTime res;
        DateTimeOffset dto;
        Exception *exception = nullptr;
        if(!(CoreParse(s, provider, styles, res, dto, true, exception))) 
        {
            throw exception;
        }
        return res;
    }
    
    bool DateTime::CoreParse(String* s, IFormatProvider* provider, Globalization::DateTimeStyles styles, DateTime result, DateTimeOffset dto, bool setExceptionOnError, Exception* exception) {
        dto = cli::ctor<DateTimeOffset>(0L, (*TimeSpan::Zero));
        if(((s ==  nullptr) || (s->get_Length() ==  0))) 
        {
            if(setExceptionOnError) 
            {
                exception = cli::gcnew<FormatException>(_T("String was not recognized as a valid DateTime."));
            }
            result = (*MinValue);
            return false;
        }
        if((provider ==  nullptr)) 
        {
            provider = Globalization::CultureInfo::get_CurrentCulture();
        }
        Globalization::DateTimeFormatInfo *dfi = Globalization::DateTimeFormatInfo::GetInstance(provider);
        cli::array<String*> *allDateFormats = YearMonthDayFormats(dfi);
        if((allDateFormats ==  nullptr)) 
        {
            result = (*MinValue);
            return false;
        }
        bool longYear = false;
        for(int32_t i = 0; (i < allDateFormats->get_Length()); i++){
            String *firstPart = allDateFormats->at(i);
            bool incompleteFormat = false;
            if(_DoParse(s, firstPart, _T(""), false, result, dto, dfi, styles, true, incompleteFormat, longYear)) 
            {
                return true;
            }
            if(!(incompleteFormat)) 
            {
                continue;
            }
            for(int32_t j = 0; (j < ParseTimeFormats->get_Length()); j++){
                if(_DoParse(s, firstPart, ParseTimeFormats->at(j), false, result, dto, dfi, styles, true, incompleteFormat, longYear)) 
                {
                    return true;
                }
            }
        }
        int32_t dayIndex = dfi->get_MonthDayPattern()->IndexOf4(u'd');
        int32_t monthIndex = dfi->get_MonthDayPattern()->IndexOf4(u'M');
        if(((dayIndex ==  -1) || (monthIndex ==  -1))) 
        {
            result = (*MinValue);
            if(setExceptionOnError) 
            {
                exception = cli::gcnew<FormatException>(Locale::GetText2(_T("Order of month and date is not defined by {0}"), (new cli::array<Object*>({dfi->get_MonthDayPattern()}))));
            }
            return false;
        }
        bool is_day_before_month = (dayIndex < monthIndex);
        cli::array<String*> *monthDayFormats = is_day_before_month ? DayMonthShortFormats : MonthDayShortFormats;
        for(int32_t i = 0; (i < monthDayFormats->get_Length()); i++){
            bool incompleteFormat = false;
            if(_DoParse(s, monthDayFormats->at(i), _T(""), false, result, dto, dfi, styles, true, incompleteFormat, longYear)) 
            {
                return true;
            }
        }
        for(int32_t j = 0; (j < ParseTimeFormats->get_Length()); j++){
            String *firstPart = ParseTimeFormats->at(j);
            bool incompleteFormat = false;
            if(_DoParse(s, firstPart, _T(""), false, result, dto, dfi, styles, false, incompleteFormat, longYear)) 
            {
                return true;
            }
            if(!(incompleteFormat)) 
            {
                continue;
            }
            for(int32_t i = 0; (i < monthDayFormats->get_Length()); i++){
                if(_DoParse(s, firstPart, monthDayFormats->at(i), false, result, dto, dfi, styles, false, incompleteFormat, longYear)) 
                {
                    return true;
                }
            }
            for(int32_t i = 0; (i < allDateFormats->get_Length()); i++){
                String *dateFormat = allDateFormats->at(i);
                if(((int32_t)(dateFormat->get_Chars((dateFormat->get_Length() - 1))) ==  84)) 
                {
                    continue;
                }
                if(_DoParse(s, firstPart, dateFormat, false, result, dto, dfi, styles, false, incompleteFormat, longYear)) 
                {
                    return true;
                }
            }
        }
        if(ParseExact4(s, dfi->GetAllDateTimePatternsInternal(), dfi, styles, result, false, longYear, setExceptionOnError, exception)) 
        {
            return true;
        }
        if(!(setExceptionOnError)) 
        {
            return false;
        }
        exception = cli::gcnew<FormatException>(_T("String was not recognized as a valid DateTime."));
        return false;
    }
    
    DateTime DateTime::ParseExact(String* s, String* format, IFormatProvider* provider) {
        return ParseExact2(s, format, provider, Globalization::DateTimeStyles::None);
    }
    
    cli::array<String*>* DateTime::YearMonthDayFormats(Globalization::DateTimeFormatInfo* dfi) {
        int32_t dayIndex = dfi->get_ShortDatePattern()->IndexOf4(u'd');
        int32_t monthIndex = dfi->get_ShortDatePattern()->IndexOf4(u'M');
        int32_t yearIndex = dfi->get_ShortDatePattern()->IndexOf4(u'y');
        if((((dayIndex ==  -1) || (monthIndex ==  -1)) || (yearIndex ==  -1))) 
        {
            return ParseGenericYearMonthDayFormats;
        }
        if((yearIndex < monthIndex)) 
        {
            if((monthIndex < dayIndex)) 
            {
                return ParseYearMonthDayFormats;
            }
             else 
            {
                if((yearIndex < dayIndex)) 
                {
                    return ParseYearDayMonthFormats;
                }
                 else 
                {
                    return ParseGenericYearMonthDayFormats;
                }
            }
        }
         else 
        {
            if((dayIndex < monthIndex)) 
            {
                return ParseDayMonthYearFormats;
            }
             else 
            {
                if((dayIndex < yearIndex)) 
                {
                    return ParseMonthDayYearFormats;
                }
                 else 
                {
                    return ParseGenericYearMonthDayFormats;
                }
            }
        }
    }
    
    int32_t DateTime::_ParseNumber(String* s, int32_t valuePos, int32_t min_digits, int32_t digits, bool leadingzero, bool sloppy_parsing, int32_t num_parsed) {
        int32_t number = 0, i;
        if(sloppy_parsing) 
        {
            leadingzero = false;
        }
        if(!(leadingzero)) 
        {
            int32_t real_digits = 0;
            for(i = valuePos; ((i < s->get_Length()) && (i < (digits + valuePos))); i++){
                if(!(Char::IsDigit(s->get_Chars(i)))) 
                {
                    break;
                }
                real_digits++;
            }
            digits = real_digits;
        }
        if((digits < min_digits)) 
        {
            num_parsed = -1;
            return 0;
        }
        if(((s->get_Length() - valuePos) < digits)) 
        {
            num_parsed = -1;
            return 0;
        }
        for(i = valuePos; (i < (digits + valuePos)); i++){
            char16_t c = s->get_Chars(i);
            if(!(Char::IsDigit(c))) 
            {
                num_parsed = -1;
                return 0;
            }
            number = ((number * 10) + (int32_t)((unsigned char)((int32_t)(c) - 48)));
        }
        num_parsed = digits;
        return number;
    }
    
    int32_t DateTime::_ParseEnum(String* s, int32_t sPos, cli::array<String*>* values, cli::array<String*>* invValues, bool exact, int32_t num_parsed) {
        for(int32_t i = (values->get_Length() - 1); (i >= 0); i--){
            if((!(exact) && (invValues->at(i)->get_Length() > values->at(i)->get_Length()))) 
            {
                if(((invValues->at(i)->get_Length() > 0) && _ParseString(s, sPos, 0, invValues->at(i), num_parsed))) 
                {
                    return i;
                }
                if(((values->at(i)->get_Length() > 0) && _ParseString(s, sPos, 0, values->at(i), num_parsed))) 
                {
                    return i;
                }
            }
             else 
            {
                if(((values->at(i)->get_Length() > 0) && _ParseString(s, sPos, 0, values->at(i), num_parsed))) 
                {
                    return i;
                }
                if(((!(exact) && (invValues->at(i)->get_Length() > 0)) && _ParseString(s, sPos, 0, invValues->at(i), num_parsed))) 
                {
                    return i;
                }
            }
        }
        num_parsed = -1;
        return -1;
    }
    
    bool DateTime::_ParseString(String* s, int32_t sPos, int32_t maxlength, String* value, int32_t num_parsed) {
        if((maxlength <= 0)) 
        {
            maxlength = value->get_Length();
        }
        if((((sPos + maxlength) <= s->get_Length()) && (String::Compare6(s, sPos, value, 0, maxlength, true, Globalization::CultureInfo::get_InvariantCulture()) ==  0))) 
        {
            num_parsed = maxlength;
            return true;
        }
        num_parsed = -1;
        return false;
    }
    
    bool DateTime::_ParseAmPm(String* s, int32_t valuePos, int32_t num, Globalization::DateTimeFormatInfo* dfi, bool exact, int32_t num_parsed, int32_t ampm) {
        num_parsed = -1;
        if((ampm != -1)) 
        {
            return false;
        }
        if(!(IsLetter(s, valuePos))) 
        {
            if(String::op_Inequality(dfi->get_AMDesignator(), _T(""))) 
            {
                return false;
            }
            if(exact) 
            {
                ampm = 0;
            }
            num_parsed = 0;
            return true;
        }
        Globalization::DateTimeFormatInfo *invInfo = Globalization::DateTimeFormatInfo::get_InvariantInfo();
        if(((!(exact) && _ParseString(s, valuePos, num, invInfo->get_PMDesignator(), num_parsed)) || (String::op_Inequality(dfi->get_PMDesignator(), _T("")) && _ParseString(s, valuePos, num, dfi->get_PMDesignator(), num_parsed)))) 
        {
            ampm = 1;
        }
         else 
        {
            if(((!(exact) && _ParseString(s, valuePos, num, invInfo->get_AMDesignator(), num_parsed)) || _ParseString(s, valuePos, num, dfi->get_AMDesignator(), num_parsed))) 
            {
                if((exact || (num_parsed != 0))) 
                {
                    ampm = 0;
                }
            }
             else 
            {
                return false;
            }
        }
        return true;
    }
    
    bool DateTime::_ParseTimeSeparator(String* s, int32_t sPos, Globalization::DateTimeFormatInfo* dfi, bool exact, int32_t num_parsed) {
        return (_ParseString(s, sPos, 0, dfi->get_TimeSeparator(), num_parsed) || (!(exact) && _ParseString(s, sPos, 0, _T(":"), num_parsed)));
    }
    
    bool DateTime::_ParseDateSeparator(String* s, int32_t sPos, Globalization::DateTimeFormatInfo* dfi, bool exact, int32_t num_parsed) {
        num_parsed = -1;
        if((exact && ((int32_t)(s->get_Chars(sPos)) != 47))) 
        {
            return false;
        }
        if(((_ParseTimeSeparator(s, sPos, dfi, exact, num_parsed) || Char::IsDigit(s->get_Chars(sPos))) || Char::IsLetter(s->get_Chars(sPos)))) 
        {
            return false;
        }
        num_parsed = 1;
        return true;
    }
    
    bool DateTime::IsLetter(String* s, int32_t pos) {
        return ((pos < s->get_Length()) && Char::IsLetter(s->get_Chars(pos)));
    }
    
    bool DateTime::_DoParse(String* s, String* firstPart, String* secondPart, bool exact, DateTime result, DateTimeOffset dto, Globalization::DateTimeFormatInfo* dfi, Globalization::DateTimeStyles style, bool firstPartIsDate, bool incompleteFormat, bool longYear) {
        bool useutc = false;
        bool use_invariant = false;
        bool sloppy_parsing = false;
        dto = cli::ctor<DateTimeOffset>(0L, (*TimeSpan::Zero));
        bool flexibleTwoPartsParsing = (!(exact) && (secondPart != nullptr));
        incompleteFormat = false;
        int32_t valuePos = 0;
        String *format = firstPart;
        bool afterTFormat = false;
        Globalization::DateTimeFormatInfo *invInfo = Globalization::DateTimeFormatInfo::get_InvariantInfo();
        if((format->get_Length() ==  1)) 
        {
            format = DateTimeUtils::GetStandardPattern(format->get_Chars(0), dfi, useutc, use_invariant);
        }
        result = cli::ctor<DateTime>(0L);
        if((format ==  nullptr)) 
        {
            return false;
        }
        if((s ==  nullptr)) 
        {
            return false;
        }
        if(((int32_t)(((int32_t)(style) & 1)) != 0)) 
        {
            format = format->TrimStart(nullptr);
            s = s->TrimStart(nullptr);
        }
        if(((int32_t)(((int32_t)(style) & 2)) != 0)) 
        {
            format = format->TrimEnd(nullptr);
            s = s->TrimEnd(nullptr);
        }
        if(use_invariant) 
        {
            dfi = invInfo;
        }
        if(((int32_t)(((int32_t)(style) & 4)) != 0)) 
        {
            sloppy_parsing = true;
        }
        String *chars = format;
        int32_t len = format->get_Length(), pos = 0, num = 0;
        if((len ==  0)) 
        {
            return false;
        }
        int32_t day = -1, dayofweek = -1, month = -1, year = -1;
        int32_t hour = -1, minute = -1, second = -1;
        double fractionalSeconds = std::numeric_limits<double>::epsilon();
        int32_t ampm = -1;
        int32_t tzsign = -1, tzoffset = -1, tzoffmin = -1;
        bool isFirstPart = true;
        bool format_with_24_hours = false;
        for(; ; ){
            if((valuePos ==  s->get_Length())) 
            {
                break;
            }
            int32_t num_parsed = 0;
            if((flexibleTwoPartsParsing && ((pos + num) ==  0))) 
            {
                bool isLetter = IsLetter(s, valuePos);
                if(isLetter) 
                {
                    if(((int32_t)(s->get_Chars(valuePos)) ==  90)) 
                    {
                        num_parsed = 1;
                    }
                     else 
                    {
                        _ParseString(s, valuePos, 0, _T("GMT"), num_parsed);
                    }
                    if(((num_parsed > 0) && !(IsLetter(s, (valuePos + num_parsed))))) 
                    {
                        (valuePos = valuePos + num_parsed);
                        useutc = true;
                        continue;
                    }
                }
                if((!(afterTFormat) && _ParseAmPm(s, valuePos, 0, dfi, exact, num_parsed, ampm))) 
                {
                    if(IsLetter(s, (valuePos + num_parsed))) 
                    {
                        ampm = -1;
                    }
                     else 
                    {
                        if((num_parsed > 0)) 
                        {
                            (valuePos = valuePos + num_parsed);
                            continue;
                        }
                    }
                }
                if(((!(afterTFormat) && (dayofweek ==  -1)) && isLetter)) 
                {
                    dayofweek = _ParseEnum(s, valuePos, dfi->get_RawDayNames(), invInfo->get_RawDayNames(), exact, num_parsed);
                    if((dayofweek ==  -1)) 
                    {
                        dayofweek = _ParseEnum(s, valuePos, dfi->get_RawAbbreviatedDayNames(), invInfo->get_RawAbbreviatedDayNames(), exact, num_parsed);
                    }
                    if(((dayofweek != -1) && !(IsLetter(s, (valuePos + num_parsed))))) 
                    {
                        (valuePos = valuePos + num_parsed);
                        continue;
                    }
                     else 
                    {
                        dayofweek = -1;
                    }
                }
                if((Char::IsWhiteSpace(s->get_Chars(valuePos)) || ((int32_t)(s->get_Chars(valuePos)) ==  44))) 
                {
                    (valuePos = valuePos + 1);
                    continue;
                }
                num_parsed = 0;
            }
            if(((pos + num) >= len)) 
            {
                if((flexibleTwoPartsParsing && (num ==  0))) 
                {
                    afterTFormat = (isFirstPart && ((int32_t)(firstPart->get_Chars((firstPart->get_Length() - 1))) ==  84));
                    if((!(isFirstPart) && String::op_Equality(format, _T("")))) 
                    {
                        break;
                    }
                    pos = 0;
                    if(isFirstPart) 
                    {
                        format = secondPart;
                    }
                     else 
                    {
                        format = _T("");
                    }
                    chars = format;
                    len = chars->get_Length();
                    isFirstPart = false;
                    continue;
                }
                break;
            }
            bool leading_zeros = true;
            if(((int32_t)(chars->get_Chars(pos)) ==  39)) 
            {
                num = 1;
                while(((pos + num) < len)) {
                    if(((int32_t)(chars->get_Chars((pos + num))) ==  39)) 
                    {
                        break;
                    }
                    if(((valuePos ==  s->get_Length()) || ((int32_t)(s->get_Chars(valuePos)) != (int32_t)(chars->get_Chars((pos + num)))))) 
                    {
                        return false;
                    }
                    valuePos++;
                    num++;
                }
                (pos = pos + (num + 1));
                num = 0;
                continue;
            }
             else 
            {
                if(((int32_t)(chars->get_Chars(pos)) ==  34)) 
                {
                    num = 1;
                    while(((pos + num) < len)) {
                        if(((int32_t)(chars->get_Chars((pos + num))) ==  34)) 
                        {
                            break;
                        }
                        if(((valuePos ==  s->get_Length()) || ((int32_t)(s->get_Chars(valuePos)) != (int32_t)(chars->get_Chars((pos + num)))))) 
                        {
                            return false;
                        }
                        valuePos++;
                        num++;
                    }
                    (pos = pos + (num + 1));
                    num = 0;
                    continue;
                }
                 else 
                {
                    if(((int32_t)(chars->get_Chars(pos)) ==  92)) 
                    {
                        (pos = pos + (num + 1));
                        num = 0;
                        if((pos >= len)) 
                        {
                            return false;
                        }
                        if(((int32_t)(s->get_Chars(valuePos)) != (int32_t)(chars->get_Chars(pos)))) 
                        {
                            return false;
                        }
                        valuePos++;
                        pos++;
                        continue;
                    }
                     else 
                    {
                        if(((int32_t)(chars->get_Chars(pos)) ==  37)) 
                        {
                            pos++;
                            continue;
                        }
                         else 
                        {
                            if((Char::IsWhiteSpace(s->get_Chars(valuePos)) || (((int32_t)(s->get_Chars(valuePos)) ==  44) && ((!(exact) && ((int32_t)(chars->get_Chars(pos)) ==  47)) || Char::IsWhiteSpace(chars->get_Chars(pos)))))) 
                            {
                                valuePos++;
                                num = 0;
                                if((exact && ((int32_t)(((int32_t)(style) & 4)) ==  0))) 
                                {
                                    if(!(Char::IsWhiteSpace(chars->get_Chars(pos)))) 
                                    {
                                        return false;
                                    }
                                    pos++;
                                    continue;
                                }
                                int32_t ws = valuePos;
                                while((ws < s->get_Length())) {
                                    if((Char::IsWhiteSpace(s->get_Chars(ws)) || ((int32_t)(s->get_Chars(ws)) ==  44))) 
                                    {
                                        ws++;
                                    }
                                     else 
                                    {
                                        break;
                                    }
                                }
                                valuePos = ws;
                                ws = pos;
                                while((ws < chars->get_Length())) {
                                    if((Char::IsWhiteSpace(chars->get_Chars(ws)) || ((int32_t)(chars->get_Chars(ws)) ==  44))) 
                                    {
                                        ws++;
                                    }
                                     else 
                                    {
                                        break;
                                    }
                                }
                                pos = ws;
                                if(((!(exact) && (pos < chars->get_Length())) && ((int32_t)(chars->get_Chars(pos)) ==  47))) 
                                {
                                    if(!(_ParseDateSeparator(s, valuePos, dfi, exact, num_parsed))) 
                                    {
                                        pos++;
                                    }
                                }
                                continue;
                            }
                        }
                    }
                }
            }
            if(((((pos + num) + 1) < len) && ((int32_t)(chars->get_Chars(((pos + num) + 1))) ==  (int32_t)(chars->get_Chars((pos + num)))))) 
            {
                num++;
                continue;
            }
            switch(chars->get_Chars(pos)) {
                case u'd': case_5: {
                    if((((num < 2) && (day != -1)) || ((num >= 2) && (dayofweek != -1)))) 
                    {
                        return false;
                    }
                    if((num ==  0)) 
                    {
                        day = _ParseNumber(s, valuePos, 1, 2, false, sloppy_parsing, num_parsed);
                    }
                     else 
                    {
                        if((num ==  1)) 
                        {
                            day = _ParseNumber(s, valuePos, 1, 2, true, sloppy_parsing, num_parsed);
                        }
                         else 
                        {
                            if((num ==  2)) 
                            {
                                dayofweek = _ParseEnum(s, valuePos, dfi->get_RawAbbreviatedDayNames(), invInfo->get_RawAbbreviatedDayNames(), exact, num_parsed);
                            }
                             else 
                            {
                                dayofweek = _ParseEnum(s, valuePos, dfi->get_RawDayNames(), invInfo->get_RawDayNames(), exact, num_parsed);
                            }
                        }
                    }
                    break;
                }
                case u'M': case_6: {
                    if((month != -1)) 
                    {
                        return false;
                    }
                    if(flexibleTwoPartsParsing) 
                    {
                        num_parsed = -1;
                        if(((num ==  0) || (num ==  3))) 
                        {
                            month = _ParseNumber(s, valuePos, 1, 2, false, sloppy_parsing, num_parsed);
                        }
                        if(((num > 1) && (num_parsed ==  -1))) 
                        {
                            month = (_ParseEnum(s, valuePos, dfi->get_RawMonthNames(), invInfo->get_RawMonthNames(), exact, num_parsed) + 1);
                        }
                        if(((num > 1) && (num_parsed ==  -1))) 
                        {
                            month = (_ParseEnum(s, valuePos, dfi->get_RawAbbreviatedMonthNames(), invInfo->get_RawAbbreviatedMonthNames(), exact, num_parsed) + 1);
                        }
                        break;
                    }
                    if((num ==  0)) 
                    {
                        month = _ParseNumber(s, valuePos, 1, 2, false, sloppy_parsing, num_parsed);
                    }
                     else 
                    {
                        if((num ==  1)) 
                        {
                            month = _ParseNumber(s, valuePos, 1, 2, true, sloppy_parsing, num_parsed);
                        }
                         else 
                        {
                            if((num ==  2)) 
                            {
                                month = (_ParseEnum(s, valuePos, dfi->get_RawAbbreviatedMonthNames(), invInfo->get_RawAbbreviatedMonthNames(), exact, num_parsed) + 1);
                            }
                             else 
                            {
                                month = (_ParseEnum(s, valuePos, dfi->get_RawMonthNames(), invInfo->get_RawMonthNames(), exact, num_parsed) + 1);
                            }
                        }
                    }
                    break;
                }
                case u'y': case_7: {
                    if((year != -1)) 
                    {
                        return false;
                    }
                    if((num ==  0)) 
                    {
                        year = _ParseNumber(s, valuePos, 1, 2, false, sloppy_parsing, num_parsed);
                    }
                     else 
                    {
                        if((num < 3)) 
                        {
                            year = _ParseNumber(s, valuePos, 1, 2, true, sloppy_parsing, num_parsed);
                        }
                         else 
                        {
                            year = _ParseNumber(s, valuePos, exact ? 4 : 3, 4, false, sloppy_parsing, num_parsed);
                            if(((((year >= 1000) && (num_parsed ==  4)) && !(longYear)) && (s->get_Length() > (4 + valuePos)))) 
                            {
                                int32_t np = 0;
                                int32_t ly = _ParseNumber(s, valuePos, 5, 5, false, sloppy_parsing, np);
                                longYear = (ly > 9999);
                            }
                            num = 3;
                        }
                    }
                    if((num_parsed <= 2)) 
                    {
                        (year = year + (year < 30) ? 2000 : 1900);
                    }
                    break;
                }
                case u'h': case_8: {
                    if((hour != -1)) 
                    {
                        return false;
                    }
                    if((num ==  0)) 
                    {
                        hour = _ParseNumber(s, valuePos, 1, 2, false, sloppy_parsing, num_parsed);
                    }
                     else 
                    {
                        hour = _ParseNumber(s, valuePos, 1, 2, true, sloppy_parsing, num_parsed);
                    }
                    if((hour > 12)) 
                    {
                        return false;
                    }
                    if((hour ==  12)) 
                    {
                        hour = 0;
                    }
                    break;
                }
                case u'H': case_9: {
                    if(((hour != -1) || (!(flexibleTwoPartsParsing) && (ampm >= 0)))) 
                    {
                        return false;
                    }
                    if((num ==  0)) 
                    {
                        hour = _ParseNumber(s, valuePos, 1, 2, false, sloppy_parsing, num_parsed);
                    }
                     else 
                    {
                        hour = _ParseNumber(s, valuePos, 1, 2, true, sloppy_parsing, num_parsed);
                    }
                    if((hour >= 24)) 
                    {
                        return false;
                    }
                    format_with_24_hours = true;
                    break;
                }
                case u'm': case_10: {
                    if((minute != -1)) 
                    {
                        return false;
                    }
                    if((num ==  0)) 
                    {
                        minute = _ParseNumber(s, valuePos, 1, 2, false, sloppy_parsing, num_parsed);
                    }
                     else 
                    {
                        minute = _ParseNumber(s, valuePos, 1, 2, true, sloppy_parsing, num_parsed);
                    }
                    if((minute >= 60)) 
                    {
                        return false;
                    }
                    break;
                }
                case u's': case_11: {
                    if((second != -1)) 
                    {
                        return false;
                    }
                    if((num ==  0)) 
                    {
                        second = _ParseNumber(s, valuePos, 1, 2, false, sloppy_parsing, num_parsed);
                    }
                     else 
                    {
                        second = _ParseNumber(s, valuePos, 1, 2, true, sloppy_parsing, num_parsed);
                    }
                    if((second >= 60)) 
                    {
                        return false;
                    }
                    break;
                }
                case u'F': case_12: {
                    leading_zeros = false;
                    goto case_13;
                }
                case u'f': case_13: {
                    if(((num > 6) || (fractionalSeconds != std::numeric_limits<double>::epsilon()))) 
                    {
                        return false;
                    }
                    double decimalNumber = (double)(_ParseNumber(s, valuePos, 0, (num + 1), leading_zeros, sloppy_parsing, num_parsed));
                    if((num_parsed ==  -1)) 
                    {
                        return false;
                    }
                    fractionalSeconds = (decimalNumber / Math::Pow(10., (double)(num_parsed)));
                    break;
                }
                case u't': case_14: {
                    if(!(_ParseAmPm(s, valuePos, (num > 0) ? 0 : 1, dfi, exact, num_parsed, ampm))) 
                    {
                        return false;
                    }
                    break;
                }
                case u'z': case_15: {
                    if((tzsign != -1)) 
                    {
                        return false;
                    }
                    if(((int32_t)(s->get_Chars(valuePos)) ==  43)) 
                    {
                        tzsign = 0;
                    }
                     else 
                    {
                        if(((int32_t)(s->get_Chars(valuePos)) ==  45)) 
                        {
                            tzsign = 1;
                        }
                         else 
                        {
                            return false;
                        }
                    }
                    valuePos++;
                    if((num ==  0)) 
                    {
                        tzoffset = _ParseNumber(s, valuePos, 1, 2, false, sloppy_parsing, num_parsed);
                    }
                     else 
                    {
                        if((num ==  1)) 
                        {
                            tzoffset = _ParseNumber(s, valuePos, 1, 2, true, sloppy_parsing, num_parsed);
                        }
                         else 
                        {
                            tzoffset = _ParseNumber(s, valuePos, 1, 2, true, true, num_parsed);
                            (valuePos = valuePos + num_parsed);
                            if((num_parsed < 0)) 
                            {
                                return false;
                            }
                            num_parsed = 0;
                            if((((valuePos < s->get_Length()) && Char::IsDigit(s->get_Chars(valuePos))) || _ParseTimeSeparator(s, valuePos, dfi, exact, num_parsed))) 
                            {
                                (valuePos = valuePos + num_parsed);
                                tzoffmin = _ParseNumber(s, valuePos, 1, 2, true, sloppy_parsing, num_parsed);
                                if((num_parsed < 0)) 
                                {
                                    return false;
                                }
                            }
                             else 
                            {
                                if(!(flexibleTwoPartsParsing)) 
                                {
                                    return false;
                                }
                                 else 
                                {
                                    num_parsed = 0;
                                }
                            }
                        }
                    }
                    break;
                }
                case u'K': case_16: {
                    if(((int32_t)(s->get_Chars(valuePos)) ==  90)) 
                    {
                        valuePos++;
                        useutc = true;
                    }
                     else 
                    {
                        if((((int32_t)(s->get_Chars(valuePos)) ==  43) || ((int32_t)(s->get_Chars(valuePos)) ==  45))) 
                        {
                            if((tzsign != -1)) 
                            {
                                return false;
                            }
                            if(((int32_t)(s->get_Chars(valuePos)) ==  43)) 
                            {
                                tzsign = 0;
                            }
                             else 
                            {
                                if(((int32_t)(s->get_Chars(valuePos)) ==  45)) 
                                {
                                    tzsign = 1;
                                }
                            }
                            valuePos++;
                            tzoffset = _ParseNumber(s, valuePos, 0, 2, true, sloppy_parsing, num_parsed);
                            (valuePos = valuePos + num_parsed);
                            if((num_parsed < 0)) 
                            {
                                return false;
                            }
                            if(Char::IsDigit(s->get_Chars(valuePos))) 
                            {
                                num_parsed = 0;
                            }
                             else 
                            {
                                if(!(_ParseString(s, valuePos, 0, dfi->get_TimeSeparator(), num_parsed))) 
                                {
                                    return false;
                                }
                            }
                            (valuePos = valuePos + num_parsed);
                            tzoffmin = _ParseNumber(s, valuePos, 0, 2, true, sloppy_parsing, num_parsed);
                            num = 2;
                            if((num_parsed < 0)) 
                            {
                                return false;
                            }
                        }
                    }
                    break;
                }
                case u'Z': case_17: {
                    if(((int32_t)(s->get_Chars(valuePos)) != 90)) 
                    {
                        return false;
                    }
                    num = 0;
                    num_parsed = 1;
                    useutc = true;
                    break;
                }
                case u'G': case_18: {
                    if(((int32_t)(s->get_Chars(valuePos)) != 71)) 
                    {
                        return false;
                    }
                    if((((((((pos + 2) < len) && ((valuePos + 2) < s->get_Length())) && ((int32_t)(chars->get_Chars((pos + 1))) ==  77)) && ((int32_t)(s->get_Chars((valuePos + 1))) ==  77)) && ((int32_t)(chars->get_Chars((pos + 2))) ==  84)) && ((int32_t)(s->get_Chars((valuePos + 2))) ==  84))) 
                    {
                        useutc = true;
                        num = 2;
                        num_parsed = 3;
                    }
                     else 
                    {
                        num = 0;
                        num_parsed = 1;
                    }
                    break;
                }
                case u':': case_19: {
                    if(!(_ParseTimeSeparator(s, valuePos, dfi, exact, num_parsed))) 
                    {
                        return false;
                    }
                    break;
                }
                case u'/': case_20: {
                    if(!(_ParseDateSeparator(s, valuePos, dfi, exact, num_parsed))) 
                    {
                        return false;
                    }
                    num = 0;
                    break;
                }
                case u'.': case_21: {
                    if(((int32_t)(s->get_Chars(valuePos)) ==  46)) 
                    {
                        num = 0;
                        num_parsed = 1;
                        break;
                    }
                    if((((pos + 1) < len) && ((int32_t)(chars->get_Chars((pos + 1))) ==  70))) 
                    {
                        ++pos;
                        while(((pos < len) && ((int32_t)(chars->get_Chars((pos + 1))) ==  70))) {
                            ++pos;
                        }
                        num = 0;
                        num_parsed = 0;
                        break;
                    }
                    return false;
                }
                default: case_22: {
                    if(((int32_t)(s->get_Chars(valuePos)) != (int32_t)(chars->get_Chars(pos)))) 
                    {
                        return false;
                    }
                    num = 0;
                    num_parsed = 1;
                    break;
                }
            }
            if((num_parsed < 0)) 
            {
                return false;
            }
            (valuePos = valuePos + num_parsed);
            if((!(exact) && !(flexibleTwoPartsParsing))) 
            {
                switch(chars->get_Chars(pos)) {
                    case u'm': case u's': case u'F': case u'f': case u'z': case_23: {
                        if((((s->get_Length() > valuePos) && ((int32_t)(s->get_Chars(valuePos)) ==  90)) && (((pos + 1) ==  chars->get_Length()) || ((int32_t)(chars->get_Chars((pos + 1))) != 90)))) 
                        {
                            useutc = true;
                            valuePos++;
                        }
                        break;
                    }
                }
            }
            pos = ((pos + num) + 1);
            num = 0;
        }
        if(((((pos + 1) < len) && ((int32_t)(chars->get_Chars(pos)) ==  46)) && ((int32_t)(chars->get_Chars((pos + 1))) ==  70))) 
        {
            pos++;
            while(((pos < len) && ((int32_t)(chars->get_Chars(pos)) ==  70))) pos++;
        }
        while(((pos < len) && ((int32_t)(chars->get_Chars(pos)) ==  75))) pos++;
        if((pos < len)) 
        {
            return false;
        }
        if((s->get_Length() > valuePos)) 
        {
            if((valuePos ==  0)) 
            {
                return false;
            }
            if((Char::IsDigit(s->get_Chars(valuePos)) && Char::IsDigit(s->get_Chars((valuePos - 1))))) 
            {
                return false;
            }
            if((Char::IsLetter(s->get_Chars(valuePos)) && Char::IsLetter(s->get_Chars((valuePos - 1))))) 
            {
                return false;
            }
            incompleteFormat = true;
            return false;
        }
        if((hour ==  -1)) 
        {
            hour = 0;
        }
        if((minute ==  -1)) 
        {
            minute = 0;
        }
        if((second ==  -1)) 
        {
            second = 0;
        }
        if((fractionalSeconds ==  std::numeric_limits<double>::epsilon())) 
        {
            fractionalSeconds = std::numeric_limits<double>::epsilon();
        }
        if((((day ==  -1) && (month ==  -1)) && (year ==  -1))) 
        {
            if(((int32_t)(((int32_t)(style) & 8)) != 0)) 
            {
                day = 1;
                month = 1;
                year = 1;
            }
             else 
            {
                day = DateTime::get_Today()->get_Day();
                month = DateTime::get_Today()->get_Month();
                year = DateTime::get_Today()->get_Year();
            }
        }
        if((day ==  -1)) 
        {
            day = 1;
        }
        if((month ==  -1)) 
        {
            month = 1;
        }
        if((year ==  -1)) 
        {
            if(((int32_t)(((int32_t)(style) & 8)) != 0)) 
            {
                year = 1;
            }
             else 
            {
                year = DateTime::get_Today()->get_Year();
            }
        }
        if((ampm ==  0)) 
        {
            if((((hour >= 12) && format_with_24_hours) && exact)) 
            {
                return false;
            }
            if((hour ==  12)) 
            {
                hour = 0;
            }
        }
         else 
        {
            if((ampm ==  1)) 
            {
                if((hour < 12)) 
                {
                    if((format_with_24_hours && exact)) 
                    {
                        return false;
                    }
                    (hour = hour + 12);
                }
            }
        }
        if(((((((((((((year < 1) || (year > 9999)) || (month < 1)) || (month > 12)) || (day < 1)) || (day > DateTime::DaysInMonth(year, month))) || (hour < 0)) || (hour > 23)) || (minute < 0)) || (minute > 59)) || (second < 0)) || (second > 59))) 
        {
            return false;
        }
        result = cli::ctor<DateTime>(year, month, day, hour, minute, second, 0);
        result = result->AddSeconds(fractionalSeconds);
        if(((dayofweek != -1) && (dayofweek != (int32_t)(result->get_DayOfWeek())))) 
        {
            return false;
        }
        if((tzsign ==  -1)) 
        {
            if(op_Inequality(result, (*MinValue))) 
            {
                try {
                    dto = cli::ctor<DateTimeOffset>(result);
                }
                catch(...) {
                }
            }
        }
         else 
        {
            if((tzoffmin ==  -1)) 
            {
                tzoffmin = 0;
            }
            if((tzoffset ==  -1)) 
            {
                tzoffset = 0;
            }
            if((tzsign ==  1)) 
            {
                tzoffset = -(tzoffset);
                tzoffmin = -(tzoffmin);
            }
            try {
                dto = cli::ctor<DateTimeOffset>(result, cli::ctor<TimeSpan>(tzoffset, tzoffmin, 0));
            }
            catch(...) {
            }
        }
        bool adjustToUniversal = ((int32_t)(((int32_t)(style) & 16)) != 0);
        if((tzsign != -1)) 
        {
            int64_t newticks = op_Subtraction2(result, dto->get_Offset())->get_Ticks();
            if((newticks < 0L)) 
            {
                (newticks = newticks + 864000000000L);
            }
            result = cli::ctor<DateTime>(newticks, DateTimeKind::Utc);
            if(((int32_t)(((int32_t)(style) & 128)) != 0)) 
            {
                result = result->ToLocalTime();
            }
        }
         else 
        {
            if((useutc || ((int32_t)(((int32_t)(style) & 64)) != 0))) 
            {
                (result->encoded = result->encoded | 4611686018427387904L);
            }
             else 
            {
                if(((int32_t)(((int32_t)(style) & 32)) != 0)) 
                {
                    (result->encoded = result->encoded | (-9223372036854775807L - 1));
                }
            }
        }
        bool adjustToLocal = (!(adjustToUniversal) && ((int32_t)(((int32_t)(style) & 128)) ==  0));
        if(((int32_t)((int32_t)((uint64_t)result->encoded >> 62)) != 0)) 
        {
            if(adjustToUniversal) 
            {
                result = result->ToUniversalTime();
            }
             else 
            {
                if(adjustToLocal) 
                {
                    result = result->ToLocalTime();
                }
            }
        }
        return true;
    }
    
    DateTime DateTime::ParseExact2(String* s, String* format, IFormatProvider* provider, Globalization::DateTimeStyles style) {
        if((format ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("format"));
        }
        cli::array<String*> *formats = (new cli::array<String*>(1));
        formats->at(0) = format;
        return ParseExact3(s, formats, provider, style);
    }
    
    DateTime DateTime::ParseExact3(String* s, cli::array<String*>* formats, IFormatProvider* provider, Globalization::DateTimeStyles style) {
        Globalization::DateTimeFormatInfo *dfi = Globalization::DateTimeFormatInfo::GetInstance(provider);
        CheckStyle(style);
        if((s ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("s"));
        }
        if((formats ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("formats"));
        }
        if((formats->get_Length() ==  0)) 
        {
            throw cli::gcnew<FormatException>(_T("Format specifier was invalid."));
        }
        DateTime result;
        bool longYear = false;
        Exception *e = nullptr;
        if(!(ParseExact4(s, formats, dfi, style, result, true, longYear, true, e))) 
        {
            throw e;
        }
        return result;
    }
    
    void DateTime::CheckStyle(Globalization::DateTimeStyles style) {
        if(((int32_t)(((int32_t)(style) & 128)) != 0)) 
        {
            if(((((int32_t)(((int32_t)(style) & 16)) != 0) || ((int32_t)(((int32_t)(style) & 32)) != 0)) || ((int32_t)(((int32_t)(style) & 64)) != 0))) 
            {
                throw cli::gcnew<ArgumentException>(_T("The DateTimeStyles value RoundtripKind cannot be used with the values AssumeLocal, Asersal or AdjustToUniversal."), _T("style"));
            }
        }
        if((((int32_t)(((int32_t)(style) & 64)) != 0) && ((int32_t)(((int32_t)(style) & 32)) != 0))) 
        {
            throw cli::gcnew<ArgumentException>(_T("The DateTimeStyles values AssumeLocal and AssumeUniversal cannot be used together."), _T("style"));
        }
    }
    
    bool DateTime::TryParse(String* s, DateTime result) {
        if((s != nullptr)) 
        {
            try {
                Exception *exception = nullptr;
                DateTimeOffset dto;
                return CoreParse(s, nullptr, Globalization::DateTimeStyles::AllowWhiteSpaces, result, dto, false, exception);
            }
            catch(...) {
            }
        }
        result = (*MinValue);
        return false;
    }
    
    bool DateTime::TryParse2(String* s, IFormatProvider* provider, Globalization::DateTimeStyles styles, DateTime result) {
        if((s != nullptr)) 
        {
            try {
                Exception *exception = nullptr;
                DateTimeOffset dto;
                return CoreParse(s, provider, styles, result, dto, false, exception);
            }
            catch(...) {
            }
        }
        result = (*MinValue);
        return false;
    }
    
    bool DateTime::TryParseExact(String* s, String* format, IFormatProvider* provider, Globalization::DateTimeStyles style, DateTime result) {
        cli::array<String*> *formats;
        formats = (new cli::array<String*>(1));
        formats->at(0) = format;
        return TryParseExact2(s, formats, provider, style, result);
    }
    
    bool DateTime::TryParseExact2(String* s, cli::array<String*>* formats, IFormatProvider* provider, Globalization::DateTimeStyles style, DateTime result) {
        try {
            Globalization::DateTimeFormatInfo *dfi = Globalization::DateTimeFormatInfo::GetInstance(provider);
            bool longYear = false;
            Exception *e = nullptr;
            return ParseExact4(s, formats, dfi, style, result, true, longYear, false, e);
        }
        catch(...) {
            result = (*MinValue);
            return false;
        }
    }
    
    bool DateTime::ParseExact4(String* s, cli::array<String*>* formats, Globalization::DateTimeFormatInfo* dfi, Globalization::DateTimeStyles style, DateTime ret, bool exact, bool longYear, bool setExceptionOnError, Exception* exception) {
        int32_t i;
        bool incompleteFormat = false;
        for(i = 0; (i < formats->get_Length()); i++){
            DateTime result;
            String *format = formats->at(i);
            if(((format ==  nullptr) || String::op_Equality(format, String::Empty))) 
            {
                break;
            }
            DateTimeOffset dto;
            if(_DoParse(s, formats->at(i), nullptr, exact, result, dto, dfi, style, false, incompleteFormat, longYear)) 
            {
                ret = result;
                return true;
            }
        }
        if(setExceptionOnError) 
        {
            exception = cli::gcnew<FormatException>(_T("Invalid format string"));
        }
        ret = (*MinValue);
        return false;
    }
    
    TimeSpan DateTime::Subtract(DateTime value) {
        return TimeSpan::op_Subtraction(cli::ctor<TimeSpan>((*this)->get_Ticks()), cli::ctor<TimeSpan>(value->get_Ticks()));
    }
    
    DateTime DateTime::Subtract2(TimeSpan value) {
        int64_t newticks;
        newticks = ((*this)->get_Ticks() - value->get_Ticks());
        if(((newticks < 0L) || (newticks > 3155378975999999999L))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>();
        }
        DateTime ret = cli::ctor<DateTime>(newticks);
        (ret->encoded = ret->encoded | ((*this)->encoded & -4611686018427387904L));
        return ret;
    }
    
    int64_t DateTime::ToFileTime() {
        DateTime universalTime = ToUniversalTime();
        if((universalTime->get_Ticks() < 504911232000000000L)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("file time is not valid"));
        }
        return (universalTime->get_Ticks() - 504911232000000000L);
    }
    
    int64_t DateTime::ToFileTimeUtc() {
        if(((*this)->get_Ticks() < 504911232000000000L)) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("file time is not valid"));
        }
        return ((*this)->get_Ticks() - 504911232000000000L);
    }
    
    String* DateTime::ToLongDateString() {
        return ToString4(_T("D"));
    }
    
    String* DateTime::ToLongTimeString() {
        return ToString4(_T("T"));
    }
    
    double DateTime::ToOADate() {
        int64_t t = (*this)->get_Ticks();
        if((t ==  0L)) 
        {
            return std::numeric_limits<double>::epsilon();
        }
        if((t < 31242239136000000L)) 
        {
            return std::numeric_limits<double>::epsilon();
        }
        TimeSpan ts = cli::ctor<TimeSpan>(((*this)->get_Ticks() - 599264352000000000L));
        double result = ts->get_TotalDays();
        if((t < 599264352000000000L)) 
        {
            double d = Math::Ceiling2(result);
            result = ((d - 2.) - (result - d));
        }
         else 
        {
            if((result >= 2958466.)) 
            {
                result = 2958465.99999999;
            }
        }
        return result;
    }
    
    String* DateTime::ToShortDateString() {
        return ToString4(_T("d"));
    }
    
    String* DateTime::ToShortTimeString() {
        return ToString4(_T("t"));
    }
    
    String* DateTime::ToString_1636a0751cb9ac11() {
        return ToString5(_T("G"), nullptr);
    }
    
    String* DateTime::ToString3(IFormatProvider* provider) {
        return ToString5(nullptr, provider);
    }
    
    String* DateTime::ToString4(String* format) {
        return ToString5(format, nullptr);
    }
    
    String* DateTime::ToString5(String* format, IFormatProvider* provider) {
        Globalization::DateTimeFormatInfo *dfi = Globalization::DateTimeFormatInfo::GetInstance(provider);
        if(((format ==  nullptr) || String::op_Equality(format, String::Empty))) 
        {
            format = _T("G");
        }
        bool useutc = false, use_invariant = false;
        if((format->get_Length() ==  1)) 
        {
            char16_t fchar = format->get_Chars(0);
            format = DateTimeUtils::GetStandardPattern(fchar, dfi, useutc, use_invariant);
            if(((int32_t)(fchar) ==  85)) 
            {
                return DateTimeUtils::ToString2(ToUniversalTime(), format, dfi);
            }
            if((format ==  nullptr)) 
            {
                throw cli::gcnew<FormatException>(_T("format is not one of the format specifier characters defined for DateTimeFormatInfo"));
            }
        }
        return DateTimeUtils::ToString2((*this), format, dfi);
    }
    
    DateTime DateTime::ToLocalTime() {
        return TimeZone::get_CurrentTimeZone()->ToLocalTime_727a1d453c597b66((*this));
    }
    
    DateTime DateTime::ToUniversalTime() {
        return TimeZone::get_CurrentTimeZone()->ToUniversalTime_a2fdcc18b24d9d81((*this));
    }
    
    bool DateTime::ToBoolean(IFormatProvider* provider) {
        throw cli::gcnew<InvalidCastException>();
    }
    
    unsigned char DateTime::ToByte(IFormatProvider* provider) {
        throw cli::gcnew<InvalidCastException>();
    }
    
    char16_t DateTime::ToChar(IFormatProvider* provider) {
        throw cli::gcnew<InvalidCastException>();
    }
    
    DateTime DateTime::ToDateTime(IFormatProvider* provider) {
        return (*this);
    }
    
    Decimal DateTime::ToDecimal(IFormatProvider* provider) {
        throw cli::gcnew<InvalidCastException>();
    }
    
    double DateTime::ToDouble(IFormatProvider* provider) {
        throw cli::gcnew<InvalidCastException>();
    }
    
    int16_t DateTime::ToInt16(IFormatProvider* provider) {
        throw cli::gcnew<InvalidCastException>();
    }
    
    int32_t DateTime::ToInt32(IFormatProvider* provider) {
        throw cli::gcnew<InvalidCastException>();
    }
    
    int64_t DateTime::ToInt64(IFormatProvider* provider) {
        throw cli::gcnew<InvalidCastException>();
    }
    
    signed char DateTime::ToSByte(IFormatProvider* provider) {
        throw cli::gcnew<InvalidCastException>();
    }
    
    float DateTime::ToSingle(IFormatProvider* provider) {
        throw cli::gcnew<InvalidCastException>();
    }
    
    Object* DateTime::ToType(Type* targetType, IFormatProvider* provider) {
        if(Type::op_Equality2(targetType, nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("targetType"));
        }
        if(Type::op_Equality2(targetType, cli::typeof<Type>::info)) 
        {
            return cli::box((*this));
        }
         else 
        {
            if(Type::op_Equality2(targetType, cli::typeof<Type>::info)) 
            {
                return (*this)->ToString3(provider);
            }
             else 
            {
                if(Type::op_Equality2(targetType, cli::typeof<Type>::info)) 
                {
                    return cli::box((*this));
                }
                 else 
                {
                    throw cli::gcnew<InvalidCastException>();
                }
            }
        }
    }
    
    uint16_t DateTime::ToUInt16(IFormatProvider* provider) {
        throw cli::gcnew<InvalidCastException>();
    }
    
    uint32_t DateTime::ToUInt32(IFormatProvider* provider) {
        throw cli::gcnew<InvalidCastException>();
    }
    
    uint64_t DateTime::ToUInt64(IFormatProvider* provider) {
        throw cli::gcnew<InvalidCastException>();
    }
    
    void DateTime::GetObjectData(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        int64_t t = (*this)->get_Ticks();
        info->AddValue14(_T("ticks"), t);
        info->AddValue14(_T("dateData"), (*this)->encoded);
    }
    
    DateTime DateTime::op_Addition(DateTime d, TimeSpan t) {
        try {
            int64_t res = cli::checked(((d->encoded & 4611686018427387903L) + t->get_Ticks()));
            if(((res < 0L) || (res > 3155378975999999999L))) 
            {
                throw cli::gcnew<ArgumentOutOfRangeException>();
            }
            return cli::ctor<DateTime>(res, d->get_Kind());
        }
        catch(OverflowException*) {
            throw cli::gcnew<ArgumentOutOfRangeException>();
        }
    }
    
    bool DateTime::op_Equality(DateTime d1, DateTime d2) {
        return ((d1->encoded & 4611686018427387903L) ==  (d2->encoded & 4611686018427387903L));
    }
    
    bool DateTime::op_GreaterThan(DateTime t1, DateTime t2) {
        return ((t1->encoded & 4611686018427387903L) > (t2->encoded & 4611686018427387903L));
    }
    
    bool DateTime::op_GreaterThanOrEqual(DateTime t1, DateTime t2) {
        return ((t1->encoded & 4611686018427387903L) >= (t2->encoded & 4611686018427387903L));
    }
    
    bool DateTime::op_Inequality(DateTime d1, DateTime d2) {
        return ((d1->encoded & 4611686018427387903L) != (d2->encoded & 4611686018427387903L));
    }
    
    bool DateTime::op_LessThan(DateTime t1, DateTime t2) {
        return ((t1->encoded & 4611686018427387903L) < (t2->encoded & 4611686018427387903L));
    }
    
    bool DateTime::op_LessThanOrEqual(DateTime t1, DateTime t2) {
        return ((t1->encoded & 4611686018427387903L) <= (t2->encoded & 4611686018427387903L));
    }
    
    TimeSpan DateTime::op_Subtraction(DateTime d1, DateTime d2) {
        return cli::ctor<TimeSpan>(((d1->encoded & 4611686018427387903L) - (d2->encoded & 4611686018427387903L)));
    }
    
    DateTime DateTime::op_Subtraction2(DateTime d, TimeSpan t) {
        try {
            int64_t res = cli::checked(((d->encoded & 4611686018427387903L) - t->get_Ticks()));
            if(((res < 0L) || (res > 3155378975999999999L))) 
            {
                throw cli::gcnew<ArgumentOutOfRangeException>();
            }
            return cli::ctor<DateTime>(res, d->get_Kind());
        }
        catch(OverflowException*) {
            throw cli::gcnew<ArgumentOutOfRangeException>();
        }
    }
    
    DateTime DateTime::get_Date() {
        DateTime ret = cli::ctor<DateTime>((*this)->get_Year(), (*this)->get_Month(), (*this)->get_Day());
        (ret->encoded = ret->encoded | ((*this)->encoded & -4611686018427387904L));
        return ret;
    }
    
    int32_t DateTime::get_Month() {
        return FromTicks(Which::Month5);
    }
    
    int32_t DateTime::get_Day() {
        return FromTicks(Which::Day);
    }
    
    DayOfWeek DateTime::get_DayOfWeek() {
        return (DayOfWeek)((int32_t)(((((*this)->encoded & 4611686018427387903L) / 864000000000L) + 1L) % 7L));
    }
    
    int32_t DateTime::get_DayOfYear() {
        return FromTicks(Which::DayYear);
    }
    
    TimeSpan DateTime::get_TimeOfDay() {
        return cli::ctor<TimeSpan>((((*this)->encoded & 4611686018427387903L) % 864000000000L));
    }
    
    int32_t DateTime::get_Hour() {
        return (int32_t)((((*this)->encoded & 4611686018427387903L) % 864000000000L) / 36000000000L);
    }
    
    int32_t DateTime::get_Minute() {
        return (int32_t)((((*this)->encoded & 4611686018427387903L) % 36000000000L) / 600000000L);
    }
    
    int32_t DateTime::get_Second() {
        return (int32_t)((((*this)->encoded & 4611686018427387903L) % 600000000L) / 10000000L);
    }
    
    int32_t DateTime::get_Millisecond() {
        return (int32_t)((((*this)->encoded & 4611686018427387903L) % 10000000L) / 10000L);
    }
    
    DateTime DateTime::get_Now() {
        int64_t now = GetNow();
        DateTime dt = cli::ctor<DateTime>(now);
        if(((now - last_now) > 600000000L)) 
        {
            to_local_time_span_object = cli::box(TimeZone::get_CurrentTimeZone()->GetLocalTimeDiff(dt));
            last_now = now;
        }
        DateTime ret = op_Addition(dt, cli::unbox<TimeSpan>(to_local_time_span_object));
        (ret->encoded = ret->encoded | (-9223372036854775807L - 1));
        return ret;
    }
    
    int64_t DateTime::get_Ticks() {
        return ((*this)->encoded & 4611686018427387903L);
    }
    
    DateTime DateTime::get_Today() {
        DateTime now = get_Now();
        DateTime today = cli::ctor<DateTime>(now->get_Year(), now->get_Month(), now->get_Day());
        (today->encoded = today->encoded | (-9223372036854775807L - 1));
        return today;
    }
    
    DateTime DateTime::get_UtcNow() {
        return cli::ctor<DateTime>(GetNow(), DateTimeKind::Utc);
    }
    
    int32_t DateTime::get_Year() {
        return FromTicks(Which::Year);
    }
    
    DateTimeKind DateTime::get_Kind() {
        return (DateTimeKind)((int32_t)((uint64_t)(*this)->encoded >> 62));
    }
    
}
namespace System {
    
    DateTimeOffset*  DateTimeOffset::MaxValue;
    DateTimeOffset*  DateTimeOffset::MinValue;
    
    void DateTimeOffset::constructor(DateTime dateTime) {
        (*this)->dt = dateTime;
        if(((int32_t)(dateTime->get_Kind()) ==  1)) 
        {
            (*this)->utc_offset = (*TimeSpan::Zero);
        }
         else 
        {
            (*this)->utc_offset = TimeZone::get_CurrentTimeZone()->GetUtcOffset_7ede31ceb7855151(dateTime);
        }
        if((DateTime::op_LessThan((*this)->get_UtcDateTime(), (*DateTime::MinValue)) || DateTime::op_GreaterThan((*this)->get_UtcDateTime(), (*DateTime::MaxValue)))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("The UTC date and time that results from applying the offset is earlier than MinValue or later than MaxValue."));
        }
    }
    
    void DateTimeOffset::constructor(DateTime dateTime, TimeSpan offset) {
        if((((int32_t)(dateTime->get_Kind()) ==  1) && TimeSpan::op_Inequality(offset, (*TimeSpan::Zero)))) 
        {
            throw cli::gcnew<ArgumentException>(_T("dateTime.Kind equals Utc and offset does not equal zero."));
        }
        if((((int32_t)(dateTime->get_Kind()) ==  2) && TimeSpan::op_Inequality(offset, TimeZone::get_CurrentTimeZone()->GetUtcOffset_7ede31ceb7855151(dateTime)))) 
        {
            throw cli::gcnew<ArgumentException>(_T("dateTime.Kind equals Local and offset does not equal the offset of the system\'s local time zone."));
        }
        if(((offset->get_Ticks() % 600000000L) != 0L)) 
        {
            throw cli::gcnew<ArgumentException>(_T("offset is not specified in whole minutes."));
        }
        if((TimeSpan::op_LessThan(offset, cli::ctor<TimeSpan>(-14, 0, 0)) || TimeSpan::op_GreaterThan(offset, cli::ctor<TimeSpan>(14, 0, 0)))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("offset is less than -14 hours or greater than 14 hours."));
        }
        (*this)->dt = dateTime;
        (*this)->utc_offset = offset;
        if((DateTime::op_LessThan((*this)->get_UtcDateTime(), (*DateTime::MinValue)) || DateTime::op_GreaterThan((*this)->get_UtcDateTime(), (*DateTime::MaxValue)))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("The UtcDateTime property is earlier than MinValue or later than MaxValue."));
        }
    }
    
    void DateTimeOffset::constructor(int64_t ticks, TimeSpan offset) {
    }
    
    void DateTimeOffset::constructor(int32_t year, int32_t month, int32_t day, int32_t hour, int32_t minute, int32_t second, TimeSpan offset) {
    }
    
    void DateTimeOffset::constructor(int32_t year, int32_t month, int32_t day, int32_t hour, int32_t minute, int32_t second, int32_t millisecond, TimeSpan offset) {
    }
    
    void DateTimeOffset::constructor(int32_t year, int32_t month, int32_t day, int32_t hour, int32_t minute, int32_t second, int32_t millisecond, Globalization::Calendar* calendar, TimeSpan offset) {
    }
    
    void DateTimeOffset::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        DateTime dt0 = cli::unbox<DateTime>(info->GetValue(_T("DateTime"), cli::typeof<Type>::info));
        int16_t totalMinutes = info->GetInt16(_T("OffsetMinutes"));
        (*this)->utc_offset = TimeSpan::FromMinutes((double)(totalMinutes));
        (*this)->dt = dt0->Add((*this)->utc_offset);
    }
    
    void DateTimeOffset::static_constructor() {
    }
    
    DateTimeOffset DateTimeOffset::Add(TimeSpan timeSpan) {
        return cli::ctor<DateTimeOffset>((*this)->dt->Add(timeSpan)->get_Ticks(), (*this)->utc_offset);
    }
    
    DateTimeOffset DateTimeOffset::AddDays(double days) {
        return cli::ctor<DateTimeOffset>((*this)->dt->AddDays(days)->get_Ticks(), (*this)->utc_offset);
    }
    
    DateTimeOffset DateTimeOffset::AddHours(double hours) {
        return cli::ctor<DateTimeOffset>((*this)->dt->AddHours(hours)->get_Ticks(), (*this)->utc_offset);
    }
    
    DateTimeOffset DateTimeOffset::AddMilliseconds(double milliseconds) {
        return cli::ctor<DateTimeOffset>((*this)->dt->AddMilliseconds(milliseconds)->get_Ticks(), (*this)->utc_offset);
    }
    
    DateTimeOffset DateTimeOffset::AddMinutes(double minutes) {
        return cli::ctor<DateTimeOffset>((*this)->dt->AddMinutes(minutes)->get_Ticks(), (*this)->utc_offset);
    }
    
    DateTimeOffset DateTimeOffset::AddMonths(int32_t months) {
        return cli::ctor<DateTimeOffset>((*this)->dt->AddMonths(months)->get_Ticks(), (*this)->utc_offset);
    }
    
    DateTimeOffset DateTimeOffset::AddSeconds(double seconds) {
        return cli::ctor<DateTimeOffset>((*this)->dt->AddSeconds(seconds)->get_Ticks(), (*this)->utc_offset);
    }
    
    DateTimeOffset DateTimeOffset::AddTicks(int64_t ticks) {
        return cli::ctor<DateTimeOffset>((*this)->dt->AddTicks(ticks)->get_Ticks(), (*this)->utc_offset);
    }
    
    DateTimeOffset DateTimeOffset::AddYears(int32_t years) {
        return cli::ctor<DateTimeOffset>((*this)->dt->AddYears(years)->get_Ticks(), (*this)->utc_offset);
    }
    
    int32_t DateTimeOffset::Compare(DateTimeOffset first, DateTimeOffset second) {
        return first->CompareTo(second);
    }
    
    int32_t DateTimeOffset::CompareTo(DateTimeOffset other) {
        return (*this)->get_UtcDateTime()->CompareTo2(other->get_UtcDateTime());
    }
    
    int32_t DateTimeOffset::CompareTo2(Object* obj) {
        return CompareTo(cli::unbox<DateTimeOffset>(obj));
    }
    
    bool DateTimeOffset::Equals(DateTimeOffset other) {
        return DateTime::op_Equality((*this)->get_UtcDateTime(), other->get_UtcDateTime());
    }
    
    bool DateTimeOffset::Equals_ed975d2f4a7d193e(Object* obj) {
        if(cli::is<DateTimeOffset>(obj)) 
        {
            return DateTime::op_Equality((*this)->get_UtcDateTime(), cli::unbox<DateTimeOffset>(obj)->get_UtcDateTime());
        }
        return false;
    }
    
    bool DateTimeOffset::Equals4(DateTimeOffset first, DateTimeOffset second) {
        return first->Equals(second);
    }
    
    bool DateTimeOffset::EqualsExact(DateTimeOffset other) {
        return (DateTime::op_Equality((*this)->dt, other->dt) && TimeSpan::op_Equality((*this)->utc_offset, other->utc_offset));
    }
    
    DateTimeOffset DateTimeOffset::FromFileTime(int64_t fileTime) {
        if(((fileTime < 0L) || (fileTime > (*MaxValue)->get_Ticks()))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("fileTime is less than zero or greater than DateTimeOffset.MaxValue.Ticks."));
        }
        return cli::ctor<DateTimeOffset>(DateTime::FromFileTime(fileTime), TimeZone::get_CurrentTimeZone()->GetUtcOffset_7ede31ceb7855151(DateTime::FromFileTime(fileTime)));
    }
    
    int32_t DateTimeOffset::GetHashCode_6648aef0f235ee6c() {
        return ((*this)->dt->GetHashCode_6648aef0f235ee6c() ^ (*this)->utc_offset->GetHashCode_6648aef0f235ee6c());
    }
    
    void DateTimeOffset::GetObjectData(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        if((info ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("info"));
        }
        DateTime dt0 = cli::ctor<DateTime>((*this)->dt->get_Ticks())->Subtract2((*this)->utc_offset);
        info->AddValue11(_T("DateTime"), dt0);
        info->AddValue2(_T("OffsetMinutes"), (int16_t)(*this)->utc_offset->get_TotalMinutes());
    }
    
    void DateTimeOffset::OnDeserialization(Object* sender) {
    }
    
    DateTimeOffset DateTimeOffset::Parse(String* input) {
        return Parse2(input, nullptr);
    }
    
    DateTimeOffset DateTimeOffset::Parse2(String* input, IFormatProvider* formatProvider) {
        return Parse3(input, formatProvider, Globalization::DateTimeStyles::AllowWhiteSpaces);
    }
    
    DateTimeOffset DateTimeOffset::Parse3(String* input, IFormatProvider* formatProvider, Globalization::DateTimeStyles styles) {
        if((input ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("input"));
        }
        DateTime d;
        DateTimeOffset dto;
        Exception *exception = nullptr;
        try {
            if(!(DateTime::CoreParse(input, formatProvider, styles, d, dto, true, exception))) 
            {
                throw exception;
            }
        }
        catch(ArgumentOutOfRangeException* ex) {
            throw cli::gcnew<FormatException>(_T("The UTC representation falls outside the 1-9999 year range"), ex);
        }
        if(((d->get_Ticks() != 0L) && (dto->get_Ticks() ==  0L))) 
        {
            throw cli::gcnew<FormatException>(_T("The UTC representation falls outside the 1-9999 year range"));
        }
        return dto;
    }
    
    DateTimeOffset DateTimeOffset::ParseExact(String* input, String* format, IFormatProvider* formatProvider) {
        return ParseExact2(input, format, formatProvider, Globalization::DateTimeStyles::AssumeLocal);
    }
    
    DateTimeOffset DateTimeOffset::ParseExact2(String* input, String* format, IFormatProvider* formatProvider, Globalization::DateTimeStyles styles) {
        if((format ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("format"));
        }
        if(String::op_Equality(format, String::Empty)) 
        {
            throw cli::gcnew<FormatException>(_T("format is an empty string"));
        }
        return ParseExact3(input, (new cli::array<String*>({format})), formatProvider, styles);
    }
    
    DateTimeOffset DateTimeOffset::ParseExact3(String* input, cli::array<String*>* formats, IFormatProvider* formatProvider, Globalization::DateTimeStyles styles) {
        if((input ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("input"));
        }
        if(String::op_Equality(input, String::Empty)) 
        {
            throw cli::gcnew<FormatException>(_T("input is an empty string"));
        }
        if((formats ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("formats"));
        }
        if((formats->get_Length() ==  0)) 
        {
            throw cli::gcnew<FormatException>(_T("Invalid format specifier"));
        }
        if((((int32_t)(((int32_t)(styles) & 32)) != 0) && ((int32_t)(((int32_t)(styles) & 64)) != 0))) 
        {
            throw cli::gcnew<ArgumentException>(_T("styles parameter contains incompatible flags"));
        }
        DateTimeOffset result;
        if(!(ParseExact4(input, formats, Globalization::DateTimeFormatInfo::GetInstance(formatProvider), styles, result))) 
        {
            throw cli::gcnew<FormatException>(_T("Invalid format string"));
        }
        return result;
    }
    
    bool DateTimeOffset::ParseExact4(String* input, cli::array<String*>* formats, Globalization::DateTimeFormatInfo* dfi, Globalization::DateTimeStyles styles, DateTimeOffset ret) {
        for(auto tmp_1 : formats) {
            auto format = cli::cast<String*>(tmp_1);
            {
                if(((format ==  nullptr) || String::op_Equality(format, String::Empty))) 
                {
                    throw cli::gcnew<FormatException>(_T("Invalid format string"));
                }
                DateTimeOffset result;
                if(DoParse(input, format, false, result, dfi, styles)) 
                {
                    ret = result;
                    return true;
                }
            }
        }
        ret = (*MinValue);
        return false;
    }
    
    bool DateTimeOffset::DoParse(String* input, String* format, bool exact, DateTimeOffset result, Globalization::DateTimeFormatInfo* dfi, Globalization::DateTimeStyles styles) {
        if(((int32_t)(((int32_t)(styles) & 1)) != 0)) 
        {
            format = format->TrimStart(nullptr);
            input = input->TrimStart(nullptr);
        }
        if(((int32_t)(((int32_t)(styles) & 2)) != 0)) 
        {
            format = format->TrimEnd(nullptr);
            input = input->TrimEnd(nullptr);
        }
        bool allow_white_spaces = false;
        if(((int32_t)(((int32_t)(styles) & 4)) != 0)) 
        {
            allow_white_spaces = true;
        }
        result = (*MinValue);
        bool useutc = false, use_invariants = false;
        if((format->get_Length() ==  1)) 
        {
            format = DateTimeUtils::GetStandardPattern2(format->get_Chars(0), dfi, useutc, use_invariants, true);
            if((format ==  nullptr)) 
            {
                return false;
            }
        }
        int32_t year = -1;
        int32_t month = -1;
        int32_t day = -1;
        int32_t partial_hour = -1;
        int32_t hour = -1;
        int32_t minute = -1;
        int32_t second = -1;
        double fraction = std::numeric_limits<double>::epsilon();
        int32_t temp_int = -1;
        TimeSpan offset = (*TimeSpan::MinValue);
        int32_t fi = 0;
        int32_t ii = 0;
        int32_t off_h, off_m = 0, sign;
        while((fi < format->get_Length())) {
            int32_t tokLen;
            char16_t ch = format->get_Chars(fi);
            switch(ch) {
                case u'd': case_24: {
                    tokLen = DateTimeUtils::CountRepeat(format, fi, ch);
                    if(((day != -1) || (tokLen > 4))) 
                    {
                        return false;
                    }
                    if((tokLen <= 2)) 
                    {
                        (ii = ii + ParseNumber(input, ii, 2, (tokLen ==  2), allow_white_spaces, day));
                    }
                     else 
                    {
                        (ii = ii + ParseEnum(input, ii, (tokLen ==  3) ? dfi->get_AbbreviatedDayNames() : dfi->get_DayNames(), allow_white_spaces, temp_int));
                    }
                    break;
                }
                case u'f': case_25: {
                    tokLen = DateTimeUtils::CountRepeat(format, fi, ch);
                    (ii = ii + ParseNumber(input, ii, tokLen, true, allow_white_spaces, temp_int));
                    if((((fraction >= std::numeric_limits<double>::epsilon()) || (tokLen > 7)) || (temp_int ==  -1))) 
                    {
                        return false;
                    }
                    fraction = ((double)(temp_int) / Math::Pow(10., (double)(tokLen)));
                    break;
                }
                case u'F': case_26: {
                    tokLen = DateTimeUtils::CountRepeat(format, fi, ch);
                    int32_t digits;
                    int32_t read = ParseNumber2(input, ii, tokLen, true, allow_white_spaces, temp_int, digits);
                    if((temp_int ==  -1)) 
                    {
                        (ii = ii + ParseNumber(input, ii, digits, true, allow_white_spaces, temp_int));
                    }
                     else 
                    {
                        (ii = ii + read);
                    }
                    if((((fraction >= std::numeric_limits<double>::epsilon()) || (tokLen > 7)) || (temp_int ==  -1))) 
                    {
                        return false;
                    }
                    fraction = ((double)(temp_int) / Math::Pow(10., (double)(digits)));
                    break;
                }
                case u'h': case_27: {
                    tokLen = DateTimeUtils::CountRepeat(format, fi, ch);
                    if(((hour != -1) || (tokLen > 2))) 
                    {
                        return false;
                    }
                    (ii = ii + ParseNumber(input, ii, 2, (tokLen ==  2), allow_white_spaces, temp_int));
                    if((temp_int ==  -1)) 
                    {
                        return false;
                    }
                    if((partial_hour ==  -1)) 
                    {
                        partial_hour = temp_int;
                    }
                     else 
                    {
                        hour = (partial_hour + temp_int);
                    }
                    break;
                }
                case u'H': case_28: {
                    tokLen = DateTimeUtils::CountRepeat(format, fi, ch);
                    if(((hour != -1) || (tokLen > 2))) 
                    {
                        return false;
                    }
                    (ii = ii + ParseNumber(input, ii, 2, (tokLen ==  2), allow_white_spaces, hour));
                    break;
                }
                case u'm': case_29: {
                    tokLen = DateTimeUtils::CountRepeat(format, fi, ch);
                    if(((minute != -1) || (tokLen > 2))) 
                    {
                        return false;
                    }
                    (ii = ii + ParseNumber(input, ii, 2, (tokLen ==  2), allow_white_spaces, minute));
                    break;
                }
                case u'M': case_30: {
                    tokLen = DateTimeUtils::CountRepeat(format, fi, ch);
                    if(((month != -1) || (tokLen > 4))) 
                    {
                        return false;
                    }
                    if((tokLen <= 2)) 
                    {
                        (ii = ii + ParseNumber(input, ii, 2, (tokLen ==  2), allow_white_spaces, month));
                    }
                     else 
                    {
                        (ii = ii + ParseEnum(input, ii, (tokLen ==  3) ? dfi->get_AbbreviatedMonthNames() : dfi->get_MonthNames(), allow_white_spaces, month));
                        (month = month + 1);
                    }
                    break;
                }
                case u's': case_31: {
                    tokLen = DateTimeUtils::CountRepeat(format, fi, ch);
                    if(((second != -1) || (tokLen > 2))) 
                    {
                        return false;
                    }
                    (ii = ii + ParseNumber(input, ii, 2, (tokLen ==  2), allow_white_spaces, second));
                    break;
                }
                case u't': case_32: {
                    tokLen = DateTimeUtils::CountRepeat(format, fi, ch);
                    if(((hour != -1) || (tokLen > 2))) 
                    {
                        return false;
                    }
                    (ii = ii + ParseEnum(input, ii, (tokLen ==  1) ? (new cli::array<String*>({cli::gcnew<String>(dfi->get_AMDesignator()->get_Chars(0), 1), cli::gcnew<String>(dfi->get_PMDesignator()->get_Chars(0), 0)})) : (new cli::array<String*>({dfi->get_AMDesignator(), dfi->get_PMDesignator()})), allow_white_spaces, temp_int));
                    if((temp_int ==  -1)) 
                    {
                        return false;
                    }
                    if((partial_hour ==  -1)) 
                    {
                        partial_hour = (temp_int * 12);
                    }
                     else 
                    {
                        hour = (partial_hour + (temp_int * 12));
                    }
                    break;
                }
                case u'y': case_33: {
                    if((year != -1)) 
                    {
                        return false;
                    }
                    tokLen = DateTimeUtils::CountRepeat(format, fi, ch);
                    if((tokLen <= 2)) 
                    {
                        (ii = ii + ParseNumber(input, ii, 2, (tokLen ==  2), allow_white_spaces, year));
                        if((year != -1)) 
                        {
                            year = dfi->get_Calendar()->ToFourDigitYear_cb92a104112b3121(year);
                        }
                    }
                     else 
                    {
                        if((tokLen <= 4)) 
                        {
                            int32_t digit_parsed;
                            (ii = ii + ParseNumber2(input, ii, 5, false, allow_white_spaces, year, digit_parsed));
                            if(((digit_parsed < tokLen) || ((digit_parsed > tokLen) && (((double)(year) / Math::Pow(10., (double)((digit_parsed - 1)))) < 1.)))) 
                            {
                                return false;
                            }
                        }
                         else 
                        {
                            (ii = ii + ParseNumber(input, ii, tokLen, true, allow_white_spaces, year));
                        }
                    }
                    break;
                }
                case u'K': case_34: {
                    tokLen = 1;
                    temp_int = 0;
                    (ii = ii + ParseEnum(input, ii, (new cli::array<String*>({_T("-"), _T("+")})), allow_white_spaces, sign));
                    (ii = ii + ParseNumber(input, ii, 4, false, false, off_h));
                    if((((off_h ==  -1) || (off_m ==  -1)) || (sign ==  -1))) 
                    {
                        return false;
                    }
                    if((sign ==  0)) 
                    {
                        sign = -1;
                    }
                    offset = cli::ctor<TimeSpan>((sign * off_h), (sign * off_m), 0);
                    break;
                }
                case u'z': case_35: {
                    tokLen = DateTimeUtils::CountRepeat(format, fi, ch);
                    if((TimeSpan::op_Inequality(offset, (*TimeSpan::MinValue)) || (tokLen > 3))) 
                    {
                        return false;
                    }
                    off_m = 0;
                    temp_int = 0;
                    (ii = ii + ParseEnum(input, ii, (new cli::array<String*>({_T("-"), _T("+")})), allow_white_spaces, sign));
                    (ii = ii + ParseNumber(input, ii, 2, (tokLen != 1), false, off_h));
                    if((tokLen ==  3)) 
                    {
                        (ii = ii + ParseEnum(input, ii, (new cli::array<String*>({dfi->get_TimeSeparator()})), false, temp_int));
                        (ii = ii + ParseNumber(input, ii, 2, true, false, off_m));
                    }
                    if((((off_h ==  -1) || (off_m ==  -1)) || (sign ==  -1))) 
                    {
                        return false;
                    }
                    if((sign ==  0)) 
                    {
                        sign = -1;
                    }
                    offset = cli::ctor<TimeSpan>((sign * off_h), (sign * off_m), 0);
                    break;
                }
                case u':': case_36: {
                    tokLen = 1;
                    (ii = ii + ParseEnum(input, ii, (new cli::array<String*>({dfi->get_TimeSeparator()})), false, temp_int));
                    if((temp_int ==  -1)) 
                    {
                        return false;
                    }
                    break;
                }
                case u'/': case_37: {
                    tokLen = 1;
                    (ii = ii + ParseEnum(input, ii, (new cli::array<String*>({dfi->get_DateSeparator()})), false, temp_int));
                    if((temp_int ==  -1)) 
                    {
                        return false;
                    }
                    break;
                }
                case u'%': case_38: {
                    tokLen = 1;
                    if((fi != 0)) 
                    {
                        return false;
                    }
                    break;
                }
                case u' ': case_39: {
                    tokLen = 1;
                    (ii = ii + ParseChar(input, ii, u' ', false, temp_int));
                    if((temp_int ==  -1)) 
                    {
                        return false;
                    }
                    break;
                }
                case u'\\': case_40: {
                    tokLen = 2;
                    (ii = ii + ParseChar(input, ii, format->get_Chars((fi + 1)), allow_white_spaces, temp_int));
                    if((temp_int ==  -1)) 
                    {
                        return false;
                    }
                    break;
                }
                case u'\'': case u'"': case_41: {
                    tokLen = 1;
                    while((ii < input->get_Length())) {
                        char16_t ftoken = format->get_Chars((fi + tokLen));
                        ++tokLen;
                        if(((int32_t)(ftoken) ==  (int32_t)(format->get_Chars(fi)))) 
                        {
                            if(((((useutc && (tokLen ==  5)) && ((int32_t)(input->get_Chars((ii - 3))) ==  71)) && ((int32_t)(input->get_Chars((ii - 2))) ==  77)) && ((int32_t)(input->get_Chars((ii - 1))) ==  84))) 
                            {
                                offset = (*TimeSpan::Zero);
                            }
                            break;
                        }
                        if(((int32_t)(ftoken) != (int32_t)(input->get_Chars(ii++)))) 
                        {
                            return false;
                        }
                    }
                    break;
                }
                default: case_42: {
                    tokLen = 1;
                    (ii = ii + ParseChar(input, ii, format->get_Chars(fi), allow_white_spaces, temp_int));
                    if((temp_int ==  -1)) 
                    {
                        return false;
                    }
                    break;
                }
            }
            (fi = fi + tokLen);
        }
        if(TimeSpan::op_Equality(offset, (*TimeSpan::MinValue))) 
        {
            if(((int32_t)(((int32_t)(styles) & 64)) != 0)) 
            {
                offset = (*TimeSpan::Zero);
            }
             else 
            {
                if(((int32_t)(((int32_t)(styles) & 32)) != 0)) 
                {
                    offset = use_invariants ? (*TimeSpan::Zero) : TimeZone::get_CurrentTimeZone()->GetUtcOffset_7ede31ceb7855151(DateTime::get_Now());
                }
            }
        }
        if((hour < 0)) 
        {
            hour = 0;
        }
        if((minute < 0)) 
        {
            minute = 0;
        }
        if((second < 0)) 
        {
            second = 0;
        }
        if((fraction < std::numeric_limits<double>::epsilon())) 
        {
            fraction = std::numeric_limits<double>::epsilon();
        }
        if((((year > 0) && (month > 0)) && (day > 0))) 
        {
            result = cli::ctor<DateTimeOffset>(year, month, day, hour, minute, second, 0, offset);
            result = result->AddSeconds(fraction);
            if(((int32_t)(((int32_t)(styles) & 16)) != 0)) 
            {
                result = result->ToUniversalTime();
            }
            return true;
        }
        return false;
    }
    
    int32_t DateTimeOffset::ParseNumber(String* input, int32_t pos, int32_t digits, bool leading_zero, bool allow_leading_white, int32_t result) {
        int32_t digit_parsed;
        return ParseNumber2(input, pos, digits, leading_zero, allow_leading_white, result, digit_parsed);
    }
    
    int32_t DateTimeOffset::ParseNumber2(String* input, int32_t pos, int32_t digits, bool leading_zero, bool allow_leading_white, int32_t result, int32_t digit_parsed) {
        int32_t char_parsed = 0;
        digit_parsed = 0;
        result = 0;
        for(; ((allow_leading_white && (pos < input->get_Length())) && ((int32_t)(input->get_Chars(pos)) ==  32)); pos++) {
            char_parsed++;
        }
        for(; (((pos < input->get_Length()) && Char::IsDigit(input->get_Chars(pos))) && (digits > 0)); pos++, char_parsed++, digit_parsed++, digits--) {
            result = ((10 * result) + (int32_t)((unsigned char)((int32_t)(input->get_Chars(pos)) - 48)));
        }
        if((leading_zero && (digits > 0))) 
        {
            result = -1;
        }
        if((digit_parsed ==  0)) 
        {
            result = -1;
        }
        return char_parsed;
    }
    
    int32_t DateTimeOffset::ParseEnum(String* input, int32_t pos, cli::array<String*>* enums, bool allow_leading_white, int32_t result) {
        int32_t char_parsed = 0;
        result = -1;
        for(; ((allow_leading_white && (pos < input->get_Length())) && ((int32_t)(input->get_Chars(pos)) ==  32)); pos++) {
            char_parsed++;
        }
        for(int32_t i = 0; (i < enums->get_Length()); i++) {
            if(input->Substring(pos)->StartsWith(enums->at(i))) 
            {
                result = i;
                break;
            }
        }
        if((result >= 0)) 
        {
            (char_parsed = char_parsed + enums->at(result)->get_Length());
        }
        return char_parsed;
    }
    
    int32_t DateTimeOffset::ParseChar(String* input, int32_t pos, char16_t c, bool allow_leading_white, int32_t result) {
        int32_t char_parsed = 0;
        result = -1;
        for(; ((allow_leading_white && (pos < input->get_Length())) && ((int32_t)(input->get_Chars(pos)) ==  32)); pos++, char_parsed++) {;
        }
        if(((pos < input->get_Length()) && ((int32_t)(input->get_Chars(pos)) ==  (int32_t)(c)))) 
        {
            result = (int32_t)(c);
            char_parsed++;
        }
        return char_parsed;
    }
    
    TimeSpan DateTimeOffset::Subtract(DateTimeOffset value) {
        return DateTime::op_Subtraction((*this)->get_UtcDateTime(), value->get_UtcDateTime());
    }
    
    DateTimeOffset DateTimeOffset::Subtract2(TimeSpan value) {
        return Add(TimeSpan::op_UnaryNegation(value));
    }
    
    int64_t DateTimeOffset::ToFileTime() {
        return (*this)->get_UtcDateTime()->ToFileTime();
    }
    
    DateTimeOffset DateTimeOffset::ToLocalTime() {
        return cli::ctor<DateTimeOffset>((*this)->get_UtcDateTime()->ToLocalTime(), TimeZone::get_CurrentTimeZone()->GetUtcOffset_7ede31ceb7855151((*this)->get_UtcDateTime()->ToLocalTime()));
    }
    
    DateTimeOffset DateTimeOffset::ToOffset(TimeSpan offset) {
        return cli::ctor<DateTimeOffset>(DateTime::op_Addition(DateTime::op_Subtraction2((*this)->dt, (*this)->utc_offset), offset), offset);
    }
    
    String* DateTimeOffset::ToString_1636a0751cb9ac11() {
        return ToString5(nullptr, nullptr);
    }
    
    String* DateTimeOffset::ToString3(IFormatProvider* formatProvider) {
        return ToString5(nullptr, formatProvider);
    }
    
    String* DateTimeOffset::ToString4(String* format) {
        return ToString5(format, nullptr);
    }
    
    String* DateTimeOffset::ToString5(String* format, IFormatProvider* formatProvider) {
        Globalization::DateTimeFormatInfo *dfi = Globalization::DateTimeFormatInfo::GetInstance(formatProvider);
        if(((format ==  nullptr) || String::op_Equality(format, String::Empty))) 
        {
            format = cli::concat(dfi->get_ShortDatePattern(), _T(" "));
        }
        bool to_utc = false, use_invariant = false;
        if((format->get_Length() ==  1)) 
        {
            char16_t fchar = format->get_Chars(0);
            try {
                format = DateTimeUtils::GetStandardPattern2(fchar, dfi, to_utc, use_invariant, true);
            }
            catch(...) {
                format = nullptr;
            }
            if((format ==  nullptr)) 
            {
                throw cli::gcnew<FormatException>(_T("format is not one of the format specifier characters defined for DateTimeFormatInfo"));
            }
        }
        return to_utc ? DateTimeUtils::ToString3((*this)->get_UtcDateTime(), cli::wrap_nullable((*TimeSpan::Zero)), format, dfi) : DateTimeUtils::ToString3((*this)->get_DateTime(), cli::wrap_nullable((*this)->get_Offset()), format, dfi);
    }
    
    DateTimeOffset DateTimeOffset::ToUniversalTime() {
        return cli::ctor<DateTimeOffset>((*this)->get_UtcDateTime(), (*TimeSpan::Zero));
    }
    
    bool DateTimeOffset::TryParse(String* input, DateTimeOffset result) {
        try {
            result = Parse(input);
            return true;
        }
        catch(...) {
            result = (*MinValue);
            return false;
        }
    }
    
    bool DateTimeOffset::TryParse2(String* input, IFormatProvider* formatProvider, Globalization::DateTimeStyles styles, DateTimeOffset result) {
        try {
            result = Parse3(input, formatProvider, styles);
            return true;
        }
        catch(...) {
            result = (*MinValue);
            return false;
        }
    }
    
    bool DateTimeOffset::TryParseExact(String* input, String* format, IFormatProvider* formatProvider, Globalization::DateTimeStyles styles, DateTimeOffset result) {
        try {
            result = ParseExact2(input, format, formatProvider, styles);
            return true;
        }
        catch(...) {
            result = (*MinValue);
            return false;
        }
    }
    
    bool DateTimeOffset::TryParseExact2(String* input, cli::array<String*>* formats, IFormatProvider* formatProvider, Globalization::DateTimeStyles styles, DateTimeOffset result) {
        try {
            result = ParseExact3(input, formats, formatProvider, styles);
            return true;
        }
        catch(...) {
            result = (*MinValue);
            return false;
        }
    }
    
    DateTimeOffset DateTimeOffset::op_Addition(DateTimeOffset dateTimeOffset, TimeSpan timeSpan) {
        return dateTimeOffset->Add(timeSpan);
    }
    
    bool DateTimeOffset::op_Equality(DateTimeOffset left, DateTimeOffset right) {
        return left->Equals(right);
    }
    
    bool DateTimeOffset::op_GreaterThan(DateTimeOffset left, DateTimeOffset right) {
        return DateTime::op_GreaterThan(left->get_UtcDateTime(), right->get_UtcDateTime());
    }
    
    bool DateTimeOffset::op_GreaterThanOrEqual(DateTimeOffset left, DateTimeOffset right) {
        return DateTime::op_GreaterThanOrEqual(left->get_UtcDateTime(), right->get_UtcDateTime());
    }
    
    DateTimeOffset DateTimeOffset::op_Implicit(DateTime dateTime) {
        return cli::ctor<DateTimeOffset>(dateTime);
    }
    
    bool DateTimeOffset::op_Inequality(DateTimeOffset left, DateTimeOffset right) {
        return DateTime::op_Inequality(left->get_UtcDateTime(), right->get_UtcDateTime());
    }
    
    bool DateTimeOffset::op_LessThan(DateTimeOffset left, DateTimeOffset right) {
        return DateTime::op_LessThan(left->get_UtcDateTime(), right->get_UtcDateTime());
    }
    
    bool DateTimeOffset::op_LessThanOrEqual(DateTimeOffset left, DateTimeOffset right) {
        return DateTime::op_LessThanOrEqual(left->get_UtcDateTime(), right->get_UtcDateTime());
    }
    
    TimeSpan DateTimeOffset::op_Subtraction(DateTimeOffset left, DateTimeOffset right) {
        return left->Subtract(right);
    }
    
    DateTimeOffset DateTimeOffset::op_Subtraction2(DateTimeOffset dateTimeOffset, TimeSpan timeSpan) {
        return dateTimeOffset->Subtract2(timeSpan);
    }
    
    DateTime DateTimeOffset::get_Date() {
        return DateTime::SpecifyKind((*this)->dt->get_Date(), DateTimeKind::Unspecified);
    }
    
    DateTime DateTimeOffset::get_DateTime() {
        return DateTime::SpecifyKind((*this)->dt, DateTimeKind::Unspecified);
    }
    
    int32_t DateTimeOffset::get_Day() {
        return (*this)->dt->get_Day();
    }
    
    DayOfWeek DateTimeOffset::get_DayOfWeek() {
        return (*this)->dt->get_DayOfWeek();
    }
    
    int32_t DateTimeOffset::get_DayOfYear() {
        return (*this)->dt->get_DayOfYear();
    }
    
    int32_t DateTimeOffset::get_Hour() {
        return (*this)->dt->get_Hour();
    }
    
    DateTime DateTimeOffset::get_LocalDateTime() {
        return (*this)->get_UtcDateTime()->ToLocalTime();
    }
    
    int32_t DateTimeOffset::get_Millisecond() {
        return (*this)->dt->get_Millisecond();
    }
    
    int32_t DateTimeOffset::get_Minute() {
        return (*this)->dt->get_Minute();
    }
    
    int32_t DateTimeOffset::get_Month() {
        return (*this)->dt->get_Month();
    }
    
    DateTimeOffset DateTimeOffset::get_Now() {
        return cli::ctor<DateTimeOffset>(DateTime::get_Now());
    }
    
    TimeSpan DateTimeOffset::get_Offset() {
        return (*this)->utc_offset;
    }
    
    int32_t DateTimeOffset::get_Second() {
        return (*this)->dt->get_Second();
    }
    
    int64_t DateTimeOffset::get_Ticks() {
        return (*this)->dt->get_Ticks();
    }
    
    TimeSpan DateTimeOffset::get_TimeOfDay() {
        return (*this)->dt->get_TimeOfDay();
    }
    
    DateTime DateTimeOffset::get_UtcDateTime() {
        return DateTime::SpecifyKind(DateTime::op_Subtraction2((*this)->dt, (*this)->utc_offset), DateTimeKind::Utc);
    }
    
    DateTimeOffset DateTimeOffset::get_UtcNow() {
        return cli::ctor<DateTimeOffset>(DateTime::get_UtcNow());
    }
    
    int64_t DateTimeOffset::get_UtcTicks() {
        return (*this)->get_UtcDateTime()->get_Ticks();
    }
    
    int32_t DateTimeOffset::get_Year() {
        return (*this)->dt->get_Year();
    }
    
}
namespace System {
    
    Decimal*  Decimal::MaxValueDiv10;
    
    void Decimal::constructor(int32_t lo, int32_t mid, int32_t hi, bool isNegative, unsigned char scale) {
        /*unchecked*/ {
            (*this)->lo = (uint32_t)lo;
            (*this)->mid = (uint32_t)mid;
            (*this)->hi = (uint32_t)hi;
            if(((uint32_t)(scale) > 28U)) 
            {
                throw cli::gcnew<ArgumentOutOfRangeException>(Locale::GetText(_T("scale must be between 0 and 28")));
            }
            (*this)->flags = (uint32_t)(scale);
            ((*this)->flags = (*this)->flags << 16);
            if(isNegative) 
            {
                ((*this)->flags = (*this)->flags | 2147483648U);
            }
        }
    }
    
    void Decimal::constructor(int32_t value) {
        /*unchecked*/ {
            (*this)->hi = (*this)->mid = 0U;
            if((value < 0)) 
            {
                (*this)->flags = 2147483648U;
                (*this)->lo = ((uint32_t)~(value) + 1U);
            }
             else 
            {
                (*this)->flags = 0U;
                (*this)->lo = (uint32_t)value;
            }
        }
    }
    
    void Decimal::constructor(uint32_t value) {
        (*this)->lo = value;
        (*this)->flags = (*this)->hi = (*this)->mid = 0U;
    }
    
    void Decimal::constructor(int64_t value) {
        /*unchecked*/ {
            (*this)->hi = 0U;
            if((value < 0L)) 
            {
                (*this)->flags = 2147483648U;
                uint64_t u = ((uint64_t)~(value) + 1UL);
                (*this)->lo = (uint32_t)u;
                (*this)->mid = (uint32_t)(u >> 32);
            }
             else 
            {
                (*this)->flags = 0U;
                uint64_t u = (uint64_t)value;
                (*this)->lo = (uint32_t)u;
                (*this)->mid = (uint32_t)(u >> 32);
            }
        }
    }
    
    void Decimal::constructor(uint64_t value) {
        /*unchecked*/ {
            (*this)->flags = (*this)->hi = 0U;
            (*this)->lo = (uint32_t)value;
            (*this)->mid = (uint32_t)(value >> 32);
        }
    }
    
    void Decimal::constructor(float value) {
        if((((((value > 7.922816E+28f) || (value < std::numeric_limits<float>::epsilon())) || Single::IsNaN(value)) || Single::IsNegativeInfinity(value)) || Single::IsPositiveInfinity(value))) 
        {
            throw cli::gcnew<OverflowException>(Locale::GetText2(_T("Value {0} is greater than Decimal.MaxValue or less than Decimal.MinValue"), (new cli::array<Object*>({cli::box(value)}))));
        }
        Decimal d = Decimal::Parse4(cli::import(value)->ToString3(Globalization::CultureInfo::get_InvariantCulture()), Globalization::NumberStyles::Float, Globalization::CultureInfo::get_InvariantCulture());
        (*this)->flags = d->flags;
        (*this)->hi = d->hi;
        (*this)->lo = d->lo;
        (*this)->mid = d->mid;
    }
    
    void Decimal::constructor(double value) {
        if((double2decimal((*this), value, 15) != 0)) 
        {
            throw cli::gcnew<OverflowException>();
        }
    }
    
    void Decimal::constructor(cli::array<int32_t>* bits) {
        if((bits ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(Locale::GetText(_T("Bits is a null reference")));
        }
        if((cli::import(bits)->GetLength(0) != 4)) 
        {
            throw cli::gcnew<ArgumentException>(Locale::GetText(_T("bits does not contain four values")));
        }
        /*unchecked*/ {
            (*this)->lo = (uint32_t)bits->at(0);
            (*this)->mid = (uint32_t)bits->at(1);
            (*this)->hi = (uint32_t)bits->at(2);
            (*this)->flags = (uint32_t)bits->at(3);
            unsigned char scale = (unsigned char)((*this)->flags >> 16);
            if((((uint32_t)(scale) > 28U) || (((*this)->flags & 2130771967U) != 0U))) 
            {
                throw cli::gcnew<ArgumentException>(Locale::GetText(_T("Invalid bits[3]")));
            }
        }
    }
    
    void Decimal::static_constructor() {
    }
    
    Decimal Decimal::FromOACurrency(int64_t cy) {
        return op_Division(Decimal::op_Implicit8(cy), cli::decimal<int>("10000"));
    }
    
    cli::array<int32_t>* Decimal::GetBits(Decimal d) {
        /*unchecked*/ {
            return (new cli::array<int32_t>({(Int32)d->lo, (Int32)d->mid, (Int32)d->hi, (Int32)d->flags}));
        }
    }
    
    Decimal Decimal::Negate(Decimal d) {
        (d->flags = d->flags ^ 2147483648U);
        return d;
    }
    
    Decimal Decimal::Add(Decimal d1, Decimal d2) {
        if((decimalIncr(d1, d2) ==  0)) 
        {
            return d1;
        }
         else 
        {
            throw cli::gcnew<OverflowException>(Locale::GetText(_T("Overflow on adding decimal number")));
        }
    }
    
    Decimal Decimal::Subtract(Decimal d1, Decimal d2) {
        (d2->flags = d2->flags ^ 2147483648U);
        int32_t result = decimalIncr(d1, d2);
        if((result ==  0)) 
        {
            return d1;
        }
         else 
        {
            throw cli::gcnew<OverflowException>(Locale::GetText(cli::concat(_T("Overflow on subtracting decimal numbers ("), cli::box(result))));
        }
    }
    
    int32_t Decimal::GetHashCode_6648aef0f235ee6c() {
        return (int32_t)((((*this)->flags ^ (*this)->hi) ^ (*this)->lo) ^ (*this)->mid);
    }
    
    uint64_t Decimal::u64(Decimal value) {
        uint64_t result;
        decimalFloorAndTrunc(value, 0);
        if((decimal2UInt64(value, result) != 0)) 
        {
            throw cli::gcnew<OverflowException>();
        }
        return result;
    }
    
    int64_t Decimal::s64(Decimal value) {
        int64_t result;
        decimalFloorAndTrunc(value, 0);
        if((decimal2Int64(value, result) != 0)) 
        {
            throw cli::gcnew<OverflowException>();
        }
        return result;
    }
    
    bool Decimal::Equals(Decimal d1, Decimal d2) {
        return (Compare(d1, d2) ==  0);
    }
    
    bool Decimal::Equals_ed975d2f4a7d193e(Object* value) {
        if(!(cli::is<Decimal>(value))) 
        {
            return false;
        }
        return Equals(cli::unbox<Decimal>(value), (*this));
    }
    
    bool Decimal::IsZero() {
        return ((((*this)->hi ==  0U) && ((*this)->lo ==  0U)) && ((*this)->mid ==  0U));
    }
    
    bool Decimal::IsNegative() {
        return (((*this)->flags & 2147483648U) ==  2147483648U);
    }
    
    Decimal Decimal::Floor(Decimal d) {
        decimalFloorAndTrunc(d, 1);
        return d;
    }
    
    Decimal Decimal::Truncate(Decimal d) {
        decimalFloorAndTrunc(d, 0);
        return d;
    }
    
    Decimal Decimal::Round(Decimal d, int32_t decimals) {
        return Round2(d, decimals, MidpointRounding::ToEven);
    }
    
    Decimal Decimal::Round2(Decimal d, int32_t decimals, MidpointRounding mode) {
        if((((int32_t)(mode) != 0) && ((int32_t)(mode) != 1))) 
        {
            throw cli::gcnew<ArgumentException>(cli::concat(_T("The value \'"), cli::box(mode)), _T("mode"));
        }
        if(((decimals < 0) || (decimals > 28))) 
        {
            throw cli::gcnew<ArgumentOutOfRangeException>(_T("decimals"), _T("[0,28]"));
        }
        bool negative = d->IsNegative();
        if(negative) 
        {
            (d->flags = d->flags ^ 2147483648U);
        }
        Decimal p = Decimal::op_Explicit11(Math::Pow(10., (double)(decimals)));
        Decimal int_part = Decimal::Floor(d);
        Decimal dec_part = op_Subtraction(d, int_part);
        (dec_part = op_Multiply(dec_part, cli::decimal<int>("10000000000000000000000000000")));
        dec_part = Decimal::Floor(dec_part);
        (dec_part = op_Division(dec_part, op_Division(cli::decimal<int>("10000000000000000000000000000"), p)));
        dec_part = Math::Round3(dec_part, mode);
        (dec_part = op_Division(dec_part, p));
        Decimal result = op_Addition(int_part, dec_part);
        int64_t scaleDiff = ((int64_t)(decimals) - (int64_t)(((result->flags & 2147418112U) >> 16)));
        if((scaleDiff > 0L)) 
        {
            while((scaleDiff > 0L)) {
                if(op_GreaterThan(result, (*MaxValueDiv10))) 
                {
                    break;
                }
                (result = op_Multiply(result, cli::decimal<int>("10")));
                scaleDiff--;
            }
        }
         else 
        {
            if((scaleDiff < 0L)) 
            {
                while((scaleDiff < 0L)) {
                    (result = op_Division(result, cli::decimal<int>("10")));
                    scaleDiff++;
                }
            }
        }
        result->flags = (uint32_t)(((int64_t)(decimals) - scaleDiff) << 16);
        if(negative) 
        {
            (result->flags = result->flags ^ 2147483648U);
        }
        return result;
    }
    
    Decimal Decimal::Round3(Decimal d) {
        return Math::Round(d);
    }
    
    Decimal Decimal::Round4(Decimal d, MidpointRounding mode) {
        return Math::Round3(d, mode);
    }
    
    Decimal Decimal::Multiply(Decimal d1, Decimal d2) {
        if((d1->IsZero() || d2->IsZero())) 
        {
            return cli::decimal<int>("0");
        }
        if((decimalMult(d1, d2) != 0)) 
        {
            throw cli::gcnew<OverflowException>();
        }
        return d1;
    }
    
    Decimal Decimal::Divide(Decimal d1, Decimal d2) {
        if(d2->IsZero()) 
        {
            throw cli::gcnew<DivideByZeroException>();
        }
        if(d1->IsZero()) 
        {
            return cli::decimal<int>("0");
        }
        (d1->flags = d1->flags ^ 2147483648U);
        (d1->flags = d1->flags ^ 2147483648U);
        Decimal result;
        if((decimalDiv(result, d1, d2) != 0)) 
        {
            throw cli::gcnew<OverflowException>();
        }
        return result;
    }
    
    Decimal Decimal::Remainder(Decimal d1, Decimal d2) {
        if(d2->IsZero()) 
        {
            throw cli::gcnew<DivideByZeroException>();
        }
        if(d1->IsZero()) 
        {
            return cli::decimal<int>("0");
        }
        bool negative = d1->IsNegative();
        if(negative) 
        {
            (d1->flags = d1->flags ^ 2147483648U);
        }
        if(d2->IsNegative()) 
        {
            (d2->flags = d2->flags ^ 2147483648U);
        }
        Decimal result;
        if(op_Equality(d1, d2)) 
        {
            return cli::decimal<int>("0");
        }
         else 
        {
            if(op_GreaterThan(d2, d1)) 
            {
                result = d1;
            }
             else 
            {
                if((decimalDiv(result, d1, d2) != 0)) 
                {
                    throw cli::gcnew<OverflowException>();
                }
                result = Decimal::Truncate(result);
                result = op_Subtraction(d1, op_Multiply(result, d2));
            }
        }
        if(negative) 
        {
            (result->flags = result->flags ^ 2147483648U);
        }
        return result;
    }
    
    int32_t Decimal::Compare(Decimal d1, Decimal d2) {
        return decimalCompare(d1, d2);
    }
    
    int32_t Decimal::CompareTo(Object* value) {
        if((value ==  nullptr)) 
        {
            return 1;
        }
        if(!(cli::is<Decimal>(value))) 
        {
            throw cli::gcnew<ArgumentException>(Locale::GetText(_T("Value is not a System.Decimal")));
        }
        return Compare((*this), cli::unbox<Decimal>(value));
    }
    
    int32_t Decimal::CompareTo2(Decimal value) {
        return Compare((*this), value);
    }
    
    bool Decimal::Equals4(Decimal value) {
        return Equals(value, (*this));
    }
    
    Decimal Decimal::Ceiling(Decimal d) {
        return Math::Ceiling(d);
    }
    
    Decimal Decimal::Parse(String* s) {
        return Parse4(s, Globalization::NumberStyles::Number, nullptr);
    }
    
    Decimal Decimal::Parse2(String* s, Globalization::NumberStyles style) {
        return Parse4(s, style, nullptr);
    }
    
    Decimal Decimal::Parse3(String* s, IFormatProvider* provider) {
        return Parse4(s, Globalization::NumberStyles::Number, provider);
    }
    
    void Decimal::ThrowAtPos(int32_t pos) {
        throw cli::gcnew<FormatException>(String::Format2(Locale::GetText(_T("Invalid character at position {0}")), cli::box(pos)));
    }
    
    void Decimal::ThrowInvalidExp() {
        throw cli::gcnew<FormatException>(Locale::GetText(_T("Invalid exponent")));
    }
    
    String* Decimal::stripStyles(String* s, Globalization::NumberStyles style, Globalization::NumberFormatInfo* nfi, int32_t decPos, bool isNegative, bool expFlag, int32_t exp, bool throwex) {
        isNegative = false;
        expFlag = false;
        exp = 0;
        decPos = -1;
        bool hasSign = false;
        bool hasOpeningParentheses = false;
        bool hasDecimalPoint = false;
        bool allowedLeadingWhiteSpace = ((int32_t)(((int32_t)(style) & 1)) != 0);
        bool allowedTrailingWhiteSpace = ((int32_t)(((int32_t)(style) & 2)) != 0);
        bool allowedLeadingSign = ((int32_t)(((int32_t)(style) & 4)) != 0);
        bool allowedTrailingSign = ((int32_t)(((int32_t)(style) & 8)) != 0);
        bool allowedParentheses = ((int32_t)(((int32_t)(style) & 16)) != 0);
        bool allowedThousands = ((int32_t)(((int32_t)(style) & 64)) != 0);
        bool allowedDecimalPoint = ((int32_t)(((int32_t)(style) & 32)) != 0);
        bool allowedExponent = ((int32_t)(((int32_t)(style) & 128)) != 0);
        bool hasCurrency = false;
        if(((int32_t)(((int32_t)(style) & 256)) != 0)) 
        {
            int32_t index = s->IndexOf7(nfi->get_CurrencySymbol());
            if((index >= 0)) 
            {
                s = s->Remove2(index, nfi->get_CurrencySymbol()->get_Length());
                hasCurrency = true;
            }
        }
        String *decimalSep = hasCurrency ? nfi->get_CurrencyDecimalSeparator() : nfi->get_NumberDecimalSeparator();
        String *groupSep = hasCurrency ? nfi->get_CurrencyGroupSeparator() : nfi->get_NumberGroupSeparator();
        int32_t pos = 0;
        int32_t len = s->get_Length();
        Text::StringBuilder *sb = cli::gcnew<Text::StringBuilder>(len);
        while((pos < len)) {
            char16_t ch = s->get_Chars(pos);
            if(Char::IsDigit(ch)) 
            {
                break;
            }
             else 
            {
                if((allowedLeadingWhiteSpace && Char::IsWhiteSpace(ch))) 
                {
                    pos++;
                }
                 else 
                {
                    if((((allowedParentheses && ((int32_t)(ch) ==  40)) && !(hasSign)) && !(hasOpeningParentheses))) 
                    {
                        hasOpeningParentheses = true;
                        hasSign = true;
                        isNegative = true;
                        pos++;
                    }
                     else 
                    {
                        if(((allowedLeadingSign && ((int32_t)(ch) ==  (int32_t)(nfi->get_NegativeSign()->get_Chars(0)))) && !(hasSign))) 
                        {
                            int32_t slen = nfi->get_NegativeSign()->get_Length();
                            if(((slen ==  1) || (s->IndexOf9(nfi->get_NegativeSign(), pos, slen) ==  pos))) 
                            {
                                hasSign = true;
                                isNegative = true;
                                (pos = pos + slen);
                            }
                        }
                         else 
                        {
                            if(((allowedLeadingSign && ((int32_t)(ch) ==  (int32_t)(nfi->get_PositiveSign()->get_Chars(0)))) && !(hasSign))) 
                            {
                                int32_t slen = nfi->get_PositiveSign()->get_Length();
                                if(((slen ==  1) || (s->IndexOf9(nfi->get_PositiveSign(), pos, slen) ==  pos))) 
                                {
                                    hasSign = true;
                                    (pos = pos + slen);
                                }
                            }
                             else 
                            {
                                if((allowedDecimalPoint && ((int32_t)(ch) ==  (int32_t)(decimalSep->get_Chars(0))))) 
                                {
                                    int32_t slen = decimalSep->get_Length();
                                    if(((slen != 1) && (s->IndexOf9(decimalSep, pos, slen) != pos))) 
                                    {
                                        if(throwex) 
                                        {
                                            ThrowAtPos(pos);
                                        }
                                         else 
                                        {
                                            return nullptr;
                                        }
                                    }
                                    break;
                                }
                                 else 
                                {
                                    if(throwex) 
                                    {
                                        ThrowAtPos(pos);
                                    }
                                     else 
                                    {
                                        return nullptr;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        if((pos ==  len)) 
        {
            if(throwex) 
            {
                throw cli::gcnew<FormatException>(Locale::GetText(_T("No digits found")));
            }
             else 
            {
                return nullptr;
            }
        }
        while((pos < len)) {
            char16_t ch = s->get_Chars(pos);
            if(Char::IsDigit(ch)) 
            {
                sb->Append16(ch);
                pos++;
            }
             else 
            {
                if(((allowedThousands && ((int32_t)(ch) ==  (int32_t)(groupSep->get_Chars(0)))) && ((int32_t)(ch) != (int32_t)(decimalSep->get_Chars(0))))) 
                {
                    int32_t slen = groupSep->get_Length();
                    if(((slen != 1) && (s->IndexOf9(groupSep, pos, slen) != pos))) 
                    {
                        if(throwex) 
                        {
                            ThrowAtPos(pos);
                        }
                         else 
                        {
                            return nullptr;
                        }
                    }
                    (pos = pos + slen);
                }
                 else 
                {
                    if(((allowedDecimalPoint && ((int32_t)(ch) ==  (int32_t)(decimalSep->get_Chars(0)))) && !(hasDecimalPoint))) 
                    {
                        int32_t slen = decimalSep->get_Length();
                        if(((slen ==  1) || (s->IndexOf9(decimalSep, pos, slen) ==  pos))) 
                        {
                            decPos = sb->get_Length();
                            hasDecimalPoint = true;
                            (pos = pos + slen);
                        }
                    }
                     else 
                    {
                        break;
                    }
                }
            }
        }
        if((pos < len)) 
        {
            char16_t ch = s->get_Chars(pos);
            if((allowedExponent && ((int32_t)(Char::ToUpperInvariant(ch)) ==  69))) 
            {
                expFlag = true;
                pos++;
                if((pos >= len)) 
                {
                    if(throwex) 
                    {
                        ThrowInvalidExp();
                    }
                     else 
                    {
                        return nullptr;
                    }
                }
                ch = s->get_Chars(pos);
                bool isNegativeExp = false;
                if(((int32_t)(ch) ==  (int32_t)(nfi->get_PositiveSign()->get_Chars(0)))) 
                {
                    int32_t slen = nfi->get_PositiveSign()->get_Length();
                    if(((slen ==  1) || (s->IndexOf9(nfi->get_PositiveSign(), pos, slen) ==  pos))) 
                    {
                        (pos = pos + slen);
                        if((pos >= len)) 
                        {
                            if(throwex) 
                            {
                                ThrowInvalidExp();
                            }
                             else 
                            {
                                return nullptr;
                            }
                        }
                    }
                }
                 else 
                {
                    if(((int32_t)(ch) ==  (int32_t)(nfi->get_NegativeSign()->get_Chars(0)))) 
                    {
                        int32_t slen = nfi->get_NegativeSign()->get_Length();
                        if(((slen ==  1) || (s->IndexOf9(nfi->get_NegativeSign(), pos, slen) ==  pos))) 
                        {
                            (pos = pos + slen);
                            if((pos >= len)) 
                            {
                                if(throwex) 
                                {
                                    ThrowInvalidExp();
                                }
                                 else 
                                {
                                    return nullptr;
                                }
                            }
                            isNegativeExp = true;
                        }
                    }
                }
                ch = s->get_Chars(pos);
                if(!(Char::IsDigit(ch))) 
                {
                    if(throwex) 
                    {
                        ThrowInvalidExp();
                    }
                     else 
                    {
                        return nullptr;
                    }
                }
                exp = ((int32_t)(ch) - 48);
                pos++;
                while(((pos < len) && Char::IsDigit(s->get_Chars(pos)))) {
                    (exp = exp * 10);
                    (exp = exp + ((int32_t)(s->get_Chars(pos)) - 48));
                    pos++;
                }
                if(isNegativeExp) 
                {
                    (exp = exp * -1);
                }
            }
        }
        while((pos < len)) {
            char16_t ch = s->get_Chars(pos);
            if((allowedTrailingWhiteSpace && Char::IsWhiteSpace(ch))) 
            {
                pos++;
            }
             else 
            {
                if(((allowedParentheses && ((int32_t)(ch) ==  41)) && hasOpeningParentheses)) 
                {
                    hasOpeningParentheses = false;
                    pos++;
                }
                 else 
                {
                    if(((allowedTrailingSign && ((int32_t)(ch) ==  (int32_t)(nfi->get_NegativeSign()->get_Chars(0)))) && !(hasSign))) 
                    {
                        int32_t slen = nfi->get_NegativeSign()->get_Length();
                        if(((slen ==  1) || (s->IndexOf9(nfi->get_NegativeSign(), pos, slen) ==  pos))) 
                        {
                            hasSign = true;
                            isNegative = true;
                            (pos = pos + slen);
                        }
                    }
                     else 
                    {
                        if(((allowedTrailingSign && ((int32_t)(ch) ==  (int32_t)(nfi->get_PositiveSign()->get_Chars(0)))) && !(hasSign))) 
                        {
                            int32_t slen = nfi->get_PositiveSign()->get_Length();
                            if(((slen ==  1) || (s->IndexOf9(nfi->get_PositiveSign(), pos, slen) ==  pos))) 
                            {
                                hasSign = true;
                                (pos = pos + slen);
                            }
                        }
                         else 
                        {
                            if(((int32_t)(ch) ==  0)) 
                            {
                                while(((++pos < len) && ((int32_t)(s->get_Chars(pos)) ==  0))) ;
                                if((pos ==  len)) 
                                {
                                    break;
                                }
                            }
                            if(throwex) 
                            {
                                ThrowAtPos(pos);
                            }
                             else 
                            {
                                return nullptr;
                            }
                        }
                    }
                }
            }
        }
        if(hasOpeningParentheses) 
        {
            if(throwex) 
            {
                throw cli::gcnew<FormatException>(Locale::GetText(_T("Closing Parentheses not found")));
            }
             else 
            {
                return nullptr;
            }
        }
        if(!(hasDecimalPoint)) 
        {
            decPos = sb->get_Length();
        }
        return sb->ToString_1636a0751cb9ac11();
    }
    
    Decimal Decimal::Parse4(String* s, Globalization::NumberStyles style, IFormatProvider* provider) {
        if((s ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("s"));
        }
        if(((int32_t)(((int32_t)(style) & 512)) != 0)) 
        {
            throw cli::gcnew<ArgumentException>(_T("Decimal.TryParse does not accept AllowHexSpecifier"), _T("style"));
        }
        Decimal result;
        PerformParse(s, style, provider, result, true);
        return result;
    }
    
    bool Decimal::TryParse(String* s, Decimal result) {
        if((s ==  nullptr)) 
        {
            result = cli::decimal<int>("0");
            return false;
        }
        return PerformParse(s, Globalization::NumberStyles::Number, nullptr, result, false);
    }
    
    bool Decimal::TryParse2(String* s, Globalization::NumberStyles style, IFormatProvider* provider, Decimal result) {
        if(((s ==  nullptr) || ((int32_t)(((int32_t)(style) & 512)) != 0))) 
        {
            result = cli::decimal<int>("0");
            return false;
        }
        return PerformParse(s, style, provider, result, false);
    }
    
    bool Decimal::PerformParse(String* s, Globalization::NumberStyles style, IFormatProvider* provider, Decimal res, bool throwex) {
        Globalization::NumberFormatInfo *nfi = Globalization::NumberFormatInfo::GetInstance(provider);
        int32_t iDecPos, exp;
        bool isNegative, expFlag;
        s = stripStyles(s, style, nfi, iDecPos, isNegative, expFlag, exp, throwex);
        if((s ==  nullptr)) 
        {
            res = cli::decimal<int>("0");
            return false;
        }
        if((iDecPos < 0)) 
        {
            if(throwex) 
            {
                throw cli::gcnew<Exception>(Locale::GetText(_T("Error in System.Decimal.Parse")));
            }
            res = cli::decimal<int>("0");
            return false;
        }
        int32_t len = s->get_Length();
        int32_t i = 0;
        while(((i < iDecPos) && ((int32_t)(s->get_Chars(i)) ==  48))) i++;
        if(((i > 1) && (len > 1))) 
        {
            s = s->Substring2(i, (len - i));
            (iDecPos = iDecPos - i);
        }
        int32_t max = (iDecPos ==  0) ? 27 : 28;
        len = s->get_Length();
        if((len >= (max + 1))) 
        {
            if((String::Compare6(s, 0, _T("79228162514264337593543950335"), 0, (max + 1), false, Globalization::CultureInfo::get_InvariantCulture()) <= 0)) 
            {
                max++;
            }
        }
        if(((len > max) && (iDecPos < len))) 
        {
            int32_t round = ((int32_t)(s->get_Chars(max)) - 48);
            s = s->Substring2(0, max);
            bool addone = false;
            if((round > 5)) 
            {
                addone = true;
            }
             else 
            {
                if((round ==  5)) 
                {
                    if(isNegative) 
                    {
                        addone = true;
                    }
                     else 
                    {
                        int32_t previous = ((int32_t)(s->get_Chars((max - 1))) - 48);
                        addone = ((previous & 1) ==  1);
                    }
                }
            }
            if(addone) 
            {
                cli::array<char16_t> *array = s->ToCharArray();
                int32_t p = (max - 1);
                while((p >= 0)) {
                    int32_t b = ((int32_t)(array->at(p)) - 48);
                    if(((int32_t)(array->at(p)) != 57)) 
                    {
                        array->at(p) = (char16_t)(b + 49);
                        break;
                    }
                     else 
                    {
                        array->at(p--) = u'0';
                    }
                }
                if(((p ==  -1) && ((int32_t)(array->at(0)) ==  48))) 
                {
                    iDecPos++;
                    s = _T("1")->PadRight2(iDecPos, u'0');
                }
                 else 
                {
                    s = cli::gcnew<String>(array);
                }
            }
        }
        Decimal result;
        if((string2decimal(result, s, (uint32_t)iDecPos, 0) != 0)) 
        {
            if(throwex) 
            {
                throw cli::gcnew<OverflowException>();
            }
            res = cli::decimal<int>("0");
            return false;
        }
        if(expFlag) 
        {
            if((decimalSetExponent(result, exp) != 0)) 
            {
                if(throwex) 
                {
                    throw cli::gcnew<OverflowException>();
                }
                res = cli::decimal<int>("0");
                return false;
            }
        }
        if(isNegative) 
        {
            (result->flags = result->flags ^ 2147483648U);
        }
        res = result;
        return true;
    }
    
    TypeCode Decimal::GetTypeCode() {
        return TypeCode::Decimal2;
    }
    
    unsigned char Decimal::ToByte(Decimal value) {
        if((op_GreaterThan(value, cli::decimal<int>("255")) || op_LessThan(value, cli::decimal<int>("0")))) 
        {
            throw cli::gcnew<OverflowException>(Locale::GetText(_T("Value is greater than Byte.MaxValue or less than Byte.MinValue")));
        }
        return Decimal::op_Explicit(Decimal::Truncate(value));
    }
    
    double Decimal::ToDouble(Decimal d) {
        return Convert::ToDouble5(d);
    }
    
    int16_t Decimal::ToInt16(Decimal value) {
        if((op_GreaterThan(value, cli::decimal<int>("32767")) || op_LessThan(value, cli::decimal<int>("-32768")))) 
        {
            throw cli::gcnew<OverflowException>(Locale::GetText(_T("Value is greater than Int16.MaxValue or less than Int16.MinValue")));
        }
        return Decimal::op_Explicit4(Decimal::Truncate(value));
    }
    
    int32_t Decimal::ToInt32(Decimal d) {
        if((op_GreaterThan(d, cli::decimal<int>("2147483647")) || op_LessThan(d, cli::decimal<int>("-2147483648")))) 
        {
            throw cli::gcnew<OverflowException>(Locale::GetText(_T("Value is greater than Int32.MaxValue or less than Int32.MinValue")));
        }
        return Decimal::op_Explicit6(Decimal::Truncate(d));
    }
    
    int64_t Decimal::ToInt64(Decimal d) {
        if((op_GreaterThan(d, cli::decimal<int>("9223372036854775807")) || op_LessThan(d, cli::decimal<int>("-9223372036854775808")))) 
        {
            throw cli::gcnew<OverflowException>(Locale::GetText(_T("Value is greater than Int64.MaxValue or less than Int64.MinValue")));
        }
        return Decimal::op_Explicit8(Decimal::Truncate(d));
    }
    
    int64_t Decimal::ToOACurrency(Decimal value) {
        return Decimal::op_Explicit8(op_Multiply(value, cli::decimal<int>("10000")));
    }
    
    signed char Decimal::ToSByte(Decimal value) {
        if((op_GreaterThan(value, cli::decimal<int>("127")) || op_LessThan(value, cli::decimal<int>("-128")))) 
        {
            throw cli::gcnew<OverflowException>(Locale::GetText(_T("Value is greater than SByte.MaxValue or less than SByte.MinValue")));
        }
        return Decimal::op_Explicit2(Decimal::Truncate(value));
    }
    
    float Decimal::ToSingle(Decimal d) {
        return Convert::ToSingle5(d);
    }
    
    uint16_t Decimal::ToUInt16(Decimal value) {
        if((op_GreaterThan(value, cli::decimal<int>("65535")) || op_LessThan(value, cli::decimal<int>("0")))) 
        {
            throw cli::gcnew<OverflowException>(Locale::GetText(_T("Value is greater than UInt16.MaxValue or less than UInt16.MinValue")));
        }
        return Decimal::op_Explicit5(Decimal::Truncate(value));
    }
    
    uint32_t Decimal::ToUInt32(Decimal d) {
        if((op_GreaterThan(d, cli::decimal<int>("4294967295")) || op_LessThan(d, cli::decimal<int>("0")))) 
        {
            throw cli::gcnew<OverflowException>(Locale::GetText(_T("Value is greater than UInt32.MaxValue or less than UInt32.MinValue")));
        }
        return Decimal::op_Explicit7(Decimal::Truncate(d));
    }
    
    uint64_t Decimal::ToUInt64(Decimal d) {
        if((op_GreaterThan(d, cli::decimal<int>("18446744073709551615")) || op_LessThan(d, cli::decimal<int>("0")))) 
        {
            throw cli::gcnew<OverflowException>(Locale::GetText(_T("Value is greater than UInt64.MaxValue or less than UInt64.MinValue")));
        }
        return Decimal::op_Explicit9(Decimal::Truncate(d));
    }
    
    Object* Decimal::ToType(Type* targetType, IFormatProvider* provider) {
        if(Type::op_Equality2(targetType, nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("targetType"));
        }
        return Convert::ToType(cli::box((*this)), targetType, provider, false);
    }
    
    bool Decimal::ToBoolean(IFormatProvider* provider) {
        return Convert::ToBoolean5((*this));
    }
    
    unsigned char Decimal::ToByte2(IFormatProvider* provider) {
        return Convert::ToByte5((*this));
    }
    
    char16_t Decimal::ToChar(IFormatProvider* provider) {
        throw cli::gcnew<InvalidCastException>();
    }
    
    DateTime Decimal::ToDateTime(IFormatProvider* provider) {
        throw cli::gcnew<InvalidCastException>();
    }
    
    Decimal Decimal::ToDecimal(IFormatProvider* provider) {
        return (*this);
    }
    
    double Decimal::ToDouble2(IFormatProvider* provider) {
        return Convert::ToDouble5((*this));
    }
    
    int16_t Decimal::ToInt162(IFormatProvider* provider) {
        return Convert::ToInt165((*this));
    }
    
    int32_t Decimal::ToInt322(IFormatProvider* provider) {
        return Convert::ToInt325((*this));
    }
    
    int64_t Decimal::ToInt642(IFormatProvider* provider) {
        return Convert::ToInt645((*this));
    }
    
    signed char Decimal::ToSByte2(IFormatProvider* provider) {
        return Convert::ToSByte5((*this));
    }
    
    float Decimal::ToSingle2(IFormatProvider* provider) {
        return Convert::ToSingle5((*this));
    }
    
    uint16_t Decimal::ToUInt162(IFormatProvider* provider) {
        return Convert::ToUInt165((*this));
    }
    
    uint32_t Decimal::ToUInt322(IFormatProvider* provider) {
        return Convert::ToUInt325((*this));
    }
    
    uint64_t Decimal::ToUInt642(IFormatProvider* provider) {
        return Convert::ToUInt645((*this));
    }
    
    String* Decimal::ToString(String* format, IFormatProvider* provider) {
        return NumberFormatter::NumberToString11(format, (*this), provider);
    }
    
    String* Decimal::ToString_1636a0751cb9ac11() {
        return ToString(_T("G"), nullptr);
    }
    
    String* Decimal::ToString4(String* format) {
        return ToString(format, nullptr);
    }
    
    String* Decimal::ToString5(IFormatProvider* provider) {
        return ToString(_T("G"), provider);
    }
    
    void Decimal::OnDeserialization(Object* sender) {
    }
    
    int32_t Decimal::decimal2UInt64(Decimal val, uint64_t result) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t Decimal::decimal2Int64(Decimal val, int64_t result) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t Decimal::double2decimal(Decimal erg, double val, int32_t digits) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t Decimal::decimalIncr(Decimal d1, Decimal d2) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t Decimal::decimal2string(Decimal val, int32_t digits, int32_t decimals, cli::array<char16_t>* bufDigits, int32_t bufSize, int32_t decPos, int32_t sign) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t Decimal::string2decimal(Decimal val, String* sDigits, uint32_t decPos, int32_t sign) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t Decimal::decimalSetExponent(Decimal val, int32_t exp) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    double Decimal::decimal2double(Decimal val) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Decimal::decimalFloorAndTrunc(Decimal val, int32_t floorFlag) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t Decimal::decimalMult(Decimal pd1, Decimal pd2) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t Decimal::decimalDiv(Decimal pc, Decimal pa, Decimal pb) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t Decimal::decimalIntDiv(Decimal pc, Decimal pa, Decimal pb) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t Decimal::decimalCompare(Decimal d1, Decimal d2) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    Decimal Decimal::op_Addition(Decimal d1, Decimal d2) {
        return Add(d1, d2);
    }
    
    Decimal Decimal::op_Decrement(Decimal d) {
        return Add(d, cli::decimal<int>("-1"));
    }
    
    Decimal Decimal::op_Increment(Decimal d) {
        return Add(d, cli::decimal<int>("1"));
    }
    
    Decimal Decimal::op_Subtraction(Decimal d1, Decimal d2) {
        return Subtract(d1, d2);
    }
    
    Decimal Decimal::op_UnaryNegation(Decimal d) {
        return Negate(d);
    }
    
    Decimal Decimal::op_UnaryPlus(Decimal d) {
        return d;
    }
    
    Decimal Decimal::op_Multiply(Decimal d1, Decimal d2) {
        return Multiply(d1, d2);
    }
    
    Decimal Decimal::op_Division(Decimal d1, Decimal d2) {
        return Divide(d1, d2);
    }
    
    Decimal Decimal::op_Modulus(Decimal d1, Decimal d2) {
        return Remainder(d1, d2);
    }
    
    unsigned char Decimal::op_Explicit(Decimal value) {
        uint64_t result = u64(value);
        return cli::checked((unsigned char)result);
    }
    
    signed char Decimal::op_Explicit2(Decimal value) {
        int64_t result = s64(value);
        return cli::checked((signed char)result);
    }
    
    char16_t Decimal::op_Explicit3(Decimal value) {
        uint64_t result = u64(value);
        return cli::checked((char16_t)result);
    }
    
    int16_t Decimal::op_Explicit4(Decimal value) {
        int64_t result = s64(value);
        return cli::checked((int16_t)result);
    }
    
    uint16_t Decimal::op_Explicit5(Decimal value) {
        uint64_t result = u64(value);
        return cli::checked((uint16_t)result);
    }
    
    int32_t Decimal::op_Explicit6(Decimal value) {
        int64_t result = s64(value);
        return cli::checked((int32_t)result);
    }
    
    uint32_t Decimal::op_Explicit7(Decimal value) {
        uint64_t result = u64(value);
        return cli::checked((uint32_t)result);
    }
    
    int64_t Decimal::op_Explicit8(Decimal value) {
        return s64(value);
    }
    
    uint64_t Decimal::op_Explicit9(Decimal value) {
        return u64(value);
    }
    
    Decimal Decimal::op_Implicit(unsigned char value) {
        return cli::ctor<Decimal>((int32_t)(value));
    }
    
    Decimal Decimal::op_Implicit2(signed char value) {
        return cli::ctor<Decimal>((int32_t)(value));
    }
    
    Decimal Decimal::op_Implicit3(int16_t value) {
        return cli::ctor<Decimal>((int32_t)(value));
    }
    
    Decimal Decimal::op_Implicit4(uint16_t value) {
        return cli::ctor<Decimal>((int32_t)(value));
    }
    
    Decimal Decimal::op_Implicit5(char16_t value) {
        return cli::ctor<Decimal>((int32_t)(value));
    }
    
    Decimal Decimal::op_Implicit6(int32_t value) {
        return cli::ctor<Decimal>(value);
    }
    
    Decimal Decimal::op_Implicit7(uint32_t value) {
        return cli::ctor<Decimal>(value);
    }
    
    Decimal Decimal::op_Implicit8(int64_t value) {
        return cli::ctor<Decimal>(value);
    }
    
    Decimal Decimal::op_Implicit9(uint64_t value) {
        return cli::ctor<Decimal>(value);
    }
    
    Decimal Decimal::op_Explicit10(float value) {
        return cli::ctor<Decimal>(value);
    }
    
    Decimal Decimal::op_Explicit11(double value) {
        return cli::ctor<Decimal>(value);
    }
    
    float Decimal::op_Explicit12(Decimal value) {
        return (float)Decimal::op_Explicit13(value);
    }
    
    double Decimal::op_Explicit13(Decimal value) {
        return decimal2double(value);
    }
    
    bool Decimal::op_Inequality(Decimal d1, Decimal d2) {
        return !(Equals(d1, d2));
    }
    
    bool Decimal::op_Equality(Decimal d1, Decimal d2) {
        return Equals(d1, d2);
    }
    
    bool Decimal::op_GreaterThan(Decimal d1, Decimal d2) {
        return (Compare(d1, d2) > 0);
    }
    
    bool Decimal::op_GreaterThanOrEqual(Decimal d1, Decimal d2) {
        return (Compare(d1, d2) >= 0);
    }
    
    bool Decimal::op_LessThan(Decimal d1, Decimal d2) {
        return (Compare(d1, d2) < 0);
    }
    
    bool Decimal::op_LessThanOrEqual(Decimal d1, Decimal d2) {
        return (Compare(d1, d2) <= 0);
    }
    
}
namespace System {
    
    
    int32_t Double::CompareTo(Object* value) {
        if((value ==  nullptr)) 
        {
            return 1;
        }
        if(!(cli::is<Double>(value))) 
        {
            throw cli::gcnew<ArgumentException>(Locale::GetText(_T("Value is not a System.Double")));
        }
        double dv = cli::unbox<double>(value);
        if((IsPositiveInfinity(cli::import((*this))->m_value) && IsPositiveInfinity(dv))) 
        {
            return 0;
        }
        if((IsNegativeInfinity(cli::import((*this))->m_value) && IsNegativeInfinity(dv))) 
        {
            return 0;
        }
        if(IsNaN(dv)) 
        {
            if(IsNaN(cli::import((*this))->m_value)) 
            {
                return 0;
            }
             else 
            {
                return 1;
            }
        }
        if(IsNaN(cli::import((*this))->m_value)) 
        {
            if(IsNaN(dv)) 
            {
                return 0;
            }
             else 
            {
                return -1;
            }
        }
        if((cli::import((*this))->m_value > dv)) 
        {
            return 1;
        }
         else 
        {
            if((cli::import((*this))->m_value < dv)) 
            {
                return -1;
            }
             else 
            {
                return 0;
            }
        }
    }
    
    bool Double::Equals_ed975d2f4a7d193e(Object* obj) {
        if(!(cli::is<Double>(obj))) 
        {
            return false;
        }
        double value = cli::unbox<double>(obj);
        if(IsNaN(value)) 
        {
            return IsNaN(cli::import((*this))->m_value);
        }
        return (value ==  cli::import((*this))->m_value);
    }
    
    int32_t Double::CompareTo2(double value) {
        if((IsPositiveInfinity(cli::import((*this))->m_value) && IsPositiveInfinity(value))) 
        {
            return 0;
        }
        if((IsNegativeInfinity(cli::import((*this))->m_value) && IsNegativeInfinity(value))) 
        {
            return 0;
        }
        if(IsNaN(value)) 
        {
            if(IsNaN(cli::import((*this))->m_value)) 
            {
                return 0;
            }
             else 
            {
                return 1;
            }
        }
        if(IsNaN(cli::import((*this))->m_value)) 
        {
            if(IsNaN(value)) 
            {
                return 0;
            }
             else 
            {
                return -1;
            }
        }
        if((cli::import((*this))->m_value > value)) 
        {
            return 1;
        }
         else 
        {
            if((cli::import((*this))->m_value < value)) 
            {
                return -1;
            }
             else 
            {
                return 0;
            }
        }
    }
    
    bool Double::Equals2(double obj) {
        if(IsNaN(obj)) 
        {
            if(IsNaN(cli::import((*this))->m_value)) 
            {
                return true;
            }
             else 
            {
                return false;
            }
        }
        return (obj ==  cli::import((*this))->m_value);
    }
    
    int32_t Double::GetHashCode_6648aef0f235ee6c() {
        double d = cli::import((*this))->m_value;
        return cli::import((*(int64_t*)(&(d))))->GetHashCode_6648aef0f235ee6c();
    }
    
    bool Double::IsInfinity(double d) {
        return ((d ==  std::numeric_limits<double>::infinity()) || (d ==  -std::numeric_limits<double>::infinity()));
    }
    
    bool Double::IsNaN(double d) {
        return (d != d);
    }
    
    bool Double::IsNegativeInfinity(double d) {
        return ((d < std::numeric_limits<double>::epsilon()) && ((d ==  -std::numeric_limits<double>::infinity()) || (d ==  std::numeric_limits<double>::infinity())));
    }
    
    bool Double::IsPositiveInfinity(double d) {
        return ((d > std::numeric_limits<double>::epsilon()) && ((d ==  -std::numeric_limits<double>::infinity()) || (d ==  std::numeric_limits<double>::infinity())));
    }
    
    double Double::Parse(String* s) {
        return Parse4(s, (Globalization::NumberStyles)231L, nullptr);
    }
    
    double Double::Parse2(String* s, IFormatProvider* provider) {
        return Parse4(s, (Globalization::NumberStyles)231L, provider);
    }
    
    double Double::Parse3(String* s, Globalization::NumberStyles style) {
        return Parse4(s, style, nullptr);
    }
    
    double Double::Parse4(String* s, Globalization::NumberStyles style, IFormatProvider* provider) {
        Exception *exc;
        double result;
        if(!(Parse5(s, style, provider, false, result, exc))) 
        {
            throw exc;
        }
        return result;
    }
    
    bool Double::Parse5(String* s, Globalization::NumberStyles style, IFormatProvider* provider, bool tryParse, double result, Exception* exc) {
        result = std::numeric_limits<double>::epsilon();
        exc = nullptr;
        if((s ==  nullptr)) 
        {
            if(!(tryParse)) 
            {
                exc = cli::gcnew<ArgumentNullException>(_T("s"));
            }
            return false;
        }
        if((s->get_Length() ==  0)) 
        {
            if(!(tryParse)) 
            {
                exc = cli::gcnew<FormatException>();
            }
            return false;
        }
        if(((int32_t)(((int32_t)(style) & 512)) != 0)) 
        {
            String *msg = Locale::GetText2(_T("Double doesn\'t support parsing with \'{0}\'."), (new cli::array<Object*>({_T("AllowHexSpecifier")})));
            throw cli::gcnew<ArgumentException>(msg);
        }
        if(((int32_t)(style) > 511)) 
        {
            if(!(tryParse)) 
            {
                exc = cli::gcnew<ArgumentException>();
            }
            return false;
        }
        Globalization::NumberFormatInfo *format = Globalization::NumberFormatInfo::GetInstance(provider);
        if((format ==  nullptr)) 
        {
            throw cli::gcnew<Exception>(_T("How did this happen?"));
        }
        int32_t len = s->get_Length();
        int32_t didx = 0;
        int32_t sidx = 0;
        char16_t c;
        bool allow_leading_white = ((int32_t)(((int32_t)(style) & 1)) != 0);
        bool allow_trailing_white = ((int32_t)(((int32_t)(style) & 2)) != 0);
        if(allow_leading_white) 
        {
            while(((sidx < len) && Char::IsWhiteSpace(s->get_Chars(sidx)))) sidx++;
            if((sidx ==  len)) 
            {
                if(!(tryParse)) 
                {
                    exc = Int32::GetFormatException();
                }
                return false;
            }
        }
        int32_t sEndPos = (s->get_Length() - 1);
        if(allow_trailing_white) 
        {
            while(Char::IsWhiteSpace(s->get_Chars(sEndPos))) sEndPos--;
        }
        if(TryParseStringConstant(format->get_NaNSymbol(), s, sidx, sEndPos)) 
        {
            result = std::numeric_limits<double>::quiet_NaN();
            return true;
        }
        if(TryParseStringConstant(format->get_PositiveInfinitySymbol(), s, sidx, sEndPos)) 
        {
            result = std::numeric_limits<double>::infinity();
            return true;
        }
        if(TryParseStringConstant(format->get_NegativeInfinitySymbol(), s, sidx, sEndPos)) 
        {
            result = -std::numeric_limits<double>::infinity();
            return true;
        }
        cli::array<unsigned char> *b = (new cli::array<unsigned char>((len + 1)));
        int32_t state = 1;
        String *decimal_separator = nullptr;
        String *group_separator = nullptr;
        String *currency_symbol = nullptr;
        int32_t decimal_separator_len = 0;
        int32_t group_separator_len = 0;
        int32_t currency_symbol_len = 0;
        if(((int32_t)(((int32_t)(style) & 32)) != 0)) 
        {
            decimal_separator = format->get_NumberDecimalSeparator();
            decimal_separator_len = decimal_separator->get_Length();
        }
        if(((int32_t)(((int32_t)(style) & 64)) != 0)) 
        {
            group_separator = format->get_NumberGroupSeparator();
            group_separator_len = group_separator->get_Length();
        }
        if(((int32_t)(((int32_t)(style) & 256)) != 0)) 
        {
            currency_symbol = format->get_CurrencySymbol();
            currency_symbol_len = currency_symbol->get_Length();
        }
        String *positive = format->get_PositiveSign();
        String *negative = format->get_NegativeSign();
        for(; (sidx < len); sidx++){
            c = s->get_Chars(sidx);
            if(((int32_t)(c) ==  0)) 
            {
                sidx = len;
                continue;
            }
            switch(state) {
                case 1: case_43: {
                    if(((int32_t)(((int32_t)(style) & 4)) != 0)) 
                    {
                        if((((int32_t)(c) ==  (int32_t)(positive->get_Chars(0))) && String::op_Equality(s->Substring2(sidx, positive->get_Length()), positive))) 
                        {
                            state = 2;
                            (sidx = sidx + (positive->get_Length() - 1));
                            continue;
                        }
                        if((((int32_t)(c) ==  (int32_t)(negative->get_Chars(0))) && String::op_Equality(s->Substring2(sidx, negative->get_Length()), negative))) 
                        {
                            state = 2;
                            b->at(didx++) = 45;
                            (sidx = sidx + (negative->get_Length() - 1));
                            continue;
                        }
                    }
                    state = 2;
                    goto case_44;
                }
                case 2: case_44: {
                    if(Char::IsDigit(c)) 
                    {
                        b->at(didx++) = (unsigned char)c;
                        break;
                    }
                    if((((int32_t)(c) ==  101) || ((int32_t)(c) ==  69))) 
                    {
                        goto case_45;
                    }
                    if(((decimal_separator_len > 0) && ((int32_t)(decimal_separator->get_Chars(0)) ==  (int32_t)(c)))) 
                    {
                        if((String::CompareOrdinal2(s, sidx, decimal_separator, 0, decimal_separator_len) ==  0)) 
                        {
                            b->at(didx++) = 46;
                            (sidx = sidx + (decimal_separator_len - 1));
                            state = 3;
                            break;
                        }
                    }
                    if(((group_separator_len > 0) && ((int32_t)(group_separator->get_Chars(0)) ==  (int32_t)(c)))) 
                    {
                        if(String::op_Equality(s->Substring2(sidx, group_separator_len), group_separator)) 
                        {
                            (sidx = sidx + (group_separator_len - 1));
                            state = 2;
                            break;
                        }
                    }
                    if(((currency_symbol_len > 0) && ((int32_t)(currency_symbol->get_Chars(0)) ==  (int32_t)(c)))) 
                    {
                        if(String::op_Equality(s->Substring2(sidx, currency_symbol_len), currency_symbol)) 
                        {
                            (sidx = sidx + (currency_symbol_len - 1));
                            state = 2;
                            break;
                        }
                    }
                    if(Char::IsWhiteSpace(c)) 
                    {
                        goto case_48;
                    }
                    if(!(tryParse)) 
                    {
                        exc = cli::gcnew<FormatException>(cli::concat(_T("Unknown char: "), cli::box(c)));
                    }
                    return false;
                }
                case 3: case_45: {
                    if(Char::IsDigit(c)) 
                    {
                        b->at(didx++) = (unsigned char)c;
                        break;
                    }
                    if((((int32_t)(c) ==  101) || ((int32_t)(c) ==  69))) 
                    {
                        if(((int32_t)(((int32_t)(style) & 128)) ==  0)) 
                        {
                            if(!(tryParse)) 
                            {
                                exc = cli::gcnew<FormatException>(cli::concat(_T("Unknown char: "), cli::box(c)));
                            }
                            return false;
                        }
                        b->at(didx++) = (unsigned char)c;
                        state = 4;
                        break;
                    }
                    if(Char::IsWhiteSpace(c)) 
                    {
                        goto case_48;
                    }
                    if(!(tryParse)) 
                    {
                        exc = cli::gcnew<FormatException>(cli::concat(_T("Unknown char: "), cli::box(c)));
                    }
                    return false;
                }
                case 4: case_46: {
                    if(Char::IsDigit(c)) 
                    {
                        state = 5;
                        goto case_47;
                    }
                    if((((int32_t)(c) ==  (int32_t)(positive->get_Chars(0))) && String::op_Equality(s->Substring2(sidx, positive->get_Length()), positive))) 
                    {
                        state = 2;
                        (sidx = sidx + (positive->get_Length() - 1));
                        continue;
                    }
                    if((((int32_t)(c) ==  (int32_t)(negative->get_Chars(0))) && String::op_Equality(s->Substring2(sidx, negative->get_Length()), negative))) 
                    {
                        state = 2;
                        b->at(didx++) = 45;
                        (sidx = sidx + (negative->get_Length() - 1));
                        continue;
                    }
                    if(Char::IsWhiteSpace(c)) 
                    {
                        goto case_48;
                    }
                    if(!(tryParse)) 
                    {
                        exc = cli::gcnew<FormatException>(cli::concat(_T("Unknown char: "), cli::box(c)));
                    }
                    return false;
                }
                case 5: case_47: {
                    if(Char::IsDigit(c)) 
                    {
                        b->at(didx++) = (unsigned char)c;
                        break;
                    }
                    if(Char::IsWhiteSpace(c)) 
                    {
                        goto case_48;
                    }
                    if(!(tryParse)) 
                    {
                        exc = cli::gcnew<FormatException>(cli::concat(_T("Unknown char: "), cli::box(c)));
                    }
                    return false;
                }
                case 6: case_48: {
                    if((allow_trailing_white && Char::IsWhiteSpace(c))) 
                    {
                        state = 6;
                        break;
                    }
                    if(!(tryParse)) 
                    {
                        exc = cli::gcnew<FormatException>(_T("Unknown char"));
                    }
                    return false;
                }
            }
            if((state ==  7)) 
            {
                break;
            }
        }
        b->at(didx) = 0;
        {
            /* FIXED - BLOCK */
            unsigned char* p = cli::fixed_guard(&(b->at(0)));
            double retVal;
            if(!(ParseImpl(p, retVal))) 
            {
                if(!(tryParse)) 
                {
                    exc = Int32::GetFormatException();
                }
                return false;
            }
            if((IsPositiveInfinity(retVal) || IsNegativeInfinity(retVal))) 
            {
                if(!(tryParse)) 
                {
                    exc = cli::gcnew<OverflowException>();
                }
                return false;
            }
            result = retVal;
            return true;
        }
    }
    
    bool Double::TryParseStringConstant(String* format, String* s, int32_t start, int32_t end) {
        return ((((end - start) + 1) ==  format->get_Length()) && (String::CompareOrdinal2(format, 0, s, start, format->get_Length()) ==  0));
    }
    
    bool Double::ParseImpl(unsigned char* byte_ptr, double value) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool Double::TryParse(String* s, Globalization::NumberStyles style, IFormatProvider* provider, double result) {
        Exception *exc;
        if(!(Parse5(s, style, provider, true, result, exc))) 
        {
            result = std::numeric_limits<double>::epsilon();
            return false;
        }
        return true;
    }
    
    bool Double::TryParse2(String* s, double result) {
        return TryParse(s, Globalization::NumberStyles::Any, nullptr, result);
    }
    
    String* Double::ToString_1636a0751cb9ac11() {
        return NumberFormatter::NumberToString17(cli::import((*this))->m_value, nullptr);
    }
    
    String* Double::ToString3(IFormatProvider* provider) {
        return NumberFormatter::NumberToString17(cli::import((*this))->m_value, provider);
    }
    
    String* Double::ToString4(String* format) {
        return ToString5(format, nullptr);
    }
    
    String* Double::ToString5(String* format, IFormatProvider* provider) {
        return NumberFormatter::NumberToString10(format, cli::import((*this))->m_value, provider);
    }
    
    TypeCode Double::GetTypeCode() {
        return TypeCode::Double2;
    }
    
    Object* Double::ToType(Type* targetType, IFormatProvider* provider) {
        if(Type::op_Equality2(targetType, nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("targetType"));
        }
        return Convert::ToType(cli::box(cli::import((*this))->m_value), targetType, provider, false);
    }
    
    bool Double::ToBoolean(IFormatProvider* provider) {
        return Convert::ToBoolean6(cli::import((*this))->m_value);
    }
    
    unsigned char Double::ToByte(IFormatProvider* provider) {
        return Convert::ToByte6(cli::import((*this))->m_value);
    }
    
    char16_t Double::ToChar(IFormatProvider* provider) {
        throw cli::gcnew<InvalidCastException>();
    }
    
    DateTime Double::ToDateTime(IFormatProvider* provider) {
        throw cli::gcnew<InvalidCastException>();
    }
    
    Decimal Double::ToDecimal(IFormatProvider* provider) {
        return Convert::ToDecimal6(cli::import((*this))->m_value);
    }
    
    double Double::ToDouble(IFormatProvider* provider) {
        return Convert::ToDouble6(cli::import((*this))->m_value);
    }
    
    int16_t Double::ToInt16(IFormatProvider* provider) {
        return Convert::ToInt166(cli::import((*this))->m_value);
    }
    
    int32_t Double::ToInt32(IFormatProvider* provider) {
        return Convert::ToInt326(cli::import((*this))->m_value);
    }
    
    int64_t Double::ToInt64(IFormatProvider* provider) {
        return Convert::ToInt646(cli::import((*this))->m_value);
    }
    
    signed char Double::ToSByte(IFormatProvider* provider) {
        return Convert::ToSByte6(cli::import((*this))->m_value);
    }
    
    float Double::ToSingle(IFormatProvider* provider) {
        return Convert::ToSingle6(cli::import((*this))->m_value);
    }
    
    uint16_t Double::ToUInt16(IFormatProvider* provider) {
        return Convert::ToUInt166(cli::import((*this))->m_value);
    }
    
    uint32_t Double::ToUInt32(IFormatProvider* provider) {
        return Convert::ToUInt326(cli::import((*this))->m_value);
    }
    
    uint64_t Double::ToUInt64(IFormatProvider* provider) {
        return Convert::ToUInt646(cli::import((*this))->m_value);
    }
    
    bool Double::op_Equality(double left, double right) {
        return (left ==  right);
    }
    
    bool Double::op_Inequality(double left, double right) {
        return (left != right);
    }
    
    bool Double::op_GreaterThan(double left, double right) {
        return (left > right);
    }
    
    bool Double::op_GreaterThanOrEqual(double left, double right) {
        return (left >= right);
    }
    
    bool Double::op_LessThan(double left, double right) {
        return (left < right);
    }
    
    bool Double::op_LessThanOrEqual(double left, double right) {
        return (left <= right);
    }
    
}
namespace System {
    
    Collections::Hashtable*  MonoEnumInfo::cache;
    Collections::Hashtable*  MonoEnumInfo::global_cache;
    Object*  MonoEnumInfo::global_cache_monitor;
    SByteComparer*  MonoEnumInfo::sbyte_comparer;
    ShortComparer*  MonoEnumInfo::short_comparer;
    IntComparer*  MonoEnumInfo::int_comparer;
    LongComparer*  MonoEnumInfo::long_comparer;
    
    void MonoEnumInfo::static_constructor() {
        global_cache_monitor = cli::gcnew<Object>();
        global_cache = cli::gcnew<Collections::Hashtable>();
    }
    
    void MonoEnumInfo::constructor(MonoEnumInfo other) {
        (*this)->utype = other->utype;
        (*this)->values = other->values;
        (*this)->names = other->names;
        (*this)->name_hash = other->name_hash;
    }
    
    void MonoEnumInfo::get_enum_info(Type* enumType, MonoEnumInfo info) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void MonoEnumInfo::GetInfo(Type* enumType, MonoEnumInfo info) {
        if(MonoEnumInfo::get_Cache()->ContainsKey_5de2e202a0290d76(enumType)) 
        {
            info = cli::unbox<MonoEnumInfo>(cache->get_Item_d75c6e706b965758(enumType));
            return;
        }
        {
            cli::lock_guard{global_cache_monitor};
            if(global_cache->ContainsKey_5de2e202a0290d76(enumType)) 
            {
                Object *boxedInfo = global_cache->get_Item_d75c6e706b965758(enumType);
                cache->set_Item_84c7e24d9caa09(enumType, boxedInfo);
                info = cli::unbox<MonoEnumInfo>(boxedInfo);
                return;
            }
        }
        get_enum_info(enumType, info);
        Collections::IComparer *ic = nullptr;
        Type *et = Enum::GetUnderlyingType(enumType);
        if(Type::op_Equality2(et, cli::typeof<Type>::info)) 
        {
            ic = int_comparer;
        }
         else 
        {
            if(Type::op_Equality2(et, cli::typeof<Type>::info)) 
            {
                ic = short_comparer;
            }
             else 
            {
                if(Type::op_Equality2(et, cli::typeof<Type>::info)) 
                {
                    ic = sbyte_comparer;
                }
                 else 
                {
                    if(Type::op_Equality2(et, cli::typeof<Type>::info)) 
                    {
                        ic = long_comparer;
                    }
                }
            }
        }
        Array::Sort5(info->values, info->names, ic);
        if((info->names->get_Length() > 50)) 
        {
            info->name_hash = cli::gcnew<Collections::Hashtable>(info->names->get_Length());
            for(int32_t i = 0; (i < info->names->get_Length()); ++i) {
                info->name_hash->set_Item_84c7e24d9caa09(info->names->at(i), cli::box(i));
            }
        }
        MonoEnumInfo cached = cli::ctor<MonoEnumInfo>(info);
        {
            cli::lock_guard{global_cache_monitor};
            global_cache->set_Item_84c7e24d9caa09(enumType, cli::box(cached));
        }
    }
    
    Collections::Hashtable* MonoEnumInfo::get_Cache() {
        if((cache ==  nullptr)) 
        {
            cache = cli::gcnew<Collections::Hashtable>();
        }
        return cache;
    }
    
}
namespace System {
    
    Guid*  Guid::Empty;
    Object*  Guid::_rngAccess;
    Security::Cryptography::RandomNumberGenerator*  Guid::_rng;
    Security::Cryptography::RandomNumberGenerator*  Guid::_fastRng;
    
    void Guid::constructor(cli::array<unsigned char>* b) {
        CheckArray(b, 16);
        (*this)->_a = Mono::Security::BitConverterLE::ToInt32(b, 0);
        (*this)->_b = Mono::Security::BitConverterLE::ToInt16(b, 4);
        (*this)->_c = Mono::Security::BitConverterLE::ToInt16(b, 6);
        (*this)->_d = b->at(8);
        (*this)->_e = b->at(9);
        (*this)->_f = b->at(10);
        (*this)->_g = b->at(11);
        (*this)->_h = b->at(12);
        (*this)->_i = b->at(13);
        (*this)->_j = b->at(14);
        (*this)->_k = b->at(15);
    }
    
    void Guid::constructor(String* g) {
        CheckNull(g);
        g = g->Trim();
        GuidParser *parser = cli::gcnew<GuidParser>(g);
        Guid guid;
        if(!(parser->Parse2(guid))) 
        {
            throw CreateFormatException(g);
        }
        (*this) = guid;
    }
    
    void Guid::constructor(int32_t a, int16_t b, int16_t c, cli::array<unsigned char>* d) {
        CheckArray(d, 8);
        (*this)->_a = (int32_t)(a);
        (*this)->_b = (int16_t)(b);
        (*this)->_c = (int16_t)(c);
        (*this)->_d = d->at(0);
        (*this)->_e = d->at(1);
        (*this)->_f = d->at(2);
        (*this)->_g = d->at(3);
        (*this)->_h = d->at(4);
        (*this)->_i = d->at(5);
        (*this)->_j = d->at(6);
        (*this)->_k = d->at(7);
    }
    
    void Guid::constructor(int32_t a, int16_t b, int16_t c, unsigned char d, unsigned char e, unsigned char f, unsigned char g, unsigned char h, unsigned char i, unsigned char j, unsigned char k) {
        (*this)->_a = a;
        (*this)->_b = b;
        (*this)->_c = c;
        (*this)->_d = d;
        (*this)->_e = e;
        (*this)->_f = f;
        (*this)->_g = g;
        (*this)->_h = h;
        (*this)->_i = i;
        (*this)->_j = j;
        (*this)->_k = k;
    }
    
    void Guid::constructor(uint32_t a, uint16_t b, uint16_t c, unsigned char d, unsigned char e, unsigned char f, unsigned char g, unsigned char h, unsigned char i, unsigned char j, unsigned char k) {
    }
    
    void Guid::static_constructor() {
    }
    
    void Guid::CheckNull(Object* o) {
        if((o ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(Locale::GetText(_T("Value cannot be null.")));
        }
    }
    
    void Guid::CheckLength(cli::array<unsigned char>* o, int32_t l) {
        if((o->get_Length() != l)) 
        {
            throw cli::gcnew<ArgumentException>(String::Format2(Locale::GetText(_T("Array should be exactly {0} bytes long.")), cli::box(l)));
        }
    }
    
    void Guid::CheckArray(cli::array<unsigned char>* o, int32_t l) {
        CheckNull(o);
        CheckLength(o, l);
    }
    
    Exception* Guid::CreateFormatException(String* s) {
        return cli::gcnew<FormatException>(String::Format2(_T("Invalid Guid format: {0}"), s));
    }
    
    int32_t Guid::Compare(int32_t x, int32_t y) {
        if((x < y)) 
        {
            return -1;
        }
         else 
        {
            return 1;
        }
    }
    
    int32_t Guid::CompareTo(Object* value) {
        if((value ==  nullptr)) 
        {
            return 1;
        }
        if(!(cli::is<Guid>(value))) 
        {
            throw cli::gcnew<ArgumentException>(_T("value"), Locale::GetText(_T("Argument of System.Guid.CompareTo should be a Guid.")));
        }
        return CompareTo2(cli::unbox<Guid>(value));
    }
    
    bool Guid::Equals_ed975d2f4a7d193e(Object* o) {
        if(cli::is<Guid>(o)) 
        {
            return (CompareTo2(cli::unbox<Guid>(o)) ==  0);
        }
        return false;
    }
    
    int32_t Guid::CompareTo2(Guid value) {
        if(((*this)->_a != value->_a)) 
        {
            return Compare((*this)->_a, value->_a);
        }
         else 
        {
            if(((int32_t)((*this)->_b) != (int32_t)(value->_b))) 
            {
                return Compare((int32_t)((*this)->_b), (int32_t)(value->_b));
            }
             else 
            {
                if(((int32_t)((*this)->_c) != (int32_t)(value->_c))) 
                {
                    return Compare((int32_t)((*this)->_c), (int32_t)(value->_c));
                }
                 else 
                {
                    if(((int32_t)((*this)->_d) != (int32_t)(value->_d))) 
                    {
                        return Compare((int32_t)((*this)->_d), (int32_t)(value->_d));
                    }
                     else 
                    {
                        if(((int32_t)((*this)->_e) != (int32_t)(value->_e))) 
                        {
                            return Compare((int32_t)((*this)->_e), (int32_t)(value->_e));
                        }
                         else 
                        {
                            if(((int32_t)((*this)->_f) != (int32_t)(value->_f))) 
                            {
                                return Compare((int32_t)((*this)->_f), (int32_t)(value->_f));
                            }
                             else 
                            {
                                if(((int32_t)((*this)->_g) != (int32_t)(value->_g))) 
                                {
                                    return Compare((int32_t)((*this)->_g), (int32_t)(value->_g));
                                }
                                 else 
                                {
                                    if(((int32_t)((*this)->_h) != (int32_t)(value->_h))) 
                                    {
                                        return Compare((int32_t)((*this)->_h), (int32_t)(value->_h));
                                    }
                                     else 
                                    {
                                        if(((int32_t)((*this)->_i) != (int32_t)(value->_i))) 
                                        {
                                            return Compare((int32_t)((*this)->_i), (int32_t)(value->_i));
                                        }
                                         else 
                                        {
                                            if(((int32_t)((*this)->_j) != (int32_t)(value->_j))) 
                                            {
                                                return Compare((int32_t)((*this)->_j), (int32_t)(value->_j));
                                            }
                                             else 
                                            {
                                                if(((int32_t)((*this)->_k) != (int32_t)(value->_k))) 
                                                {
                                                    return Compare((int32_t)((*this)->_k), (int32_t)(value->_k));
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return 0;
    }
    
    bool Guid::Equals2(Guid g) {
        return (CompareTo2(g) ==  0);
    }
    
    int32_t Guid::GetHashCode_6648aef0f235ee6c() {
        int32_t res;
        res = (int32_t)((*this)->_a);
        res = (res ^ (((int32_t)((*this)->_b) << 16) | (int32_t)((*this)->_c)));
        res = (res ^ ((int32_t)((*this)->_d) << 24));
        res = (res ^ ((int32_t)((*this)->_e) << 16));
        res = (res ^ ((int32_t)((*this)->_f) << 8));
        res = (res ^ (int32_t)((*this)->_g));
        res = (res ^ ((int32_t)((*this)->_h) << 24));
        res = (res ^ ((int32_t)((*this)->_i) << 16));
        res = (res ^ ((int32_t)((*this)->_j) << 8));
        res = (res ^ (int32_t)((*this)->_k));
        return res;
    }
    
    char16_t Guid::ToHex(int32_t b) {
        return (char16_t)(b < 10) ? (48 + b) : ((97 + b) - 10);
    }
    
    Guid Guid::NewGuid() {
        cli::array<unsigned char> *b = (new cli::array<unsigned char>(16));
        {
            cli::lock_guard{_rngAccess};
            if((_rng ==  nullptr)) 
            {
                _rng = Security::Cryptography::RandomNumberGenerator::Create();
            }
            _rng->GetBytes_bf6c3bc1baf70dfd(b);
        }
        Guid res = cli::ctor<Guid>(b);
        res->_d = (unsigned char)(((uint32_t)(res->_d) & 63U) | 128U);
        res->_c = (int16_t)(((int64_t)(res->_c) & 4095L) | 16384L);
        return res;
    }
    
    cli::array<unsigned char>* Guid::FastNewGuidArray() {
        cli::array<unsigned char> *guid = (new cli::array<unsigned char>(16));
        {
            cli::lock_guard{_rngAccess};
            if((_rng != nullptr)) 
            {
                _fastRng = _rng;
            }
            if((_fastRng ==  nullptr)) 
            {
                _fastRng = cli::gcnew<Security::Cryptography::RNGCryptoServiceProvider>();
            }
            _fastRng->GetBytes_bf6c3bc1baf70dfd(guid);
        }
        guid->at(8) = (unsigned char)(((int32_t)(guid->at(8)) & 63) | 128);
        guid->at(7) = (unsigned char)(((int32_t)(guid->at(7)) & 15) | 64);
        return guid;
    }
    
    cli::array<unsigned char>* Guid::ToByteArray() {
        cli::array<unsigned char> *res = (new cli::array<unsigned char>(16));
        cli::array<unsigned char> *tmp;
        int32_t d = 0;
        int32_t s;
        tmp = Mono::Security::BitConverterLE::GetBytes4((*this)->_a);
        for(s = 0; (s < 4); ++s){
            res->at(d++) = tmp->at(s);
        }
        tmp = Mono::Security::BitConverterLE::GetBytes3((*this)->_b);
        for(s = 0; (s < 2); ++s){
            res->at(d++) = tmp->at(s);
        }
        tmp = Mono::Security::BitConverterLE::GetBytes3((*this)->_c);
        for(s = 0; (s < 2); ++s){
            res->at(d++) = tmp->at(s);
        }
        res->at(8) = (*this)->_d;
        res->at(9) = (*this)->_e;
        res->at(10) = (*this)->_f;
        res->at(11) = (*this)->_g;
        res->at(12) = (*this)->_h;
        res->at(13) = (*this)->_i;
        res->at(14) = (*this)->_j;
        res->at(15) = (*this)->_k;
        return res;
    }
    
    void Guid::AppendInt(Text::StringBuilder* builder, int32_t value) {
        builder->Append16(ToHex(((value >> 28) & 15)));
        builder->Append16(ToHex(((value >> 24) & 15)));
        builder->Append16(ToHex(((value >> 20) & 15)));
        builder->Append16(ToHex(((value >> 16) & 15)));
        builder->Append16(ToHex(((value >> 12) & 15)));
        builder->Append16(ToHex(((value >> 8) & 15)));
        builder->Append16(ToHex(((value >> 4) & 15)));
        builder->Append16(ToHex((value & 15)));
    }
    
    void Guid::AppendShort(Text::StringBuilder* builder, int16_t value) {
        builder->Append16(ToHex((((int32_t)(value) >> 12) & 15)));
        builder->Append16(ToHex((((int32_t)(value) >> 8) & 15)));
        builder->Append16(ToHex((((int32_t)(value) >> 4) & 15)));
        builder->Append16(ToHex(((int32_t)(value) & 15)));
    }
    
    void Guid::AppendByte(Text::StringBuilder* builder, unsigned char value) {
        builder->Append16(ToHex((((int32_t)(value) >> 4) & 15)));
        builder->Append16(ToHex(((int32_t)(value) & 15)));
    }
    
    String* Guid::BaseToString(bool h, bool p, bool b) {
        Text::StringBuilder *res = cli::gcnew<Text::StringBuilder>(40);
        if(p) 
        {
            res->Append16(u'(');
        }
         else 
        {
            if(b) 
            {
                res->Append16(u'\x7b');
            }
        }
        AppendInt(res, (*this)->_a);
        if(h) 
        {
            res->Append16(u'-');
        }
        AppendShort(res, (*this)->_b);
        if(h) 
        {
            res->Append16(u'-');
        }
        AppendShort(res, (*this)->_c);
        if(h) 
        {
            res->Append16(u'-');
        }
        AppendByte(res, (*this)->_d);
        AppendByte(res, (*this)->_e);
        if(h) 
        {
            res->Append16(u'-');
        }
        AppendByte(res, (*this)->_f);
        AppendByte(res, (*this)->_g);
        AppendByte(res, (*this)->_h);
        AppendByte(res, (*this)->_i);
        AppendByte(res, (*this)->_j);
        AppendByte(res, (*this)->_k);
        if(p) 
        {
            res->Append16(u')');
        }
         else 
        {
            if(b) 
            {
                res->Append16(u'\x7d');
            }
        }
        return res->ToString_1636a0751cb9ac11();
    }
    
    String* Guid::ToString_1636a0751cb9ac11() {
        return BaseToString(true, false, false);
    }
    
    String* Guid::ToString3(String* format) {
        bool h = true;
        bool p = false;
        bool b = false;
        if((format != nullptr)) 
        {
            String *f = format->ToLowerInvariant();
            if(String::op_Equality(f, _T("b"))) 
            {
                b = true;
            }
             else 
            {
                if(String::op_Equality(f, _T("p"))) 
                {
                    p = true;
                }
                 else 
                {
                    if(String::op_Equality(f, _T("n"))) 
                    {
                        h = false;
                    }
                     else 
                    {
                        if((String::op_Inequality(f, _T("d")) && String::op_Inequality(f, String::Empty))) 
                        {
                            throw cli::gcnew<FormatException>(Locale::GetText(_T("Argument to Guid.ToString(string format) should be \"b\", \"B\", \"d\", \"D\", \"n\", \"N\", \"p\" or \"P\"")));
                        }
                    }
                }
            }
        }
        return BaseToString(h, p, b);
    }
    
    String* Guid::ToString4(String* format, IFormatProvider* provider) {
        return ToString3(format);
    }
    
    Guid Guid::Parse(String* input) {
        Guid guid;
        if(!(TryParse(input, guid))) 
        {
            throw CreateFormatException(input);
        }
        return guid;
    }
    
    Guid Guid::ParseExact(String* input, String* format) {
        Guid guid;
        if(!(TryParseExact(input, format, guid))) 
        {
            throw CreateFormatException(input);
        }
        return guid;
    }
    
    bool Guid::TryParse(String* input, Guid result) {
        if((input ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("input"));
        }
        GuidParser *parser = cli::gcnew<GuidParser>(input);
        return parser->Parse2(result);
    }
    
    bool Guid::TryParseExact(String* input, String* format, Guid result) {
        if((input ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("input"));
        }
        if((format ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("format"));
        }
        GuidParser *parser = cli::gcnew<GuidParser>(input);
        return parser->Parse(ParseFormat(format), result);
    }
    
    Format Guid::ParseFormat(String* format) {
        if((format->get_Length() != 1)) 
        {
            throw cli::gcnew<ArgumentException>(_T("Wrong format"));
        }
        switch(format->get_Chars(0)) {
            case u'N': case_49: {
                return Format::N;
            }
            case u'D': case_50: {
                return Format::D;
            }
            case u'B': case_51: {
                return Format::B;
            }
            case u'P': case_52: {
                return Format::P;
            }
            case u'X': case_53: {
                return Format::X;
            }
        }
        throw cli::gcnew<ArgumentException>(_T("Wrong format"));
    }
    
    bool Guid::op_Equality(Guid a, Guid b) {
        return a->Equals2(b);
    }
    
    bool Guid::op_Inequality(Guid a, Guid b) {
        return !(a->Equals2(b));
    }
    
}
namespace System {
    
    
    int32_t Int16::CompareTo(Object* value) {
        if((value ==  nullptr)) 
        {
            return 1;
        }
        if(!(cli::is<Int16>(value))) 
        {
            throw cli::gcnew<ArgumentException>(Locale::GetText(_T("Value is not a System.Int16")));
        }
        int16_t xv = cli::unbox<int16_t>(value);
        if(((int32_t)(cli::import((*this))->m_value) ==  (int32_t)(xv))) 
        {
            return 0;
        }
        if(((int32_t)(cli::import((*this))->m_value) > (int32_t)(xv))) 
        {
            return 1;
        }
         else 
        {
            return -1;
        }
    }
    
    bool Int16::Equals_ed975d2f4a7d193e(Object* obj) {
        if(!(cli::is<Int16>(obj))) 
        {
            return false;
        }
        return ((int32_t)(cli::unbox<int16_t>(obj)) ==  (int32_t)(cli::import((*this))->m_value));
    }
    
    int32_t Int16::GetHashCode_6648aef0f235ee6c() {
        return (int32_t)(cli::import((*this))->m_value);
    }
    
    int32_t Int16::CompareTo2(int16_t value) {
        if(((int32_t)(cli::import((*this))->m_value) ==  (int32_t)(value))) 
        {
            return 0;
        }
        if(((int32_t)(cli::import((*this))->m_value) > (int32_t)(value))) 
        {
            return 1;
        }
         else 
        {
            return -1;
        }
    }
    
    bool Int16::Equals2(int16_t obj) {
        return ((int32_t)(obj) ==  (int32_t)(cli::import((*this))->m_value));
    }
    
    bool Int16::Parse(String* s, bool tryParse, int16_t result, Exception* exc) {
        int16_t val = 0;
        int32_t len;
        int32_t i, sign = 1;
        bool digits_seen = false;
        result = 0;
        exc = nullptr;
        if((s ==  nullptr)) 
        {
            if(!(tryParse)) 
            {
                exc = cli::gcnew<ArgumentNullException>(_T("s"));
            }
            return false;
        }
        len = s->get_Length();
        char16_t c;
        for(i = 0; (i < len); i++){
            c = s->get_Chars(i);
            if(!(Char::IsWhiteSpace(c))) 
            {
                break;
            }
        }
        if((i ==  len)) 
        {
            if(!(tryParse)) 
            {
                exc = Int32::GetFormatException();
            }
            return false;
        }
        c = s->get_Chars(i);
        if(((int32_t)(c) ==  43)) 
        {
            i++;
        }
         else 
        {
            if(((int32_t)(c) ==  45)) 
            {
                sign = -1;
                i++;
            }
        }
        for(; (i < len); i++){
            c = s->get_Chars(i);
            if((((int32_t)(c) >= 48) && ((int32_t)(c) <= 57))) 
            {
                unsigned char d = (unsigned char)((int32_t)(c) - 48);
                if(((int32_t)(val) > 3276)) 
                {
                    goto overflow;
                }
                if(((int32_t)(val) ==  3276)) 
                {
                    if((((int32_t)(d) > 7) && ((sign ==  1) || ((int32_t)(d) > 8)))) 
                    {
                        goto overflow;
                    }
                    if((sign ==  -1)) 
                    {
                        val = (int16_t)((((int32_t)(val) * sign) * 10) - (int32_t)(d));
                    }
                     else 
                    {
                        val = (int16_t)(((int32_t)(val) * 10) + (int32_t)(d));
                    }
                    if(Int32::ProcessTrailingWhitespace(tryParse, s, (i + 1), exc)) 
                    {
                        result = val;
                        return true;
                    }
                    goto overflow;
                }
                 else 
                {
                    val = (int16_t)(((int32_t)(val) * 10) + (int32_t)(d));
                }
                digits_seen = true;
            }
             else 
            {
                if(!(Int32::ProcessTrailingWhitespace(tryParse, s, i, exc))) 
                {
                    return false;
                }
            }
        }
        if(!(digits_seen)) 
        {
            if(!(tryParse)) 
            {
                exc = Int32::GetFormatException();
            }
            return false;
        }
        if((sign ==  -1)) 
        {
            result = (int16_t)((int32_t)(val) * sign);
        }
         else 
        {
            result = val;
        }
        return true;
        overflow:
        if(!(tryParse)) 
        {
            exc = cli::gcnew<OverflowException>(_T("Value is too large"));
        }
        return false;
    }
    
    int16_t Int16::Parse2(String* s, IFormatProvider* provider) {
        return Parse4(s, Globalization::NumberStyles::Integer, provider);
    }
    
    int16_t Int16::Parse3(String* s, Globalization::NumberStyles style) {
        return Parse4(s, style, nullptr);
    }
    
    int16_t Int16::Parse4(String* s, Globalization::NumberStyles style, IFormatProvider* provider) {
        int32_t tmpResult = Int32::Parse6(s, style, provider);
        if(((int32_t)(((int32_t)(style) & 512)) != 0)) 
        {
            if(((tmpResult >= 0) && (tmpResult <= 65535))) 
            {
                return (int16_t)tmpResult;
            }
        }
         else 
        {
            if(((tmpResult <= 32767) && (tmpResult >= -32768))) 
            {
                return (int16_t)tmpResult;
            }
        }
        throw cli::gcnew<OverflowException>(_T("Value too large or too small."));
    }
    
    int16_t Int16::Parse5(String* s) {
        Exception *exc;
        int16_t res;
        if(!(Parse(s, false, res, exc))) 
        {
            throw exc;
        }
        return res;
    }
    
    bool Int16::TryParse(String* s, int16_t result) {
        Exception *exc;
        if(!(Parse(s, true, result, exc))) 
        {
            result = 0;
            return false;
        }
        return true;
    }
    
    bool Int16::TryParse2(String* s, Globalization::NumberStyles style, IFormatProvider* provider, int16_t result) {
        int32_t tmpResult;
        result = 0;
        if(!(Int32::TryParse2(s, style, provider, tmpResult))) 
        {
            return false;
        }
        if(((tmpResult > 32767) || (tmpResult < -32768))) 
        {
            return false;
        }
        result = (int16_t)tmpResult;
        return true;
    }
    
    String* Int16::ToString_1636a0751cb9ac11() {
        return NumberFormatter::NumberToString13((int32_t)(cli::import((*this))->m_value), nullptr);
    }
    
    String* Int16::ToString3(IFormatProvider* provider) {
        return NumberFormatter::NumberToString13((int32_t)(cli::import((*this))->m_value), provider);
    }
    
    String* Int16::ToString4(String* format) {
        return ToString5(format, nullptr);
    }
    
    String* Int16::ToString5(String* format, IFormatProvider* provider) {
        return NumberFormatter::NumberToString4(format, cli::import((*this))->m_value, provider);
    }
    
    TypeCode Int16::GetTypeCode() {
        return TypeCode::Int162;
    }
    
    bool Int16::ToBoolean(IFormatProvider* provider) {
        return Convert::ToBoolean11(cli::import((*this))->m_value);
    }
    
    unsigned char Int16::ToByte(IFormatProvider* provider) {
        return Convert::ToByte11(cli::import((*this))->m_value);
    }
    
    char16_t Int16::ToChar(IFormatProvider* provider) {
        return Convert::ToChar11(cli::import((*this))->m_value);
    }
    
    DateTime Int16::ToDateTime(IFormatProvider* provider) {
        return Convert::ToDateTime9(cli::import((*this))->m_value);
    }
    
    Decimal Int16::ToDecimal(IFormatProvider* provider) {
        return Convert::ToDecimal11(cli::import((*this))->m_value);
    }
    
    double Int16::ToDouble(IFormatProvider* provider) {
        return Convert::ToDouble11(cli::import((*this))->m_value);
    }
    
    int16_t Int16::ToInt16(IFormatProvider* provider) {
        return Convert::ToInt1611(cli::import((*this))->m_value);
    }
    
    int32_t Int16::ToInt32(IFormatProvider* provider) {
        return Convert::ToInt3211(cli::import((*this))->m_value);
    }
    
    int64_t Int16::ToInt64(IFormatProvider* provider) {
        return Convert::ToInt6411(cli::import((*this))->m_value);
    }
    
    signed char Int16::ToSByte(IFormatProvider* provider) {
        return Convert::ToSByte11(cli::import((*this))->m_value);
    }
    
    float Int16::ToSingle(IFormatProvider* provider) {
        return Convert::ToSingle11(cli::import((*this))->m_value);
    }
    
    Object* Int16::ToType(Type* targetType, IFormatProvider* provider) {
        if(Type::op_Equality2(targetType, nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("targetType"));
        }
        return Convert::ToType(cli::box(cli::import((*this))->m_value), targetType, provider, false);
    }
    
    uint16_t Int16::ToUInt16(IFormatProvider* provider) {
        return Convert::ToUInt1611(cli::import((*this))->m_value);
    }
    
    uint32_t Int16::ToUInt32(IFormatProvider* provider) {
        return Convert::ToUInt3211(cli::import((*this))->m_value);
    }
    
    uint64_t Int16::ToUInt64(IFormatProvider* provider) {
        return Convert::ToUInt6411(cli::import((*this))->m_value);
    }
    
}
namespace System {
    
    
    int32_t Int32::CompareTo(Object* value) {
        if((value ==  nullptr)) 
        {
            return 1;
        }
        if(!(cli::is<Int32>(value))) 
        {
            throw cli::gcnew<ArgumentException>(Locale::GetText(_T("Value is not a System.Int32")));
        }
        int32_t xv = cli::unbox<int32_t>(value);
        if((cli::import((*this))->m_value ==  xv)) 
        {
            return 0;
        }
        if((cli::import((*this))->m_value > xv)) 
        {
            return 1;
        }
         else 
        {
            return -1;
        }
    }
    
    bool Int32::Equals_ed975d2f4a7d193e(Object* obj) {
        if(!(cli::is<Int32>(obj))) 
        {
            return false;
        }
        return (cli::unbox<int32_t>(obj) ==  cli::import((*this))->m_value);
    }
    
    int32_t Int32::GetHashCode_6648aef0f235ee6c() {
        return cli::import((*this))->m_value;
    }
    
    int32_t Int32::CompareTo2(int32_t value) {
        if((cli::import((*this))->m_value ==  value)) 
        {
            return 0;
        }
        if((cli::import((*this))->m_value > value)) 
        {
            return 1;
        }
         else 
        {
            return -1;
        }
    }
    
    bool Int32::Equals2(int32_t obj) {
        return (obj ==  cli::import((*this))->m_value);
    }
    
    bool Int32::ProcessTrailingWhitespace(bool tryParse, String* s, int32_t position, Exception* exc) {
        int32_t len = s->get_Length();
        for(int32_t i = position; (i < len); i++){
            char16_t c = s->get_Chars(i);
            if((((int32_t)(c) != 0) && !(Char::IsWhiteSpace(c)))) 
            {
                if(!(tryParse)) 
                {
                    exc = GetFormatException();
                }
                return false;
            }
        }
        return true;
    }
    
    bool Int32::Parse(String* s, bool tryParse, int32_t result, Exception* exc) {
        int32_t val = 0;
        int32_t len;
        int32_t i, sign = 1;
        bool digits_seen = false;
        result = 0;
        exc = nullptr;
        Globalization::NumberFormatInfo *nfi = Threading::Thread::get_CurrentThread()->get_CurrentCulture()->get_NumberFormat_56b6d54c07628932();
        if((s ==  nullptr)) 
        {
            if(!(tryParse)) 
            {
                exc = cli::gcnew<ArgumentNullException>(_T("s"));
            }
            return false;
        }
        len = s->get_Length();
        char16_t c;
        for(i = 0; (i < len); i++){
            c = s->get_Chars(i);
            if(!(Char::IsWhiteSpace(c))) 
            {
                break;
            }
        }
        if((i ==  len)) 
        {
            if(!(tryParse)) 
            {
                exc = GetFormatException();
            }
            return false;
        }
        if((String::Compare4(s, i, nfi->get_PositiveSign(), 0, nfi->get_PositiveSign()->get_Length()) ==  0)) 
        {
            (i = i + nfi->get_PositiveSign()->get_Length());
        }
         else 
        {
            if((String::Compare4(s, i, nfi->get_NegativeSign(), 0, nfi->get_NegativeSign()->get_Length()) ==  0)) 
            {
                sign = -1;
                (i = i + nfi->get_NegativeSign()->get_Length());
            }
        }
        for(; (i < len); i++){
            c = s->get_Chars(i);
            if(((int32_t)(c) ==  0)) 
            {
                i = len;
                continue;
            }
            if((((int32_t)(c) >= 48) && ((int32_t)(c) <= 57))) 
            {
                unsigned char d = (unsigned char)((int32_t)(c) - 48);
                if((val > 214748364)) 
                {
                    goto overflow;
                }
                if((val ==  214748364)) 
                {
                    if((((int32_t)(d) > 7) && ((sign ==  1) || ((int32_t)(d) > 8)))) 
                    {
                        goto overflow;
                    }
                    if((sign ==  -1)) 
                    {
                        val = (((val * sign) * 10) - (int32_t)(d));
                    }
                     else 
                    {
                        val = ((val * 10) + (int32_t)(d));
                    }
                    if(ProcessTrailingWhitespace(tryParse, s, (i + 1), exc)) 
                    {
                        result = val;
                        return true;
                    }
                    goto overflow;
                }
                 else 
                {
                    val = ((val * 10) + (int32_t)(d));
                }
                digits_seen = true;
            }
             else 
            {
                if(!(ProcessTrailingWhitespace(tryParse, s, i, exc))) 
                {
                    return false;
                }
            }
        }
        if(!(digits_seen)) 
        {
            if(!(tryParse)) 
            {
                exc = GetFormatException();
            }
            return false;
        }
        if((sign ==  -1)) 
        {
            result = (val * sign);
        }
         else 
        {
            result = val;
        }
        return true;
        overflow:
        if(!(tryParse)) 
        {
            exc = cli::gcnew<OverflowException>(_T("Value is too large"));
        }
        return false;
    }
    
    int32_t Int32::Parse2(String* s, IFormatProvider* provider) {
        return Parse6(s, Globalization::NumberStyles::Integer, provider);
    }
    
    int32_t Int32::Parse3(String* s, Globalization::NumberStyles style) {
        return Parse6(s, style, nullptr);
    }
    
    bool Int32::CheckStyle(Globalization::NumberStyles style, bool tryParse, Exception* exc) {
        if(((int32_t)(((int32_t)(style) & 512)) != 0)) 
        {
            Globalization::NumberStyles ne = (Globalization::NumberStyles)(((int32_t)(style) ^ 512));
            if(((int32_t)(((int32_t)(ne) & 1)) != 0)) 
            {
                (ne = (Globalization::NumberStyles)(((int32_t)(ne) ^ 1)));
            }
            if(((int32_t)(((int32_t)(ne) & 2)) != 0)) 
            {
                (ne = (Globalization::NumberStyles)(((int32_t)(ne) ^ 2)));
            }
            if(((int32_t)(ne) != 0)) 
            {
                if(!(tryParse)) 
                {
                    exc = cli::gcnew<ArgumentException>(_T("With AllowHexSpecifier only AllowLeadingWhite and AllowTrailingWhite are permitted."));
                }
                return false;
            }
        }
         else 
        {
            if(((uint32_t)((uint32_t)(int32_t)(style)) > 511U)) 
            {
                if(!(tryParse)) 
                {
                    exc = cli::gcnew<ArgumentException>(_T("Not a valid number style"));
                }
                return false;
            }
        }
        return true;
    }
    
    bool Int32::JumpOverWhite(int32_t pos, String* s, bool reportError, bool tryParse, Exception* exc) {
        while(((pos < s->get_Length()) && Char::IsWhiteSpace(s->get_Chars(pos)))) pos++;
        if((reportError && (pos >= s->get_Length()))) 
        {
            if(!(tryParse)) 
            {
                exc = GetFormatException();
            }
            return false;
        }
        return true;
    }
    
    void Int32::FindSign(int32_t pos, String* s, Globalization::NumberFormatInfo* nfi, bool foundSign, bool negative) {
        if((((pos + nfi->get_NegativeSign()->get_Length()) <= s->get_Length()) && (s->IndexOf9(nfi->get_NegativeSign(), pos, nfi->get_NegativeSign()->get_Length()) ==  pos))) 
        {
            negative = true;
            foundSign = true;
            (pos = pos + nfi->get_NegativeSign()->get_Length());
        }
         else 
        {
            if((((pos + nfi->get_PositiveSign()->get_Length()) <= s->get_Length()) && (s->IndexOf9(nfi->get_PositiveSign(), pos, nfi->get_PositiveSign()->get_Length()) ==  pos))) 
            {
                negative = false;
                (pos = pos + nfi->get_PositiveSign()->get_Length());
                foundSign = true;
            }
        }
    }
    
    void Int32::FindCurrency(int32_t pos, String* s, Globalization::NumberFormatInfo* nfi, bool foundCurrency) {
        if((((pos + nfi->get_CurrencySymbol()->get_Length()) <= s->get_Length()) && String::op_Equality(s->Substring2(pos, nfi->get_CurrencySymbol()->get_Length()), nfi->get_CurrencySymbol()))) 
        {
            foundCurrency = true;
            (pos = pos + nfi->get_CurrencySymbol()->get_Length());
        }
    }
    
    bool Int32::FindExponent(int32_t pos, String* s, int32_t exponent, bool tryParse, Exception* exc) {
        exponent = 0;
        int64_t exp = 0L;
        int32_t i = s->IndexOfAny2((new cli::array<char16_t>({u'e', u'E'})), pos);
        if((i < 0)) 
        {
            exc = nullptr;
            return false;
        }
        if((++i ==  s->get_Length())) 
        {
            exc = tryParse ? nullptr : GetFormatException();
            return true;
        }
        if(((int32_t)(s->get_Chars(i)) ==  45)) 
        {
            exc = tryParse ? nullptr : cli::gcnew<OverflowException>(_T("Value too large or too small."));
            return true;
        }
        if((((int32_t)(s->get_Chars(i)) ==  43) && (++i ==  s->get_Length()))) 
        {
            exc = tryParse ? nullptr : GetFormatException();
            return true;
        }
        for(; (i < s->get_Length()); i++){
            if(!(Char::IsDigit(s->get_Chars(i)))) 
            {
                exc = tryParse ? nullptr : GetFormatException();
                return true;
            }
            exp = cli::checked(((exp * 10L) - (int64_t)((int32_t)(((int32_t)(s->get_Chars(i)) - 48)))));
            if(((exp < -2147483648L) || (exp > 2147483647L))) 
            {
                exc = tryParse ? nullptr : cli::gcnew<OverflowException>(_T("Value too large or too small."));
                return true;
            }
        }
        exp = -(exp);
        exc = nullptr;
        exponent = (int32_t)exp;
        pos = i;
        return true;
    }
    
    bool Int32::FindOther(int32_t pos, String* s, String* other) {
        if((((pos + other->get_Length()) <= s->get_Length()) && String::op_Equality(s->Substring2(pos, other->get_Length()), other))) 
        {
            (pos = pos + other->get_Length());
            return true;
        }
        return false;
    }
    
    bool Int32::ValidDigit(char16_t e, bool allowHex) {
        if(allowHex) 
        {
            return ((Char::IsDigit(e) || (((int32_t)(e) >= 65) && ((int32_t)(e) <= 70))) || (((int32_t)(e) >= 97) && ((int32_t)(e) <= 102)));
        }
        return Char::IsDigit(e);
    }
    
    Exception* Int32::GetFormatException() {
        return cli::gcnew<FormatException>(_T("Input string was not in the correct format"));
    }
    
    bool Int32::Parse4(String* s, Globalization::NumberStyles style, IFormatProvider* fp, bool tryParse, int32_t result, Exception* exc) {
        result = 0;
        exc = nullptr;
        if((s ==  nullptr)) 
        {
            if(!(tryParse)) 
            {
                exc = cli::gcnew<ArgumentNullException>(_T("s"));
            }
            return false;
        }
        if((s->get_Length() ==  0)) 
        {
            if(!(tryParse)) 
            {
                exc = GetFormatException();
            }
            return false;
        }
        Globalization::NumberFormatInfo *nfi = nullptr;
        if((fp != nullptr)) 
        {
            Type *typeNFI = cli::typeof<Type>::info;
            nfi = cli::cast<Globalization::NumberFormatInfo*>(fp->GetFormat_b67414a65453cc7e(typeNFI));
        }
        if((nfi ==  nullptr)) 
        {
            nfi = Threading::Thread::get_CurrentThread()->get_CurrentCulture()->get_NumberFormat_56b6d54c07628932();
        }
        if(!(CheckStyle(style, tryParse, exc))) 
        {
            return false;
        }
        bool AllowCurrencySymbol = ((int32_t)(((int32_t)(style) & 256)) != 0);
        bool AllowHexSpecifier = ((int32_t)(((int32_t)(style) & 512)) != 0);
        bool AllowThousands = ((int32_t)(((int32_t)(style) & 64)) != 0);
        bool AllowDecimalPoint = ((int32_t)(((int32_t)(style) & 32)) != 0);
        bool AllowParentheses = ((int32_t)(((int32_t)(style) & 16)) != 0);
        bool AllowTrailingSign = ((int32_t)(((int32_t)(style) & 8)) != 0);
        bool AllowLeadingSign = ((int32_t)(((int32_t)(style) & 4)) != 0);
        bool AllowTrailingWhite = ((int32_t)(((int32_t)(style) & 2)) != 0);
        bool AllowLeadingWhite = ((int32_t)(((int32_t)(style) & 1)) != 0);
        bool AllowExponent = ((int32_t)(((int32_t)(style) & 128)) != 0);
        int32_t pos = 0;
        if((AllowLeadingWhite && !(JumpOverWhite(pos, s, true, tryParse, exc)))) 
        {
            return false;
        }
        bool foundOpenParentheses = false;
        bool negative = false;
        bool foundSign = false;
        bool foundCurrency = false;
        if((AllowParentheses && ((int32_t)(s->get_Chars(pos)) ==  40))) 
        {
            foundOpenParentheses = true;
            foundSign = true;
            negative = true;
            pos++;
            if((AllowLeadingWhite && !(JumpOverWhite(pos, s, true, tryParse, exc)))) 
            {
                return false;
            }
            if(String::op_Equality(s->Substring2(pos, nfi->get_NegativeSign()->get_Length()), nfi->get_NegativeSign())) 
            {
                if(!(tryParse)) 
                {
                    exc = GetFormatException();
                }
                return false;
            }
            if(String::op_Equality(s->Substring2(pos, nfi->get_PositiveSign()->get_Length()), nfi->get_PositiveSign())) 
            {
                if(!(tryParse)) 
                {
                    exc = GetFormatException();
                }
                return false;
            }
        }
        if((AllowLeadingSign && !(foundSign))) 
        {
            FindSign(pos, s, nfi, foundSign, negative);
            if(foundSign) 
            {
                if((AllowLeadingWhite && !(JumpOverWhite(pos, s, true, tryParse, exc)))) 
                {
                    return false;
                }
                if(AllowCurrencySymbol) 
                {
                    FindCurrency(pos, s, nfi, foundCurrency);
                    if(((foundCurrency && AllowLeadingWhite) && !(JumpOverWhite(pos, s, true, tryParse, exc)))) 
                    {
                        return false;
                    }
                }
            }
        }
        if((AllowCurrencySymbol && !(foundCurrency))) 
        {
            FindCurrency(pos, s, nfi, foundCurrency);
            if(foundCurrency) 
            {
                if((AllowLeadingWhite && !(JumpOverWhite(pos, s, true, tryParse, exc)))) 
                {
                    return false;
                }
                if(foundCurrency) 
                {
                    if((!(foundSign) && AllowLeadingSign)) 
                    {
                        FindSign(pos, s, nfi, foundSign, negative);
                        if(((foundSign && AllowLeadingWhite) && !(JumpOverWhite(pos, s, true, tryParse, exc)))) 
                        {
                            return false;
                        }
                    }
                }
            }
        }
        int32_t number = 0;
        int32_t nDigits = 0;
        bool decimalPointFound = false;
        int32_t digitValue;
        char16_t hexDigit;
        int32_t exponent = 0;
        do {
            if(!(ValidDigit(s->get_Chars(pos), AllowHexSpecifier))) 
            {
                if((AllowThousands && (FindOther(pos, s, nfi->get_NumberGroupSeparator()) || FindOther(pos, s, nfi->get_CurrencyGroupSeparator())))) 
                {
                    continue;
                }
                 else 
                {
                    if(((!(decimalPointFound) && AllowDecimalPoint) && (FindOther(pos, s, nfi->get_NumberDecimalSeparator()) || FindOther(pos, s, nfi->get_CurrencyDecimalSeparator())))) 
                    {
                        decimalPointFound = true;
                        continue;
                    }
                }
                break;
            }
            if(AllowHexSpecifier) 
            {
                nDigits++;
                hexDigit = s->get_Chars(pos++);
                if(Char::IsDigit(hexDigit)) 
                {
                    digitValue = (int32_t)(((int32_t)(hexDigit) - 48));
                }
                 else 
                {
                    if(Char::IsLower(hexDigit)) 
                    {
                        digitValue = (int32_t)((((int32_t)(hexDigit) - 97) + 10));
                    }
                     else 
                    {
                        digitValue = (int32_t)((((int32_t)(hexDigit) - 65) + 10));
                    }
                }
                uint32_t unumber = (uint32_t)number;
                if(tryParse) 
                {
                    if(((unumber & 4026531840U) != 0U)) 
                    {
                        return false;
                    }
                    number = (int32_t)((unumber * 16U) + (uint32_t)digitValue);
                }
                 else 
                {
                    number = (int32_t)cli::checked(((unumber * 16U) + (uint32_t)digitValue));
                }
            }
             else 
            {
                if(decimalPointFound) 
                {
                    nDigits++;
                    if(((int32_t)(s->get_Chars(pos++)) != 48)) 
                    {
                        if(!(tryParse)) 
                        {
                            exc = cli::gcnew<OverflowException>(_T("Value too large or too small."));
                        }
                        return false;
                    }
                }
                 else 
                {
                    nDigits++;
                    try {
                        number = cli::checked(((number * 10) - (int32_t)(((int32_t)(s->get_Chars(pos++)) - 48))));
                    }
                    catch(OverflowException*) {
                        if(!(tryParse)) 
                        {
                            exc = cli::gcnew<OverflowException>(_T("Value too large or too small."));
                        }
                        return false;
                    }
                }
            }
        }
        while((pos < s->get_Length()));
        if((nDigits ==  0)) 
        {
            if(!(tryParse)) 
            {
                exc = GetFormatException();
            }
            return false;
        }
        if(AllowExponent) 
        {
            if((FindExponent(pos, s, exponent, tryParse, exc) && (exc != nullptr))) 
            {
                return false;
            }
        }
        if((AllowTrailingSign && !(foundSign))) 
        {
            FindSign(pos, s, nfi, foundSign, negative);
            if((foundSign && (pos < s->get_Length()))) 
            {
                if((AllowTrailingWhite && !(JumpOverWhite(pos, s, true, tryParse, exc)))) 
                {
                    return false;
                }
            }
        }
        if((AllowCurrencySymbol && !(foundCurrency))) 
        {
            if(((AllowTrailingWhite && (pos < s->get_Length())) && !(JumpOverWhite(pos, s, false, tryParse, exc)))) 
            {
                return false;
            }
            FindCurrency(pos, s, nfi, foundCurrency);
            if((foundCurrency && (pos < s->get_Length()))) 
            {
                if((AllowTrailingWhite && !(JumpOverWhite(pos, s, true, tryParse, exc)))) 
                {
                    return false;
                }
                if((!(foundSign) && AllowTrailingSign)) 
                {
                    FindSign(pos, s, nfi, foundSign, negative);
                }
            }
        }
        if(((AllowTrailingWhite && (pos < s->get_Length())) && !(JumpOverWhite(pos, s, false, tryParse, exc)))) 
        {
            return false;
        }
        if(foundOpenParentheses) 
        {
            if(((pos >= s->get_Length()) || ((int32_t)(s->get_Chars(pos++)) != 41))) 
            {
                if(!(tryParse)) 
                {
                    exc = GetFormatException();
                }
                return false;
            }
            if(((AllowTrailingWhite && (pos < s->get_Length())) && !(JumpOverWhite(pos, s, false, tryParse, exc)))) 
            {
                return false;
            }
        }
        if(((pos < s->get_Length()) && ((int32_t)(s->get_Chars(pos)) != 0))) 
        {
            if(!(tryParse)) 
            {
                exc = GetFormatException();
            }
            return false;
        }
        if((!(negative) && !(AllowHexSpecifier))) 
        {
            if(tryParse) 
            {
                int64_t lval = -((int64_t)(number));
                if(((lval < -2147483648L) || (lval > 2147483647L))) 
                {
                    return false;
                }
                number = (int32_t)lval;
            }
             else 
            {
                number = cli::checked(-(number));
            }
        }
        if((exponent > 0)) 
        {
            double res = cli::checked((Math::Pow(10., (double)(exponent)) * (double)(number)));
            if(((res < std::numeric_limits<double>::epsilon()) || (res > 2147483647.))) 
            {
                if(!(tryParse)) 
                {
                    exc = cli::gcnew<OverflowException>(_T("Value too large or too small."));
                }
                return false;
            }
            number = (int32_t)res;
        }
        result = number;
        return true;
    }
    
    int32_t Int32::Parse5(String* s) {
        Exception *exc;
        int32_t res;
        if(!(Parse(s, false, res, exc))) 
        {
            throw exc;
        }
        return res;
    }
    
    int32_t Int32::Parse6(String* s, Globalization::NumberStyles style, IFormatProvider* provider) {
        Exception *exc;
        int32_t res;
        if(!(Parse4(s, style, provider, false, res, exc))) 
        {
            throw exc;
        }
        return res;
    }
    
    bool Int32::TryParse(String* s, int32_t result) {
        Exception *exc;
        if(!(Parse(s, true, result, exc))) 
        {
            result = 0;
            return false;
        }
        return true;
    }
    
    bool Int32::TryParse2(String* s, Globalization::NumberStyles style, IFormatProvider* provider, int32_t result) {
        Exception *exc;
        if(!(Parse4(s, style, provider, true, result, exc))) 
        {
            result = 0;
            return false;
        }
        return true;
    }
    
    String* Int32::ToString_1636a0751cb9ac11() {
        return NumberFormatter::NumberToString13(cli::import((*this))->m_value, nullptr);
    }
    
    String* Int32::ToString3(IFormatProvider* provider) {
        return NumberFormatter::NumberToString13(cli::import((*this))->m_value, provider);
    }
    
    String* Int32::ToString4(String* format) {
        return ToString5(format, nullptr);
    }
    
    String* Int32::ToString5(String* format, IFormatProvider* provider) {
        return NumberFormatter::NumberToString6(format, cli::import((*this))->m_value, provider);
    }
    
    TypeCode Int32::GetTypeCode() {
        return TypeCode::Int322;
    }
    
    bool Int32::ToBoolean(IFormatProvider* provider) {
        return Convert::ToBoolean8(cli::import((*this))->m_value);
    }
    
    unsigned char Int32::ToByte(IFormatProvider* provider) {
        return Convert::ToByte8(cli::import((*this))->m_value);
    }
    
    char16_t Int32::ToChar(IFormatProvider* provider) {
        return Convert::ToChar7(cli::import((*this))->m_value);
    }
    
    DateTime Int32::ToDateTime(IFormatProvider* provider) {
        return Convert::ToDateTime10(cli::import((*this))->m_value);
    }
    
    Decimal Int32::ToDecimal(IFormatProvider* provider) {
        return Convert::ToDecimal8(cli::import((*this))->m_value);
    }
    
    double Int32::ToDouble(IFormatProvider* provider) {
        return Convert::ToDouble8(cli::import((*this))->m_value);
    }
    
    int16_t Int32::ToInt16(IFormatProvider* provider) {
        return Convert::ToInt168(cli::import((*this))->m_value);
    }
    
    int32_t Int32::ToInt32(IFormatProvider* provider) {
        return cli::import((*this))->m_value;
    }
    
    int64_t Int32::ToInt64(IFormatProvider* provider) {
        return Convert::ToInt648(cli::import((*this))->m_value);
    }
    
    signed char Int32::ToSByte(IFormatProvider* provider) {
        return Convert::ToSByte8(cli::import((*this))->m_value);
    }
    
    float Int32::ToSingle(IFormatProvider* provider) {
        return Convert::ToSingle8(cli::import((*this))->m_value);
    }
    
    Object* Int32::ToType(Type* targetType, IFormatProvider* provider) {
        if(Type::op_Equality2(targetType, nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("targetType"));
        }
        return Convert::ToType(cli::box(cli::import((*this))->m_value), targetType, provider, false);
    }
    
    uint16_t Int32::ToUInt16(IFormatProvider* provider) {
        return Convert::ToUInt168(cli::import((*this))->m_value);
    }
    
    uint32_t Int32::ToUInt32(IFormatProvider* provider) {
        return Convert::ToUInt328(cli::import((*this))->m_value);
    }
    
    uint64_t Int32::ToUInt64(IFormatProvider* provider) {
        return Convert::ToUInt648(cli::import((*this))->m_value);
    }
    
}
namespace System {
    
    
    int32_t Int64::CompareTo(Object* value) {
        if((value ==  nullptr)) 
        {
            return 1;
        }
        if(!(cli::is<Int64>(value))) 
        {
            throw cli::gcnew<ArgumentException>(Locale::GetText(_T("Value is not a System.Int64")));
        }
        int64_t lValue = cli::unbox<int64_t>(value);
        if((cli::import((*this))->m_value ==  lValue)) 
        {
            return 0;
        }
        return (cli::import((*this))->m_value < lValue) ? -1 : 1;
    }
    
    bool Int64::Equals_ed975d2f4a7d193e(Object* obj) {
        if(!(cli::is<Int64>(obj))) 
        {
            return false;
        }
        return (cli::unbox<int64_t>(obj) ==  cli::import((*this))->m_value);
    }
    
    int32_t Int64::GetHashCode_6648aef0f235ee6c() {
        return ((int32_t)(cli::import((*this))->m_value & 4294967295L) ^ (int32_t)(cli::import((*this))->m_value >> 32));
    }
    
    int32_t Int64::CompareTo2(int64_t value) {
        if((cli::import((*this))->m_value ==  value)) 
        {
            return 0;
        }
        if((cli::import((*this))->m_value > value)) 
        {
            return 1;
        }
         else 
        {
            return -1;
        }
    }
    
    bool Int64::Equals2(int64_t obj) {
        return (obj ==  cli::import((*this))->m_value);
    }
    
    bool Int64::Parse(String* s, bool tryParse, int64_t result, Exception* exc) {
        int64_t val = 0L;
        int32_t len;
        int32_t i, sign = 1;
        bool digits_seen = false;
        result = 0L;
        exc = nullptr;
        Globalization::NumberFormatInfo *nfi = Threading::Thread::get_CurrentThread()->get_CurrentCulture()->get_NumberFormat_56b6d54c07628932();
        if((s ==  nullptr)) 
        {
            if(!(tryParse)) 
            {
                exc = cli::gcnew<ArgumentNullException>(_T("s"));
            }
            return false;
        }
        len = s->get_Length();
        char16_t c;
        for(i = 0; (i < len); i++){
            c = s->get_Chars(i);
            if(!(Char::IsWhiteSpace(c))) 
            {
                break;
            }
        }
        if((i ==  len)) 
        {
            if(!(tryParse)) 
            {
                exc = Int32::GetFormatException();
            }
            return false;
        }
        if((String::Compare4(s, i, nfi->get_PositiveSign(), 0, nfi->get_PositiveSign()->get_Length()) ==  0)) 
        {
            (i = i + nfi->get_PositiveSign()->get_Length());
        }
         else 
        {
            if((String::Compare4(s, i, nfi->get_NegativeSign(), 0, nfi->get_NegativeSign()->get_Length()) ==  0)) 
            {
                sign = -1;
                (i = i + nfi->get_NegativeSign()->get_Length());
            }
        }
        for(; (i < len); i++){
            c = s->get_Chars(i);
            if((((int32_t)(c) >= 48) && ((int32_t)(c) <= 57))) 
            {
                unsigned char d = (unsigned char)((int32_t)(c) - 48);
                if((val > 922337203685477580L)) 
                {
                    goto overflow;
                }
                if((val ==  922337203685477580L)) 
                {
                    if((((int64_t)(d) > 7L) && ((sign ==  1) || ((int64_t)(d) > 8L)))) 
                    {
                        goto overflow;
                    }
                    if((sign ==  -1)) 
                    {
                        val = (((val * (int64_t)(sign)) * 10L) - (int64_t)(d));
                    }
                     else 
                    {
                        val = ((val * 10L) + (int64_t)(d));
                    }
                    if(Int32::ProcessTrailingWhitespace(tryParse, s, (i + 1), exc)) 
                    {
                        result = val;
                        return true;
                    }
                    goto overflow;
                }
                 else 
                {
                    val = ((val * 10L) + (int64_t)(d));
                }
                digits_seen = true;
            }
             else 
            {
                if(!(Int32::ProcessTrailingWhitespace(tryParse, s, i, exc))) 
                {
                    return false;
                }
            }
        }
        if(!(digits_seen)) 
        {
            if(!(tryParse)) 
            {
                exc = Int32::GetFormatException();
            }
            return false;
        }
        if((sign ==  -1)) 
        {
            result = (val * (int64_t)(sign));
        }
         else 
        {
            result = val;
        }
        return true;
        overflow:
        if(!(tryParse)) 
        {
            exc = cli::gcnew<OverflowException>(_T("Value is too large"));
        }
        return false;
    }
    
    int64_t Int64::Parse2(String* s, IFormatProvider* provider) {
        return Parse6(s, Globalization::NumberStyles::Integer, provider);
    }
    
    int64_t Int64::Parse3(String* s, Globalization::NumberStyles style) {
        return Parse6(s, style, nullptr);
    }
    
    bool Int64::Parse4(String* s, Globalization::NumberStyles style, IFormatProvider* fp, bool tryParse, int64_t result, Exception* exc) {
        result = 0L;
        exc = nullptr;
        if((s ==  nullptr)) 
        {
            if(!(tryParse)) 
            {
                exc = cli::gcnew<ArgumentNullException>(_T("s"));
            }
            return false;
        }
        if((s->get_Length() ==  0)) 
        {
            if(!(tryParse)) 
            {
                exc = Int32::GetFormatException();
            }
            return false;
        }
        Globalization::NumberFormatInfo *nfi = nullptr;
        if((fp != nullptr)) 
        {
            Type *typeNFI = cli::typeof<Type>::info;
            nfi = cli::cast<Globalization::NumberFormatInfo*>(fp->GetFormat_b67414a65453cc7e(typeNFI));
        }
        if((nfi ==  nullptr)) 
        {
            nfi = Threading::Thread::get_CurrentThread()->get_CurrentCulture()->get_NumberFormat_56b6d54c07628932();
        }
        if(!(Int32::CheckStyle(style, tryParse, exc))) 
        {
            return false;
        }
        bool AllowCurrencySymbol = ((int32_t)(((int32_t)(style) & 256)) != 0);
        bool AllowHexSpecifier = ((int32_t)(((int32_t)(style) & 512)) != 0);
        bool AllowThousands = ((int32_t)(((int32_t)(style) & 64)) != 0);
        bool AllowDecimalPoint = ((int32_t)(((int32_t)(style) & 32)) != 0);
        bool AllowParentheses = ((int32_t)(((int32_t)(style) & 16)) != 0);
        bool AllowTrailingSign = ((int32_t)(((int32_t)(style) & 8)) != 0);
        bool AllowLeadingSign = ((int32_t)(((int32_t)(style) & 4)) != 0);
        bool AllowTrailingWhite = ((int32_t)(((int32_t)(style) & 2)) != 0);
        bool AllowLeadingWhite = ((int32_t)(((int32_t)(style) & 1)) != 0);
        bool AllowExponent = ((int32_t)(((int32_t)(style) & 128)) != 0);
        int32_t pos = 0;
        if((AllowLeadingWhite && !(Int32::JumpOverWhite(pos, s, true, tryParse, exc)))) 
        {
            return false;
        }
        bool foundOpenParentheses = false;
        bool negative = false;
        bool foundSign = false;
        bool foundCurrency = false;
        if((AllowParentheses && ((int32_t)(s->get_Chars(pos)) ==  40))) 
        {
            foundOpenParentheses = true;
            foundSign = true;
            negative = true;
            pos++;
            if((AllowLeadingWhite && !(Int32::JumpOverWhite(pos, s, true, tryParse, exc)))) 
            {
                return false;
            }
            if(String::op_Equality(s->Substring2(pos, nfi->get_NegativeSign()->get_Length()), nfi->get_NegativeSign())) 
            {
                if(!(tryParse)) 
                {
                    exc = Int32::GetFormatException();
                }
                return false;
            }
            if(String::op_Equality(s->Substring2(pos, nfi->get_PositiveSign()->get_Length()), nfi->get_PositiveSign())) 
            {
                if(!(tryParse)) 
                {
                    exc = Int32::GetFormatException();
                }
                return false;
            }
        }
        if((AllowLeadingSign && !(foundSign))) 
        {
            Int32::FindSign(pos, s, nfi, foundSign, negative);
            if(foundSign) 
            {
                if((AllowLeadingWhite && !(Int32::JumpOverWhite(pos, s, true, tryParse, exc)))) 
                {
                    return false;
                }
                if(AllowCurrencySymbol) 
                {
                    Int32::FindCurrency(pos, s, nfi, foundCurrency);
                    if(((foundCurrency && AllowLeadingWhite) && !(Int32::JumpOverWhite(pos, s, true, tryParse, exc)))) 
                    {
                        return false;
                    }
                }
            }
        }
        if((AllowCurrencySymbol && !(foundCurrency))) 
        {
            Int32::FindCurrency(pos, s, nfi, foundCurrency);
            if(foundCurrency) 
            {
                if((AllowLeadingWhite && !(Int32::JumpOverWhite(pos, s, true, tryParse, exc)))) 
                {
                    return false;
                }
                if(foundCurrency) 
                {
                    if((!(foundSign) && AllowLeadingSign)) 
                    {
                        Int32::FindSign(pos, s, nfi, foundSign, negative);
                        if(((foundSign && AllowLeadingWhite) && !(Int32::JumpOverWhite(pos, s, true, tryParse, exc)))) 
                        {
                            return false;
                        }
                    }
                }
            }
        }
        int64_t number = 0L;
        int32_t nDigits = 0;
        bool decimalPointFound = false;
        int32_t digitValue;
        char16_t hexDigit;
        int32_t exponent = 0;
        do {
            if(!(Int32::ValidDigit(s->get_Chars(pos), AllowHexSpecifier))) 
            {
                if((AllowThousands && (Int32::FindOther(pos, s, nfi->get_NumberGroupSeparator()) || Int32::FindOther(pos, s, nfi->get_CurrencyGroupSeparator())))) 
                {
                    continue;
                }
                 else 
                {
                    if(((!(decimalPointFound) && AllowDecimalPoint) && (Int32::FindOther(pos, s, nfi->get_NumberDecimalSeparator()) || Int32::FindOther(pos, s, nfi->get_CurrencyDecimalSeparator())))) 
                    {
                        decimalPointFound = true;
                        continue;
                    }
                }
                break;
            }
            if(AllowHexSpecifier) 
            {
                nDigits++;
                hexDigit = s->get_Chars(pos++);
                if(Char::IsDigit(hexDigit)) 
                {
                    digitValue = (int32_t)(((int32_t)(hexDigit) - 48));
                }
                 else 
                {
                    if(Char::IsLower(hexDigit)) 
                    {
                        digitValue = (int32_t)((((int32_t)(hexDigit) - 97) + 10));
                    }
                     else 
                    {
                        digitValue = (int32_t)((((int32_t)(hexDigit) - 65) + 10));
                    }
                }
                uint64_t unumber = (uint64_t)number;
                try {
                    number = (int64_t)cli::checked(((unumber * 16UL) + (uint64_t)digitValue));
                }
                catch(OverflowException* e) {
                    if(!(tryParse)) 
                    {
                        exc = e;
                    }
                    return false;
                }
            }
             else 
            {
                if(decimalPointFound) 
                {
                    nDigits++;
                    if(((int32_t)(s->get_Chars(pos++)) != 48)) 
                    {
                        if(!(tryParse)) 
                        {
                            exc = cli::gcnew<OverflowException>(_T("Value too large or too small."));
                        }
                        return false;
                    }
                }
                 else 
                {
                    nDigits++;
                    try {
                        number = cli::checked(((number * 10L) - (int64_t)(((int32_t)(s->get_Chars(pos++)) - 48))));
                    }
                    catch(OverflowException*) {
                        if(!(tryParse)) 
                        {
                            exc = cli::gcnew<OverflowException>(_T("Value too large or too small."));
                        }
                        return false;
                    }
                }
            }
        }
        while((pos < s->get_Length()));
        if((nDigits ==  0)) 
        {
            if(!(tryParse)) 
            {
                exc = Int32::GetFormatException();
            }
            return false;
        }
        if(AllowExponent) 
        {
            if((Int32::FindExponent(pos, s, exponent, tryParse, exc) && (exc != nullptr))) 
            {
                return false;
            }
        }
        if((AllowTrailingSign && !(foundSign))) 
        {
            Int32::FindSign(pos, s, nfi, foundSign, negative);
            if((foundSign && (pos < s->get_Length()))) 
            {
                if((AllowTrailingWhite && !(Int32::JumpOverWhite(pos, s, true, tryParse, exc)))) 
                {
                    return false;
                }
            }
        }
        if((AllowCurrencySymbol && !(foundCurrency))) 
        {
            if(((AllowTrailingWhite && (pos < s->get_Length())) && !(Int32::JumpOverWhite(pos, s, false, tryParse, exc)))) 
            {
                return false;
            }
            Int32::FindCurrency(pos, s, nfi, foundCurrency);
            if((foundCurrency && (pos < s->get_Length()))) 
            {
                if((AllowTrailingWhite && !(Int32::JumpOverWhite(pos, s, true, tryParse, exc)))) 
                {
                    return false;
                }
                if((!(foundSign) && AllowTrailingSign)) 
                {
                    Int32::FindSign(pos, s, nfi, foundSign, negative);
                }
            }
        }
        if(((AllowTrailingWhite && (pos < s->get_Length())) && !(Int32::JumpOverWhite(pos, s, false, tryParse, exc)))) 
        {
            return false;
        }
        if(foundOpenParentheses) 
        {
            if(((pos >= s->get_Length()) || ((int32_t)(s->get_Chars(pos++)) != 41))) 
            {
                if(!(tryParse)) 
                {
                    exc = Int32::GetFormatException();
                }
                return false;
            }
            if(((AllowTrailingWhite && (pos < s->get_Length())) && !(Int32::JumpOverWhite(pos, s, false, tryParse, exc)))) 
            {
                return false;
            }
        }
        if(((pos < s->get_Length()) && ((int32_t)(s->get_Chars(pos)) != 0))) 
        {
            if(!(tryParse)) 
            {
                exc = Int32::GetFormatException();
            }
            return false;
        }
        if((!(negative) && !(AllowHexSpecifier))) 
        {
            try {
                number = cli::checked(-(number));
            }
            catch(OverflowException* e) {
                if(!(tryParse)) 
                {
                    exc = e;
                }
                return false;
            }
        }
        if((exponent > 0)) 
        {
            double res = cli::checked((Math::Pow(10., (double)(exponent)) * (double)(number)));
            if(((res < std::numeric_limits<double>::epsilon()) || (res > 2147483647.))) 
            {
                if(!(tryParse)) 
                {
                    exc = cli::gcnew<OverflowException>(_T("Value too large or too small."));
                }
                return false;
            }
            number = (int64_t)res;
        }
        result = number;
        return true;
    }
    
    int64_t Int64::Parse5(String* s) {
        Exception *exc;
        int64_t res;
        if(!(Parse(s, false, res, exc))) 
        {
            throw exc;
        }
        return res;
    }
    
    int64_t Int64::Parse6(String* s, Globalization::NumberStyles style, IFormatProvider* provider) {
        Exception *exc;
        int64_t res;
        if(!(Parse4(s, style, provider, false, res, exc))) 
        {
            throw exc;
        }
        return res;
    }
    
    bool Int64::TryParse(String* s, int64_t result) {
        Exception *exc;
        if(!(Parse(s, true, result, exc))) 
        {
            result = 0L;
            return false;
        }
        return true;
    }
    
    bool Int64::TryParse2(String* s, Globalization::NumberStyles style, IFormatProvider* provider, int64_t result) {
        Exception *exc;
        if(!(Parse4(s, style, provider, true, result, exc))) 
        {
            result = 0L;
            return false;
        }
        return true;
    }
    
    String* Int64::ToString_1636a0751cb9ac11() {
        return NumberFormatter::NumberToString15(cli::import((*this))->m_value, nullptr);
    }
    
    String* Int64::ToString3(IFormatProvider* provider) {
        return NumberFormatter::NumberToString15(cli::import((*this))->m_value, provider);
    }
    
    String* Int64::ToString4(String* format) {
        return ToString5(format, nullptr);
    }
    
    String* Int64::ToString5(String* format, IFormatProvider* provider) {
        return NumberFormatter::NumberToString8(format, cli::import((*this))->m_value, provider);
    }
    
    TypeCode Int64::GetTypeCode() {
        return TypeCode::Int642;
    }
    
    bool Int64::ToBoolean(IFormatProvider* provider) {
        return Convert::ToBoolean9(cli::import((*this))->m_value);
    }
    
    unsigned char Int64::ToByte(IFormatProvider* provider) {
        return Convert::ToByte9(cli::import((*this))->m_value);
    }
    
    char16_t Int64::ToChar(IFormatProvider* provider) {
        return Convert::ToChar8(cli::import((*this))->m_value);
    }
    
    DateTime Int64::ToDateTime(IFormatProvider* provider) {
        return Convert::ToDateTime11(cli::import((*this))->m_value);
    }
    
    Decimal Int64::ToDecimal(IFormatProvider* provider) {
        return Convert::ToDecimal9(cli::import((*this))->m_value);
    }
    
    double Int64::ToDouble(IFormatProvider* provider) {
        return Convert::ToDouble9(cli::import((*this))->m_value);
    }
    
    int16_t Int64::ToInt16(IFormatProvider* provider) {
        return Convert::ToInt169(cli::import((*this))->m_value);
    }
    
    int32_t Int64::ToInt32(IFormatProvider* provider) {
        return Convert::ToInt329(cli::import((*this))->m_value);
    }
    
    int64_t Int64::ToInt64(IFormatProvider* provider) {
        return cli::import((*this))->m_value;
    }
    
    signed char Int64::ToSByte(IFormatProvider* provider) {
        return Convert::ToSByte9(cli::import((*this))->m_value);
    }
    
    float Int64::ToSingle(IFormatProvider* provider) {
        return Convert::ToSingle9(cli::import((*this))->m_value);
    }
    
    Object* Int64::ToType(Type* targetType, IFormatProvider* provider) {
        if(Type::op_Equality2(targetType, nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("targetType"));
        }
        return Convert::ToType(cli::box(cli::import((*this))->m_value), targetType, provider, false);
    }
    
    uint16_t Int64::ToUInt16(IFormatProvider* provider) {
        return Convert::ToUInt169(cli::import((*this))->m_value);
    }
    
    uint32_t Int64::ToUInt32(IFormatProvider* provider) {
        return Convert::ToUInt329(cli::import((*this))->m_value);
    }
    
    uint64_t Int64::ToUInt64(IFormatProvider* provider) {
        return Convert::ToUInt649(cli::import((*this))->m_value);
    }
    
}
namespace System {
    
    void**  ::System::IntPtr::Zero;
    
    void IntPtr::constructor(int32_t value) {
        cli::import((*this))->m_value = (void*)(value);
    }
    
    void IntPtr::constructor(int64_t value) {
        cli::import((*this))->m_value = (void*)value;
    }
    
    void IntPtr::constructor(void* value) {
        cli::import((*this))->m_value = value;
    }
    
    void IntPtr::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        int64_t savedValue = info->GetInt64(_T("value"));
        cli::import((*this))->m_value = (void*)savedValue;
    }
    
    void IntPtr::GetObjectData(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        if((info ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("info"));
        }
        info->AddValue14(_T("value"), ToInt64());
    }
    
    bool IntPtr::Equals_ed975d2f4a7d193e(Object* obj) {
        if(!(cli::is<::System::IntPtr>(obj))) 
        {
            return false;
        }
        return (cli::import(cli::unbox<void*>(obj))->m_value ==  cli::import((*this))->m_value);
    }
    
    int32_t IntPtr::GetHashCode_6648aef0f235ee6c() {
        return (int32_t)(cli::import((*this))->m_value);
    }
    
    int32_t IntPtr::ToInt32() {
        return (int32_t)(cli::import((*this))->m_value);
    }
    
    int64_t IntPtr::ToInt64() {
        if((::System::IntPtr::get_Size() ==  4)) 
        {
            return (int64_t)((int32_t)(cli::import((*this))->m_value));
        }
         else 
        {
            return (int64_t)cli::import((*this))->m_value;
        }
    }
    
    void* IntPtr::ToPointer() {
        return cli::import((*this))->m_value;
    }
    
    String* IntPtr::ToString_1636a0751cb9ac11() {
        return ToString3(nullptr);
    }
    
    String* IntPtr::ToString3(String* format) {
        if((::System::IntPtr::get_Size() ==  4)) 
        {
            return cli::import((int32_t)(cli::import((*this))->m_value))->ToString4(format);
        }
         else 
        {
            return cli::import((int64_t)cli::import((*this))->m_value)->ToString4(format);
        }
    }
    
    void* IntPtr::Add(void* pointer, int32_t offset) {
        return (void*)(void*)(cli::unchecked(((unsigned char*)((void*)pointer) + (int32_t)(offset))));
    }
    
    void* IntPtr::Subtract(void* pointer, int32_t offset) {
        return (void*)(void*)(cli::unchecked(((unsigned char*)((void*)pointer) - (int32_t)(offset))));
    }
    
    bool IntPtr::op_Equality(void* value1, void* value2) {
        return (cli::import(value1)->m_value ==  cli::import(value2)->m_value);
    }
    
    bool IntPtr::op_Inequality(void* value1, void* value2) {
        return (cli::import(value1)->m_value != cli::import(value2)->m_value);
    }
    
    void* IntPtr::op_Explicit(int32_t value) {
        return cli::ctor<::System::IntPtr>(value);
    }
    
    void* IntPtr::op_Explicit2(int64_t value) {
        return cli::ctor<::System::IntPtr>(value);
    }
    
    void* IntPtr::op_Explicit3(void* value) {
        return cli::ctor<::System::IntPtr>(value);
    }
    
    int32_t IntPtr::op_Explicit4(void* value) {
        return (int32_t)(cli::import(value)->m_value);
    }
    
    int64_t IntPtr::op_Explicit5(void* value) {
        return cli::import(value)->ToInt64();
    }
    
    void* IntPtr::op_Explicit6(void* value) {
        return cli::import(value)->m_value;
    }
    
    void* IntPtr::op_Addition(void* pointer, int32_t offset) {
        return (void*)(void*)(cli::unchecked(((unsigned char*)((void*)pointer) + (int32_t)(offset))));
    }
    
    void* IntPtr::op_Subtraction(void* pointer, int32_t offset) {
        return (void*)(void*)(cli::unchecked(((unsigned char*)((void*)pointer) - (int32_t)(offset))));
    }
    
    int32_t IntPtr::get_Size() {
        return sizeof(::System::IntPtr);
    }
    
}
namespace System {
    
    ModuleHandle*  ModuleHandle::EmptyHandle;
    
    void ModuleHandle::constructor(void* v) {
        (*this)->value = v;
    }
    
    void ModuleHandle::static_constructor() {
    }
    
    void ModuleHandle::GetPEKind(Reflection::PortableExecutableKinds peKind, Reflection::ImageFileMachine machine) {
        if(::System::IntPtr::op_Equality((*this)->value, (*::System::IntPtr::Zero))) 
        {
            throw cli::gcnew<ArgumentNullException>(String::Empty, _T("Invalid handle"));
        }
        Reflection::Module::GetPEKind((*this)->value, peKind, machine);
    }
    
    RuntimeFieldHandle ModuleHandle::ResolveFieldHandle(int32_t fieldToken) {
        return ResolveFieldHandle2(fieldToken, nullptr, nullptr);
    }
    
    RuntimeMethodHandle ModuleHandle::ResolveMethodHandle(int32_t methodToken) {
        return ResolveMethodHandle2(methodToken, nullptr, nullptr);
    }
    
    RuntimeTypeHandle ModuleHandle::ResolveTypeHandle(int32_t typeToken) {
        return ResolveTypeHandle2(typeToken, nullptr, nullptr);
    }
    
    cli::array<void*>* ModuleHandle::ptrs_from_handles(cli::array<RuntimeTypeHandle>* handles) {
        if((handles ==  nullptr)) 
        {
            return nullptr;
        }
         else 
        {
            cli::array<void*> *res = (new cli::array<void*>(handles->get_Length()));
            for(int32_t i = 0; (i < handles->get_Length()); ++i) {
                res->at(i) = handles->at(i)->get_Value();
            }
            return res;
        }
    }
    
    RuntimeTypeHandle ModuleHandle::ResolveTypeHandle2(int32_t typeToken, cli::array<RuntimeTypeHandle>* typeInstantiationContext, cli::array<RuntimeTypeHandle>* methodInstantiationContext) {
        Reflection::ResolveTokenError error;
        if(::System::IntPtr::op_Equality((*this)->value, (*::System::IntPtr::Zero))) 
        {
            throw cli::gcnew<ArgumentNullException>(String::Empty, _T("Invalid handle"));
        }
        void *res = Reflection::Module::ResolveTypeToken((*this)->value, typeToken, ptrs_from_handles(typeInstantiationContext), ptrs_from_handles(methodInstantiationContext), error);
        if(::System::IntPtr::op_Equality(res, (*::System::IntPtr::Zero))) 
        {
            throw cli::gcnew<TypeLoadException>(String::Format3(_T("Could not load type \'0x{0:x}\' from assembly \'0x{1:x}\'"), cli::box(typeToken), cli::box(cli::import((*this)->value)->ToInt64())));
        }
         else 
        {
            return cli::ctor<RuntimeTypeHandle>(res);
        }
    }
    
    RuntimeMethodHandle ModuleHandle::ResolveMethodHandle2(int32_t methodToken, cli::array<RuntimeTypeHandle>* typeInstantiationContext, cli::array<RuntimeTypeHandle>* methodInstantiationContext) {
        Reflection::ResolveTokenError error;
        if(::System::IntPtr::op_Equality((*this)->value, (*::System::IntPtr::Zero))) 
        {
            throw cli::gcnew<ArgumentNullException>(String::Empty, _T("Invalid handle"));
        }
        void *res = Reflection::Module::ResolveMethodToken((*this)->value, methodToken, ptrs_from_handles(typeInstantiationContext), ptrs_from_handles(methodInstantiationContext), error);
        if(::System::IntPtr::op_Equality(res, (*::System::IntPtr::Zero))) 
        {
            throw cli::gcnew<Exception>(String::Format3(_T("Could not load method \'0x{0:x}\' from assembly \'0x{1:x}\'"), cli::box(methodToken), cli::box(cli::import((*this)->value)->ToInt64())));
        }
         else 
        {
            return cli::ctor<RuntimeMethodHandle>(res);
        }
    }
    
    RuntimeFieldHandle ModuleHandle::ResolveFieldHandle2(int32_t fieldToken, cli::array<RuntimeTypeHandle>* typeInstantiationContext, cli::array<RuntimeTypeHandle>* methodInstantiationContext) {
        Reflection::ResolveTokenError error;
        if(::System::IntPtr::op_Equality((*this)->value, (*::System::IntPtr::Zero))) 
        {
            throw cli::gcnew<ArgumentNullException>(String::Empty, _T("Invalid handle"));
        }
        void *res = Reflection::Module::ResolveFieldToken((*this)->value, fieldToken, ptrs_from_handles(typeInstantiationContext), ptrs_from_handles(methodInstantiationContext), error);
        if(::System::IntPtr::op_Equality(res, (*::System::IntPtr::Zero))) 
        {
            throw cli::gcnew<Exception>(String::Format3(_T("Could not load field \'0x{0:x}\' from assembly \'0x{1:x}\'"), cli::box(fieldToken), cli::box(cli::import((*this)->value)->ToInt64())));
        }
         else 
        {
            return cli::ctor<RuntimeFieldHandle>(res);
        }
    }
    
    RuntimeFieldHandle ModuleHandle::GetRuntimeFieldHandleFromMetadataToken(int32_t fieldToken) {
        return ResolveFieldHandle(fieldToken);
    }
    
    RuntimeMethodHandle ModuleHandle::GetRuntimeMethodHandleFromMetadataToken(int32_t methodToken) {
        return ResolveMethodHandle(methodToken);
    }
    
    RuntimeTypeHandle ModuleHandle::GetRuntimeTypeHandleFromMetadataToken(int32_t typeToken) {
        return ResolveTypeHandle(typeToken);
    }
    
    bool ModuleHandle::Equals_ed975d2f4a7d193e(Object* obj) {
        if(((obj ==  nullptr) || Type::op_Inequality2(Object::GetType(), obj->GetType()))) 
        {
            return false;
        }
        return ::System::IntPtr::op_Equality((*this)->value, cli::unbox<ModuleHandle>(obj)->get_Value());
    }
    
    bool ModuleHandle::Equals2(ModuleHandle handle) {
        return ::System::IntPtr::op_Equality((*this)->value, handle->get_Value());
    }
    
    int32_t ModuleHandle::GetHashCode_6648aef0f235ee6c() {
        return cli::import((*this)->value)->GetHashCode_6648aef0f235ee6c();
    }
    
    bool ModuleHandle::op_Equality(ModuleHandle left, ModuleHandle right) {
        return Object::Equals2(cli::box(left), cli::box(right));
    }
    
    bool ModuleHandle::op_Inequality(ModuleHandle left, ModuleHandle right) {
        return !(Object::Equals2(cli::box(left), cli::box(right)));
    }
    
    void* ModuleHandle::get_Value() {
        return (*this)->value;
    }
    
    int32_t ModuleHandle::get_MDStreamVersion() {
        if(::System::IntPtr::op_Equality((*this)->value, (*::System::IntPtr::Zero))) 
        {
            throw cli::gcnew<ArgumentNullException>(String::Empty, _T("Invalid handle"));
        }
        return Reflection::Module::GetMDStreamVersion((*this)->value);
    }
    
}
namespace System {
    
    
}
namespace System {
    
    
}
namespace System {
    
    
    void RuntimeFieldHandle::constructor(void* v) {
        (*this)->value = v;
    }
    
    void RuntimeFieldHandle::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        if((info ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("info"));
        }
        Reflection::MonoField *mf = cli::cast<Reflection::MonoField*>(info->GetValue(_T("FieldObj"), cli::typeof<Type>::info));
        (*this)->value = mf->get_FieldHandle_43fbd13b33ef15a8()->get_Value();
        if(::System::IntPtr::op_Equality((*this)->value, (*::System::IntPtr::Zero))) 
        {
            throw cli::gcnew<Runtime::Serialization::SerializationException>(Locale::GetText(_T("Insufficient state.")));
        }
    }
    
    void RuntimeFieldHandle::GetObjectData(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        if((info ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("info"));
        }
        if(::System::IntPtr::op_Equality((*this)->value, (*::System::IntPtr::Zero))) 
        {
            throw cli::gcnew<Runtime::Serialization::SerializationException>(_T("Object fields may not be properly initialized"));
        }
        info->AddValue(_T("FieldObj"), cli::cast<Reflection::MonoField*>(Reflection::FieldInfo::GetFieldFromHandle((*this))), cli::typeof<Type>::info);
    }
    
    bool RuntimeFieldHandle::Equals_ed975d2f4a7d193e(Object* obj) {
        if(((obj ==  nullptr) || Type::op_Inequality2(Object::GetType(), obj->GetType()))) 
        {
            return false;
        }
        return ::System::IntPtr::op_Equality((*this)->value, cli::unbox<RuntimeFieldHandle>(obj)->get_Value());
    }
    
    bool RuntimeFieldHandle::Equals2(RuntimeFieldHandle handle) {
        return ::System::IntPtr::op_Equality((*this)->value, handle->get_Value());
    }
    
    int32_t RuntimeFieldHandle::GetHashCode_6648aef0f235ee6c() {
        return cli::import((*this)->value)->GetHashCode_6648aef0f235ee6c();
    }
    
    bool RuntimeFieldHandle::op_Equality(RuntimeFieldHandle left, RuntimeFieldHandle right) {
        return left->Equals2(right);
    }
    
    bool RuntimeFieldHandle::op_Inequality(RuntimeFieldHandle left, RuntimeFieldHandle right) {
        return !(left->Equals2(right));
    }
    
    void* RuntimeFieldHandle::get_Value() {
        return (*this)->value;
    }
    
}
namespace System {
    
    
    void RuntimeMethodHandle::constructor(void* v) {
        (*this)->value = v;
    }
    
    void RuntimeMethodHandle::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        if((info ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("info"));
        }
        Reflection::MonoMethod *mm = cli::cast<Reflection::MonoMethod*>(info->GetValue(_T("MethodObj"), cli::typeof<Type>::info));
        (*this)->value = mm->get_MethodHandle_a92ba3e25e0a5ec8()->get_Value();
        if(::System::IntPtr::op_Equality((*this)->value, (*::System::IntPtr::Zero))) 
        {
            throw cli::gcnew<Runtime::Serialization::SerializationException>(Locale::GetText(_T("Insufficient state.")));
        }
    }
    
    void RuntimeMethodHandle::GetObjectData(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        if((info ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("info"));
        }
        if(::System::IntPtr::op_Equality((*this)->value, (*::System::IntPtr::Zero))) 
        {
            throw cli::gcnew<Runtime::Serialization::SerializationException>(_T("Object fields may not be properly initialized"));
        }
        info->AddValue(_T("MethodObj"), cli::cast<Reflection::MonoMethod*>(Reflection::MethodBase::GetMethodFromHandle((*this))), cli::typeof<Type>::info);
    }
    
    void* RuntimeMethodHandle::GetFunctionPointer(void* m) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void* RuntimeMethodHandle::GetFunctionPointer2() {
        return GetFunctionPointer((*this)->value);
    }
    
    bool RuntimeMethodHandle::Equals_ed975d2f4a7d193e(Object* obj) {
        if(((obj ==  nullptr) || Type::op_Inequality2(Object::GetType(), obj->GetType()))) 
        {
            return false;
        }
        return ::System::IntPtr::op_Equality((*this)->value, cli::unbox<RuntimeMethodHandle>(obj)->get_Value());
    }
    
    bool RuntimeMethodHandle::Equals2(RuntimeMethodHandle handle) {
        return ::System::IntPtr::op_Equality((*this)->value, handle->get_Value());
    }
    
    int32_t RuntimeMethodHandle::GetHashCode_6648aef0f235ee6c() {
        return cli::import((*this)->value)->GetHashCode_6648aef0f235ee6c();
    }
    
    bool RuntimeMethodHandle::op_Equality(RuntimeMethodHandle left, RuntimeMethodHandle right) {
        return left->Equals2(right);
    }
    
    bool RuntimeMethodHandle::op_Inequality(RuntimeMethodHandle left, RuntimeMethodHandle right) {
        return !(left->Equals2(right));
    }
    
    void* RuntimeMethodHandle::get_Value() {
        return (*this)->value;
    }
    
}
namespace System {
    
    
    void RuntimeTypeHandle::constructor(void* val) {
        (*this)->value = val;
    }
    
    void RuntimeTypeHandle::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        if((info ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("info"));
        }
        MonoType *mt = cli::cast<MonoType*>(info->GetValue(_T("TypeObj"), cli::typeof<Type>::info));
        (*this)->value = mt->get_TypeHandle_a14995fa9102936b()->get_Value();
        if(::System::IntPtr::op_Equality((*this)->value, (*::System::IntPtr::Zero))) 
        {
            throw cli::gcnew<Runtime::Serialization::SerializationException>(Locale::GetText(_T("Insufficient state.")));
        }
    }
    
    void RuntimeTypeHandle::GetObjectData(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        if((info ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("info"));
        }
        if(::System::IntPtr::op_Equality((*this)->value, (*::System::IntPtr::Zero))) 
        {
            throw cli::gcnew<Runtime::Serialization::SerializationException>(_T("Object fields may not be properly initialized"));
        }
        info->AddValue(_T("TypeObj"), cli::box(Type::GetTypeHandle(cli::box((*this)))), cli::typeof<Type>::info);
    }
    
    bool RuntimeTypeHandle::Equals_ed975d2f4a7d193e(Object* obj) {
        if(((obj ==  nullptr) || Type::op_Inequality2(Object::GetType(), obj->GetType()))) 
        {
            return false;
        }
        return ::System::IntPtr::op_Equality((*this)->value, cli::unbox<RuntimeTypeHandle>(obj)->get_Value());
    }
    
    bool RuntimeTypeHandle::Equals2(RuntimeTypeHandle handle) {
        return ::System::IntPtr::op_Equality((*this)->value, handle->get_Value());
    }
    
    int32_t RuntimeTypeHandle::GetHashCode_6648aef0f235ee6c() {
        return cli::import((*this)->value)->GetHashCode_6648aef0f235ee6c();
    }
    
    ModuleHandle RuntimeTypeHandle::GetModuleHandle() {
        if(::System::IntPtr::op_Equality((*this)->value, (*::System::IntPtr::Zero))) 
        {
            throw cli::gcnew<InvalidOperationException>(_T("Object fields may not be properly initialized"));
        }
        return Type::GetTypeFromHandle((*this))->get_Module_ea7d65dc88202263()->get_ModuleHandle();
    }
    
    bool RuntimeTypeHandle::op_Equality(RuntimeTypeHandle left, Object* right) {
        return (((right != nullptr) && cli::is<RuntimeTypeHandle>(right)) && left->Equals2(cli::unbox<RuntimeTypeHandle>(right)));
    }
    
    bool RuntimeTypeHandle::op_Inequality(RuntimeTypeHandle left, Object* right) {
        return (((right ==  nullptr) || !(cli::is<RuntimeTypeHandle>(right))) || !(left->Equals2(cli::unbox<RuntimeTypeHandle>(right))));
    }
    
    bool RuntimeTypeHandle::op_Equality2(Object* left, RuntimeTypeHandle right) {
        return (((left != nullptr) && cli::is<RuntimeTypeHandle>(left)) && cli::unbox<RuntimeTypeHandle>(left)->Equals2(right));
    }
    
    bool RuntimeTypeHandle::op_Inequality2(Object* left, RuntimeTypeHandle right) {
        return (((left ==  nullptr) || !(cli::is<RuntimeTypeHandle>(left))) || !(cli::unbox<RuntimeTypeHandle>(left)->Equals2(right)));
    }
    
    void* RuntimeTypeHandle::get_Value() {
        return (*this)->value;
    }
    
}
namespace System {
    
    
    int32_t SByte::CompareTo(Object* obj) {
        if((obj ==  nullptr)) 
        {
            return 1;
        }
        if(!(cli::is<SByte>(obj))) 
        {
            throw cli::gcnew<ArgumentException>(Locale::GetText(_T("Value is not a System.SByte.")));
        }
        signed char xv = cli::unbox<signed char>(obj);
        if(((int32_t)(cli::import((*this))->m_value) ==  (int32_t)(xv))) 
        {
            return 0;
        }
        if(((int32_t)(cli::import((*this))->m_value) > (int32_t)(xv))) 
        {
            return 1;
        }
         else 
        {
            return -1;
        }
    }
    
    bool SByte::Equals_ed975d2f4a7d193e(Object* obj) {
        if(!(cli::is<SByte>(obj))) 
        {
            return false;
        }
        return ((int32_t)(cli::unbox<signed char>(obj)) ==  (int32_t)(cli::import((*this))->m_value));
    }
    
    int32_t SByte::GetHashCode_6648aef0f235ee6c() {
        return (int32_t)(cli::import((*this))->m_value);
    }
    
    int32_t SByte::CompareTo2(signed char value) {
        if(((int32_t)(cli::import((*this))->m_value) ==  (int32_t)(value))) 
        {
            return 0;
        }
        if(((int32_t)(cli::import((*this))->m_value) > (int32_t)(value))) 
        {
            return 1;
        }
         else 
        {
            return -1;
        }
    }
    
    bool SByte::Equals2(signed char obj) {
        return ((int32_t)(obj) ==  (int32_t)(cli::import((*this))->m_value));
    }
    
    bool SByte::Parse(String* s, bool tryParse, signed char result, Exception* exc) {
        int32_t ival = 0;
        int32_t len;
        int32_t i;
        bool neg = false;
        bool digits_seen = false;
        result = 0;
        exc = nullptr;
        if((s ==  nullptr)) 
        {
            if(!(tryParse)) 
            {
                exc = cli::gcnew<ArgumentNullException>(_T("s"));
            }
            return false;
        }
        len = s->get_Length();
        char16_t c;
        for(i = 0; (i < len); i++){
            c = s->get_Chars(i);
            if(!(Char::IsWhiteSpace(c))) 
            {
                break;
            }
        }
        if((i ==  len)) 
        {
            if(!(tryParse)) 
            {
                exc = Int32::GetFormatException();
            }
            return false;
        }
        c = s->get_Chars(i);
        if(((int32_t)(c) ==  43)) 
        {
            i++;
        }
         else 
        {
            if(((int32_t)(c) ==  45)) 
            {
                neg = true;
                i++;
            }
        }
        for(; (i < len); i++){
            c = s->get_Chars(i);
            if((((int32_t)(c) >= 48) && ((int32_t)(c) <= 57))) 
            {
                if(tryParse) 
                {
                    int32_t intval = ((ival * 10) - (int32_t)(((int32_t)(c) - 48)));
                    if((intval < -128)) 
                    {
                        return false;
                    }
                    ival = (int32_t)((signed char)intval);
                }
                 else 
                {
                    ival = cli::checked(((ival * 10) - (int32_t)(((int32_t)(c) - 48))));
                }
                digits_seen = true;
            }
             else 
            {
                if(Char::IsWhiteSpace(c)) 
                {
                    for(i++; (i < len); i++){
                        if(!(Char::IsWhiteSpace(s->get_Chars(i)))) 
                        {
                            if(!(tryParse)) 
                            {
                                exc = Int32::GetFormatException();
                            }
                            return false;
                        }
                    }
                    break;
                }
                 else 
                {
                    if(!(tryParse)) 
                    {
                        exc = Int32::GetFormatException();
                    }
                    return false;
                }
            }
        }
        if(!(digits_seen)) 
        {
            if(!(tryParse)) 
            {
                exc = Int32::GetFormatException();
            }
            return false;
        }
        ival = neg ? ival : -(ival);
        if(((ival < -128) || (ival > 127))) 
        {
            if(!(tryParse)) 
            {
                exc = cli::gcnew<OverflowException>();
            }
            return false;
        }
        result = (signed char)ival;
        return true;
    }
    
    signed char SByte::Parse2(String* s, IFormatProvider* provider) {
        return Parse4(s, Globalization::NumberStyles::Integer, provider);
    }
    
    signed char SByte::Parse3(String* s, Globalization::NumberStyles style) {
        return Parse4(s, style, nullptr);
    }
    
    signed char SByte::Parse4(String* s, Globalization::NumberStyles style, IFormatProvider* provider) {
        int32_t tmpResult = Int32::Parse6(s, style, provider);
        if(((int32_t)(((int32_t)(style) & 512)) != 0)) 
        {
            if(((tmpResult >= 0) && (tmpResult <= 255))) 
            {
                return (signed char)tmpResult;
            }
        }
         else 
        {
            if(((tmpResult <= 127) && (tmpResult >= -128))) 
            {
                return (signed char)tmpResult;
            }
        }
        throw cli::gcnew<OverflowException>(Locale::GetText(_T("Value too large or too small.")));
    }
    
    signed char SByte::Parse5(String* s) {
        Exception *exc;
        signed char res;
        if(!(Parse(s, false, res, exc))) 
        {
            throw exc;
        }
        return res;
    }
    
    bool SByte::TryParse(String* s, signed char result) {
        Exception *exc;
        if(!(Parse(s, true, result, exc))) 
        {
            result = 0;
            return false;
        }
        return true;
    }
    
    bool SByte::TryParse2(String* s, Globalization::NumberStyles style, IFormatProvider* provider, signed char result) {
        int32_t tmpResult;
        result = 0;
        if(!(Int32::TryParse2(s, style, provider, tmpResult))) 
        {
            return false;
        }
        if(((tmpResult > 127) || (tmpResult < -128))) 
        {
            return false;
        }
        result = (signed char)tmpResult;
        return true;
    }
    
    String* SByte::ToString_1636a0751cb9ac11() {
        return NumberFormatter::NumberToString13((int32_t)(cli::import((*this))->m_value), nullptr);
    }
    
    String* SByte::ToString3(IFormatProvider* provider) {
        return NumberFormatter::NumberToString13((int32_t)(cli::import((*this))->m_value), provider);
    }
    
    String* SByte::ToString4(String* format) {
        return ToString5(format, nullptr);
    }
    
    String* SByte::ToString5(String* format, IFormatProvider* provider) {
        return NumberFormatter::NumberToString(format, cli::import((*this))->m_value, provider);
    }
    
    TypeCode SByte::GetTypeCode() {
        return TypeCode::SByte2;
    }
    
    bool SByte::ToBoolean(IFormatProvider* provider) {
        return Convert::ToBoolean10(cli::import((*this))->m_value);
    }
    
    unsigned char SByte::ToByte(IFormatProvider* provider) {
        return Convert::ToByte10(cli::import((*this))->m_value);
    }
    
    char16_t SByte::ToChar(IFormatProvider* provider) {
        return Convert::ToChar10(cli::import((*this))->m_value);
    }
    
    DateTime SByte::ToDateTime(IFormatProvider* provider) {
        return Convert::ToDateTime15(cli::import((*this))->m_value);
    }
    
    Decimal SByte::ToDecimal(IFormatProvider* provider) {
        return Convert::ToDecimal10(cli::import((*this))->m_value);
    }
    
    double SByte::ToDouble(IFormatProvider* provider) {
        return Convert::ToDouble10(cli::import((*this))->m_value);
    }
    
    int16_t SByte::ToInt16(IFormatProvider* provider) {
        return Convert::ToInt1610(cli::import((*this))->m_value);
    }
    
    int32_t SByte::ToInt32(IFormatProvider* provider) {
        return Convert::ToInt3210(cli::import((*this))->m_value);
    }
    
    int64_t SByte::ToInt64(IFormatProvider* provider) {
        return Convert::ToInt6410(cli::import((*this))->m_value);
    }
    
    signed char SByte::ToSByte(IFormatProvider* provider) {
        return cli::import((*this))->m_value;
    }
    
    float SByte::ToSingle(IFormatProvider* provider) {
        return Convert::ToSingle10(cli::import((*this))->m_value);
    }
    
    Object* SByte::ToType(Type* targetType, IFormatProvider* provider) {
        if(Type::op_Equality2(targetType, nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("targetType"));
        }
        return Convert::ToType(cli::box(cli::import((*this))->m_value), targetType, provider, false);
    }
    
    uint16_t SByte::ToUInt16(IFormatProvider* provider) {
        return Convert::ToUInt1610(cli::import((*this))->m_value);
    }
    
    uint32_t SByte::ToUInt32(IFormatProvider* provider) {
        return Convert::ToUInt3210(cli::import((*this))->m_value);
    }
    
    uint64_t SByte::ToUInt64(IFormatProvider* provider) {
        return Convert::ToUInt6410(cli::import((*this))->m_value);
    }
    
}
namespace System {
    
    
    int32_t Single::CompareTo(Object* value) {
        if((value ==  nullptr)) 
        {
            return 1;
        }
        if(!(cli::is<Single>(value))) 
        {
            throw cli::gcnew<ArgumentException>(Locale::GetText(_T("Value is not a System.Single.")));
        }
        float fv = cli::unbox<float>(value);
        if((IsPositiveInfinity(cli::import((*this))->m_value) && IsPositiveInfinity(fv))) 
        {
            return 0;
        }
        if((IsNegativeInfinity(cli::import((*this))->m_value) && IsNegativeInfinity(fv))) 
        {
            return 0;
        }
        if(IsNaN(fv)) 
        {
            if(IsNaN(cli::import((*this))->m_value)) 
            {
                return 0;
            }
             else 
            {
                return 1;
            }
        }
        if(IsNaN(cli::import((*this))->m_value)) 
        {
            if(IsNaN(fv)) 
            {
                return 0;
            }
             else 
            {
                return -1;
            }
        }
        if((cli::import((*this))->m_value ==  fv)) 
        {
            return 0;
        }
         else 
        {
            if((cli::import((*this))->m_value > fv)) 
            {
                return 1;
            }
             else 
            {
                return -1;
            }
        }
    }
    
    bool Single::Equals_ed975d2f4a7d193e(Object* obj) {
        if(!(cli::is<Single>(obj))) 
        {
            return false;
        }
        float value = cli::unbox<float>(obj);
        if(IsNaN(value)) 
        {
            return IsNaN(cli::import((*this))->m_value);
        }
        return (value ==  cli::import((*this))->m_value);
    }
    
    int32_t Single::CompareTo2(float value) {
        if((IsPositiveInfinity(cli::import((*this))->m_value) && IsPositiveInfinity(value))) 
        {
            return 0;
        }
        if((IsNegativeInfinity(cli::import((*this))->m_value) && IsNegativeInfinity(value))) 
        {
            return 0;
        }
        if(IsNaN(value)) 
        {
            if(IsNaN(cli::import((*this))->m_value)) 
            {
                return 0;
            }
             else 
            {
                return 1;
            }
        }
        if(IsNaN(cli::import((*this))->m_value)) 
        {
            if(IsNaN(value)) 
            {
                return 0;
            }
             else 
            {
                return -1;
            }
        }
        if((cli::import((*this))->m_value ==  value)) 
        {
            return 0;
        }
         else 
        {
            if((cli::import((*this))->m_value > value)) 
            {
                return 1;
            }
             else 
            {
                return -1;
            }
        }
    }
    
    bool Single::Equals2(float obj) {
        if(IsNaN(obj)) 
        {
            return IsNaN(cli::import((*this))->m_value);
        }
        return (obj ==  cli::import((*this))->m_value);
    }
    
    int32_t Single::GetHashCode_6648aef0f235ee6c() {
        float f = cli::import((*this))->m_value;
        return (*(int32_t*)(&(f)));
    }
    
    bool Single::IsInfinity(float f) {
        return ((f ==  std::numeric_limits<float>::infinity()) || (f ==  -std::numeric_limits<float>::infinity()));
    }
    
    bool Single::IsNaN(float f) {
        return (f != f);
    }
    
    bool Single::IsNegativeInfinity(float f) {
        return ((f < std::numeric_limits<float>::epsilon()) && ((f ==  -std::numeric_limits<float>::infinity()) || (f ==  std::numeric_limits<float>::infinity())));
    }
    
    bool Single::IsPositiveInfinity(float f) {
        return ((f > std::numeric_limits<float>::epsilon()) && ((f ==  -std::numeric_limits<float>::infinity()) || (f ==  std::numeric_limits<float>::infinity())));
    }
    
    float Single::Parse(String* s) {
        double parsed_value = Double::Parse4(s, (Globalization::NumberStyles)231L, nullptr);
        if((((parsed_value - 3.40282346638529E+38) > 3.61471124579618E+29) && !(Double::IsPositiveInfinity(parsed_value)))) 
        {
            throw cli::gcnew<OverflowException>();
        }
        return (float)parsed_value;
    }
    
    float Single::Parse2(String* s, IFormatProvider* provider) {
        double parsed_value = Double::Parse4(s, (Globalization::NumberStyles)231L, provider);
        if((((parsed_value - 3.40282346638529E+38) > 3.61471124579618E+29) && !(Double::IsPositiveInfinity(parsed_value)))) 
        {
            throw cli::gcnew<OverflowException>();
        }
        return (float)parsed_value;
    }
    
    float Single::Parse3(String* s, Globalization::NumberStyles style) {
        double parsed_value = Double::Parse4(s, style, nullptr);
        if((((parsed_value - 3.40282346638529E+38) > 3.61471124579618E+29) && !(Double::IsPositiveInfinity(parsed_value)))) 
        {
            throw cli::gcnew<OverflowException>();
        }
        return (float)parsed_value;
    }
    
    float Single::Parse4(String* s, Globalization::NumberStyles style, IFormatProvider* provider) {
        double parsed_value = Double::Parse4(s, style, provider);
        if((((parsed_value - 3.40282346638529E+38) > 3.61471124579618E+29) && !(Double::IsPositiveInfinity(parsed_value)))) 
        {
            throw cli::gcnew<OverflowException>();
        }
        return (float)parsed_value;
    }
    
    bool Single::TryParse(String* s, Globalization::NumberStyles style, IFormatProvider* provider, float result) {
        double parsed_value;
        Exception *exc;
        if(!(Double::Parse5(s, style, provider, true, parsed_value, exc))) 
        {
            result = std::numeric_limits<float>::epsilon();
            return false;
        }
         else 
        {
            if((((parsed_value - 3.40282346638529E+38) > 3.61471124579618E+29) && !(Double::IsPositiveInfinity(parsed_value)))) 
            {
                result = std::numeric_limits<float>::epsilon();
                return false;
            }
        }
        result = (float)parsed_value;
        return true;
    }
    
    bool Single::TryParse2(String* s, float result) {
        return TryParse(s, Globalization::NumberStyles::Any, nullptr, result);
    }
    
    String* Single::ToString_1636a0751cb9ac11() {
        return NumberFormatter::NumberToString16(cli::import((*this))->m_value, nullptr);
    }
    
    String* Single::ToString3(IFormatProvider* provider) {
        return NumberFormatter::NumberToString16(cli::import((*this))->m_value, provider);
    }
    
    String* Single::ToString4(String* format) {
        return ToString5(format, nullptr);
    }
    
    String* Single::ToString5(String* format, IFormatProvider* provider) {
        return NumberFormatter::NumberToString9(format, cli::import((*this))->m_value, provider);
    }
    
    TypeCode Single::GetTypeCode() {
        return TypeCode::Single2;
    }
    
    bool Single::ToBoolean(IFormatProvider* provider) {
        return Convert::ToBoolean7(cli::import((*this))->m_value);
    }
    
    unsigned char Single::ToByte(IFormatProvider* provider) {
        return Convert::ToByte7(cli::import((*this))->m_value);
    }
    
    char16_t Single::ToChar(IFormatProvider* provider) {
        return Convert::ToChar9(cli::import((*this))->m_value);
    }
    
    DateTime Single::ToDateTime(IFormatProvider* provider) {
        return Convert::ToDateTime12(cli::import((*this))->m_value);
    }
    
    Decimal Single::ToDecimal(IFormatProvider* provider) {
        return Convert::ToDecimal7(cli::import((*this))->m_value);
    }
    
    double Single::ToDouble(IFormatProvider* provider) {
        return Convert::ToDouble7(cli::import((*this))->m_value);
    }
    
    int16_t Single::ToInt16(IFormatProvider* provider) {
        return Convert::ToInt167(cli::import((*this))->m_value);
    }
    
    int32_t Single::ToInt32(IFormatProvider* provider) {
        return Convert::ToInt327(cli::import((*this))->m_value);
    }
    
    int64_t Single::ToInt64(IFormatProvider* provider) {
        return Convert::ToInt647(cli::import((*this))->m_value);
    }
    
    signed char Single::ToSByte(IFormatProvider* provider) {
        return Convert::ToSByte7(cli::import((*this))->m_value);
    }
    
    float Single::ToSingle(IFormatProvider* provider) {
        return Convert::ToSingle7(cli::import((*this))->m_value);
    }
    
    Object* Single::ToType(Type* targetType, IFormatProvider* provider) {
        if(Type::op_Equality2(targetType, nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("targetType"));
        }
        return Convert::ToType(cli::box(cli::import((*this))->m_value), targetType, provider, false);
    }
    
    uint16_t Single::ToUInt16(IFormatProvider* provider) {
        return Convert::ToUInt167(cli::import((*this))->m_value);
    }
    
    uint32_t Single::ToUInt32(IFormatProvider* provider) {
        return Convert::ToUInt327(cli::import((*this))->m_value);
    }
    
    uint64_t Single::ToUInt64(IFormatProvider* provider) {
        return Convert::ToUInt647(cli::import((*this))->m_value);
    }
    
    bool Single::op_Equality(float left, float right) {
        return (left ==  right);
    }
    
    bool Single::op_Inequality(float left, float right) {
        return (left != right);
    }
    
    bool Single::op_GreaterThan(float left, float right) {
        return (left > right);
    }
    
    bool Single::op_GreaterThanOrEqual(float left, float right) {
        return (left >= right);
    }
    
    bool Single::op_LessThan(float left, float right) {
        return (left < right);
    }
    
    bool Single::op_LessThanOrEqual(float left, float right) {
        return (left <= right);
    }
    
}
namespace System {
    
    
    void FormatElement::constructor(FormatElementType type) {
        (*this)->Type2 = type;
        (*this)->CharValue = u'\x0';
        (*this)->IntValue = 0;
        (*this)->StringValue = nullptr;
    }
    
}
namespace System {
    
    TimeSpan*  TimeSpan::MaxValue;
    TimeSpan*  TimeSpan::MinValue;
    TimeSpan*  TimeSpan::Zero;
    
    void TimeSpan::constructor(int64_t ticks) {
        (*this)->_ticks = ticks;
    }
    
    void TimeSpan::constructor(int32_t hours, int32_t minutes, int32_t seconds) {
        CalculateTicks(0, hours, minutes, seconds, 0, true, (*this)->_ticks);
    }
    
    void TimeSpan::constructor(int32_t days, int32_t hours, int32_t minutes, int32_t seconds) {
        CalculateTicks(days, hours, minutes, seconds, 0, true, (*this)->_ticks);
    }
    
    void TimeSpan::constructor(int32_t days, int32_t hours, int32_t minutes, int32_t seconds, int32_t milliseconds) {
        CalculateTicks(days, hours, minutes, seconds, milliseconds, true, (*this)->_ticks);
    }
    
    void TimeSpan::static_constructor() {
    }
    
    bool TimeSpan::CalculateTicks(int32_t days, int32_t hours, int32_t minutes, int32_t seconds, int32_t milliseconds, bool throwExc, int64_t result) {
        int32_t hrssec = (hours * 3600);
        int32_t minsec = (minutes * 60);
        int64_t t = (((int64_t)(((hrssec + minsec) + seconds)) * 1000L) + (int64_t)(milliseconds));
        (t = t * 10000L);
        result = 0L;
        bool overflow = false;
        if((days > 0)) 
        {
            int64_t td = (864000000000L * (int64_t)(days));
            if((t < 0L)) 
            {
                int64_t ticks = t;
                (t = t + td);
                overflow = (ticks > t);
            }
             else 
            {
                (t = t + td);
                overflow = (t < 0L);
            }
        }
         else 
        {
            if((days < 0)) 
            {
                int64_t td = (864000000000L * (int64_t)(days));
                if((t <= 0L)) 
                {
                    (t = t + td);
                    overflow = (t > 0L);
                }
                 else 
                {
                    int64_t ticks = t;
                    (t = t + td);
                    overflow = (t > ticks);
                }
            }
        }
        if(overflow) 
        {
            if(throwExc) 
            {
                throw cli::gcnew<ArgumentOutOfRangeException>(Locale::GetText(_T("The timespan is too big or too small.")));
            }
            return false;
        }
        result = t;
        return true;
    }
    
    TimeSpan TimeSpan::Add(TimeSpan ts) {
        try {
            /*checked*/ {
                return cli::ctor<TimeSpan>(((*this)->_ticks + ts->get_Ticks()));
            }
        }
        catch(OverflowException*) {
            throw cli::gcnew<OverflowException>(Locale::GetText(_T("Resulting timespan is too big.")));
        }
    }
    
    int32_t TimeSpan::Compare(TimeSpan t1, TimeSpan t2) {
        if((t1->_ticks < t2->_ticks)) 
        {
            return -1;
        }
        if((t1->_ticks > t2->_ticks)) 
        {
            return 1;
        }
        return 0;
    }
    
    int32_t TimeSpan::CompareTo(Object* value) {
        if((value ==  nullptr)) 
        {
            return 1;
        }
        if(!(cli::is<TimeSpan>(value))) 
        {
            throw cli::gcnew<ArgumentException>(Locale::GetText(_T("Argument has to be a TimeSpan.")), _T("value"));
        }
        return Compare((*this), cli::unbox<TimeSpan>(value));
    }
    
    int32_t TimeSpan::CompareTo2(TimeSpan value) {
        return Compare((*this), value);
    }
    
    bool TimeSpan::Equals(TimeSpan obj) {
        return (obj->_ticks ==  (*this)->_ticks);
    }
    
    TimeSpan TimeSpan::Duration() {
        try {
            /*checked*/ {
                return cli::ctor<TimeSpan>(Math::Abs5((*this)->_ticks));
            }
        }
        catch(OverflowException*) {
            throw cli::gcnew<OverflowException>(Locale::GetText(_T("This TimeSpan value is MinValue so you cannot get the duration.")));
        }
    }
    
    bool TimeSpan::Equals_ed975d2f4a7d193e(Object* value) {
        if(!(cli::is<TimeSpan>(value))) 
        {
            return false;
        }
        return ((*this)->_ticks ==  cli::unbox<TimeSpan>(value)->_ticks);
    }
    
    bool TimeSpan::Equals4(TimeSpan t1, TimeSpan t2) {
        return (t1->_ticks ==  t2->_ticks);
    }
    
    TimeSpan TimeSpan::FromDays(double value) {
        return From(value, 864000000000L);
    }
    
    TimeSpan TimeSpan::FromHours(double value) {
        return From(value, 36000000000L);
    }
    
    TimeSpan TimeSpan::FromMinutes(double value) {
        return From(value, 600000000L);
    }
    
    TimeSpan TimeSpan::FromSeconds(double value) {
        return From(value, 10000000L);
    }
    
    TimeSpan TimeSpan::FromMilliseconds(double value) {
        return From(value, 10000L);
    }
    
    TimeSpan TimeSpan::From(double value, int64_t tickMultiplicator) {
        if(Double::IsNaN(value)) 
        {
            throw cli::gcnew<ArgumentException>(Locale::GetText(_T("Value cannot be NaN.")), _T("value"));
        }
        if((((Double::IsNegativeInfinity(value) || Double::IsPositiveInfinity(value)) || (value < (double)((*MinValue)->get_Ticks()))) || (value > (double)((*MaxValue)->get_Ticks())))) 
        {
            throw cli::gcnew<OverflowException>(Locale::GetText(_T("Outside range [MinValue,MaxValue]")));
        }
        try {
            value = (value * (double)((tickMultiplicator / 10000L)));
            /*checked*/ {
                int64_t val = (int64_t)Math::Round5(value);
                return cli::ctor<TimeSpan>((val * 10000L));
            }
        }
        catch(OverflowException*) {
            throw cli::gcnew<OverflowException>(Locale::GetText(_T("Resulting timespan is too big.")));
        }
    }
    
    TimeSpan TimeSpan::FromTicks(int64_t value) {
        return cli::ctor<TimeSpan>(value);
    }
    
    int32_t TimeSpan::GetHashCode_6648aef0f235ee6c() {
        return cli::import((*this)->_ticks)->GetHashCode_6648aef0f235ee6c();
    }
    
    TimeSpan TimeSpan::Negate() {
        if(((*this)->_ticks ==  (*MinValue)->_ticks)) 
        {
            throw cli::gcnew<OverflowException>(Locale::GetText(_T("This TimeSpan value is MinValue and cannot be negated.")));
        }
        return cli::ctor<TimeSpan>(-((*this)->_ticks));
    }
    
    TimeSpan TimeSpan::Parse(String* s) {
        if((s ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("s"));
        }
        TimeSpan result;
        Parser *p = cli::gcnew<Parser>(s);
        p->Execute(false, result);
        return result;
    }
    
    bool TimeSpan::TryParse(String* s, TimeSpan result) {
        if((s ==  nullptr)) 
        {
            result = (*Zero);
            return false;
        }
        Parser *p = cli::gcnew<Parser>(s);
        return p->Execute(true, result);
    }
    
    TimeSpan TimeSpan::Parse2(String* input, IFormatProvider* formatProvider) {
        if((input ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("input"));
        }
        TimeSpan result;
        Parser *p = cli::gcnew<Parser>(input, formatProvider);
        p->Execute(false, result);
        return result;
    }
    
    bool TimeSpan::TryParse2(String* input, IFormatProvider* formatProvider, TimeSpan result) {
        if(String::IsNullOrEmpty(input)) 
        {
            result = (*Zero);
            return false;
        }
        Parser *p = cli::gcnew<Parser>(input, formatProvider);
        return p->Execute(true, result);
    }
    
    TimeSpan TimeSpan::ParseExact(String* input, String* format, IFormatProvider* formatProvider) {
        if((format ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("format"));
        }
        return ParseExact4(input, (new cli::array<String*>({format})), formatProvider, Globalization::TimeSpanStyles::None);
    }
    
    TimeSpan TimeSpan::ParseExact2(String* input, String* format, IFormatProvider* formatProvider, Globalization::TimeSpanStyles styles) {
        if((format ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("format"));
        }
        return ParseExact4(input, (new cli::array<String*>({format})), formatProvider, styles);
    }
    
    TimeSpan TimeSpan::ParseExact3(String* input, cli::array<String*>* formats, IFormatProvider* formatProvider) {
        return ParseExact4(input, formats, formatProvider, Globalization::TimeSpanStyles::None);
    }
    
    TimeSpan TimeSpan::ParseExact4(String* input, cli::array<String*>* formats, IFormatProvider* formatProvider, Globalization::TimeSpanStyles styles) {
        if((input ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("input"));
        }
        if((formats ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("formats"));
        }
        TimeSpan result;
        if(!(TryParseExact4(input, formats, formatProvider, styles, result))) 
        {
            throw cli::gcnew<FormatException>(_T("Invalid format."));
        }
        return result;
    }
    
    bool TimeSpan::TryParseExact(String* input, String* format, IFormatProvider* formatProvider, TimeSpan result) {
        return TryParseExact4(input, (new cli::array<String*>({format})), formatProvider, Globalization::TimeSpanStyles::None, result);
    }
    
    bool TimeSpan::TryParseExact2(String* input, String* format, IFormatProvider* formatProvider, Globalization::TimeSpanStyles styles, TimeSpan result) {
        return TryParseExact4(input, (new cli::array<String*>({format})), formatProvider, styles, result);
    }
    
    bool TimeSpan::TryParseExact3(String* input, cli::array<String*>* formats, IFormatProvider* formatProvider, TimeSpan result) {
        return TryParseExact4(input, formats, formatProvider, Globalization::TimeSpanStyles::None, result);
    }
    
    bool TimeSpan::TryParseExact4(String* input, cli::array<String*>* formats, IFormatProvider* formatProvider, Globalization::TimeSpanStyles styles, TimeSpan result) {
        result = (*Zero);
        if(((formats ==  nullptr) || (formats->get_Length() ==  0))) 
        {
            return false;
        }
        Parser *p = cli::gcnew<Parser>(input, formatProvider);
        p->Exact = true;
        for(auto tmp_2 : formats) {
            auto format = cli::cast<String*>(tmp_2);
            {
                if(((format ==  nullptr) || (format->get_Length() ==  0))) 
                {
                    return false;
                }
                String* tmp_3 = format;
                ::System::Int32 tmp_4 = -1;
                if(::System::String::Equals3(tmp_3, _T("g"))) tmp_4 = 0;
                if(::System::String::Equals3(tmp_3, _T("G"))) tmp_4 = 1;
                if(::System::String::Equals3(tmp_3, _T("c"))) tmp_4 = 2;
                switch(tmp_4)
                {
                    case 0: case_54: 
                    {
                        p->AllMembersRequired = false;
                        p->CultureSensitive = true;
                        p->UseColonAsDaySeparator = true;
                        break;
                    }
                    case 1: case_55: 
                    {
                        p->AllMembersRequired = true;
                        p->CultureSensitive = true;
                        p->UseColonAsDaySeparator = true;
                        break;
                    }
                    case 2: case_56: 
                    {
                        p->AllMembersRequired = false;
                        p->CultureSensitive = false;
                        p->UseColonAsDaySeparator = false;
                        break;
                    }
                    default: case_57: 
                    {
                        if((format->get_Length() ==  1)) 
                        {
                            return false;
                        }
                        if(p->ExecuteWithFormat(format, styles, true, result)) 
                        {
                            return true;
                        }
                        continue;
                    }
                }
                if(p->Execute(true, result)) 
                {
                    return true;
                }
            }
        }
        return false;
    }
    
    TimeSpan TimeSpan::Subtract(TimeSpan ts) {
        try {
            /*checked*/ {
                return cli::ctor<TimeSpan>(((*this)->_ticks - ts->get_Ticks()));
            }
        }
        catch(OverflowException*) {
            throw cli::gcnew<OverflowException>(Locale::GetText(_T("Resulting timespan is too big.")));
        }
    }
    
    String* TimeSpan::ToString_1636a0751cb9ac11() {
        Text::StringBuilder *sb = cli::gcnew<Text::StringBuilder>(14);
        if(((*this)->_ticks < 0L)) 
        {
            sb->Append16(u'-');
        }
        if(((*this)->get_Days() != 0)) 
        {
            sb->Append8(Math::Abs4((*this)->get_Days()));
            sb->Append16(u'.');
        }
        sb->Append2(cli::import(Math::Abs4((*this)->get_Hours()))->ToString4(_T("D2")));
        sb->Append16(u':');
        sb->Append2(cli::import(Math::Abs4((*this)->get_Minutes()))->ToString4(_T("D2")));
        sb->Append16(u':');
        sb->Append2(cli::import(Math::Abs4((*this)->get_Seconds()))->ToString4(_T("D2")));
        int32_t fractional = (int32_t)Math::Abs5(((*this)->_ticks % 10000000L));
        if((fractional != 0)) 
        {
            sb->Append16(u'.');
            sb->Append2(cli::import(fractional)->ToString4(_T("D7")));
        }
        return sb->ToString_1636a0751cb9ac11();
    }
    
    String* TimeSpan::ToString3(String* format) {
        return ToString4(format, nullptr);
    }
    
    String* TimeSpan::ToString4(String* format, IFormatProvider* formatProvider) {
        if((((((format ==  nullptr) || (format->get_Length() ==  0)) || String::op_Equality(format, _T("c"))) || String::op_Equality(format, _T("t"))) || String::op_Equality(format, _T("T")))) 
        {
            return Object::ToString_1636a0751cb9ac11();
        }
        if((String::op_Inequality(format, _T("g")) && String::op_Inequality(format, _T("G")))) 
        {
            return ToStringCustom(format);
        }
        Globalization::NumberFormatInfo *number_info = nullptr;
        if((formatProvider != nullptr)) 
        {
            number_info = cli::cast<Globalization::NumberFormatInfo*>(formatProvider->GetFormat_b67414a65453cc7e(cli::typeof<Type>::info));
        }
        if((number_info ==  nullptr)) 
        {
            number_info = Threading::Thread::get_CurrentThread()->get_CurrentCulture()->get_NumberFormat_56b6d54c07628932();
        }
        String *decimal_separator = number_info->get_NumberDecimalSeparator();
        int32_t days, hours, minutes, seconds, milliseconds, fractional;
        days = Math::Abs4((*this)->get_Days());
        hours = Math::Abs4((*this)->get_Hours());
        minutes = Math::Abs4((*this)->get_Minutes());
        seconds = Math::Abs4((*this)->get_Seconds());
        milliseconds = Math::Abs4((*this)->get_Milliseconds());
        fractional = (int32_t)Math::Abs5(((*this)->_ticks % 10000000L));
        Text::StringBuilder *sb = cli::gcnew<Text::StringBuilder>(String::op_Equality(format, _T("g")) ? 16 : 32);
        if(((*this)->_ticks < 0L)) 
        {
            sb->Append16(u'-');
        }
        String* tmp_5 = format;
        ::System::Int32 tmp_6 = -1;
        if(::System::String::Equals3(tmp_5, _T("g"))) tmp_6 = 0;
        if(::System::String::Equals3(tmp_5, _T("G"))) tmp_6 = 1;
        switch(tmp_6)
        {
            case 0: case_58: 
            {
                if((days != 0)) 
                {
                    sb->Append2(cli::import(days)->ToString_1636a0751cb9ac11());
                    sb->Append16(u':');
                }
                sb->Append2(cli::import(hours)->ToString_1636a0751cb9ac11());
                sb->Append16(u':');
                sb->Append2(cli::import(minutes)->ToString4(_T("D2")));
                sb->Append16(u':');
                sb->Append2(cli::import(seconds)->ToString4(_T("D2")));
                if((milliseconds != 0)) 
                {
                    sb->Append2(decimal_separator);
                    sb->Append2(cli::import(milliseconds)->ToString4(_T("D3")));
                }
                break;
            }
            case 1: case_59: 
            {
                sb->Append2(cli::import(days)->ToString4(_T("D1")));
                sb->Append16(u':');
                sb->Append2(cli::import(hours)->ToString4(_T("D2")));
                sb->Append16(u':');
                sb->Append2(cli::import(minutes)->ToString4(_T("D2")));
                sb->Append16(u':');
                sb->Append2(cli::import(seconds)->ToString4(_T("D2")));
                sb->Append2(decimal_separator);
                sb->Append2(cli::import(fractional)->ToString4(_T("D7")));
                break;
            }
        }
        return sb->ToString_1636a0751cb9ac11();
    }
    
    String* TimeSpan::ToStringCustom(String* format) {
        if((format->get_Length() < 2)) 
        {
            throw cli::gcnew<FormatException>(_T("The format is not recognized."));
        }
        FormatParser *parser = cli::gcnew<FormatParser>(format);
        FormatElement element;
        int32_t value;
        Text::StringBuilder *sb = cli::gcnew<Text::StringBuilder>((format->get_Length() + 1));
        for(; ; ){
            if(parser->get_AtEnd()) 
            {
                break;
            }
            element = parser->GetNextElement();
            switch(element->Type2) {
                case FormatElementType::Days: case_60: {
                    value = Math::Abs4((*this)->get_Days());
                    sb->Append2(cli::import(value)->ToString4(cli::concat(_T("D"), cli::box(element->IntValue))));
                    break;
                }
                case FormatElementType::Hours: case_61: {
                    value = Math::Abs4((*this)->get_Hours());
                    sb->Append2(cli::import(value)->ToString4(cli::concat(_T("D"), cli::box(element->IntValue))));
                    break;
                }
                case FormatElementType::Minutes: case_62: {
                    value = Math::Abs4((*this)->get_Minutes());
                    sb->Append2(cli::import(value)->ToString4(cli::concat(_T("D"), cli::box(element->IntValue))));
                    break;
                }
                case FormatElementType::Seconds: case_63: {
                    value = Math::Abs4((*this)->get_Seconds());
                    sb->Append2(cli::import(value)->ToString4(cli::concat(_T("D"), cli::box(element->IntValue))));
                    break;
                }
                case FormatElementType::Ticks: case_64: {
                    value = Math::Abs4((*this)->get_Milliseconds());
                    sb->Append2(cli::import(value)->ToString4(cli::concat(_T("D"), cli::box(element->IntValue))));
                    break;
                }
                case FormatElementType::TicksUppercase: case_65: {
                    value = Math::Abs4((*this)->get_Milliseconds());
                    if((value > 0)) 
                    {
                        int32_t threshold = (int32_t)Math::Pow(10., (double)(element->IntValue));
                        while((value >= threshold)) (value = value / 10);
                        sb->Append2(cli::import(value)->ToString_1636a0751cb9ac11());
                    }
                    break;
                }
                case FormatElementType::EscapedChar: case_66: {
                    sb->Append16(element->CharValue);
                    break;
                }
                case FormatElementType::Literal: case_67: {
                    sb->Append2(element->StringValue);
                    break;
                }
                default: case_68: {
                    throw cli::gcnew<FormatException>(_T("The format is not recognized."));
                }
            }
        }
        return sb->ToString_1636a0751cb9ac11();
    }
    
    TimeSpan TimeSpan::op_Addition(TimeSpan t1, TimeSpan t2) {
        return t1->Add(t2);
    }
    
    bool TimeSpan::op_Equality(TimeSpan t1, TimeSpan t2) {
        return (t1->_ticks ==  t2->_ticks);
    }
    
    bool TimeSpan::op_GreaterThan(TimeSpan t1, TimeSpan t2) {
        return (t1->_ticks > t2->_ticks);
    }
    
    bool TimeSpan::op_GreaterThanOrEqual(TimeSpan t1, TimeSpan t2) {
        return (t1->_ticks >= t2->_ticks);
    }
    
    bool TimeSpan::op_Inequality(TimeSpan t1, TimeSpan t2) {
        return (t1->_ticks != t2->_ticks);
    }
    
    bool TimeSpan::op_LessThan(TimeSpan t1, TimeSpan t2) {
        return (t1->_ticks < t2->_ticks);
    }
    
    bool TimeSpan::op_LessThanOrEqual(TimeSpan t1, TimeSpan t2) {
        return (t1->_ticks <= t2->_ticks);
    }
    
    TimeSpan TimeSpan::op_Subtraction(TimeSpan t1, TimeSpan t2) {
        return t1->Subtract(t2);
    }
    
    TimeSpan TimeSpan::op_UnaryNegation(TimeSpan t) {
        return t->Negate();
    }
    
    TimeSpan TimeSpan::op_UnaryPlus(TimeSpan t) {
        return t;
    }
    
    int32_t TimeSpan::get_Days() {
        return (int32_t)((*this)->_ticks / 864000000000L);
    }
    
    int32_t TimeSpan::get_Hours() {
        return (int32_t)(((*this)->_ticks % 864000000000L) / 36000000000L);
    }
    
    int32_t TimeSpan::get_Milliseconds() {
        return (int32_t)(((*this)->_ticks % 10000000L) / 10000L);
    }
    
    int32_t TimeSpan::get_Minutes() {
        return (int32_t)(((*this)->_ticks % 36000000000L) / 600000000L);
    }
    
    int32_t TimeSpan::get_Seconds() {
        return (int32_t)(((*this)->_ticks % 600000000L) / 10000000L);
    }
    
    int64_t TimeSpan::get_Ticks() {
        return (*this)->_ticks;
    }
    
    double TimeSpan::get_TotalDays() {
        return ((double)((*this)->_ticks) / 864000000000.);
    }
    
    double TimeSpan::get_TotalHours() {
        return ((double)((*this)->_ticks) / 36000000000.);
    }
    
    double TimeSpan::get_TotalMilliseconds() {
        return ((double)((*this)->_ticks) / 10000.);
    }
    
    double TimeSpan::get_TotalMinutes() {
        return ((double)((*this)->_ticks) / 600000000.);
    }
    
    double TimeSpan::get_TotalSeconds() {
        return ((double)((*this)->_ticks) / 10000000.);
    }
    
}
namespace System {
    
    
    bool TypedReference::Equals_ed975d2f4a7d193e(Object* o) {
        throw cli::gcnew<NotSupportedException>(Locale::GetText(_T("This operation is not supported for this type.")));
    }
    
    int32_t TypedReference::GetHashCode_6648aef0f235ee6c() {
        if(::System::IntPtr::op_Equality((*this)->type->get_Value(), (*::System::IntPtr::Zero))) 
        {
            return 0;
        }
        return Type::GetTypeFromHandle((*this)->type)->GetHashCode_6648aef0f235ee6c();
    }
    
    Type* TypedReference::GetTargetType(TypedReference value) {
        return Type::GetTypeFromHandle(value->type);
    }
    
    TypedReference TypedReference::MakeTypedReference(Object* target, cli::array<Reflection::FieldInfo*>* flds) {
        if((target ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("target"));
        }
        if((flds ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("flds"));
        }
        if((flds->get_Length() ==  0)) 
        {
            throw cli::gcnew<ArgumentException>(Locale::GetText(_T("flds has no elements")));
        }
        throw cli::gcnew<NotImplementedException>();
    }
    
    void TypedReference::SetTypedReference(TypedReference target, Object* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("value"));
        }
        throw cli::gcnew<NotImplementedException>();
    }
    
    RuntimeTypeHandle TypedReference::TargetTypeToken(TypedReference value) {
        return value->type;
    }
    
    Object* TypedReference::ToObject(TypedReference value) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
}
namespace System {
    
    
    int32_t UInt16::CompareTo(Object* value) {
        if((value ==  nullptr)) 
        {
            return 1;
        }
        if(!(cli::is<UInt16>(value))) 
        {
            throw cli::gcnew<ArgumentException>(Locale::GetText(_T("Value is not a System.UInt16.")));
        }
        return ((int32_t)(cli::import((*this))->m_value) - (int32_t)(cli::unbox<uint16_t>(value)));
    }
    
    bool UInt16::Equals_ed975d2f4a7d193e(Object* obj) {
        if(!(cli::is<UInt16>(obj))) 
        {
            return false;
        }
        return ((int32_t)(cli::unbox<uint16_t>(obj)) ==  (int32_t)(cli::import((*this))->m_value));
    }
    
    int32_t UInt16::GetHashCode_6648aef0f235ee6c() {
        return (int32_t)(cli::import((*this))->m_value);
    }
    
    int32_t UInt16::CompareTo2(uint16_t value) {
        return ((int32_t)(cli::import((*this))->m_value) - (int32_t)(value));
    }
    
    bool UInt16::Equals2(uint16_t obj) {
        return ((int32_t)(obj) ==  (int32_t)(cli::import((*this))->m_value));
    }
    
    uint16_t UInt16::Parse(String* s, IFormatProvider* provider) {
        return Parse3(s, Globalization::NumberStyles::Integer, provider);
    }
    
    uint16_t UInt16::Parse2(String* s, Globalization::NumberStyles style) {
        return Parse3(s, style, nullptr);
    }
    
    uint16_t UInt16::Parse3(String* s, Globalization::NumberStyles style, IFormatProvider* provider) {
        uint32_t tmpResult = UInt32::Parse4(s, style, provider);
        if((tmpResult > 65535U)) 
        {
            throw cli::gcnew<OverflowException>(Locale::GetText(_T("Value too large.")));
        }
        return (uint16_t)tmpResult;
    }
    
    uint16_t UInt16::Parse4(String* s) {
        return Parse3(s, Globalization::NumberStyles::Number, nullptr);
    }
    
    bool UInt16::TryParse(String* s, uint16_t result) {
        return TryParse2(s, Globalization::NumberStyles::Integer, nullptr, result);
    }
    
    bool UInt16::TryParse2(String* s, Globalization::NumberStyles style, IFormatProvider* provider, uint16_t result) {
        uint32_t tmpResult;
        result = 0;
        if(!(UInt32::TryParse2(s, style, provider, tmpResult))) 
        {
            return false;
        }
        if((tmpResult > 65535U)) 
        {
            return false;
        }
        result = (uint16_t)tmpResult;
        return true;
    }
    
    String* UInt16::ToString_1636a0751cb9ac11() {
        return NumberFormatter::NumberToString13((int32_t)(cli::import((*this))->m_value), nullptr);
    }
    
    String* UInt16::ToString3(IFormatProvider* provider) {
        return NumberFormatter::NumberToString13((int32_t)(cli::import((*this))->m_value), provider);
    }
    
    String* UInt16::ToString4(String* format) {
        return ToString5(format, nullptr);
    }
    
    String* UInt16::ToString5(String* format, IFormatProvider* provider) {
        return NumberFormatter::NumberToString3(format, cli::import((*this))->m_value, provider);
    }
    
    TypeCode UInt16::GetTypeCode() {
        return TypeCode::UInt162;
    }
    
    bool UInt16::ToBoolean(IFormatProvider* provider) {
        return Convert::ToBoolean16(cli::import((*this))->m_value);
    }
    
    unsigned char UInt16::ToByte(IFormatProvider* provider) {
        return Convert::ToByte17(cli::import((*this))->m_value);
    }
    
    char16_t UInt16::ToChar(IFormatProvider* provider) {
        return Convert::ToChar16(cli::import((*this))->m_value);
    }
    
    DateTime UInt16::ToDateTime(IFormatProvider* provider) {
        return Convert::ToDateTime16(cli::import((*this))->m_value);
    }
    
    Decimal UInt16::ToDecimal(IFormatProvider* provider) {
        return Convert::ToDecimal16(cli::import((*this))->m_value);
    }
    
    double UInt16::ToDouble(IFormatProvider* provider) {
        return Convert::ToDouble16(cli::import((*this))->m_value);
    }
    
    int16_t UInt16::ToInt16(IFormatProvider* provider) {
        return Convert::ToInt1617(cli::import((*this))->m_value);
    }
    
    int32_t UInt16::ToInt32(IFormatProvider* provider) {
        return Convert::ToInt3217(cli::import((*this))->m_value);
    }
    
    int64_t UInt16::ToInt64(IFormatProvider* provider) {
        return Convert::ToInt6417(cli::import((*this))->m_value);
    }
    
    signed char UInt16::ToSByte(IFormatProvider* provider) {
        return Convert::ToSByte17(cli::import((*this))->m_value);
    }
    
    float UInt16::ToSingle(IFormatProvider* provider) {
        return Convert::ToSingle16(cli::import((*this))->m_value);
    }
    
    Object* UInt16::ToType(Type* targetType, IFormatProvider* provider) {
        if(Type::op_Equality2(targetType, nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("targetType"));
        }
        return Convert::ToType(cli::box(cli::import((*this))->m_value), targetType, provider, false);
    }
    
    uint16_t UInt16::ToUInt16(IFormatProvider* provider) {
        return cli::import((*this))->m_value;
    }
    
    uint32_t UInt16::ToUInt32(IFormatProvider* provider) {
        return Convert::ToUInt3217(cli::import((*this))->m_value);
    }
    
    uint64_t UInt16::ToUInt64(IFormatProvider* provider) {
        return Convert::ToUInt6417(cli::import((*this))->m_value);
    }
    
}
namespace System {
    
    
    int32_t UInt32::CompareTo(Object* value) {
        if((value ==  nullptr)) 
        {
            return 1;
        }
        if(!(cli::is<UInt32>(value))) 
        {
            throw cli::gcnew<ArgumentException>(Locale::GetText(_T("Value is not a System.UInt32.")));
        }
        uint32_t val = cli::unbox<uint32_t>(value);
        if((cli::import((*this))->m_value ==  val)) 
        {
            return 0;
        }
        return (cli::import((*this))->m_value < val) ? -1 : 1;
    }
    
    bool UInt32::Equals_ed975d2f4a7d193e(Object* obj) {
        if(!(cli::is<UInt32>(obj))) 
        {
            return false;
        }
        return (cli::unbox<uint32_t>(obj) ==  cli::import((*this))->m_value);
    }
    
    int32_t UInt32::GetHashCode_6648aef0f235ee6c() {
        return (int32_t)cli::import((*this))->m_value;
    }
    
    int32_t UInt32::CompareTo2(uint32_t value) {
        if((cli::import((*this))->m_value ==  value)) 
        {
            return 0;
        }
        if((cli::import((*this))->m_value > value)) 
        {
            return 1;
        }
         else 
        {
            return -1;
        }
    }
    
    bool UInt32::Equals2(uint32_t obj) {
        return (obj ==  cli::import((*this))->m_value);
    }
    
    bool UInt32::Parse(String* s, bool tryParse, uint32_t result, Exception* exc) {
        uint32_t val = 0U;
        int32_t len;
        int32_t i;
        bool digits_seen = false;
        bool has_negative_sign = false;
        result = 0U;
        exc = nullptr;
        if((s ==  nullptr)) 
        {
            if(!(tryParse)) 
            {
                exc = cli::gcnew<ArgumentNullException>(_T("s"));
            }
            return false;
        }
        len = s->get_Length();
        char16_t c;
        for(i = 0; (i < len); i++){
            c = s->get_Chars(i);
            if(!(Char::IsWhiteSpace(c))) 
            {
                break;
            }
        }
        if((i ==  len)) 
        {
            if(!(tryParse)) 
            {
                exc = Int32::GetFormatException();
            }
            return false;
        }
        if(((int32_t)(s->get_Chars(i)) ==  43)) 
        {
            i++;
        }
         else 
        {
            if(((int32_t)(s->get_Chars(i)) ==  45)) 
            {
                i++;
                has_negative_sign = true;
            }
        }
        for(; (i < len); i++){
            c = s->get_Chars(i);
            if((((int32_t)(c) >= 48) && ((int32_t)(c) <= 57))) 
            {
                uint32_t d = (uint32_t)((int32_t)(c) - 48);
                if(((val > 429496729U) || ((val ==  429496729U) && (d > 5U)))) 
                {
                    if(!(tryParse)) 
                    {
                        exc = cli::gcnew<OverflowException>(Locale::GetText(_T("Value is too large")));
                    }
                    return false;
                }
                val = ((val * 10U) + d);
                digits_seen = true;
            }
             else 
            {
                if(!(Int32::ProcessTrailingWhitespace(tryParse, s, i, exc))) 
                {
                    return false;
                }
            }
        }
        if(!(digits_seen)) 
        {
            if(!(tryParse)) 
            {
                exc = Int32::GetFormatException();
            }
            return false;
        }
        if((has_negative_sign && (val > 0U))) 
        {
            if(!(tryParse)) 
            {
                exc = cli::gcnew<OverflowException>(Locale::GetText(_T("Negative number")));
            }
            return false;
        }
        result = val;
        return true;
    }
    
    bool UInt32::Parse2(String* s, Globalization::NumberStyles style, IFormatProvider* provider, bool tryParse, uint32_t result, Exception* exc) {
        result = 0U;
        exc = nullptr;
        if((s ==  nullptr)) 
        {
            if(!(tryParse)) 
            {
                exc = cli::gcnew<ArgumentNullException>(_T("s"));
            }
            return false;
        }
        if((s->get_Length() ==  0)) 
        {
            if(!(tryParse)) 
            {
                exc = Int32::GetFormatException();
            }
            return false;
        }
        Globalization::NumberFormatInfo *nfi = nullptr;
        if((provider != nullptr)) 
        {
            Type *typeNFI = cli::typeof<Type>::info;
            nfi = cli::cast<Globalization::NumberFormatInfo*>(provider->GetFormat_b67414a65453cc7e(typeNFI));
        }
        if((nfi ==  nullptr)) 
        {
            nfi = Threading::Thread::get_CurrentThread()->get_CurrentCulture()->get_NumberFormat_56b6d54c07628932();
        }
        if(!(Int32::CheckStyle(style, tryParse, exc))) 
        {
            return false;
        }
        bool AllowCurrencySymbol = ((int32_t)(((int32_t)(style) & 256)) != 0);
        bool AllowHexSpecifier = ((int32_t)(((int32_t)(style) & 512)) != 0);
        bool AllowThousands = ((int32_t)(((int32_t)(style) & 64)) != 0);
        bool AllowDecimalPoint = ((int32_t)(((int32_t)(style) & 32)) != 0);
        bool AllowParentheses = ((int32_t)(((int32_t)(style) & 16)) != 0);
        bool AllowTrailingSign = ((int32_t)(((int32_t)(style) & 8)) != 0);
        bool AllowLeadingSign = ((int32_t)(((int32_t)(style) & 4)) != 0);
        bool AllowTrailingWhite = ((int32_t)(((int32_t)(style) & 2)) != 0);
        bool AllowLeadingWhite = ((int32_t)(((int32_t)(style) & 1)) != 0);
        bool AllowExponent = ((int32_t)(((int32_t)(style) & 128)) != 0);
        int32_t pos = 0;
        if((AllowLeadingWhite && !(Int32::JumpOverWhite(pos, s, true, tryParse, exc)))) 
        {
            return false;
        }
        bool foundOpenParentheses = false;
        bool negative = false;
        bool foundSign = false;
        bool foundCurrency = false;
        if((AllowParentheses && ((int32_t)(s->get_Chars(pos)) ==  40))) 
        {
            foundOpenParentheses = true;
            foundSign = true;
            negative = true;
            pos++;
            if((AllowLeadingWhite && !(Int32::JumpOverWhite(pos, s, true, tryParse, exc)))) 
            {
                return false;
            }
            if(String::op_Equality(s->Substring2(pos, nfi->get_NegativeSign()->get_Length()), nfi->get_NegativeSign())) 
            {
                if(!(tryParse)) 
                {
                    exc = Int32::GetFormatException();
                }
                return false;
            }
            if(String::op_Equality(s->Substring2(pos, nfi->get_PositiveSign()->get_Length()), nfi->get_PositiveSign())) 
            {
                if(!(tryParse)) 
                {
                    exc = Int32::GetFormatException();
                }
                return false;
            }
        }
        if((AllowLeadingSign && !(foundSign))) 
        {
            Int32::FindSign(pos, s, nfi, foundSign, negative);
            if(foundSign) 
            {
                if((AllowLeadingWhite && !(Int32::JumpOverWhite(pos, s, true, tryParse, exc)))) 
                {
                    return false;
                }
                if(AllowCurrencySymbol) 
                {
                    Int32::FindCurrency(pos, s, nfi, foundCurrency);
                    if(((foundCurrency && AllowLeadingWhite) && !(Int32::JumpOverWhite(pos, s, true, tryParse, exc)))) 
                    {
                        return false;
                    }
                }
            }
        }
        if((AllowCurrencySymbol && !(foundCurrency))) 
        {
            Int32::FindCurrency(pos, s, nfi, foundCurrency);
            if(foundCurrency) 
            {
                if((AllowLeadingWhite && !(Int32::JumpOverWhite(pos, s, true, tryParse, exc)))) 
                {
                    return false;
                }
                if(foundCurrency) 
                {
                    if((!(foundSign) && AllowLeadingSign)) 
                    {
                        Int32::FindSign(pos, s, nfi, foundSign, negative);
                        if(((foundSign && AllowLeadingWhite) && !(Int32::JumpOverWhite(pos, s, true, tryParse, exc)))) 
                        {
                            return false;
                        }
                    }
                }
            }
        }
        uint32_t number = 0U;
        int32_t nDigits = 0;
        bool decimalPointFound = false;
        uint32_t digitValue;
        char16_t hexDigit;
        int32_t exponent = 0;
        do {
            if(!(Int32::ValidDigit(s->get_Chars(pos), AllowHexSpecifier))) 
            {
                if((AllowThousands && (Int32::FindOther(pos, s, nfi->get_NumberGroupSeparator()) || Int32::FindOther(pos, s, nfi->get_CurrencyGroupSeparator())))) 
                {
                    continue;
                }
                 else 
                {
                    if(((!(decimalPointFound) && AllowDecimalPoint) && (Int32::FindOther(pos, s, nfi->get_NumberDecimalSeparator()) || Int32::FindOther(pos, s, nfi->get_CurrencyDecimalSeparator())))) 
                    {
                        decimalPointFound = true;
                        continue;
                    }
                }
                break;
            }
            if(AllowHexSpecifier) 
            {
                nDigits++;
                hexDigit = s->get_Chars(pos++);
                if(Char::IsDigit(hexDigit)) 
                {
                    digitValue = (uint32_t)((int32_t)(hexDigit) - 48);
                }
                 else 
                {
                    if(Char::IsLower(hexDigit)) 
                    {
                        digitValue = (uint32_t)(((int32_t)(hexDigit) - 97) + 10);
                    }
                     else 
                    {
                        digitValue = (uint32_t)(((int32_t)(hexDigit) - 65) + 10);
                    }
                }
                if(tryParse) 
                {
                    uint64_t l = (uint64_t)(((number * 16U) + digitValue));
                    if((l > 4294967295UL)) 
                    {
                        return false;
                    }
                    number = (uint32_t)l;
                }
                 else 
                {
                    number = cli::checked(((number * 16U) + digitValue));
                }
            }
             else 
            {
                if(decimalPointFound) 
                {
                    nDigits++;
                    if(((int32_t)(s->get_Chars(pos++)) != 48)) 
                    {
                        if(!(tryParse)) 
                        {
                            exc = cli::gcnew<OverflowException>(Locale::GetText(_T("Value too large or too small.")));
                        }
                        return false;
                    }
                }
                 else 
                {
                    nDigits++;
                    try {
                        number = cli::checked(((number * 10U) + (uint32_t)((int32_t)(s->get_Chars(pos++)) - 48)));
                    }
                    catch(OverflowException*) {
                        if(!(tryParse)) 
                        {
                            exc = cli::gcnew<OverflowException>(Locale::GetText(_T("Value too large or too small.")));
                        }
                        return false;
                    }
                }
            }
        }
        while((pos < s->get_Length()));
        if((nDigits ==  0)) 
        {
            if(!(tryParse)) 
            {
                exc = Int32::GetFormatException();
            }
            return false;
        }
        if(AllowExponent) 
        {
            if((Int32::FindExponent(pos, s, exponent, tryParse, exc) && (exc != nullptr))) 
            {
                return false;
            }
        }
        if((AllowTrailingSign && !(foundSign))) 
        {
            Int32::FindSign(pos, s, nfi, foundSign, negative);
            if((foundSign && (pos < s->get_Length()))) 
            {
                if((AllowTrailingWhite && !(Int32::JumpOverWhite(pos, s, true, tryParse, exc)))) 
                {
                    return false;
                }
            }
        }
        if((AllowCurrencySymbol && !(foundCurrency))) 
        {
            if(((AllowTrailingWhite && (pos < s->get_Length())) && !(Int32::JumpOverWhite(pos, s, false, tryParse, exc)))) 
            {
                return false;
            }
            Int32::FindCurrency(pos, s, nfi, foundCurrency);
            if((foundCurrency && (pos < s->get_Length()))) 
            {
                if((AllowTrailingWhite && !(Int32::JumpOverWhite(pos, s, true, tryParse, exc)))) 
                {
                    return false;
                }
                if((!(foundSign) && AllowTrailingSign)) 
                {
                    Int32::FindSign(pos, s, nfi, foundSign, negative);
                }
            }
        }
        if(((AllowTrailingWhite && (pos < s->get_Length())) && !(Int32::JumpOverWhite(pos, s, false, tryParse, exc)))) 
        {
            return false;
        }
        if(foundOpenParentheses) 
        {
            if(((pos >= s->get_Length()) || ((int32_t)(s->get_Chars(pos++)) != 41))) 
            {
                if(!(tryParse)) 
                {
                    exc = Int32::GetFormatException();
                }
                return false;
            }
            if(((AllowTrailingWhite && (pos < s->get_Length())) && !(Int32::JumpOverWhite(pos, s, false, tryParse, exc)))) 
            {
                return false;
            }
        }
        if(((pos < s->get_Length()) && ((int32_t)(s->get_Chars(pos)) != 0))) 
        {
            if(!(tryParse)) 
            {
                exc = Int32::GetFormatException();
            }
            return false;
        }
        if((negative && (number > 0U))) 
        {
            if(!(tryParse)) 
            {
                exc = cli::gcnew<OverflowException>(Locale::GetText(_T("Negative number")));
            }
            return false;
        }
        if((exponent > 0)) 
        {
            double res = cli::checked((Math::Pow(10., (double)(exponent)) * (double)(number)));
            if(((res < std::numeric_limits<double>::epsilon()) || (res > 2147483647.))) 
            {
                if(!(tryParse)) 
                {
                    exc = cli::gcnew<OverflowException>(_T("Value too large or too small."));
                }
                return false;
            }
            number = (uint32_t)res;
        }
        result = number;
        return true;
    }
    
    uint32_t UInt32::Parse3(String* s) {
        Exception *exc;
        uint32_t res;
        if(!(Parse(s, false, res, exc))) 
        {
            throw exc;
        }
        return res;
    }
    
    uint32_t UInt32::Parse4(String* s, Globalization::NumberStyles style, IFormatProvider* provider) {
        Exception *exc;
        uint32_t res;
        if(!(Parse2(s, style, provider, false, res, exc))) 
        {
            throw exc;
        }
        return res;
    }
    
    uint32_t UInt32::Parse5(String* s, IFormatProvider* provider) {
        return Parse4(s, Globalization::NumberStyles::Integer, provider);
    }
    
    uint32_t UInt32::Parse6(String* s, Globalization::NumberStyles style) {
        return Parse4(s, style, nullptr);
    }
    
    bool UInt32::TryParse(String* s, uint32_t result) {
        Exception *exc;
        if(!(Parse(s, true, result, exc))) 
        {
            result = 0U;
            return false;
        }
        return true;
    }
    
    bool UInt32::TryParse2(String* s, Globalization::NumberStyles style, IFormatProvider* provider, uint32_t result) {
        Exception *exc;
        if(!(Parse2(s, style, provider, true, result, exc))) 
        {
            result = 0U;
            return false;
        }
        return true;
    }
    
    String* UInt32::ToString_1636a0751cb9ac11() {
        return NumberFormatter::NumberToString12(cli::import((*this))->m_value, nullptr);
    }
    
    String* UInt32::ToString3(IFormatProvider* provider) {
        return NumberFormatter::NumberToString12(cli::import((*this))->m_value, provider);
    }
    
    String* UInt32::ToString4(String* format) {
        return ToString5(format, nullptr);
    }
    
    String* UInt32::ToString5(String* format, IFormatProvider* provider) {
        return NumberFormatter::NumberToString5(format, cli::import((*this))->m_value, provider);
    }
    
    TypeCode UInt32::GetTypeCode() {
        return TypeCode::UInt322;
    }
    
    bool UInt32::ToBoolean(IFormatProvider* provider) {
        return Convert::ToBoolean14(cli::import((*this))->m_value);
    }
    
    unsigned char UInt32::ToByte(IFormatProvider* provider) {
        return Convert::ToByte15(cli::import((*this))->m_value);
    }
    
    char16_t UInt32::ToChar(IFormatProvider* provider) {
        return Convert::ToChar14(cli::import((*this))->m_value);
    }
    
    DateTime UInt32::ToDateTime(IFormatProvider* provider) {
        return Convert::ToDateTime17(cli::import((*this))->m_value);
    }
    
    Decimal UInt32::ToDecimal(IFormatProvider* provider) {
        return Convert::ToDecimal14(cli::import((*this))->m_value);
    }
    
    double UInt32::ToDouble(IFormatProvider* provider) {
        return Convert::ToDouble14(cli::import((*this))->m_value);
    }
    
    int16_t UInt32::ToInt16(IFormatProvider* provider) {
        return Convert::ToInt1615(cli::import((*this))->m_value);
    }
    
    int32_t UInt32::ToInt32(IFormatProvider* provider) {
        return Convert::ToInt3215(cli::import((*this))->m_value);
    }
    
    int64_t UInt32::ToInt64(IFormatProvider* provider) {
        return Convert::ToInt6415(cli::import((*this))->m_value);
    }
    
    signed char UInt32::ToSByte(IFormatProvider* provider) {
        return Convert::ToSByte15(cli::import((*this))->m_value);
    }
    
    float UInt32::ToSingle(IFormatProvider* provider) {
        return Convert::ToSingle14(cli::import((*this))->m_value);
    }
    
    Object* UInt32::ToType(Type* targetType, IFormatProvider* provider) {
        if(Type::op_Equality2(targetType, nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("targetType"));
        }
        return Convert::ToType(cli::box(cli::import((*this))->m_value), targetType, provider, false);
    }
    
    uint16_t UInt32::ToUInt16(IFormatProvider* provider) {
        return Convert::ToUInt1615(cli::import((*this))->m_value);
    }
    
    uint32_t UInt32::ToUInt32(IFormatProvider* provider) {
        return cli::import((*this))->m_value;
    }
    
    uint64_t UInt32::ToUInt64(IFormatProvider* provider) {
        return Convert::ToUInt6415(cli::import((*this))->m_value);
    }
    
}
namespace System {
    
    
    int32_t UInt64::CompareTo(Object* value) {
        if((value ==  nullptr)) 
        {
            return 1;
        }
        if(!(cli::is<UInt64>(value))) 
        {
            throw cli::gcnew<ArgumentException>(Locale::GetText(_T("Value is not a System.UInt64.")));
        }
        uint64_t int64 = cli::unbox<uint64_t>(value);
        if((cli::import((*this))->m_value ==  int64)) 
        {
            return 0;
        }
        return (cli::import((*this))->m_value < int64) ? -1 : 1;
    }
    
    bool UInt64::Equals_ed975d2f4a7d193e(Object* obj) {
        if(!(cli::is<UInt64>(obj))) 
        {
            return false;
        }
        return (cli::unbox<uint64_t>(obj) ==  cli::import((*this))->m_value);
    }
    
    int32_t UInt64::GetHashCode_6648aef0f235ee6c() {
        return ((int32_t)(cli::import((*this))->m_value & 4294967295UL) ^ (int32_t)(cli::import((*this))->m_value >> 32));
    }
    
    int32_t UInt64::CompareTo2(uint64_t value) {
        if((cli::import((*this))->m_value ==  value)) 
        {
            return 0;
        }
        if((cli::import((*this))->m_value > value)) 
        {
            return 1;
        }
         else 
        {
            return -1;
        }
    }
    
    bool UInt64::Equals2(uint64_t obj) {
        return (obj ==  cli::import((*this))->m_value);
    }
    
    uint64_t UInt64::Parse(String* s) {
        Exception *exc;
        uint64_t result;
        if(!(Parse2(s, false, result, exc))) 
        {
            throw exc;
        }
        return result;
    }
    
    bool UInt64::Parse2(String* s, bool tryParse, uint64_t result, Exception* exc) {
        uint64_t val = 0UL;
        int32_t len;
        int32_t i;
        bool digits_seen = false;
        bool has_negative_sign = false;
        exc = nullptr;
        result = 0UL;
        if((s ==  nullptr)) 
        {
            if(!(tryParse)) 
            {
                exc = cli::gcnew<ArgumentNullException>(_T("s"));
            }
            return false;
        }
        len = s->get_Length();
        char16_t c;
        for(i = 0; (i < len); i++){
            c = s->get_Chars(i);
            if(!(Char::IsWhiteSpace(c))) 
            {
                break;
            }
        }
        if((i ==  len)) 
        {
            if(!(tryParse)) 
            {
                exc = Int32::GetFormatException();
            }
            return false;
        }
        if(((int32_t)(s->get_Chars(i)) ==  43)) 
        {
            i++;
        }
         else 
        {
            if(((int32_t)(s->get_Chars(i)) ==  45)) 
            {
                i++;
                has_negative_sign = true;
            }
        }
        for(; (i < len); i++){
            c = s->get_Chars(i);
            if((((int32_t)(c) >= 48) && ((int32_t)(c) <= 57))) 
            {
                uint32_t d = (uint32_t)((int32_t)(c) - 48);
                if(((val > 1844674407370955161UL) || ((val ==  1844674407370955161UL) && ((uint64_t)(d) > 5UL)))) 
                {
                    if(!(tryParse)) 
                    {
                        exc = cli::gcnew<OverflowException>(_T("Value is too large."));
                    }
                    return false;
                }
                val = ((val * 10UL) + (uint64_t)(d));
                digits_seen = true;
            }
             else 
            {
                if(!(Int32::ProcessTrailingWhitespace(tryParse, s, i, exc))) 
                {
                    return false;
                }
            }
        }
        if(!(digits_seen)) 
        {
            if(!(tryParse)) 
            {
                exc = Int32::GetFormatException();
            }
            return false;
        }
        if((has_negative_sign && (val > 0UL))) 
        {
            if(!(tryParse)) 
            {
                exc = cli::gcnew<OverflowException>(_T("Negative number."));
            }
            return false;
        }
        result = val;
        return true;
    }
    
    uint64_t UInt64::Parse3(String* s, IFormatProvider* provider) {
        return Parse6(s, Globalization::NumberStyles::Integer, provider);
    }
    
    uint64_t UInt64::Parse4(String* s, Globalization::NumberStyles style) {
        return Parse6(s, style, nullptr);
    }
    
    bool UInt64::Parse5(String* s, Globalization::NumberStyles style, IFormatProvider* provider, bool tryParse, uint64_t result, Exception* exc) {
        result = 0UL;
        exc = nullptr;
        if((s ==  nullptr)) 
        {
            if(!(tryParse)) 
            {
                exc = cli::gcnew<ArgumentNullException>(_T("s"));
            }
            return false;
        }
        if((s->get_Length() ==  0)) 
        {
            if(!(tryParse)) 
            {
                exc = Int32::GetFormatException();
            }
            return false;
        }
        Globalization::NumberFormatInfo *nfi = nullptr;
        if((provider != nullptr)) 
        {
            Type *typeNFI = cli::typeof<Type>::info;
            nfi = cli::cast<Globalization::NumberFormatInfo*>(provider->GetFormat_b67414a65453cc7e(typeNFI));
        }
        if((nfi ==  nullptr)) 
        {
            nfi = Threading::Thread::get_CurrentThread()->get_CurrentCulture()->get_NumberFormat_56b6d54c07628932();
        }
        if(!(Int32::CheckStyle(style, tryParse, exc))) 
        {
            return false;
        }
        bool AllowCurrencySymbol = ((int32_t)(((int32_t)(style) & 256)) != 0);
        bool AllowHexSpecifier = ((int32_t)(((int32_t)(style) & 512)) != 0);
        bool AllowThousands = ((int32_t)(((int32_t)(style) & 64)) != 0);
        bool AllowDecimalPoint = ((int32_t)(((int32_t)(style) & 32)) != 0);
        bool AllowParentheses = ((int32_t)(((int32_t)(style) & 16)) != 0);
        bool AllowTrailingSign = ((int32_t)(((int32_t)(style) & 8)) != 0);
        bool AllowLeadingSign = ((int32_t)(((int32_t)(style) & 4)) != 0);
        bool AllowTrailingWhite = ((int32_t)(((int32_t)(style) & 2)) != 0);
        bool AllowLeadingWhite = ((int32_t)(((int32_t)(style) & 1)) != 0);
        bool AllowExponent = ((int32_t)(((int32_t)(style) & 128)) != 0);
        int32_t pos = 0;
        if((AllowLeadingWhite && !(Int32::JumpOverWhite(pos, s, true, tryParse, exc)))) 
        {
            return false;
        }
        bool foundOpenParentheses = false;
        bool negative = false;
        bool foundSign = false;
        bool foundCurrency = false;
        if((AllowParentheses && ((int32_t)(s->get_Chars(pos)) ==  40))) 
        {
            foundOpenParentheses = true;
            foundSign = true;
            negative = true;
            pos++;
            if((AllowLeadingWhite && !(Int32::JumpOverWhite(pos, s, true, tryParse, exc)))) 
            {
                return false;
            }
            if(String::op_Equality(s->Substring2(pos, nfi->get_NegativeSign()->get_Length()), nfi->get_NegativeSign())) 
            {
                if(!(tryParse)) 
                {
                    exc = Int32::GetFormatException();
                }
                return false;
            }
            if(String::op_Equality(s->Substring2(pos, nfi->get_PositiveSign()->get_Length()), nfi->get_PositiveSign())) 
            {
                if(!(tryParse)) 
                {
                    exc = Int32::GetFormatException();
                }
                return false;
            }
        }
        if((AllowLeadingSign && !(foundSign))) 
        {
            Int32::FindSign(pos, s, nfi, foundSign, negative);
            if(foundSign) 
            {
                if((AllowLeadingWhite && !(Int32::JumpOverWhite(pos, s, true, tryParse, exc)))) 
                {
                    return false;
                }
                if(AllowCurrencySymbol) 
                {
                    Int32::FindCurrency(pos, s, nfi, foundCurrency);
                    if(((foundCurrency && AllowLeadingWhite) && !(Int32::JumpOverWhite(pos, s, true, tryParse, exc)))) 
                    {
                        return false;
                    }
                }
            }
        }
        if((AllowCurrencySymbol && !(foundCurrency))) 
        {
            Int32::FindCurrency(pos, s, nfi, foundCurrency);
            if(foundCurrency) 
            {
                if((AllowLeadingWhite && !(Int32::JumpOverWhite(pos, s, true, tryParse, exc)))) 
                {
                    return false;
                }
                if(foundCurrency) 
                {
                    if((!(foundSign) && AllowLeadingSign)) 
                    {
                        Int32::FindSign(pos, s, nfi, foundSign, negative);
                        if(((foundSign && AllowLeadingWhite) && !(Int32::JumpOverWhite(pos, s, true, tryParse, exc)))) 
                        {
                            return false;
                        }
                    }
                }
            }
        }
        uint64_t number = 0UL;
        int32_t nDigits = 0;
        bool decimalPointFound = false;
        uint64_t digitValue;
        char16_t hexDigit;
        int32_t exponent = 0;
        do {
            if(!(Int32::ValidDigit(s->get_Chars(pos), AllowHexSpecifier))) 
            {
                if((AllowThousands && (Int32::FindOther(pos, s, nfi->get_NumberGroupSeparator()) || Int32::FindOther(pos, s, nfi->get_CurrencyGroupSeparator())))) 
                {
                    continue;
                }
                 else 
                {
                    if(((!(decimalPointFound) && AllowDecimalPoint) && (Int32::FindOther(pos, s, nfi->get_NumberDecimalSeparator()) || Int32::FindOther(pos, s, nfi->get_CurrencyDecimalSeparator())))) 
                    {
                        decimalPointFound = true;
                        continue;
                    }
                }
                break;
            }
            if(AllowHexSpecifier) 
            {
                nDigits++;
                hexDigit = s->get_Chars(pos++);
                if(Char::IsDigit(hexDigit)) 
                {
                    digitValue = (uint64_t)((int32_t)(hexDigit) - 48);
                }
                 else 
                {
                    if(Char::IsLower(hexDigit)) 
                    {
                        digitValue = (uint64_t)(((int32_t)(hexDigit) - 97) + 10);
                    }
                     else 
                    {
                        digitValue = (uint64_t)(((int32_t)(hexDigit) - 65) + 10);
                    }
                }
                if(tryParse) 
                {
                    bool can_overflow = (number > 65535UL);
                    number = ((number * 16UL) + digitValue);
                    if((can_overflow && (number < 16UL))) 
                    {
                        return false;
                    }
                }
                 else 
                {
                    number = cli::checked(((number * 16UL) + digitValue));
                }
            }
             else 
            {
                if(decimalPointFound) 
                {
                    nDigits++;
                    if(((int32_t)(s->get_Chars(pos++)) != 48)) 
                    {
                        if(!(tryParse)) 
                        {
                            exc = cli::gcnew<OverflowException>(Locale::GetText(_T("Value too large or too small.")));
                        }
                        return false;
                    }
                }
                 else 
                {
                    nDigits++;
                    try {
                        number = cli::checked(((number * 10UL) + (uint64_t)((int32_t)(s->get_Chars(pos++)) - 48)));
                    }
                    catch(OverflowException*) {
                        if(!(tryParse)) 
                        {
                            exc = cli::gcnew<OverflowException>(Locale::GetText(_T("Value too large or too small.")));
                        }
                        return false;
                    }
                }
            }
        }
        while((pos < s->get_Length()));
        if((nDigits ==  0)) 
        {
            if(!(tryParse)) 
            {
                exc = Int32::GetFormatException();
            }
            return false;
        }
        if(AllowExponent) 
        {
            if((Int32::FindExponent(pos, s, exponent, tryParse, exc) && (exc != nullptr))) 
            {
                return false;
            }
        }
        if((AllowTrailingSign && !(foundSign))) 
        {
            Int32::FindSign(pos, s, nfi, foundSign, negative);
            if((foundSign && (pos < s->get_Length()))) 
            {
                if((AllowTrailingWhite && !(Int32::JumpOverWhite(pos, s, true, tryParse, exc)))) 
                {
                    return false;
                }
            }
        }
        if((AllowCurrencySymbol && !(foundCurrency))) 
        {
            if(((AllowTrailingWhite && (pos < s->get_Length())) && !(Int32::JumpOverWhite(pos, s, false, tryParse, exc)))) 
            {
                return false;
            }
            Int32::FindCurrency(pos, s, nfi, foundCurrency);
            if((foundCurrency && (pos < s->get_Length()))) 
            {
                if((AllowTrailingWhite && !(Int32::JumpOverWhite(pos, s, true, tryParse, exc)))) 
                {
                    return false;
                }
                if((!(foundSign) && AllowTrailingSign)) 
                {
                    Int32::FindSign(pos, s, nfi, foundSign, negative);
                }
            }
        }
        if(((AllowTrailingWhite && (pos < s->get_Length())) && !(Int32::JumpOverWhite(pos, s, false, tryParse, exc)))) 
        {
            return false;
        }
        if(foundOpenParentheses) 
        {
            if(((pos >= s->get_Length()) || ((int32_t)(s->get_Chars(pos++)) != 41))) 
            {
                if(!(tryParse)) 
                {
                    exc = Int32::GetFormatException();
                }
                return false;
            }
            if(((AllowTrailingWhite && (pos < s->get_Length())) && !(Int32::JumpOverWhite(pos, s, false, tryParse, exc)))) 
            {
                return false;
            }
        }
        if(((pos < s->get_Length()) && ((int32_t)(s->get_Chars(pos)) != 0))) 
        {
            if(!(tryParse)) 
            {
                exc = Int32::GetFormatException();
            }
            return false;
        }
        if((negative && (number > 0UL))) 
        {
            if(!(tryParse)) 
            {
                exc = cli::gcnew<OverflowException>(Locale::GetText(_T("Negative number")));
            }
            return false;
        }
        if((exponent > 0)) 
        {
            double res = cli::checked((Math::Pow(10., (double)(exponent)) * (double)(number)));
            if(((res < std::numeric_limits<double>::epsilon()) || (res > 2147483647.))) 
            {
                if(!(tryParse)) 
                {
                    exc = cli::gcnew<OverflowException>(_T("Value too large or too small."));
                }
                return false;
            }
            number = (uint64_t)res;
        }
        result = number;
        return true;
    }
    
    uint64_t UInt64::Parse6(String* s, Globalization::NumberStyles style, IFormatProvider* provider) {
        Exception *exc;
        uint64_t res;
        if(!(Parse5(s, style, provider, false, res, exc))) 
        {
            throw exc;
        }
        return res;
    }
    
    bool UInt64::TryParse(String* s, uint64_t result) {
        Exception *exc;
        if(!(Parse2(s, true, result, exc))) 
        {
            result = 0UL;
            return false;
        }
        return true;
    }
    
    bool UInt64::TryParse2(String* s, Globalization::NumberStyles style, IFormatProvider* provider, uint64_t result) {
        Exception *exc;
        if(!(Parse5(s, style, provider, true, result, exc))) 
        {
            result = 0UL;
            return false;
        }
        return true;
    }
    
    String* UInt64::ToString_1636a0751cb9ac11() {
        return NumberFormatter::NumberToString14(cli::import((*this))->m_value, nullptr);
    }
    
    String* UInt64::ToString3(IFormatProvider* provider) {
        return NumberFormatter::NumberToString14(cli::import((*this))->m_value, provider);
    }
    
    String* UInt64::ToString4(String* format) {
        return ToString5(format, nullptr);
    }
    
    String* UInt64::ToString5(String* format, IFormatProvider* provider) {
        return NumberFormatter::NumberToString7(format, cli::import((*this))->m_value, provider);
    }
    
    TypeCode UInt64::GetTypeCode() {
        return TypeCode::UInt642;
    }
    
    bool UInt64::ToBoolean(IFormatProvider* provider) {
        return Convert::ToBoolean15(cli::import((*this))->m_value);
    }
    
    unsigned char UInt64::ToByte(IFormatProvider* provider) {
        return Convert::ToByte16(cli::import((*this))->m_value);
    }
    
    char16_t UInt64::ToChar(IFormatProvider* provider) {
        return Convert::ToChar15(cli::import((*this))->m_value);
    }
    
    DateTime UInt64::ToDateTime(IFormatProvider* provider) {
        return Convert::ToDateTime18(cli::import((*this))->m_value);
    }
    
    Decimal UInt64::ToDecimal(IFormatProvider* provider) {
        return Convert::ToDecimal15(cli::import((*this))->m_value);
    }
    
    double UInt64::ToDouble(IFormatProvider* provider) {
        return Convert::ToDouble15(cli::import((*this))->m_value);
    }
    
    int16_t UInt64::ToInt16(IFormatProvider* provider) {
        return Convert::ToInt1616(cli::import((*this))->m_value);
    }
    
    int32_t UInt64::ToInt32(IFormatProvider* provider) {
        return Convert::ToInt3216(cli::import((*this))->m_value);
    }
    
    int64_t UInt64::ToInt64(IFormatProvider* provider) {
        return Convert::ToInt6416(cli::import((*this))->m_value);
    }
    
    signed char UInt64::ToSByte(IFormatProvider* provider) {
        return Convert::ToSByte16(cli::import((*this))->m_value);
    }
    
    float UInt64::ToSingle(IFormatProvider* provider) {
        return Convert::ToSingle15(cli::import((*this))->m_value);
    }
    
    Object* UInt64::ToType(Type* targetType, IFormatProvider* provider) {
        if(Type::op_Equality2(targetType, nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("targetType"));
        }
        return Convert::ToType(cli::box(cli::import((*this))->m_value), targetType, provider, false);
    }
    
    uint16_t UInt64::ToUInt16(IFormatProvider* provider) {
        return Convert::ToUInt1616(cli::import((*this))->m_value);
    }
    
    uint32_t UInt64::ToUInt32(IFormatProvider* provider) {
        return Convert::ToUInt3216(cli::import((*this))->m_value);
    }
    
    uint64_t UInt64::ToUInt64(IFormatProvider* provider) {
        return cli::import((*this))->m_value;
    }
    
}
namespace System {
    
    void**  UIntPtr::Zero;
    
    void UIntPtr::constructor(uint64_t value) {
        if(((value > 4294967295UL) && (UIntPtr::get_Size() < 8))) 
        {
            throw cli::gcnew<OverflowException>(Locale::GetText(_T("This isn\'t a 64bits machine.")));
        }
        cli::import((*this))->m_value = (void*)value;
    }
    
    void UIntPtr::constructor(uint32_t value) {
        cli::import((*this))->m_value = (void*)(value);
    }
    
    void UIntPtr::constructor(void* value) {
        cli::import((*this))->m_value = value;
    }
    
    void UIntPtr::static_constructor() {
    }
    
    bool UIntPtr::Equals_ed975d2f4a7d193e(Object* obj) {
        if(cli::is<UIntPtr>(obj)) 
        {
            void *obj2 = cli::unbox<void*>(obj);
            return (cli::import((*this))->m_value ==  cli::import(obj2)->m_value);
        }
        return false;
    }
    
    int32_t UIntPtr::GetHashCode_6648aef0f235ee6c() {
        return (int32_t)(cli::import((*this))->m_value);
    }
    
    uint32_t UIntPtr::ToUInt32() {
        return (uint32_t)(cli::import((*this))->m_value);
    }
    
    uint64_t UIntPtr::ToUInt64() {
        return (uint64_t)(cli::import((*this))->m_value);
    }
    
    void* UIntPtr::ToPointer() {
        return cli::import((*this))->m_value;
    }
    
    String* UIntPtr::ToString_1636a0751cb9ac11() {
        return cli::import((uint32_t)(cli::import((*this))->m_value))->ToString_1636a0751cb9ac11();
    }
    
    void UIntPtr::GetObjectData(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        if((info ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("info"));
        }
        info->AddValue15(_T("pointer"), (uint64_t)(cli::import((*this))->m_value));
    }
    
    void* UIntPtr::Add(void* pointer, int32_t offset) {
        return UIntPtr::op_Explicit4((void*)(cli::unchecked(((unsigned char*)((void*)pointer) + (int32_t)(offset)))));
    }
    
    void* UIntPtr::Subtract(void* pointer, int32_t offset) {
        return UIntPtr::op_Explicit4((void*)(cli::unchecked(((unsigned char*)((void*)pointer) - (int32_t)(offset)))));
    }
    
    bool UIntPtr::op_Equality(void* value1, void* value2) {
        return (cli::import(value1)->m_value ==  cli::import(value2)->m_value);
    }
    
    bool UIntPtr::op_Inequality(void* value1, void* value2) {
        return (cli::import(value1)->m_value != cli::import(value2)->m_value);
    }
    
    uint64_t UIntPtr::op_Explicit(void* value) {
        return (uint64_t)(cli::import(value)->m_value);
    }
    
    uint32_t UIntPtr::op_Explicit2(void* value) {
        return (uint32_t)(cli::import(value)->m_value);
    }
    
    void* UIntPtr::op_Explicit3(uint64_t value) {
        return cli::ctor<UIntPtr>(value);
    }
    
    void* UIntPtr::op_Explicit4(void* value) {
        return cli::ctor<UIntPtr>(value);
    }
    
    void* UIntPtr::op_Explicit5(void* value) {
        return cli::import(value)->ToPointer();
    }
    
    void* UIntPtr::op_Explicit6(uint32_t value) {
        return cli::ctor<UIntPtr>(value);
    }
    
    void* UIntPtr::op_Addition(void* pointer, int32_t offset) {
        return UIntPtr::op_Explicit4((void*)(cli::unchecked(((unsigned char*)((void*)pointer) + (int32_t)(offset)))));
    }
    
    void* UIntPtr::op_Subtraction(void* pointer, int32_t offset) {
        return UIntPtr::op_Explicit4((void*)(cli::unchecked(((unsigned char*)((void*)pointer) - (int32_t)(offset)))));
    }
    
    int32_t UIntPtr::get_Size() {
        return sizeof(::System::IntPtr);
    }
    
}
namespace System {
    
    
    void Variant::SetValue(Object* obj) {
        (*this)->vt = 0;
        if((obj ==  nullptr)) 
        {
            return;
        }
        Type *t = obj->GetType();
        if(t->get_IsEnum_bc85ea7b0a749db()) 
        {
            t = Enum::GetUnderlyingType(t);
        }
        if(Type::op_Equality2(t, cli::typeof<Type>::info)) 
        {
            (*this)->vt = 16;
            (*this)->cVal = cli::unbox<signed char>(obj);
        }
         else 
        {
            if(Type::op_Equality2(t, cli::typeof<Type>::info)) 
            {
                (*this)->vt = 17;
                (*this)->bVal = cli::unbox<unsigned char>(obj);
            }
             else 
            {
                if(Type::op_Equality2(t, cli::typeof<Type>::info)) 
                {
                    (*this)->vt = 2;
                    (*this)->iVal = cli::unbox<int16_t>(obj);
                }
                 else 
                {
                    if(Type::op_Equality2(t, cli::typeof<Type>::info)) 
                    {
                        (*this)->vt = 18;
                        (*this)->uiVal = cli::unbox<uint16_t>(obj);
                    }
                     else 
                    {
                        if(Type::op_Equality2(t, cli::typeof<Type>::info)) 
                        {
                            (*this)->vt = 3;
                            (*this)->lVal = cli::unbox<int32_t>(obj);
                        }
                         else 
                        {
                            if(Type::op_Equality2(t, cli::typeof<Type>::info)) 
                            {
                                (*this)->vt = 19;
                                (*this)->ulVal = cli::unbox<uint32_t>(obj);
                            }
                             else 
                            {
                                if(Type::op_Equality2(t, cli::typeof<Type>::info)) 
                                {
                                    (*this)->vt = 20;
                                    (*this)->llVal = cli::unbox<int64_t>(obj);
                                }
                                 else 
                                {
                                    if(Type::op_Equality2(t, cli::typeof<Type>::info)) 
                                    {
                                        (*this)->vt = 21;
                                        (*this)->ullVal = cli::unbox<uint64_t>(obj);
                                    }
                                     else 
                                    {
                                        if(Type::op_Equality2(t, cli::typeof<Type>::info)) 
                                        {
                                            (*this)->vt = 4;
                                            (*this)->fltVal = cli::unbox<float>(obj);
                                        }
                                         else 
                                        {
                                            if(Type::op_Equality2(t, cli::typeof<Type>::info)) 
                                            {
                                                (*this)->vt = 5;
                                                (*this)->dblVal = cli::unbox<double>(obj);
                                            }
                                             else 
                                            {
                                                if(Type::op_Equality2(t, cli::typeof<Type>::info)) 
                                                {
                                                    (*this)->vt = 8;
                                                    (*this)->bstrVal = Runtime::InteropServices::Marshal::StringToBSTR(cli::cast<String*>(obj));
                                                }
                                                 else 
                                                {
                                                    if(Type::op_Equality2(t, cli::typeof<Type>::info)) 
                                                    {
                                                        (*this)->vt = 11;
                                                        (*this)->lVal = cli::unbox<bool>(obj) ? -1 : 0;
                                                    }
                                                     else 
                                                    {
                                                        if(Type::op_Equality2(t, cli::typeof<Type>::info)) 
                                                        {
                                                            (*this)->vt = 8;
                                                            (*this)->bstrVal = Runtime::InteropServices::Marshal::StringToBSTR(cli::cast<Runtime::InteropServices::BStrWrapper*>(obj)->get_WrappedObject());
                                                        }
                                                         else 
                                                        {
                                                            if(Type::op_Equality2(t, cli::typeof<Type>::info)) 
                                                            {
                                                                (*this)->vt = 13;
                                                                (*this)->pdispVal = Runtime::InteropServices::Marshal::GetIUnknownForObject(cli::cast<Runtime::InteropServices::UnknownWrapper*>(obj)->get_WrappedObject());
                                                            }
                                                             else 
                                                            {
                                                                if(Type::op_Equality2(t, cli::typeof<Type>::info)) 
                                                                {
                                                                    (*this)->vt = 9;
                                                                    (*this)->pdispVal = Runtime::InteropServices::Marshal::GetIDispatchForObject(cli::cast<Runtime::InteropServices::DispatchWrapper*>(obj)->get_WrappedObject());
                                                                }
                                                                 else 
                                                                {
                                                                    try {
                                                                        (*this)->pdispVal = Runtime::InteropServices::Marshal::GetIDispatchForObject(obj);
                                                                        (*this)->vt = 9;
                                                                        return;
                                                                    }
                                                                    catch(...) {
                                                                    }
                                                                    try {
                                                                        (*this)->vt = 13;
                                                                        (*this)->pdispVal = Runtime::InteropServices::Marshal::GetIUnknownForObject(obj);
                                                                    }
                                                                    catch(Exception* ex) {
                                                                        throw cli::gcnew<NotImplementedException>(String::Format2(_T("Variant couldn\'t handle object of type {0}"), obj->GetType()), ex);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    
    Object* Variant::GetValue() {
        Object *obj = nullptr;
        switch((Runtime::InteropServices::VarEnum)((*this)->vt)) {
            case Runtime::InteropServices::VarEnum::VT_I1: case_69: {
                obj = cli::box((*this)->cVal);
                break;
            }
            case Runtime::InteropServices::VarEnum::VT_UI1: case_70: {
                obj = cli::box((*this)->bVal);
                break;
            }
            case Runtime::InteropServices::VarEnum::VT_I2: case_71: {
                obj = cli::box((*this)->iVal);
                break;
            }
            case Runtime::InteropServices::VarEnum::VT_UI2: case_72: {
                obj = cli::box((*this)->uiVal);
                break;
            }
            case Runtime::InteropServices::VarEnum::VT_I4: case_73: {
                obj = cli::box((*this)->lVal);
                break;
            }
            case Runtime::InteropServices::VarEnum::VT_UI4: case_74: {
                obj = cli::box((*this)->ulVal);
                break;
            }
            case Runtime::InteropServices::VarEnum::VT_I8: case_75: {
                obj = cli::box((*this)->llVal);
                break;
            }
            case Runtime::InteropServices::VarEnum::VT_UI8: case_76: {
                obj = cli::box((*this)->ullVal);
                break;
            }
            case Runtime::InteropServices::VarEnum::VT_R4: case_77: {
                obj = cli::box((*this)->fltVal);
                break;
            }
            case Runtime::InteropServices::VarEnum::VT_R8: case_78: {
                obj = cli::box((*this)->dblVal);
                break;
            }
            case Runtime::InteropServices::VarEnum::VT_BOOL: case_79: {
                obj = cli::box(!(((int32_t)((*this)->boolVal) ==  0)));
                break;
            }
            case Runtime::InteropServices::VarEnum::VT_BSTR: case_80: {
                obj = Runtime::InteropServices::Marshal::PtrToStringBSTR((*this)->bstrVal);
                break;
            }
            case Runtime::InteropServices::VarEnum::VT_UNKNOWN: case Runtime::InteropServices::VarEnum::VT_DISPATCH: case_81: {
                if(::System::IntPtr::op_Inequality((*this)->pdispVal, (*::System::IntPtr::Zero))) 
                {
                    obj = Runtime::InteropServices::Marshal::GetObjectForIUnknown((*this)->pdispVal);
                }
                break;
            }
        }
        return obj;
    }
    
    void Variant::Clear() {
        if(((int32_t)((*this)->vt) ==  8)) 
        {
            Runtime::InteropServices::Marshal::FreeBSTR((*this)->bstrVal);
        }
         else 
        {
            if((((int32_t)((*this)->vt) ==  9) || ((int32_t)((*this)->vt) ==  13))) 
            {
                if(::System::IntPtr::op_Inequality((*this)->pdispVal, (*::System::IntPtr::Zero))) 
                {
                    Runtime::InteropServices::Marshal::Release((*this)->pdispVal);
                }
            }
        }
    }
    
}
namespace System {
    
    
}
namespace System {
    
    
}
namespace System {
    
    
}
namespace System {
    
    
}
namespace System {
    
    
}
namespace System {
    
    
    void Coord::constructor(int32_t x, int32_t y) {
        (*this)->X = (int16_t)x;
        (*this)->Y = (int16_t)y;
    }
    
}
namespace System {
    
    
    void SmallRect::constructor(int32_t left, int32_t top, int32_t right, int32_t bottom) {
        (*this)->Left = (int16_t)left;
        (*this)->Top = (int16_t)top;
        (*this)->Right = (int16_t)right;
        (*this)->Bottom = (int16_t)bottom;
    }
    
}
namespace System {
    
    
}
namespace System { namespace Collections {
    
    
    void DictionaryEntry::constructor(System::Object* key, System::Object* value) {
        (*this)->_key = key;
        (*this)->_value = value;
    }
    
    System::Object* DictionaryEntry::get_Key() {
        return (*this)->_key;
    }
    
    System::Object* DictionaryEntry::set_Key(System::Object* value) {
        (*this)->_key = value;
        return get_Key();
    }
    
    System::Object* DictionaryEntry::get_Value() {
        return (*this)->_value;
    }
    
    System::Object* DictionaryEntry::set_Value(System::Object* value) {
        (*this)->_value = value;
        return get_Value();
    }
    
}}
namespace System { namespace Collections {
    
    
}}
namespace System { namespace Collections {
    
    
}}
namespace System { namespace Collections { namespace Concurrent {
    
    
}}}
namespace System { namespace Collections { namespace Generic {
    
    
}}}
namespace System { namespace Collections { namespace Generic {
    
    
}}}
namespace System { namespace Collections { namespace Generic {
    
    
}}}
namespace System { namespace Collections { namespace Generic {
    
    
}}}
namespace System { namespace Collections { namespace Generic {
    
    
}}}
namespace System { namespace Collections { namespace Generic {
    
    
}}}
namespace System { namespace Configuration { namespace Assemblies {
    
    AssemblyHash*  AssemblyHash::Empty;
    
    void AssemblyHash::constructor(AssemblyHashAlgorithm algorithm, cli::array<unsigned char>* value) {
        (*this)->_algorithm = algorithm;
        if((value != nullptr)) 
        {
            (*this)->_value = cli::cast<cli::array<unsigned char>*>(cli::import(value)->Clone());
        }
         else 
        {
            (*this)->_value = nullptr;
        }
    }
    
    void AssemblyHash::constructor(cli::array<unsigned char>* value) {
    }
    
    void AssemblyHash::static_constructor() {
    }
    
    System::Object* AssemblyHash::Clone() {
        return cli::box(cli::ctor<AssemblyHash>((*this)->_algorithm, (*this)->_value));
    }
    
    cli::array<unsigned char>* AssemblyHash::GetValue() {
        return (*this)->_value;
    }
    
    void AssemblyHash::SetValue(cli::array<unsigned char>* value) {
        (*this)->_value = value;
    }
    
    AssemblyHashAlgorithm AssemblyHash::get_Algorithm() {
        return (*this)->_algorithm;
    }
    
    AssemblyHashAlgorithm AssemblyHash::set_Algorithm(AssemblyHashAlgorithm value) {
        (*this)->_algorithm = value;
        return get_Algorithm();
    }
    
}}}
namespace System { namespace Diagnostics { namespace SymbolStore {
    
    
    void SymbolToken::constructor(int32_t val) {
        (*this)->_val = val;
    }
    
    bool SymbolToken::Equals_ed975d2f4a7d193e(System::Object* obj) {
        if(!(cli::is<SymbolToken>(obj))) 
        {
            return false;
        }
        return (cli::unbox<SymbolToken>(obj)->GetToken() ==  (*this)->_val);
    }
    
    bool SymbolToken::Equals2(SymbolToken obj) {
        return (obj->GetToken() ==  (*this)->_val);
    }
    
    int32_t SymbolToken::GetHashCode_6648aef0f235ee6c() {
        return cli::import((*this)->_val)->GetHashCode_6648aef0f235ee6c();
    }
    
    int32_t SymbolToken::GetToken() {
        return (*this)->_val;
    }
    
    bool SymbolToken::op_Equality(SymbolToken a, SymbolToken b) {
        return a->Equals2(b);
    }
    
    bool SymbolToken::op_Inequality(SymbolToken a, SymbolToken b) {
        return !(a->Equals2(b));
    }
    
}}}
namespace System { namespace Globalization {
    
    
    void Era::constructor(int32_t nr, int32_t start, int32_t end) {
        if((nr ==  0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Era number shouldn\'t be zero."));
        }
        (*this)->_nr = nr;
        if((start > end)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Era should start before end."));
        }
        (*this)->_start = start;
        (*this)->_end = end;
        (*this)->_gregorianYearStart = CCGregorianCalendar::year_from_fixed((*this)->_start);
        int32_t gregorianYearEnd = CCGregorianCalendar::year_from_fixed((*this)->_end);
        (*this)->_maxYear = ((gregorianYearEnd - (*this)->_gregorianYearStart) + 1);
    }
    
    int32_t Era::GregorianYear(int32_t year) {
        if(((year < 1) || (year > (*this)->_maxYear))) 
        {
            System::IO::StringWriter *sw = cli::gcnew<System::IO::StringWriter>();
            sw->Write_d1ec280d8f085d73(_T("Valid Values are between {0} and {1}, inclusive."), cli::box(1), cli::box((*this)->_maxYear));
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("year"), sw->ToString_1636a0751cb9ac11());
        }
        return ((year + (*this)->_gregorianYearStart) - 1);
    }
    
    bool Era::Covers(int32_t date) {
        return (((*this)->_start <= date) && (date <= (*this)->_end));
    }
    
    int32_t Era::EraYear(int32_t era, int32_t date) {
        if(!(Covers(date))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("date"), _T("Time was out of Era range."));
        }
        int32_t gregorianYear = CCGregorianCalendar::year_from_fixed(date);
        era = (*this)->_nr;
        return ((gregorianYear - (*this)->_gregorianYearStart) + 1);
    }
    
    int32_t Era::get_Nr() {
        return (*this)->_nr;
    }
    
}}
namespace System { namespace Globalization {
    
    
    void Era2::constructor(int32_t nr, int32_t start, int32_t end) {
        if((nr ==  0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Era number shouldn\'t be zero."));
        }
        (*this)->_nr = nr;
        if((start > end)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Era should start before end."));
        }
        (*this)->_start = start;
        (*this)->_end = end;
        (*this)->_gregorianYearStart = CCGregorianCalendar::year_from_fixed((*this)->_start);
        int32_t gregorianYearEnd = CCGregorianCalendar::year_from_fixed((*this)->_end);
        (*this)->_maxYear = ((gregorianYearEnd - (*this)->_gregorianYearStart) + 1);
    }
    
    int32_t Era2::GregorianYear(int32_t year) {
        if(((year < 1) || (year > (*this)->_maxYear))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("year"), System::String::Format3(_T("Valid Values are between {0} and {1}, inclusive."), cli::box(1), cli::box((*this)->_maxYear)));
        }
        return ((year + (*this)->_gregorianYearStart) - 1);
    }
    
    bool Era2::Covers(int32_t date) {
        return (((*this)->_start <= date) && (date <= (*this)->_end));
    }
    
    int32_t Era2::EraYear(int32_t era, int32_t date) {
        if(!(Covers(date))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("date"), _T("Time was out of Era range."));
        }
        int32_t gregorianYear = CCGregorianCalendar::year_from_fixed(date);
        era = (*this)->_nr;
        return ((gregorianYear - (*this)->_gregorianYearStart) + 1);
    }
    
    int32_t Era2::get_Nr() {
        return (*this)->_nr;
    }
    
}}
namespace System { namespace Globalization {
    
    
}}
namespace System { namespace IO {
    
    
}}
namespace System { namespace IO { namespace IsolatedStorage {
    
    
    void Identities::constructor(System::Object* application, System::Object* assembly, System::Object* domain) {
        (*this)->Application = application;
        (*this)->Assembly2 = assembly;
        (*this)->Domain = domain;
    }
    
}}}
namespace System { namespace Reflection {
    
    
    void CustomAttributeNamedArgument::constructor(MemberInfo* memberInfo, System::Object* value) {
        (*this)->memberInfo = memberInfo;
        (*this)->typedArgument = cli::unbox<CustomAttributeTypedArgument>(value);
    }
    
    void CustomAttributeNamedArgument::constructor(MemberInfo* memberInfo, CustomAttributeTypedArgument typedArgument) {
        (*this)->memberInfo = memberInfo;
        (*this)->typedArgument = typedArgument;
    }
    
    System::String* CustomAttributeNamedArgument::ToString_1636a0751cb9ac11() {
        return cli::concat((*this)->memberInfo->get_Name_50fad5fa936c3ae2(), _T(" = "));
    }
    
    bool CustomAttributeNamedArgument::Equals_ed975d2f4a7d193e(System::Object* obj) {
        if(!(cli::is<CustomAttributeNamedArgument>(obj))) 
        {
            return false;
        }
        CustomAttributeNamedArgument other = cli::unbox<CustomAttributeNamedArgument>(obj);
        return (MemberInfo::op_Equality(other->memberInfo, (*this)->memberInfo) && (*this)->typedArgument->Equals_ed975d2f4a7d193e(cli::box(other->typedArgument)));
    }
    
    int32_t CustomAttributeNamedArgument::GetHashCode_6648aef0f235ee6c() {
        return (((*this)->memberInfo->GetHashCode_6648aef0f235ee6c() << 16) + (*this)->typedArgument->GetHashCode_6648aef0f235ee6c());
    }
    
    bool CustomAttributeNamedArgument::op_Equality(CustomAttributeNamedArgument left, CustomAttributeNamedArgument right) {
        return left->Equals_ed975d2f4a7d193e(cli::box(right));
    }
    
    bool CustomAttributeNamedArgument::op_Inequality(CustomAttributeNamedArgument left, CustomAttributeNamedArgument right) {
        return !(left->Equals_ed975d2f4a7d193e(cli::box(right)));
    }
    
    MemberInfo* CustomAttributeNamedArgument::get_MemberInfo() {
        return (*this)->memberInfo;
    }
    
    CustomAttributeTypedArgument CustomAttributeNamedArgument::get_TypedValue() {
        return (*this)->typedArgument;
    }
    
}}
namespace System { namespace Reflection {
    
    
    void CustomAttributeTypedArgument::constructor(System::Type* argumentType, System::Object* value) {
        if(System::Type::op_Equality2(argumentType, nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("argumentType"));
        }
        (*this)->argumentType = argumentType;
        (*this)->value = value;
        if(cli::is<System::Array>(value)) 
        {
            System::Array *a = cli::cast<System::Array*>(value);
            System::Type *etype = a->GetType()->GetElementType_ab5070dbbfe66f5f();
            cli::array<CustomAttributeTypedArgument> *new_value = (new cli::array<CustomAttributeTypedArgument>(a->GetLength(0)));
            for(int32_t i = 0; (i < new_value->get_Length()); ++i) {
                new_value->at(i) = cli::ctor<CustomAttributeTypedArgument>(etype, a->GetValue2(i));
            }
            (*this)->value = cli::gcnew<System::Collections::ObjectModel::ReadOnlyCollection<CustomAttributeTypedArgument>>(new_value);
        }
    }
    
    void CustomAttributeTypedArgument::constructor(System::Object* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("value"));
        }
        (*this)->argumentType = value->GetType();
        (*this)->value = value;
    }
    
    System::String* CustomAttributeTypedArgument::ToString_1636a0751cb9ac11() {
        System::String *val = ((*this)->value != nullptr) ? (*this)->value->ToString_1636a0751cb9ac11() : System::String::Empty;
        if(System::Type::op_Equality2((*this)->argumentType, cli::typeof<System::Type>::info)) 
        {
            return cli::concat(_T("\""), val);
        }
        if(System::Type::op_Equality2((*this)->argumentType, cli::typeof<System::Type>::info)) 
        {
            return cli::concat(_T("typeof ("), val);
        }
        if((*this)->argumentType->get_IsEnum_bc85ea7b0a749db()) 
        {
            return cli::concat(_T("("), (*this)->argumentType->get_Name_50fad5fa936c3ae2());
        }
        return val;
    }
    
    bool CustomAttributeTypedArgument::Equals_ed975d2f4a7d193e(System::Object* obj) {
        if(!(cli::is<CustomAttributeTypedArgument>(obj))) 
        {
            return false;
        }
        CustomAttributeTypedArgument other = cli::unbox<CustomAttributeTypedArgument>(obj);
        return (System::Type::op_Equality2(other->argumentType, (*this)->argumentType) && ((*this)->value != nullptr)) ? (*this)->value->Equals_ed975d2f4a7d193e(other->value) : (cli::cast<System::Object*>(other->value) ==  nullptr);
    }
    
    int32_t CustomAttributeTypedArgument::GetHashCode_6648aef0f235ee6c() {
        return (((*this)->argumentType->GetHashCode_6648aef0f235ee6c() << 16) + ((*this)->value != nullptr) ? (*this)->value->GetHashCode_6648aef0f235ee6c() : 0);
    }
    
    bool CustomAttributeTypedArgument::op_Equality(CustomAttributeTypedArgument left, CustomAttributeTypedArgument right) {
        return left->Equals_ed975d2f4a7d193e(cli::box(right));
    }
    
    bool CustomAttributeTypedArgument::op_Inequality(CustomAttributeTypedArgument left, CustomAttributeTypedArgument right) {
        return !(left->Equals_ed975d2f4a7d193e(cli::box(right)));
    }
    
    System::Type* CustomAttributeTypedArgument::get_ArgumentType() {
        return (*this)->argumentType;
    }
    
    System::Object* CustomAttributeTypedArgument::get_Value() {
        return (*this)->value;
    }
    
}}
namespace System { namespace Reflection {
    
    
}}
namespace System { namespace Reflection {
    
    
    void MonoEventInfo::get_event_info(MonoEvent* ev, MonoEventInfo info) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    MonoEventInfo MonoEventInfo::GetEventInfo(MonoEvent* ev) {
        MonoEventInfo mei;
        MonoEventInfo::get_event_info(ev, mei);
        return mei;
    }
    
}}
namespace System { namespace Reflection {
    
    
    void MonoMethodInfo::get_method_info(void* handle, MonoMethodInfo info) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t MonoMethodInfo::get_method_attributes(void* handle) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    MonoMethodInfo MonoMethodInfo::GetMethodInfo(void* handle) {
        MonoMethodInfo info;
        MonoMethodInfo::get_method_info(handle, info);
        return info;
    }
    
    System::Type* MonoMethodInfo::GetDeclaringType(void* handle) {
        return GetMethodInfo(handle)->parent;
    }
    
    System::Type* MonoMethodInfo::GetReturnType(void* handle) {
        return GetMethodInfo(handle)->ret;
    }
    
    MethodAttributes MonoMethodInfo::GetAttributes(void* handle) {
        return (MethodAttributes)(get_method_attributes(handle));
    }
    
    CallingConventions MonoMethodInfo::GetCallingConvention(void* handle) {
        return GetMethodInfo(handle)->callconv;
    }
    
    MethodImplAttributes MonoMethodInfo::GetMethodImplementationFlags(void* handle) {
        return GetMethodInfo(handle)->iattrs;
    }
    
    cli::array<ParameterInfo*>* MonoMethodInfo::get_parameter_info(void* handle, MemberInfo* member) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    cli::array<ParameterInfo*>* MonoMethodInfo::GetParametersInfo(void* handle, MemberInfo* member) {
        return get_parameter_info(handle, member);
    }
    
    Emit::UnmanagedMarshal* MonoMethodInfo::get_retval_marshal(void* handle) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    ParameterInfo* MonoMethodInfo::GetReturnParameterInfo(MonoMethod* method) {
        return cli::gcnew<ParameterInfo>(GetReturnType(method->mhandle), method, get_retval_marshal(method->mhandle));
    }
    
}}
namespace System { namespace Reflection {
    
    
    void MonoPropertyInfo::get_property_info(MonoProperty* prop, MonoPropertyInfo info, PInfo req_info) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    cli::array<System::Type*>* MonoPropertyInfo::GetTypeModifiers(MonoProperty* prop, bool optional) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    System::Object* MonoPropertyInfo::get_default_value(MonoProperty* prop) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
}}
namespace System { namespace Reflection {
    
    
    void ParameterModifier::constructor(int32_t parameterCount) {
        if((parameterCount <= 0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Must specify one or more parameters."));
        }
        (*this)->_byref = (new cli::array<bool>(parameterCount));
    }
    
    bool ParameterModifier::get_Item(int32_t index) {
        return (*this)->_byref->at(index);
    }
    
    bool ParameterModifier::set_Item(int32_t index, bool value) {
        (*this)->_byref->at(index) = value;
        return get_Item(index);
    }
    
}}
namespace System { namespace Reflection { namespace Emit {
    
    
    void RefEmitPermissionSet::constructor(System::Security::Permissions::SecurityAction action, System::String* pset) {
        (*this)->action = action;
        (*this)->pset = pset;
    }
    
}}}
namespace System { namespace Reflection { namespace Emit {
    
    
}}}
namespace System { namespace Reflection { namespace Emit {
    
    
    void MonoWin32Resource::constructor(int32_t res_type, int32_t res_id, int32_t lang_id, cli::array<unsigned char>* data) {
        (*this)->res_type = res_type;
        (*this)->res_id = res_id;
        (*this)->lang_id = lang_id;
        (*this)->data = data;
    }
    
}}}
namespace System { namespace Reflection { namespace Emit {
    
    
}}}
namespace System { namespace Reflection { namespace Emit {
    
    EventToken*  EventToken::Empty;
    
    void EventToken::static_constructor() {
        (*Empty) = cli::ctor<EventToken>();
    }
    
    void EventToken::constructor(int32_t val) {
        (*this)->tokValue = val;
    }
    
    bool EventToken::Equals_ed975d2f4a7d193e(System::Object* obj) {
        bool res = cli::is<EventToken>(obj);
        if(res) 
        {
            EventToken that = cli::unbox<EventToken>(obj);
            res = ((*this)->tokValue ==  that->tokValue);
        }
        return res;
    }
    
    bool EventToken::Equals2(EventToken obj) {
        return ((*this)->tokValue ==  obj->tokValue);
    }
    
    int32_t EventToken::GetHashCode_6648aef0f235ee6c() {
        return (*this)->tokValue;
    }
    
    bool EventToken::op_Equality(EventToken a, EventToken b) {
        return System::Object::Equals2(cli::box(a), cli::box(b));
    }
    
    bool EventToken::op_Inequality(EventToken a, EventToken b) {
        return !(System::Object::Equals2(cli::box(a), cli::box(b)));
    }
    
    int32_t EventToken::get_Token() {
        return (*this)->tokValue;
    }
    
}}}
namespace System { namespace Reflection { namespace Emit {
    
    FieldToken*  FieldToken::Empty;
    
    void FieldToken::static_constructor() {
        (*Empty) = cli::ctor<FieldToken>();
    }
    
    void FieldToken::constructor(int32_t val) {
        (*this)->tokValue = val;
    }
    
    bool FieldToken::Equals_ed975d2f4a7d193e(System::Object* obj) {
        bool res = cli::is<FieldToken>(obj);
        if(res) 
        {
            FieldToken that = cli::unbox<FieldToken>(obj);
            res = ((*this)->tokValue ==  that->tokValue);
        }
        return res;
    }
    
    bool FieldToken::Equals2(FieldToken obj) {
        return ((*this)->tokValue ==  obj->tokValue);
    }
    
    int32_t FieldToken::GetHashCode_6648aef0f235ee6c() {
        return (*this)->tokValue;
    }
    
    bool FieldToken::op_Equality(FieldToken a, FieldToken b) {
        return System::Object::Equals2(cli::box(a), cli::box(b));
    }
    
    bool FieldToken::op_Inequality(FieldToken a, FieldToken b) {
        return !(System::Object::Equals2(cli::box(a), cli::box(b)));
    }
    
    int32_t FieldToken::get_Token() {
        return (*this)->tokValue;
    }
    
}}}
namespace System { namespace Reflection { namespace Emit {
    
    
    void ILExceptionBlock::Debug() {
    }
    
}}}
namespace System { namespace Reflection { namespace Emit {
    
    
    int32_t ILExceptionInfo::NumHandlers() {
        return (*this)->handlers->get_Length();
    }
    
    void ILExceptionInfo::AddCatch(System::Type* extype, int32_t offset) {
        int32_t i;
        End(offset);
        add_block(offset);
        i = ((*this)->handlers->get_Length() - 1);
        (*this)->handlers->at(i)->type = 0;
        (*this)->handlers->at(i)->start = offset;
        (*this)->handlers->at(i)->extype = extype;
    }
    
    void ILExceptionInfo::AddFinally(int32_t offset) {
        int32_t i;
        End(offset);
        add_block(offset);
        i = ((*this)->handlers->get_Length() - 1);
        (*this)->handlers->at(i)->type = 2;
        (*this)->handlers->at(i)->start = offset;
        (*this)->handlers->at(i)->extype = nullptr;
    }
    
    void ILExceptionInfo::AddFault(int32_t offset) {
        int32_t i;
        End(offset);
        add_block(offset);
        i = ((*this)->handlers->get_Length() - 1);
        (*this)->handlers->at(i)->type = 4;
        (*this)->handlers->at(i)->start = offset;
        (*this)->handlers->at(i)->extype = nullptr;
    }
    
    void ILExceptionInfo::AddFilter(int32_t offset) {
        int32_t i;
        End(offset);
        add_block(offset);
        i = ((*this)->handlers->get_Length() - 1);
        (*this)->handlers->at(i)->type = -1;
        (*this)->handlers->at(i)->extype = nullptr;
        (*this)->handlers->at(i)->filter_offset = offset;
    }
    
    void ILExceptionInfo::End(int32_t offset) {
        if(((*this)->handlers ==  nullptr)) 
        {
            return;
        }
        int32_t i = ((*this)->handlers->get_Length() - 1);
        if((i >= 0)) 
        {
            (*this)->handlers->at(i)->len = (offset - (*this)->handlers->at(i)->start);
        }
    }
    
    int32_t ILExceptionInfo::LastClauseType() {
        if(((*this)->handlers != nullptr)) 
        {
            return (*this)->handlers->at(((*this)->handlers->get_Length() - 1))->type;
        }
         else 
        {
            return 0;
        }
    }
    
    void ILExceptionInfo::PatchFilterClause(int32_t start) {
        if((((*this)->handlers != nullptr) && ((*this)->handlers->get_Length() > 0))) 
        {
            (*this)->handlers->at(((*this)->handlers->get_Length() - 1))->start = start;
            (*this)->handlers->at(((*this)->handlers->get_Length() - 1))->type = 1;
        }
    }
    
    void ILExceptionInfo::Debug(int32_t b) {
    }
    
    void ILExceptionInfo::add_block(int32_t offset) {
        if(((*this)->handlers != nullptr)) 
        {
            int32_t i = (*this)->handlers->get_Length();
            cli::array<ILExceptionBlock> *new_b = (new cli::array<ILExceptionBlock>((i + 1)));
            System::Array::Copy((*this)->handlers, new_b, i);
            (*this)->handlers = new_b;
            (*this)->handlers->at(i)->len = (offset - (*this)->handlers->at(i)->start);
        }
         else 
        {
            (*this)->handlers = (new cli::array<ILExceptionBlock>(1));
            (*this)->len = (offset - (*this)->start);
        }
    }
    
}}}
namespace System { namespace Reflection { namespace Emit {
    
    
}}}
namespace System { namespace Reflection { namespace Emit {
    
    
}}}
namespace System { namespace Reflection { namespace Emit {
    
    
    void LabelData::constructor(int32_t addr, int32_t maxStack) {
        (*this)->addr = addr;
        (*this)->maxStack = maxStack;
    }
    
}}}
namespace System { namespace Reflection { namespace Emit {
    
    
}}}
namespace System { namespace Reflection { namespace Emit {
    
    
    void Label::constructor(int32_t val) {
        (*this)->label = val;
    }
    
    bool Label::Equals_ed975d2f4a7d193e(System::Object* obj) {
        bool res = cli::is<Label>(obj);
        if(res) 
        {
            Label l = cli::unbox<Label>(obj);
            res = ((*this)->label ==  l->label);
        }
        return res;
    }
    
    bool Label::Equals2(Label obj) {
        return ((*this)->label ==  obj->label);
    }
    
    int32_t Label::GetHashCode_6648aef0f235ee6c() {
        return cli::import((*this)->label)->GetHashCode_6648aef0f235ee6c();
    }
    
    bool Label::op_Equality(Label a, Label b) {
        return a->Equals2(b);
    }
    
    bool Label::op_Inequality(Label a, Label b) {
        return !(op_Equality(a, b));
    }
    
}}}
namespace System { namespace Reflection { namespace Emit {
    
    MethodToken*  MethodToken::Empty;
    
    void MethodToken::static_constructor() {
        (*Empty) = cli::ctor<MethodToken>();
    }
    
    void MethodToken::constructor(int32_t val) {
        (*this)->tokValue = val;
    }
    
    bool MethodToken::Equals_ed975d2f4a7d193e(System::Object* obj) {
        bool res = cli::is<MethodToken>(obj);
        if(res) 
        {
            MethodToken that = cli::unbox<MethodToken>(obj);
            res = ((*this)->tokValue ==  that->tokValue);
        }
        return res;
    }
    
    bool MethodToken::Equals2(MethodToken obj) {
        return ((*this)->tokValue ==  obj->tokValue);
    }
    
    int32_t MethodToken::GetHashCode_6648aef0f235ee6c() {
        return (*this)->tokValue;
    }
    
    bool MethodToken::op_Equality(MethodToken a, MethodToken b) {
        return System::Object::Equals2(cli::box(a), cli::box(b));
    }
    
    bool MethodToken::op_Inequality(MethodToken a, MethodToken b) {
        return !(System::Object::Equals2(cli::box(a), cli::box(b)));
    }
    
    int32_t MethodToken::get_Token() {
        return (*this)->tokValue;
    }
    
}}}
namespace System { namespace Reflection { namespace Emit {
    
    
    void OpCode::constructor(int32_t p, int32_t q) {
        (*this)->op1 = (unsigned char)(p & 255);
        (*this)->op2 = (unsigned char)((p >> 8) & 255);
        (*this)->push = (unsigned char)((p >> 16) & 255);
        (*this)->pop = (unsigned char)((p >> 24) & 255);
        (*this)->size = (unsigned char)(q & 255);
        (*this)->type = (unsigned char)((q >> 8) & 255);
        (*this)->args = (unsigned char)((q >> 16) & 255);
        (*this)->flow = (unsigned char)((q >> 24) & 255);
    }
    
    int32_t OpCode::GetHashCode_6648aef0f235ee6c() {
        return (*this)->get_Name()->GetHashCode_6648aef0f235ee6c();
    }
    
    bool OpCode::Equals_ed975d2f4a7d193e(System::Object* obj) {
        if(((obj ==  nullptr) || !(cli::is<OpCode>(obj)))) 
        {
            return false;
        }
        OpCode v = cli::unbox<OpCode>(obj);
        return (((int32_t)(v->op1) ==  (int32_t)((*this)->op1)) && ((int32_t)(v->op2) ==  (int32_t)((*this)->op2)));
    }
    
    bool OpCode::Equals2(OpCode obj) {
        return (((int32_t)(obj->op1) ==  (int32_t)((*this)->op1)) && ((int32_t)(obj->op2) ==  (int32_t)((*this)->op2)));
    }
    
    System::String* OpCode::ToString_1636a0751cb9ac11() {
        return (*this)->get_Name();
    }
    
    bool OpCode::op_Equality(OpCode a, OpCode b) {
        return (((int32_t)(a->op1) ==  (int32_t)(b->op1)) && ((int32_t)(a->op2) ==  (int32_t)(b->op2)));
    }
    
    bool OpCode::op_Inequality(OpCode a, OpCode b) {
        return (((int32_t)(a->op1) != (int32_t)(b->op1)) || ((int32_t)(a->op2) != (int32_t)(b->op2)));
    }
    
    System::String* OpCode::get_Name() {
        if(((int32_t)((*this)->op1) ==  255)) 
        {
            return OpCodeNames::names->at((int32_t)((*this)->op2));
        }
        return OpCodeNames::names->at((256 + (int32_t)((*this)->op2)));
    }
    
    int32_t OpCode::get_Size() {
        return (int32_t)((*this)->size);
    }
    
    OpCodeType OpCode::get_OpCodeType() {
        return (OpCodeType)((*this)->type);
    }
    
    OperandType OpCode::get_OperandType() {
        return (OperandType)((*this)->args);
    }
    
    FlowControl OpCode::get_FlowControl() {
        return (FlowControl)((*this)->flow);
    }
    
    StackBehaviour OpCode::get_StackBehaviourPop() {
        return (StackBehaviour)((*this)->pop);
    }
    
    StackBehaviour OpCode::get_StackBehaviourPush() {
        return (StackBehaviour)((*this)->push);
    }
    
    int16_t OpCode::get_Value() {
        if(((int32_t)((*this)->size) ==  1)) 
        {
            return (int16_t)((*this)->op2);
        }
         else 
        {
            return (int16_t)(((int32_t)((*this)->op1) << 8) | (int32_t)((*this)->op2));
        }
    }
    
}}}
namespace System { namespace Reflection { namespace Emit {
    
    ParameterToken*  ParameterToken::Empty;
    
    void ParameterToken::static_constructor() {
        (*Empty) = cli::ctor<ParameterToken>();
    }
    
    void ParameterToken::constructor(int32_t val) {
        (*this)->tokValue = val;
    }
    
    bool ParameterToken::Equals_ed975d2f4a7d193e(System::Object* obj) {
        bool res = cli::is<ParameterToken>(obj);
        if(res) 
        {
            ParameterToken that = cli::unbox<ParameterToken>(obj);
            res = ((*this)->tokValue ==  that->tokValue);
        }
        return res;
    }
    
    bool ParameterToken::Equals2(ParameterToken obj) {
        return ((*this)->tokValue ==  obj->tokValue);
    }
    
    int32_t ParameterToken::GetHashCode_6648aef0f235ee6c() {
        return (*this)->tokValue;
    }
    
    bool ParameterToken::op_Equality(ParameterToken a, ParameterToken b) {
        return System::Object::Equals2(cli::box(a), cli::box(b));
    }
    
    bool ParameterToken::op_Inequality(ParameterToken a, ParameterToken b) {
        return !(System::Object::Equals2(cli::box(a), cli::box(b)));
    }
    
    int32_t ParameterToken::get_Token() {
        return (*this)->tokValue;
    }
    
}}}
namespace System { namespace Reflection { namespace Emit {
    
    PropertyToken*  PropertyToken::Empty;
    
    void PropertyToken::static_constructor() {
        (*Empty) = cli::ctor<PropertyToken>();
    }
    
    void PropertyToken::constructor(int32_t val) {
        (*this)->tokValue = val;
    }
    
    bool PropertyToken::Equals_ed975d2f4a7d193e(System::Object* obj) {
        bool res = cli::is<PropertyToken>(obj);
        if(res) 
        {
            PropertyToken that = cli::unbox<PropertyToken>(obj);
            res = ((*this)->tokValue ==  that->tokValue);
        }
        return res;
    }
    
    bool PropertyToken::Equals2(PropertyToken obj) {
        return ((*this)->tokValue ==  obj->tokValue);
    }
    
    int32_t PropertyToken::GetHashCode_6648aef0f235ee6c() {
        return (*this)->tokValue;
    }
    
    bool PropertyToken::op_Equality(PropertyToken a, PropertyToken b) {
        return System::Object::Equals2(cli::box(a), cli::box(b));
    }
    
    bool PropertyToken::op_Inequality(PropertyToken a, PropertyToken b) {
        return !(System::Object::Equals2(cli::box(a), cli::box(b)));
    }
    
    int32_t PropertyToken::get_Token() {
        return (*this)->tokValue;
    }
    
}}}
namespace System { namespace Reflection { namespace Emit {
    
    SignatureToken*  SignatureToken::Empty;
    
    void SignatureToken::static_constructor() {
        (*Empty) = cli::ctor<SignatureToken>();
    }
    
    void SignatureToken::constructor(int32_t val) {
        (*this)->tokValue = val;
    }
    
    bool SignatureToken::Equals_ed975d2f4a7d193e(System::Object* obj) {
        bool res = cli::is<SignatureToken>(obj);
        if(res) 
        {
            SignatureToken that = cli::unbox<SignatureToken>(obj);
            res = ((*this)->tokValue ==  that->tokValue);
        }
        return res;
    }
    
    bool SignatureToken::Equals2(SignatureToken obj) {
        return ((*this)->tokValue ==  obj->tokValue);
    }
    
    int32_t SignatureToken::GetHashCode_6648aef0f235ee6c() {
        return (*this)->tokValue;
    }
    
    bool SignatureToken::op_Equality(SignatureToken a, SignatureToken b) {
        return System::Object::Equals2(cli::box(a), cli::box(b));
    }
    
    bool SignatureToken::op_Inequality(SignatureToken a, SignatureToken b) {
        return !(System::Object::Equals2(cli::box(a), cli::box(b)));
    }
    
    int32_t SignatureToken::get_Token() {
        return (*this)->tokValue;
    }
    
}}}
namespace System { namespace Reflection { namespace Emit {
    
    
    void StringToken::static_constructor() {
    }
    
    void StringToken::constructor(int32_t val) {
        (*this)->tokValue = val;
    }
    
    bool StringToken::Equals_ed975d2f4a7d193e(System::Object* obj) {
        bool res = cli::is<StringToken>(obj);
        if(res) 
        {
            StringToken that = cli::unbox<StringToken>(obj);
            res = ((*this)->tokValue ==  that->tokValue);
        }
        return res;
    }
    
    bool StringToken::Equals2(StringToken obj) {
        return ((*this)->tokValue ==  obj->tokValue);
    }
    
    int32_t StringToken::GetHashCode_6648aef0f235ee6c() {
        return (*this)->tokValue;
    }
    
    bool StringToken::op_Equality(StringToken a, StringToken b) {
        return System::Object::Equals2(cli::box(a), cli::box(b));
    }
    
    bool StringToken::op_Inequality(StringToken a, StringToken b) {
        return !(System::Object::Equals2(cli::box(a), cli::box(b)));
    }
    
    int32_t StringToken::get_Token() {
        return (*this)->tokValue;
    }
    
}}}
namespace System { namespace Reflection { namespace Emit {
    
    TypeToken*  TypeToken::Empty;
    
    void TypeToken::static_constructor() {
        (*Empty) = cli::ctor<TypeToken>();
    }
    
    void TypeToken::constructor(int32_t val) {
        (*this)->tokValue = val;
    }
    
    bool TypeToken::Equals_ed975d2f4a7d193e(System::Object* obj) {
        bool res = cli::is<TypeToken>(obj);
        if(res) 
        {
            TypeToken that = cli::unbox<TypeToken>(obj);
            res = ((*this)->tokValue ==  that->tokValue);
        }
        return res;
    }
    
    bool TypeToken::Equals2(TypeToken obj) {
        return ((*this)->tokValue ==  obj->tokValue);
    }
    
    int32_t TypeToken::GetHashCode_6648aef0f235ee6c() {
        return (*this)->tokValue;
    }
    
    bool TypeToken::op_Equality(TypeToken a, TypeToken b) {
        return System::Object::Equals2(cli::box(a), cli::box(b));
    }
    
    bool TypeToken::op_Inequality(TypeToken a, TypeToken b) {
        return !(System::Object::Equals2(cli::box(a), cli::box(b)));
    }
    
    int32_t TypeToken::get_Token() {
        return (*this)->tokValue;
    }
    
}}}
namespace System { namespace Resources {
    
    
    void ResourceInfo::constructor(System::String* resourceName, int64_t valuePosition, int32_t type_index) {
        (*this)->ValuePosition = valuePosition;
        (*this)->ResourceName = resourceName;
        (*this)->TypeIndex = type_index;
    }
    
}}
namespace System { namespace Resources {
    
    
    void ResourceCacheItem::constructor(System::String* name, System::Object* value) {
        (*this)->ResourceName = name;
        (*this)->ResourceValue = value;
    }
    
}}
namespace System { namespace Runtime { namespace CompilerServices {
    
    
}}}
namespace System { namespace Runtime { namespace InteropServices {
    
    
    void ArrayWithOffset::constructor(System::Object* array, int32_t offset) {
        (*this)->array = array;
        (*this)->offset = offset;
    }
    
    bool ArrayWithOffset::Equals_ed975d2f4a7d193e(System::Object* obj) {
        if((obj ==  nullptr)) 
        {
            return false;
        }
        if(!(cli::is<ArrayWithOffset>(obj))) 
        {
            return false;
        }
        ArrayWithOffset other = cli::unbox<ArrayWithOffset>(obj);
        return ((other->array ==  (*this)->array) && (other->offset ==  (*this)->offset));
    }
    
    bool ArrayWithOffset::Equals2(ArrayWithOffset obj) {
        return ((obj->array ==  (*this)->array) && (obj->offset ==  (*this)->offset));
    }
    
    int32_t ArrayWithOffset::GetHashCode_6648aef0f235ee6c() {
        return (*this)->offset;
    }
    
    System::Object* ArrayWithOffset::GetArray() {
        return (*this)->array;
    }
    
    int32_t ArrayWithOffset::GetOffset() {
        return (*this)->offset;
    }
    
    bool ArrayWithOffset::op_Equality(ArrayWithOffset a, ArrayWithOffset b) {
        return a->Equals2(b);
    }
    
    bool ArrayWithOffset::op_Inequality(ArrayWithOffset a, ArrayWithOffset b) {
        return !(a->Equals2(b));
    }
    
}}}
namespace System { namespace Runtime { namespace InteropServices {
    
    
}}}
namespace System { namespace Runtime { namespace InteropServices {
    
    
}}}
namespace System { namespace Runtime { namespace InteropServices {
    
    
}}}
namespace System { namespace Runtime { namespace InteropServices {
    
    
}}}
namespace System { namespace Runtime { namespace InteropServices {
    
    
}}}
namespace System { namespace Runtime { namespace InteropServices {
    
    
}}}
namespace System { namespace Runtime { namespace InteropServices {
    
    
}}}
namespace System { namespace Runtime { namespace InteropServices {
    
    
}}}
namespace System { namespace Runtime { namespace InteropServices {
    
    
}}}
namespace System { namespace Runtime { namespace InteropServices {
    
    
    void GCHandle::constructor(void* h) {
        (*this)->handle = (int32_t)h;
    }
    
    void GCHandle::constructor(System::Object* obj) {
    }
    
    void GCHandle::constructor(System::Object* value, GCHandleType type) {
        if((((int32_t)(type) < 0) || ((int32_t)(type) > 3))) 
        {
            type = GCHandleType::Normal;
        }
        (*this)->handle = GetTargetHandle(value, 0, type);
    }
    
    void* GCHandle::AddrOfPinnedObject() {
        void *res = GetAddrOfPinnedObject((*this)->handle);
        if(::System::IntPtr::op_Equality(res, (void*)-1)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Object contains non-primitive or non-blittable data."));
        }
        if(::System::IntPtr::op_Equality(res, (void*)-2)) 
        {
            throw cli::gcnew<System::InvalidOperationException>(_T("Handle is not pinned."));
        }
        return res;
    }
    
    GCHandle GCHandle::Alloc(System::Object* value) {
        return cli::ctor<GCHandle>(value);
    }
    
    GCHandle GCHandle::Alloc2(System::Object* value, GCHandleType type) {
        return cli::ctor<GCHandle>(value, type);
    }
    
    void GCHandle::Free() {
        FreeHandle((*this)->handle);
        (*this)->handle = 0;
    }
    
    bool GCHandle::CheckCurrentDomain(int32_t handle) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    System::Object* GCHandle::GetTarget(int32_t handle) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t GCHandle::GetTargetHandle(System::Object* obj, int32_t handle, GCHandleType type) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void GCHandle::FreeHandle(int32_t handle) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void* GCHandle::GetAddrOfPinnedObject(int32_t handle) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool GCHandle::Equals_ed975d2f4a7d193e(System::Object* o) {
        return cli::is<GCHandle>(o) ? op_Equality((*this), cli::unbox<GCHandle>(o)) : false;
    }
    
    int32_t GCHandle::GetHashCode_6648aef0f235ee6c() {
        return cli::import((*this)->handle)->GetHashCode_6648aef0f235ee6c();
    }
    
    GCHandle GCHandle::FromIntPtr(void* value) {
        return GCHandle::op_Explicit2(value);
    }
    
    void* GCHandle::ToIntPtr(GCHandle value) {
        return (void*)value;
    }
    
    void* GCHandle::op_Explicit(GCHandle value) {
        return (void*)value->handle;
    }
    
    GCHandle GCHandle::op_Explicit2(void* value) {
        if(::System::IntPtr::op_Equality(value, (*::System::IntPtr::Zero))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("GCHandle value cannot be zero"));
        }
        if(!(CheckCurrentDomain((int32_t)value))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("GCHandle value belongs to a different domain"));
        }
        return cli::ctor<GCHandle>(value);
    }
    
    bool GCHandle::op_Equality(GCHandle a, GCHandle b) {
        return (a->handle ==  b->handle);
    }
    
    bool GCHandle::op_Inequality(GCHandle a, GCHandle b) {
        return !(op_Equality(a, b));
    }
    
    bool GCHandle::get_IsAllocated() {
        return ((*this)->handle != 0);
    }
    
    System::Object* GCHandle::get_Target() {
        if(!((*this)->get_IsAllocated())) 
        {
            throw cli::gcnew<System::InvalidOperationException>(Locale::GetText(_T("Handle is not allocated")));
        }
        return GetTarget((*this)->handle);
    }
    
    System::Object* GCHandle::set_Target(System::Object* value) {
        (*this)->handle = GetTargetHandle(value, (*this)->handle, (GCHandleType)-1L);
        return get_Target();
    }
    
}}}
namespace System { namespace Runtime { namespace InteropServices {
    
    
    void HandleRef::constructor(System::Object* wrapper, void* handle) {
        (*this)->wrapper = wrapper;
        (*this)->handle = handle;
    }
    
    void* HandleRef::ToIntPtr(HandleRef value) {
        return value->get_Handle();
    }
    
    void* HandleRef::op_Explicit(HandleRef value) {
        return value->get_Handle();
    }
    
    void* HandleRef::get_Handle() {
        return (*this)->handle;
    }
    
    System::Object* HandleRef::get_Wrapper() {
        return (*this)->wrapper;
    }
    
}}}
namespace System { namespace Runtime { namespace InteropServices {
    
    
}}}
namespace System { namespace Runtime { namespace InteropServices {
    
    
}}}
namespace System { namespace Runtime { namespace InteropServices {
    
    
}}}
namespace System { namespace Runtime { namespace InteropServices {
    
    
}}}
namespace System { namespace Runtime { namespace InteropServices {
    
    
}}}
namespace System { namespace Runtime { namespace InteropServices {
    
    
}}}
namespace System { namespace Runtime { namespace InteropServices {
    
    
}}}
namespace System { namespace Runtime { namespace InteropServices {
    
    
}}}
namespace System { namespace Runtime { namespace InteropServices { namespace ComTypes {
    
    
}}}}
namespace System { namespace Runtime { namespace InteropServices { namespace ComTypes {
    
    
}}}}
namespace System { namespace Runtime { namespace InteropServices { namespace ComTypes {
    
    
}}}}
namespace System { namespace Runtime { namespace InteropServices { namespace ComTypes {
    
    
}}}}
namespace System { namespace Runtime { namespace InteropServices { namespace ComTypes {
    
    
}}}}
namespace System { namespace Runtime { namespace InteropServices { namespace ComTypes {
    
    
}}}}
namespace System { namespace Runtime { namespace InteropServices { namespace ComTypes {
    
    
}}}}
namespace System { namespace Runtime { namespace InteropServices { namespace ComTypes {
    
    
}}}}
namespace System { namespace Runtime { namespace InteropServices { namespace ComTypes {
    
    
}}}}
namespace System { namespace Runtime { namespace InteropServices { namespace ComTypes {
    
    
}}}}
namespace System { namespace Runtime { namespace InteropServices { namespace ComTypes {
    
    
}}}}
namespace System { namespace Runtime { namespace InteropServices { namespace ComTypes {
    
    
}}}}
namespace System { namespace Runtime { namespace InteropServices { namespace ComTypes {
    
    
}}}}
namespace System { namespace Runtime { namespace InteropServices { namespace ComTypes {
    
    
}}}}
namespace System { namespace Runtime { namespace InteropServices { namespace ComTypes {
    
    
}}}}
namespace System { namespace Runtime { namespace InteropServices { namespace ComTypes {
    
    
}}}}
namespace System { namespace Runtime { namespace InteropServices { namespace ComTypes {
    
    
}}}}
namespace System { namespace Runtime { namespace Remoting { namespace Channels {
    
    
}}}}
namespace System { namespace Runtime { namespace Serialization {
    
    
    void SerializationEntry::constructor(System::String* name, System::Type* type, System::Object* value) {
        (*this)->name = name;
        (*this)->objectType = type;
        (*this)->value = value;
    }
    
    System::String* SerializationEntry::get_Name() {
        return (*this)->name;
    }
    
    System::Type* SerializationEntry::get_ObjectType() {
        return (*this)->objectType;
    }
    
    System::Object* SerializationEntry::get_Value() {
        return (*this)->value;
    }
    
}}}
namespace System { namespace Runtime { namespace Serialization {
    
    
    void StreamingContext::constructor(StreamingContextStates state) {
        (*this)->state = state;
        (*this)->additional = nullptr;
    }
    
    void StreamingContext::constructor(StreamingContextStates state, System::Object* additional) {
        (*this)->state = state;
        (*this)->additional = additional;
    }
    
    bool StreamingContext::Equals_ed975d2f4a7d193e(System::Object* obj) {
        StreamingContext other;
        if(!(cli::is<StreamingContext>(obj))) 
        {
            return false;
        }
        other = cli::unbox<StreamingContext>(obj);
        return (((int32_t)(other->state) ==  (int32_t)((*this)->state)) && (other->additional ==  (*this)->additional));
    }
    
    int32_t StreamingContext::GetHashCode_6648aef0f235ee6c() {
        return (int32_t)((*this)->state);
    }
    
    System::Object* StreamingContext::get_Context() {
        return (*this)->additional;
    }
    
    StreamingContextStates StreamingContext::get_State() {
        return (*this)->state;
    }
    
}}}
namespace System { namespace Security {
    
    
}}
namespace System { namespace Security {
    
    
    void SecurityFrame::constructor(RuntimeSecurityFrame* frame) {
        (*this)->_domain = nullptr;
        (*this)->_method = nullptr;
        (*this)->_assert = nullptr;
        (*this)->_deny = nullptr;
        (*this)->_permitonly = nullptr;
        InitFromRuntimeFrame(frame);
    }
    
    void SecurityFrame::constructor(int32_t skip) {
        (*this)->_domain = nullptr;
        (*this)->_method = nullptr;
        (*this)->_assert = nullptr;
        (*this)->_deny = nullptr;
        (*this)->_permitonly = nullptr;
        InitFromRuntimeFrame(_GetSecurityFrame((skip + 2)));
    }
    
    RuntimeSecurityFrame* SecurityFrame::_GetSecurityFrame(int32_t skip) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    System::Array* SecurityFrame::_GetSecurityStack(int32_t skip) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void SecurityFrame::InitFromRuntimeFrame(RuntimeSecurityFrame* frame) {
        (*this)->_domain = frame->domain;
        (*this)->_method = frame->method;
        if((frame->assert->size > 0)) 
        {
            (*this)->_assert = SecurityManager::Decode(frame->assert->blob, frame->assert->size);
        }
        if((frame->deny->size > 0)) 
        {
            (*this)->_deny = SecurityManager::Decode(frame->deny->blob, frame->deny->size);
        }
        if((frame->permitonly->size > 0)) 
        {
            (*this)->_permitonly = SecurityManager::Decode(frame->permitonly->blob, frame->permitonly->size);
        }
    }
    
    bool SecurityFrame::Equals(SecurityFrame sf) {
        if(!(System::Object::ReferenceEquals((*this)->_domain, sf->get_Domain()))) 
        {
            return false;
        }
        if(System::String::op_Inequality((*this)->get_Assembly()->ToString_1636a0751cb9ac11(), sf->get_Assembly()->ToString_1636a0751cb9ac11())) 
        {
            return false;
        }
        if(System::String::op_Inequality((*this)->get_Method()->ToString_1636a0751cb9ac11(), sf->get_Method()->ToString_1636a0751cb9ac11())) 
        {
            return false;
        }
        if((((*this)->_assert != nullptr) && !((*this)->_assert->Equals_ed975d2f4a7d193e(sf->get_Assert())))) 
        {
            return false;
        }
        if((((*this)->_deny != nullptr) && !((*this)->_deny->Equals_ed975d2f4a7d193e(sf->get_Deny())))) 
        {
            return false;
        }
        if((((*this)->_permitonly != nullptr) && !((*this)->_permitonly->Equals_ed975d2f4a7d193e(sf->get_PermitOnly())))) 
        {
            return false;
        }
        return true;
    }
    
    System::String* SecurityFrame::ToString_1636a0751cb9ac11() {
        System::Text::StringBuilder *sb = cli::gcnew<System::Text::StringBuilder>();
        sb->AppendFormat4(_T("Frame: {0}{1}"), (*this)->_method, System::Environment::get_NewLine());
        sb->AppendFormat4(_T("\tAppDomain: {0}{1}"), (*this)->get_Domain(), System::Environment::get_NewLine());
        sb->AppendFormat4(_T("\tAssembly: {0}{1}"), (*this)->get_Assembly(), System::Environment::get_NewLine());
        if(((*this)->_assert != nullptr)) 
        {
            sb->AppendFormat4(_T("\tAssert: {0}{1}"), (*this)->_assert, System::Environment::get_NewLine());
        }
        if(((*this)->_deny != nullptr)) 
        {
            sb->AppendFormat4(_T("\tDeny: {0}{1}"), (*this)->_deny, System::Environment::get_NewLine());
        }
        if(((*this)->_permitonly != nullptr)) 
        {
            sb->AppendFormat4(_T("\tPermitOnly: {0}{1}"), (*this)->_permitonly, System::Environment::get_NewLine());
        }
        return sb->ToString_1636a0751cb9ac11();
    }
    
    System::Collections::ArrayList* SecurityFrame::GetStack(int32_t skipFrames) {
        System::Array *stack = _GetSecurityStack((skipFrames + 2));
        System::Collections::ArrayList *al = cli::gcnew<System::Collections::ArrayList>();
        for(int32_t i = 0; (i < stack->get_Length()); i++){
            System::Object *o = stack->GetValue2(i);
            if((o ==  nullptr)) 
            {
                break;
            }
            al->Add_e6a92085999ce388(cli::box(cli::ctor<SecurityFrame>(cli::cast<RuntimeSecurityFrame*>(o))));
        }
        return al;
    }
    
    System::Reflection::Assembly* SecurityFrame::get_Assembly() {
        return (*this)->_method->get_ReflectedType_bf4971c0f442b9dc()->get_Assembly_3aae0acbf2a6d696();
    }
    
    System::AppDomain* SecurityFrame::get_Domain() {
        return (*this)->_domain;
    }
    
    System::Reflection::MethodInfo* SecurityFrame::get_Method() {
        return (*this)->_method;
    }
    
    PermissionSet* SecurityFrame::get_Assert() {
        return (*this)->_assert;
    }
    
    PermissionSet* SecurityFrame::get_Deny() {
        return (*this)->_deny;
    }
    
    PermissionSet* SecurityFrame::get_PermitOnly() {
        return (*this)->_permitonly;
    }
    
    bool SecurityFrame::get_HasStackModifiers() {
        return ((((*this)->_assert != nullptr) || ((*this)->_deny != nullptr)) || ((*this)->_permitonly != nullptr));
    }
    
}}
namespace System { namespace Security {
    
    
}}
namespace System { namespace Security { namespace Cryptography {
    
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    
}}}
namespace System { namespace Security { namespace Cryptography { namespace X509Certificates {
    
    
}}}}
namespace System { namespace Security { namespace Permissions {
    
    
    void SNIP::constructor(StrongNamePublicKeyBlob* pk, System::String* name, System::Version* version) {
        (*this)->PublicKey = pk;
        (*this)->Name2 = name;
        (*this)->AssemblyVersion = version;
    }
    
    SNIP SNIP::CreateDefault() {
        return cli::ctor<SNIP>(nullptr, System::String::Empty, cli::cast<System::Version*>(StrongNameIdentityPermission::defaultVersion->Clone()));
    }
    
    bool SNIP::IsNameSubsetOf(System::String* target) {
        if(((*this)->Name2 ==  nullptr)) 
        {
            return (target ==  nullptr);
        }
        if((target ==  nullptr)) 
        {
            return true;
        }
        int32_t wildcard = (*this)->Name2->LastIndexOf4(u'*');
        if((wildcard ==  0)) 
        {
            return true;
        }
        if((wildcard ==  -1)) 
        {
            wildcard = (*this)->Name2->get_Length();
        }
        return (System::String::Compare6((*this)->Name2, 0, target, 0, wildcard, true, System::Globalization::CultureInfo::get_InvariantCulture()) ==  0);
    }
    
    bool SNIP::IsSubsetOf(SNIP target) {
        if((((*this)->PublicKey != nullptr) && (*this)->PublicKey->Equals_ed975d2f4a7d193e(target->PublicKey))) 
        {
            return true;
        }
        if(!(IsNameSubsetOf(target->Name2))) 
        {
            return false;
        }
        if((System::Version::op_Inequality((*this)->AssemblyVersion, nullptr) && !((*this)->AssemblyVersion->Equals4(target->AssemblyVersion)))) 
        {
            return false;
        }
        if(((*this)->PublicKey ==  nullptr)) 
        {
            return (target->PublicKey ==  nullptr);
        }
        return false;
    }
    
}}}
namespace System { namespace Threading {
    
    
    void AsyncFlowControl::constructor(Thread* t, AsyncFlowControlType type) {
        (*this)->_t = t;
        (*this)->_type = type;
    }
    
    void AsyncFlowControl::Undo() {
        if(((*this)->_t ==  nullptr)) 
        {
            throw cli::gcnew<System::InvalidOperationException>(Locale::GetText(_T("Can only be called once.")));
        }
        switch((*this)->_type) {
            case AsyncFlowControlType::Execution: case_82: {
                ExecutionContext::RestoreFlow();
                break;
            }
            case AsyncFlowControlType::Security: case_83: {
                System::Security::SecurityContext::RestoreFlow();
                break;
            }
        }
        (*this)->_t = nullptr;
    }
    
    void AsyncFlowControl::Dispose() {
        if(((*this)->_t != nullptr)) 
        {
            Undo();
            (*this)->_t = nullptr;
            (*this)->_type = AsyncFlowControlType::None;
        }
    }
    
    int32_t AsyncFlowControl::GetHashCode_6648aef0f235ee6c() {
        return System::ValueType::GetHashCode_6648aef0f235ee6c();
    }
    
    bool AsyncFlowControl::Equals_ed975d2f4a7d193e(System::Object* obj) {
        if(!(cli::is<AsyncFlowControl>(obj))) 
        {
            return false;
        }
        return obj->Equals_ed975d2f4a7d193e(cli::box((*this)));
    }
    
    bool AsyncFlowControl::Equals2(AsyncFlowControl obj) {
        if((((*this)->_t ==  obj->_t) && ((int32_t)((*this)->_type) ==  (int32_t)(obj->_type)))) 
        {
            return true;
        }
         else 
        {
            return false;
        }
    }
    
    bool AsyncFlowControl::op_Equality(AsyncFlowControl a, AsyncFlowControl b) {
        return a->Equals2(b);
    }
    
    bool AsyncFlowControl::op_Inequality(AsyncFlowControl a, AsyncFlowControl b) {
        return !(a->Equals2(b));
    }
    
}}
namespace System { namespace Threading {
    
    
    bool AtomicBooleanValue::CompareAndExchange(bool expected, bool newVal) {
        int32_t newTemp = newVal ? 1 : 0;
        int32_t expectedTemp = expected ? 1 : 0;
        return (Interlocked::CompareExchange((*this)->flag, newTemp, expectedTemp) ==  expectedTemp);
    }
    
    AtomicBooleanValue AtomicBooleanValue::FromValue(bool value) {
        AtomicBooleanValue temp = cli::ctor<AtomicBooleanValue>();
        temp->set_Value(value);
        return temp;
    }
    
    bool AtomicBooleanValue::TrySet() {
        return !(Exchange(true));
    }
    
    bool AtomicBooleanValue::TryRelaxedSet() {
        return (((*this)->flag ==  0) && !(Exchange(true)));
    }
    
    bool AtomicBooleanValue::Exchange(bool newVal) {
        int32_t newTemp = newVal ? 1 : 0;
        return (Interlocked::Exchange((*this)->flag, newTemp) ==  1);
    }
    
    bool AtomicBooleanValue::Equals(AtomicBooleanValue rhs) {
        return ((*this)->flag ==  rhs->flag);
    }
    
    bool AtomicBooleanValue::Equals_ed975d2f4a7d193e(System::Object* rhs) {
        return cli::is<AtomicBooleanValue>(rhs) ? Equals(cli::unbox<AtomicBooleanValue>(rhs)) : false;
    }
    
    int32_t AtomicBooleanValue::GetHashCode_6648aef0f235ee6c() {
        return cli::import((*this)->flag)->GetHashCode_6648aef0f235ee6c();
    }
    
    bool AtomicBooleanValue::op_Explicit(AtomicBooleanValue rhs) {
        return rhs->get_Value();
    }
    
    AtomicBooleanValue AtomicBooleanValue::op_Implicit(bool rhs) {
        return AtomicBooleanValue::FromValue(rhs);
    }
    
    bool AtomicBooleanValue::get_Value() {
        return ((*this)->flag ==  1);
    }
    
    bool AtomicBooleanValue::set_Value(bool value) {
        Exchange(value);
        return get_Value();
    }
    
}}
namespace System { namespace Threading {
    
    
    void CancellationToken::constructor(bool canceled) {
    }
    
    void CancellationToken::constructor(CancellationTokenSource* source) {
        (*this)->source = source;
    }
    
    CancellationTokenRegistration CancellationToken::Register(System::Action* callback) {
        return Register2(callback, false);
    }
    
    CancellationTokenRegistration CancellationToken::Register2(System::Action* callback, bool useSynchronizationContext) {
        if((callback ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("callback"));
        }
        return (*this)->get_Source()->Register(callback, useSynchronizationContext);
    }
    
    CancellationTokenRegistration CancellationToken::Register3(System::Action2<System::Object*>* callback, System::Object* state) {
        return Register4(callback, state, false);
    }
    
    CancellationTokenRegistration CancellationToken::Register4(System::Action2<System::Object*>* callback, System::Object* state, bool useSynchronizationContext) {
        auto storey_7 = cli::gcnew<_Register_c__AnonStorey1B>();
        storey_7->callback = callback;
        storey_7->state = state;
        if((storey_7->callback ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("callback"));
        }
        return Register2(cli::bind(storey_7, &_Register_c__AnonStorey1B::__m__14), useSynchronizationContext);
    }
    
    void CancellationToken::ThrowIfCancellationRequested() {
        if((*this)->get_Source()->get_IsCancellationRequested()) 
        {
            throw cli::gcnew<System::OperationCanceledException>((*this));
        }
    }
    
    bool CancellationToken::Equals(CancellationToken other) {
        return ((*this)->get_Source() ==  other->get_Source());
    }
    
    bool CancellationToken::Equals_ed975d2f4a7d193e(System::Object* other) {
        return cli::is<CancellationToken>(other) ? Equals(cli::unbox<CancellationToken>(other)) : false;
    }
    
    int32_t CancellationToken::GetHashCode_6648aef0f235ee6c() {
        return (*this)->get_Source()->GetHashCode_6648aef0f235ee6c();
    }
    
    bool CancellationToken::op_Equality(CancellationToken left, CancellationToken right) {
        return left->Equals(right);
    }
    
    bool CancellationToken::op_Inequality(CancellationToken left, CancellationToken right) {
        return !(left->Equals(right));
    }
    
    CancellationToken CancellationToken::get_None() {
        return cli::ctor<CancellationToken>();
    }
    
    bool CancellationToken::get_CanBeCanceled() {
        return ((*this)->source != nullptr);
    }
    
    bool CancellationToken::get_IsCancellationRequested() {
        return (*this)->get_Source()->get_IsCancellationRequested();
    }
    
    WaitHandle* CancellationToken::get_WaitHandle() {
        return (*this)->get_Source()->get_WaitHandle();
    }
    
    CancellationTokenSource* CancellationToken::get_Source() {
        return ([&]() {
            CancellationTokenSource* tmp_8 = (*this)->source;
            if(tmp_8 == nullptr) {
                return CancellationTokenSource::NoneSource;
            } else
                return tmp_8;
        })();
    }
    
}}
namespace System { namespace Threading {
    
    
    void CancellationTokenRegistration::constructor(int32_t id, CancellationTokenSource* source) {
        (*this)->id = id;
        (*this)->source = source;
    }
    
    void CancellationTokenRegistration::Dispose() {
        (*this)->source->RemoveCallback((*this));
    }
    
    bool CancellationTokenRegistration::Equals(CancellationTokenRegistration other) {
        return (((*this)->id ==  other->id) && ((*this)->source ==  other->source));
    }
    
    int32_t CancellationTokenRegistration::GetHashCode_6648aef0f235ee6c() {
        return (cli::import((*this)->id)->GetHashCode_6648aef0f235ee6c() ^ (*this)->source->GetHashCode_6648aef0f235ee6c());
    }
    
    bool CancellationTokenRegistration::Equals_ed975d2f4a7d193e(System::Object* obj) {
        return cli::is<CancellationTokenRegistration>(obj) ? Equals(cli::unbox<CancellationTokenRegistration>(obj)) : false;
    }
    
    bool CancellationTokenRegistration::op_Equality(CancellationTokenRegistration left, CancellationTokenRegistration right) {
        return left->Equals(right);
    }
    
    bool CancellationTokenRegistration::op_Inequality(CancellationTokenRegistration left, CancellationTokenRegistration right) {
        return !(left->Equals(right));
    }
    
}}
namespace System { namespace Threading {
    
    
    void CompressedStackSwitcher::constructor(CompressedStack* cs, Thread* t) {
        (*this)->_cs = cs;
        (*this)->_t = t;
    }
    
    bool CompressedStackSwitcher::Equals_ed975d2f4a7d193e(System::Object* obj) {
        if((obj ==  nullptr)) 
        {
            return false;
        }
        if(cli::is<CompressedStackSwitcher>(obj)) 
        {
            return op_Equality((*this), cli::unbox<CompressedStackSwitcher>(obj));
        }
        return false;
    }
    
    int32_t CompressedStackSwitcher::GetHashCode_6648aef0f235ee6c() {
        return cli::typeof<System::Type>::info->GetHashCode_6648aef0f235ee6c();
    }
    
    void CompressedStackSwitcher::Undo() {
        if((((*this)->_cs != nullptr) && ((*this)->_t != nullptr))) 
        {
            {
                cli::lock_guard{(*this)->_cs};
                if((((*this)->_cs != nullptr) && ((*this)->_t != nullptr))) 
                {
                    (*this)->_t->SetCompressedStack((*this)->_cs);
                }
                (*this)->_t = nullptr;
                (*this)->_cs = nullptr;
            }
        }
    }
    
    bool CompressedStackSwitcher::op_Equality(CompressedStackSwitcher c1, CompressedStackSwitcher c2) {
        if((c1->_cs ==  nullptr)) 
        {
            return (c2->_cs ==  nullptr);
        }
        if((c2->_cs ==  nullptr)) 
        {
            return false;
        }
        if((c1->_t->get_ManagedThreadId() != c2->_t->get_ManagedThreadId())) 
        {
            return false;
        }
        return c1->_cs->Equals3(c2->_cs);
    }
    
    bool CompressedStackSwitcher::op_Inequality(CompressedStackSwitcher c1, CompressedStackSwitcher c2) {
        return !(op_Equality(c1, c2));
    }
    
    void CompressedStackSwitcher::Dispose() {
        Undo();
    }
    
}}
namespace System { namespace Threading {
    
    
    bool ExecutionContextSwitcher::Equals_ed975d2f4a7d193e(System::Object* ob) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t ExecutionContextSwitcher::GetHashCode_6648aef0f235ee6c() {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    void ExecutionContextSwitcher::Undo() {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    void ExecutionContextSwitcher::Dispose() {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool ExecutionContextSwitcher::op_Equality(ExecutionContextSwitcher c1, ExecutionContextSwitcher c2) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool ExecutionContextSwitcher::op_Inequality(ExecutionContextSwitcher c1, ExecutionContextSwitcher c2) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
}}
namespace System { namespace Threading {
    
    
    void HostExecutionContextSwitcher::Undo() {
    }
    
    bool HostExecutionContextSwitcher::Equals_ed975d2f4a7d193e(System::Object* o) {
        if((o ==  nullptr)) 
        {
            return false;
        }
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t HostExecutionContextSwitcher::GetHashCode_6648aef0f235ee6c() {
        return 0;
    }
    
    void HostExecutionContextSwitcher::Dispose() {
        Undo();
    }
    
    HostExecutionContext* HostExecutionContextSwitcher::get_CurrentHostExecutionContext() {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    HostExecutionContext* HostExecutionContextSwitcher::set_CurrentHostExecutionContext(HostExecutionContext* value) {
        throw cli::gcnew<System::NotImplementedException>();
        return get_CurrentHostExecutionContext();
    }
    
    HostExecutionContext* HostExecutionContextSwitcher::get_PreviousHostExecutionContext() {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    HostExecutionContext* HostExecutionContextSwitcher::set_PreviousHostExecutionContext(HostExecutionContext* value) {
        throw cli::gcnew<System::NotImplementedException>();
        return get_PreviousHostExecutionContext();
    }
    
}}
namespace System { namespace Threading {
    
    
    void LockCookie::constructor(int32_t thread_id) {
        (*this)->ThreadId = thread_id;
        (*this)->ReaderLocks = 0;
        (*this)->WriterLocks = 0;
    }
    
    void LockCookie::constructor(int32_t thread_id, int32_t reader_locks, int32_t writer_locks) {
        (*this)->ThreadId = thread_id;
        (*this)->ReaderLocks = reader_locks;
        (*this)->WriterLocks = writer_locks;
    }
    
    int32_t LockCookie::GetHashCode_6648aef0f235ee6c() {
        return System::ValueType::GetHashCode_6648aef0f235ee6c();
    }
    
    bool LockCookie::Equals(LockCookie obj) {
        if(((((*this)->ThreadId ==  obj->ThreadId) && ((*this)->ReaderLocks ==  obj->ReaderLocks)) && ((*this)->WriterLocks ==  obj->WriterLocks))) 
        {
            return true;
        }
         else 
        {
            return false;
        }
    }
    
    bool LockCookie::Equals_ed975d2f4a7d193e(System::Object* obj) {
        if(!(cli::is<LockCookie>(obj))) 
        {
            return false;
        }
        return obj->Equals_ed975d2f4a7d193e(cli::box((*this)));
    }
    
    bool LockCookie::op_Equality(LockCookie a, LockCookie b) {
        return a->Equals(b);
    }
    
    bool LockCookie::op_Inequality(LockCookie a, LockCookie b) {
        return !(a->Equals(b));
    }
    
}}
namespace System { namespace Threading {
    
    
}}
namespace System { namespace Threading {
    
    
}}
namespace System { namespace Threading {
    
    Watch  SpinLock::sw;
    
    void SpinLock::constructor(bool enableThreadOwnerTracking) {
        (*this)->isThreadOwnerTrackingEnabled = enableThreadOwnerTracking;
        (*this)->threadWhoTookLock = 0;
        (*this)->ticket = cli::ctor<TicketType>();
        (*this)->stallTickets = nullptr;
    }
    
    void SpinLock::static_constructor() {
    }
    
    void SpinLock::Enter(bool lockTaken) {
        if(lockTaken) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("lockTaken"), _T("lockTaken must be initialized to false"));
        }
        if(((*this)->isThreadOwnerTrackingEnabled && (*this)->get_IsHeldByCurrentThread())) 
        {
            throw cli::gcnew<LockRecursionException>();
        }
        int32_t slot = -1;
        System::Runtime::CompilerServices::RuntimeHelpers::PrepareConstrainedRegions();
        {
            cli::finally_guard([&]() {
                if((slot ==  (*this)->ticket->Value)) 
                {
                    lockTaken = true;
                    (*this)->threadWhoTookLock = Thread::get_CurrentThread()->get_ManagedThreadId();
                }
                 else 
                {
                    if((slot != -1)) 
                    {
                        if(((*this)->stallTickets ==  nullptr)) 
                        {
                            Interlocked::template CompareExchange_1<System::Collections::Concurrent::ConcurrentOrderedList<int32_t>*>((*this)->stallTickets, cli::gcnew<System::Collections::Concurrent::ConcurrentOrderedList<int32_t>>(), nullptr);
                        }
                        (*this)->stallTickets->TryAdd(slot);
                    }
                }
            });
            slot = (Interlocked::Increment((*this)->ticket->Users) - 1);
            SpinWait wait = cli::ctor<SpinWait>();
            while((slot != (*this)->ticket->Value)) {
                wait->SpinOnce();
                while((((*this)->stallTickets != nullptr) && (*this)->stallTickets->TryRemove((*this)->ticket->Value))) ++(*this)->ticket->Value;
            }
        }
    }
    
    void SpinLock::TryEnter(bool lockTaken) {
        TryEnter3(0, lockTaken);
    }
    
    void SpinLock::TryEnter2(System::TimeSpan timeout, bool lockTaken) {
        TryEnter3((int32_t)timeout->get_TotalMilliseconds(), lockTaken);
    }
    
    void SpinLock::TryEnter3(int32_t millisecondsTimeout, bool lockTaken) {
        if((millisecondsTimeout < -1)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("milliSeconds"), _T("millisecondsTimeout is a negative number other than -1"));
        }
        if(lockTaken) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("lockTaken"), _T("lockTaken must be initialized to false"));
        }
        if(((*this)->isThreadOwnerTrackingEnabled && (*this)->get_IsHeldByCurrentThread())) 
        {
            throw cli::gcnew<LockRecursionException>();
        }
        int64_t start = (millisecondsTimeout ==  -1) ? 0L : sw->get_ElapsedMilliseconds();
        bool stop = false;
        do {
            while((((*this)->stallTickets != nullptr) && (*this)->stallTickets->TryRemove((*this)->ticket->Value))) ++(*this)->ticket->Value;
            int64_t u = (int64_t)((*this)->ticket->Users);
            int64_t totalValue = ((u << 32) | u);
            int64_t newTotalValue = System::BitConverter::IsLittleEndian ? ((u << 32) | (u + 1L)) : (((u + 1L) << 32) | u);
            System::Runtime::CompilerServices::RuntimeHelpers::PrepareConstrainedRegions();
            {
                cli::finally_guard([&]() {
                    lockTaken = (Interlocked::CompareExchange4((*this)->ticket->TotalValue, newTotalValue, totalValue) ==  totalValue);
                    if(lockTaken) 
                    {
                        (*this)->threadWhoTookLock = Thread::get_CurrentThread()->get_ManagedThreadId();
                        stop = true;
                    }
                });
            }
        }
        while((!(stop) && ((millisecondsTimeout ==  -1) || ((sw->get_ElapsedMilliseconds() - start) < (int64_t)(millisecondsTimeout)))));
    }
    
    void SpinLock::Exit() {
        Exit2(false);
    }
    
    void SpinLock::Exit2(bool useMemoryBarrier) {
        System::Runtime::CompilerServices::RuntimeHelpers::PrepareConstrainedRegions();
        {
            cli::finally_guard([&]() {
                if(((*this)->isThreadOwnerTrackingEnabled && !((*this)->get_IsHeldByCurrentThread()))) 
                {
                    throw cli::gcnew<SynchronizationLockException>(_T("Current thread is not the owner of this lock"));
                }
                (*this)->threadWhoTookLock = -2147483648;
                do {
                    if(useMemoryBarrier) 
                    {
                        Interlocked::Increment((*this)->ticket->Value);
                    }
                     else 
                    {
                        (*this)->ticket->Value++;
                    }
                }
                while((((*this)->stallTickets != nullptr) && (*this)->stallTickets->TryRemove((*this)->ticket->Value)));
            });
        }
    }
    
    bool SpinLock::get_IsThreadOwnerTrackingEnabled() {
        return (*this)->isThreadOwnerTrackingEnabled;
    }
    
    bool SpinLock::get_IsHeld() {
        int64_t totalValue = (*this)->ticket->TotalValue;
        return ((totalValue >> 32) != (totalValue & 4294967295L));
    }
    
    bool SpinLock::get_IsHeldByCurrentThread() {
        if((*this)->isThreadOwnerTrackingEnabled) 
        {
            return ((*this)->get_IsHeld() && (Thread::get_CurrentThread()->get_ManagedThreadId() ==  (*this)->threadWhoTookLock));
        }
         else 
        {
            return (*this)->get_IsHeld();
        }
    }
    
}}
namespace System { namespace Threading {
    
    bool  SpinWait::isSingleCpu;
    
    void SpinWait::static_constructor() {
    }
    
    void SpinWait::SpinOnce() {
        ((*this)->ntime = (*this)->ntime + 1);
        if(isSingleCpu) 
        {
            Thread::Yield();
        }
         else 
        {
            if((((*this)->ntime % 10) ==  0)) 
            {
                Thread::Yield();
            }
             else 
            {
                Thread::SpinWait2((System::Math::Min5((*this)->ntime, 200) << 1));
            }
        }
    }
    
    void SpinWait::SpinUntil(System::Func<bool>* condition) {
        SpinWait sw = cli::ctor<SpinWait>();
        while(!(condition->Invoke())) sw->SpinOnce();
    }
    
    bool SpinWait::SpinUntil2(System::Func<bool>* condition, System::TimeSpan timeout) {
        return SpinUntil3(condition, (int32_t)timeout->get_TotalMilliseconds());
    }
    
    bool SpinWait::SpinUntil3(System::Func<bool>* condition, int32_t millisecondsTimeout) {
        SpinWait sw = cli::ctor<SpinWait>();
        Watch watch = Watch::StartNew();
        while(!(condition->Invoke())) {
            if((watch->get_ElapsedMilliseconds() > (int64_t)(millisecondsTimeout))) 
            {
                return false;
            }
            sw->SpinOnce();
        }
        return true;
    }
    
    void SpinWait::Reset() {
        (*this)->ntime = 0;
    }
    
    bool SpinWait::get_NextSpinWillYield() {
        return isSingleCpu ? true : (((*this)->ntime % 10) ==  0);
    }
    
    int32_t SpinWait::get_Count() {
        return (*this)->ntime;
    }
    
}}
namespace System { namespace Threading {
    
    
    bool SynchronizationContextSwitcher::Equals_ed975d2f4a7d193e(System::Object* ob) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t SynchronizationContextSwitcher::GetHashCode_6648aef0f235ee6c() {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    void SynchronizationContextSwitcher::Undo() {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    void SynchronizationContextSwitcher::Dispose() {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool SynchronizationContextSwitcher::op_Equality(SynchronizationContextSwitcher c1, SynchronizationContextSwitcher c2) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool SynchronizationContextSwitcher::op_Inequality(SynchronizationContextSwitcher c1, SynchronizationContextSwitcher c2) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
}}
namespace System { namespace Threading {
    
    
}}
namespace System { namespace Threading {
    
    
    Watch Watch::StartNew() {
        Watch watch = cli::ctor<Watch>();
        watch->Start();
        return watch;
    }
    
    void Watch::Start() {
        (*this)->startTicks = TicksNow();
    }
    
    void Watch::Stop() {
    }
    
    int64_t Watch::TicksNow() {
        return System::DateTime::GetTimeMonotonic();
    }
    
    int64_t Watch::get_ElapsedMilliseconds() {
        return ((TicksNow() - (*this)->startTicks) / 10000L);
    }
    
}}
namespace System { namespace Threading { namespace Tasks {
    
    
}}}
namespace System { namespace Threading { namespace Tasks {
    
    
    void ParallelLoopResult::constructor(System::Nullable2<int64_t> lowest, bool isCompleted) {
        (*this)->set_LowestBreakIteration(lowest);
        (*this)->set_IsCompleted(isCompleted);
    }
    
    System::Nullable2<int64_t> ParallelLoopResult::get_LowestBreakIteration() {
        return (*this)->_LowestBreakIteration_k__BackingField;
    }
    
    System::Nullable2<int64_t> ParallelLoopResult::set_LowestBreakIteration(System::Nullable2<int64_t> value) {
        (*this)->_LowestBreakIteration_k__BackingField = value;
        return get_LowestBreakIteration();
    }
    
    bool ParallelLoopResult::get_IsCompleted() {
        return (*this)->_IsCompleted_k__BackingField;
    }
    
    bool ParallelLoopResult::set_IsCompleted(bool value) {
        (*this)->_IsCompleted_k__BackingField = value;
        return get_IsCompleted();
    }
    
}}}
namespace System { namespace Threading { namespace Tasks {
    
    
}}}
namespace System {
    
    
    void MonoTODOAttribute::constructor() {
    }
    
    void MonoTODOAttribute::constructor(String* comment) {
        this->comment = comment;
    }
    
    String* MonoTODOAttribute::get_Comment() {
        return this->comment;
    }
    
}
namespace System {
    
    
    void MonoDocumentationNoteAttribute::constructor(String* comment) {
    }
    
}
namespace System {
    
    
    void MonoExtensionAttribute::constructor(String* comment) {
    }
    
}
namespace System {
    
    
    void MonoInternalNoteAttribute::constructor(String* comment) {
    }
    
}
namespace System {
    
    
    void MonoLimitationAttribute::constructor(String* comment) {
    }
    
}
namespace System {
    
    
    void MonoNotSupportedAttribute::constructor(String* comment) {
    }
    
}




void Locale::constructor() {
}

System::String* Locale::GetText(System::String* msg) {
    return msg;
}

System::String* Locale::GetText2(System::String* fmt, cli::array<System::Object*>* args) {
    return System::String::Format5(fmt, args);
}

namespace Microsoft { namespace Win32 {
    
    RegistryKey*  Registry::ClassesRoot;
    RegistryKey*  Registry::CurrentConfig;
    RegistryKey*  Registry::CurrentUser;
    RegistryKey*  Registry::DynData;
    RegistryKey*  Registry::LocalMachine;
    RegistryKey*  Registry::PerformanceData;
    RegistryKey*  Registry::Users;
    System::Collections::Generic::Dictionary<System::String*, int32_t>*  Registry::__f__switch_map0;
    
    Registry::Registry()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void Registry::static_constructor() {
    }
    
    RegistryKey* Registry::ToKey(System::String* keyName, bool setting) {
        if((keyName ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Not a valid registry key name"), _T("keyName"));
        }
        RegistryKey *key = nullptr;
        cli::array<System::String*> *keys = keyName->Split((new cli::array<char16_t>({u'\\'})));
        System::String* tmp_9 = keys->at(0);
        ::System::Int32 tmp_10 = -1;
        if(::System::String::Equals3(tmp_9, _T("HKEY_CLASSES_ROOT"))) tmp_10 = 0;
        if(::System::String::Equals3(tmp_9, _T("HKEY_CURRENT_CONFIG"))) tmp_10 = 1;
        if(::System::String::Equals3(tmp_9, _T("HKEY_CURRENT_USER"))) tmp_10 = 2;
        if(::System::String::Equals3(tmp_9, _T("HKEY_DYN_DATA"))) tmp_10 = 3;
        if(::System::String::Equals3(tmp_9, _T("HKEY_LOCAL_MACHINE"))) tmp_10 = 4;
        if(::System::String::Equals3(tmp_9, _T("HKEY_PERFORMANCE_DATA"))) tmp_10 = 5;
        if(::System::String::Equals3(tmp_9, _T("HKEY_USERS"))) tmp_10 = 6;
        switch(tmp_10)
        {
            case 0: case_84: 
            {
                key = ClassesRoot;
                break;
            }
            case 1: case_85: 
            {
                key = CurrentConfig;
                break;
            }
            case 2: case_86: 
            {
                key = CurrentUser;
                break;
            }
            case 3: case_87: 
            {
                key = DynData;
                break;
            }
            case 4: case_88: 
            {
                key = LocalMachine;
                break;
            }
            case 5: case_89: 
            {
                key = PerformanceData;
                break;
            }
            case 6: case_90: 
            {
                key = Users;
                break;
            }
            default: case_91: 
            {
                throw cli::gcnew<System::ArgumentException>(_T("Keyname does not start with a valid registry root"), _T("keyName"));
            }
        }
        for(int32_t i = 1; (i < keys->get_Length()); i++){
            RegistryKey *nkey = key->OpenSubKey2(keys->at(i), true);
            if((nkey ==  nullptr)) 
            {
                if(!(setting)) 
                {
                    return nullptr;
                }
                nkey = key->CreateSubKey(keys->at(i));
            }
            key = nkey;
        }
        return key;
    }
    
    void Registry::SetValue(System::String* keyName, System::String* valueName, System::Object* value) {
        RegistryKey *key = ToKey(keyName, true);
        if((valueName->get_Length() > 255)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("valueName is larger than 255 characters"), _T("valueName"));
        }
        if((key ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("cant locate that keyName"), _T("keyName"));
        }
        key->SetValue(valueName, value);
    }
    
    void Registry::SetValue2(System::String* keyName, System::String* valueName, System::Object* value, RegistryValueKind valueKind) {
        RegistryKey *key = ToKey(keyName, true);
        if((valueName->get_Length() > 255)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("valueName is larger than 255 characters"), _T("valueName"));
        }
        if((key ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("cant locate that keyName"), _T("keyName"));
        }
        key->SetValue2(valueName, value, valueKind);
    }
    
    System::Object* Registry::GetValue(System::String* keyName, System::String* valueName, System::Object* defaultValue) {
        RegistryKey *key = ToKey(keyName, false);
        if((key ==  nullptr)) 
        {
            return defaultValue;
        }
        return key->GetValue2(valueName, defaultValue);
    }
    
}}
namespace Microsoft { namespace Win32 {
    
    IRegistryApi*  RegistryKey::RegistryApi;
    
    RegistryKey::RegistryKey()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void RegistryKey::static_constructor() {
        if(((int32_t)(System::IO::Path::DirectorySeparatorChar) ==  92)) 
        {
            RegistryApi = cli::gcnew<Win32RegistryApi>();
        }
         else 
        {
            RegistryApi = cli::gcnew<UnixRegistryApi>();
        }
    }
    
    void RegistryKey::constructor(RegistryHive hiveId) {
    }
    
    void RegistryKey::constructor(RegistryHive hiveId, void* keyHandle, bool remoteRoot) {
        this->hive = cli::box(hiveId);
        this->handle = cli::box(keyHandle);
        this->qname = GetHiveName(hiveId);
        this->isRemoteRoot = remoteRoot;
        this->isWritable = true;
    }
    
    void RegistryKey::constructor(System::Object* data, System::String* keyName, bool writable) {
        this->handle = data;
        this->qname = keyName;
        this->isWritable = writable;
    }
    
    void RegistryKey::Finalize_97a09cd51cc9cae0() {
        {
            cli::finally_guard([&]() {
                Finalize_b946fbc32e26afd6();
            });
            Close();
        }
    }
    
    void RegistryKey::Dispose() {
        System::GC::SuppressFinalize(this);
        Close();
    }
    
    void RegistryKey::Flush() {
        RegistryApi->Flush_53d355753283f224(this);
    }
    
    void RegistryKey::Close() {
        Flush();
        if((!(this->isRemoteRoot) && this->get_IsRoot())) 
        {
            return;
        }
        RegistryApi->Close_7ab99d30db36a1fc(this);
        this->handle = nullptr;
        this->safe_handle = nullptr;
    }
    
    void RegistryKey::SetValue(System::String* name, System::Object* value) {
        AssertKeyStillValid();
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("value"));
        }
        if((name != nullptr)) 
        {
            AssertKeyNameLength(name);
        }
        if(!(this->get_IsWritable())) 
        {
            throw cli::gcnew<System::UnauthorizedAccessException>(_T("Cannot write to the registry key."));
        }
        RegistryApi->SetValue_9e6c50dfb2e1c48(this, name, value);
    }
    
    void RegistryKey::SetValue2(System::String* name, System::Object* value, RegistryValueKind valueKind) {
        AssertKeyStillValid();
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("value"));
        }
        if((name != nullptr)) 
        {
            AssertKeyNameLength(name);
        }
        if(!(this->get_IsWritable())) 
        {
            throw cli::gcnew<System::UnauthorizedAccessException>(_T("Cannot write to the registry key."));
        }
        RegistryApi->SetValue_5d8b5cf92e3e050f(this, name, value, valueKind);
    }
    
    RegistryKey* RegistryKey::OpenSubKey(System::String* name) {
        return OpenSubKey2(name, false);
    }
    
    RegistryKey* RegistryKey::OpenSubKey2(System::String* name, bool writable) {
        AssertKeyStillValid();
        if((name ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("name"));
        }
        AssertKeyNameLength(name);
        return RegistryApi->OpenSubKey_4d6bff263dc4c438(this, name, writable);
    }
    
    System::Object* RegistryKey::GetValue(System::String* name) {
        return GetValue2(name, nullptr);
    }
    
    System::Object* RegistryKey::GetValue2(System::String* name, System::Object* defaultValue) {
        AssertKeyStillValid();
        return RegistryApi->GetValue_e35c4dfdaf0e1cb4(this, name, defaultValue, RegistryValueOptions::None);
    }
    
    System::Object* RegistryKey::GetValue3(System::String* name, System::Object* defaultValue, RegistryValueOptions options) {
        AssertKeyStillValid();
        return RegistryApi->GetValue_e35c4dfdaf0e1cb4(this, name, defaultValue, options);
    }
    
    RegistryValueKind RegistryKey::GetValueKind(System::String* name) {
        return RegistryApi->GetValueKind_c91458ed4ea1e91a(this, name);
    }
    
    RegistryKey* RegistryKey::CreateSubKey(System::String* subkey) {
        AssertKeyStillValid();
        AssertKeyNameNotNull(subkey);
        AssertKeyNameLength(subkey);
        if(!(this->get_IsWritable())) 
        {
            throw cli::gcnew<System::UnauthorizedAccessException>(_T("Cannot write to the registry key."));
        }
        return RegistryApi->CreateSubKey_e3b01f557508b68f(this, subkey);
    }
    
    RegistryKey* RegistryKey::CreateSubKey2(System::String* subkey, RegistryKeyPermissionCheck permissionCheck) {
        return CreateSubKey(subkey);
    }
    
    RegistryKey* RegistryKey::CreateSubKey3(System::String* subkey, RegistryKeyPermissionCheck permissionCheck, System::Security::AccessControl::RegistrySecurity* registrySecurity) {
        return CreateSubKey(subkey);
    }
    
    RegistryKey* RegistryKey::CreateSubKey4(System::String* subkey, RegistryKeyPermissionCheck permissionCheck, RegistryOptions options) {
        AssertKeyStillValid();
        AssertKeyNameNotNull(subkey);
        AssertKeyNameLength(subkey);
        if(!(this->get_IsWritable())) 
        {
            throw cli::gcnew<System::UnauthorizedAccessException>(_T("Cannot write to the registry key."));
        }
        return RegistryApi->CreateSubKey_d59517498a7eff5a(this, subkey, options);
    }
    
    RegistryKey* RegistryKey::CreateSubKey5(System::String* subkey, RegistryKeyPermissionCheck permissionCheck, RegistryOptions registryOptions, System::Security::AccessControl::RegistrySecurity* registrySecurity) {
        return CreateSubKey4(subkey, permissionCheck, registryOptions);
    }
    
    void RegistryKey::DeleteSubKey(System::String* subkey) {
        DeleteSubKey2(subkey, true);
    }
    
    void RegistryKey::DeleteSubKey2(System::String* subkey, bool throwOnMissingSubKey) {
        AssertKeyStillValid();
        AssertKeyNameNotNull(subkey);
        AssertKeyNameLength(subkey);
        if(!(this->get_IsWritable())) 
        {
            throw cli::gcnew<System::UnauthorizedAccessException>(_T("Cannot write to the registry key."));
        }
        RegistryKey *child = OpenSubKey(subkey);
        if((child ==  nullptr)) 
        {
            if(throwOnMissingSubKey) 
            {
                throw cli::gcnew<System::ArgumentException>(_T("Cannot delete a subkey tree because the subkey does not exist."));
            }
            return;
        }
        if((child->get_SubKeyCount() > 0)) 
        {
            throw cli::gcnew<System::InvalidOperationException>(_T("Registry key has subkeys and recursive removes are not supported by this method."));
        }
        child->Close();
        RegistryApi->DeleteKey_84e4c2cae50b1273(this, subkey, throwOnMissingSubKey);
    }
    
    void RegistryKey::DeleteSubKeyTree(System::String* subkey) {
        DeleteSubKeyTree2(subkey, true);
    }
    
    void RegistryKey::DeleteSubKeyTree2(System::String* subkey, bool throwOnMissingSubKey) {
        AssertKeyStillValid();
        AssertKeyNameNotNull(subkey);
        AssertKeyNameLength(subkey);
        RegistryKey *child = OpenSubKey2(subkey, true);
        if((child ==  nullptr)) 
        {
            if(!(throwOnMissingSubKey)) 
            {
                return;
            }
            throw cli::gcnew<System::ArgumentException>(_T("Cannot delete a subkey tree because the subkey does not exist."));
        }
        child->DeleteChildKeysAndValues();
        child->Close();
        DeleteSubKey2(subkey, false);
    }
    
    void RegistryKey::DeleteValue(System::String* name) {
        DeleteValue2(name, true);
    }
    
    void RegistryKey::DeleteValue2(System::String* name, bool throwOnMissingValue) {
        AssertKeyStillValid();
        if((name ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("name"));
        }
        if(!(this->get_IsWritable())) 
        {
            throw cli::gcnew<System::UnauthorizedAccessException>(_T("Cannot write to the registry key."));
        }
        RegistryApi->DeleteValue_8d736af9c68b135(this, name, throwOnMissingValue);
    }
    
    System::Security::AccessControl::RegistrySecurity* RegistryKey::GetAccessControl() {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    System::Security::AccessControl::RegistrySecurity* RegistryKey::GetAccessControl2(System::Security::AccessControl::AccessControlSections includeSections) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    cli::array<System::String*>* RegistryKey::GetSubKeyNames() {
        AssertKeyStillValid();
        return RegistryApi->GetSubKeyNames_34dc199201a58ad7(this);
    }
    
    cli::array<System::String*>* RegistryKey::GetValueNames() {
        AssertKeyStillValid();
        return RegistryApi->GetValueNames_1b2f3e2c26006c8d(this);
    }
    
    RegistryKey* RegistryKey::FromHandle(SafeHandles::SafeRegistryHandle* handle) {
        if((handle ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("handle"));
        }
        return RegistryApi->FromHandle_46a059a7a448791a(handle);
    }
    
    RegistryKey* RegistryKey::FromHandle2(SafeHandles::SafeRegistryHandle* handle, RegistryView view) {
        return FromHandle(handle);
    }
    
    RegistryKey* RegistryKey::OpenRemoteBaseKey(RegistryHive hKey, System::String* machineName) {
        if((machineName ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("machineName"));
        }
        return RegistryApi->OpenRemoteBaseKey_f80fed951d8f34a6(hKey, machineName);
    }
    
    RegistryKey* RegistryKey::OpenRemoteBaseKey2(RegistryHive hKey, System::String* machineName, RegistryView view) {
        if((machineName ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("machineName"));
        }
        return RegistryApi->OpenRemoteBaseKey_f80fed951d8f34a6(hKey, machineName);
    }
    
    RegistryKey* RegistryKey::OpenBaseKey(RegistryHive hKey, RegistryView view) {
        switch(hKey) {
            case RegistryHive::ClassesRoot: case_92: {
                return Registry::ClassesRoot;
            }
            case RegistryHive::CurrentConfig: case_93: {
                return Registry::CurrentConfig;
            }
            case RegistryHive::CurrentUser: case_94: {
                return Registry::CurrentUser;
            }
            case RegistryHive::DynData: case_95: {
                return Registry::DynData;
            }
            case RegistryHive::LocalMachine: case_96: {
                return Registry::LocalMachine;
            }
            case RegistryHive::PerformanceData: case_97: {
                return Registry::PerformanceData;
            }
            case RegistryHive::Users: case_98: {
                return Registry::Users;
            }
        }
        throw cli::gcnew<System::ArgumentException>(_T("hKey"));
    }
    
    RegistryKey* RegistryKey::OpenSubKey3(System::String* name, RegistryKeyPermissionCheck permissionCheck) {
        return OpenSubKey(name);
    }
    
    RegistryKey* RegistryKey::OpenSubKey4(System::String* name, RegistryKeyPermissionCheck permissionCheck, System::Security::AccessControl::RegistryRights rights) {
        return OpenSubKey(name);
    }
    
    void RegistryKey::SetAccessControl(System::Security::AccessControl::RegistrySecurity* registrySecurity) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    System::String* RegistryKey::ToString_1636a0751cb9ac11() {
        AssertKeyStillValid();
        return RegistryApi->ToString_8a8e8752aa6cc828(this);
    }
    
    void RegistryKey::AssertKeyStillValid() {
        if((this->handle ==  nullptr)) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("Microsoft.Win32.RegistryKey"));
        }
    }
    
    void RegistryKey::AssertKeyNameNotNull(System::String* subKeyName) {
        if((subKeyName ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("name"));
        }
    }
    
    void RegistryKey::AssertKeyNameLength(System::String* name) {
        if((name->get_Length() > 255)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Name of registry key cannot be greater than 255 characters"));
        }
    }
    
    void RegistryKey::DeleteChildKeysAndValues() {
        if(this->get_IsRoot()) 
        {
            return;
        }
        cli::array<System::String*> *subKeys = GetSubKeyNames();
        for(auto tmp_11 : subKeys) {
            auto subKey = cli::cast<System::String*>(tmp_11);
            {
                RegistryKey *sub = OpenSubKey2(subKey, true);
                sub->DeleteChildKeysAndValues();
                sub->Close();
                DeleteSubKey2(subKey, false);
            }
        }
        cli::array<System::String*> *values = GetValueNames();
        for(auto tmp_12 : values) {
            auto value = cli::cast<System::String*>(tmp_12);
            {
                DeleteValue2(value, false);
            }
        }
    }
    
    System::String* RegistryKey::DecodeString(cli::array<unsigned char>* data) {
        System::String *stringRep = System::Text::Encoding::get_Unicode()->GetString_12d22365648431d7(data);
        int32_t idx = stringRep->IndexOf4(u'\x0');
        if((idx != -1)) 
        {
            stringRep = stringRep->TrimEnd((new cli::array<char16_t>({u'\x0'})));
        }
        return stringRep;
    }
    
    System::IO::IOException* RegistryKey::CreateMarkedForDeletionException() {
        throw cli::gcnew<System::IO::IOException>(_T("Illegal operation attempted on a registry key that has been marked for deletion."));
    }
    
    System::String* RegistryKey::GetHiveName(RegistryHive hive) {
        switch(hive) {
            case RegistryHive::ClassesRoot: case_99: {
                return _T("HKEY_CLASSES_ROOT");
            }
            case RegistryHive::CurrentConfig: case_100: {
                return _T("HKEY_CURRENT_CONFIG");
            }
            case RegistryHive::CurrentUser: case_101: {
                return _T("HKEY_CURRENT_USER");
            }
            case RegistryHive::DynData: case_102: {
                return _T("HKEY_DYN_DATA");
            }
            case RegistryHive::LocalMachine: case_103: {
                return _T("HKEY_LOCAL_MACHINE");
            }
            case RegistryHive::PerformanceData: case_104: {
                return _T("HKEY_PERFORMANCE_DATA");
            }
            case RegistryHive::Users: case_105: {
                return _T("HKEY_USERS");
            }
        }
        throw cli::gcnew<System::NotImplementedException>(System::String::Format2(_T("Registry hive \'{0}\' is not implemented."), cli::import(hive)->ToString_1636a0751cb9ac11()));
    }
    
    System::String* RegistryKey::get_Name() {
        return this->qname;
    }
    
    int32_t RegistryKey::get_SubKeyCount() {
        AssertKeyStillValid();
        return RegistryApi->SubKeyCount_2748a641640ffdf6(this);
    }
    
    int32_t RegistryKey::get_ValueCount() {
        AssertKeyStillValid();
        return RegistryApi->ValueCount_2062387fe7292f8d(this);
    }
    
    SafeHandles::SafeRegistryHandle* RegistryKey::get_Handle() {
        AssertKeyStillValid();
        if((this->safe_handle ==  nullptr)) 
        {
            void *h = RegistryApi->GetHandle_1af66fc049eafa1e(this);
            this->safe_handle = cli::gcnew<SafeHandles::SafeRegistryHandle>(h, true);
        }
        return this->safe_handle;
    }
    
    RegistryView RegistryKey::get_View() {
        return RegistryView::Default2;
    }
    
    bool RegistryKey::get_IsRoot() {
        return (this->hive != nullptr);
    }
    
    bool RegistryKey::get_IsWritable() {
        return this->isWritable;
    }
    
    RegistryHive RegistryKey::get_Hive() {
        if(!(this->get_IsRoot())) 
        {
            throw cli::gcnew<System::NotSupportedException>();
        }
        return cli::unbox<RegistryHive>(this->hive);
    }
    
    System::Object* RegistryKey::get_InternalHandle() {
        return this->handle;
    }
    
}}
namespace Microsoft { namespace Win32 {
    
    
    void ExpandString::constructor(System::String* s) {
        this->value = s;
    }
    
    System::String* ExpandString::ToString_1636a0751cb9ac11() {
        return this->value;
    }
    
    System::String* ExpandString::Expand() {
        System::Text::StringBuilder *sb = cli::gcnew<System::Text::StringBuilder>();
        for(int32_t i = 0; (i < this->value->get_Length()); i++){
            if(((int32_t)(this->value->get_Chars(i)) ==  37)) 
            {
                int32_t j = (i + 1);
                for(; (j < this->value->get_Length()); j++){
                    if(((int32_t)(this->value->get_Chars(j)) ==  37)) 
                    {
                        System::String *key = this->value->Substring2((i + 1), ((j - i) - 1));
                        sb->Append2(System::Environment::GetEnvironmentVariable(key));
                        (i = i + j);
                        break;
                    }
                }
                if((j ==  this->value->get_Length())) 
                {
                    sb->Append16(u'%');
                }
            }
             else 
            {
                sb->Append16(this->value->get_Chars(i));
            }
        }
        return sb->ToString_1636a0751cb9ac11();
    }
    
}}
namespace Microsoft { namespace Win32 {
    
    System::Collections::Hashtable*  KeyHandler::key_to_handler;
    System::Collections::Hashtable*  KeyHandler::dir_to_handler;
    System::String*  KeyHandler::user_store;
    System::String*  KeyHandler::machine_store;
    
    KeyHandler::KeyHandler()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void KeyHandler::static_constructor() {
        CleanVolatileKeys();
    }
    
    void KeyHandler::constructor(RegistryKey* rkey, System::String* basedir) {
    }
    
    void KeyHandler::constructor(RegistryKey* rkey, System::String* basedir, bool is_volatile) {
        System::String *volatile_basedir = GetVolatileDir(basedir);
        System::String *actual_basedir = basedir;
        if(System::IO::Directory::Exists(basedir)) 
        {
            is_volatile = false;
        }
         else 
        {
            if(System::IO::Directory::Exists(volatile_basedir)) 
            {
                actual_basedir = volatile_basedir;
                is_volatile = true;
            }
             else 
            {
                if(is_volatile) 
                {
                    actual_basedir = volatile_basedir;
                }
            }
        }
        if(!(System::IO::Directory::Exists(actual_basedir))) 
        {
            try {
                System::IO::Directory::CreateDirectory(actual_basedir);
            }
            catch(System::UnauthorizedAccessException*) {
                throw cli::gcnew<System::Security::SecurityException>(_T("No access to the given key"));
            }
        }
        this->Dir = basedir;
        this->ActualDir = actual_basedir;
        this->IsVolatile2 = is_volatile;
        this->file = System::IO::Path::Combine(this->ActualDir, _T("values.xml"));
        Load();
    }
    
    void KeyHandler::Finalize_3f786511f9cd099b() {
        {
            cli::finally_guard([&]() {
                Finalize_b946fbc32e26afd6();
            });
            Flush();
        }
    }
    
    void KeyHandler::Load() {
        this->values = cli::gcnew<System::Collections::Hashtable>();
        if(!(System::IO::File::Exists(this->file))) 
        {
            return;
        }
        try {
            {
                /* USING - BLOCK */
                auto fs = System::IO::File::OpenRead(this->file);
                cli::using_guard{fs};
                System::IO::StreamReader *r = cli::gcnew<System::IO::StreamReader>(fs);
                System::String *xml = r->ReadToEnd_f683943dd5002e1e();
                if((xml->get_Length() ==  0)) 
                {
                    return;
                }
                System::Security::SecurityElement *tree = System::Security::SecurityElement::FromString(xml);
                if((System::String::op_Equality(tree->get_Tag(), _T("values")) && (tree->get_Children() != nullptr))) 
                {
                    for(auto tmp_13 : tree->get_Children()) {
                        auto value = cli::cast<System::Security::SecurityElement*>(tmp_13);
                        {
                            if(System::String::op_Equality(value->get_Tag(), _T("value"))) 
                            {
                                LoadKey(value);
                            }
                        }
                    }
                }
            }
        }
        catch(System::UnauthorizedAccessException*) {
            this->values->Clear_f1f405c8fa63a059();
            throw cli::gcnew<System::Security::SecurityException>(_T("No access to the given key"));
        }
        catch(System::Exception* e) {
            System::Console::get_Error()->WriteLine_b33fb6632b99859a(_T("While loading registry key at {0}: {1}"), this->file, e);
            this->values->Clear_f1f405c8fa63a059();
        }
    }
    
    void KeyHandler::LoadKey(System::Security::SecurityElement* se) {
        System::Collections::Hashtable *h = se->get_Attributes();
        try {
            System::String *name = cli::cast<System::String*>(h->get_Item_d75c6e706b965758(_T("name")));
            if((name ==  nullptr)) 
            {
                return;
            }
            System::String *type = cli::cast<System::String*>(h->get_Item_d75c6e706b965758(_T("type")));
            if((type ==  nullptr)) 
            {
                return;
            }
            System::String* tmp_14 = type;
            ::System::Int32 tmp_15 = -1;
            if(::System::String::Equals3(tmp_14, _T("int"))) tmp_15 = 0;
            if(::System::String::Equals3(tmp_14, _T("bytearray"))) tmp_15 = 1;
            if(::System::String::Equals3(tmp_14, _T("string"))) tmp_15 = 2;
            if(::System::String::Equals3(tmp_14, _T("expand"))) tmp_15 = 3;
            if(::System::String::Equals3(tmp_14, _T("qword"))) tmp_15 = 4;
            if(::System::String::Equals3(tmp_14, _T("string-array"))) tmp_15 = 5;
            switch(tmp_15)
            {
                case 0: case_106: 
                {
                    this->values->set_Item_84c7e24d9caa09(name, cli::box(System::Int32::Parse5(se->get_Text())));
                    break;
                }
                case 1: case_107: 
                {
                    this->values->set_Item_84c7e24d9caa09(name, System::Convert::FromBase64String(se->get_Text()));
                    break;
                }
                case 2: case_108: 
                {
                    this->values->set_Item_84c7e24d9caa09(name, (se->get_Text() ==  nullptr) ? System::String::Empty : se->get_Text());
                    break;
                }
                case 3: case_109: 
                {
                    this->values->set_Item_84c7e24d9caa09(name, cli::gcnew<ExpandString>(se->get_Text()));
                    break;
                }
                case 4: case_110: 
                {
                    this->values->set_Item_84c7e24d9caa09(name, cli::box(System::Int64::Parse5(se->get_Text())));
                    break;
                }
                case 5: case_111: 
                {
                    System::Collections::Generic::List<System::String*> *sa = cli::gcnew<System::Collections::Generic::List<System::String*>>();
                    if((se->get_Children() != nullptr)) 
                    {
                        for(auto tmp_16 : se->get_Children()) {
                            auto stre = cli::cast<System::Security::SecurityElement*>(tmp_16);
                            {
                                sa->Add(stre->get_Text());
                            }
                        }
                    }
                    this->values->set_Item_84c7e24d9caa09(name, sa->ToArray());
                    break;
                }
            }
        }
        catch(...) {
        }
    }
    
    RegistryKey* KeyHandler::Ensure(RegistryKey* rkey, System::String* extra, bool writable) {
        return Ensure2(rkey, extra, writable, false);
    }
    
    RegistryKey* KeyHandler::Ensure2(RegistryKey* rkey, System::String* extra, bool writable, bool is_volatile) {
        {
            cli::lock_guard{cli::typeof<System::Type>::info};
            System::String *f = System::IO::Path::Combine(this->Dir, extra);
            KeyHandler *kh = cli::cast<KeyHandler*>(dir_to_handler->get_Item_d75c6e706b965758(f));
            if((kh ==  nullptr)) 
            {
                kh = cli::gcnew<KeyHandler>(rkey, f, is_volatile);
            }
            RegistryKey *rk = cli::gcnew<RegistryKey>(kh, CombineName(rkey, extra), writable);
            key_to_handler->set_Item_84c7e24d9caa09(rk, kh);
            dir_to_handler->set_Item_84c7e24d9caa09(f, kh);
            return rk;
        }
    }
    
    RegistryKey* KeyHandler::Probe(RegistryKey* rkey, System::String* extra, bool writable) {
        RegistryKey *rk = nullptr;
        {
            cli::lock_guard{cli::typeof<System::Type>::info};
            System::String *f = System::IO::Path::Combine(this->Dir, extra);
            KeyHandler *kh = cli::cast<KeyHandler*>(dir_to_handler->get_Item_d75c6e706b965758(f));
            if((kh != nullptr)) 
            {
                rk = cli::gcnew<RegistryKey>(kh, CombineName(rkey, extra), writable);
                key_to_handler->set_Item_84c7e24d9caa09(rk, kh);
            }
             else 
            {
                if((System::IO::Directory::Exists(f) || VolatileKeyExists(f))) 
                {
                    kh = cli::gcnew<KeyHandler>(rkey, f);
                    rk = cli::gcnew<RegistryKey>(kh, CombineName(rkey, extra), writable);
                    dir_to_handler->set_Item_84c7e24d9caa09(f, kh);
                    key_to_handler->set_Item_84c7e24d9caa09(rk, kh);
                }
            }
            return rk;
        }
    }
    
    System::String* KeyHandler::CombineName(RegistryKey* rkey, System::String* extra) {
        if((extra->IndexOf4(u'/') != -1)) 
        {
            extra = extra->Replace(u'/', u'\\');
        }
        return System::String::Concat6(rkey->get_Name(), _T("\\"), extra);
    }
    
    int64_t KeyHandler::GetSystemBootTime() {
        if(!(System::IO::File::Exists(_T("/proc/stat")))) 
        {
            return -1L;
        }
        System::String *btime = nullptr;
        System::String *line;
        try {
            {
                /* USING - BLOCK */
                auto stat_file = cli::gcnew<System::IO::StreamReader>(_T("/proc/stat"), System::Text::Encoding::get_ASCII());
                cli::using_guard{stat_file};
                while(((line = stat_file->ReadLine_51552a49261f929e()) != (nullptr))) if(line->StartsWith(_T("btime"))) 
                {
                    btime = line;
                    break;
                }
            }
        }
        catch(System::Exception* e) {
            System::Console::get_Error()->WriteLine_5eb6d2f1667d4085(_T("While reading system info {0}"), e);
        }
        if((btime ==  nullptr)) 
        {
            return -1L;
        }
        int32_t space = btime->IndexOf4(u' ');
        int64_t res;
        if(!(System::Int64::TryParse(btime->Substring2(space, (btime->get_Length() - space)), res))) 
        {
            return -1L;
        }
        return res;
    }
    
    int64_t KeyHandler::GetRegisteredBootTime(System::String* path) {
        if(!(System::IO::File::Exists(path))) 
        {
            return -1L;
        }
        System::String *line = nullptr;
        try {
            {
                {
                    auto reader = cli::gcnew<System::IO::StreamReader>(path, System::Text::Encoding::get_ASCII());
                    cli::using_guard{reader};
                }
            }
        }
        catch(System::Exception* e) {
            System::Console::get_Error()->WriteLine_b33fb6632b99859a(_T("While reading registry data at {0}: {1}"), path, e);
        }
        if((line ==  nullptr)) 
        {
            return -1L;
        }
        int64_t res;
        if(!(System::Int64::TryParse(line, res))) 
        {
            return -1L;
        }
        return res;
    }
    
    void KeyHandler::SaveRegisteredBootTime(System::String* path, int64_t btime) {
        try {
            {
                {
                    auto writer = cli::gcnew<System::IO::StreamWriter>(path, false, System::Text::Encoding::get_ASCII());
                    cli::using_guard{writer};
                }
            }
        }
        catch(System::Exception* e) {
            System::Console::get_Error()->WriteLine_b33fb6632b99859a(_T("While saving registry data at {0}: {1}"), path, e);
        }
    }
    
    void KeyHandler::CleanVolatileKeys() {
        int64_t system_btime = GetSystemBootTime();
        cli::array<System::String*> *roots = (new cli::array<System::String*>({get_UserStore(), get_MachineStore()}));
        for(auto tmp_17 : roots) {
            auto root = cli::cast<System::String*>(tmp_17);
            {
                if(!(System::IO::Directory::Exists(root))) 
                {
                    continue;
                }
                System::String *btime_file = System::IO::Path::Combine(root, _T("last-btime"));
                System::String *volatile_dir = System::IO::Path::Combine(root, _T("volatile-keys"));
                if(System::IO::Directory::Exists(volatile_dir)) 
                {
                    int64_t registered_btime = GetRegisteredBootTime(btime_file);
                    if((((system_btime < 0L) || (registered_btime < 0L)) || (registered_btime != system_btime))) 
                    {
                        System::IO::Directory::Delete2(volatile_dir, true);
                    }
                }
                SaveRegisteredBootTime(btime_file, system_btime);
            }
        }
    }
    
    bool KeyHandler::VolatileKeyExists(System::String* dir) {
        {
            cli::lock_guard{cli::typeof<System::Type>::info};
            KeyHandler *kh = cli::cast<KeyHandler*>(dir_to_handler->get_Item_d75c6e706b965758(dir));
            if((kh != nullptr)) 
            {
                return kh->IsVolatile2;
            }
        }
        if(System::IO::Directory::Exists(dir)) 
        {
            return false;
        }
        return System::IO::Directory::Exists(GetVolatileDir(dir));
    }
    
    System::String* KeyHandler::GetVolatileDir(System::String* dir) {
        System::String *root = GetRootFromDir(dir);
        System::String *volatile_dir = dir->Replace2(root, System::IO::Path::Combine(root, _T("volatile-keys")));
        return volatile_dir;
    }
    
    KeyHandler* KeyHandler::Lookup(RegistryKey* rkey, bool createNonExisting) {
        {
            cli::lock_guard{cli::typeof<System::Type>::info};
            KeyHandler *k = cli::cast<KeyHandler*>(key_to_handler->get_Item_d75c6e706b965758(rkey));
            if((k != nullptr)) 
            {
                return k;
            }
            if((!(rkey->get_IsRoot()) || !(createNonExisting))) 
            {
                return nullptr;
            }
            RegistryHive x = (RegistryHive)(rkey->get_Hive());
            switch(x) {
                case RegistryHive::CurrentUser: case_112: {
                    System::String *userDir = System::IO::Path::Combine(KeyHandler::get_UserStore(), cli::import(x)->ToString_1636a0751cb9ac11());
                    k = cli::gcnew<KeyHandler>(rkey, userDir);
                    dir_to_handler->set_Item_84c7e24d9caa09(userDir, k);
                    break;
                }
                case RegistryHive::CurrentConfig: case RegistryHive::ClassesRoot: case RegistryHive::DynData: case RegistryHive::LocalMachine: case RegistryHive::PerformanceData: case RegistryHive::Users: case_113: {
                    System::String *machine_dir = System::IO::Path::Combine(KeyHandler::get_MachineStore(), cli::import(x)->ToString_1636a0751cb9ac11());
                    k = cli::gcnew<KeyHandler>(rkey, machine_dir);
                    dir_to_handler->set_Item_84c7e24d9caa09(machine_dir, k);
                    break;
                }
                default: case_114: {
                    throw cli::gcnew<System::Exception>(_T("Unknown RegistryHive"));
                }
            }
            key_to_handler->set_Item_84c7e24d9caa09(rkey, k);
            return k;
        }
    }
    
    System::String* KeyHandler::GetRootFromDir(System::String* dir) {
        if((dir->IndexOf7(KeyHandler::get_UserStore()) > -1)) 
        {
            return KeyHandler::get_UserStore();
        }
         else 
        {
            if((dir->IndexOf7(KeyHandler::get_MachineStore()) > -1)) 
            {
                return KeyHandler::get_MachineStore();
            }
        }
        throw cli::gcnew<System::Exception>(cli::concat(_T("Could not get root for dir "), dir));
    }
    
    void KeyHandler::Drop(RegistryKey* rkey) {
        {
            cli::lock_guard{cli::typeof<System::Type>::info};
            KeyHandler *k = cli::cast<KeyHandler*>(key_to_handler->get_Item_d75c6e706b965758(rkey));
            if((k ==  nullptr)) 
            {
                return;
            }
            key_to_handler->Remove_fd653674dd8a5ac4(rkey);
            int32_t refCount = 0;
            for(auto tmp_18 : key_to_handler) {
                auto de = cli::cast<System::Collections::DictionaryEntry>(tmp_18);
                if((de->get_Value() ==  k)) 
                {
                    refCount++;
                }
            }
            if((refCount ==  0)) 
            {
                dir_to_handler->Remove_fd653674dd8a5ac4(k->Dir);
            }
        }
    }
    
    void KeyHandler::Drop2(System::String* dir) {
        {
            cli::lock_guard{cli::typeof<System::Type>::info};
            KeyHandler *kh = cli::cast<KeyHandler*>(dir_to_handler->get_Item_d75c6e706b965758(dir));
            if((kh ==  nullptr)) 
            {
                return;
            }
            dir_to_handler->Remove_fd653674dd8a5ac4(dir);
            System::Collections::ArrayList *keys = cli::gcnew<System::Collections::ArrayList>();
            for(auto tmp_19 : key_to_handler) {
                auto de = cli::cast<System::Collections::DictionaryEntry>(tmp_19);
                if((de->get_Value() ==  kh)) 
                {
                    keys->Add_e6a92085999ce388(de->get_Key());
                }
            }
            for(auto tmp_20 : keys) {
                auto key = cli::cast<System::Object*>(tmp_20);
                key_to_handler->Remove_fd653674dd8a5ac4(key);
            }
        }
    }
    
    bool KeyHandler::Delete(System::String* dir) {
        if(!(System::IO::Directory::Exists(dir))) 
        {
            System::String *volatile_dir = GetVolatileDir(dir);
            if(!(System::IO::Directory::Exists(volatile_dir))) 
            {
                return false;
            }
            dir = volatile_dir;
        }
        System::IO::Directory::Delete2(dir, true);
        Drop2(dir);
        return true;
    }
    
    RegistryValueKind KeyHandler::GetValueKind(System::String* name) {
        if((name ==  nullptr)) 
        {
            return RegistryValueKind::Unknown;
        }
        System::Object *value = this->values->get_Item_d75c6e706b965758(name);
        if((value ==  nullptr)) 
        {
            return RegistryValueKind::Unknown;
        }
        if(cli::is<System::Int32>(value)) 
        {
            return RegistryValueKind::DWord;
        }
        if(cli::is<cli::array<System::String*>>(value)) 
        {
            return RegistryValueKind::MultiString;
        }
        if(cli::is<System::Int64>(value)) 
        {
            return RegistryValueKind::QWord;
        }
        if(cli::is<cli::array<unsigned char>>(value)) 
        {
            return RegistryValueKind::Binary;
        }
        if(cli::is<System::String>(value)) 
        {
            return RegistryValueKind::String2;
        }
        if(cli::is<ExpandString>(value)) 
        {
            return RegistryValueKind::ExpandString2;
        }
        return RegistryValueKind::Unknown;
    }
    
    System::Object* KeyHandler::GetValue(System::String* name, RegistryValueOptions options) {
        if(this->get_IsMarkedForDeletion()) 
        {
            return nullptr;
        }
        if((name ==  nullptr)) 
        {
            name = System::String::Empty;
        }
        System::Object *value = this->values->get_Item_d75c6e706b965758(name);
        ExpandString *exp = cli::as<ExpandString*>(value);
        if((exp ==  nullptr)) 
        {
            return value;
        }
        if(((int32_t)(((int32_t)(options) & 1)) ==  0)) 
        {
            return exp->Expand();
        }
        return exp->ToString_1636a0751cb9ac11();
    }
    
    void KeyHandler::SetValue(System::String* name, System::Object* value) {
        AssertNotMarkedForDeletion();
        if((name ==  nullptr)) 
        {
            name = System::String::Empty;
        }
        if((((cli::is<System::Int32>(value) || cli::is<System::String>(value)) || cli::is<cli::array<unsigned char>>(value)) || cli::is<cli::array<System::String*>>(value))) 
        {
            this->values->set_Item_84c7e24d9caa09(name, value);
        }
         else 
        {
            this->values->set_Item_84c7e24d9caa09(name, value->ToString_1636a0751cb9ac11());
        }
        SetDirty();
    }
    
    cli::array<System::String*>* KeyHandler::GetValueNames() {
        AssertNotMarkedForDeletion();
        System::Collections::ICollection *keys = this->values->get_Keys_8171dfd94447fa93();
        cli::array<System::String*> *vals = (new cli::array<System::String*>(keys->get_Count_8f254f3dd8e2403()));
        keys->CopyTo_7065a6e3cf6a140(vals, 0);
        return vals;
    }
    
    int32_t KeyHandler::GetSubKeyCount() {
        return GetSubKeyNames()->get_Length();
    }
    
    cli::array<System::String*>* KeyHandler::GetSubKeyNames() {
        System::IO::DirectoryInfo *selfDir = cli::gcnew<System::IO::DirectoryInfo>(this->ActualDir);
        cli::array<System::IO::DirectoryInfo*> *subDirs = selfDir->GetDirectories();
        cli::array<System::String*> *subKeyNames;
        if((this->IsVolatile2 || !(System::IO::Directory::Exists(GetVolatileDir(this->Dir))))) 
        {
            subKeyNames = (new cli::array<System::String*>(subDirs->get_Length()));
            for(int32_t i = 0; (i < subDirs->get_Length()); i++){
                System::IO::DirectoryInfo *subDir = subDirs->at(i);
                subKeyNames->at(i) = subDir->get_Name_34b64716a6d0afcd();
            }
            return subKeyNames;
        }
        System::IO::DirectoryInfo *volatileDir = cli::gcnew<System::IO::DirectoryInfo>(GetVolatileDir(this->Dir));
        cli::array<System::IO::DirectoryInfo*> *volatileSubDirs = volatileDir->GetDirectories();
        System::Collections::Generic::Dictionary<System::String*, System::String*> *dirs = cli::gcnew<System::Collections::Generic::Dictionary<System::String*, System::String*>>();
        for(auto tmp_21 : subDirs) {
            auto dir = cli::cast<System::IO::DirectoryInfo*>(tmp_21);
            dirs->set_Item(dir->get_Name_34b64716a6d0afcd(), dir->get_Name_34b64716a6d0afcd());
        }
        for(auto tmp_22 : volatileSubDirs) {
            auto volDir = cli::cast<System::IO::DirectoryInfo*>(tmp_22);
            dirs->set_Item(volDir->get_Name_34b64716a6d0afcd(), volDir->get_Name_34b64716a6d0afcd());
        }
        subKeyNames = (new cli::array<System::String*>(dirs->get_Count()));
        int32_t j = 0;
        for(auto tmp_23 : dirs) {
            auto entry = cli::cast<System::Collections::Generic::KeyValuePair<System::String*, System::String*>>(tmp_23);
            subKeyNames->at(j++) = entry->get_Value();
        }
        return subKeyNames;
    }
    
    void KeyHandler::SetValue2(System::String* name, System::Object* value, RegistryValueKind valueKind) {
        SetDirty();
        if((name ==  nullptr)) 
        {
            name = System::String::Empty;
        }
        switch(valueKind) {
            case RegistryValueKind::String2: case_115: {
                if(cli::is<System::String>(value)) 
                {
                    this->values->set_Item_84c7e24d9caa09(name, value);
                    return;
                }
                break;
            }
            case RegistryValueKind::ExpandString2: case_116: {
                if(cli::is<System::String>(value)) 
                {
                    this->values->set_Item_84c7e24d9caa09(name, cli::gcnew<ExpandString>(cli::cast<System::String*>(value)));
                    return;
                }
                break;
            }
            case RegistryValueKind::Binary: case_117: {
                if(cli::is<cli::array<unsigned char>>(value)) 
                {
                    this->values->set_Item_84c7e24d9caa09(name, value);
                    return;
                }
                break;
            }
            case RegistryValueKind::DWord: case_118: {
                try {
                    this->values->set_Item_84c7e24d9caa09(name, cli::box(System::Convert::ToInt3218(value)));
                    return;
                }
                catch(System::OverflowException*) {
                    break;
                }
            }
            case RegistryValueKind::MultiString: case_119: {
                if(cli::is<cli::array<System::String*>>(value)) 
                {
                    this->values->set_Item_84c7e24d9caa09(name, value);
                    return;
                }
                break;
            }
            case RegistryValueKind::QWord: case_120: {
                try {
                    this->values->set_Item_84c7e24d9caa09(name, cli::box(System::Convert::ToInt6418(value)));
                    return;
                }
                catch(System::OverflowException*) {
                    break;
                }
            }
            default: case_121: {
                throw cli::gcnew<System::ArgumentException>(_T("unknown value"), _T("valueKind"));
            }
        }
        throw cli::gcnew<System::ArgumentException>(_T("Value could not be converted to specified type"), _T("valueKind"));
    }
    
    void KeyHandler::SetDirty() {
        {
            cli::lock_guard{cli::typeof<System::Type>::info};
            if(this->dirty) 
            {
                return;
            }
            this->dirty = true;
            cli::gcnew<System::Threading::Timer>(cli::bind(this, &KeyHandler::DirtyTimeout), nullptr, 3000, -1);
        }
    }
    
    void KeyHandler::DirtyTimeout(System::Object* state) {
        Flush();
    }
    
    void KeyHandler::Flush() {
        {
            cli::lock_guard{cli::typeof<System::Type>::info};
            if(this->dirty) 
            {
                Save();
                this->dirty = false;
            }
        }
    }
    
    bool KeyHandler::ValueExists(System::String* name) {
        if((name ==  nullptr)) 
        {
            name = System::String::Empty;
        }
        return this->values->Contains_be7d0f2741618cb4(name);
    }
    
    void KeyHandler::RemoveValue(System::String* name) {
        AssertNotMarkedForDeletion();
        this->values->Remove_fd653674dd8a5ac4(name);
        SetDirty();
    }
    
    void KeyHandler::Save() {
        if(this->get_IsMarkedForDeletion()) 
        {
            return;
        }
        if((!(System::IO::File::Exists(this->file)) && (this->values->get_Count_40aff81471a60b4c() ==  0))) 
        {
            return;
        }
        System::Security::SecurityElement *se = cli::gcnew<System::Security::SecurityElement>(_T("values"));
        for(auto tmp_24 : this->values) {
            auto de = cli::cast<System::Collections::DictionaryEntry>(tmp_24);
            {
                System::Object *val = de->get_Value();
                System::Security::SecurityElement *value = cli::gcnew<System::Security::SecurityElement>(_T("value"));
                value->AddAttribute(_T("name"), System::Security::SecurityElement::Escape2(cli::cast<System::String*>(de->get_Key())));
                if(cli::is<System::String>(val)) 
                {
                    value->AddAttribute(_T("type"), _T("string"));
                    value->set_Text(System::Security::SecurityElement::Escape2(cli::cast<System::String*>(val)));
                }
                 else 
                {
                    if(cli::is<System::Int32>(val)) 
                    {
                        value->AddAttribute(_T("type"), _T("int"));
                        value->set_Text(val->ToString_1636a0751cb9ac11());
                    }
                     else 
                    {
                        if(cli::is<System::Int64>(val)) 
                        {
                            value->AddAttribute(_T("type"), _T("qword"));
                            value->set_Text(val->ToString_1636a0751cb9ac11());
                        }
                         else 
                        {
                            if(cli::is<cli::array<unsigned char>>(val)) 
                            {
                                value->AddAttribute(_T("type"), _T("bytearray"));
                                value->set_Text(System::Convert::ToBase64String(cli::cast<cli::array<unsigned char>*>(val)));
                            }
                             else 
                            {
                                if(cli::is<ExpandString>(val)) 
                                {
                                    value->AddAttribute(_T("type"), _T("expand"));
                                    value->set_Text(System::Security::SecurityElement::Escape2(val->ToString_1636a0751cb9ac11()));
                                }
                                 else 
                                {
                                    if(cli::is<cli::array<System::String*>>(val)) 
                                    {
                                        value->AddAttribute(_T("type"), _T("string-array"));
                                        for(auto tmp_25 : cli::cast<cli::array<System::String*>*>(val)) {
                                            auto ss = cli::cast<System::String*>(tmp_25);
                                            {
                                                System::Security::SecurityElement *str = cli::gcnew<System::Security::SecurityElement>(_T("string"));
                                                str->set_Text(System::Security::SecurityElement::Escape2(ss));
                                                value->AddChild(str);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                se->AddChild(value);
            }
        }
        {
            /* USING - BLOCK */
            auto fs = System::IO::File::Create(this->file);
            cli::using_guard{fs};
            System::IO::StreamWriter *sw = cli::gcnew<System::IO::StreamWriter>(fs);
            sw->Write_dcf5e45abd9e11c4(se->ToString_1636a0751cb9ac11());
            sw->Flush_c8220c56815bfd56();
        }
    }
    
    void KeyHandler::AssertNotMarkedForDeletion() {
        if(this->get_IsMarkedForDeletion()) 
        {
            throw RegistryKey::CreateMarkedForDeletionException();
        }
    }
    
    int32_t KeyHandler::get_ValueCount() {
        return this->values->get_Keys_8171dfd94447fa93()->get_Count_8f254f3dd8e2403();
    }
    
    bool KeyHandler::get_IsMarkedForDeletion() {
        return !(dir_to_handler->Contains_be7d0f2741618cb4(this->Dir));
    }
    
    System::String* KeyHandler::get_UserStore() {
        if((user_store ==  nullptr)) 
        {
            user_store = System::IO::Path::Combine(System::Environment::GetFolderPath(System::SpecialFolder::MyDocuments), _T(".mono/registry"));
        }
        return user_store;
    }
    
    System::String* KeyHandler::get_MachineStore() {
        if((machine_store ==  nullptr)) 
        {
            machine_store = System::Environment::GetEnvironmentVariable(_T("MONO_REGISTRY_PATH"));
            if((machine_store ==  nullptr)) 
            {
                System::String *s = System::Environment::GetMachineConfigPath();
                int32_t p = s->IndexOf7(_T("machine.config"));
                machine_store = System::IO::Path::Combine(System::IO::Path::Combine(s->Substring2(0, (p - 1)), _T("..")), _T("registry"));
            }
        }
        return machine_store;
    }
    
}}
namespace Microsoft { namespace Win32 {
    
    
    void UnixRegistryApi::constructor() {
    }
    
    System::String* UnixRegistryApi::ToUnix(System::String* keyname) {
        if((keyname->IndexOf4(u'\\') != -1)) 
        {
            keyname = keyname->Replace(u'\\', u'/');
        }
        return keyname->ToLower();
    }
    
    bool UnixRegistryApi::IsWellKnownKey(System::String* parentKeyName, System::String* keyname) {
        if((System::String::op_Equality(parentKeyName, Registry::CurrentUser->get_Name()) || System::String::op_Equality(parentKeyName, Registry::LocalMachine->get_Name()))) 
        {
            return (0 ==  System::String::Compare3(_T("software"), keyname, true, System::Globalization::CultureInfo::get_InvariantCulture()));
        }
        return false;
    }
    
    RegistryKey* UnixRegistryApi::CreateSubKey(RegistryKey* rkey, System::String* keyname) {
        return CreateSubKey3(rkey, keyname, true);
    }
    
    RegistryKey* UnixRegistryApi::CreateSubKey2(RegistryKey* rkey, System::String* keyname, RegistryOptions options) {
        return CreateSubKey4(rkey, keyname, true, ((int32_t)(options) ==  1));
    }
    
    RegistryKey* UnixRegistryApi::OpenRemoteBaseKey(RegistryHive hKey, System::String* machineName) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    RegistryKey* UnixRegistryApi::OpenSubKey(RegistryKey* rkey, System::String* keyname, bool writable) {
        KeyHandler *self = KeyHandler::Lookup(rkey, true);
        if((self ==  nullptr)) 
        {
            return nullptr;
        }
        RegistryKey *result = self->Probe(rkey, ToUnix(keyname), writable);
        if(((result ==  nullptr) && IsWellKnownKey(rkey->get_Name(), keyname))) 
        {
            result = CreateSubKey3(rkey, keyname, writable);
        }
        return result;
    }
    
    RegistryKey* UnixRegistryApi::FromHandle(SafeHandles::SafeRegistryHandle* handle) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    void UnixRegistryApi::Flush(RegistryKey* rkey) {
        KeyHandler *self = KeyHandler::Lookup(rkey, false);
        if((self ==  nullptr)) 
        {
            return;
        }
        self->Flush();
    }
    
    void UnixRegistryApi::Close(RegistryKey* rkey) {
        KeyHandler::Drop(rkey);
    }
    
    System::Object* UnixRegistryApi::GetValue(RegistryKey* rkey, System::String* name, System::Object* default_value, RegistryValueOptions options) {
        KeyHandler *self = KeyHandler::Lookup(rkey, true);
        if((self ==  nullptr)) 
        {
            return default_value;
        }
        if(self->ValueExists(name)) 
        {
            return self->GetValue(name, options);
        }
        return default_value;
    }
    
    void UnixRegistryApi::SetValue(RegistryKey* rkey, System::String* name, System::Object* value) {
        KeyHandler *self = KeyHandler::Lookup(rkey, true);
        if((self ==  nullptr)) 
        {
            throw RegistryKey::CreateMarkedForDeletionException();
        }
        self->SetValue(name, value);
    }
    
    void UnixRegistryApi::SetValue2(RegistryKey* rkey, System::String* name, System::Object* value, RegistryValueKind valueKind) {
        KeyHandler *self = KeyHandler::Lookup(rkey, true);
        if((self ==  nullptr)) 
        {
            throw RegistryKey::CreateMarkedForDeletionException();
        }
        self->SetValue2(name, value, valueKind);
    }
    
    int32_t UnixRegistryApi::SubKeyCount(RegistryKey* rkey) {
        KeyHandler *self = KeyHandler::Lookup(rkey, true);
        if((self ==  nullptr)) 
        {
            throw RegistryKey::CreateMarkedForDeletionException();
        }
        return self->GetSubKeyCount();
    }
    
    int32_t UnixRegistryApi::ValueCount(RegistryKey* rkey) {
        KeyHandler *self = KeyHandler::Lookup(rkey, true);
        if((self ==  nullptr)) 
        {
            throw RegistryKey::CreateMarkedForDeletionException();
        }
        return self->get_ValueCount();
    }
    
    void UnixRegistryApi::DeleteValue(RegistryKey* rkey, System::String* name, bool throw_if_missing) {
        KeyHandler *self = KeyHandler::Lookup(rkey, true);
        if((self ==  nullptr)) 
        {
            return;
        }
        if((throw_if_missing && !(self->ValueExists(name)))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("the given value does not exist"));
        }
        self->RemoveValue(name);
    }
    
    void UnixRegistryApi::DeleteKey(RegistryKey* rkey, System::String* keyname, bool throw_if_missing) {
        KeyHandler *self = KeyHandler::Lookup(rkey, true);
        if((self ==  nullptr)) 
        {
            if(!(throw_if_missing)) 
            {
                return;
            }
            throw cli::gcnew<System::ArgumentException>(_T("the given value does not exist"));
        }
        System::String *dir = System::IO::Path::Combine(self->Dir, ToUnix(keyname));
        if((!(KeyHandler::Delete(dir)) && throw_if_missing)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("the given value does not exist"));
        }
    }
    
    cli::array<System::String*>* UnixRegistryApi::GetSubKeyNames(RegistryKey* rkey) {
        KeyHandler *self = KeyHandler::Lookup(rkey, true);
        return self->GetSubKeyNames();
    }
    
    cli::array<System::String*>* UnixRegistryApi::GetValueNames(RegistryKey* rkey) {
        KeyHandler *self = KeyHandler::Lookup(rkey, true);
        if((self ==  nullptr)) 
        {
            throw RegistryKey::CreateMarkedForDeletionException();
        }
        return self->GetValueNames();
    }
    
    System::String* UnixRegistryApi::ToString2(RegistryKey* rkey) {
        return rkey->get_Name();
    }
    
    RegistryKey* UnixRegistryApi::CreateSubKey3(RegistryKey* rkey, System::String* keyname, bool writable) {
        return CreateSubKey4(rkey, keyname, writable, false);
    }
    
    RegistryKey* UnixRegistryApi::CreateSubKey4(RegistryKey* rkey, System::String* keyname, bool writable, bool is_volatile) {
        KeyHandler *self = KeyHandler::Lookup(rkey, true);
        if((self ==  nullptr)) 
        {
            throw RegistryKey::CreateMarkedForDeletionException();
        }
        if((KeyHandler::VolatileKeyExists(self->Dir) && !(is_volatile))) 
        {
            throw cli::gcnew<System::IO::IOException>(_T("Cannot create a non volatile subkey under a volatile key."));
        }
        return self->Ensure2(rkey, ToUnix(keyname), writable, is_volatile);
    }
    
    RegistryValueKind UnixRegistryApi::GetValueKind(RegistryKey* rkey, System::String* name) {
        KeyHandler *self = KeyHandler::Lookup(rkey, true);
        if((self != nullptr)) 
        {
            return self->GetValueKind(name);
        }
        return RegistryValueKind::Unknown;
    }
    
    void* UnixRegistryApi::GetHandle(RegistryKey* key) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
}}
namespace Microsoft { namespace Win32 {
    
    
    void Win32RegistryApi::constructor() {
    }
    
    int32_t Win32RegistryApi::RegCreateKeyEx(void* keyBase, System::String* keyName, int32_t reserved, void* lpClass, int32_t options, int32_t access, void* securityAttrs, void* keyHandle, int32_t disposition) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t Win32RegistryApi::RegCloseKey(void* keyHandle) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t Win32RegistryApi::RegConnectRegistry(System::String* machineName, void* hKey, void* keyHandle) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t Win32RegistryApi::RegFlushKey(void* keyHandle) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t Win32RegistryApi::RegOpenKeyEx(void* keyBase, System::String* keyName, void* reserved, int32_t access, void* keyHandle) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t Win32RegistryApi::RegDeleteKey(void* keyHandle, System::String* valueName) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t Win32RegistryApi::RegDeleteValue(void* keyHandle, System::String* valueName) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t Win32RegistryApi::RegEnumKey(void* keyBase, int32_t index, System::Text::StringBuilder* nameBuffer, int32_t bufferLength) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t Win32RegistryApi::RegEnumValue(void* keyBase, int32_t index, System::Text::StringBuilder* nameBuffer, int32_t nameLength, void* reserved, RegistryValueKind type, void* data, void* dataLength) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t Win32RegistryApi::RegSetValueEx(void* keyBase, System::String* valueName, void* reserved, RegistryValueKind type, System::String* data, int32_t rawDataLength) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t Win32RegistryApi::RegSetValueEx2(void* keyBase, System::String* valueName, void* reserved, RegistryValueKind type, cli::array<unsigned char>* rawData, int32_t rawDataLength) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t Win32RegistryApi::RegSetValueEx3(void* keyBase, System::String* valueName, void* reserved, RegistryValueKind type, int32_t data, int32_t rawDataLength) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t Win32RegistryApi::RegSetValueEx4(void* keyBase, System::String* valueName, void* reserved, RegistryValueKind type, int64_t data, int32_t rawDataLength) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t Win32RegistryApi::RegQueryValueEx(void* keyBase, System::String* valueName, void* reserved, RegistryValueKind type, void* zero, int32_t dataSize) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t Win32RegistryApi::RegQueryValueEx2(void* keyBase, System::String* valueName, void* reserved, RegistryValueKind type, cli::array<unsigned char>* data, int32_t dataSize) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t Win32RegistryApi::RegQueryValueEx3(void* keyBase, System::String* valueName, void* reserved, RegistryValueKind type, int32_t data, int32_t dataSize) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t Win32RegistryApi::RegQueryValueEx4(void* keyBase, System::String* valueName, void* reserved, RegistryValueKind type, int64_t data, int32_t dataSize) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void* Win32RegistryApi::GetHandle(RegistryKey* key) {
        return cli::unbox<void*>(key->get_InternalHandle());
    }
    
    bool Win32RegistryApi::IsHandleValid(RegistryKey* key) {
        return (key->get_InternalHandle() != nullptr);
    }
    
    RegistryValueKind Win32RegistryApi::GetValueKind(RegistryKey* rkey, System::String* name) {
        RegistryValueKind type = RegistryValueKind::Unknown;
        int32_t size = 0;
        void *handle = GetHandle(rkey);
        int32_t result = RegQueryValueEx(handle, name, (*::System::IntPtr::Zero), type, (*::System::IntPtr::Zero), size);
        if(((result ==  2) || (result ==  1018))) 
        {
            return RegistryValueKind::Unknown;
        }
        return type;
    }
    
    System::Object* Win32RegistryApi::GetValue(RegistryKey* rkey, System::String* name, System::Object* defaultValue, RegistryValueOptions options) {
        RegistryValueKind type = RegistryValueKind::Unknown;
        int32_t size = 0;
        System::Object *obj = nullptr;
        void *handle = GetHandle(rkey);
        int32_t result = RegQueryValueEx(handle, name, (*::System::IntPtr::Zero), type, (*::System::IntPtr::Zero), size);
        if(((result ==  2) || (result ==  1018))) 
        {
            return defaultValue;
        }
        if(((result != 234) && (result != 0))) 
        {
            GenerateException(result);
        }
        if(((int32_t)(type) ==  1)) 
        {
            cli::array<unsigned char> *data;
            result = GetBinaryValue(rkey, name, type, data, size);
            obj = RegistryKey::DecodeString(data);
        }
         else 
        {
            if(((int32_t)(type) ==  2)) 
            {
                cli::array<unsigned char> *data;
                result = GetBinaryValue(rkey, name, type, data, size);
                obj = RegistryKey::DecodeString(data);
                if(((int32_t)(((int32_t)(options) & 1)) ==  0)) 
                {
                    obj = System::Environment::ExpandEnvironmentVariables(cli::cast<System::String*>(obj));
                }
            }
             else 
            {
                if(((int32_t)(type) ==  4)) 
                {
                    int32_t data = 0;
                    result = RegQueryValueEx3(handle, name, (*::System::IntPtr::Zero), type, data, size);
                    obj = cli::box(data);
                }
                 else 
                {
                    if(((int32_t)(type) ==  11)) 
                    {
                        int64_t data = 0L;
                        result = RegQueryValueEx4(handle, name, (*::System::IntPtr::Zero), type, data, size);
                        obj = cli::box(data);
                    }
                     else 
                    {
                        if(((int32_t)(type) ==  3)) 
                        {
                            cli::array<unsigned char> *data;
                            result = GetBinaryValue(rkey, name, type, data, size);
                            obj = data;
                        }
                         else 
                        {
                            if(((int32_t)(type) ==  7)) 
                            {
                                obj = nullptr;
                                cli::array<unsigned char> *data;
                                result = GetBinaryValue(rkey, name, type, data, size);
                                if((result ==  0)) 
                                {
                                    obj = RegistryKey::DecodeString(data)->Split((new cli::array<char16_t>({u'\x0'})));
                                }
                            }
                             else 
                            {
                                throw cli::gcnew<System::SystemException>();
                            }
                        }
                    }
                }
            }
        }
        if((result != 0)) 
        {
            GenerateException(result);
        }
        return obj;
    }
    
    void Win32RegistryApi::SetValue(RegistryKey* rkey, System::String* name, System::Object* value, RegistryValueKind valueKind) {
        System::Type *type = value->GetType();
        int32_t result;
        void *handle = GetHandle(rkey);
        if((((int32_t)(valueKind) ==  11) && System::Type::op_Equality2(type, cli::typeof<System::Type>::info))) 
        {
            int64_t rawValue = cli::unbox<int64_t>(value);
            result = RegSetValueEx4(handle, name, (*::System::IntPtr::Zero), RegistryValueKind::QWord, rawValue, 8);
        }
         else 
        {
            if((((int32_t)(valueKind) ==  4) && System::Type::op_Equality2(type, cli::typeof<System::Type>::info))) 
            {
                int32_t rawValue = cli::unbox<int32_t>(value);
                result = RegSetValueEx3(handle, name, (*::System::IntPtr::Zero), RegistryValueKind::DWord, rawValue, 4);
            }
             else 
            {
                if((((int32_t)(valueKind) ==  3) && System::Type::op_Equality2(type, cli::typeof<System::Type>::info))) 
                {
                    cli::array<unsigned char> *rawValue = cli::cast<cli::array<unsigned char>*>(value);
                    result = RegSetValueEx2(handle, name, (*::System::IntPtr::Zero), RegistryValueKind::Binary, rawValue, rawValue->get_Length());
                }
                 else 
                {
                    if((((int32_t)(valueKind) ==  7) && System::Type::op_Equality2(type, cli::typeof<System::Type>::info))) 
                    {
                        cli::array<System::String*> *vals = cli::cast<cli::array<System::String*>*>(value);
                        System::Text::StringBuilder *fullStringValue = cli::gcnew<System::Text::StringBuilder>();
                        for(auto tmp_26 : vals) {
                            auto v = cli::cast<System::String*>(tmp_26);
                            {
                                fullStringValue->Append2(v);
                                fullStringValue->Append16(u'\x0');
                            }
                        }
                        fullStringValue->Append16(u'\x0');
                        cli::array<unsigned char> *rawValue = System::Text::Encoding::get_Unicode()->GetBytes_49806e8e98b1c1db(fullStringValue->ToString_1636a0751cb9ac11());
                        result = RegSetValueEx2(handle, name, (*::System::IntPtr::Zero), RegistryValueKind::MultiString, rawValue, rawValue->get_Length());
                    }
                     else 
                    {
                        if(((((int32_t)(valueKind) ==  1) || ((int32_t)(valueKind) ==  2)) && System::Type::op_Equality2(type, cli::typeof<System::Type>::info))) 
                        {
                            System::String *rawValue = System::String::Format3(_T("{0}{1}"), value, cli::box(u'\x0'));
                            result = RegSetValueEx(handle, name, (*::System::IntPtr::Zero), valueKind, rawValue, (rawValue->get_Length() * this->NativeBytesPerCharacter));
                        }
                         else 
                        {
                            if(type->get_IsArray()) 
                            {
                                throw cli::gcnew<System::ArgumentException>(_T("Only string and byte arrays can written as registry values"));
                            }
                             else 
                            {
                                throw cli::gcnew<System::ArgumentException>(_T("Type does not match the valueKind"));
                            }
                        }
                    }
                }
            }
        }
        if((result != 0)) 
        {
            GenerateException(result);
        }
    }
    
    void Win32RegistryApi::SetValue2(RegistryKey* rkey, System::String* name, System::Object* value) {
        System::Type *type = value->GetType();
        int32_t result;
        void *handle = GetHandle(rkey);
        if(System::Type::op_Equality2(type, cli::typeof<System::Type>::info)) 
        {
            int32_t rawValue = cli::unbox<int32_t>(value);
            result = RegSetValueEx3(handle, name, (*::System::IntPtr::Zero), RegistryValueKind::DWord, rawValue, 4);
        }
         else 
        {
            if(System::Type::op_Equality2(type, cli::typeof<System::Type>::info)) 
            {
                cli::array<unsigned char> *rawValue = cli::cast<cli::array<unsigned char>*>(value);
                result = RegSetValueEx2(handle, name, (*::System::IntPtr::Zero), RegistryValueKind::Binary, rawValue, rawValue->get_Length());
            }
             else 
            {
                if(System::Type::op_Equality2(type, cli::typeof<System::Type>::info)) 
                {
                    cli::array<System::String*> *vals = cli::cast<cli::array<System::String*>*>(value);
                    System::Text::StringBuilder *fullStringValue = cli::gcnew<System::Text::StringBuilder>();
                    for(auto tmp_27 : vals) {
                        auto v = cli::cast<System::String*>(tmp_27);
                        {
                            fullStringValue->Append2(v);
                            fullStringValue->Append16(u'\x0');
                        }
                    }
                    fullStringValue->Append16(u'\x0');
                    cli::array<unsigned char> *rawValue = System::Text::Encoding::get_Unicode()->GetBytes_49806e8e98b1c1db(fullStringValue->ToString_1636a0751cb9ac11());
                    result = RegSetValueEx2(handle, name, (*::System::IntPtr::Zero), RegistryValueKind::MultiString, rawValue, rawValue->get_Length());
                }
                 else 
                {
                    if(type->get_IsArray()) 
                    {
                        throw cli::gcnew<System::ArgumentException>(_T("Only string and byte arrays can written as registry values"));
                    }
                     else 
                    {
                        System::String *rawValue = System::String::Format3(_T("{0}{1}"), value, cli::box(u'\x0'));
                        result = RegSetValueEx(handle, name, (*::System::IntPtr::Zero), RegistryValueKind::String2, rawValue, (rawValue->get_Length() * this->NativeBytesPerCharacter));
                    }
                }
            }
        }
        if((result ==  1018)) 
        {
            throw RegistryKey::CreateMarkedForDeletionException();
        }
        if((result != 0)) 
        {
            GenerateException(result);
        }
    }
    
    int32_t Win32RegistryApi::GetBinaryValue(RegistryKey* rkey, System::String* name, RegistryValueKind type, cli::array<unsigned char>* data, int32_t size) {
        cli::array<unsigned char> *internalData = (new cli::array<unsigned char>(size));
        void *handle = GetHandle(rkey);
        int32_t result = RegQueryValueEx2(handle, name, (*::System::IntPtr::Zero), type, internalData, size);
        data = internalData;
        return result;
    }
    
    int32_t Win32RegistryApi::SubKeyCount(RegistryKey* rkey) {
        int32_t index;
        System::Text::StringBuilder *stringBuffer = cli::gcnew<System::Text::StringBuilder>(1024);
        void *handle = GetHandle(rkey);
        for(index = 0; true; index++){
            int32_t result = RegEnumKey(handle, index, stringBuffer, stringBuffer->get_Capacity());
            if((result ==  1018)) 
            {
                throw RegistryKey::CreateMarkedForDeletionException();
            }
            if((result ==  0)) 
            {
                continue;
            }
            if((result ==  259)) 
            {
                break;
            }
            GenerateException(result);
        }
        return index;
    }
    
    int32_t Win32RegistryApi::ValueCount(RegistryKey* rkey) {
        int32_t index, result, bufferCapacity;
        RegistryValueKind type;
        System::Text::StringBuilder *buffer = cli::gcnew<System::Text::StringBuilder>(1024);
        void *handle = GetHandle(rkey);
        for(index = 0; true; index++){
            type = RegistryValueKind::Unknown;
            bufferCapacity = buffer->get_Capacity();
            result = RegEnumValue(handle, index, buffer, bufferCapacity, (*::System::IntPtr::Zero), type, (*::System::IntPtr::Zero), (*::System::IntPtr::Zero));
            if((result ==  1018)) 
            {
                throw RegistryKey::CreateMarkedForDeletionException();
            }
            if(((result ==  0) || (result ==  234))) 
            {
                continue;
            }
            if((result ==  259)) 
            {
                break;
            }
            GenerateException(result);
        }
        return index;
    }
    
    RegistryKey* Win32RegistryApi::OpenRemoteBaseKey(RegistryHive hKey, System::String* machineName) {
        void *handle = cli::ctor<::System::IntPtr>((int32_t)(hKey));
        void *keyHandle;
        int32_t result = RegConnectRegistry(machineName, handle, keyHandle);
        if((result != 0)) 
        {
            GenerateException(result);
        }
        return cli::gcnew<RegistryKey>(hKey, keyHandle, true);
    }
    
    RegistryKey* Win32RegistryApi::OpenSubKey(RegistryKey* rkey, System::String* keyName, bool writable) {
        int32_t access = 131097;
        if(writable) 
        {
            (access = access | 131078);
        }
        void *handle = GetHandle(rkey);
        void *subKeyHandle;
        int32_t result = RegOpenKeyEx(handle, keyName, (*::System::IntPtr::Zero), access, subKeyHandle);
        if(((result ==  2) || (result ==  1018))) 
        {
            return nullptr;
        }
        if((result != 0)) 
        {
            GenerateException(result);
        }
        return cli::gcnew<RegistryKey>(cli::box(subKeyHandle), CombineName(rkey, keyName), writable);
    }
    
    void Win32RegistryApi::Flush(RegistryKey* rkey) {
        if(!(IsHandleValid(rkey))) 
        {
            return;
        }
        void *handle = GetHandle(rkey);
        RegFlushKey(handle);
    }
    
    void Win32RegistryApi::Close(RegistryKey* rkey) {
        if(!(IsHandleValid(rkey))) 
        {
            return;
        }
        SafeHandles::SafeRegistryHandle *safe_handle = rkey->get_Handle();
        if((safe_handle != nullptr)) 
        {
            safe_handle->Close();
            return;
        }
        void *handle = GetHandle(rkey);
        RegCloseKey(handle);
    }
    
    RegistryKey* Win32RegistryApi::FromHandle(SafeHandles::SafeRegistryHandle* handle) {
        return cli::gcnew<RegistryKey>(cli::box(handle->DangerousGetHandle()), System::String::Empty, true);
    }
    
    RegistryKey* Win32RegistryApi::CreateSubKey(RegistryKey* rkey, System::String* keyName) {
        void *handle = GetHandle(rkey);
        void *subKeyHandle;
        int32_t disposition;
        int32_t result = RegCreateKeyEx(handle, keyName, 0, (*::System::IntPtr::Zero), 0, 131103, (*::System::IntPtr::Zero), subKeyHandle, disposition);
        if((result ==  1018)) 
        {
            throw RegistryKey::CreateMarkedForDeletionException();
        }
        if((result != 0)) 
        {
            GenerateException(result);
        }
        return cli::gcnew<RegistryKey>(cli::box(subKeyHandle), CombineName(rkey, keyName), true);
    }
    
    RegistryKey* Win32RegistryApi::CreateSubKey2(RegistryKey* rkey, System::String* keyName, RegistryOptions options) {
        void *handle = GetHandle(rkey);
        void *subKeyHandle;
        int32_t disposition;
        int32_t result = RegCreateKeyEx(handle, keyName, 0, (*::System::IntPtr::Zero), ((int32_t)(options) ==  1) ? 1 : 0, 131103, (*::System::IntPtr::Zero), subKeyHandle, disposition);
        if((result ==  1018)) 
        {
            throw RegistryKey::CreateMarkedForDeletionException();
        }
        if((result != 0)) 
        {
            GenerateException(result);
        }
        return cli::gcnew<RegistryKey>(cli::box(subKeyHandle), CombineName(rkey, keyName), true);
    }
    
    void Win32RegistryApi::DeleteKey(RegistryKey* rkey, System::String* keyName, bool shouldThrowWhenKeyMissing) {
        void *handle = GetHandle(rkey);
        int32_t result = RegDeleteKey(handle, keyName);
        if((result ==  2)) 
        {
            if(shouldThrowWhenKeyMissing) 
            {
                throw cli::gcnew<System::ArgumentException>(cli::concat(_T("key "), keyName));
            }
            return;
        }
        if((result != 0)) 
        {
            GenerateException(result);
        }
    }
    
    void Win32RegistryApi::DeleteValue(RegistryKey* rkey, System::String* value, bool shouldThrowWhenKeyMissing) {
        void *handle = GetHandle(rkey);
        int32_t result = RegDeleteValue(handle, value);
        if((result ==  1018)) 
        {
            return;
        }
        if((result ==  2)) 
        {
            if(shouldThrowWhenKeyMissing) 
            {
                throw cli::gcnew<System::ArgumentException>(cli::concat(_T("value "), value));
            }
            return;
        }
        if((result != 0)) 
        {
            GenerateException(result);
        }
    }
    
    cli::array<System::String*>* Win32RegistryApi::GetSubKeyNames(RegistryKey* rkey) {
        void *handle = GetHandle(rkey);
        System::Text::StringBuilder *buffer = cli::gcnew<System::Text::StringBuilder>(1024);
        System::Collections::Generic::List<System::String*> *keys = cli::gcnew<System::Collections::Generic::List<System::String*>>();
        for(int32_t index = 0; true; index++){
            int32_t result = RegEnumKey(handle, index, buffer, buffer->get_Capacity());
            if((result ==  0)) 
            {
                keys->Add(buffer->ToString_1636a0751cb9ac11());
                buffer->set_Length(0);
                continue;
            }
            if((result ==  259)) 
            {
                break;
            }
            GenerateException(result);
        }
        return keys->ToArray();
    }
    
    cli::array<System::String*>* Win32RegistryApi::GetValueNames(RegistryKey* rkey) {
        void *handle = GetHandle(rkey);
        System::Collections::Generic::List<System::String*> *values = cli::gcnew<System::Collections::Generic::List<System::String*>>();
        for(int32_t index = 0; true; index++){
            System::Text::StringBuilder *buffer = cli::gcnew<System::Text::StringBuilder>(1024);
            int32_t bufferCapacity = buffer->get_Capacity();
            RegistryValueKind type = RegistryValueKind::Unknown;
            int32_t result = RegEnumValue(handle, index, buffer, bufferCapacity, (*::System::IntPtr::Zero), type, (*::System::IntPtr::Zero), (*::System::IntPtr::Zero));
            if(((result ==  0) || (result ==  234))) 
            {
                values->Add(buffer->ToString_1636a0751cb9ac11());
                continue;
            }
            if((result ==  259)) 
            {
                break;
            }
            if((result ==  1018)) 
            {
                throw RegistryKey::CreateMarkedForDeletionException();
            }
            GenerateException(result);
        }
        return values->ToArray();
    }
    
    void Win32RegistryApi::GenerateException(int32_t errorCode) {
        switch(errorCode) {
            case 2: case 87: case_122: {
                throw cli::gcnew<System::ArgumentException>();
            }
            case 5: case_123: {
                throw cli::gcnew<System::Security::SecurityException>();
            }
            case 53: case_124: {
                throw cli::gcnew<System::IO::IOException>(_T("The network path was not found."));
            }
            case 6: case_125: {
                throw cli::gcnew<System::IO::IOException>(_T("Invalid handle."));
            }
            default: case_126: {
                throw cli::gcnew<System::SystemException>();
            }
        }
    }
    
    System::String* Win32RegistryApi::ToString2(RegistryKey* rkey) {
        return rkey->get_Name();
    }
    
    System::String* Win32RegistryApi::CombineName(RegistryKey* rkey, System::String* localName) {
        return System::String::Concat6(rkey->get_Name(), _T("\\"), localName);
    }
    
}}
namespace Microsoft { namespace Win32 {
    
    
    void Win32ResultCode::constructor() {
    }
    
}}
namespace Microsoft { namespace Win32 { namespace SafeHandles {
    
    
    void CriticalHandleMinusOneIsInvalid::constructor() {
    }
    
    bool CriticalHandleMinusOneIsInvalid::get_IsInvalid_2fec8dcdb17ef2a3() {
        return ::System::IntPtr::op_Equality(this->handle, (void*)-1);
    }
    
}}}
namespace Microsoft { namespace Win32 { namespace SafeHandles {
    
    
    void CriticalHandleZeroOrMinusOneIsInvalid::constructor() {
    }
    
    bool CriticalHandleZeroOrMinusOneIsInvalid::get_IsInvalid_2fec8dcdb17ef2a3() {
        return (::System::IntPtr::op_Equality(this->handle, (void*)-1) || ::System::IntPtr::op_Equality(this->handle, (*::System::IntPtr::Zero)));
    }
    
}}}
namespace Microsoft { namespace Win32 { namespace SafeHandles {
    
    
    void SafeFileHandle::constructor(void* preexistingHandle, bool ownsHandle) {
        System::Runtime::InteropServices::SafeHandle::SetHandle(preexistingHandle);
    }
    
    void SafeFileHandle::constructor() {
    }
    
    bool SafeFileHandle::ReleaseHandle_f52de76ab86d3480() {
        System::IO::MonoIOError error;
        System::IO::MonoIO::Close(this->handle, error);
        return ((int32_t)(error) ==  0);
    }
    
}}}
namespace Microsoft { namespace Win32 { namespace SafeHandles {
    
    
    void SafeHandleMinusOneIsInvalid::constructor(bool ownsHandle) {
    }
    
    bool SafeHandleMinusOneIsInvalid::get_IsInvalid_64f170f124c20f6b() {
        return ::System::IntPtr::op_Equality(this->handle, (void*)-1);
    }
    
}}}
namespace Microsoft { namespace Win32 { namespace SafeHandles {
    
    
    void SafeHandleZeroOrMinusOneIsInvalid::constructor(bool ownsHandle) {
    }
    
    bool SafeHandleZeroOrMinusOneIsInvalid::get_IsInvalid_64f170f124c20f6b() {
        return (::System::IntPtr::op_Equality(this->handle, (void*)-1) || ::System::IntPtr::op_Equality(this->handle, (void*)0));
    }
    
}}}
namespace Microsoft { namespace Win32 { namespace SafeHandles {
    
    
    void SafeRegistryHandle::constructor(void* preexistingHandle, bool ownsHandle) {
        this->handle = preexistingHandle;
    }
    
    bool SafeRegistryHandle::ReleaseHandle_f52de76ab86d3480() {
        if(((int32_t)(System::IO::Path::DirectorySeparatorChar) ==  92)) 
        {
            return (RegCloseKey(this->handle) ==  0);
        }
        return true;
    }
    
    int32_t SafeRegistryHandle::RegCloseKey(void* keyHandle) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
}}}
namespace Microsoft { namespace Win32 { namespace SafeHandles {
    
    
    void SafeWaitHandle::constructor(void* existingHandle, bool ownsHandle) {
        System::Runtime::InteropServices::SafeHandle::SetHandle(existingHandle);
    }
    
    bool SafeWaitHandle::ReleaseHandle_f52de76ab86d3480() {
        System::Threading::NativeEventCalls::CloseEvent_internal(this->handle);
        return true;
    }
    
}}}
namespace Mono {
    
    
    void PackContext::constructor() {
    }
    
    void PackContext::Add(cli::array<unsigned char>* group) {
        if((this->buffer ==  nullptr)) 
        {
            this->buffer = group;
            this->next = group->get_Length();
            return;
        }
        if((this->align != 0)) 
        {
            if((this->align ==  -1)) 
            {
                this->next = DataConverter::Align(this->next, group->get_Length());
            }
             else 
            {
                this->next = DataConverter::Align(this->next, this->align);
            }
            this->align = 0;
        }
        if(((this->next + group->get_Length()) > this->buffer->get_Length())) 
        {
            cli::array<unsigned char> *nb = (new cli::array<unsigned char>(((System::Math::Max5(this->next, 16) * 2) + group->get_Length())));
            System::Array::Copy(this->buffer, nb, this->buffer->get_Length());
            System::Array::Copy2(group, 0, nb, this->next, group->get_Length());
            this->next = (this->next + group->get_Length());
            this->buffer = nb;
        }
         else 
        {
            System::Array::Copy2(group, 0, this->buffer, this->next, group->get_Length());
            (this->next = this->next + group->get_Length());
        }
    }
    
    cli::array<unsigned char>* PackContext::Get() {
        if((this->buffer ==  nullptr)) 
        {
            return (new cli::array<unsigned char>(0));
        }
        if((this->buffer->get_Length() != this->next)) 
        {
            cli::array<unsigned char> *b = (new cli::array<unsigned char>(this->next));
            System::Array::Copy(this->buffer, b, this->next);
            return b;
        }
        return this->buffer;
    }
    
}
namespace Mono {
    
    
    void CopyConverter::constructor() {
    }
    
    double CopyConverter::GetDouble_982f91d38d946b8(cli::array<unsigned char>* data, int32_t index) {
        if((data ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("data"));
        }
        if(((data->get_Length() - index) < 8)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("index"));
        }
        if((index < 0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("index"));
        }
        double ret;
        unsigned char *b = (unsigned char*)(&(ret));
        for(int32_t i = 0; (i < 8); i++) {
            (*(b + i)) = data->at((index + i));
        }
        return ret;
    }
    
    uint64_t CopyConverter::GetUInt64_dffd8018e877d5b3(cli::array<unsigned char>* data, int32_t index) {
        if((data ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("data"));
        }
        if(((data->get_Length() - index) < 8)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("index"));
        }
        if((index < 0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("index"));
        }
        uint64_t ret;
        unsigned char *b = (unsigned char*)(&(ret));
        for(int32_t i = 0; (i < 8); i++) {
            (*(b + i)) = data->at((index + i));
        }
        return ret;
    }
    
    int64_t CopyConverter::GetInt64_cb5ad8c264a233be(cli::array<unsigned char>* data, int32_t index) {
        if((data ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("data"));
        }
        if(((data->get_Length() - index) < 8)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("index"));
        }
        if((index < 0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("index"));
        }
        int64_t ret;
        unsigned char *b = (unsigned char*)(&(ret));
        for(int32_t i = 0; (i < 8); i++) {
            (*(b + i)) = data->at((index + i));
        }
        return ret;
    }
    
    float CopyConverter::GetFloat_2855d1e0112a51d8(cli::array<unsigned char>* data, int32_t index) {
        if((data ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("data"));
        }
        if(((data->get_Length() - index) < 4)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("index"));
        }
        if((index < 0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("index"));
        }
        float ret;
        unsigned char *b = (unsigned char*)(&(ret));
        for(int32_t i = 0; (i < 4); i++) {
            (*(b + i)) = data->at((index + i));
        }
        return ret;
    }
    
    int32_t CopyConverter::GetInt32_5fe45303465b6967(cli::array<unsigned char>* data, int32_t index) {
        if((data ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("data"));
        }
        if(((data->get_Length() - index) < 4)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("index"));
        }
        if((index < 0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("index"));
        }
        int32_t ret;
        unsigned char *b = (unsigned char*)(&(ret));
        for(int32_t i = 0; (i < 4); i++) {
            (*(b + i)) = data->at((index + i));
        }
        return ret;
    }
    
    uint32_t CopyConverter::GetUInt32_dddce65a8680a7dd(cli::array<unsigned char>* data, int32_t index) {
        if((data ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("data"));
        }
        if(((data->get_Length() - index) < 4)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("index"));
        }
        if((index < 0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("index"));
        }
        uint32_t ret;
        unsigned char *b = (unsigned char*)(&(ret));
        for(int32_t i = 0; (i < 4); i++) {
            (*(b + i)) = data->at((index + i));
        }
        return ret;
    }
    
    int16_t CopyConverter::GetInt16_758f7ab00ffee775(cli::array<unsigned char>* data, int32_t index) {
        if((data ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("data"));
        }
        if(((data->get_Length() - index) < 2)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("index"));
        }
        if((index < 0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("index"));
        }
        int16_t ret;
        unsigned char *b = (unsigned char*)(&(ret));
        for(int32_t i = 0; (i < 2); i++) {
            (*(b + i)) = data->at((index + i));
        }
        return ret;
    }
    
    uint16_t CopyConverter::GetUInt16_b622ed9a3e9dd013(cli::array<unsigned char>* data, int32_t index) {
        if((data ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("data"));
        }
        if(((data->get_Length() - index) < 2)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("index"));
        }
        if((index < 0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("index"));
        }
        uint16_t ret;
        unsigned char *b = (unsigned char*)(&(ret));
        for(int32_t i = 0; (i < 2); i++) {
            (*(b + i)) = data->at((index + i));
        }
        return ret;
    }
    
    void CopyConverter::PutBytes_826b3ecadff1e9db(cli::array<unsigned char>* dest, int32_t destIdx, double value) {
        DataConverter::Check(dest, destIdx, 8);
        {
            /* FIXED - BLOCK */
            unsigned char* target = cli::fixed_guard(&(dest->at(destIdx)));
            int64_t *source = (int64_t*)(&(value));
            (*(int64_t*)(target)) = (*source);
        }
    }
    
    void CopyConverter::PutBytes_9c1149d2e7e5f565(cli::array<unsigned char>* dest, int32_t destIdx, float value) {
        DataConverter::Check(dest, destIdx, 4);
        {
            /* FIXED - BLOCK */
            unsigned char* target = cli::fixed_guard(&(dest->at(destIdx)));
            uint32_t *source = (uint32_t*)(&(value));
            (*(uint32_t*)(target)) = (*source);
        }
    }
    
    void CopyConverter::PutBytes_cbf2c466c0e65790(cli::array<unsigned char>* dest, int32_t destIdx, int32_t value) {
        DataConverter::Check(dest, destIdx, 4);
        {
            /* FIXED - BLOCK */
            unsigned char* target = cli::fixed_guard(&(dest->at(destIdx)));
            uint32_t *source = (uint32_t*)(&(value));
            (*(uint32_t*)(target)) = (*source);
        }
    }
    
    void CopyConverter::PutBytes_8baa85ac9d2698a3(cli::array<unsigned char>* dest, int32_t destIdx, uint32_t value) {
        DataConverter::Check(dest, destIdx, 4);
        {
            /* FIXED - BLOCK */
            unsigned char* target = cli::fixed_guard(&(dest->at(destIdx)));
            uint32_t *source = (uint32_t*)(&(value));
            (*(uint32_t*)(target)) = (*source);
        }
    }
    
    void CopyConverter::PutBytes_6c0f4987776467f3(cli::array<unsigned char>* dest, int32_t destIdx, int64_t value) {
        DataConverter::Check(dest, destIdx, 8);
        {
            /* FIXED - BLOCK */
            unsigned char* target = cli::fixed_guard(&(dest->at(destIdx)));
            int64_t *source = (int64_t*)(&(value));
            (*(int64_t*)(target)) = (*source);
        }
    }
    
    void CopyConverter::PutBytes_cad08b7dc9cde562(cli::array<unsigned char>* dest, int32_t destIdx, uint64_t value) {
        DataConverter::Check(dest, destIdx, 8);
        {
            /* FIXED - BLOCK */
            unsigned char* target = cli::fixed_guard(&(dest->at(destIdx)));
            uint64_t *source = (uint64_t*)(&(value));
            (*(uint64_t*)(target)) = (*source);
        }
    }
    
    void CopyConverter::PutBytes_24b92f8078ec7174(cli::array<unsigned char>* dest, int32_t destIdx, int16_t value) {
        DataConverter::Check(dest, destIdx, 2);
        {
            /* FIXED - BLOCK */
            unsigned char* target = cli::fixed_guard(&(dest->at(destIdx)));
            uint16_t *source = (uint16_t*)(&(value));
            (*(uint16_t*)(target)) = (*source);
        }
    }
    
    void CopyConverter::PutBytes_d2f5dd10e40042a8(cli::array<unsigned char>* dest, int32_t destIdx, uint16_t value) {
        DataConverter::Check(dest, destIdx, 2);
        {
            /* FIXED - BLOCK */
            unsigned char* target = cli::fixed_guard(&(dest->at(destIdx)));
            uint16_t *source = (uint16_t*)(&(value));
            (*(uint16_t*)(target)) = (*source);
        }
    }
    
}
namespace Mono {
    
    
    void SwapConverter::constructor() {
    }
    
    double SwapConverter::GetDouble_982f91d38d946b8(cli::array<unsigned char>* data, int32_t index) {
        if((data ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("data"));
        }
        if(((data->get_Length() - index) < 8)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("index"));
        }
        if((index < 0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("index"));
        }
        double ret;
        unsigned char *b = (unsigned char*)(&(ret));
        for(int32_t i = 0; (i < 8); i++) {
            (*(b + (7 - i))) = data->at((index + i));
        }
        return ret;
    }
    
    uint64_t SwapConverter::GetUInt64_dffd8018e877d5b3(cli::array<unsigned char>* data, int32_t index) {
        if((data ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("data"));
        }
        if(((data->get_Length() - index) < 8)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("index"));
        }
        if((index < 0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("index"));
        }
        uint64_t ret;
        unsigned char *b = (unsigned char*)(&(ret));
        for(int32_t i = 0; (i < 8); i++) {
            (*(b + (7 - i))) = data->at((index + i));
        }
        return ret;
    }
    
    int64_t SwapConverter::GetInt64_cb5ad8c264a233be(cli::array<unsigned char>* data, int32_t index) {
        if((data ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("data"));
        }
        if(((data->get_Length() - index) < 8)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("index"));
        }
        if((index < 0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("index"));
        }
        int64_t ret;
        unsigned char *b = (unsigned char*)(&(ret));
        for(int32_t i = 0; (i < 8); i++) {
            (*(b + (7 - i))) = data->at((index + i));
        }
        return ret;
    }
    
    float SwapConverter::GetFloat_2855d1e0112a51d8(cli::array<unsigned char>* data, int32_t index) {
        if((data ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("data"));
        }
        if(((data->get_Length() - index) < 4)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("index"));
        }
        if((index < 0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("index"));
        }
        float ret;
        unsigned char *b = (unsigned char*)(&(ret));
        for(int32_t i = 0; (i < 4); i++) {
            (*(b + (3 - i))) = data->at((index + i));
        }
        return ret;
    }
    
    int32_t SwapConverter::GetInt32_5fe45303465b6967(cli::array<unsigned char>* data, int32_t index) {
        if((data ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("data"));
        }
        if(((data->get_Length() - index) < 4)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("index"));
        }
        if((index < 0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("index"));
        }
        int32_t ret;
        unsigned char *b = (unsigned char*)(&(ret));
        for(int32_t i = 0; (i < 4); i++) {
            (*(b + (3 - i))) = data->at((index + i));
        }
        return ret;
    }
    
    uint32_t SwapConverter::GetUInt32_dddce65a8680a7dd(cli::array<unsigned char>* data, int32_t index) {
        if((data ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("data"));
        }
        if(((data->get_Length() - index) < 4)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("index"));
        }
        if((index < 0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("index"));
        }
        uint32_t ret;
        unsigned char *b = (unsigned char*)(&(ret));
        for(int32_t i = 0; (i < 4); i++) {
            (*(b + (3 - i))) = data->at((index + i));
        }
        return ret;
    }
    
    int16_t SwapConverter::GetInt16_758f7ab00ffee775(cli::array<unsigned char>* data, int32_t index) {
        if((data ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("data"));
        }
        if(((data->get_Length() - index) < 2)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("index"));
        }
        if((index < 0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("index"));
        }
        int16_t ret;
        unsigned char *b = (unsigned char*)(&(ret));
        for(int32_t i = 0; (i < 2); i++) {
            (*(b + (1 - i))) = data->at((index + i));
        }
        return ret;
    }
    
    uint16_t SwapConverter::GetUInt16_b622ed9a3e9dd013(cli::array<unsigned char>* data, int32_t index) {
        if((data ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("data"));
        }
        if(((data->get_Length() - index) < 2)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("index"));
        }
        if((index < 0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("index"));
        }
        uint16_t ret;
        unsigned char *b = (unsigned char*)(&(ret));
        for(int32_t i = 0; (i < 2); i++) {
            (*(b + (1 - i))) = data->at((index + i));
        }
        return ret;
    }
    
    void SwapConverter::PutBytes_826b3ecadff1e9db(cli::array<unsigned char>* dest, int32_t destIdx, double value) {
        DataConverter::Check(dest, destIdx, 8);
        {
            /* FIXED - BLOCK */
            unsigned char* target = cli::fixed_guard(&(dest->at(destIdx)));
            unsigned char *source = (unsigned char*)(&(value));
            for(int32_t i = 0; (i < 8); i++) {
                (*(target + i)) = (*(source + (7 - i)));
            }
        }
    }
    
    void SwapConverter::PutBytes_9c1149d2e7e5f565(cli::array<unsigned char>* dest, int32_t destIdx, float value) {
        DataConverter::Check(dest, destIdx, 4);
        {
            /* FIXED - BLOCK */
            unsigned char* target = cli::fixed_guard(&(dest->at(destIdx)));
            unsigned char *source = (unsigned char*)(&(value));
            for(int32_t i = 0; (i < 4); i++) {
                (*(target + i)) = (*(source + (3 - i)));
            }
        }
    }
    
    void SwapConverter::PutBytes_cbf2c466c0e65790(cli::array<unsigned char>* dest, int32_t destIdx, int32_t value) {
        DataConverter::Check(dest, destIdx, 4);
        {
            /* FIXED - BLOCK */
            unsigned char* target = cli::fixed_guard(&(dest->at(destIdx)));
            unsigned char *source = (unsigned char*)(&(value));
            for(int32_t i = 0; (i < 4); i++) {
                (*(target + i)) = (*(source + (3 - i)));
            }
        }
    }
    
    void SwapConverter::PutBytes_8baa85ac9d2698a3(cli::array<unsigned char>* dest, int32_t destIdx, uint32_t value) {
        DataConverter::Check(dest, destIdx, 4);
        {
            /* FIXED - BLOCK */
            unsigned char* target = cli::fixed_guard(&(dest->at(destIdx)));
            unsigned char *source = (unsigned char*)(&(value));
            for(int32_t i = 0; (i < 4); i++) {
                (*(target + i)) = (*(source + (3 - i)));
            }
        }
    }
    
    void SwapConverter::PutBytes_6c0f4987776467f3(cli::array<unsigned char>* dest, int32_t destIdx, int64_t value) {
        DataConverter::Check(dest, destIdx, 8);
        {
            /* FIXED - BLOCK */
            unsigned char* target = cli::fixed_guard(&(dest->at(destIdx)));
            unsigned char *source = (unsigned char*)(&(value));
            for(int32_t i = 0; (i < 8); i++) {
                (*(target + i)) = (*(source + (7 - i)));
            }
        }
    }
    
    void SwapConverter::PutBytes_cad08b7dc9cde562(cli::array<unsigned char>* dest, int32_t destIdx, uint64_t value) {
        DataConverter::Check(dest, destIdx, 8);
        {
            /* FIXED - BLOCK */
            unsigned char* target = cli::fixed_guard(&(dest->at(destIdx)));
            unsigned char *source = (unsigned char*)(&(value));
            for(int32_t i = 0; (i < 8); i++) {
                (*(target + i)) = (*(source + (7 - i)));
            }
        }
    }
    
    void SwapConverter::PutBytes_24b92f8078ec7174(cli::array<unsigned char>* dest, int32_t destIdx, int16_t value) {
        DataConverter::Check(dest, destIdx, 2);
        {
            /* FIXED - BLOCK */
            unsigned char* target = cli::fixed_guard(&(dest->at(destIdx)));
            unsigned char *source = (unsigned char*)(&(value));
            for(int32_t i = 0; (i < 2); i++) {
                (*(target + i)) = (*(source + (1 - i)));
            }
        }
    }
    
    void SwapConverter::PutBytes_d2f5dd10e40042a8(cli::array<unsigned char>* dest, int32_t destIdx, uint16_t value) {
        DataConverter::Check(dest, destIdx, 2);
        {
            /* FIXED - BLOCK */
            unsigned char* target = cli::fixed_guard(&(dest->at(destIdx)));
            unsigned char *source = (unsigned char*)(&(value));
            for(int32_t i = 0; (i < 2); i++) {
                (*(target + i)) = (*(source + (1 - i)));
            }
        }
    }
    
}
namespace Mono {
    
    DataConverter*  DataConverter::SwapConv;
    DataConverter*  DataConverter::CopyConv;
    bool  DataConverter::IsLittleEndian;
    
    DataConverter::DataConverter()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void DataConverter::constructor() {
    }
    
    void DataConverter::static_constructor() {
    }
    
    cli::array<unsigned char>* DataConverter::GetBytes(double value) {
        cli::array<unsigned char> *ret = (new cli::array<unsigned char>(8));
        PutBytes_826b3ecadff1e9db(ret, 0, value);
        return ret;
    }
    
    cli::array<unsigned char>* DataConverter::GetBytes2(float value) {
        cli::array<unsigned char> *ret = (new cli::array<unsigned char>(4));
        PutBytes_9c1149d2e7e5f565(ret, 0, value);
        return ret;
    }
    
    cli::array<unsigned char>* DataConverter::GetBytes3(int32_t value) {
        cli::array<unsigned char> *ret = (new cli::array<unsigned char>(4));
        PutBytes_cbf2c466c0e65790(ret, 0, value);
        return ret;
    }
    
    cli::array<unsigned char>* DataConverter::GetBytes4(int64_t value) {
        cli::array<unsigned char> *ret = (new cli::array<unsigned char>(8));
        PutBytes_6c0f4987776467f3(ret, 0, value);
        return ret;
    }
    
    cli::array<unsigned char>* DataConverter::GetBytes5(int16_t value) {
        cli::array<unsigned char> *ret = (new cli::array<unsigned char>(2));
        PutBytes_24b92f8078ec7174(ret, 0, value);
        return ret;
    }
    
    cli::array<unsigned char>* DataConverter::GetBytes6(uint16_t value) {
        cli::array<unsigned char> *ret = (new cli::array<unsigned char>(2));
        PutBytes_d2f5dd10e40042a8(ret, 0, value);
        return ret;
    }
    
    cli::array<unsigned char>* DataConverter::GetBytes7(uint32_t value) {
        cli::array<unsigned char> *ret = (new cli::array<unsigned char>(4));
        PutBytes_8baa85ac9d2698a3(ret, 0, value);
        return ret;
    }
    
    cli::array<unsigned char>* DataConverter::GetBytes8(uint64_t value) {
        cli::array<unsigned char> *ret = (new cli::array<unsigned char>(8));
        PutBytes_cad08b7dc9cde562(ret, 0, value);
        return ret;
    }
    
    int32_t DataConverter::Align(int32_t current, int32_t align) {
        return ((((current + align) - 1) / align) * align);
    }
    
    cli::array<unsigned char>* DataConverter::Pack(System::String* description, cli::array<System::Object*>* args) {
        int32_t argn = 0;
        PackContext *b = cli::gcnew<PackContext>();
        b->conv = CopyConv;
        b->description = description;
        for(b->i = 0; (b->i < description->get_Length()); ){
            System::Object *oarg;
            if((argn < args->get_Length())) 
            {
                oarg = args->at(argn);
            }
             else 
            {
                if((b->repeat != 0)) 
                {
                    break;
                }
                oarg = nullptr;
            }
            int32_t save = b->i;
            if(PackOne(b, oarg)) 
            {
                argn++;
                if((b->repeat > 0)) 
                {
                    if((--b->repeat > 0)) 
                    {
                        b->i = save;
                    }
                     else 
                    {
                        b->i++;
                    }
                }
                 else 
                {
                    b->i++;
                }
            }
             else 
            {
                b->i++;
            }
        }
        return b->Get();
    }
    
    cli::array<unsigned char>* DataConverter::PackEnumerable(System::String* description, System::Collections::IEnumerable* args) {
        PackContext *b = cli::gcnew<PackContext>();
        b->conv = CopyConv;
        b->description = description;
        System::Collections::IEnumerator *enumerator = args->GetEnumerator_674ad93a972a4d67();
        bool ok = enumerator->MoveNext_4e78e145935f5417();
        for(b->i = 0; (b->i < description->get_Length()); ){
            System::Object *oarg;
            if(ok) 
            {
                oarg = enumerator->get_Current_8eca9b3da02b123a();
            }
             else 
            {
                if((b->repeat != 0)) 
                {
                    break;
                }
                oarg = nullptr;
            }
            int32_t save = b->i;
            if(PackOne(b, oarg)) 
            {
                ok = enumerator->MoveNext_4e78e145935f5417();
                if((b->repeat > 0)) 
                {
                    if((--b->repeat > 0)) 
                    {
                        b->i = save;
                    }
                     else 
                    {
                        b->i++;
                    }
                }
                 else 
                {
                    b->i++;
                }
            }
             else 
            {
                b->i++;
            }
        }
        return b->Get();
    }
    
    bool DataConverter::PackOne(PackContext* b, System::Object* oarg) {
        int32_t n;
        switch(b->description->get_Chars(b->i)) {
            case u'^': case_127: {
                b->conv = get_BigEndian();
                return false;
            }
            case u'_': case_128: {
                b->conv = get_LittleEndian();
                return false;
            }
            case u'%': case_129: {
                b->conv = get_Native();
                return false;
            }
            case u'!': case_130: {
                b->align = -1;
                return false;
            }
            case u'x': case_131: {
                b->Add((new cli::array<unsigned char>({0})));
                return false;
            }
            case u'i': case_132: {
                b->Add(b->conv->GetBytes3(System::Convert::ToInt3218(oarg)));
                break;
            }
            case u'I': case_133: {
                b->Add(b->conv->GetBytes7(System::Convert::ToUInt3218(oarg)));
                break;
            }
            case u's': case_134: {
                b->Add(b->conv->GetBytes5(System::Convert::ToInt1618(oarg)));
                break;
            }
            case u'S': case_135: {
                b->Add(b->conv->GetBytes6(System::Convert::ToUInt1618(oarg)));
                break;
            }
            case u'l': case_136: {
                b->Add(b->conv->GetBytes4(System::Convert::ToInt6418(oarg)));
                break;
            }
            case u'L': case_137: {
                b->Add(b->conv->GetBytes8(System::Convert::ToUInt6418(oarg)));
                break;
            }
            case u'f': case_138: {
                b->Add(b->conv->GetBytes2(System::Convert::ToSingle17(oarg)));
                break;
            }
            case u'd': case_139: {
                b->Add(b->conv->GetBytes(System::Convert::ToDouble17(oarg)));
                break;
            }
            case u'b': case_140: {
                b->Add((new cli::array<unsigned char>({System::Convert::ToByte18(oarg)})));
                break;
            }
            case u'c': case_141: {
                b->Add((new cli::array<unsigned char>({(System::Byte)System::Convert::ToSByte18(oarg)})));
                break;
            }
            case u'C': case_142: {
                b->Add((new cli::array<unsigned char>({System::Convert::ToByte18(oarg)})));
                break;
            }
            case u'1': case u'2': case u'3': case u'4': case u'5': case u'6': case u'7': case u'8': case u'9': case_143: {
                b->repeat = ((int32_t)((int16_t)b->description->get_Chars(b->i)) - 48);
                return false;
            }
            case u'*': case_144: {
                b->repeat = 2147483647;
                return false;
            }
            case u'[': case_145: {
                int32_t count = -1, j;
                for(j = (b->i + 1); (j < b->description->get_Length()); j++){
                    if(((int32_t)(b->description->get_Chars(j)) ==  93)) 
                    {
                        break;
                    }
                    n = ((int32_t)((int16_t)b->description->get_Chars(j)) - 48);
                    if(((n >= 0) && (n <= 9))) 
                    {
                        if((count ==  -1)) 
                        {
                            count = n;
                        }
                         else 
                        {
                            count = ((count * 10) + n);
                        }
                    }
                }
                if((count ==  -1)) 
                {
                    throw cli::gcnew<System::ArgumentException>(_T("invalid size specification"));
                }
                b->i = j;
                b->repeat = count;
                return false;
            }
            case u'$': case u'z': case_146: {
                bool add_null = ((int32_t)(b->description->get_Chars(b->i)) ==  122);
                b->i++;
                if((b->i >= b->description->get_Length())) 
                {
                    throw cli::gcnew<System::ArgumentException>(_T("$ description needs a type specified"), _T("description"));
                }
                char16_t d = b->description->get_Chars(b->i);
                System::Text::Encoding *e;
                switch(d) {
                    case u'8': case_148: {
                        e = System::Text::Encoding::get_UTF8();
                        n = 1;
                        break;
                    }
                    case u'6': case_149: {
                        e = System::Text::Encoding::get_Unicode();
                        n = 2;
                        break;
                    }
                    case u'7': case_150: {
                        e = System::Text::Encoding::get_UTF7();
                        n = 1;
                        break;
                    }
                    case u'b': case_151: {
                        e = System::Text::Encoding::get_BigEndianUnicode();
                        n = 2;
                        break;
                    }
                    case u'3': case_152: {
                        e = System::Text::Encoding::GetEncoding(12000);
                        n = 4;
                        break;
                    }
                    case u'4': case_153: {
                        e = System::Text::Encoding::GetEncoding(12001);
                        n = 4;
                        break;
                    }
                    default: case_154: {
                        throw cli::gcnew<System::ArgumentException>(_T("Invalid format for $ specifier"), _T("description"));
                    }
                }
                if((b->align ==  -1)) 
                {
                    b->align = 4;
                }
                b->Add(e->GetBytes_49806e8e98b1c1db(System::Convert::ToString23(oarg)));
                if(add_null) 
                {
                    b->Add((new cli::array<unsigned char>(n)));
                }
                break;
            }
            default: case_147: {
                throw cli::gcnew<System::ArgumentException>(System::String::Format2(_T("invalid format specified `{0}\'"), cli::box(b->description->get_Chars(b->i))));
            }
        }
        return true;
    }
    
    bool DataConverter::Prepare(cli::array<unsigned char>* buffer, int32_t idx, int32_t size, bool align) {
        if(align) 
        {
            idx = Align(idx, size);
            align = false;
        }
        if(((idx + size) > buffer->get_Length())) 
        {
            idx = buffer->get_Length();
            return false;
        }
        return true;
    }
    
    System::Collections::IList* DataConverter::Unpack(System::String* description, cli::array<unsigned char>* buffer, int32_t startIndex) {
        DataConverter *conv = CopyConv;
        System::Collections::ArrayList *result = cli::gcnew<System::Collections::ArrayList>();
        int32_t idx = startIndex;
        bool align = false;
        int32_t repeat = 0, n;
        for(int32_t i = 0; ((i < description->get_Length()) && (idx < buffer->get_Length())); ){
            int32_t save = i;
            switch(description->get_Chars(i)) {
                case u'^': case_155: {
                    conv = get_BigEndian();
                    break;
                }
                case u'_': case_156: {
                    conv = get_LittleEndian();
                    break;
                }
                case u'%': case_157: {
                    conv = get_Native();
                    break;
                }
                case u'x': case_158: {
                    idx++;
                    break;
                }
                case u'!': case_159: {
                    align = true;
                    break;
                }
                case u'i': case_160: {
                    if(Prepare(buffer, idx, 4, align)) 
                    {
                        result->Add_e6a92085999ce388(cli::box(conv->GetInt32_5fe45303465b6967(buffer, idx)));
                        (idx = idx + 4);
                    }
                    break;
                }
                case u'I': case_161: {
                    if(Prepare(buffer, idx, 4, align)) 
                    {
                        result->Add_e6a92085999ce388(cli::box(conv->GetUInt32_dddce65a8680a7dd(buffer, idx)));
                        (idx = idx + 4);
                    }
                    break;
                }
                case u's': case_162: {
                    if(Prepare(buffer, idx, 2, align)) 
                    {
                        result->Add_e6a92085999ce388(cli::box(conv->GetInt16_758f7ab00ffee775(buffer, idx)));
                        (idx = idx + 2);
                    }
                    break;
                }
                case u'S': case_163: {
                    if(Prepare(buffer, idx, 2, align)) 
                    {
                        result->Add_e6a92085999ce388(cli::box(conv->GetUInt16_b622ed9a3e9dd013(buffer, idx)));
                        (idx = idx + 2);
                    }
                    break;
                }
                case u'l': case_164: {
                    if(Prepare(buffer, idx, 8, align)) 
                    {
                        result->Add_e6a92085999ce388(cli::box(conv->GetInt64_cb5ad8c264a233be(buffer, idx)));
                        (idx = idx + 8);
                    }
                    break;
                }
                case u'L': case_165: {
                    if(Prepare(buffer, idx, 8, align)) 
                    {
                        result->Add_e6a92085999ce388(cli::box(conv->GetUInt64_dffd8018e877d5b3(buffer, idx)));
                        (idx = idx + 8);
                    }
                    break;
                }
                case u'f': case_166: {
                    if(Prepare(buffer, idx, 4, align)) 
                    {
                        result->Add_e6a92085999ce388(cli::box(conv->GetFloat_2855d1e0112a51d8(buffer, idx)));
                        (idx = idx + 4);
                    }
                    break;
                }
                case u'd': case_167: {
                    if(Prepare(buffer, idx, 8, align)) 
                    {
                        result->Add_e6a92085999ce388(cli::box(conv->GetDouble_982f91d38d946b8(buffer, idx)));
                        (idx = idx + 8);
                    }
                    break;
                }
                case u'b': case_168: {
                    if(Prepare(buffer, idx, 1, align)) 
                    {
                        result->Add_e6a92085999ce388(cli::box(buffer->at(idx)));
                        idx++;
                    }
                    break;
                }
                case u'c': case u'C': case_169: {
                    if(Prepare(buffer, idx, 1, align)) 
                    {
                        char16_t c;
                        if(((int32_t)(description->get_Chars(i)) ==  99)) 
                        {
                            c = (char16_t)(signed char)buffer->at(idx);
                        }
                         else 
                        {
                            c = (char16_t)(unsigned char)(buffer->at(idx));
                        }
                        result->Add_e6a92085999ce388(cli::box(c));
                        idx++;
                    }
                    break;
                }
                case u'1': case u'2': case u'3': case u'4': case u'5': case u'6': case u'7': case u'8': case u'9': case_170: {
                    repeat = ((int32_t)((int16_t)description->get_Chars(i)) - 48);
                    save = (i + 1);
                    break;
                }
                case u'*': case_171: {
                    repeat = 2147483647;
                    break;
                }
                case u'[': case_172: {
                    int32_t count = -1, j;
                    for(j = (i + 1); (j < description->get_Length()); j++){
                        if(((int32_t)(description->get_Chars(j)) ==  93)) 
                        {
                            break;
                        }
                        n = ((int32_t)((int16_t)description->get_Chars(j)) - 48);
                        if(((n >= 0) && (n <= 9))) 
                        {
                            if((count ==  -1)) 
                            {
                                count = n;
                            }
                             else 
                            {
                                count = ((count * 10) + n);
                            }
                        }
                    }
                    if((count ==  -1)) 
                    {
                        throw cli::gcnew<System::ArgumentException>(_T("invalid size specification"));
                    }
                    i = j;
                    save = (i + 1);
                    repeat = count;
                    break;
                }
                case u'$': case u'z': case_173: {
                    i++;
                    if((i >= description->get_Length())) 
                    {
                        throw cli::gcnew<System::ArgumentException>(_T("$ description needs a type specified"), _T("description"));
                    }
                    char16_t d = description->get_Chars(i);
                    System::Text::Encoding *e;
                    if(align) 
                    {
                        idx = Align(idx, 4);
                        align = false;
                    }
                    if((idx >= buffer->get_Length())) 
                    {
                        break;
                    }
                    switch(d) {
                        case u'8': case_175: {
                            e = System::Text::Encoding::get_UTF8();
                            n = 1;
                            break;
                        }
                        case u'6': case_176: {
                            e = System::Text::Encoding::get_Unicode();
                            n = 2;
                            break;
                        }
                        case u'7': case_177: {
                            e = System::Text::Encoding::get_UTF7();
                            n = 1;
                            break;
                        }
                        case u'b': case_178: {
                            e = System::Text::Encoding::get_BigEndianUnicode();
                            n = 2;
                            break;
                        }
                        case u'3': case_179: {
                            e = System::Text::Encoding::GetEncoding(12000);
                            n = 4;
                            break;
                        }
                        case u'4': case_180: {
                            e = System::Text::Encoding::GetEncoding(12001);
                            n = 4;
                            break;
                        }
                        default: case_181: {
                            throw cli::gcnew<System::ArgumentException>(_T("Invalid format for $ specifier"), _T("description"));
                        }
                    }
                    int32_t k = idx;
                    switch(n) {
                        case 1: case_182: {
                            for(; ((k < buffer->get_Length()) && ((int32_t)(buffer->at(k)) != 0)); k++) {;
                            }
                            result->Add_e6a92085999ce388(e->GetChars_66b39e5249276d4a(buffer, idx, (k - idx)));
                            if((k ==  buffer->get_Length())) 
                            {
                                idx = k;
                            }
                             else 
                            {
                                idx = (k + 1);
                            }
                            break;
                        }
                        case 2: case_183: {
                            for(; (k < buffer->get_Length()); k++){
                                if(((k + 1) ==  buffer->get_Length())) 
                                {
                                    k++;
                                    break;
                                }
                                if((((int32_t)(buffer->at(k)) ==  0) && ((int32_t)(buffer->at((k + 1))) ==  0))) 
                                {
                                    break;
                                }
                            }
                            result->Add_e6a92085999ce388(e->GetChars_66b39e5249276d4a(buffer, idx, (k - idx)));
                            if((k ==  buffer->get_Length())) 
                            {
                                idx = k;
                            }
                             else 
                            {
                                idx = (k + 2);
                            }
                            break;
                        }
                        case 4: case_184: {
                            for(; (k < buffer->get_Length()); k++){
                                if(((k + 3) >= buffer->get_Length())) 
                                {
                                    k = buffer->get_Length();
                                    break;
                                }
                                if((((((int32_t)(buffer->at(k)) ==  0) && ((int32_t)(buffer->at((k + 1))) ==  0)) && ((int32_t)(buffer->at((k + 2))) ==  0)) && ((int32_t)(buffer->at((k + 3))) ==  0))) 
                                {
                                    break;
                                }
                            }
                            result->Add_e6a92085999ce388(e->GetChars_66b39e5249276d4a(buffer, idx, (k - idx)));
                            if((k ==  buffer->get_Length())) 
                            {
                                idx = k;
                            }
                             else 
                            {
                                idx = (k + 4);
                            }
                            break;
                        }
                    }
                    break;
                }
                default: case_174: {
                    throw cli::gcnew<System::ArgumentException>(System::String::Format2(_T("invalid format specified `{0}\'"), cli::box(description->get_Chars(i))));
                }
            }
            if((repeat > 0)) 
            {
                if((--repeat > 0)) 
                {
                    i = save;
                }
            }
             else 
            {
                i++;
            }
        }
        return result;
    }
    
    void DataConverter::Check(cli::array<unsigned char>* dest, int32_t destIdx, int32_t size) {
        if((dest ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("dest"));
        }
        if(((destIdx < 0) || (destIdx > (dest->get_Length() - size)))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("destIdx"));
        }
    }
    
    DataConverter* DataConverter::get_LittleEndian() {
        return System::BitConverter::IsLittleEndian ? CopyConv : SwapConv;
    }
    
    DataConverter* DataConverter::get_BigEndian() {
        return System::BitConverter::IsLittleEndian ? SwapConv : CopyConv;
    }
    
    DataConverter* DataConverter::get_Native() {
        return CopyConv;
    }
    
}
namespace Mono {
    
    
    void Runtime::constructor() {
    }
    
    void Runtime::mono_runtime_install_handlers() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Runtime::InstallSignalHandlers() {
        mono_runtime_install_handlers();
    }
    
    System::String* Runtime::GetDisplayName() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
}
namespace Mono { namespace Globalization { namespace Unicode {
    
    
    void CodePointIndexer::constructor(cli::array<int32_t>* starts, cli::array<int32_t>* ends, int32_t defaultIndex, int32_t defaultCP) {
        this->defaultIndex = defaultIndex;
        this->defaultCP = defaultCP;
        this->ranges = (new cli::array<TableRange>(starts->get_Length()));
        for(int32_t i = 0; (i < this->ranges->get_Length()); i++) {
            this->ranges->at(i) = cli::ctor<TableRange>(starts->at(i), ends->at(i), (i ==  0) ? 0 : (this->ranges->at((i - 1))->IndexStart + this->ranges->at((i - 1))->Count));
        }
        for(int32_t i = 0; (i < this->ranges->get_Length()); i++) {
            (this->TotalCount = this->TotalCount + this->ranges->at(i)->Count);
        }
    }
    
    System::Array* CodePointIndexer::CompressArray(System::Array* source, System::Type* type, CodePointIndexer* indexer) {
        int32_t totalCount = 0;
        for(int32_t i = 0; (i < indexer->ranges->get_Length()); i++) {
            (totalCount = totalCount + indexer->ranges->at(i)->Count);
        }
        System::Array *ret = System::Array::CreateInstance(type, totalCount);
        for(int32_t i = 0; (i < indexer->ranges->get_Length()); i++) {
            System::Array::Copy2(source, indexer->ranges->at(i)->Start, ret, indexer->ranges->at(i)->IndexStart, indexer->ranges->at(i)->Count);
        }
        return ret;
    }
    
    int32_t CodePointIndexer::ToIndex(int32_t cp) {
        for(int32_t t = 0; (t < this->ranges->get_Length()); t++){
            if((cp < this->ranges->at(t)->Start)) 
            {
                return this->defaultIndex;
            }
             else 
            {
                if((cp < this->ranges->at(t)->End)) 
                {
                    return ((cp - this->ranges->at(t)->Start) + this->ranges->at(t)->IndexStart);
                }
            }
        }
        return this->defaultIndex;
    }
    
    int32_t CodePointIndexer::ToCodePoint(int32_t i) {
        for(int32_t t = 0; (t < this->ranges->get_Length()); t++){
            if((i < this->ranges->at(t)->IndexStart)) 
            {
                return this->defaultCP;
            }
            if((i < this->ranges->at(t)->IndexEnd)) 
            {
                return ((i - this->ranges->at(t)->IndexStart) + this->ranges->at(t)->Start);
            }
        }
        return this->defaultCP;
    }
    
}}}
namespace Mono { namespace Globalization { namespace Unicode {
    
    CodePointIndexer*  CollationElementTableUtil::Indexer;
    
    CollationElementTableUtil::CollationElementTableUtil()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void CollationElementTableUtil::static_constructor() {
        cli::array<int32_t> *starts = (new cli::array<int32_t>({0, 19904, 40960, 63744, 64256, 118784, 194560, 917504, 1114112}));
        cli::array<int32_t> *ends = (new cli::array<int32_t>({13328, 19984, 42192, 64112, 67648, 120832, 195104, 918016, 1114112}));
        Indexer = cli::gcnew<CodePointIndexer>(starts, ends, 0, 0);
    }
    
    void CollationElementTableUtil::constructor() {
    }
    
}}}
namespace Mono { namespace Globalization { namespace Unicode {
    
    
    void TailoringInfo::constructor(int32_t lcid, int32_t tailoringIndex, int32_t tailoringCount, bool frenchSort) {
        this->LCID = lcid;
        this->TailoringIndex = tailoringIndex;
        this->TailoringCount = tailoringCount;
        this->FrenchSort = frenchSort;
    }
    
}}}
namespace Mono { namespace Globalization { namespace Unicode {
    
    
    void Contraction::constructor(int32_t index, cli::array<char16_t>* source, System::String* replacement, cli::array<unsigned char>* sortkey) {
        this->Index = index;
        this->Source = source;
        this->Replacement = replacement;
        this->SortKey2 = sortkey;
    }
    
}}}
namespace Mono { namespace Globalization { namespace Unicode {
    
    ContractionComparer*  ContractionComparer::Instance;
    
    ContractionComparer::ContractionComparer()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void ContractionComparer::constructor() {
    }
    
    void ContractionComparer::static_constructor() {
    }
    
    int32_t ContractionComparer::Compare(System::Object* o1, System::Object* o2) {
        Contraction *c1 = cli::cast<Contraction*>(o1);
        Contraction *c2 = cli::cast<Contraction*>(o2);
        cli::array<char16_t> *a1 = c1->Source;
        cli::array<char16_t> *a2 = c2->Source;
        int32_t min = (a1->get_Length() > a2->get_Length()) ? a2->get_Length() : a1->get_Length();
        for(int32_t i = 0; (i < min); i++) {
            if(((int32_t)(a1->at(i)) != (int32_t)(a2->at(i)))) 
            {
                return ((int32_t)(a1->at(i)) - (int32_t)(a2->at(i)));
            }
        }
        if((a1->get_Length() != a2->get_Length())) 
        {
            return (a1->get_Length() - a2->get_Length());
        }
        return (c1->Index - c2->Index);
    }
    
}}}
namespace Mono { namespace Globalization { namespace Unicode {
    
    
    void Level2Map::constructor(unsigned char source, unsigned char replace) {
        this->Source = source;
        this->Replace = replace;
    }
    
}}}
namespace Mono { namespace Globalization { namespace Unicode {
    
    Level2MapComparer*  Level2MapComparer::Instance;
    
    Level2MapComparer::Level2MapComparer()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void Level2MapComparer::constructor() {
    }
    
    void Level2MapComparer::static_constructor() {
    }
    
    int32_t Level2MapComparer::Compare(System::Object* o1, System::Object* o2) {
        Level2Map *m1 = cli::cast<Level2Map*>(o1);
        Level2Map *m2 = cli::cast<Level2Map*>(o2);
        return ((int32_t)(m1->Source) - (int32_t)(m2->Source));
    }
    
}}}
namespace Mono { namespace Globalization { namespace Unicode {
    
    int32_t  MSCompatUnicodeTable::MaxExpansionLength;
    unsigned char*  MSCompatUnicodeTable::ignorableFlags;
    unsigned char*  MSCompatUnicodeTable::categories;
    unsigned char*  MSCompatUnicodeTable::level1;
    unsigned char*  MSCompatUnicodeTable::level2;
    unsigned char*  MSCompatUnicodeTable::level3;
    unsigned char*  MSCompatUnicodeTable::cjkCHScategory;
    unsigned char*  MSCompatUnicodeTable::cjkCHTcategory;
    unsigned char*  MSCompatUnicodeTable::cjkJAcategory;
    unsigned char*  MSCompatUnicodeTable::cjkKOcategory;
    unsigned char*  MSCompatUnicodeTable::cjkCHSlv1;
    unsigned char*  MSCompatUnicodeTable::cjkCHTlv1;
    unsigned char*  MSCompatUnicodeTable::cjkJAlv1;
    unsigned char*  MSCompatUnicodeTable::cjkKOlv1;
    unsigned char*  MSCompatUnicodeTable::cjkKOlv2;
    cli::array<char16_t>*  MSCompatUnicodeTable::tailoringArr;
    cli::array<TailoringInfo*>*  MSCompatUnicodeTable::tailoringInfos;
    System::Object*  MSCompatUnicodeTable::forLock;
    bool  MSCompatUnicodeTable::isReady;
    
    MSCompatUnicodeTable::MSCompatUnicodeTable()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void MSCompatUnicodeTable::static_constructor() {
        unsigned char *raw;
        unsigned char *tailor;
        uint32_t size;
        uint32_t idx = 0U;
        void *ptr = GetResource(_T("collation.core.bin"));
        if(::System::IntPtr::op_Equality(ptr, (*::System::IntPtr::Zero))) 
        {
            return;
        }
        raw = (unsigned char*)((void*)ptr);
        ptr = GetResource(_T("collation.tailoring.bin"));
        if(::System::IntPtr::op_Equality(ptr, (*::System::IntPtr::Zero))) 
        {
            return;
        }
        tailor = (unsigned char*)((void*)ptr);
        if(((raw ==  nullptr) || (tailor ==  nullptr))) 
        {
            return;
        }
        if((((int32_t)((*(raw + 0))) != 3) || ((int32_t)((*(tailor + 0))) != 3))) 
        {
            return;
        }
        idx = 1U;
        size = UInt32FromBytePtr(raw, idx);
        (idx = idx + 4U);
        ignorableFlags = (raw + (uint32_t)(idx));
        (idx = idx + size);
        size = UInt32FromBytePtr(raw, idx);
        (idx = idx + 4U);
        categories = (raw + (uint32_t)(idx));
        (idx = idx + size);
        size = UInt32FromBytePtr(raw, idx);
        (idx = idx + 4U);
        level1 = (raw + (uint32_t)(idx));
        (idx = idx + size);
        size = UInt32FromBytePtr(raw, idx);
        (idx = idx + 4U);
        level2 = (raw + (uint32_t)(idx));
        (idx = idx + size);
        size = UInt32FromBytePtr(raw, idx);
        (idx = idx + 4U);
        level3 = (raw + (uint32_t)(idx));
        (idx = idx + size);
        idx = 1U;
        uint32_t count = UInt32FromBytePtr(tailor, idx);
        (idx = idx + 4U);
        tailoringInfos = (new cli::array<TailoringInfo*>((int32_t)count));
        for(int32_t i = 0; ((int64_t)(i) < (int64_t)(count)); i++){
            int32_t i1 = (int32_t)UInt32FromBytePtr(tailor, idx);
            (idx = idx + 4U);
            int32_t i2 = (int32_t)UInt32FromBytePtr(tailor, idx);
            (idx = idx + 4U);
            int32_t i3 = (int32_t)UInt32FromBytePtr(tailor, idx);
            (idx = idx + 4U);
            TailoringInfo *ti = cli::gcnew<TailoringInfo>(i1, i2, i3, ((int32_t)((*(tailor + idx++))) != 0));
            tailoringInfos->at(i) = ti;
        }
        (idx = idx + 2U);
        count = UInt32FromBytePtr(tailor, idx);
        (idx = idx + 4U);
        tailoringArr = (new cli::array<char16_t>((int32_t)count));
        for(int32_t i = 0; ((int64_t)(i) < (int64_t)(count)); i++, (idx = idx + 2U)) {
            tailoringArr->at(i) = (char16_t)((int32_t)((*(tailor + idx))) + ((int32_t)((*(tailor + (idx + 1U)))) << 8));
        }
        isReady = true;
    }
    
    void MSCompatUnicodeTable::constructor() {
    }
    
    TailoringInfo* MSCompatUnicodeTable::GetTailoringInfo(int32_t lcid) {
        for(int32_t i = 0; (i < tailoringInfos->get_Length()); i++) {
            if((tailoringInfos->at(i)->LCID ==  lcid)) 
            {
                return tailoringInfos->at(i);
            }
        }
        return nullptr;
    }
    
    void MSCompatUnicodeTable::BuildTailoringTables(System::Globalization::CultureInfo* culture, TailoringInfo* t, cli::array<Contraction*>* contractions, cli::array<Level2Map*>* diacriticals) {
        System::Collections::ArrayList *cmaps = cli::gcnew<System::Collections::ArrayList>();
        System::Collections::ArrayList *dmaps = cli::gcnew<System::Collections::ArrayList>();
        int32_t iindex = 0;
        {
            /* FIXED - BLOCK */
            char16_t* tarr = cli::fixed_guard(((tailoringArr ==  nullptr) || (tailoringArr->get_Length() ==  0)) ? nullptr : tailoringArr);
            int32_t idx = t->TailoringIndex;
            int32_t end = (idx + t->TailoringCount);
            while((idx < end)) {
                int32_t ss = (idx + 1);
                cli::array<char16_t> *src = nullptr;
                switch((*(tarr + idx))) {
                    case u'\x1': case_185: {
                        idx++;
                        while(((int32_t)((*(tarr + ss))) != 0)) ss++;
                        src = (new cli::array<char16_t>((ss - idx)));
                        System::Runtime::InteropServices::Marshal::Copy10((void*)(void*)((tarr + (int32_t)(idx))), src, 0, (ss - idx));
                        cli::array<unsigned char> *sortkey = (new cli::array<unsigned char>(4));
                        for(int32_t i = 0; (i < 4); i++) {
                            sortkey->at(i) = (unsigned char)(*(tarr + ((ss + 1) + i)));
                        }
                        cmaps->Add_e6a92085999ce388(cli::gcnew<Contraction>(iindex, src, nullptr, sortkey));
                        idx = (ss + 6);
                        iindex++;
                        break;
                    }
                    case u'\x2': case_186: {
                        dmaps->Add_e6a92085999ce388(cli::gcnew<Level2Map>((unsigned char)(*(tarr + (idx + 1))), (unsigned char)(*(tarr + (idx + 2)))));
                        (idx = idx + 3);
                        break;
                    }
                    case u'\x3': case_187: {
                        idx++;
                        while(((int32_t)((*(tarr + ss))) != 0)) ss++;
                        src = (new cli::array<char16_t>((ss - idx)));
                        System::Runtime::InteropServices::Marshal::Copy10((void*)(void*)((tarr + (int32_t)(idx))), src, 0, (ss - idx));
                        ss++;
                        int32_t l = ss;
                        while(((int32_t)((*(tarr + l))) != 0)) l++;
                        System::String *r = cli::gcnew<System::String>(tarr, ss, (l - ss));
                        cmaps->Add_e6a92085999ce388(cli::gcnew<Contraction>(iindex, src, r, nullptr));
                        idx = (l + 1);
                        iindex++;
                        break;
                    }
                    default: case_188: {
                        throw cli::gcnew<System::NotImplementedException>(System::String::Format4(_T("Mono INTERNAL ERROR (Should not happen): Collation tailoring table is broken for culture {0} ({1}) at 0x{2:X}"), cli::box(culture->get_LCID_f4b9bc9d0bf0db86()), culture->get_Name_7a59bd1b86cfacd3(), cli::box(idx)));
                    }
                }
            }
        }
        cmaps->Sort_bdf7dee226e6219b(ContractionComparer::Instance);
        dmaps->Sort_bdf7dee226e6219b(Level2MapComparer::Instance);
        contractions = cli::as<cli::array<Contraction*>*>(cmaps->ToArray_7b80f35a5dbfbc47(cli::typeof<System::Type>::info));
        diacriticals = cli::as<cli::array<Level2Map*>*>(dmaps->ToArray_7b80f35a5dbfbc47(cli::typeof<System::Type>::info));
    }
    
    void MSCompatUnicodeTable::SetCJKReferences(System::String* name, CodePointIndexer* cjkIndexer, unsigned char* catTable, unsigned char* lv1Table, CodePointIndexer* lv2Indexer, unsigned char* lv2Table) {
        System::String* tmp_28 = name;
        ::System::Int32 tmp_29 = -1;
        if(::System::String::Equals3(tmp_28, _T("zh-CHS"))) tmp_29 = 0;
        if(::System::String::Equals3(tmp_28, _T("zh-CHT"))) tmp_29 = 1;
        if(::System::String::Equals3(tmp_28, _T("ja"))) tmp_29 = 2;
        if(::System::String::Equals3(tmp_28, _T("ko"))) tmp_29 = 3;
        switch(tmp_29)
        {
            case 0: case_189: 
            {
                catTable = cjkCHScategory;
                lv1Table = cjkCHSlv1;
                cjkIndexer = MSCompatUnicodeTableUtil::CjkCHS;
                break;
            }
            case 1: case_190: 
            {
                catTable = cjkCHTcategory;
                lv1Table = cjkCHTlv1;
                cjkIndexer = MSCompatUnicodeTableUtil::Cjk;
                break;
            }
            case 2: case_191: 
            {
                catTable = cjkJAcategory;
                lv1Table = cjkJAlv1;
                cjkIndexer = MSCompatUnicodeTableUtil::Cjk;
                break;
            }
            case 3: case_192: 
            {
                catTable = cjkKOcategory;
                lv1Table = cjkKOlv1;
                lv2Table = cjkKOlv2;
                cjkIndexer = MSCompatUnicodeTableUtil::Cjk;
                lv2Indexer = MSCompatUnicodeTableUtil::Cjk;
                break;
            }
        }
    }
    
    unsigned char MSCompatUnicodeTable::Category(int32_t cp) {
        return (*(categories + MSCompatUnicodeTableUtil::Category->ToIndex(cp)));
    }
    
    unsigned char MSCompatUnicodeTable::Level1(int32_t cp) {
        return (*(level1 + MSCompatUnicodeTableUtil::Level1->ToIndex(cp)));
    }
    
    unsigned char MSCompatUnicodeTable::Level2(int32_t cp) {
        return (*(level2 + MSCompatUnicodeTableUtil::Level2->ToIndex(cp)));
    }
    
    unsigned char MSCompatUnicodeTable::Level3(int32_t cp) {
        return (*(level3 + MSCompatUnicodeTableUtil::Level3->ToIndex(cp)));
    }
    
    bool MSCompatUnicodeTable::IsSortable(System::String* s) {
        for(auto tmp_30 : s) {
            auto c = cli::cast<char16_t>(tmp_30);
            if(!(IsSortable2((int32_t)(c)))) 
            {
                return false;
            }
        }
        return true;
    }
    
    bool MSCompatUnicodeTable::IsSortable2(int32_t cp) {
        if(!(IsIgnorable(cp))) 
        {
            return true;
        }
        switch(cp) {
            case 0: case 1600: case 65279: case_193: {
                return true;
            }
        }
        return (((((((6155 <= cp) && (cp <= 6158)) || ((8204 <= cp) && (cp <= 8207))) || ((8234 <= cp) && (cp <= 8238))) || ((8298 <= cp) && (cp <= 8303))) || ((8204 <= cp) && (cp <= 8207))) || ((65529 <= cp) && (cp <= 65533)));
    }
    
    bool MSCompatUnicodeTable::IsIgnorable(int32_t cp) {
        return IsIgnorable2(cp, 1);
    }
    
    bool MSCompatUnicodeTable::IsIgnorable2(int32_t cp, unsigned char flag) {
        if((cp ==  0)) 
        {
            return true;
        }
        if((((int32_t)(flag) & 1) != 0)) 
        {
            System::Globalization::UnicodeCategory uc = System::Char::GetUnicodeCategory((char16_t)cp);
            if(((int32_t)(uc) ==  29)) 
            {
                return true;
            }
            if(((55424 <= cp) && (cp < 56192))) 
            {
                return true;
            }
        }
        int32_t i = MSCompatUnicodeTableUtil::Ignorable->ToIndex(cp);
        return ((i >= 0) && (((int32_t)((*(ignorableFlags + i))) & (int32_t)(flag)) != 0));
    }
    
    bool MSCompatUnicodeTable::IsIgnorableSymbol(int32_t cp) {
        return IsIgnorable2(cp, 2);
    }
    
    bool MSCompatUnicodeTable::IsIgnorableNonSpacing(int32_t cp) {
        return IsIgnorable2(cp, 4);
    }
    
    int32_t MSCompatUnicodeTable::ToKanaTypeInsensitive(int32_t i) {
        return ((12353 <= i) && (i <= 12436)) ? (i + 96) : i;
    }
    
    int32_t MSCompatUnicodeTable::ToWidthCompat(int32_t i) {
        if((i < 8592)) 
        {
            return i;
        }
        if((i > 65280)) 
        {
            if((i <= 65374)) 
            {
                return ((i - 65280) + 32);
            }
            switch(i) {
                case 65504: case_194: {
                    return 162;
                }
                case 65505: case_195: {
                    return 163;
                }
                case 65506: case_196: {
                    return 172;
                }
                case 65507: case_197: {
                    return 175;
                }
                case 65508: case_198: {
                    return 166;
                }
                case 65509: case_199: {
                    return 165;
                }
                case 65510: case_200: {
                    return 8361;
                }
            }
        }
        if((i > 13054)) 
        {
            return i;
        }
        if((i <= 8595)) 
        {
            return (56921 + i);
        }
        if((i < 9474)) 
        {
            return i;
        }
        if((i <= 9675)) 
        {
            switch(i) {
                case 9474: case_201: {
                    return 65512;
                }
                case 9632: case_202: {
                    return 65517;
                }
                case 9675: case_203: {
                    return 65518;
                }
                default: case_204: {
                    return i;
                }
            }
        }
        if((i < 12288)) 
        {
            return i;
        }
        if((i < 12593)) 
        {
            switch(i) {
                case 12288: case_205: {
                    return 32;
                }
                case 12289: case_206: {
                    return 65380;
                }
                case 12290: case_207: {
                    return 65377;
                }
                case 12300: case_208: {
                    return 65378;
                }
                case 12301: case_209: {
                    return 65379;
                }
                case 12539: case_210: {
                    return 65381;
                }
                default: case_211: {
                    return i;
                }
            }
        }
        if((i < 12644)) 
        {
            return ((i - 12592) + 65440);
        }
        if((i ==  12644)) 
        {
            return 65440;
        }
        return i;
    }
    
    bool MSCompatUnicodeTable::HasSpecialWeight(char16_t c) {
        if(((int32_t)(c) < 12353)) 
        {
            return false;
        }
         else 
        {
            if(((65382 <= (int32_t)(c)) && ((int32_t)(c) < 65438))) 
            {
                return true;
            }
             else 
            {
                if((13056 <= (int32_t)(c))) 
                {
                    return false;
                }
                 else 
                {
                    if(((int32_t)(c) < 12445)) 
                    {
                        return ((int32_t)(c) < 12441);
                    }
                     else 
                    {
                        if(((int32_t)(c) < 12544)) 
                        {
                            return ((int32_t)(c) != 12539);
                        }
                         else 
                        {
                            if(((int32_t)(c) < 13008)) 
                            {
                                return false;
                            }
                             else 
                            {
                                if(((int32_t)(c) < 13055)) 
                                {
                                    return true;
                                }
                            }
                        }
                    }
                }
            }
        }
        return false;
    }
    
    unsigned char MSCompatUnicodeTable::GetJapaneseDashType(char16_t c) {
        switch(c) {
            case u'\x309d': case u'\x309e': case u'\x30fd': case u'\x30fe': case u'\xff70': case_212: {
                return 4;
            }
            case u'\x30fc': case_213: {
                return 5;
            }
        }
        return 3;
    }
    
    bool MSCompatUnicodeTable::IsHalfWidthKana(char16_t c) {
        return ((65382 <= (int32_t)(c)) && ((int32_t)(c) <= 65437));
    }
    
    bool MSCompatUnicodeTable::IsHiragana(char16_t c) {
        return ((12353 <= (int32_t)(c)) && ((int32_t)(c) <= 12436));
    }
    
    bool MSCompatUnicodeTable::IsJapaneseSmallLetter(char16_t c) {
        if(((65383 <= (int32_t)(c)) && ((int32_t)(c) <= 65391))) 
        {
            return true;
        }
        if(((12352 < (int32_t)(c)) && ((int32_t)(c) < 12538))) 
        {
            switch(c) {
                case u'\x3041': case u'\x3043': case u'\x3045': case u'\x3047': case u'\x3049': case u'\x3063': case u'\x3083': case u'\x3085': case u'\x3087': case u'\x308e': case u'\x30a1': case u'\x30a3': case u'\x30a5': case u'\x30a7': case u'\x30a9': case u'\x30c3': case u'\x30e3': case u'\x30e5': case u'\x30e7': case u'\x30ee': case u'\x30f5': case u'\x30f6': case_214: {
                    return true;
                }
            }
        }
        return false;
    }
    
    void* MSCompatUnicodeTable::GetResource(System::String* name) {
        int32_t size;
        System::Reflection::Module *module;
        return System::Reflection::Assembly::GetExecutingAssembly()->GetManifestResourceInternal(name, size, module);
    }
    
    uint32_t MSCompatUnicodeTable::UInt32FromBytePtr(unsigned char* raw, uint32_t idx) {
        return (uint32_t)((((int32_t)((*(raw + idx))) + ((int32_t)((*(raw + (idx + 1U)))) << 8)) + ((int32_t)((*(raw + (idx + 2U)))) << 16)) + ((int32_t)((*(raw + (idx + 3U)))) << 24));
    }
    
    void MSCompatUnicodeTable::FillCJK(System::String* culture, CodePointIndexer* cjkIndexer, unsigned char* catTable, unsigned char* lv1Table, CodePointIndexer* lv2Indexer, unsigned char* lv2Table) {
        {
            cli::lock_guard{forLock};
            FillCJKCore(culture, cjkIndexer, catTable, lv1Table, lv2Indexer, lv2Table);
            SetCJKReferences(culture, cjkIndexer, catTable, lv1Table, lv2Indexer, lv2Table);
        }
    }
    
    void MSCompatUnicodeTable::FillCJKCore(System::String* culture, CodePointIndexer* cjkIndexer, unsigned char* catTable, unsigned char* lv1Table, CodePointIndexer* cjkLv2Indexer, unsigned char* lv2Table) {
        if(!(MSCompatUnicodeTable::get_IsReady())) 
        {
            return;
        }
        System::String *name = nullptr;
        System::String* tmp_31 = culture;
        ::System::Int32 tmp_32 = -1;
        if(::System::String::Equals3(tmp_31, _T("zh-CHS"))) tmp_32 = 0;
        if(::System::String::Equals3(tmp_31, _T("zh-CHT"))) tmp_32 = 1;
        if(::System::String::Equals3(tmp_31, _T("ja"))) tmp_32 = 2;
        if(::System::String::Equals3(tmp_31, _T("ko"))) tmp_32 = 3;
        switch(tmp_32)
        {
            case 0: case_215: 
            {
                name = _T("cjkCHS");
                catTable = cjkCHScategory;
                lv1Table = cjkCHSlv1;
                break;
            }
            case 1: case_216: 
            {
                name = _T("cjkCHT");
                catTable = cjkCHTcategory;
                lv1Table = cjkCHTlv1;
                break;
            }
            case 2: case_217: 
            {
                name = _T("cjkJA");
                catTable = cjkJAcategory;
                lv1Table = cjkJAlv1;
                break;
            }
            case 3: case_218: 
            {
                name = _T("cjkKO");
                catTable = cjkKOcategory;
                lv1Table = cjkKOlv1;
                break;
            }
        }
        if(((name ==  nullptr) || (lv1Table != nullptr))) 
        {
            return;
        }
        unsigned char *raw;
        uint32_t idx = 0U;
        System::String *filename = System::String::Format2(_T("collation.{0}.bin"), name);
        void *ptr = GetResource(filename);
        if(::System::IntPtr::op_Equality(ptr, (*::System::IntPtr::Zero))) 
        {
            return;
        }
        raw = (unsigned char*)((void*)ptr);
        (idx = idx + 1U);
        uint32_t count = UInt32FromBytePtr(raw, idx);
        (idx = idx + 4U);
        catTable = ((unsigned char*)(raw) + (uint32_t)(idx));
        lv1Table = (((unsigned char*)(raw) + (uint32_t)(idx)) + (uint32_t)(count));
        System::String* tmp_33 = culture;
        ::System::Int32 tmp_34 = -1;
        if(::System::String::Equals3(tmp_33, _T("zh-CHS"))) tmp_34 = 0;
        if(::System::String::Equals3(tmp_33, _T("zh-CHT"))) tmp_34 = 1;
        if(::System::String::Equals3(tmp_33, _T("ja"))) tmp_34 = 2;
        if(::System::String::Equals3(tmp_33, _T("ko"))) tmp_34 = 3;
        switch(tmp_34)
        {
            case 0: case_219: 
            {
                cjkCHScategory = catTable;
                cjkCHSlv1 = lv1Table;
                break;
            }
            case 1: case_220: 
            {
                cjkCHTcategory = catTable;
                cjkCHTlv1 = lv1Table;
                break;
            }
            case 2: case_221: 
            {
                cjkJAcategory = catTable;
                cjkJAlv1 = lv1Table;
                break;
            }
            case 3: case_222: 
            {
                cjkKOcategory = catTable;
                cjkKOlv1 = lv1Table;
                break;
            }
        }
        if(System::String::op_Inequality(name, _T("cjkKO"))) 
        {
            return;
        }
        ptr = GetResource(_T("collation.cjkKOlv2.bin"));
        if(::System::IntPtr::op_Equality(ptr, (*::System::IntPtr::Zero))) 
        {
            return;
        }
        raw = (unsigned char*)((void*)ptr);
        idx = 5U;
        cjkKOlv2 = (raw + (uint32_t)(idx));
        lv2Table = cjkKOlv2;
    }
    
    bool MSCompatUnicodeTable::get_IsReady() {
        return isReady;
    }
    
}}}
namespace Mono { namespace Globalization { namespace Unicode {
    
    CodePointIndexer*  MSCompatUnicodeTableUtil::Ignorable;
    CodePointIndexer*  MSCompatUnicodeTableUtil::Category;
    CodePointIndexer*  MSCompatUnicodeTableUtil::Level1;
    CodePointIndexer*  MSCompatUnicodeTableUtil::Level2;
    CodePointIndexer*  MSCompatUnicodeTableUtil::Level3;
    CodePointIndexer*  MSCompatUnicodeTableUtil::CjkCHS;
    CodePointIndexer*  MSCompatUnicodeTableUtil::Cjk;
    
    MSCompatUnicodeTableUtil::MSCompatUnicodeTableUtil()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void MSCompatUnicodeTableUtil::static_constructor() {
        cli::array<int32_t> *ignoreStarts = (new cli::array<int32_t>({0, 40960, 63744}));
        cli::array<int32_t> *ignoreEnds = (new cli::array<int32_t>({13312, 42240, 65536}));
        cli::array<int32_t> *catStarts = (new cli::array<int32_t>({0, 7680, 12288, 19968, 44032, 63744}));
        cli::array<int32_t> *catEnds = (new cli::array<int32_t>({4608, 10240, 13312, 40960, 55216, 65536}));
        cli::array<int32_t> *lv1Starts = (new cli::array<int32_t>({0, 7680, 12288, 19968, 44032, 63744}));
        cli::array<int32_t> *lv1Ends = (new cli::array<int32_t>({4608, 10240, 13312, 40960, 55216, 65536}));
        cli::array<int32_t> *lv2Starts = (new cli::array<int32_t>({0, 7680, 12288, 64256}));
        cli::array<int32_t> *lv2Ends = (new cli::array<int32_t>({3840, 10240, 13312, 65536}));
        cli::array<int32_t> *lv3Starts = (new cli::array<int32_t>({0, 7680, 12288, 64256}));
        cli::array<int32_t> *lv3Ends = (new cli::array<int32_t>({4608, 10240, 13312, 65536}));
        cli::array<int32_t> *chsStarts = (new cli::array<int32_t>({12544, 19968, 59392}));
        cli::array<int32_t> *chsEnds = (new cli::array<int32_t>({13312, 40960, 65536}));
        cli::array<int32_t> *cjkStarts = (new cli::array<int32_t>({12544, 19968, 63744}));
        cli::array<int32_t> *cjkEnds = (new cli::array<int32_t>({13312, 40960, 64256}));
        Ignorable = cli::gcnew<CodePointIndexer>(ignoreStarts, ignoreEnds, -1, -1);
        Category = cli::gcnew<CodePointIndexer>(catStarts, catEnds, 0, 0);
        Level1 = cli::gcnew<CodePointIndexer>(lv1Starts, lv1Ends, 0, 0);
        Level2 = cli::gcnew<CodePointIndexer>(lv2Starts, lv2Ends, 0, 0);
        Level3 = cli::gcnew<CodePointIndexer>(lv3Starts, lv3Ends, 0, 0);
        CjkCHS = cli::gcnew<CodePointIndexer>(chsStarts, chsEnds, -1, -1);
        Cjk = cli::gcnew<CodePointIndexer>(cjkStarts, cjkEnds, -1, -1);
    }
    
    void MSCompatUnicodeTableUtil::constructor() {
    }
    
}}}
namespace Mono { namespace Globalization { namespace Unicode {
    
    unsigned char*  Normalization::props;
    int32_t*  Normalization::mappedChars;
    int16_t*  Normalization::charMapIndex;
    int16_t*  Normalization::helperIndex;
    uint16_t*  Normalization::mapIdxToComposite;
    unsigned char*  Normalization::combiningClass;
    System::Object*  Normalization::forLock;
    bool  Normalization::isReady;
    
    Normalization::Normalization()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void Normalization::static_constructor() {
        void *p1, *p2, *p3, *p4, *p5, *p6;
        {
            cli::lock_guard{forLock};
            load_normalization_resource(p1, p2, p3, p4, p5, p6);
            props = (unsigned char*)((void*)p1);
            mappedChars = (int32_t*)((void*)p2);
            charMapIndex = (int16_t*)((void*)p3);
            helperIndex = (int16_t*)((void*)p4);
            mapIdxToComposite = (uint16_t*)((void*)p5);
            combiningClass = (unsigned char*)((void*)p6);
        }
        isReady = true;
    }
    
    void Normalization::constructor() {
    }
    
    uint32_t Normalization::PropValue(int32_t cp) {
        return (uint32_t)((*(props + NormalizationTableUtil::PropIdx(cp))));
    }
    
    int32_t Normalization::CharMapIdx(int32_t cp) {
        return (int32_t)((*(charMapIndex + NormalizationTableUtil::MapIdx(cp))));
    }
    
    unsigned char Normalization::GetCombiningClass(int32_t c) {
        return (*(combiningClass + NormalizationTableUtil::Combining->ToIndex(c)));
    }
    
    int32_t Normalization::GetPrimaryCompositeFromMapIndex(int32_t src) {
        return (int32_t)((*(mapIdxToComposite + NormalizationTableUtil::Composite->ToIndex(src))));
    }
    
    int32_t Normalization::GetPrimaryCompositeHelperIndex(int32_t cp) {
        return (int32_t)((*(helperIndex + NormalizationTableUtil::Helper->ToIndex(cp))));
    }
    
    System::String* Normalization::Compose(System::String* source, int32_t checkType) {
        System::Text::StringBuilder *sb = nullptr;
        Decompose2(source, sb, (checkType ==  2) ? 3 : 1);
        if((sb ==  nullptr)) 
        {
            sb = Combine(source, 0, checkType);
        }
         else 
        {
            Combine2(sb, 0, checkType);
        }
        return (sb != nullptr) ? sb->ToString_1636a0751cb9ac11() : source;
    }
    
    System::Text::StringBuilder* Normalization::Combine(System::String* source, int32_t start, int32_t checkType) {
        for(int32_t i = 0; (i < source->get_Length()); i++){
            if(((int32_t)(QuickCheck(source->get_Chars(i), checkType)) ==  0)) 
            {
                continue;
            }
            System::Text::StringBuilder *sb = cli::gcnew<System::Text::StringBuilder>((source->get_Length() + (source->get_Length() / 10)));
            sb->Append2(source);
            Combine2(sb, i, checkType);
            return sb;
        }
        return nullptr;
    }
    
    void Normalization::Combine2(System::Text::StringBuilder* sb, int32_t i, int32_t checkType) {
        CombineHangul(sb, nullptr, (i > 0) ? (i - 1) : i);
        while((i < sb->get_Length())) {
            if(((int32_t)(QuickCheck(sb->get_Chars(i), checkType)) ==  0)) 
            {
                i++;
                continue;
            }
            i = TryComposeWithPreviousStarter(sb, nullptr, i);
        }
    }
    
    int32_t Normalization::CombineHangul(System::Text::StringBuilder* sb, System::String* s, int32_t current) {
        int32_t length = (sb != nullptr) ? sb->get_Length() : s->get_Length();
        int32_t last = Fetch(sb, s, current);
        for(int32_t i = (current + 1); (i < length); ++i){
            int32_t ch = Fetch(sb, s, i);
            int32_t LIndex = (last - 4352);
            if(((0 <= LIndex) && (LIndex < 19))) 
            {
                int32_t VIndex = (ch - 4449);
                if(((0 <= VIndex) && (VIndex < 21))) 
                {
                    if((sb ==  nullptr)) 
                    {
                        return -1;
                    }
                    last = (44032 + (((LIndex * 21) + VIndex) * 28));
                    sb->set_Chars((i - 1), (char16_t)last);
                    sb->Remove(i, 1);
                    i--;
                    length--;
                    continue;
                }
            }
            int32_t SIndex = (last - 44032);
            if((((0 <= SIndex) && (SIndex < 11172)) && ((SIndex % 28) ==  0))) 
            {
                int32_t TIndex = (ch - 4519);
                if(((0 < TIndex) && (TIndex < 28))) 
                {
                    if((sb ==  nullptr)) 
                    {
                        return -1;
                    }
                    (last = last + TIndex);
                    sb->set_Chars((i - 1), (char16_t)last);
                    sb->Remove(i, 1);
                    i--;
                    length--;
                    continue;
                }
            }
            last = ch;
        }
        return length;
    }
    
    int32_t Normalization::Fetch(System::Text::StringBuilder* sb, System::String* s, int32_t i) {
        return (int32_t)((sb != nullptr) ? sb->get_Chars(i) : s->get_Chars(i));
    }
    
    int32_t Normalization::TryComposeWithPreviousStarter(System::Text::StringBuilder* sb, System::String* s, int32_t current) {
        int32_t i = (current - 1);
        if(((int32_t)(GetCombiningClass(Fetch(sb, s, current))) ==  0)) 
        {
            if(((i < 0) || ((int32_t)(GetCombiningClass(Fetch(sb, s, i))) != 0))) 
            {
                return (current + 1);
            }
        }
         else 
        {
            while(((i >= 0) && ((int32_t)(GetCombiningClass(Fetch(sb, s, i))) != 0))) i--;
            if((i < 0)) 
            {
                return (current + 1);
            }
        }
        int32_t starter = Fetch(sb, s, i);
        int32_t comp_idx = GetPrimaryCompositeHelperIndex(starter);
        if((comp_idx ==  0)) 
        {
            return (current + 1);
        }
        int32_t length = (sb != nullptr) ? sb->get_Length() : s->get_Length();
        int32_t prevCombiningClass = -1;
        for(int32_t j = (i + 1); (j < length); j++){
            int32_t candidate = Fetch(sb, s, j);
            int32_t combiningClass = (int32_t)(GetCombiningClass(candidate));
            if((combiningClass ==  prevCombiningClass)) 
            {
                continue;
            }
            int32_t composed = TryCompose(comp_idx, starter, candidate);
            if((composed != 0)) 
            {
                if((sb ==  nullptr)) 
                {
                    return -1;
                }
                sb->set_Chars(i, (char16_t)composed);
                sb->Remove(j, 1);
                return current;
            }
            if((combiningClass ==  0)) 
            {
                return (j + 1);
            }
            prevCombiningClass = combiningClass;
        }
        return length;
    }
    
    int32_t Normalization::TryCompose(int32_t i, int32_t starter, int32_t candidate) {
        while(((*(mappedChars + i)) ==  starter)) {
            if((((*(mappedChars + (i + 1))) ==  candidate) && ((*(mappedChars + (i + 2))) ==  0))) 
            {
                int32_t composed = GetPrimaryCompositeFromMapIndex(i);
                if(((PropValue(composed) & 64U) ==  0U)) 
                {
                    return composed;
                }
            }
            while(((*(mappedChars + i)) != 0)) i++;
            i++;
        }
        return 0;
    }
    
    System::String* Normalization::Decompose(System::String* source, int32_t checkType) {
        System::Text::StringBuilder *sb = nullptr;
        Decompose2(source, sb, checkType);
        return (sb != nullptr) ? sb->ToString_1636a0751cb9ac11() : source;
    }
    
    void Normalization::Decompose2(System::String* source, System::Text::StringBuilder* sb, int32_t checkType) {
        cli::array<int32_t> *buf = nullptr;
        int32_t start = 0;
        for(int32_t i = 0; (i < source->get_Length()); i++) {
            if(((int32_t)(QuickCheck(source->get_Chars(i), checkType)) ==  1)) 
            {
                DecomposeChar(sb, buf, source, i, checkType, start);
            }
        }
        if((sb != nullptr)) 
        {
            sb->Append19(source, start, (source->get_Length() - start));
        }
        ReorderCanonical(source, sb, 1);
    }
    
    void Normalization::ReorderCanonical(System::String* src, System::Text::StringBuilder* sb, int32_t start) {
        if((sb ==  nullptr)) 
        {
            for(int32_t i = 1; (i < src->get_Length()); i++){
                int32_t level = (int32_t)(GetCombiningClass((int32_t)(src->get_Chars(i))));
                if((level ==  0)) 
                {
                    continue;
                }
                if(((int32_t)(GetCombiningClass((int32_t)(src->get_Chars((i - 1))))) > level)) 
                {
                    sb = cli::gcnew<System::Text::StringBuilder>(src->get_Length());
                    sb->Append19(src, 0, src->get_Length());
                    ReorderCanonical(src, sb, i);
                    return;
                }
            }
            return;
        }
        for(int32_t i = start; (i < sb->get_Length()); ){
            int32_t level = (int32_t)(GetCombiningClass((int32_t)(sb->get_Chars(i))));
            if(((level ==  0) || ((int32_t)(GetCombiningClass((int32_t)(sb->get_Chars((i - 1))))) <= level))) 
            {
                i++;
                continue;
            }
            char16_t c = sb->get_Chars((i - 1));
            sb->set_Chars((i - 1), sb->get_Chars(i));
            sb->set_Chars(i, c);
            if((i > 1)) 
            {
                i--;
            }
        }
    }
    
    void Normalization::DecomposeChar(System::Text::StringBuilder* sb, cli::array<int32_t>* buf, System::String* s, int32_t i, int32_t checkType, int32_t start) {
        if((sb ==  nullptr)) 
        {
            sb = cli::gcnew<System::Text::StringBuilder>((s->get_Length() + 100));
        }
        sb->Append19(s, start, (i - start));
        if((buf ==  nullptr)) 
        {
            buf = (new cli::array<int32_t>(19));
        }
        int32_t n = GetCanonical((int32_t)(s->get_Chars(i)), buf, 0, checkType);
        for(int32_t x = 0; (x < n); x++){
            if((buf->at(x) < 65535)) 
            {
                sb->Append16((char16_t)buf->at(x));
            }
             else 
            {
                sb->Append16((char16_t)((buf->at(x) >> 10) + 55296));
                sb->Append16((char16_t)((buf->at(x) & 4095) + 56320));
            }
        }
        start = (i + 1);
    }
    
    NormalizationCheck Normalization::QuickCheck(char16_t c, int32_t type) {
        uint32_t v;
        switch(type) {
            default: case_223: {
                v = PropValue((int32_t)(c));
                return ((v & 4U) ==  0U) ? ((v & 8U) ==  0U) ? NormalizationCheck::Yes : NormalizationCheck::Maybe : NormalizationCheck::No;
            }
            case 1: case_224: {
                if(((44032 <= (int32_t)(c)) && ((int32_t)(c) <= 55203))) 
                {
                    return NormalizationCheck::No;
                }
                return ((PropValue((int32_t)(c)) & 1U) != 0U) ? NormalizationCheck::No : NormalizationCheck::Yes;
            }
            case 2: case_225: {
                v = PropValue((int32_t)(c));
                return ((v & 16U) != 0U) ? NormalizationCheck::No : ((v & 32U) != 0U) ? NormalizationCheck::Maybe : NormalizationCheck::Yes;
            }
            case 3: case_226: {
                if(((44032 <= (int32_t)(c)) && ((int32_t)(c) <= 55203))) 
                {
                    return NormalizationCheck::No;
                }
                return ((PropValue((int32_t)(c)) & 2U) != 0U) ? NormalizationCheck::No : NormalizationCheck::Yes;
            }
        }
    }
    
    int32_t Normalization::GetCanonicalHangul(int32_t s, cli::array<int32_t>* buf, int32_t bufIdx) {
        int32_t idx = (s - 44032);
        if(((idx < 0) || (idx >= 11172))) 
        {
            return bufIdx;
        }
        int32_t L = (4352 + (idx / 588));
        int32_t V = (4449 + ((idx % 588) / 28));
        int32_t T = (4519 + (idx % 28));
        buf->at(bufIdx++) = L;
        buf->at(bufIdx++) = V;
        if((T != 4519)) 
        {
            buf->at(bufIdx++) = T;
        }
        buf->at(bufIdx) = 0;
        return bufIdx;
    }
    
    int32_t Normalization::GetCanonical(int32_t c, cli::array<int32_t>* buf, int32_t bufIdx, int32_t checkType) {
        int32_t newBufIdx = GetCanonicalHangul(c, buf, bufIdx);
        if((newBufIdx > bufIdx)) 
        {
            return newBufIdx;
        }
        int32_t i = CharMapIdx(c);
        if(((i ==  0) || ((*(mappedChars + i)) ==  c))) 
        {
            buf->at(bufIdx++) = c;
        }
         else 
        {
            for(; ((*(mappedChars + i)) != 0); i++){
                int32_t nth = (*(mappedChars + i));
                if(((nth <= 65535) && ((int32_t)(QuickCheck((char16_t)nth, checkType)) ==  0))) 
                {
                    buf->at(bufIdx++) = nth;
                }
                 else 
                {
                    bufIdx = GetCanonical(nth, buf, bufIdx, checkType);
                }
            }
        }
        return bufIdx;
    }
    
    bool Normalization::IsNormalized(System::String* source, int32_t type) {
        int32_t prevCC = -1;
        for(int32_t i = 0; (i < source->get_Length()); ){
            int32_t cc = (int32_t)(GetCombiningClass((int32_t)(source->get_Chars(i))));
            if(((cc != 0) && (cc < prevCC))) 
            {
                return false;
            }
            prevCC = cc;
            switch(QuickCheck(source->get_Chars(i), type)) {
                case NormalizationCheck::Yes: case_227: {
                    i++;
                    break;
                }
                case NormalizationCheck::No: case_228: {
                    return false;
                }
                case NormalizationCheck::Maybe: case_229: {
                    switch(type) {
                        case 0: case 2: case_230: {
                            return System::String::op_Equality(source, Normalize(source, type));
                        }
                    }
                    i = CombineHangul(nullptr, source, (i > 0) ? (i - 1) : i);
                    if((i < 0)) 
                    {
                        return false;
                    }
                    i = TryComposeWithPreviousStarter(nullptr, source, i);
                    if((i < 0)) 
                    {
                        return false;
                    }
                    break;
                }
            }
        }
        return true;
    }
    
    System::String* Normalization::Normalize(System::String* source, int32_t type) {
        switch(type) {
            default: case 2: case_231: {
                return Compose(source, type);
            }
            case 1: case 3: case_232: {
                return Decompose(source, type);
            }
        }
    }
    
    void Normalization::load_normalization_resource(void* props, void* mappedChars, void* charMapIndex, void* helperIndex, void* mapIdxToComposite, void* combiningClass) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool Normalization::get_IsReady() {
        return isReady;
    }
    
}}}
namespace Mono { namespace Globalization { namespace Unicode {
    
    CodePointIndexer*  NormalizationTableUtil::Prop;
    CodePointIndexer*  NormalizationTableUtil::Map;
    CodePointIndexer*  NormalizationTableUtil::Combining;
    CodePointIndexer*  NormalizationTableUtil::Composite;
    CodePointIndexer*  NormalizationTableUtil::Helper;
    
    NormalizationTableUtil::NormalizationTableUtil()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void NormalizationTableUtil::static_constructor() {
        cli::array<int32_t> *propStarts = (new cli::array<int32_t>({0, 2320, 6912, 9312, 10624, 11376, 11616, 11920, 42864, 63744}));
        cli::array<int32_t> *propEnds = (new cli::array<int32_t>({1760, 4608, 9008, 9728, 10976, 11392, 11632, 13312, 42880, 65536}));
        cli::array<int32_t> *mapStarts = (new cli::array<int32_t>({144, 2336, 7456, 9312, 9376, 10752, 11616, 11920, 63744}));
        cli::array<int32_t> *mapEnds = (new cli::array<int32_t>({1760, 4352, 9008, 9376, 9456, 10976, 11632, 13312, 65536}));
        cli::array<int32_t> *combiningStarts = (new cli::array<int32_t>({752, 1152, 1424, 2352, 2480, 2608, 2736, 2864, 3008, 3136, 3248, 3392, 3520, 3632, 3760, 3840, 4144, 4944, 5904, 6096, 6304, 6448, 6672, 7616, 8400, 12320, 12432, 43008, 64272, 65056}));
        cli::array<int32_t> *combiningEnds = (new cli::array<int32_t>({864, 1168, 1872, 2400, 2512, 2640, 2768, 2896, 3024, 3168, 3280, 3408, 3536, 3664, 3792, 4048, 4160, 4960, 5952, 6112, 6320, 6464, 6688, 7632, 8432, 12336, 12448, 43024, 64288, 65072}));
        cli::array<int32_t> *compositeStarts = (new cli::array<int32_t>({1152, 5136, 5744}));
        cli::array<int32_t> *compositeEnds = (new cli::array<int32_t>({4224, 5504, 8624}));
        cli::array<int32_t> *helperStarts = (new cli::array<int32_t>({0, 2304, 7424, 9472, 12288, 15248, 16400, 19968, 64320}));
        cli::array<int32_t> *helperEnds = (new cli::array<int32_t>({1792, 4608, 8960, 9728, 12640, 15264, 16432, 40960, 64336}));
        Prop = cli::gcnew<CodePointIndexer>(propStarts, propEnds, 0, 0);
        Map = cli::gcnew<CodePointIndexer>(mapStarts, mapEnds, 0, 0);
        Combining = cli::gcnew<CodePointIndexer>(combiningStarts, combiningEnds, 0, 0);
        Composite = cli::gcnew<CodePointIndexer>(compositeStarts, compositeEnds, 0, 0);
        Helper = cli::gcnew<CodePointIndexer>(helperStarts, helperEnds, 0, 0);
    }
    
    void NormalizationTableUtil::constructor() {
    }
    
    int32_t NormalizationTableUtil::PropIdx(int32_t cp) {
        return Prop->ToIndex(cp);
    }
    
    int32_t NormalizationTableUtil::PropCP(int32_t index) {
        return Prop->ToCodePoint(index);
    }
    
    int32_t NormalizationTableUtil::MapIdx(int32_t cp) {
        return Map->ToIndex(cp);
    }
    
    int32_t NormalizationTableUtil::MapCP(int32_t index) {
        return Map->ToCodePoint(index);
    }
    
    int32_t NormalizationTableUtil::CbIdx(int32_t cp) {
        return Combining->ToIndex(cp);
    }
    
    int32_t NormalizationTableUtil::CbCP(int32_t index) {
        return Combining->ToCodePoint(index);
    }
    
    int32_t NormalizationTableUtil::get_PropCount() {
        return Prop->TotalCount;
    }
    
    int32_t NormalizationTableUtil::get_MapCount() {
        return Map->TotalCount;
    }
    
}}}
namespace Mono { namespace Globalization { namespace Unicode {
    
    bool  SimpleCollator::QuickCheckDisabled;
    SimpleCollator*  SimpleCollator::invariant;
    
    SimpleCollator::SimpleCollator()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void SimpleCollator::constructor(System::Globalization::CultureInfo* culture) {
        this->lcid = culture->get_LCID_f4b9bc9d0bf0db86();
        this->textInfo = culture->get_TextInfo_63dfa6e5f11a61f0();
        SetCJKTable(culture, this->cjkIndexer, this->cjkCatTable, this->cjkLv1Table, this->cjkLv2Indexer, this->cjkLv2Table);
        TailoringInfo *t = nullptr;
        for(System::Globalization::CultureInfo *ci = culture; (ci->get_LCID_f4b9bc9d0bf0db86() != 127); ci = ci->get_Parent_87d5fb2f5c680cba()){
            t = MSCompatUnicodeTable::GetTailoringInfo(ci->get_LCID_f4b9bc9d0bf0db86());
            if((t != nullptr)) 
            {
                break;
            }
        }
        if((t ==  nullptr)) 
        {
            t = MSCompatUnicodeTable::GetTailoringInfo(127);
        }
        this->frenchSort = t->FrenchSort;
        MSCompatUnicodeTable::BuildTailoringTables(culture, t, this->contractions, this->level2Maps);
        this->unsafeFlags = (new cli::array<unsigned char>(96));
        for(auto tmp_35 : this->contractions) {
            auto c = cli::cast<Contraction*>(tmp_35);
            {
                if((c->Source->get_Length() > 1)) 
                {
                    for(auto tmp_36 : c->Source) {
                        auto ch = cli::cast<char16_t>(tmp_36);
                        (this->unsafeFlags->at(((int32_t)(ch) / 8)) = (unsigned char)((int32_t)(this->unsafeFlags->at(((int32_t)(ch) / 8))) | (int32_t)((unsigned char)(1 << (((int32_t)(ch) & 7) & 31)))));
                    }
                }
            }
        }
        if((this->lcid != 127)) 
        {
            for(auto tmp_37 : invariant->contractions) {
                auto c = cli::cast<Contraction*>(tmp_37);
                {
                    if((c->Source->get_Length() > 1)) 
                    {
                        for(auto tmp_38 : c->Source) {
                            auto ch = cli::cast<char16_t>(tmp_38);
                            (this->unsafeFlags->at(((int32_t)(ch) / 8)) = (unsigned char)((int32_t)(this->unsafeFlags->at(((int32_t)(ch) / 8))) | (int32_t)((unsigned char)(1 << (((int32_t)(ch) & 7) & 31)))));
                        }
                    }
                }
            }
        }
    }
    
    void SimpleCollator::static_constructor() {
    }
    
    void SimpleCollator::SetCJKTable(System::Globalization::CultureInfo* culture, CodePointIndexer* cjkIndexer, unsigned char* catTable, unsigned char* lv1Table, CodePointIndexer* lv2Indexer, unsigned char* lv2Table) {
        System::String *name = GetNeutralCulture(culture)->get_Name_7a59bd1b86cfacd3();
        MSCompatUnicodeTable::FillCJK(name, cjkIndexer, catTable, lv1Table, lv2Indexer, lv2Table);
    }
    
    System::Globalization::CultureInfo* SimpleCollator::GetNeutralCulture(System::Globalization::CultureInfo* info) {
        System::Globalization::CultureInfo *ret = info;
        while(((ret->get_Parent_87d5fb2f5c680cba() != nullptr) && (ret->get_Parent_87d5fb2f5c680cba()->get_LCID_f4b9bc9d0bf0db86() != 127))) ret = ret->get_Parent_87d5fb2f5c680cba();
        return ret;
    }
    
    unsigned char SimpleCollator::Category(int32_t cp) {
        if(((cp < 12288) || (this->cjkCatTable ==  nullptr))) 
        {
            return MSCompatUnicodeTable::Category(cp);
        }
        int32_t idx = this->cjkIndexer->ToIndex(cp);
        return (idx < 0) ? MSCompatUnicodeTable::Category(cp) : (*(this->cjkCatTable + idx));
    }
    
    unsigned char SimpleCollator::Level1(int32_t cp) {
        if(((cp < 12288) || (this->cjkLv1Table ==  nullptr))) 
        {
            return MSCompatUnicodeTable::Level1(cp);
        }
        int32_t idx = this->cjkIndexer->ToIndex(cp);
        return (idx < 0) ? MSCompatUnicodeTable::Level1(cp) : (*(this->cjkLv1Table + idx));
    }
    
    unsigned char SimpleCollator::Level2(int32_t cp, ExtenderType ext) {
        if(((int32_t)(ext) ==  4)) 
        {
            return 5;
        }
         else 
        {
            if(((int32_t)(ext) ==  3)) 
            {
                return 0;
            }
        }
        if(((cp < 12288) || (this->cjkLv2Table ==  nullptr))) 
        {
            return MSCompatUnicodeTable::Level2(cp);
        }
        int32_t idx = this->cjkLv2Indexer->ToIndex(cp);
        unsigned char ret = (idx < 0) ? 0 : (*(this->cjkLv2Table + idx));
        if(((int32_t)(ret) != 0)) 
        {
            return ret;
        }
        ret = MSCompatUnicodeTable::Level2(cp);
        if((this->level2Maps->get_Length() ==  0)) 
        {
            return ret;
        }
        for(int32_t i = 0; (i < this->level2Maps->get_Length()); i++){
            if(((int32_t)(this->level2Maps->at(i)->Source) ==  (int32_t)(ret))) 
            {
                return this->level2Maps->at(i)->Replace;
            }
             else 
            {
                if(((int32_t)(this->level2Maps->at(i)->Source) > (int32_t)(ret))) 
                {
                    break;
                }
            }
        }
        return ret;
    }
    
    bool SimpleCollator::IsHalfKana(int32_t cp, System::Globalization::CompareOptions opt) {
        return (((int32_t)(((int32_t)(opt) & 16)) != 0) || MSCompatUnicodeTable::IsHalfWidthKana((char16_t)cp));
    }
    
    Contraction* SimpleCollator::GetContraction(System::String* s, int32_t start, int32_t end) {
        Contraction *c = GetContraction2(s, start, end, this->contractions);
        if(((c != nullptr) || (this->lcid ==  127))) 
        {
            return c;
        }
        return GetContraction2(s, start, end, invariant->contractions);
    }
    
    Contraction* SimpleCollator::GetContraction2(System::String* s, int32_t start, int32_t end, cli::array<Contraction*>* clist) {
        for(int32_t i = 0; (i < clist->get_Length()); i++){
            Contraction *ct = clist->at(i);
            int32_t diff = ((int32_t)(ct->Source->at(0)) - (int32_t)(s->get_Chars(start)));
            if((diff > 0)) 
            {
                return nullptr;
            }
             else 
            {
                if((diff < 0)) 
                {
                    continue;
                }
            }
            cli::array<char16_t> *chars = ct->Source;
            if(((end - start) < chars->get_Length())) 
            {
                continue;
            }
            bool match = true;
            for(int32_t n = 0; (n < chars->get_Length()); n++) {
                if(((int32_t)(s->get_Chars((start + n))) != (int32_t)(chars->at(n)))) 
                {
                    match = false;
                    break;
                }
            }
            if(match) 
            {
                return ct;
            }
        }
        return nullptr;
    }
    
    Contraction* SimpleCollator::GetTailContraction(System::String* s, int32_t start, int32_t end) {
        Contraction *c = GetTailContraction2(s, start, end, this->contractions);
        if(((c != nullptr) || (this->lcid ==  127))) 
        {
            return c;
        }
        return GetTailContraction2(s, start, end, invariant->contractions);
    }
    
    Contraction* SimpleCollator::GetTailContraction2(System::String* s, int32_t start, int32_t end, cli::array<Contraction*>* clist) {
        if(((((start ==  end) || (end < -1)) || (start >= s->get_Length())) || (s->get_Length() <= (end + 1)))) 
        {
            throw cli::gcnew<System::SystemException>(System::String::Format4(_T("MONO internal error. Failed to get TailContraction. start = {0} end = {1} string = \'{2}\'"), cli::box(start), cli::box(end), s));
        }
        for(int32_t i = 0; (i < clist->get_Length()); i++){
            Contraction *ct = clist->at(i);
            cli::array<char16_t> *chars = ct->Source;
            if((chars->get_Length() > (start - end))) 
            {
                continue;
            }
            if(((int32_t)(chars->at((chars->get_Length() - 1))) != (int32_t)(s->get_Chars(start)))) 
            {
                continue;
            }
            bool match = true;
            for(int32_t n = 0, spos = ((start - chars->get_Length()) + 1); (n < chars->get_Length()); n++, spos++){
                if(((int32_t)(s->get_Chars(spos)) != (int32_t)(chars->at(n)))) 
                {
                    match = false;
                    break;
                }
            }
            if(match) 
            {
                return ct;
            }
        }
        return nullptr;
    }
    
    Contraction* SimpleCollator::GetContraction3(char16_t c) {
        Contraction *ct = GetContraction4(c, this->contractions);
        if(((ct != nullptr) || (this->lcid ==  127))) 
        {
            return ct;
        }
        return GetContraction4(c, invariant->contractions);
    }
    
    Contraction* SimpleCollator::GetContraction4(char16_t c, cli::array<Contraction*>* clist) {
        for(int32_t i = 0; (i < clist->get_Length()); i++){
            Contraction *ct = clist->at(i);
            if(((int32_t)(ct->Source->at(0)) > (int32_t)(c))) 
            {
                return nullptr;
            }
            if((((int32_t)(ct->Source->at(0)) ==  (int32_t)(c)) && (ct->Source->get_Length() ==  1))) 
            {
                return ct;
            }
        }
        return nullptr;
    }
    
    int32_t SimpleCollator::FilterOptions(int32_t i, System::Globalization::CompareOptions opt) {
        if(((int32_t)(((int32_t)(opt) & 16)) != 0)) 
        {
            int32_t x = MSCompatUnicodeTable::ToWidthCompat(i);
            if((x != 0)) 
            {
                i = x;
            }
        }
        if(((int32_t)(((int32_t)(opt) & 268435456)) != 0)) 
        {
            i = (int32_t)(this->textInfo->ToLower_6b32dfb00a24a852((char16_t)i));
        }
        if(((int32_t)(((int32_t)(opt) & 1)) != 0)) 
        {
            i = (int32_t)(this->textInfo->ToLower_6b32dfb00a24a852((char16_t)i));
        }
        if(((int32_t)(((int32_t)(opt) & 8)) != 0)) 
        {
            i = MSCompatUnicodeTable::ToKanaTypeInsensitive(i);
        }
        return i;
    }
    
    ExtenderType SimpleCollator::GetExtenderType(int32_t i) {
        if((i ==  8213)) 
        {
            return (this->lcid ==  16) ? ExtenderType::Conditional : ExtenderType::None;
        }
        if(((i < 12293) || (i > 65392))) 
        {
            return ExtenderType::None;
        }
        if((i >= 65148)) 
        {
            switch(i) {
                case 65148: case 65149: case_233: {
                    return ExtenderType::Simple;
                }
                case 65392: case_234: {
                    return ExtenderType::Conditional;
                }
                case 65438: case 65439: case_235: {
                    return ExtenderType::Voiced;
                }
            }
        }
        if((i > 12542)) 
        {
            return ExtenderType::None;
        }
        switch(i) {
            case 12293: case_236: {
                return ExtenderType::Buggy;
            }
            case 12337: case 12338: case 12445: case 12541: case_237: {
                return ExtenderType::Simple;
            }
            case 12446: case 12542: case_238: {
                return ExtenderType::Voiced;
            }
            case 12540: case_239: {
                return ExtenderType::Conditional;
            }
            default: case_240: {
                return ExtenderType::None;
            }
        }
    }
    
    unsigned char SimpleCollator::ToDashTypeValue(ExtenderType ext, System::Globalization::CompareOptions opt) {
        if(((int32_t)(((int32_t)(opt) & 2)) != 0)) 
        {
            return 3;
        }
        switch(ext) {
            case ExtenderType::None: case_241: {
                return 3;
            }
            case ExtenderType::Conditional: case_242: {
                return 5;
            }
            default: case_243: {
                return 4;
            }
        }
    }
    
    int32_t SimpleCollator::FilterExtender(int32_t i, ExtenderType ext, System::Globalization::CompareOptions opt) {
        if((((int32_t)(ext) ==  3) && MSCompatUnicodeTable::HasSpecialWeight((char16_t)i))) 
        {
            bool half = IsHalfKana((int32_t)((char16_t)i), opt);
            bool katakana = !(MSCompatUnicodeTable::IsHiragana((char16_t)i));
            switch(((int32_t)(Level1(i)) & 7)) {
                case 2: case_244: {
                    return half ? 65393 : katakana ? 12450 : 12354;
                }
                case 3: case_245: {
                    return half ? 65394 : katakana ? 12452 : 12356;
                }
                case 4: case_246: {
                    return half ? 65395 : katakana ? 12454 : 12358;
                }
                case 5: case_247: {
                    return half ? 65396 : katakana ? 12456 : 12360;
                }
                case 6: case_248: {
                    return half ? 65397 : katakana ? 12458 : 12362;
                }
            }
        }
        return i;
    }
    
    bool SimpleCollator::IsIgnorable(int32_t i, System::Globalization::CompareOptions opt) {
        return MSCompatUnicodeTable::IsIgnorable2(i, (unsigned char)((1 + ((int32_t)(((int32_t)(opt) & 4)) != 0) ? 2 : 0) + ((int32_t)(((int32_t)(opt) & 2)) != 0) ? 4 : 0));
    }
    
    bool SimpleCollator::IsSafe(int32_t i) {
        return ((i / 8) >= this->unsafeFlags->get_Length()) ? true : (((int32_t)(this->unsafeFlags->at((i / 8))) & (1 << ((i % 8) & 31))) ==  0);
    }
    
    System::Globalization::SortKey* SimpleCollator::GetSortKey(System::String* s) {
        return GetSortKey2(s, System::Globalization::CompareOptions::None);
    }
    
    System::Globalization::SortKey* SimpleCollator::GetSortKey2(System::String* s, System::Globalization::CompareOptions options) {
        return GetSortKey3(s, 0, s->get_Length(), options);
    }
    
    System::Globalization::SortKey* SimpleCollator::GetSortKey3(System::String* s, int32_t start, int32_t length, System::Globalization::CompareOptions options) {
        SortKeyBuffer *buf = cli::gcnew<SortKeyBuffer>(this->lcid);
        buf->Initialize(options, this->lcid, s, this->frenchSort);
        int32_t end = (start + length);
        GetSortKey4(s, start, end, buf, options);
        return buf->GetResultAndReset();
    }
    
    void SimpleCollator::GetSortKey4(System::String* s, int32_t start, int32_t end, SortKeyBuffer* buf, System::Globalization::CompareOptions opt) {
        unsigned char prevbuf[4];
        ClearBuffer(prevbuf, 4);
        Context ctx = cli::ctor<Context>(opt, nullptr, nullptr, nullptr, nullptr, prevbuf, false);
        for(int32_t n = start; (n < end); n++){
            int32_t i = (int32_t)(s->get_Chars(n));
            ExtenderType ext = GetExtenderType(i);
            if(((int32_t)(ext) != 0)) 
            {
                i = FilterExtender(ctx->PrevCode, ext, opt);
                if((i >= 0)) 
                {
                    FillSortKeyRaw(i, ext, buf, opt);
                }
                 else 
                {
                    if((ctx->PrevSortKey != nullptr)) 
                    {
                        unsigned char *b = ctx->PrevSortKey;
                        buf->AppendNormal((*(b + 0)), (*(b + 1)), ((int32_t)((*(b + 2))) != 1) ? (*(b + 2)) : Level2(i, ext), ((int32_t)((*(b + 3))) != 1) ? (*(b + 3)) : MSCompatUnicodeTable::Level3(i));
                    }
                }
                continue;
            }
            if(IsIgnorable(i, opt)) 
            {
                continue;
            }
            i = FilterOptions(i, opt);
            Contraction *ct = GetContraction(s, n, end);
            if((ct != nullptr)) 
            {
                if((ct->Replacement != nullptr)) 
                {
                    GetSortKey4(ct->Replacement, 0, ct->Replacement->get_Length(), buf, opt);
                }
                 else 
                {
                    unsigned char *b = ctx->PrevSortKey;
                    for(int32_t bi = 0; (bi < ct->SortKey2->get_Length()); bi++) {
                        (*(b + bi)) = ct->SortKey2->at(bi);
                    }
                    buf->AppendNormal((*(b + 0)), (*(b + 1)), ((int32_t)((*(b + 2))) != 1) ? (*(b + 2)) : Level2(i, ext), ((int32_t)((*(b + 3))) != 1) ? (*(b + 3)) : MSCompatUnicodeTable::Level3(i));
                    ctx->PrevCode = -1;
                }
                (n = n + (ct->Source->get_Length() - 1));
            }
             else 
            {
                if(!(MSCompatUnicodeTable::IsIgnorableNonSpacing(i))) 
                {
                    ctx->PrevCode = i;
                }
                FillSortKeyRaw(i, ExtenderType::None, buf, opt);
            }
        }
    }
    
    void SimpleCollator::FillSortKeyRaw(int32_t i, ExtenderType ext, SortKeyBuffer* buf, System::Globalization::CompareOptions opt) {
        if(((13312 <= i) && (i <= 19893))) 
        {
            int32_t diff = (i - 13312);
            buf->AppendCJKExtension((unsigned char)(16 + (diff / 254)), (unsigned char)((diff % 254) + 2));
            return;
        }
        System::Globalization::UnicodeCategory uc = System::Char::GetUnicodeCategory((char16_t)i);
        switch(uc) {
            case System::Globalization::UnicodeCategory::PrivateUse: case_249: {
                int32_t diff = (i - 57344);
                buf->AppendNormal((unsigned char)(229 + (diff / 254)), (unsigned char)((diff % 254) + 2), 0, 0);
                return;
            }
            case System::Globalization::UnicodeCategory::Surrogate: case_250: {
                FillSurrogateSortKeyRaw(i, buf);
                return;
            }
        }
        unsigned char level2 = Level2(i, ext);
        if(MSCompatUnicodeTable::HasSpecialWeight((char16_t)i)) 
        {
            unsigned char level1 = Level1(i);
            buf->AppendKana(Category(i), level1, level2, MSCompatUnicodeTable::Level3(i), MSCompatUnicodeTable::IsJapaneseSmallLetter((char16_t)i), ToDashTypeValue(ext, opt), !(MSCompatUnicodeTable::IsHiragana((char16_t)i)), IsHalfKana((int32_t)((char16_t)i), opt));
            if((((int32_t)(((int32_t)(opt) & 2)) ==  0) && ((int32_t)(ext) ==  2))) 
            {
                buf->AppendNormal(1, 1, 1, 0);
            }
        }
         else 
        {
            buf->AppendNormal(Category(i), Level1(i), level2, MSCompatUnicodeTable::Level3(i));
        }
    }
    
    void SimpleCollator::FillSurrogateSortKeyRaw(int32_t i, SortKeyBuffer* buf) {
        int32_t diffbase = 0;
        int32_t segment = 0;
        unsigned char lower = 0;
        if((i < 55360)) 
        {
            diffbase = 55296;
            segment = 65;
            lower = (unsigned char)(i ==  55296) ? 62 : 63;
        }
         else 
        {
            if(((55360 <= i) && (i < 55424))) 
            {
                diffbase = 55360;
                segment = 242;
                lower = 62;
            }
             else 
            {
                if(((56192 <= i) && (i < 56320))) 
                {
                    diffbase = 56128;
                    segment = 254;
                    lower = 62;
                }
                 else 
                {
                    diffbase = 56074;
                    segment = 65;
                    lower = 63;
                }
            }
        }
        int32_t diff = (i - diffbase);
        buf->AppendNormal((unsigned char)(segment + (diff / 254)), (unsigned char)((diff % 254) + 2), lower, lower);
    }
    
    int32_t SimpleCollator::Compare(System::String* s1, System::String* s2) {
        return Compare2(s1, s2, System::Globalization::CompareOptions::None);
    }
    
    int32_t SimpleCollator::Compare2(System::String* s1, System::String* s2, System::Globalization::CompareOptions options) {
        return Compare3(s1, 0, s1->get_Length(), s2, 0, s2->get_Length(), options);
    }
    
    int32_t SimpleCollator::CompareOrdinal(System::String* s1, int32_t idx1, int32_t len1, System::String* s2, int32_t idx2, int32_t len2) {
        int32_t min = (len1 < len2) ? len1 : len2;
        int32_t end1 = (idx1 + min);
        int32_t end2 = (idx2 + min);
        if(((((idx1 < 0) || (idx2 < 0)) || (end1 > s1->get_Length())) || (end2 > s2->get_Length()))) 
        {
            throw cli::gcnew<System::SystemException>(System::String::Format5(_T("CompareInfo Internal Error: Should not happen. {0} {1} {2} {3} {4} {5}"), (new cli::array<System::Object*>({cli::box(idx1), cli::box(idx2), cli::box(len1), cli::box(len2), cli::box(s1->get_Length()), cli::box(s2->get_Length())}))));
        }
        for(int32_t i1 = idx1, i2 = idx2; ((i1 < end1) && (i2 < end2)); i1++, i2++) {
            if(((int32_t)(s1->get_Chars(i1)) != (int32_t)(s2->get_Chars(i2)))) 
            {
                return ((int32_t)(s1->get_Chars(i1)) - (int32_t)(s2->get_Chars(i2)));
            }
        }
        return (len1 ==  len2) ? 0 : (len1 ==  min) ? -1 : 1;
    }
    
    int32_t SimpleCollator::CompareQuick(System::String* s1, int32_t idx1, int32_t len1, System::String* s2, int32_t idx2, int32_t len2, bool sourceConsumed, bool targetConsumed, bool immediateBreakup) {
        sourceConsumed = false;
        targetConsumed = false;
        int32_t min = (len1 < len2) ? len1 : len2;
        int32_t end1 = (idx1 + min);
        int32_t end2 = (idx2 + min);
        if(((((idx1 < 0) || (idx2 < 0)) || (end1 > s1->get_Length())) || (end2 > s2->get_Length()))) 
        {
            throw cli::gcnew<System::SystemException>(System::String::Format5(_T("CompareInfo Internal Error: Should not happen. {0} {1} {2} {3} {4} {5}"), (new cli::array<System::Object*>({cli::box(idx1), cli::box(idx2), cli::box(len1), cli::box(len2), cli::box(s1->get_Length()), cli::box(s2->get_Length())}))));
        }
        for(int32_t i1 = idx1, i2 = idx2; ((i1 < end1) && (i2 < end2)); i1++, i2++) {
            if(((int32_t)(s1->get_Chars(i1)) != (int32_t)(s2->get_Chars(i2)))) 
            {
                if(immediateBreakup) 
                {
                    return -1;
                }
                int32_t ret = ((int32_t)(Category((int32_t)(s1->get_Chars(i1)))) - (int32_t)(Category((int32_t)(s2->get_Chars(i2)))));
                if((ret ==  0)) 
                {
                    ret = ((int32_t)(Level1((int32_t)(s1->get_Chars(i1)))) - (int32_t)(Level1((int32_t)(s2->get_Chars(i2)))));
                }
                if((ret ==  0)) 
                {
                    ret = ((int32_t)(MSCompatUnicodeTable::Level3((int32_t)(s1->get_Chars(i1)))) - (int32_t)(MSCompatUnicodeTable::Level3((int32_t)(s2->get_Chars(i2)))));
                }
                if((ret ==  0)) 
                {
                    throw cli::gcnew<System::SystemException>(System::String::Format5(_T("CompareInfo Internal Error: Should not happen. \'{0}\' {2} {3} \'{1}\' {4} {5}"), (new cli::array<System::Object*>({s1, s2, cli::box(idx1), cli::box(end1), cli::box(idx2), cli::box(end2)}))));
                }
                return ret;
            }
        }
        sourceConsumed = (len1 <= len2);
        targetConsumed = (len1 >= len2);
        return (len1 ==  len2) ? 0 : (len1 ==  min) ? -1 : 1;
    }
    
    int32_t SimpleCollator::CompareOrdinalIgnoreCase(System::String* s1, int32_t idx1, int32_t len1, System::String* s2, int32_t idx2, int32_t len2) {
        int32_t min = (len1 < len2) ? len1 : len2;
        int32_t end1 = (idx1 + min);
        int32_t end2 = (idx2 + min);
        if(((((idx1 < 0) || (idx2 < 0)) || (end1 > s1->get_Length())) || (end2 > s2->get_Length()))) 
        {
            throw cli::gcnew<System::SystemException>(System::String::Format5(_T("CompareInfo Internal Error: Should not happen. {0} {1} {2} {3} {4} {5}"), (new cli::array<System::Object*>({cli::box(idx1), cli::box(idx2), cli::box(len1), cli::box(len2), cli::box(s1->get_Length()), cli::box(s2->get_Length())}))));
        }
        System::Globalization::TextInfo *ti = invariant->textInfo;
        for(int32_t i1 = idx1, i2 = idx2; ((i1 < end1) && (i2 < end2)); i1++, i2++) {
            if(((int32_t)(ti->ToLower_6b32dfb00a24a852(s1->get_Chars(i1))) != (int32_t)(ti->ToLower_6b32dfb00a24a852(s2->get_Chars(i2))))) 
            {
                return ((int32_t)(ti->ToLower_6b32dfb00a24a852(s1->get_Chars(i1))) - (int32_t)(ti->ToLower_6b32dfb00a24a852(s2->get_Chars(i2))));
            }
        }
        return (len1 ==  len2) ? 0 : (len1 ==  min) ? -1 : 1;
    }
    
    int32_t SimpleCollator::Compare3(System::String* s1, int32_t idx1, int32_t len1, System::String* s2, int32_t idx2, int32_t len2, System::Globalization::CompareOptions options) {
        if((((idx1 ==  idx2) && (len1 ==  len2)) && System::Object::ReferenceEquals(s1, s2))) 
        {
            return 0;
        }
        if(((int32_t)(options) ==  1073741824)) 
        {
            return CompareOrdinal(s1, idx1, len1, s2, idx2, len2);
        }
        if(((int32_t)(options) ==  268435456)) 
        {
            return CompareOrdinalIgnoreCase(s1, idx1, len1, s2, idx2, len2);
        }
        unsigned char sk1[4];
        unsigned char sk2[4];
        ClearBuffer(sk1, 4);
        ClearBuffer(sk2, 4);
        Context ctx = cli::ctor<Context>(options, nullptr, nullptr, sk1, sk2, nullptr, QuickCheckPossible(s1, idx1, (idx1 + len1), s2, idx2, (idx2 + len2)));
        bool dummy, dummy2;
        int32_t ret = CompareInternal(s1, idx1, len1, s2, idx2, len2, dummy, dummy2, true, false, ctx);
        return (ret ==  0) ? 0 : (ret < 0) ? -1 : 1;
    }
    
    void SimpleCollator::ClearBuffer(unsigned char* buffer, int32_t size) {
        for(int32_t i = 0; (i < size); i++) {
            (*(buffer + i)) = 0;
        }
    }
    
    bool SimpleCollator::QuickCheckPossible(System::String* s1, int32_t idx1, int32_t end1, System::String* s2, int32_t idx2, int32_t end2) {
        return false;
    }
    
    int32_t SimpleCollator::CompareInternal(System::String* s1, int32_t idx1, int32_t len1, System::String* s2, int32_t idx2, int32_t len2, bool targetConsumed, bool sourceConsumed, bool skipHeadingExtenders, bool immediateBreakup, Context ctx) {
        System::Globalization::CompareOptions opt = ctx->Option;
        int32_t start1 = idx1;
        int32_t start2 = idx2;
        int32_t end1 = (idx1 + len1);
        int32_t end2 = (idx2 + len2);
        targetConsumed = false;
        sourceConsumed = false;
        PreviousInfo prev2 = cli::ctor<PreviousInfo>(false);
        if((((int32_t)(opt) ==  0) && ctx->QuickCheckPossible)) 
        {
            return CompareQuick(s1, idx1, len1, s2, idx2, len2, sourceConsumed, targetConsumed, immediateBreakup);
        }
        int32_t finalResult = 0;
        int32_t currentLevel = 5;
        int32_t lv5At1 = -1;
        int32_t lv5At2 = -1;
        int32_t lv5Value1 = 0;
        int32_t lv5Value2 = 0;
        if(skipHeadingExtenders) 
        {
            for(; (idx1 < end1); idx1++) {
                if(((int32_t)(GetExtenderType((int32_t)(s1->get_Chars(idx1)))) ==  0)) 
                {
                    break;
                }
            }
            for(; (idx2 < end2); idx2++) {
                if(((int32_t)(GetExtenderType((int32_t)(s2->get_Chars(idx2)))) ==  0)) 
                {
                    break;
                }
            }
        }
        ExtenderType ext1 = ExtenderType::None;
        ExtenderType ext2 = ExtenderType::None;
        int32_t quickCheckPos1 = idx1;
        int32_t quickCheckPos2 = idx2;
        bool stringSort = ((int32_t)(((int32_t)(opt) & 536870912)) != 0);
        bool ignoreNonSpace = ((int32_t)(((int32_t)(opt) & 2)) != 0);
        Escape escape1 = cli::ctor<Escape>();
        Escape escape2 = cli::ctor<Escape>();
        while(true) {
            for(; (idx1 < end1); idx1++) {
                if(!(IsIgnorable((int32_t)(s1->get_Chars(idx1)), opt))) 
                {
                    break;
                }
            }
            for(; (idx2 < end2); idx2++) {
                if(!(IsIgnorable((int32_t)(s2->get_Chars(idx2)), opt))) 
                {
                    break;
                }
            }
            if((idx1 >= end1)) 
            {
                if((escape1->Source ==  nullptr)) 
                {
                    break;
                }
                s1 = escape1->Source;
                start1 = escape1->Start;
                idx1 = escape1->Index;
                end1 = escape1->End;
                quickCheckPos1 = escape1->Optional;
                escape1->Source = nullptr;
                continue;
            }
            if((idx2 >= end2)) 
            {
                if((escape2->Source ==  nullptr)) 
                {
                    break;
                }
                s2 = escape2->Source;
                start2 = escape2->Start;
                idx2 = escape2->Index;
                end2 = escape2->End;
                quickCheckPos2 = escape2->Optional;
                escape2->Source = nullptr;
                continue;
            }
            if(((quickCheckPos1 < idx1) && (quickCheckPos2 < idx2))) 
            {
                while((((idx1 < end1) && (idx2 < end2)) && ((int32_t)(s1->get_Chars(idx1)) ==  (int32_t)(s2->get_Chars(idx2))))) {
                    idx1++;
                    idx2++;
                }
                if(((idx1 ==  end1) || (idx2 ==  end2))) 
                {
                    continue;
                }
                int32_t backwardEnd1 = quickCheckPos1;
                int32_t backwardEnd2 = quickCheckPos2;
                quickCheckPos1 = idx1;
                quickCheckPos2 = idx2;
                idx1--;
                idx2--;
                for(; (idx1 > backwardEnd1); idx1--) {
                    if(((int32_t)(Category((int32_t)(s1->get_Chars(idx1)))) != 1)) 
                    {
                        break;
                    }
                }
                for(; (idx2 > backwardEnd2); idx2--) {
                    if(((int32_t)(Category((int32_t)(s2->get_Chars(idx2)))) != 1)) 
                    {
                        break;
                    }
                }
                for(; (idx1 > backwardEnd1); idx1--) {
                    if(IsSafe((int32_t)(s1->get_Chars(idx1)))) 
                    {
                        break;
                    }
                }
                for(; (idx2 > backwardEnd2); idx2--) {
                    if(IsSafe((int32_t)(s2->get_Chars(idx2)))) 
                    {
                        break;
                    }
                }
            }
            int32_t cur1 = idx1;
            int32_t cur2 = idx2;
            unsigned char *sk1 = nullptr;
            unsigned char *sk2 = nullptr;
            int32_t i1 = FilterOptions((int32_t)(s1->get_Chars(idx1)), opt);
            int32_t i2 = FilterOptions((int32_t)(s2->get_Chars(idx2)), opt);
            bool special1 = false;
            bool special2 = false;
            ext1 = GetExtenderType(i1);
            if(((int32_t)(ext1) != 0)) 
            {
                if((ctx->PrevCode < 0)) 
                {
                    if((ctx->PrevSortKey ==  nullptr)) 
                    {
                        idx1++;
                        continue;
                    }
                    sk1 = ctx->PrevSortKey;
                }
                 else 
                {
                    i1 = FilterExtender(ctx->PrevCode, ext1, opt);
                }
            }
            ext2 = GetExtenderType(i2);
            if(((int32_t)(ext2) != 0)) 
            {
                if((prev2->Code < 0)) 
                {
                    if((prev2->SortKey2 ==  nullptr)) 
                    {
                        idx2++;
                        continue;
                    }
                    sk2 = prev2->SortKey2;
                }
                 else 
                {
                    i2 = FilterExtender(prev2->Code, ext2, opt);
                }
            }
            unsigned char cat1 = Category(i1);
            unsigned char cat2 = Category(i2);
            if(((int32_t)(cat1) ==  6)) 
            {
                if((!(stringSort) && (currentLevel ==  5))) 
                {
                    lv5At1 = (escape1->Source != nullptr) ? (escape1->Index - escape1->Start) : (cur1 - start1);
                    lv5Value1 = ((int32_t)(Level1(i1)) << ((8 + (int32_t)(MSCompatUnicodeTable::Level3(i1))) & 31));
                }
                ctx->PrevCode = i1;
                idx1++;
            }
            if(((int32_t)(cat2) ==  6)) 
            {
                if((!(stringSort) && (currentLevel ==  5))) 
                {
                    lv5At2 = (escape2->Source != nullptr) ? (escape2->Index - escape2->Start) : (cur2 - start2);
                    lv5Value2 = ((int32_t)(Level1(i2)) << ((8 + (int32_t)(MSCompatUnicodeTable::Level3(i2))) & 31));
                }
                prev2->Code = i2;
                idx2++;
            }
            if((((int32_t)(cat1) ==  6) || ((int32_t)(cat2) ==  6))) 
            {
                if((currentLevel ==  5)) 
                {
                    if((lv5Value1 ==  lv5Value2)) 
                    {
                        lv5At1 = lv5At2 = -1;
                        lv5Value1 = lv5Value2 = 0;
                    }
                     else 
                    {
                        currentLevel = 4;
                    }
                }
                continue;
            }
            Contraction *ct1 = nullptr;
            if(((int32_t)(ext1) ==  0)) 
            {
                ct1 = GetContraction(s1, idx1, end1);
            }
            int32_t offset1 = 1;
            if((sk1 != nullptr)) 
            {
                offset1 = 1;
            }
             else 
            {
                if((ct1 != nullptr)) 
                {
                    offset1 = ct1->Source->get_Length();
                    if((ct1->SortKey2 != nullptr)) 
                    {
                        sk1 = ctx->Buffer1;
                        for(int32_t i = 0; (i < ct1->SortKey2->get_Length()); i++) {
                            (*(sk1 + i)) = ct1->SortKey2->at(i);
                        }
                        ctx->PrevCode = -1;
                        ctx->PrevSortKey = sk1;
                    }
                     else 
                    {
                        if((escape1->Source ==  nullptr)) 
                        {
                            escape1->Source = s1;
                            escape1->Start = start1;
                            escape1->Index = (cur1 + ct1->Source->get_Length());
                            escape1->End = end1;
                            escape1->Optional = quickCheckPos1;
                            s1 = ct1->Replacement;
                            idx1 = 0;
                            start1 = 0;
                            end1 = s1->get_Length();
                            quickCheckPos1 = 0;
                            continue;
                        }
                    }
                }
                 else 
                {
                    sk1 = ctx->Buffer1;
                    (*(sk1 + 0)) = cat1;
                    (*(sk1 + 1)) = Level1(i1);
                    if((!(ignoreNonSpace) && (currentLevel > 1))) 
                    {
                        (*(sk1 + 2)) = Level2(i1, ext1);
                    }
                    if((currentLevel > 2)) 
                    {
                        (*(sk1 + 3)) = MSCompatUnicodeTable::Level3(i1);
                    }
                    if((currentLevel > 3)) 
                    {
                        special1 = MSCompatUnicodeTable::HasSpecialWeight((char16_t)i1);
                    }
                    if(((int32_t)(cat1) > 1)) 
                    {
                        ctx->PrevCode = i1;
                    }
                }
            }
            Contraction *ct2 = nullptr;
            if(((int32_t)(ext2) ==  0)) 
            {
                ct2 = GetContraction(s2, idx2, end2);
            }
            if((sk2 != nullptr)) 
            {
                idx2++;
            }
             else 
            {
                if((ct2 != nullptr)) 
                {
                    (idx2 = idx2 + ct2->Source->get_Length());
                    if((ct2->SortKey2 != nullptr)) 
                    {
                        sk2 = ctx->Buffer2;
                        for(int32_t i = 0; (i < ct2->SortKey2->get_Length()); i++) {
                            (*(sk2 + i)) = ct2->SortKey2->at(i);
                        }
                        prev2->Code = -1;
                        prev2->SortKey2 = sk2;
                    }
                     else 
                    {
                        if((escape2->Source ==  nullptr)) 
                        {
                            escape2->Source = s2;
                            escape2->Start = start2;
                            escape2->Index = (cur2 + ct2->Source->get_Length());
                            escape2->End = end2;
                            escape2->Optional = quickCheckPos2;
                            s2 = ct2->Replacement;
                            idx2 = 0;
                            start2 = 0;
                            end2 = s2->get_Length();
                            quickCheckPos2 = 0;
                            continue;
                        }
                    }
                }
                 else 
                {
                    sk2 = ctx->Buffer2;
                    (*(sk2 + 0)) = cat2;
                    (*(sk2 + 1)) = Level1(i2);
                    if((!(ignoreNonSpace) && (currentLevel > 1))) 
                    {
                        (*(sk2 + 2)) = Level2(i2, ext2);
                    }
                    if((currentLevel > 2)) 
                    {
                        (*(sk2 + 3)) = MSCompatUnicodeTable::Level3(i2);
                    }
                    if((currentLevel > 3)) 
                    {
                        special2 = MSCompatUnicodeTable::HasSpecialWeight((char16_t)i2);
                    }
                    if(((int32_t)(cat2) > 1)) 
                    {
                        prev2->Code = i2;
                    }
                    idx2++;
                }
            }
            (idx1 = idx1 + offset1);
            if(!(ignoreNonSpace)) 
            {
                while((idx1 < end1)) {
                    if(((int32_t)(Category((int32_t)(s1->get_Chars(idx1)))) != 1)) 
                    {
                        break;
                    }
                    if(((int32_t)((*(sk1 + 2))) ==  0)) 
                    {
                        (*(sk1 + 2)) = 2;
                    }
                    (*(sk1 + 2)) = (unsigned char)((int32_t)((*(sk1 + 2))) + (int32_t)(Level2((int32_t)(s1->get_Chars(idx1)), ExtenderType::None)));
                    idx1++;
                }
                while((idx2 < end2)) {
                    if(((int32_t)(Category((int32_t)(s2->get_Chars(idx2)))) != 1)) 
                    {
                        break;
                    }
                    if(((int32_t)((*(sk2 + 2))) ==  0)) 
                    {
                        (*(sk2 + 2)) = 2;
                    }
                    (*(sk2 + 2)) = (unsigned char)((int32_t)((*(sk2 + 2))) + (int32_t)(Level2((int32_t)(s2->get_Chars(idx2)), ExtenderType::None)));
                    idx2++;
                }
            }
            int32_t ret = ((int32_t)((*(sk1 + 0))) - (int32_t)((*(sk2 + 0))));
            ret = (ret != 0) ? ret : ((int32_t)((*(sk1 + 1))) - (int32_t)((*(sk2 + 1))));
            if((ret != 0)) 
            {
                return ret;
            }
            if((currentLevel ==  1)) 
            {
                continue;
            }
            if(!(ignoreNonSpace)) 
            {
                ret = ((int32_t)((*(sk1 + 2))) - (int32_t)((*(sk2 + 2))));
                if((ret != 0)) 
                {
                    finalResult = ret;
                    if(immediateBreakup) 
                    {
                        return -1;
                    }
                    currentLevel = this->frenchSort ? 2 : 1;
                    continue;
                }
            }
            if((currentLevel ==  2)) 
            {
                continue;
            }
            ret = ((int32_t)((*(sk1 + 3))) - (int32_t)((*(sk2 + 3))));
            if((ret != 0)) 
            {
                finalResult = ret;
                if(immediateBreakup) 
                {
                    return -1;
                }
                currentLevel = 2;
                continue;
            }
            if((currentLevel ==  3)) 
            {
                continue;
            }
            if((special1 != special2)) 
            {
                if(immediateBreakup) 
                {
                    return -1;
                }
                finalResult = special1 ? 1 : -1;
                currentLevel = 3;
                continue;
            }
            if(special1) 
            {
                ret = CompareFlagPair(!(MSCompatUnicodeTable::IsJapaneseSmallLetter((char16_t)i1)), !(MSCompatUnicodeTable::IsJapaneseSmallLetter((char16_t)i2)));
                ret = (ret != 0) ? ret : ((int32_t)(ToDashTypeValue(ext1, opt)) - (int32_t)(ToDashTypeValue(ext2, opt)));
                ret = (ret != 0) ? ret : CompareFlagPair(MSCompatUnicodeTable::IsHiragana((char16_t)i1), MSCompatUnicodeTable::IsHiragana((char16_t)i2));
                ret = (ret != 0) ? ret : CompareFlagPair(!(IsHalfKana((int32_t)((char16_t)i1), opt)), !(IsHalfKana((int32_t)((char16_t)i2), opt)));
                if((ret != 0)) 
                {
                    if(immediateBreakup) 
                    {
                        return -1;
                    }
                    finalResult = ret;
                    currentLevel = 3;
                    continue;
                }
            }
        }
        if(((!(ignoreNonSpace) && (finalResult != 0)) && (currentLevel > 2))) 
        {
            while(((idx1 < end1) && (idx2 < end2))) {
                if(!(MSCompatUnicodeTable::IsIgnorableNonSpacing((int32_t)(s1->get_Chars(idx1))))) 
                {
                    break;
                }
                if(!(MSCompatUnicodeTable::IsIgnorableNonSpacing((int32_t)(s2->get_Chars(idx2))))) 
                {
                    break;
                }
                finalResult = ((int32_t)(Level2(FilterOptions((int32_t)(s1->get_Chars(idx1)), opt), ext1)) - (int32_t)(Level2(FilterOptions((int32_t)(s2->get_Chars(idx2)), opt), ext2)));
                if((finalResult != 0)) 
                {
                    break;
                }
                idx1++;
                idx2++;
                ext1 = ExtenderType::None;
                ext2 = ExtenderType::None;
            }
        }
        if(((currentLevel ==  1) && (finalResult != 0))) 
        {
            while((idx1 < end1)) {
                if(MSCompatUnicodeTable::IsIgnorableNonSpacing((int32_t)(s1->get_Chars(idx1)))) 
                {
                    idx1++;
                }
                 else 
                {
                    break;
                }
            }
            while((idx2 < end2)) {
                if(MSCompatUnicodeTable::IsIgnorableNonSpacing((int32_t)(s2->get_Chars(idx2)))) 
                {
                    idx2++;
                }
                 else 
                {
                    break;
                }
            }
        }
        if((finalResult ==  0)) 
        {
            if(((lv5At1 < 0) && (lv5At2 >= 0))) 
            {
                finalResult = -1;
            }
             else 
            {
                if(((lv5At2 < 0) && (lv5At1 >= 0))) 
                {
                    finalResult = 1;
                }
                 else 
                {
                    finalResult = (lv5At1 - lv5At2);
                    if((finalResult ==  0)) 
                    {
                        finalResult = (lv5Value1 - lv5Value2);
                    }
                }
            }
        }
        if((finalResult ==  0)) 
        {
            if((idx2 ==  end2)) 
            {
                targetConsumed = true;
            }
            if((idx1 ==  end1)) 
            {
                sourceConsumed = true;
            }
        }
        return (idx1 != end1) ? 1 : (idx2 ==  end2) ? finalResult : -1;
    }
    
    int32_t SimpleCollator::CompareFlagPair(bool b1, bool b2) {
        return (b1 ==  b2) ? 0 : b1 ? 1 : -1;
    }
    
    bool SimpleCollator::IsPrefix(System::String* src, System::String* target, System::Globalization::CompareOptions opt) {
        return IsPrefix2(src, target, 0, src->get_Length(), opt);
    }
    
    bool SimpleCollator::IsPrefix2(System::String* s, System::String* target, int32_t start, int32_t length, System::Globalization::CompareOptions opt) {
        if((target->get_Length() ==  0)) 
        {
            return true;
        }
        unsigned char sk1[4];
        unsigned char sk2[4];
        ClearBuffer(sk1, 4);
        ClearBuffer(sk2, 4);
        Context ctx = cli::ctor<Context>(opt, nullptr, nullptr, sk1, sk2, nullptr, QuickCheckPossible(s, start, (start + length), target, 0, target->get_Length()));
        return IsPrefix3(s, target, start, length, true, ctx);
    }
    
    bool SimpleCollator::IsPrefix3(System::String* s, System::String* target, int32_t start, int32_t length, bool skipHeadingExtenders, Context ctx) {
        bool consumed, dummy;
        CompareInternal(s, start, length, target, 0, target->get_Length(), consumed, dummy, skipHeadingExtenders, true, ctx);
        return consumed;
    }
    
    bool SimpleCollator::IsSuffix(System::String* src, System::String* target, System::Globalization::CompareOptions opt) {
        return IsSuffix2(src, target, (src->get_Length() - 1), src->get_Length(), opt);
    }
    
    bool SimpleCollator::IsSuffix2(System::String* s, System::String* target, int32_t start, int32_t length, System::Globalization::CompareOptions opt) {
        if((target->get_Length() ==  0)) 
        {
            return true;
        }
        int32_t last = LastIndexOf2(s, target, start, length, opt);
        return ((last >= 0) && (Compare3(s, last, (s->get_Length() - last), target, 0, target->get_Length(), opt) ==  0));
    }
    
    int32_t SimpleCollator::IndexOf(System::String* s, System::String* target, System::Globalization::CompareOptions opt) {
        return IndexOf2(s, target, 0, s->get_Length(), opt);
    }
    
    int32_t SimpleCollator::QuickIndexOf(System::String* s, System::String* target, int32_t start, int32_t length, bool testWasUnable) {
        int32_t testedSourcePos = -1, testedTargetPos = -1;
        testWasUnable = true;
        if((target->get_Length() ==  0)) 
        {
            return 0;
        }
         else 
        {
            if((target->get_Length() > length)) 
            {
                return -1;
            }
        }
        testWasUnable = false;
        int32_t end = (((start + length) - target->get_Length()) + 1);
        for(int32_t i = start; (i < end); i++){
            bool no = false;
            for(int32_t j = 0; (j < target->get_Length()); j++){
                if((testedTargetPos < j)) 
                {
                    char16_t c = target->get_Chars(j);
                    if((((int32_t)(c) ==  0) || ((int32_t)(c) >= 128))) 
                    {
                        testWasUnable = true;
                        return -1;
                    }
                     else 
                    {
                        testedTargetPos = j;
                    }
                }
                if((testedSourcePos < (i + j))) 
                {
                    char16_t c = s->get_Chars((i + j));
                    if((((int32_t)(c) ==  0) || ((int32_t)(c) >= 128))) 
                    {
                        testWasUnable = true;
                        return -1;
                    }
                     else 
                    {
                        testedSourcePos = (i + j);
                    }
                }
                if(((int32_t)(s->get_Chars((i + j))) != (int32_t)(target->get_Chars(j)))) 
                {
                    no = true;
                    break;
                }
            }
            if(no) 
            {
                continue;
            }
            return i;
        }
        return -1;
    }
    
    int32_t SimpleCollator::IndexOf2(System::String* s, System::String* target, int32_t start, int32_t length, System::Globalization::CompareOptions opt) {
        if(((int32_t)(opt) ==  1073741824)) 
        {
            return IndexOfOrdinal(s, target, start, length);
        }
        if(((int32_t)(opt) ==  268435456)) 
        {
            return IndexOfOrdinalIgnoreCase(s, target, start, length);
        }
        if(((int32_t)(opt) ==  0)) 
        {
            bool testWasUnable;
            int32_t ret = QuickIndexOf(s, target, start, length, testWasUnable);
            if(!(testWasUnable)) 
            {
                return ret;
            }
        }
        unsigned char alwaysMatchFlags[16];
        unsigned char neverMatchFlags[16];
        unsigned char targetSortKey[4];
        unsigned char sk1[4];
        unsigned char sk2[4];
        ClearBuffer(alwaysMatchFlags, 16);
        ClearBuffer(neverMatchFlags, 16);
        ClearBuffer(targetSortKey, 4);
        ClearBuffer(sk1, 4);
        ClearBuffer(sk2, 4);
        Context ctx = cli::ctor<Context>(opt, alwaysMatchFlags, neverMatchFlags, sk1, sk2, nullptr, false);
        return IndexOf5(s, target, start, length, targetSortKey, ctx);
    }
    
    int32_t SimpleCollator::IndexOfOrdinal(System::String* s, System::String* target, int32_t start, int32_t length) {
        if((target->get_Length() ==  0)) 
        {
            return 0;
        }
         else 
        {
            if((target->get_Length() > length)) 
            {
                return -1;
            }
        }
        int32_t end = (((start + length) - target->get_Length()) + 1);
        for(int32_t i = start; (i < end); i++){
            bool no = false;
            for(int32_t j = 0; (j < target->get_Length()); j++){
                if(((int32_t)(s->get_Chars((i + j))) != (int32_t)(target->get_Chars(j)))) 
                {
                    no = true;
                    break;
                }
            }
            if(no) 
            {
                continue;
            }
            return i;
        }
        return -1;
    }
    
    int32_t SimpleCollator::IndexOfOrdinalIgnoreCase(System::String* s, System::String* target, int32_t start, int32_t length) {
        if((target->get_Length() ==  0)) 
        {
            return 0;
        }
         else 
        {
            if((target->get_Length() > length)) 
            {
                return -1;
            }
        }
        int32_t end = (((start + length) - target->get_Length()) + 1);
        for(int32_t i = start; (i < end); i++){
            bool no = false;
            for(int32_t j = 0; (j < target->get_Length()); j++){
                if(((int32_t)(this->textInfo->ToLower_6b32dfb00a24a852(s->get_Chars((i + j)))) != (int32_t)(this->textInfo->ToLower_6b32dfb00a24a852(target->get_Chars(j))))) 
                {
                    no = true;
                    break;
                }
            }
            if(no) 
            {
                continue;
            }
            return i;
        }
        return -1;
    }
    
    int32_t SimpleCollator::IndexOf3(System::String* s, char16_t target, System::Globalization::CompareOptions opt) {
        return IndexOf4(s, target, 0, s->get_Length(), opt);
    }
    
    int32_t SimpleCollator::IndexOf4(System::String* s, char16_t target, int32_t start, int32_t length, System::Globalization::CompareOptions opt) {
        if(((int32_t)(opt) ==  1073741824)) 
        {
            return IndexOfOrdinal2(s, target, start, length);
        }
        if(((int32_t)(opt) ==  268435456)) 
        {
            return IndexOfOrdinalIgnoreCase2(s, target, start, length);
        }
        unsigned char alwaysMatchFlags[16];
        unsigned char neverMatchFlags[16];
        unsigned char targetSortKey[4];
        unsigned char sk1[4];
        unsigned char sk2[4];
        ClearBuffer(alwaysMatchFlags, 16);
        ClearBuffer(neverMatchFlags, 16);
        ClearBuffer(targetSortKey, 4);
        ClearBuffer(sk1, 4);
        ClearBuffer(sk2, 4);
        Context ctx = cli::ctor<Context>(opt, alwaysMatchFlags, neverMatchFlags, sk1, sk2, nullptr, false);
        Contraction *ct = GetContraction3(target);
        if((ct != nullptr)) 
        {
            if((ct->Replacement != nullptr)) 
            {
                return IndexOf5(s, ct->Replacement, start, length, targetSortKey, ctx);
            }
             else 
            {
                for(int32_t i = 0; (i < ct->SortKey2->get_Length()); i++) {
                    (*(sk2 + i)) = ct->SortKey2->at(i);
                }
                return IndexOfSortKey(s, start, length, sk2, u'\x0', -1, true, ctx);
            }
        }
         else 
        {
            int32_t ti = FilterOptions((int32_t)(target), opt);
            (*(targetSortKey + 0)) = Category(ti);
            (*(targetSortKey + 1)) = Level1(ti);
            if(((int32_t)(((int32_t)(opt) & 2)) ==  0)) 
            {
                (*(targetSortKey + 2)) = Level2(ti, ExtenderType::None);
            }
            (*(targetSortKey + 3)) = MSCompatUnicodeTable::Level3(ti);
            return IndexOfSortKey(s, start, length, targetSortKey, target, ti, !(MSCompatUnicodeTable::HasSpecialWeight((char16_t)ti)), ctx);
        }
    }
    
    int32_t SimpleCollator::IndexOfOrdinal2(System::String* s, char16_t target, int32_t start, int32_t length) {
        int32_t end = (start + length);
        for(int32_t i = start; (i < end); i++) {
            if(((int32_t)(s->get_Chars(i)) ==  (int32_t)(target))) 
            {
                return i;
            }
        }
        return -1;
    }
    
    int32_t SimpleCollator::IndexOfOrdinalIgnoreCase2(System::String* s, char16_t target, int32_t start, int32_t length) {
        int32_t end = (start + length);
        target = this->textInfo->ToLower_6b32dfb00a24a852(target);
        for(int32_t i = start; (i < end); i++) {
            if(((int32_t)(this->textInfo->ToLower_6b32dfb00a24a852(s->get_Chars(i))) ==  (int32_t)(target))) 
            {
                return i;
            }
        }
        return -1;
    }
    
    int32_t SimpleCollator::IndexOfSortKey(System::String* s, int32_t start, int32_t length, unsigned char* sortkey, char16_t target, int32_t ti, bool noLv4, Context ctx) {
        int32_t end = (start + length);
        int32_t idx = start;
        while((idx < end)) {
            int32_t cur = idx;
            if(MatchesForward(s, idx, end, ti, sortkey, noLv4, ctx)) 
            {
                return cur;
            }
        }
        return -1;
    }
    
    int32_t SimpleCollator::IndexOf5(System::String* s, System::String* target, int32_t start, int32_t length, unsigned char* targetSortKey, Context ctx) {
        System::Globalization::CompareOptions opt = ctx->Option;
        int32_t tidx = 0;
        for(; (tidx < target->get_Length()); tidx++) {
            if(!(IsIgnorable((int32_t)(target->get_Chars(tidx)), opt))) 
            {
                break;
            }
        }
        if((tidx ==  target->get_Length())) 
        {
            return (IndexOfOrdinal2(target, u'\x0', 0, target->get_Length()) >= 0) ? IndexOfOrdinal(s, target, start, length) : start;
        }
        Contraction *ct = GetContraction(target, tidx, (target->get_Length() - tidx));
        System::String *replace = (ct != nullptr) ? ct->Replacement : nullptr;
        unsigned char *sk = (replace ==  nullptr) ? targetSortKey : nullptr;
        bool noLv4 = true;
        char16_t tc = u'\x0';
        int32_t ti = -1;
        if(((ct != nullptr) && (sk != nullptr))) 
        {
            for(int32_t i = 0; (i < ct->SortKey2->get_Length()); i++) {
                (*(sk + i)) = ct->SortKey2->at(i);
            }
        }
         else 
        {
            if((sk != nullptr)) 
            {
                tc = target->get_Chars(tidx);
                ti = FilterOptions((int32_t)(target->get_Chars(tidx)), opt);
                (*(sk + 0)) = Category(ti);
                (*(sk + 1)) = Level1(ti);
                if(((int32_t)(((int32_t)(opt) & 2)) ==  0)) 
                {
                    (*(sk + 2)) = Level2(ti, ExtenderType::None);
                }
                (*(sk + 3)) = MSCompatUnicodeTable::Level3(ti);
                noLv4 = !(MSCompatUnicodeTable::HasSpecialWeight((char16_t)ti));
            }
        }
        if((sk != nullptr)) 
        {
            for(tidx++; (tidx < target->get_Length()); tidx++){
                if(((int32_t)(Category((int32_t)(target->get_Chars(tidx)))) != 1)) 
                {
                    break;
                }
                if(((int32_t)((*(sk + 2))) ==  0)) 
                {
                    (*(sk + 2)) = 2;
                }
                (*(sk + 2)) = (unsigned char)((int32_t)((*(sk + 2))) + (int32_t)(Level2((int32_t)(target->get_Chars(tidx)), ExtenderType::None)));
            }
        }
        do {
            int32_t idx = 0;
            if((replace != nullptr)) 
            {
                idx = IndexOf5(s, replace, start, length, targetSortKey, ctx);
            }
             else 
            {
                idx = IndexOfSortKey(s, start, length, sk, tc, ti, noLv4, ctx);
            }
            if((idx < 0)) 
            {
                return -1;
            }
            (length = length - (idx - start));
            start = idx;
            if(IsPrefix3(s, target, start, length, false, ctx)) 
            {
                return idx;
            }
            Contraction *cts = GetContraction(s, start, length);
            if((cts != nullptr)) 
            {
                (start = start + cts->Source->get_Length());
                (length = length - cts->Source->get_Length());
            }
             else 
            {
                start++;
                length--;
            }
        }
        while((length > 0));
        return -1;
    }
    
    int32_t SimpleCollator::LastIndexOf(System::String* s, System::String* target, System::Globalization::CompareOptions opt) {
        return LastIndexOf2(s, target, (s->get_Length() - 1), s->get_Length(), opt);
    }
    
    int32_t SimpleCollator::LastIndexOf2(System::String* s, System::String* target, int32_t start, int32_t length, System::Globalization::CompareOptions opt) {
        if(((int32_t)(opt) ==  1073741824)) 
        {
            return LastIndexOfOrdinal(s, target, start, length);
        }
        if(((int32_t)(opt) ==  268435456)) 
        {
            return LastIndexOfOrdinalIgnoreCase(s, target, start, length);
        }
        unsigned char alwaysMatchFlags[16];
        unsigned char neverMatchFlags[16];
        unsigned char targetSortKey[4];
        unsigned char sk1[4];
        unsigned char sk2[4];
        ClearBuffer(alwaysMatchFlags, 16);
        ClearBuffer(neverMatchFlags, 16);
        ClearBuffer(targetSortKey, 4);
        ClearBuffer(sk1, 4);
        ClearBuffer(sk2, 4);
        Context ctx = cli::ctor<Context>(opt, alwaysMatchFlags, neverMatchFlags, sk1, sk2, nullptr, false);
        return LastIndexOf5(s, target, start, length, targetSortKey, ctx);
    }
    
    int32_t SimpleCollator::LastIndexOfOrdinal(System::String* s, System::String* target, int32_t start, int32_t length) {
        if((target->get_Length() ==  0)) 
        {
            return start;
        }
        if(((s->get_Length() < target->get_Length()) || (target->get_Length() > length))) 
        {
            return -1;
        }
        int32_t end = (((start - length) + target->get_Length()) - 1);
        char16_t tail = target->get_Chars((target->get_Length() - 1));
        for(int32_t i = start; (i > end); ){
            if(((int32_t)(s->get_Chars(i)) != (int32_t)(tail))) 
            {
                i--;
                continue;
            }
            int32_t x = ((i - target->get_Length()) + 1);
            i--;
            bool mismatch = false;
            for(int32_t j = (target->get_Length() - 2); (j >= 0); j--) {
                if(((int32_t)(s->get_Chars((x + j))) != (int32_t)(target->get_Chars(j)))) 
                {
                    mismatch = true;
                    break;
                }
            }
            if(mismatch) 
            {
                continue;
            }
            return x;
        }
        return -1;
    }
    
    int32_t SimpleCollator::LastIndexOfOrdinalIgnoreCase(System::String* s, System::String* target, int32_t start, int32_t length) {
        if((target->get_Length() ==  0)) 
        {
            return start;
        }
        if(((s->get_Length() < length) || (target->get_Length() > length))) 
        {
            return -1;
        }
        int32_t end = (((start - length) + target->get_Length()) - 1);
        char16_t tail = this->textInfo->ToLower_6b32dfb00a24a852(target->get_Chars((target->get_Length() - 1)));
        for(int32_t i = start; (i > end); ){
            if(((int32_t)(this->textInfo->ToLower_6b32dfb00a24a852(s->get_Chars(i))) != (int32_t)(tail))) 
            {
                i--;
                continue;
            }
            int32_t x = ((i - target->get_Length()) + 1);
            i--;
            bool mismatch = false;
            for(int32_t j = (target->get_Length() - 2); (j >= 0); j--) {
                if(((int32_t)(this->textInfo->ToLower_6b32dfb00a24a852(s->get_Chars((x + j)))) != (int32_t)(this->textInfo->ToLower_6b32dfb00a24a852(target->get_Chars(j))))) 
                {
                    mismatch = true;
                    break;
                }
            }
            if(mismatch) 
            {
                continue;
            }
            return x;
        }
        return -1;
    }
    
    int32_t SimpleCollator::LastIndexOf3(System::String* s, char16_t target, System::Globalization::CompareOptions opt) {
        return LastIndexOf4(s, target, (s->get_Length() - 1), s->get_Length(), opt);
    }
    
    int32_t SimpleCollator::LastIndexOf4(System::String* s, char16_t target, int32_t start, int32_t length, System::Globalization::CompareOptions opt) {
        if(((int32_t)(opt) ==  1073741824)) 
        {
            return LastIndexOfOrdinal2(s, target, start, length);
        }
        if(((int32_t)(opt) ==  268435456)) 
        {
            return LastIndexOfOrdinalIgnoreCase2(s, target, start, length);
        }
        unsigned char alwaysMatchFlags[16];
        unsigned char neverMatchFlags[16];
        unsigned char targetSortKey[4];
        unsigned char sk1[4];
        unsigned char sk2[4];
        ClearBuffer(alwaysMatchFlags, 16);
        ClearBuffer(neverMatchFlags, 16);
        ClearBuffer(targetSortKey, 4);
        ClearBuffer(sk1, 4);
        ClearBuffer(sk2, 4);
        Context ctx = cli::ctor<Context>(opt, alwaysMatchFlags, neverMatchFlags, sk1, sk2, nullptr, false);
        Contraction *ct = GetContraction3(target);
        if((ct != nullptr)) 
        {
            if((ct->Replacement != nullptr)) 
            {
                return LastIndexOf5(s, ct->Replacement, start, length, targetSortKey, ctx);
            }
             else 
            {
                for(int32_t bi = 0; (bi < ct->SortKey2->get_Length()); bi++) {
                    (*(sk2 + bi)) = ct->SortKey2->at(bi);
                }
                return LastIndexOfSortKey(s, start, start, length, sk2, -1, true, ctx);
            }
        }
         else 
        {
            int32_t ti = FilterOptions((int32_t)(target), opt);
            (*(targetSortKey + 0)) = Category(ti);
            (*(targetSortKey + 1)) = Level1(ti);
            if(((int32_t)(((int32_t)(opt) & 2)) ==  0)) 
            {
                (*(targetSortKey + 2)) = Level2(ti, ExtenderType::None);
            }
            (*(targetSortKey + 3)) = MSCompatUnicodeTable::Level3(ti);
            return LastIndexOfSortKey(s, start, start, length, targetSortKey, ti, !(MSCompatUnicodeTable::HasSpecialWeight((char16_t)ti)), ctx);
        }
    }
    
    int32_t SimpleCollator::LastIndexOfOrdinal2(System::String* s, char16_t target, int32_t start, int32_t length) {
        if((s->get_Length() ==  0)) 
        {
            return -1;
        }
        int32_t end = (start - length);
        for(int32_t i = start; (i > end); i--) {
            if(((int32_t)(s->get_Chars(i)) ==  (int32_t)(target))) 
            {
                return i;
            }
        }
        return -1;
    }
    
    int32_t SimpleCollator::LastIndexOfOrdinalIgnoreCase2(System::String* s, char16_t target, int32_t start, int32_t length) {
        if((s->get_Length() ==  0)) 
        {
            return -1;
        }
        int32_t end = (start - length);
        char16_t c = this->textInfo->ToUpper_d4d54a4b5ef4f4c7(target);
        for(int32_t i = start; (i > end); i--) {
            if(((int32_t)(this->textInfo->ToUpper_d4d54a4b5ef4f4c7(s->get_Chars(i))) ==  (int32_t)(c))) 
            {
                return i;
            }
        }
        return -1;
    }
    
    int32_t SimpleCollator::LastIndexOfSortKey(System::String* s, int32_t start, int32_t orgStart, int32_t length, unsigned char* sortkey, int32_t ti, bool noLv4, Context ctx) {
        int32_t end = (start - length);
        int32_t idx = start;
        while((idx > end)) {
            int32_t cur = idx;
            if(MatchesBackward(s, idx, end, orgStart, ti, sortkey, noLv4, ctx)) 
            {
                return cur;
            }
        }
        return -1;
    }
    
    int32_t SimpleCollator::LastIndexOf5(System::String* s, System::String* target, int32_t start, int32_t length, unsigned char* targetSortKey, Context ctx) {
        System::Globalization::CompareOptions opt = ctx->Option;
        int32_t orgStart = start;
        int32_t tidx = 0;
        for(; (tidx < target->get_Length()); tidx++) {
            if(!(IsIgnorable((int32_t)(target->get_Chars(tidx)), opt))) 
            {
                break;
            }
        }
        if((tidx ==  target->get_Length())) 
        {
            return (IndexOfOrdinal2(target, u'\x0', 0, target->get_Length()) >= 0) ? LastIndexOfOrdinal(s, target, start, length) : start;
        }
        Contraction *ct = GetContraction(target, tidx, (target->get_Length() - tidx));
        System::String *replace = (ct != nullptr) ? ct->Replacement : nullptr;
        unsigned char *sk = (replace ==  nullptr) ? targetSortKey : nullptr;
        bool noLv4 = true;
        int32_t ti = -1;
        if(((ct != nullptr) && (sk != nullptr))) 
        {
            for(int32_t i = 0; (i < ct->SortKey2->get_Length()); i++) {
                (*(sk + i)) = ct->SortKey2->at(i);
            }
        }
         else 
        {
            if((sk != nullptr)) 
            {
                ti = FilterOptions((int32_t)(target->get_Chars(tidx)), opt);
                (*(sk + 0)) = Category(ti);
                (*(sk + 1)) = Level1(ti);
                if(((int32_t)(((int32_t)(opt) & 2)) ==  0)) 
                {
                    (*(sk + 2)) = Level2(ti, ExtenderType::None);
                }
                (*(sk + 3)) = MSCompatUnicodeTable::Level3(ti);
                noLv4 = !(MSCompatUnicodeTable::HasSpecialWeight((char16_t)ti));
            }
        }
        if((sk != nullptr)) 
        {
            for(tidx++; (tidx < target->get_Length()); tidx++){
                if(((int32_t)(Category((int32_t)(target->get_Chars(tidx)))) != 1)) 
                {
                    break;
                }
                if(((int32_t)((*(sk + 2))) ==  0)) 
                {
                    (*(sk + 2)) = 2;
                }
                (*(sk + 2)) = (unsigned char)((int32_t)((*(sk + 2))) + (int32_t)(Level2((int32_t)(target->get_Chars(tidx)), ExtenderType::None)));
            }
        }
        do {
            int32_t idx = 0;
            if((replace != nullptr)) 
            {
                idx = LastIndexOf5(s, replace, start, length, targetSortKey, ctx);
            }
             else 
            {
                idx = LastIndexOfSortKey(s, start, orgStart, length, sk, ti, noLv4, ctx);
            }
            if((idx < 0)) 
            {
                return -1;
            }
            (length = length - (start - idx));
            start = idx;
            if(IsPrefix3(s, target, idx, ((orgStart - idx) + 1), false, ctx)) 
            {
                for(; (idx < orgStart); idx++) {
                    if(!(IsIgnorable((int32_t)(s->get_Chars(idx)), opt))) 
                    {
                        break;
                    }
                }
                return idx;
            }
            Contraction *cts = GetContraction(s, idx, ((orgStart - idx) + 1));
            if((cts != nullptr)) 
            {
                (start = start - cts->Source->get_Length());
                (length = length - cts->Source->get_Length());
            }
             else 
            {
                start--;
                length--;
            }
        }
        while((length > 0));
        return -1;
    }
    
    bool SimpleCollator::MatchesForward(System::String* s, int32_t idx, int32_t end, int32_t ti, unsigned char* sortkey, bool noLv4, Context ctx) {
        int32_t si = (int32_t)(s->get_Chars(idx));
        if((((ctx->AlwaysMatchFlags != nullptr) && (si < 128)) && (((int32_t)((*(ctx->AlwaysMatchFlags + (si / 8)))) & (1 << ((si % 8) & 31))) != 0))) 
        {
            return true;
        }
        if((((ctx->NeverMatchFlags != nullptr) && (si < 128)) && (((int32_t)((*(ctx->NeverMatchFlags + (si / 8)))) & (1 << ((si % 8) & 31))) != 0))) 
        {
            idx++;
            return false;
        }
        ExtenderType ext = GetExtenderType((int32_t)(s->get_Chars(idx)));
        Contraction *ct = nullptr;
        if(MatchesForwardCore(s, idx, end, ti, sortkey, noLv4, ext, ct, ctx)) 
        {
            if(((((ctx->AlwaysMatchFlags != nullptr) && (ct ==  nullptr)) && ((int32_t)(ext) ==  0)) && (si < 128))) 
            {
                ((*(ctx->AlwaysMatchFlags + (si / 8))) = (unsigned char)((int32_t)((*(ctx->AlwaysMatchFlags + (si / 8)))) | (int32_t)((unsigned char)(1 << ((si % 8) & 31)))));
            }
            return true;
        }
        if(((((ctx->NeverMatchFlags != nullptr) && (ct ==  nullptr)) && ((int32_t)(ext) ==  0)) && (si < 128))) 
        {
            ((*(ctx->NeverMatchFlags + (si / 8))) = (unsigned char)((int32_t)((*(ctx->NeverMatchFlags + (si / 8)))) | (int32_t)((unsigned char)(1 << ((si % 8) & 31)))));
        }
        return false;
    }
    
    bool SimpleCollator::MatchesForwardCore(System::String* s, int32_t idx, int32_t end, int32_t ti, unsigned char* sortkey, bool noLv4, ExtenderType ext, Contraction* ct, Context ctx) {
        System::Globalization::CompareOptions opt = ctx->Option;
        unsigned char *charSortKey = ctx->Buffer1;
        bool ignoreNonSpace = ((int32_t)(((int32_t)(opt) & 2)) != 0);
        int32_t si = -1;
        if(((int32_t)(ext) ==  0)) 
        {
            ct = GetContraction(s, idx, end);
        }
         else 
        {
            if((ctx->PrevCode < 0)) 
            {
                if((ctx->PrevSortKey ==  nullptr)) 
                {
                    idx++;
                    return false;
                }
                charSortKey = ctx->PrevSortKey;
            }
             else 
            {
                si = FilterExtender(ctx->PrevCode, ext, opt);
            }
        }
        if((ct != nullptr)) 
        {
            (idx = idx + ct->Source->get_Length());
            if(!(noLv4)) 
            {
                return false;
            }
            if((ct->SortKey2 != nullptr)) 
            {
                for(int32_t i = 0; (i < 4); i++) {
                    (*(charSortKey + i)) = (*(sortkey + i));
                }
                ctx->PrevCode = -1;
                ctx->PrevSortKey = charSortKey;
            }
             else 
            {
                int32_t dummy = 0;
                return MatchesForward(ct->Replacement, dummy, ct->Replacement->get_Length(), ti, sortkey, noLv4, ctx);
            }
        }
         else 
        {
            if((si < 0)) 
            {
                si = FilterOptions((int32_t)(s->get_Chars(idx)), opt);
            }
            idx++;
            (*(charSortKey + 0)) = Category(si);
            bool noMatch = false;
            if(((int32_t)((*(sortkey + 0))) ==  (int32_t)((*(charSortKey + 0))))) 
            {
                (*(charSortKey + 1)) = Level1(si);
            }
             else 
            {
                noMatch = true;
            }
            if((!(ignoreNonSpace) && ((int32_t)((*(sortkey + 1))) ==  (int32_t)((*(charSortKey + 1)))))) 
            {
                (*(charSortKey + 2)) = Level2(si, ext);
            }
             else 
            {
                if(!(ignoreNonSpace)) 
                {
                    noMatch = true;
                }
            }
            if(noMatch) 
            {
                for(; (idx < end); idx++){
                    if(((int32_t)(Category((int32_t)(s->get_Chars(idx)))) != 1)) 
                    {
                        break;
                    }
                }
                return false;
            }
            (*(charSortKey + 3)) = MSCompatUnicodeTable::Level3(si);
            if(((int32_t)((*(charSortKey + 0))) != 1)) 
            {
                ctx->PrevCode = si;
            }
        }
        for(; (idx < end); idx++){
            if(((int32_t)(Category((int32_t)(s->get_Chars(idx)))) != 1)) 
            {
                break;
            }
            if(ignoreNonSpace) 
            {
                continue;
            }
            if(((int32_t)((*(charSortKey + 2))) ==  0)) 
            {
                (*(charSortKey + 2)) = 2;
            }
            (*(charSortKey + 2)) = (unsigned char)((int32_t)((*(charSortKey + 2))) + (int32_t)(Level2((int32_t)(s->get_Chars(idx)), ExtenderType::None)));
        }
        return MatchesPrimitive(opt, charSortKey, si, ext, sortkey, ti, noLv4);
    }
    
    bool SimpleCollator::MatchesPrimitive(System::Globalization::CompareOptions opt, unsigned char* source, int32_t si, ExtenderType ext, unsigned char* target, int32_t ti, bool noLv4) {
        bool ignoreNonSpace = ((int32_t)(((int32_t)(opt) & 2)) != 0);
        if((((((int32_t)((*(source + 0))) != (int32_t)((*(target + 0)))) || ((int32_t)((*(source + 1))) != (int32_t)((*(target + 1))))) || (!(ignoreNonSpace) && ((int32_t)((*(source + 2))) != (int32_t)((*(target + 2)))))) || ((int32_t)((*(source + 3))) != (int32_t)((*(target + 3)))))) 
        {
            return false;
        }
        if((noLv4 && ((si < 0) || !(MSCompatUnicodeTable::HasSpecialWeight((char16_t)si))))) 
        {
            return true;
        }
         else 
        {
            if(noLv4) 
            {
                return false;
            }
        }
        if((!(ignoreNonSpace) && ((int32_t)(ext) ==  3))) 
        {
            return false;
        }
        if(((((MSCompatUnicodeTable::IsJapaneseSmallLetter((char16_t)si) != MSCompatUnicodeTable::IsJapaneseSmallLetter((char16_t)ti)) || ((int32_t)(ToDashTypeValue(ext, opt)) != (int32_t)(ToDashTypeValue(ExtenderType::None, opt)))) || (!(MSCompatUnicodeTable::IsHiragana((char16_t)si)) != !(MSCompatUnicodeTable::IsHiragana((char16_t)ti)))) || (IsHalfKana((int32_t)((char16_t)si), opt) != IsHalfKana((int32_t)((char16_t)ti), opt)))) 
        {
            return false;
        }
        return true;
    }
    
    bool SimpleCollator::MatchesBackward(System::String* s, int32_t idx, int32_t end, int32_t orgStart, int32_t ti, unsigned char* sortkey, bool noLv4, Context ctx) {
        int32_t si = (int32_t)(s->get_Chars(idx));
        if((((ctx->AlwaysMatchFlags != nullptr) && (si < 128)) && (((int32_t)((*(ctx->AlwaysMatchFlags + (si / 8)))) & (1 << ((si % 8) & 31))) != 0))) 
        {
            return true;
        }
        if((((ctx->NeverMatchFlags != nullptr) && (si < 128)) && (((int32_t)((*(ctx->NeverMatchFlags + (si / 8)))) & (1 << ((si % 8) & 31))) != 0))) 
        {
            idx--;
            return false;
        }
        ExtenderType ext = GetExtenderType((int32_t)(s->get_Chars(idx)));
        Contraction *ct = nullptr;
        if(MatchesBackwardCore(s, idx, end, orgStart, ti, sortkey, noLv4, ext, ct, ctx)) 
        {
            if(((((ctx->AlwaysMatchFlags != nullptr) && (ct ==  nullptr)) && ((int32_t)(ext) ==  0)) && (si < 128))) 
            {
                ((*(ctx->AlwaysMatchFlags + (si / 8))) = (unsigned char)((int32_t)((*(ctx->AlwaysMatchFlags + (si / 8)))) | (int32_t)((unsigned char)(1 << ((si % 8) & 31)))));
            }
            return true;
        }
        if(((((ctx->NeverMatchFlags != nullptr) && (ct ==  nullptr)) && ((int32_t)(ext) ==  0)) && (si < 128))) 
        {
            ((*(ctx->NeverMatchFlags + (si / 8))) = (unsigned char)((int32_t)((*(ctx->NeverMatchFlags + (si / 8)))) | (int32_t)((unsigned char)(1 << ((si % 8) & 31)))));
        }
        return false;
    }
    
    bool SimpleCollator::MatchesBackwardCore(System::String* s, int32_t idx, int32_t end, int32_t orgStart, int32_t ti, unsigned char* sortkey, bool noLv4, ExtenderType ext, Contraction* ct, Context ctx) {
        System::Globalization::CompareOptions opt = ctx->Option;
        unsigned char *charSortKey = ctx->Buffer1;
        bool ignoreNonSpace = ((int32_t)(((int32_t)(opt) & 2)) != 0);
        int32_t cur = idx;
        int32_t si = -1;
        if(((int32_t)(ext) != 0)) 
        {
            unsigned char diacritical = 0;
            for(int32_t tmp = idx; ; tmp--){
                if((tmp < 0)) 
                {
                    return false;
                }
                if(IsIgnorable((int32_t)(s->get_Chars(tmp)), opt)) 
                {
                    continue;
                }
                int32_t tmpi = FilterOptions((int32_t)(s->get_Chars(tmp)), opt);
                unsigned char category = Category(tmpi);
                if(((int32_t)(category) ==  1)) 
                {
                    diacritical = Level2(tmpi, ExtenderType::None);
                    continue;
                }
                si = FilterExtender(tmpi, ext, opt);
                (*(charSortKey + 0)) = category;
                (*(charSortKey + 1)) = Level1(si);
                if(!(ignoreNonSpace)) 
                {
                    (*(charSortKey + 2)) = Level2(si, ext);
                }
                (*(charSortKey + 3)) = MSCompatUnicodeTable::Level3(si);
                if((((int32_t)(ext) != 3) && ((int32_t)(diacritical) != 0))) 
                {
                    (*(charSortKey + 2)) = ((int32_t)((*(charSortKey + 2))) ==  0) ? (unsigned char)((int32_t)(diacritical) + 2) : diacritical;
                }
                break;
            }
            idx--;
        }
        if(((int32_t)(ext) ==  0)) 
        {
            ct = GetTailContraction(s, idx, end);
        }
        if((ct != nullptr)) 
        {
            (idx = idx - ct->Source->get_Length());
            if(!(noLv4)) 
            {
                return false;
            }
            if((ct->SortKey2 != nullptr)) 
            {
                for(int32_t i = 0; (i < 4); i++) {
                    (*(charSortKey + i)) = (*(sortkey + i));
                }
                ctx->PrevCode = -1;
                ctx->PrevSortKey = charSortKey;
            }
             else 
            {
                int32_t dummy = (ct->Replacement->get_Length() - 1);
                return (0 <= LastIndexOfSortKey(ct->Replacement, dummy, dummy, ct->Replacement->get_Length(), sortkey, ti, noLv4, ctx));
            }
        }
         else 
        {
            if(((int32_t)(ext) ==  0)) 
            {
                if((si < 0)) 
                {
                    si = FilterOptions((int32_t)(s->get_Chars(idx)), opt);
                }
                idx--;
                bool noMatch = false;
                (*(charSortKey + 0)) = Category(si);
                if(((int32_t)((*(charSortKey + 0))) ==  (int32_t)((*(sortkey + 0))))) 
                {
                    (*(charSortKey + 1)) = Level1(si);
                }
                 else 
                {
                    noMatch = true;
                }
                if((!(ignoreNonSpace) && ((int32_t)((*(charSortKey + 1))) ==  (int32_t)((*(sortkey + 1)))))) 
                {
                    (*(charSortKey + 2)) = Level2(si, ext);
                }
                 else 
                {
                    if(!(ignoreNonSpace)) 
                    {
                        noMatch = true;
                    }
                }
                if(noMatch) 
                {
                    return false;
                }
                (*(charSortKey + 3)) = MSCompatUnicodeTable::Level3(si);
                if(((int32_t)((*(charSortKey + 0))) != 1)) 
                {
                    ctx->PrevCode = si;
                }
            }
        }
        if(((int32_t)(ext) ==  0)) 
        {
            for(int32_t tmp = (cur + 1); (tmp < orgStart); tmp++){
                if(((int32_t)(Category((int32_t)(s->get_Chars(tmp)))) != 1)) 
                {
                    break;
                }
                if(ignoreNonSpace) 
                {
                    continue;
                }
                if(((int32_t)((*(charSortKey + 2))) ==  0)) 
                {
                    (*(charSortKey + 2)) = 2;
                }
                (*(charSortKey + 2)) = (unsigned char)((int32_t)((*(charSortKey + 2))) + (int32_t)(Level2((int32_t)(s->get_Chars(tmp)), ExtenderType::None)));
            }
        }
        return MatchesPrimitive(opt, charSortKey, si, ext, sortkey, ti, noLv4);
    }
    
}}}
namespace System { namespace Globalization {
    
    
    void SortKey::constructor(int32_t lcid, System::String* source, CompareOptions opt) {
        this->lcid = lcid;
        this->source = source;
        this->options = opt;
    }
    
    void SortKey::constructor(int32_t lcid, System::String* source, cli::array<unsigned char>* buffer, CompareOptions opt, int32_t lv1Length, int32_t lv2Length, int32_t lv3Length, int32_t kanaSmallLength, int32_t markTypeLength, int32_t katakanaLength, int32_t kanaWidthLength, int32_t identLength) {
        this->lcid = lcid;
        this->source = source;
        this->key = buffer;
        this->options = opt;
    }
    
    int32_t SortKey::Compare(SortKey* sortkey1, SortKey* sortkey2) {
        if((sortkey1 ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("sortkey1"));
        }
        if((sortkey2 ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("sortkey2"));
        }
        if((System::Object::ReferenceEquals(sortkey1, sortkey2) || System::Object::ReferenceEquals(sortkey1->get_OriginalString_f4d9253cc39fbcc1(), sortkey2->get_OriginalString_f4d9253cc39fbcc1()))) 
        {
            return 0;
        }
        cli::array<unsigned char> *d1 = sortkey1->get_KeyData_e359e5d060ef0079();
        cli::array<unsigned char> *d2 = sortkey2->get_KeyData_e359e5d060ef0079();
        int32_t len = (d1->get_Length() > d2->get_Length()) ? d2->get_Length() : d1->get_Length();
        for(int32_t i = 0; (i < len); i++) {
            if(((int32_t)(d1->at(i)) != (int32_t)(d2->at(i)))) 
            {
                return ((int32_t)(d1->at(i)) < (int32_t)(d2->at(i))) ? -1 : 1;
            }
        }
        return (d1->get_Length() ==  d2->get_Length()) ? 0 : (d1->get_Length() < d2->get_Length()) ? -1 : 1;
    }
    
    bool SortKey::Equals_ed975d2f4a7d193e(System::Object* value) {
        SortKey *other = cli::as<SortKey*>(value);
        if((other != nullptr)) 
        {
            if((((this->lcid ==  other->lcid) && ((int32_t)(this->options) ==  (int32_t)(other->options))) && (Compare(this, other) ==  0))) 
            {
                return true;
            }
        }
        return false;
    }
    
    int32_t SortKey::GetHashCode_6648aef0f235ee6c() {
        if((this->key->get_Length() ==  0)) 
        {
            return 0;
        }
        int32_t val = (int32_t)(this->key->at(0));
        for(int32_t i = 1; (i < this->key->get_Length()); i++) {
            (val = val ^ ((int32_t)(this->key->at(i)) << ((i & 3) & 31)));
        }
        return (int32_t)(val);
    }
    
    System::String* SortKey::ToString_1636a0751cb9ac11() {
        return cli::concat(_T("SortKey - "), cli::box(this->lcid), _T(", "), cli::box(this->options), _T(", "), this->source);
    }
    
    System::String* SortKey::get_OriginalString_f4d9253cc39fbcc1() {
        return this->source;
    }
    
    cli::array<unsigned char>* SortKey::get_KeyData_e359e5d060ef0079() {
        return this->key;
    }
    
}}
namespace Mono { namespace Globalization { namespace Unicode {
    
    
    void SortKeyBuffer::constructor(int32_t lcid) {
    }
    
    void SortKeyBuffer::Reset() {
        this->l1 = this->l2 = this->l3 = this->l4s = this->l4t = this->l4k = this->l4w = this->l5 = 0;
        this->frenchSorted = false;
    }
    
    void SortKeyBuffer::ClearBuffer() {
        this->l1b = this->l2b = this->l3b = this->l4sb = this->l4tb = this->l4kb = this->l4wb = this->l5b = nullptr;
    }
    
    void SortKeyBuffer::Initialize(System::Globalization::CompareOptions options, int32_t lcid, System::String* s, bool frenchSort) {
        this->source = s;
        this->lcid = lcid;
        this->options = options;
        int32_t len = s->get_Length();
        this->processLevel2 = ((int32_t)(((int32_t)(options) & 2)) ==  0);
        this->frenchSort = frenchSort;
        if(((this->l1b ==  nullptr) || (this->l1b->get_Length() < len))) 
        {
            this->l1b = (new cli::array<unsigned char>(((len * 2) + 10)));
        }
        if((this->processLevel2 && ((this->l2b ==  nullptr) || (this->l2b->get_Length() < len)))) 
        {
            this->l2b = (new cli::array<unsigned char>((len + 10)));
        }
        if(((this->l3b ==  nullptr) || (this->l3b->get_Length() < len))) 
        {
            this->l3b = (new cli::array<unsigned char>((len + 10)));
        }
        if((this->l4sb ==  nullptr)) 
        {
            this->l4sb = (new cli::array<unsigned char>(10));
        }
        if((this->l4tb ==  nullptr)) 
        {
            this->l4tb = (new cli::array<unsigned char>(10));
        }
        if((this->l4kb ==  nullptr)) 
        {
            this->l4kb = (new cli::array<unsigned char>(10));
        }
        if((this->l4wb ==  nullptr)) 
        {
            this->l4wb = (new cli::array<unsigned char>(10));
        }
        if((this->l5b ==  nullptr)) 
        {
            this->l5b = (new cli::array<unsigned char>(10));
        }
    }
    
    void SortKeyBuffer::AppendCJKExtension(unsigned char lv1msb, unsigned char lv1lsb) {
        AppendBufferPrimitive(254, this->l1b, this->l1);
        AppendBufferPrimitive(255, this->l1b, this->l1);
        AppendBufferPrimitive(lv1msb, this->l1b, this->l1);
        AppendBufferPrimitive(lv1lsb, this->l1b, this->l1);
        if(this->processLevel2) 
        {
            AppendBufferPrimitive(2, this->l2b, this->l2);
        }
        AppendBufferPrimitive(2, this->l3b, this->l3);
    }
    
    void SortKeyBuffer::AppendKana(unsigned char category, unsigned char lv1, unsigned char lv2, unsigned char lv3, bool isSmallKana, unsigned char markType, bool isKatakana, bool isHalfWidth) {
        AppendNormal(category, lv1, lv2, lv3);
        AppendBufferPrimitive((unsigned char)isSmallKana ? 196 : 228, this->l4sb, this->l4s);
        AppendBufferPrimitive(markType, this->l4tb, this->l4t);
        AppendBufferPrimitive((unsigned char)isKatakana ? 196 : 228, this->l4kb, this->l4k);
        AppendBufferPrimitive((unsigned char)isHalfWidth ? 196 : 228, this->l4wb, this->l4w);
    }
    
    void SortKeyBuffer::AppendNormal(unsigned char category, unsigned char lv1, unsigned char lv2, unsigned char lv3) {
        if(((int32_t)(lv2) ==  0)) 
        {
            lv2 = 2;
        }
        if(((int32_t)(lv3) ==  0)) 
        {
            lv3 = 2;
        }
        if((((int32_t)(category) ==  6) && ((int32_t)(((int32_t)(this->options) & 536870912)) ==  0))) 
        {
            AppendLevel5(category, lv1);
            return;
        }
        if(((this->processLevel2 && ((int32_t)(category) ==  1)) && (this->l1 > 0))) 
        {
            lv2 = (unsigned char)((int32_t)(lv2) + (int32_t)(this->l2b->at(--this->l2)));
            lv3 = this->l3b->at(--this->l3);
        }
        if(((int32_t)(category) != 1)) 
        {
            AppendBufferPrimitive(category, this->l1b, this->l1);
            AppendBufferPrimitive(lv1, this->l1b, this->l1);
        }
        if(this->processLevel2) 
        {
            AppendBufferPrimitive(lv2, this->l2b, this->l2);
        }
        AppendBufferPrimitive(lv3, this->l3b, this->l3);
    }
    
    void SortKeyBuffer::AppendLevel5(unsigned char category, unsigned char lv1) {
        int32_t offsetValue = ((this->l2 + 1) % 8192);
        AppendBufferPrimitive((unsigned char)((offsetValue / 64) + 128), this->l5b, this->l5);
        AppendBufferPrimitive((unsigned char)(((offsetValue % 64) * 4) + 3), this->l5b, this->l5);
        AppendBufferPrimitive(category, this->l5b, this->l5);
        AppendBufferPrimitive(lv1, this->l5b, this->l5);
    }
    
    void SortKeyBuffer::AppendBufferPrimitive(unsigned char value, cli::array<unsigned char>* buf, int32_t bidx) {
        buf->at(bidx++) = value;
        if((bidx ==  buf->get_Length())) 
        {
            cli::array<unsigned char> *tmp = (new cli::array<unsigned char>((bidx * 2)));
            System::Array::Copy(buf, tmp, buf->get_Length());
            buf = tmp;
        }
    }
    
    System::Globalization::SortKey* SortKeyBuffer::GetResultAndReset() {
        System::Globalization::SortKey *ret = GetResult();
        Reset();
        return ret;
    }
    
    int32_t SortKeyBuffer::GetOptimizedLength(cli::array<unsigned char>* data, int32_t len, unsigned char defaultValue) {
        int32_t cur = -1;
        for(int32_t i = 0; (i < len); i++) {
            if(((int32_t)(data->at(i)) != (int32_t)(defaultValue))) 
            {
                cur = i;
            }
        }
        return (cur + 1);
    }
    
    System::Globalization::SortKey* SortKeyBuffer::GetResult() {
        if((this->source->get_Length() ==  0)) 
        {
            return cli::gcnew<System::Globalization::SortKey>(this->lcid, this->source, (new cli::array<unsigned char>(0)), this->options, 0, 0, 0, 0, 0, 0, 0, 0);
        }
        if(((this->frenchSort && !(this->frenchSorted)) && (this->l2b != nullptr))) 
        {
            int32_t i = 0;
            for(; (i < this->l2b->get_Length()); i++) {
                if(((int32_t)(this->l2b->at(i)) ==  0)) 
                {
                    break;
                }
            }
            System::Array::Reverse2(this->l2b, 0, i);
            this->frenchSorted = true;
        }
        this->l2 = GetOptimizedLength(this->l2b, this->l2, 2);
        this->l3 = GetOptimizedLength(this->l3b, this->l3, 2);
        bool hasJapaneseWeight = (this->l4s > 0);
        this->l4s = GetOptimizedLength(this->l4sb, this->l4s, 228);
        this->l4t = GetOptimizedLength(this->l4tb, this->l4t, 3);
        this->l4k = GetOptimizedLength(this->l4kb, this->l4k, 228);
        this->l4w = GetOptimizedLength(this->l4wb, this->l4w, 228);
        this->l5 = GetOptimizedLength(this->l5b, this->l5, 2);
        int32_t length = ((((this->l1 + this->l2) + this->l3) + this->l5) + 5);
        int32_t jpLength = (((this->l4s + this->l4t) + this->l4k) + this->l4w);
        if(hasJapaneseWeight) 
        {
            (length = length + (jpLength + 4));
        }
        cli::array<unsigned char> *ret = (new cli::array<unsigned char>(length));
        System::Array::Copy(this->l1b, ret, this->l1);
        ret->at(this->l1) = 1;
        int32_t cur = (this->l1 + 1);
        if((this->l2 > 0)) 
        {
            System::Array::Copy2(this->l2b, 0, ret, cur, this->l2);
        }
        (cur = cur + this->l2);
        ret->at(cur++) = 1;
        if((this->l3 > 0)) 
        {
            System::Array::Copy2(this->l3b, 0, ret, cur, this->l3);
        }
        (cur = cur + this->l3);
        ret->at(cur++) = 1;
        if(hasJapaneseWeight) 
        {
            System::Array::Copy2(this->l4sb, 0, ret, cur, this->l4s);
            (cur = cur + this->l4s);
            ret->at(cur++) = 255;
            System::Array::Copy2(this->l4tb, 0, ret, cur, this->l4t);
            (cur = cur + this->l4t);
            ret->at(cur++) = 2;
            System::Array::Copy2(this->l4kb, 0, ret, cur, this->l4k);
            (cur = cur + this->l4k);
            ret->at(cur++) = 255;
            System::Array::Copy2(this->l4wb, 0, ret, cur, this->l4w);
            (cur = cur + this->l4w);
            ret->at(cur++) = 255;
        }
        ret->at(cur++) = 1;
        if((this->l5 > 0)) 
        {
            System::Array::Copy2(this->l5b, 0, ret, cur, this->l5);
        }
        (cur = cur + this->l5);
        ret->at(cur++) = 0;
        return cli::gcnew<System::Globalization::SortKey>(this->lcid, this->source, ret, this->options, this->l1, this->l2, this->l3, this->l4s, this->l4t, this->l4k, this->l4w, this->l5);
    }
    
}}}
namespace Mono { namespace Globalization { namespace Unicode {
    
    
    void TestDriver::constructor() {
    }
    
    void TestDriver::Main(cli::array<System::String*>* args) {
        if(((args->get_Length() > 0) && System::String::op_Equality(args->at(0), _T("--generate")))) 
        {
            cli::gcnew<TestDriver>()->Generate();
        }
        if(((args->get_Length() > 0) && System::String::op_Equality(args->at(0), _T("--check")))) 
        {
            cli::gcnew<TestDriver>()->CheckCultures();
        }
         else 
        {
            cli::gcnew<TestDriver>()->Run();
        }
    }
    
    void TestDriver::CheckCultures() {
        for(auto tmp_39 : System::Globalization::CultureInfo::GetCultures(System::Globalization::CultureTypes::AllCultures)) {
            auto ci = cli::cast<System::Globalization::CultureInfo*>(tmp_39);
            System::Console::WriteLine18(_T("Culture {0}({1}) : OK: {2}"), cli::box(ci->get_LCID_f4b9bc9d0bf0db86()), ci->get_Name_7a59bd1b86cfacd3(), cli::gcnew<SimpleCollator>(ci));
        }
    }
    
    void TestDriver::Run() {
        LastIndexOf2(_T(""), _T(""), System::Globalization::CompareOptions::IgnoreNonSpace);
        return;;;;;;;;;;
    }
    
    void TestDriver::Generate() {
        for(int32_t i = 0; (i <= 65535); i++){
            cli::array<unsigned char> *data = this->coll->GetSortKey2(cli::gcnew<System::String>((char16_t)i, 1), System::Globalization::CompareOptions::StringSort)->get_KeyData_e359e5d060ef0079();
            if(((((((data->get_Length() ==  5) && ((int32_t)(data->at(0)) ==  1)) && ((int32_t)(data->at(1)) ==  1)) && ((int32_t)(data->at(2)) ==  1)) && ((int32_t)(data->at(3)) ==  1)) && ((int32_t)(data->at(4)) ==  0))) 
            {
                continue;
            }
            for(auto tmp_40 : data) {
                auto b = cli::cast<unsigned char>(tmp_40);
                System::Console::Write13(_T("{0:X02} "), cli::box(b));
            }
            System::Console::WriteLine17(_T(" : {0:X04}, {1}"), cli::box(i), cli::box(System::Char::GetUnicodeCategory((char16_t)i)));
        }
    }
    
    void TestDriver::Compare(System::String* s1, System::String* s2) {
        Compare2(s1, s2, System::Globalization::CompareOptions::None);
    }
    
    void TestDriver::Compare2(System::String* s1, System::String* s2, System::Globalization::CompareOptions opt) {
        System::Console::get_Error()->WriteLine_b743f1a08f47f965(_T("compare ({3}): {0} {1} / {2}"), (new cli::array<System::Object*>({cli::box(this->coll->Compare2(s1, s2, opt)), s1, s2, cli::box(opt)})));
    }
    
    void TestDriver::Compare3(System::String* s1, int32_t idx1, int32_t len1, System::String* s2, int32_t idx2, int32_t len2, System::Globalization::CompareOptions opt) {
        System::Console::get_Error()->WriteLine_b743f1a08f47f965(_T("compare ({3} {4} {5} {6} {7}): {0} {1} / {2}"), (new cli::array<System::Object*>({cli::box(this->coll->Compare3(s1, idx1, len1, s2, idx2, len2, opt)), s1, s2, cli::box(opt), cli::box(idx1), cli::box(len1), cli::box(idx2), cli::box(len2)})));
    }
    
    void TestDriver::IndexOf(System::String* s, char16_t c, System::Globalization::CompareOptions opt) {
        IndexOf2(s, c, 0, s->get_Length(), opt);
    }
    
    void TestDriver::IndexOf2(System::String* s, char16_t c, int32_t idx, int32_t len, System::Globalization::CompareOptions opt) {
        System::Console::get_Error()->WriteLine_b743f1a08f47f965(_T("cIndex ({3} {4} {5}): {0} {1} / {2}"), (new cli::array<System::Object*>({cli::box(this->coll->IndexOf4(s, c, idx, len, opt)), s, cli::box(c), cli::box(opt), cli::box(idx), cli::box(len)})));
    }
    
    void TestDriver::IndexOf3(System::String* s1, System::String* s2, System::Globalization::CompareOptions opt) {
        IndexOf4(s1, s2, 0, s1->get_Length(), opt);
    }
    
    void TestDriver::IndexOf4(System::String* s1, System::String* s2, int32_t idx, int32_t len, System::Globalization::CompareOptions opt) {
        System::Console::get_Error()->WriteLine_b743f1a08f47f965(_T("sIndex ({3} {4} {5}): {0} {1} / {2}"), (new cli::array<System::Object*>({cli::box(this->coll->IndexOf2(s1, s2, idx, len, opt)), s1, s2, cli::box(opt), cli::box(idx), cli::box(len)})));
    }
    
    void TestDriver::IsPrefix(System::String* s1, System::String* s2, System::Globalization::CompareOptions opt) {
        System::Console::get_Error()->WriteLine_b743f1a08f47f965(_T("prefix ({3}): {0} {1} / {2}"), (new cli::array<System::Object*>({cli::box(this->coll->IsPrefix(s1, s2, opt)), s1, s2, cli::box(opt)})));
    }
    
    void TestDriver::LastIndexOf(System::String* s, char16_t c, System::Globalization::CompareOptions opt) {
        System::Console::get_Error()->WriteLine_b743f1a08f47f965(_T("cLast ({3}): {0} {1} / {2}"), (new cli::array<System::Object*>({cli::box(this->coll->LastIndexOf3(s, c, opt)), s, cli::box(c), cli::box(opt)})));
    }
    
    void TestDriver::LastIndexOf2(System::String* s1, System::String* s2, System::Globalization::CompareOptions opt) {
        System::Console::get_Error()->WriteLine_b743f1a08f47f965(_T("sLast ({3}): {0} {1} / {2}"), (new cli::array<System::Object*>({cli::box(this->coll->LastIndexOf(s1, s2, opt)), s1, s2, cli::box(opt)})));
    }
    
    void TestDriver::LastIndexOf3(System::String* s1, System::String* s2, int32_t idx, int32_t len, System::Globalization::CompareOptions opt) {
        System::Console::get_Error()->WriteLine_b743f1a08f47f965(_T("sLast ({3},{4},{5}): {0} {1} / {2}"), (new cli::array<System::Object*>({cli::box(this->coll->LastIndexOf2(s1, s2, idx, len, opt)), s1, s2, cli::box(opt), cli::box(idx), cli::box(len)})));
    }
    
    void TestDriver::IsSuffix(System::String* s1, System::String* s2, System::Globalization::CompareOptions opt) {
        System::Console::get_Error()->WriteLine_b743f1a08f47f965(_T("suffix ({3}): {0} {1} / {2}"), (new cli::array<System::Object*>({cli::box(this->coll->IsSuffix(s1, s2, opt)), s1, s2, cli::box(opt)})));
    }
    
    void TestDriver::DumpSortKey(System::String* s) {
        DumpSortKey2(s, 0, s->get_Length(), System::Globalization::CompareOptions::None);
    }
    
    void TestDriver::DumpSortKey2(System::String* s, int32_t idx, int32_t len, System::Globalization::CompareOptions opt) {
        cli::array<unsigned char> *data = this->coll->GetSortKey3(s, idx, len, opt)->get_KeyData_e359e5d060ef0079();
        for(auto tmp_41 : data) {
            auto b = cli::cast<unsigned char>(tmp_41);
            System::Console::get_Error()->Write_f2bf6875dbaeba6a(_T("{0:X02} "), cli::box(b));
        }
        System::Console::get_Error()->WriteLine_b743f1a08f47f965(_T(" : {0} ({1} {2} {3})"), (new cli::array<System::Object*>({s, cli::box(opt), cli::box(idx), cli::box(len)})));
    }
    
}}}
namespace Mono { namespace Globalization { namespace Unicode {
    
    
    void Driver::constructor() {
    }
    
    void Driver::Main(cli::array<System::String*>* args) {
        System::IO::TextWriter *w = System::Console::get_Out();
        w->set_NewLine_7d29519e1b46fe0b(_T("\n"));
        w->WriteLine_5eb6d2f1667d4085(_T("/*\nDO NOT MODIFY THIS FILE DIRECTLY.\n\nThis file is automatically generated by {0}.exe.\nThe source for this generator should be in Mono repository\n(mcs/class/corlib/Mono.Globalization.Unicode directory).\n*/\n\n#ifndef __UNICODE_DATA_H\n#define __UNICODE_DATA_H\n\n#include <glib.h>\n\n"), System::Reflection::Assembly::GetEntryAssembly()->GetName_7088a38b93d0dcc5()->get_Name());
        UnicodeData5_1_0 *ud = cli::gcnew<UnicodeData5_1_0>();
        cli::array<UcdCharacterProperty*> *ucd = ud->ParseFile_5d8c937b576f9b09(args->at(0));
        UnicodeDataCodeGeneratorC5_1_0 *ucg = cli::gcnew<UnicodeDataCodeGeneratorC5_1_0>(ud, w);
        ucg->GenerateStructures();
        w->WriteLine_f0ca76dc02634177();
        ucg->GenerateUnicodeCategoryListC(ucd);
        w->WriteLine_f0ca76dc02634177();
        ucg->GenerateSimpleCaseMappingListC(ucd);
        w->WriteLine_f0ca76dc02634177();
        ucg->GenerateSimpleTitlecaseMappingListC(ucd);
        w->WriteLine_27fb29d2c5b390c7(_T("\n#endif\n"));
    }
    
}}}
namespace Mono { namespace Globalization { namespace Unicode {
    
    cli::array<CodePointRange*>*  UnicodeData5_1_0::simple_cases;
    cli::array<CodePointRange*>*  UnicodeData5_1_0::category_ranges;
    
    UnicodeData5_1_0::UnicodeData5_1_0()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void UnicodeData5_1_0::constructor() {
    }
    
    void UnicodeData5_1_0::static_constructor() {
    }
    
    cli::array<CodePointRange*>* UnicodeData5_1_0::get_SimpleCases_2325e5522320db2d() {
        return simple_cases;
    }
    
    cli::array<CodePointRange*>* UnicodeData5_1_0::get_CategoryRanges_7fff5478a3a668d7() {
        return category_ranges;
    }
    
}}}
namespace Mono { namespace Globalization { namespace Unicode {
    
    System::Converter<System::String*, int32_t>*  UnicodeData::__f__am_cache0;
    System::Collections::Generic::Dictionary<System::String*, int32_t>*  UnicodeData::__f__switch_map1;
    System::Collections::Generic::Dictionary<System::String*, int32_t>*  UnicodeData::__f__switch_map2;
    
    void UnicodeData::constructor() {
    }
    
    cli::array<UcdCharacterProperty*>* UnicodeData::ParseFile_5d8c937b576f9b09(System::String* file) {
        System::Collections::Generic::List<System::Collections::Generic::KeyValuePair<int32_t, UcdCharacterProperty*>> *d = cli::gcnew<System::Collections::Generic::List<System::Collections::Generic::KeyValuePair<int32_t, UcdCharacterProperty*>>>();
        {
            /* USING - BLOCK */
            auto r = System::IO::File::OpenText(file);
            cli::using_guard{r};
            while((r->Peek_82f04bf3cd196dfd() >= 0)) {
                System::String *l = r->ReadLine_51552a49261f929e();
                if(((l->get_Length() > 0) && ((int32_t)(l->get_Chars(0)) != 35))) 
                {
                    UcdCharacterProperty *u = Parse(l);
                    d->Add(cli::ctor<System::Collections::Generic::KeyValuePair<int32_t, UcdCharacterProperty*>>(u->get_Codepoint(), u));
                }
            }
        }
        System::Collections::Generic::List<UcdCharacterProperty*> *list = cli::gcnew<System::Collections::Generic::List<UcdCharacterProperty*>>();
        for(auto tmp_42 : d) {
            auto p = cli::cast<System::Collections::Generic::KeyValuePair<int32_t, UcdCharacterProperty*>>(tmp_42);
            list->Add(p->get_Value());
        }
        return list->ToArray();
    }
    
    UcdCharacterProperty* UnicodeData::Parse(System::String* line) {
        cli::array<System::String*> *tokens = line->Split((new cli::array<char16_t>({u';'})));
        cli::array<System::String*> *decomp = (tokens->at(5)->get_Length() > 0) ? tokens->at(5)->Split((new cli::array<char16_t>({u' '}))) : nullptr;
        System::String *decomp_type = ((decomp != nullptr) && ((int32_t)(decomp->at(0)->get_Chars(0)) ==  60)) ? decomp->at(0) : nullptr;
        if((decomp_type != nullptr)) 
        {
            for(int32_t i = 1; (i < decomp->get_Length()); i++) {
                decomp->at((i - 1)) = decomp->at(i);
            }
            System::Array::template Resize_1<System::String*>(decomp, (decomp->get_Length() - 1));
        }
        return ([&]() { 
            auto tmp_43 = cli::gcnew<UcdCharacterProperty>();
            tmp_43->set_Codepoint(System::Int32::Parse3(tokens->at(0), System::Globalization::NumberStyles::HexNumber));
            tmp_43->set_Name(tokens->at(1));
            tmp_43->set_Category(ParseUnicodeCategory(tokens->at(2)));
            tmp_43->set_CanonicalCombiningClass((tokens->at(3)->get_Length() > 0) ? cli::wrap_nullable(System::Byte::Parse4(tokens->at(3))) : nullptr);
            tmp_43->set_BidiClass((tokens->at(4)->get_Length() > 0) ? cli::unbox<UcdBidiClass>(System::Enum::Parse(cli::typeof<System::Type>::info, tokens->at(4))) : UcdBidiClass::None);
            tmp_43->set_DecompositionType((decomp_type != nullptr) ? ParseDecompositionType(decomp_type) : UcdDecompositionType::None);
            tmp_43->set_DecompositionMapping((decomp != nullptr) ? System::Array::template ConvertAll_2<System::String*, int32_t>(decomp, cli::bind([&] (System::String* dv) -> int32_t {
                return System::Int32::Parse3(dv, System::Globalization::NumberStyles::HexNumber);
            }
            )) : nullptr);
            tmp_43->set_DecimalDigitValue(tokens->at(6));
            tmp_43->set_DigitValue(tokens->at(7));
            tmp_43->set_NumericValue(tokens->at(8));
            tmp_43->set_BidiMirrored(System::String::op_Equality(tokens->at(9), _T("Y")));
            tmp_43->set_Unicode1Name(tokens->at(10));
            tmp_43->set_IsoComment(tokens->at(11));
            tmp_43->set_SimpleUppercaseMapping((tokens->at(12)->get_Length() > 0) ? System::Int32::Parse3(tokens->at(12), System::Globalization::NumberStyles::HexNumber) : 0);
            tmp_43->set_SimpleLowercaseMapping((tokens->at(13)->get_Length() > 0) ? System::Int32::Parse3(tokens->at(13), System::Globalization::NumberStyles::HexNumber) : 0);
            tmp_43->set_SimpleTitlecaseMapping((tokens->at(14)->get_Length() > 0) ? System::Int32::Parse3(tokens->at(14), System::Globalization::NumberStyles::HexNumber) : 0);
            
            return tmp_43;
        })();
    }
    
    UcdDecompositionType UnicodeData::ParseDecompositionType(System::String* s) {
        System::String* tmp_44 = s;
        ::System::Int32 tmp_45 = -1;
        if(::System::String::Equals3(tmp_44, _T("<font>"))) tmp_45 = 0;
        if(::System::String::Equals3(tmp_44, _T("<noBreak>"))) tmp_45 = 1;
        if(::System::String::Equals3(tmp_44, _T("<initial>"))) tmp_45 = 2;
        if(::System::String::Equals3(tmp_44, _T("<medial>"))) tmp_45 = 3;
        if(::System::String::Equals3(tmp_44, _T("<final>"))) tmp_45 = 4;
        if(::System::String::Equals3(tmp_44, _T("<isolated>"))) tmp_45 = 5;
        if(::System::String::Equals3(tmp_44, _T("<circle>"))) tmp_45 = 6;
        if(::System::String::Equals3(tmp_44, _T("<super>"))) tmp_45 = 7;
        if(::System::String::Equals3(tmp_44, _T("<sub>"))) tmp_45 = 8;
        if(::System::String::Equals3(tmp_44, _T("<vertical>"))) tmp_45 = 9;
        if(::System::String::Equals3(tmp_44, _T("<wide>"))) tmp_45 = 10;
        if(::System::String::Equals3(tmp_44, _T("<narrow>"))) tmp_45 = 11;
        if(::System::String::Equals3(tmp_44, _T("<small>"))) tmp_45 = 12;
        if(::System::String::Equals3(tmp_44, _T("<square>"))) tmp_45 = 13;
        if(::System::String::Equals3(tmp_44, _T("<fraction>"))) tmp_45 = 14;
        if(::System::String::Equals3(tmp_44, _T("<compat>"))) tmp_45 = 15;
        switch(tmp_45)
        {
            case 0: case_251: 
            {
                return UcdDecompositionType::Font;
            }
            case 1: case_252: 
            {
                return UcdDecompositionType::NoBreak;
            }
            case 2: case_253: 
            {
                return UcdDecompositionType::Initial2;
            }
            case 3: case_254: 
            {
                return UcdDecompositionType::Medial;
            }
            case 4: case_255: 
            {
                return UcdDecompositionType::Final;
            }
            case 5: case_256: 
            {
                return UcdDecompositionType::Isolated;
            }
            case 6: case_257: 
            {
                return UcdDecompositionType::Circle;
            }
            case 7: case_258: 
            {
                return UcdDecompositionType::Super;
            }
            case 8: case_259: 
            {
                return UcdDecompositionType::Sub;
            }
            case 9: case_260: 
            {
                return UcdDecompositionType::Vertical;
            }
            case 10: case_261: 
            {
                return UcdDecompositionType::Wide;
            }
            case 11: case_262: 
            {
                return UcdDecompositionType::Narrow;
            }
            case 12: case_263: 
            {
                return UcdDecompositionType::Small;
            }
            case 13: case_264: 
            {
                return UcdDecompositionType::Square;
            }
            case 14: case_265: 
            {
                return UcdDecompositionType::Fraction;
            }
            case 15: case_266: 
            {
                return UcdDecompositionType::Compat;
            }
        }
        throw cli::gcnew<System::ArgumentException>(System::String::Format2(_T("Unexpected decomposition type \'{0}\'"), s));
    }
    
    System::Globalization::UnicodeCategory UnicodeData::ParseUnicodeCategory(System::String* s) {
        System::String* tmp_46 = s;
        ::System::Int32 tmp_47 = -1;
        if(::System::String::Equals3(tmp_46, _T("Lu"))) tmp_47 = 0;
        if(::System::String::Equals3(tmp_46, _T("Ll"))) tmp_47 = 1;
        if(::System::String::Equals3(tmp_46, _T("Lt"))) tmp_47 = 2;
        if(::System::String::Equals3(tmp_46, _T("Lm"))) tmp_47 = 3;
        if(::System::String::Equals3(tmp_46, _T("Lo"))) tmp_47 = 4;
        if(::System::String::Equals3(tmp_46, _T("Mn"))) tmp_47 = 5;
        if(::System::String::Equals3(tmp_46, _T("Mc"))) tmp_47 = 6;
        if(::System::String::Equals3(tmp_46, _T("Me"))) tmp_47 = 7;
        if(::System::String::Equals3(tmp_46, _T("Nd"))) tmp_47 = 8;
        if(::System::String::Equals3(tmp_46, _T("Nl"))) tmp_47 = 9;
        if(::System::String::Equals3(tmp_46, _T("No"))) tmp_47 = 10;
        if(::System::String::Equals3(tmp_46, _T("Pc"))) tmp_47 = 11;
        if(::System::String::Equals3(tmp_46, _T("Pd"))) tmp_47 = 12;
        if(::System::String::Equals3(tmp_46, _T("Ps"))) tmp_47 = 13;
        if(::System::String::Equals3(tmp_46, _T("Pe"))) tmp_47 = 14;
        if(::System::String::Equals3(tmp_46, _T("Pi"))) tmp_47 = 15;
        if(::System::String::Equals3(tmp_46, _T("Pf"))) tmp_47 = 16;
        if(::System::String::Equals3(tmp_46, _T("Po"))) tmp_47 = 17;
        if(::System::String::Equals3(tmp_46, _T("Sm"))) tmp_47 = 18;
        if(::System::String::Equals3(tmp_46, _T("Sc"))) tmp_47 = 19;
        if(::System::String::Equals3(tmp_46, _T("Sk"))) tmp_47 = 20;
        if(::System::String::Equals3(tmp_46, _T("So"))) tmp_47 = 21;
        if(::System::String::Equals3(tmp_46, _T("Zs"))) tmp_47 = 22;
        if(::System::String::Equals3(tmp_46, _T("Zl"))) tmp_47 = 23;
        if(::System::String::Equals3(tmp_46, _T("Zp"))) tmp_47 = 24;
        if(::System::String::Equals3(tmp_46, _T("Cc"))) tmp_47 = 25;
        if(::System::String::Equals3(tmp_46, _T("Cf"))) tmp_47 = 26;
        if(::System::String::Equals3(tmp_46, _T("Cs"))) tmp_47 = 27;
        if(::System::String::Equals3(tmp_46, _T("Co"))) tmp_47 = 28;
        if(::System::String::Equals3(tmp_46, _T("Cn"))) tmp_47 = 29;
        switch(tmp_47)
        {
            case 0: case_267: 
            {
                return System::Globalization::UnicodeCategory::UppercaseLetter;
            }
            case 1: case_268: 
            {
                return System::Globalization::UnicodeCategory::LowercaseLetter;
            }
            case 2: case_269: 
            {
                return System::Globalization::UnicodeCategory::TitlecaseLetter;
            }
            case 3: case_270: 
            {
                return System::Globalization::UnicodeCategory::ModifierLetter;
            }
            case 4: case_271: 
            {
                return System::Globalization::UnicodeCategory::OtherLetter;
            }
            case 5: case_272: 
            {
                return System::Globalization::UnicodeCategory::NonSpacingMark;
            }
            case 6: case_273: 
            {
                return System::Globalization::UnicodeCategory::SpacingCombiningMark;
            }
            case 7: case_274: 
            {
                return System::Globalization::UnicodeCategory::EnclosingMark;
            }
            case 8: case_275: 
            {
                return System::Globalization::UnicodeCategory::DecimalDigitNumber;
            }
            case 9: case_276: 
            {
                return System::Globalization::UnicodeCategory::LetterNumber;
            }
            case 10: case_277: 
            {
                return System::Globalization::UnicodeCategory::OtherNumber;
            }
            case 11: case_278: 
            {
                return System::Globalization::UnicodeCategory::ConnectorPunctuation;
            }
            case 12: case_279: 
            {
                return System::Globalization::UnicodeCategory::DashPunctuation;
            }
            case 13: case_280: 
            {
                return System::Globalization::UnicodeCategory::OpenPunctuation;
            }
            case 14: case_281: 
            {
                return System::Globalization::UnicodeCategory::ClosePunctuation;
            }
            case 15: case_282: 
            {
                return System::Globalization::UnicodeCategory::InitialQuotePunctuation;
            }
            case 16: case_283: 
            {
                return System::Globalization::UnicodeCategory::FinalQuotePunctuation;
            }
            case 17: case_284: 
            {
                return System::Globalization::UnicodeCategory::OtherPunctuation;
            }
            case 18: case_285: 
            {
                return System::Globalization::UnicodeCategory::MathSymbol;
            }
            case 19: case_286: 
            {
                return System::Globalization::UnicodeCategory::CurrencySymbol;
            }
            case 20: case_287: 
            {
                return System::Globalization::UnicodeCategory::ModifierSymbol;
            }
            case 21: case_288: 
            {
                return System::Globalization::UnicodeCategory::OtherSymbol;
            }
            case 22: case_289: 
            {
                return System::Globalization::UnicodeCategory::SpaceSeparator;
            }
            case 23: case_290: 
            {
                return System::Globalization::UnicodeCategory::LineSeparator;
            }
            case 24: case_291: 
            {
                return System::Globalization::UnicodeCategory::ParagraphSeparator;
            }
            case 25: case_292: 
            {
                return System::Globalization::UnicodeCategory::Control;
            }
            case 26: case_293: 
            {
                return System::Globalization::UnicodeCategory::Format3;
            }
            case 27: case_294: 
            {
                return System::Globalization::UnicodeCategory::Surrogate;
            }
            case 28: case_295: 
            {
                return System::Globalization::UnicodeCategory::PrivateUse;
            }
            case 29: case_296: 
            {
                return System::Globalization::UnicodeCategory::OtherNotAssigned;
            }
        }
        throw cli::gcnew<System::ArgumentException>(System::String::Format2(_T("Unexpected category {0}"), s));
    }
    
    int32_t UnicodeData::_Parse_m__0(System::String* dv) {
        return System::Int32::Parse3(dv, System::Globalization::NumberStyles::HexNumber);
    }
    
}}}
namespace Mono { namespace Globalization { namespace Unicode {
    
    
    void UnicodeDataCodeGeneratorC5_1_0::constructor(UnicodeData* catalog, System::IO::TextWriter* writer) {
        this->catalog = catalog;
        this->w = writer;
    }
    
    void UnicodeDataCodeGeneratorC5_1_0::GenerateStructures() {
        this->w->WriteLine_27fb29d2c5b390c7(_T("/* ======== Structures ======== */"));
        this->w->WriteLine_27fb29d2c5b390c7(_T("typedef struct {\n\tguint32 codepoint;\n\tguint32 upper;\n\tguint32 title;\n} SimpleTitlecaseMapping;"));
        this->w->WriteLine_27fb29d2c5b390c7(_T("typedef struct {\n\tguint32 start;\n\tguint32 end;\n} CodePointRange;"));
        this->w->WriteLine_27fb29d2c5b390c7(_T("typedef struct {\n\tguint32 upper;\n\tguint32 lower;\n} SimpleCaseMapping;"));
    }
    
    void UnicodeDataCodeGeneratorC5_1_0::GenerateCodePointRanges(System::String* name, cli::array<CodePointRange*>* ranges) {
        this->w->WriteLine_b33fb6632b99859a(_T("static const guint8 {0}_count = {1};"), name, cli::box(ranges->get_Length()));
        this->w->WriteLine_5eb6d2f1667d4085(_T("static const CodePointRange {0} [] = {{"), name);
        for(auto tmp_48 : ranges) {
            auto cpr = cli::cast<CodePointRange*>(tmp_48);
            this->w->WriteLine_b33fb6632b99859a(_T("{{0x{0:X06}, 0x{1:X06}}},"), cli::box(cpr->get_Start()), cli::box(cpr->get_End()));
        }
        this->w->WriteLine_27fb29d2c5b390c7(_T("{0, 0}};"));
    }
    
    void UnicodeDataCodeGeneratorC5_1_0::GenerateUnicodeCategoryListC(cli::array<UcdCharacterProperty*>* ucd) {
        this->w->WriteLine_27fb29d2c5b390c7(_T("/* ======== Unicode Categories ======== */"));
        GenerateCodePointRanges(_T("unicode_category_ranges"), this->catalog->get_CategoryRanges_7fff5478a3a668d7());
        int32_t table = 0;
        for(auto tmp_49 : this->catalog->get_CategoryRanges_7fff5478a3a668d7()) {
            auto cpr = cli::cast<CodePointRange*>(tmp_49);
            {
                this->w->WriteLine_5eb6d2f1667d4085(_T("const GUnicodeType unicode_category_table{0} [] = {{"), cli::box(table));
                this->w->WriteLine_b33fb6632b99859a(_T("\t/* ==== {0:X}-{1:X} ==== */"), cli::box(cpr->get_Start()), cli::box(cpr->get_End()));
                this->w->Write_dcf5e45abd9e11c4(_T("\t"));
                int32_t cp = cpr->get_Start();
                for(auto tmp_50 : ucd) {
                    auto ucp = cli::cast<UcdCharacterProperty*>(tmp_50);
                    {
                        if((ucp->get_Codepoint() >= cpr->get_End())) 
                        {
                            break;
                        }
                        if((ucp->get_Codepoint() < cp)) 
                        {
                            continue;
                        }
                        while((cp < ucp->get_Codepoint())) {
                            this->w->Write_dcf5e45abd9e11c4(_T("0,"));
                            if(((++cp % 16) ==  0)) 
                            {
                                this->w->Write_f2bf6875dbaeba6a(_T("\n\t"), cli::box(cp));
                            }
                        }
                        this->w->Write_12c6f74b27421524((int32_t)(ToGUnicodeCategory(ucp->get_Category())));
                        this->w->Write_96ccae6b0b267024(u',');
                        if(((++cp % 16) ==  0)) 
                        {
                            this->w->Write_f2bf6875dbaeba6a(_T("\n\t"), cli::box(cp));
                        }
                        if((cp >= cpr->get_End())) 
                        {
                            break;
                        }
                    }
                }
                this->w->WriteLine_27fb29d2c5b390c7(_T("0};"));
                table++;
            }
        }
        this->w->WriteLine_5eb6d2f1667d4085(_T("static const GUnicodeType *unicode_category [{0}]  = {{"), cli::box(this->catalog->get_CategoryRanges_7fff5478a3a668d7()->get_Length()));
        for(int32_t i = 0, end = this->catalog->get_CategoryRanges_7fff5478a3a668d7()->get_Length(); (i < end); i++) {
            this->w->WriteLine_b33fb6632b99859a(_T("\tunicode_category_table{0}{1}"), cli::box(i), ((i + 1) < end) ? _T(",") : System::String::Empty);
        }
        this->w->WriteLine_27fb29d2c5b390c7(_T("};"));
    }
    
    void UnicodeDataCodeGeneratorC5_1_0::GenerateSimpleTitlecaseMappingListC(cli::array<UcdCharacterProperty*>* ucd) {
        this->w->WriteLine_27fb29d2c5b390c7(_T("static const SimpleTitlecaseMapping simple_titlecase_mapping [] = {"));
        int32_t count = 0;
        for(auto tmp_51 : ucd) {
            auto ucp = cli::cast<UcdCharacterProperty*>(tmp_51);
            {
                if((ucp->get_SimpleUppercaseMapping() ==  ucp->get_SimpleTitlecaseMapping())) 
                {
                    continue;
                }
                if((count > 0)) 
                {
                    this->w->WriteLine_5db503756aad6b7e(u',');
                }
                this->w->Write_4d2ac9c7b9e5e3b6(_T("\t{{0x{0:X06}, 0x{1:X06}, 0x{2:X06}}}"), cli::box(ucp->get_Codepoint()), cli::box(ucp->get_SimpleUppercaseMapping()), cli::box(ucp->get_SimpleTitlecaseMapping()));
                count++;
            }
        }
        this->w->WriteLine_f0ca76dc02634177();
        this->w->WriteLine_27fb29d2c5b390c7(_T("};"));
        this->w->WriteLine_5eb6d2f1667d4085(_T("static const guint8 simple_titlecase_mapping_count = {0};"), cli::box(count));
    }
    
    void UnicodeDataCodeGeneratorC5_1_0::GenerateSimpleCaseMappingListC(cli::array<UcdCharacterProperty*>* ucd) {
        GenerateCodePointRanges(_T("simple_case_map_ranges"), this->catalog->get_SimpleCases_2325e5522320db2d());
        GenerateSimpleCaseMappingListC2(ucd, true, true);
        GenerateSimpleCaseMappingListC2(ucd, true, false);
        GenerateSimpleCaseMappingListC2(ucd, false, true);
        GenerateSimpleCaseMappingListC2(ucd, false, false);
    }
    
    void UnicodeDataCodeGeneratorC5_1_0::GenerateSimpleCaseMappingListC2(cli::array<UcdCharacterProperty*>* ucd, bool upper, bool small) {
        int32_t nTable = 0;
        for(auto tmp_52 : this->catalog->get_SimpleCases_2325e5522320db2d()) {
            auto cpr = cli::cast<CodePointRange*>(tmp_52);
            {
                if((small && (cpr->get_Start() > 65535))) 
                {
                    break;
                }
                if((!(small) && (cpr->get_Start() < 65536))) 
                {
                    continue;
                }
                this->w->WriteLine_b743f1a08f47f965(_T("static const {0} simple_{1}_case_mapping_{2}_table{3} [] = {{"), (new cli::array<System::Object*>({small ? _T("guint16") : _T("guint32"), upper ? _T("upper") : _T("lower"), small ? _T("lowarea") : _T("higharea"), cli::box(nTable)})));
                this->w->WriteLine_b33fb6632b99859a(_T("\t/* ==== {0:X}-{1:X} ==== */"), cli::box(cpr->get_Start()), cli::box(cpr->get_End()));
                this->w->Write_dcf5e45abd9e11c4(_T("\t"));
                int32_t cp = cpr->get_Start();
                for(auto tmp_53 : ucd) {
                    auto ucp = cli::cast<UcdCharacterProperty*>(tmp_53);
                    {
                        if((ucp->get_Codepoint() >= cpr->get_End())) 
                        {
                            break;
                        }
                        if((ucp->get_Codepoint() < cp)) 
                        {
                            continue;
                        }
                        while((cp < ucp->get_Codepoint())) {
                            this->w->Write_dcf5e45abd9e11c4(_T("0,"));
                            if(((++cp % 16) ==  0)) 
                            {
                                this->w->WriteLine_f0ca76dc02634177();
                            }
                        }
                        int32_t v = upper ? ucp->get_SimpleUppercaseMapping() : ucp->get_SimpleLowercaseMapping();
                        if((v != 0)) 
                        {
                            this->w->Write_f2bf6875dbaeba6a(_T("0x{0:X},"), cli::box(v));
                        }
                         else 
                        {
                            this->w->Write_dcf5e45abd9e11c4(_T("0,"));
                        }
                        if(((++cp % 16) ==  0)) 
                        {
                            this->w->WriteLine_f0ca76dc02634177();
                            this->w->Write_dcf5e45abd9e11c4(_T("\t"));
                        }
                        if((cp >= cpr->get_End())) 
                        {
                            break;
                        }
                    }
                }
                this->w->WriteLine_27fb29d2c5b390c7(_T("0};"));
                nTable++;
            }
        }
        this->w->WriteLine_10ed8cd26a3939e1(_T("static const {0} *simple_{1}_case_mapping_{2} [] = {{"), small ? _T("guint16") : _T("guint32"), upper ? _T("upper") : _T("lower"), small ? _T("lowarea") : _T("higharea"));
        for(int32_t i = 0; (i < nTable); i++){
            if((i > 0)) 
            {
                this->w->WriteLine_27fb29d2c5b390c7(_T(","));
            }
            this->w->Write_4d2ac9c7b9e5e3b6(_T("\tstatic const guint8 simple_{0}_case_mapping_{1}_table{2}"), upper ? _T("upper") : _T("lower"), small ? _T("lowarea") : _T("higharea"), cli::box(i));
        }
        this->w->WriteLine_27fb29d2c5b390c7(_T("};"));
        this->w->WriteLine_f0ca76dc02634177();
    }
    
    GUnicodeType UnicodeDataCodeGeneratorC5_1_0::ToGUnicodeCategory(System::Globalization::UnicodeCategory v) {
        switch(v) {
            case System::Globalization::UnicodeCategory::UppercaseLetter: case_297: {
                return GUnicodeType::G_UNICODE_UPPERCASE_LETTER;
            }
            case System::Globalization::UnicodeCategory::LowercaseLetter: case_298: {
                return GUnicodeType::G_UNICODE_LOWERCASE_LETTER;
            }
            case System::Globalization::UnicodeCategory::TitlecaseLetter: case_299: {
                return GUnicodeType::G_UNICODE_TITLECASE_LETTER;
            }
            case System::Globalization::UnicodeCategory::ModifierLetter: case_300: {
                return GUnicodeType::G_UNICODE_MODIFIER_LETTER;
            }
            case System::Globalization::UnicodeCategory::OtherLetter: case_301: {
                return GUnicodeType::G_UNICODE_OTHER_LETTER;
            }
            case System::Globalization::UnicodeCategory::NonSpacingMark: case_302: {
                return GUnicodeType::G_UNICODE_NON_SPACING_MARK;
            }
            case System::Globalization::UnicodeCategory::SpacingCombiningMark: case_303: {
                return GUnicodeType::G_UNICODE_COMBINING_MARK;
            }
            case System::Globalization::UnicodeCategory::EnclosingMark: case_304: {
                return GUnicodeType::G_UNICODE_ENCLOSING_MARK;
            }
            case System::Globalization::UnicodeCategory::DecimalDigitNumber: case_305: {
                return GUnicodeType::G_UNICODE_DECIMAL_NUMBER;
            }
            case System::Globalization::UnicodeCategory::LetterNumber: case_306: {
                return GUnicodeType::G_UNICODE_LETTER_NUMBER;
            }
            case System::Globalization::UnicodeCategory::OtherNumber: case_307: {
                return GUnicodeType::G_UNICODE_OTHER_NUMBER;
            }
            case System::Globalization::UnicodeCategory::ConnectorPunctuation: case_308: {
                return GUnicodeType::G_UNICODE_CONNECT_PUNCTUATION;
            }
            case System::Globalization::UnicodeCategory::DashPunctuation: case_309: {
                return GUnicodeType::G_UNICODE_DASH_PUNCTUATION;
            }
            case System::Globalization::UnicodeCategory::OpenPunctuation: case_310: {
                return GUnicodeType::G_UNICODE_OPEN_PUNCTUATION;
            }
            case System::Globalization::UnicodeCategory::ClosePunctuation: case_311: {
                return GUnicodeType::G_UNICODE_CLOSE_PUNCTUATION;
            }
            case System::Globalization::UnicodeCategory::InitialQuotePunctuation: case_312: {
                return GUnicodeType::G_UNICODE_INITIAL_PUNCTUATION;
            }
            case System::Globalization::UnicodeCategory::FinalQuotePunctuation: case_313: {
                return GUnicodeType::G_UNICODE_FINAL_PUNCTUATION;
            }
            case System::Globalization::UnicodeCategory::OtherPunctuation: case_314: {
                return GUnicodeType::G_UNICODE_OTHER_PUNCTUATION;
            }
            case System::Globalization::UnicodeCategory::MathSymbol: case_315: {
                return GUnicodeType::G_UNICODE_MATH_SYMBOL;
            }
            case System::Globalization::UnicodeCategory::CurrencySymbol: case_316: {
                return GUnicodeType::G_UNICODE_CURRENCY_SYMBOL;
            }
            case System::Globalization::UnicodeCategory::ModifierSymbol: case_317: {
                return GUnicodeType::G_UNICODE_MODIFIER_SYMBOL;
            }
            case System::Globalization::UnicodeCategory::OtherSymbol: case_318: {
                return GUnicodeType::G_UNICODE_OTHER_SYMBOL;
            }
            case System::Globalization::UnicodeCategory::SpaceSeparator: case_319: {
                return GUnicodeType::G_UNICODE_SPACE_SEPARATOR;
            }
            case System::Globalization::UnicodeCategory::LineSeparator: case_320: {
                return GUnicodeType::G_UNICODE_LINE_SEPARATOR;
            }
            case System::Globalization::UnicodeCategory::ParagraphSeparator: case_321: {
                return GUnicodeType::G_UNICODE_PARAGRAPH_SEPARATOR;
            }
            case System::Globalization::UnicodeCategory::Control: case_322: {
                return GUnicodeType::G_UNICODE_CONTROL;
            }
            case System::Globalization::UnicodeCategory::Format3: case_323: {
                return GUnicodeType::G_UNICODE_FORMAT;
            }
            case System::Globalization::UnicodeCategory::Surrogate: case_324: {
                return GUnicodeType::G_UNICODE_SURROGATE;
            }
            case System::Globalization::UnicodeCategory::PrivateUse: case_325: {
                return GUnicodeType::G_UNICODE_PRIVATE_USE;
            }
            case System::Globalization::UnicodeCategory::OtherNotAssigned: case_326: {
                return GUnicodeType::G_UNICODE_UNASSIGNED;
            }
        }
        throw cli::gcnew<System::ArgumentException>(System::String::Format2(_T("Unexpected category {0}"), cli::box(v)));
    }
    
}}}
namespace Mono { namespace Globalization { namespace Unicode {
    
    
    void CodePointRange::constructor(int32_t start, int32_t end) {
        this->set_Start(start);
        this->set_End(end);
    }
    
    int32_t CodePointRange::get_Start() {
        return this->_Start_k__BackingField;
    }
    
    int32_t CodePointRange::set_Start(int32_t value) {
        this->_Start_k__BackingField = value;
        return get_Start();
    }
    
    int32_t CodePointRange::get_End() {
        return this->_End_k__BackingField;
    }
    
    int32_t CodePointRange::set_End(int32_t value) {
        this->_End_k__BackingField = value;
        return get_End();
    }
    
}}}
namespace Mono { namespace Globalization { namespace Unicode {
    
    
    void UcdCharacterProperty::constructor() {
    }
    
    int32_t UcdCharacterProperty::get_Codepoint() {
        return this->_Codepoint_k__BackingField;
    }
    
    int32_t UcdCharacterProperty::set_Codepoint(int32_t value) {
        this->_Codepoint_k__BackingField = value;
        return get_Codepoint();
    }
    
    System::String* UcdCharacterProperty::get_Name() {
        return this->_Name_k__BackingField;
    }
    
    System::String* UcdCharacterProperty::set_Name(System::String* value) {
        this->_Name_k__BackingField = value;
        return get_Name();
    }
    
    System::Globalization::UnicodeCategory UcdCharacterProperty::get_Category() {
        return this->_Category_k__BackingField;
    }
    
    System::Globalization::UnicodeCategory UcdCharacterProperty::set_Category(System::Globalization::UnicodeCategory value) {
        this->_Category_k__BackingField = value;
        return get_Category();
    }
    
    System::Nullable2<unsigned char> UcdCharacterProperty::get_CanonicalCombiningClass() {
        return this->_CanonicalCombiningClass_k__BackingField;
    }
    
    System::Nullable2<unsigned char> UcdCharacterProperty::set_CanonicalCombiningClass(System::Nullable2<unsigned char> value) {
        this->_CanonicalCombiningClass_k__BackingField = value;
        return get_CanonicalCombiningClass();
    }
    
    UcdBidiClass UcdCharacterProperty::get_BidiClass() {
        return this->_BidiClass_k__BackingField;
    }
    
    UcdBidiClass UcdCharacterProperty::set_BidiClass(UcdBidiClass value) {
        this->_BidiClass_k__BackingField = value;
        return get_BidiClass();
    }
    
    UcdDecompositionType UcdCharacterProperty::get_DecompositionType() {
        return this->_DecompositionType_k__BackingField;
    }
    
    UcdDecompositionType UcdCharacterProperty::set_DecompositionType(UcdDecompositionType value) {
        this->_DecompositionType_k__BackingField = value;
        return get_DecompositionType();
    }
    
    cli::array<int32_t>* UcdCharacterProperty::get_DecompositionMapping() {
        return this->_DecompositionMapping_k__BackingField;
    }
    
    cli::array<int32_t>* UcdCharacterProperty::set_DecompositionMapping(cli::array<int32_t>* value) {
        this->_DecompositionMapping_k__BackingField = value;
        return get_DecompositionMapping();
    }
    
    System::String* UcdCharacterProperty::get_DecimalDigitValue() {
        return this->_DecimalDigitValue_k__BackingField;
    }
    
    System::String* UcdCharacterProperty::set_DecimalDigitValue(System::String* value) {
        this->_DecimalDigitValue_k__BackingField = value;
        return get_DecimalDigitValue();
    }
    
    System::String* UcdCharacterProperty::get_DigitValue() {
        return this->_DigitValue_k__BackingField;
    }
    
    System::String* UcdCharacterProperty::set_DigitValue(System::String* value) {
        this->_DigitValue_k__BackingField = value;
        return get_DigitValue();
    }
    
    System::String* UcdCharacterProperty::get_NumericValue() {
        return this->_NumericValue_k__BackingField;
    }
    
    System::String* UcdCharacterProperty::set_NumericValue(System::String* value) {
        this->_NumericValue_k__BackingField = value;
        return get_NumericValue();
    }
    
    bool UcdCharacterProperty::get_BidiMirrored() {
        return this->_BidiMirrored_k__BackingField;
    }
    
    bool UcdCharacterProperty::set_BidiMirrored(bool value) {
        this->_BidiMirrored_k__BackingField = value;
        return get_BidiMirrored();
    }
    
    System::String* UcdCharacterProperty::get_Unicode1Name() {
        return this->_Unicode1Name_k__BackingField;
    }
    
    System::String* UcdCharacterProperty::set_Unicode1Name(System::String* value) {
        this->_Unicode1Name_k__BackingField = value;
        return get_Unicode1Name();
    }
    
    System::String* UcdCharacterProperty::get_IsoComment() {
        return this->_IsoComment_k__BackingField;
    }
    
    System::String* UcdCharacterProperty::set_IsoComment(System::String* value) {
        this->_IsoComment_k__BackingField = value;
        return get_IsoComment();
    }
    
    int32_t UcdCharacterProperty::get_SimpleUppercaseMapping() {
        return this->_SimpleUppercaseMapping_k__BackingField;
    }
    
    int32_t UcdCharacterProperty::set_SimpleUppercaseMapping(int32_t value) {
        this->_SimpleUppercaseMapping_k__BackingField = value;
        return get_SimpleUppercaseMapping();
    }
    
    int32_t UcdCharacterProperty::get_SimpleLowercaseMapping() {
        return this->_SimpleLowercaseMapping_k__BackingField;
    }
    
    int32_t UcdCharacterProperty::set_SimpleLowercaseMapping(int32_t value) {
        this->_SimpleLowercaseMapping_k__BackingField = value;
        return get_SimpleLowercaseMapping();
    }
    
    int32_t UcdCharacterProperty::get_SimpleTitlecaseMapping() {
        return this->_SimpleTitlecaseMapping_k__BackingField;
    }
    
    int32_t UcdCharacterProperty::set_SimpleTitlecaseMapping(int32_t value) {
        this->_SimpleTitlecaseMapping_k__BackingField = value;
        return get_SimpleTitlecaseMapping();
    }
    
}}}
namespace Mono { namespace Interop {
    
    
    void ComInteropProxy::constructor(System::Type* t) {
        this->com_object = System::__ComObject::CreateRCW(t);
    }
    
    void ComInteropProxy::constructor(void* pUnk) {
    }
    
    void ComInteropProxy::constructor(void* pUnk, System::Type* t) {
        this->com_object = cli::gcnew<System::__ComObject>(pUnk);
        CacheProxy();
    }
    
    void ComInteropProxy::AddProxy(void* pItf, ComInteropProxy* proxy) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    ComInteropProxy* ComInteropProxy::FindProxy(void* pItf) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void ComInteropProxy::CacheProxy() {
        if((FindProxy(this->com_object->get_IUnknown()) ==  nullptr)) 
        {
            AddProxy(this->com_object->get_IUnknown(), this);
        }
         else 
        {
            System::Threading::Interlocked::Increment(this->ref_count);
        }
    }
    
    ComInteropProxy* ComInteropProxy::GetProxy(void* pItf, System::Type* t) {
        void *ppv;
        System::Guid iid = System::__ComObject::get_IID_IUnknown();
        int32_t hr = System::Runtime::InteropServices::Marshal::QueryInterface(pItf, iid, ppv);
        System::Runtime::InteropServices::Marshal::ThrowExceptionForHR(hr);
        ComInteropProxy *obj = FindProxy(ppv);
        if((obj ==  nullptr)) 
        {
            System::Runtime::InteropServices::Marshal::Release(pItf);
            return cli::gcnew<ComInteropProxy>(ppv);
        }
         else 
        {
            System::Runtime::InteropServices::Marshal::Release(pItf);
            System::Threading::Interlocked::Increment(obj->ref_count);
            return obj;
        }
    }
    
    ComInteropProxy* ComInteropProxy::CreateProxy(System::Type* t) {
        ComInteropProxy *proxy = cli::gcnew<ComInteropProxy>(t);
        proxy->com_object->Initialize(t);
        ComInteropProxy *cachedProxy = FindProxy(proxy->com_object->get_IUnknown());
        if((cachedProxy != nullptr)) 
        {
            System::Type *cachedType = cachedProxy->com_object->GetType();
            if(System::Type::op_Inequality2(cachedType, t)) 
            {
                throw cli::gcnew<System::InvalidCastException>(System::String::Format3(_T("Unable to cast object of type \'{0}\' to type \'{1}\'."), cachedType, t));
            }
            return cachedProxy;
        }
        return proxy;
    }
    
    System::Runtime::Remoting::Messaging::IMessage* ComInteropProxy::Invoke_fb5532e107d73b9f(System::Runtime::Remoting::Messaging::IMessage* msg) {
        System::Console::WriteLine11(_T("Invoke"));
        System::Console::WriteLine11(System::Environment::get_StackTrace());
        throw cli::gcnew<System::Exception>(_T("The method or operation is not implemented."));
    }
    
    bool ComInteropProxy::CanCastTo(System::Type* fromType, System::Object* o) {
        System::__ComObject *co = cli::as<System::__ComObject*>(o);
        if((co ==  nullptr)) 
        {
            throw cli::gcnew<System::NotSupportedException>(_T("Only RCWs are currently supported"));
        }
        if(((int32_t)(((int32_t)(fromType->get_Attributes()) & 4096)) ==  0)) 
        {
            return false;
        }
        if(::System::IntPtr::op_Equality(co->GetInterface(fromType, false), (*::System::IntPtr::Zero))) 
        {
            return false;
        }
        return true;
    }
    
    System::String* ComInteropProxy::get_TypeName() {
        return this->type_name;
    }
    
    System::String* ComInteropProxy::set_TypeName(System::String* value) {
        this->type_name = value;
        return get_TypeName();
    }
    
}}
namespace Mono { namespace Math {
    
    
    void ModulusRing::constructor(BigInteger* modulus) {
        this->mod = modulus;
        uint32_t i = (this->mod->length << 1);
        this->constant = cli::gcnew<BigInteger>(Sign::Positive, (i + 1U));
        this->constant->data->at((int32_t)i) = 1U;
        this->constant = BigInteger::op_Division2(this->constant, this->mod);
    }
    
    void ModulusRing::BarrettReduction(BigInteger* x) {
        BigInteger *n = this->mod;
        uint32_t k = n->length, kPlusOne = (k + 1U), kMinusOne = (k - 1U);
        if((x->length < k)) 
        {
            return;
        }
        BigInteger *q3;
        if(((int64_t)(x->data->get_Length()) < (int64_t)(x->length))) 
        {
            throw cli::gcnew<System::IndexOutOfRangeException>(_T("x out of range"));
        }
        q3 = cli::gcnew<BigInteger>(Sign::Positive, ((x->length - kMinusOne) + this->constant->length));
        Kernel::Multiply(x->data, kMinusOne, (x->length - kMinusOne), this->constant->data, 0U, this->constant->length, q3->data, 0U);
        uint32_t lengthToCopy = (x->length > kPlusOne) ? kPlusOne : x->length;
        x->length = lengthToCopy;
        x->Normalize();
        BigInteger *r2 = cli::gcnew<BigInteger>(Sign::Positive, kPlusOne);
        Kernel::MultiplyMod2p32pmod(q3->data, (int32_t)kPlusOne, ((int32_t)q3->length - (int32_t)kPlusOne), n->data, 0, (int32_t)n->length, r2->data, 0, (int32_t)kPlusOne);
        r2->Normalize();
        if(BigInteger::op_LessThanOrEqual(r2, x)) 
        {
            Kernel::MinusEq(x, r2);
        }
         else 
        {
            BigInteger *val = cli::gcnew<BigInteger>(Sign::Positive, (kPlusOne + 1U));
            val->data->at((int32_t)kPlusOne) = 1U;
            Kernel::MinusEq(val, r2);
            Kernel::PlusEq(x, val);
        }
        while(BigInteger::op_GreaterThanOrEqual(x, n)) Kernel::MinusEq(x, n);
    }
    
    BigInteger* ModulusRing::Multiply(BigInteger* a, BigInteger* b) {
        if((BigInteger::op_Equality(a, 0U) || BigInteger::op_Equality(b, 0U))) 
        {
            return BigInteger::op_Implicit2(0);
        }
        if(BigInteger::op_GreaterThan(a, this->mod)) 
        {
            (a = BigInteger::op_Modulus3(a, this->mod));
        }
        if(BigInteger::op_GreaterThan(b, this->mod)) 
        {
            (b = BigInteger::op_Modulus3(b, this->mod));
        }
        BigInteger *ret = BigInteger::op_Multiply(a, b);
        BarrettReduction(ret);
        return ret;
    }
    
    BigInteger* ModulusRing::Difference(BigInteger* a, BigInteger* b) {
        Sign cmp = Kernel::Compare(a, b);
        BigInteger *diff;
        switch(cmp) {
            case Sign::Zero: case_327: {
                return BigInteger::op_Implicit2(0);
            }
            case Sign::Positive: case_328: {
                diff = BigInteger::op_Subtraction(a, b);
                break;
            }
            case Sign::Negative: case_329: {
                diff = BigInteger::op_Subtraction(b, a);
                break;
            }
            default: case_330: {
                throw cli::gcnew<System::Exception>();
            }
        }
        if(BigInteger::op_GreaterThanOrEqual(diff, this->mod)) 
        {
            if((diff->length >= (this->mod->length << 1))) 
            {
                (diff = BigInteger::op_Modulus3(diff, this->mod));
            }
             else 
            {
                BarrettReduction(diff);
            }
        }
        if(((int32_t)(cmp) ==  -1)) 
        {
            diff = BigInteger::op_Subtraction(this->mod, diff);
        }
        return diff;
    }
    
    BigInteger* ModulusRing::Pow(BigInteger* a, BigInteger* k) {
        BigInteger *b = cli::gcnew<BigInteger>(1U);
        if(BigInteger::op_Equality(k, 0U)) 
        {
            return b;
        }
        BigInteger *A = a;
        if(k->TestBit2(0)) 
        {
            b = a;
        }
        for(int32_t i = 1; (i < k->BitCount()); i++){
            A = Multiply(A, A);
            if(k->TestBit2(i)) 
            {
                b = Multiply(A, b);
            }
        }
        return b;
    }
    
    BigInteger* ModulusRing::Pow2(uint32_t b, BigInteger* exp) {
        return Pow(cli::gcnew<BigInteger>(b), exp);
    }
    
}}
namespace Mono { namespace Math {
    
    
    void Kernel::constructor() {
    }
    
    BigInteger* Kernel::AddSameSign(BigInteger* bi1, BigInteger* bi2) {
        cli::array<uint32_t> *x, *y;
        uint32_t yMax, xMax, i = 0U;
        if((bi1->length < bi2->length)) 
        {
            x = bi2->data;
            xMax = bi2->length;
            y = bi1->data;
            yMax = bi1->length;
        }
         else 
        {
            x = bi1->data;
            xMax = bi1->length;
            y = bi2->data;
            yMax = bi2->length;
        }
        BigInteger *result = cli::gcnew<BigInteger>(Sign::Positive, (xMax + 1U));
        cli::array<uint32_t> *r = result->data;
        uint64_t sum = 0UL;
        do {
            sum = (((uint64_t)(x->at((int32_t)i)) + (uint64_t)(y->at((int32_t)i))) + sum);
            r->at((int32_t)i) = (uint32_t)sum;
            (sum = sum >> 32);
        }
        while((++i < yMax));
        bool carry = (sum != 0UL);
        if(carry) 
        {
            if((i < xMax)) 
            {
                do carry = ((r->at((int32_t)i) = (x->at((int32_t)i) + 1U)) ==  (0U));
                while(((++i < xMax) && carry));
            }
            if(carry) 
            {
                r->at((int32_t)i) = 1U;
                result->length = ++i;
                return result;
            }
        }
        if((i < xMax)) 
        {
            do r->at((int32_t)i) = x->at((int32_t)i);
            while((++i < xMax));
        }
        result->Normalize();
        return result;
    }
    
    BigInteger* Kernel::Subtract(BigInteger* big, BigInteger* small) {
        BigInteger *result = cli::gcnew<BigInteger>(Sign::Positive, big->length);
        cli::array<uint32_t> *r = result->data, *b = big->data, *s = small->data;
        uint32_t i = 0U, c = 0U;
        do {
            uint32_t x = s->at((int32_t)i);
            if((((x = x + c) < c) | ((r->at((int32_t)i) = (b->at((int32_t)i) - x)) > (~(x))))) 
            {
                c = 1U;
            }
             else 
            {
                c = 0U;
            }
        }
        while((++i < small->length));
        if((i ==  big->length)) 
        {
            goto fixup;
        }
        if((c ==  1U)) 
        {
            do r->at((int32_t)i) = (b->at((int32_t)i) - 1U);
            while(((b->at((int32_t)i++) ==  0U) && (i < big->length)));
            if((i ==  big->length)) 
            {
                goto fixup;
            }
        }
        do r->at((int32_t)i) = b->at((int32_t)i);
        while((++i < big->length));
        fixup:
        result->Normalize();
        return result;
    }
    
    void Kernel::MinusEq(BigInteger* big, BigInteger* small) {
        cli::array<uint32_t> *b = big->data, *s = small->data;
        uint32_t i = 0U, c = 0U;
        do {
            uint32_t x = s->at((int32_t)i);
            if((((x = x + c) < c) | ((b->at((int32_t)i) = b->at((int32_t)i) - x) > ~(x)))) 
            {
                c = 1U;
            }
             else 
            {
                c = 0U;
            }
        }
        while((++i < small->length));
        if((i ==  big->length)) 
        {
            goto fixup;
        }
        if((c ==  1U)) 
        {
            do b->at((int32_t)i)--;
            while(((b->at((int32_t)i++) ==  0U) && (i < big->length)));
        }
        fixup:
        while(((big->length > 0U) && (big->data->at((int32_t)(big->length - 1U)) ==  0U))) big->length--;
        if((big->length ==  0U)) 
        {
            big->length++;
        }
    }
    
    void Kernel::PlusEq(BigInteger* bi1, BigInteger* bi2) {
        cli::array<uint32_t> *x, *y;
        uint32_t yMax, xMax, i = 0U;
        bool flag = false;
        if((bi1->length < bi2->length)) 
        {
            flag = true;
            x = bi2->data;
            xMax = bi2->length;
            y = bi1->data;
            yMax = bi1->length;
        }
         else 
        {
            x = bi1->data;
            xMax = bi1->length;
            y = bi2->data;
            yMax = bi2->length;
        }
        cli::array<uint32_t> *r = bi1->data;
        uint64_t sum = 0UL;
        do {
            (sum = sum + ((uint64_t)(x->at((int32_t)i)) + (uint64_t)(y->at((int32_t)i))));
            r->at((int32_t)i) = (uint32_t)sum;
            (sum = sum >> 32);
        }
        while((++i < yMax));
        bool carry = (sum != 0UL);
        if(carry) 
        {
            if((i < xMax)) 
            {
                do carry = ((r->at((int32_t)i) = (x->at((int32_t)i) + 1U)) ==  (0U));
                while(((++i < xMax) && carry));
            }
            if(carry) 
            {
                r->at((int32_t)i) = 1U;
                bi1->length = ++i;
                return;
            }
        }
        if((flag && (i < (xMax - 1U)))) 
        {
            do r->at((int32_t)i) = x->at((int32_t)i);
            while((++i < xMax));
        }
        bi1->length = (xMax + 1U);
        bi1->Normalize();
    }
    
    Sign Kernel::Compare(BigInteger* bi1, BigInteger* bi2) {
        uint32_t l1 = bi1->length, l2 = bi2->length;
        while(((l1 > 0U) && (bi1->data->at((int32_t)(l1 - 1U)) ==  0U))) l1--;
        while(((l2 > 0U) && (bi2->data->at((int32_t)(l2 - 1U)) ==  0U))) l2--;
        if(((l1 ==  0U) && (l2 ==  0U))) 
        {
            return Sign::Zero;
        }
        if((l1 < l2)) 
        {
            return Sign::Negative;
        }
         else 
        {
            if((l1 > l2)) 
            {
                return Sign::Positive;
            }
        }
        uint32_t pos = (l1 - 1U);
        while(((pos != 0U) && (bi1->data->at((int32_t)pos) ==  bi2->data->at((int32_t)pos)))) pos--;
        if((bi1->data->at((int32_t)pos) < bi2->data->at((int32_t)pos))) 
        {
            return Sign::Negative;
        }
         else 
        {
            if((bi1->data->at((int32_t)pos) > bi2->data->at((int32_t)pos))) 
            {
                return Sign::Positive;
            }
             else 
            {
                return Sign::Zero;
            }
        }
    }
    
    uint32_t Kernel::SingleByteDivideInPlace(BigInteger* n, uint32_t d) {
        uint64_t r = 0UL;
        uint32_t i = n->length;
        while((i-- > 0U)) {
            (r = r << 32);
            (r = r | (uint64_t)(n->data->at((int32_t)i)));
            n->data->at((int32_t)i) = (uint32_t)(r / (uint64_t)(d));
            (r = r % (uint64_t)(d));
        }
        n->Normalize();
        return (uint32_t)r;
    }
    
    uint32_t Kernel::DwordMod(BigInteger* n, uint32_t d) {
        uint64_t r = 0UL;
        uint32_t i = n->length;
        while((i-- > 0U)) {
            (r = r << 32);
            (r = r | (uint64_t)(n->data->at((int32_t)i)));
            (r = r % (uint64_t)(d));
        }
        return (uint32_t)r;
    }
    
    BigInteger* Kernel::DwordDiv(BigInteger* n, uint32_t d) {
        BigInteger *ret = cli::gcnew<BigInteger>(Sign::Positive, n->length);
        uint64_t r = 0UL;
        uint32_t i = n->length;
        while((i-- > 0U)) {
            (r = r << 32);
            (r = r | (uint64_t)(n->data->at((int32_t)i)));
            ret->data->at((int32_t)i) = (uint32_t)(r / (uint64_t)(d));
            (r = r % (uint64_t)(d));
        }
        ret->Normalize();
        return ret;
    }
    
    cli::array<BigInteger*>* Kernel::DwordDivMod(BigInteger* n, uint32_t d) {
        BigInteger *ret = cli::gcnew<BigInteger>(Sign::Positive, n->length);
        uint64_t r = 0UL;
        uint32_t i = n->length;
        while((i-- > 0U)) {
            (r = r << 32);
            (r = r | (uint64_t)(n->data->at((int32_t)i)));
            ret->data->at((int32_t)i) = (uint32_t)(r / (uint64_t)(d));
            (r = r % (uint64_t)(d));
        }
        ret->Normalize();
        BigInteger *rem = BigInteger::op_Implicit((uint32_t)r);
        return (new cli::array<BigInteger*>({ret, rem}));
    }
    
    cli::array<BigInteger*>* Kernel::multiByteDivide(BigInteger* bi1, BigInteger* bi2) {
        if(((int32_t)(Kernel::Compare(bi1, bi2)) ==  -1)) 
        {
            return (new cli::array<BigInteger*>({BigInteger::op_Implicit2(0), cli::gcnew<BigInteger>(bi1)}));
        }
        bi1->Normalize();
        bi2->Normalize();
        if((bi2->length ==  1U)) 
        {
            return DwordDivMod(bi1, bi2->data->at(0));
        }
        uint32_t remainderLen = (bi1->length + 1U);
        int32_t divisorLen = ((int32_t)bi2->length + 1);
        uint32_t mask = 2147483648U;
        uint32_t val = bi2->data->at((int32_t)(bi2->length - 1U));
        int32_t shift = 0;
        int32_t resultPos = ((int32_t)bi1->length - (int32_t)bi2->length);
        while(((mask != 0U) && ((val & mask) ==  0U))) {
            shift++;
            (mask = mask >> 1);
        }
        BigInteger *quot = cli::gcnew<BigInteger>(Sign::Positive, ((bi1->length - bi2->length) + 1U));
        BigInteger *rem = BigInteger::op_LeftShift(bi1, shift);
        cli::array<uint32_t> *remainder = rem->data;
        bi2 = BigInteger::op_LeftShift(bi2, shift);
        int32_t j = (int32_t)(remainderLen - bi2->length);
        int32_t pos = ((int32_t)remainderLen - 1);
        uint32_t firstDivisorByte = bi2->data->at((int32_t)(bi2->length - 1U));
        uint64_t secondDivisorByte = (uint64_t)(bi2->data->at((int32_t)(bi2->length - 2U)));
        while((j > 0)) {
            uint64_t dividend = (((uint64_t)(remainder->at(pos)) << 32) + (uint64_t)(remainder->at((pos - 1))));
            uint64_t q_hat = (dividend / (uint64_t)(firstDivisorByte));
            uint64_t r_hat = (dividend % (uint64_t)(firstDivisorByte));
            do {
                if(((q_hat ==  4294967296UL) || ((q_hat * secondDivisorByte) > ((r_hat << 32) + (uint64_t)(remainder->at((pos - 2))))))) 
                {
                    q_hat--;
                    (r_hat = r_hat + (uint64_t)(firstDivisorByte));
                    if((r_hat < 4294967296UL)) 
                    {
                        continue;
                    }
                }
                break;
            }
            while(true);
            uint32_t t;
            uint32_t dPos = 0U;
            int32_t nPos = ((pos - divisorLen) + 1);
            uint64_t mc = 0UL;
            uint32_t uint_q_hat = (uint32_t)q_hat;
            do {
                (mc = mc + ((uint64_t)(bi2->data->at((int32_t)dPos)) * (uint64_t)(uint_q_hat)));
                t = remainder->at(nPos);
                (remainder->at(nPos) = remainder->at(nPos) - (uint32_t)mc);
                (mc = mc >> 32);
                if((remainder->at(nPos) > t)) 
                {
                    mc++;
                }
                dPos++;
                nPos++;
            }
            while(((int64_t)(dPos) < (int64_t)(divisorLen)));
            nPos = ((pos - divisorLen) + 1);
            dPos = 0U;
            if((mc != 0UL)) 
            {
                uint_q_hat--;
                uint64_t sum = 0UL;
                do {
                    sum = (((uint64_t)(remainder->at(nPos)) + (uint64_t)(bi2->data->at((int32_t)dPos))) + sum);
                    remainder->at(nPos) = (uint32_t)sum;
                    (sum = sum >> 32);
                    dPos++;
                    nPos++;
                }
                while(((int64_t)(dPos) < (int64_t)(divisorLen)));
            }
            quot->data->at(resultPos--) = (uint32_t)(uint_q_hat);
            pos--;
            j--;
        }
        quot->Normalize();
        rem->Normalize();
        if((shift != 0)) 
        {
            (rem = BigInteger::op_RightShift(rem, shift));
        }
        return (new cli::array<BigInteger*>({quot, rem}));
    }
    
    BigInteger* Kernel::LeftShift(BigInteger* bi, int32_t n) {
        if((n ==  0)) 
        {
            return cli::gcnew<BigInteger>(bi, (bi->length + 1U));
        }
        int32_t w = (n >> 5);
        (n = n & 31);
        BigInteger *ret = cli::gcnew<BigInteger>(Sign::Positive, ((bi->length + 1U) + (uint32_t)w));
        uint32_t i = 0U, l = bi->length;
        if((n != 0)) 
        {
            uint32_t x, carry = 0U;
            while((i < l)) {
                x = bi->data->at((int32_t)i);
                ret->data->at((int32_t)((int64_t)(i) + (int64_t)(w))) = ((x << (n & 31)) | carry);
                carry = (x >> ((32 - n) & 31));
                i++;
            }
            ret->data->at((int32_t)((int64_t)(i) + (int64_t)(w))) = carry;
        }
         else 
        {
            while((i < l)) {
                ret->data->at((int32_t)((int64_t)(i) + (int64_t)(w))) = bi->data->at((int32_t)i);
                i++;
            }
        }
        ret->Normalize();
        return ret;
    }
    
    BigInteger* Kernel::RightShift(BigInteger* bi, int32_t n) {
        if((n ==  0)) 
        {
            return cli::gcnew<BigInteger>(bi);
        }
        int32_t w = (n >> 5);
        int32_t s = (n & 31);
        BigInteger *ret = cli::gcnew<BigInteger>(Sign::Positive, ((bi->length - (uint32_t)w) + 1U));
        uint32_t l = ((uint32_t)ret->data->get_Length() - 1U);
        if((s != 0)) 
        {
            uint32_t x, carry = 0U;
            while((l-- > 0U)) {
                x = bi->data->at((int32_t)((int64_t)(l) + (int64_t)(w)));
                ret->data->at((int32_t)l) = ((x >> (n & 31)) | carry);
                carry = (x << ((32 - n) & 31));
            }
        }
         else 
        {
            while((l-- > 0U)) ret->data->at((int32_t)l) = bi->data->at((int32_t)((int64_t)(l) + (int64_t)(w)));
        }
        ret->Normalize();
        return ret;
    }
    
    BigInteger* Kernel::MultiplyByDword(BigInteger* n, uint32_t f) {
        BigInteger *ret = cli::gcnew<BigInteger>(Sign::Positive, (n->length + 1U));
        uint32_t i = 0U;
        uint64_t c = 0UL;
        do {
            (c = c + ((uint64_t)(n->data->at((int32_t)i)) * (uint64_t)(f)));
            ret->data->at((int32_t)i) = (uint32_t)c;
            (c = c >> 32);
        }
        while((++i < n->length));
        ret->data->at((int32_t)i) = (uint32_t)c;
        ret->Normalize();
        return ret;
    }
    
    void Kernel::Multiply(cli::array<uint32_t>* x, uint32_t xOffset, uint32_t xLen, cli::array<uint32_t>* y, uint32_t yOffset, uint32_t yLen, cli::array<uint32_t>* d, uint32_t dOffset) {
        {
            /* FIXED - BLOCK */
            uint32_t* xx = cli::fixed_guard(((x ==  nullptr) || (x->get_Length() ==  0)) ? nullptr : x);
            uint32_t* yy = cli::fixed_guard(((y ==  nullptr) || (y->get_Length() ==  0)) ? nullptr : y);
            uint32_t* dd = cli::fixed_guard(((d ==  nullptr) || (d->get_Length() ==  0)) ? nullptr : d);
            uint32_t *xP = (xx + (uint32_t)(xOffset)), *xE = (xP + (uint32_t)(xLen)), *yB = (yy + (uint32_t)(yOffset)), *yE = (yB + (uint32_t)(yLen)), *dB = (dd + (uint32_t)(dOffset));
            for(; (xP < xE); xP++, dB++){
                if(((*xP) ==  0U)) 
                {
                    continue;
                }
                uint64_t mcarry = 0UL;
                uint32_t *dP = dB;
                for(uint32_t *yP = yB; (yP < yE); yP++, dP++){
                    (mcarry = mcarry + (((uint64_t)((*xP)) * (uint64_t)((*yP))) + (uint64_t)((*dP))));
                    (*dP) = (uint32_t)mcarry;
                    (mcarry = mcarry >> 32);
                }
                if((mcarry != 0UL)) 
                {
                    (*dP) = (uint32_t)mcarry;
                }
            }
        }
    }
    
    void Kernel::MultiplyMod2p32pmod(cli::array<uint32_t>* x, int32_t xOffset, int32_t xLen, cli::array<uint32_t>* y, int32_t yOffest, int32_t yLen, cli::array<uint32_t>* d, int32_t dOffset, int32_t mod) {
        {
            /* FIXED - BLOCK */
            uint32_t* xx = cli::fixed_guard(((x ==  nullptr) || (x->get_Length() ==  0)) ? nullptr : x);
            uint32_t* yy = cli::fixed_guard(((y ==  nullptr) || (y->get_Length() ==  0)) ? nullptr : y);
            uint32_t* dd = cli::fixed_guard(((d ==  nullptr) || (d->get_Length() ==  0)) ? nullptr : d);
            uint32_t *xP = (xx + (int32_t)(xOffset)), *xE = (xP + (int32_t)(xLen)), *yB = (yy + (int32_t)(yOffest)), *yE = (yB + (int32_t)(yLen)), *dB = (dd + (int32_t)(dOffset)), *dE = (dB + (int32_t)(mod));
            for(; (xP < xE); xP++, dB++){
                if(((*xP) ==  0U)) 
                {
                    continue;
                }
                uint64_t mcarry = 0UL;
                uint32_t *dP = dB;
                for(uint32_t *yP = yB; ((yP < yE) && (dP < dE)); yP++, dP++){
                    (mcarry = mcarry + (((uint64_t)((*xP)) * (uint64_t)((*yP))) + (uint64_t)((*dP))));
                    (*dP) = (uint32_t)mcarry;
                    (mcarry = mcarry >> 32);
                }
                if(((mcarry != 0UL) && (dP < dE))) 
                {
                    (*dP) = (uint32_t)mcarry;
                }
            }
        }
    }
    
    void Kernel::SquarePositive(BigInteger* bi, cli::array<uint32_t>* wkSpace) {
        cli::array<uint32_t> *t = wkSpace;
        wkSpace = bi->data;
        cli::array<uint32_t> *d = bi->data;
        uint32_t dl = bi->length;
        bi->data = t;
        {
            /* FIXED - BLOCK */
            uint32_t* dd = cli::fixed_guard(((d ==  nullptr) || (d->get_Length() ==  0)) ? nullptr : d);
            uint32_t* tt = cli::fixed_guard(((t ==  nullptr) || (t->get_Length() ==  0)) ? nullptr : t);
            uint32_t *ttE = (tt + (int32_t)(t->get_Length()));
            for(uint32_t *ttt = tt; (ttt < ttE); ttt++) {
                (*ttt) = 0U;
            }
            uint32_t *dP = dd, *tP = tt;
            for(uint32_t i = 0U; (i < dl); i++, dP++){
                if(((*dP) ==  0U)) 
                {
                    continue;
                }
                uint64_t mcarry = 0UL;
                uint32_t bi1val = (*dP);
                uint32_t *dP2 = (dP + 4), *tP2 = ((tP + (uint32_t)((2U * i))) + 4);
                for(uint32_t j = (i + 1U); (j < dl); j++, tP2++, dP2++){
                    (mcarry = mcarry + (((uint64_t)(bi1val) * (uint64_t)((*dP2))) + (uint64_t)((*tP2))));
                    (*tP2) = (uint32_t)mcarry;
                    (mcarry = mcarry >> 32);
                }
                if((mcarry != 0UL)) 
                {
                    (*tP2) = (uint32_t)mcarry;
                }
            }
            tP = tt;
            uint32_t x, carry = 0U;
            while((tP < ttE)) {
                x = (*tP);
                (*tP) = ((x << 1) | carry);
                carry = (x >> 31);
                tP++;
            }
            if((carry != 0U)) 
            {
                (*tP) = carry;
            }
            dP = dd;
            tP = tt;
            for(uint32_t *dE = (dP + (uint32_t)(dl)); (dP < dE); dP++, tP++){
                uint64_t val = (((uint64_t)((*dP)) * (uint64_t)((*dP))) + (uint64_t)((*tP)));
                (*tP) = (uint32_t)val;
                (val = val >> 32);
                ((*++tP) = (*++tP) + (uint32_t)val);
                if(((*tP) < (uint32_t)val)) 
                {
                    uint32_t *tP3 = tP;
                    (*++tP3)++;
                    while(((*tP3++) ==  0U)) (*tP3)++;
                }
            }
            (bi->length = bi->length << 1);
            while((((*(tt + (bi->length - 1U))) ==  0U) && (bi->length > 1U))) bi->length--;
        }
    }
    
    BigInteger* Kernel::gcd(BigInteger* a, BigInteger* b) {
        BigInteger *x = a;
        BigInteger *y = b;
        BigInteger *g = y;
        while((x->length > 1U)) {
            g = x;
            x = BigInteger::op_Modulus3(y, x);
            y = g;
        }
        if(BigInteger::op_Equality(x, 0U)) 
        {
            return g;
        }
        uint32_t yy = x->data->at(0);
        uint32_t xx = BigInteger::op_Modulus2(y, yy);
        int32_t t = 0;
        while((((xx | yy) & 1U) ==  0U)) {
            (xx = xx >> 1);
            (yy = yy >> 1);
            t++;
        }
        while((xx != 0U)) {
            while(((xx & 1U) ==  0U)) (xx = xx >> 1);
            while(((yy & 1U) ==  0U)) (yy = yy >> 1);
            if((xx >= yy)) 
            {
                xx = ((xx - yy) >> 1);
            }
             else 
            {
                yy = ((yy - xx) >> 1);
            }
        }
        return BigInteger::op_Implicit((yy << (t & 31)));
    }
    
    uint32_t Kernel::modInverse(BigInteger* bi, uint32_t modulus) {
        uint32_t a = modulus, b = BigInteger::op_Modulus2(bi, modulus);
        uint32_t p0 = 0U, p1 = 1U;
        while((b != 0U)) {
            if((b ==  1U)) 
            {
                return p1;
            }
            (p0 = p0 + ((a / b) * p1));
            (a = a % b);
            if((a ==  0U)) 
            {
                break;
            }
            if((a ==  1U)) 
            {
                return (modulus - p0);
            }
            (p1 = p1 + ((b / a) * p0));
            (b = b % a);
        }
        return 0U;
    }
    
    BigInteger* Kernel::modInverse2(BigInteger* bi, BigInteger* modulus) {
        if((modulus->length ==  1U)) 
        {
            return BigInteger::op_Implicit(modInverse(bi, modulus->data->at(0)));
        }
        cli::array<BigInteger*> *p = (new cli::array<BigInteger*>({BigInteger::op_Implicit2(0), BigInteger::op_Implicit2(1)}));
        cli::array<BigInteger*> *q = (new cli::array<BigInteger*>(2));
        cli::array<BigInteger*> *r = (new cli::array<BigInteger*>({BigInteger::op_Implicit2(0), BigInteger::op_Implicit2(0)}));
        int32_t step = 0;
        BigInteger *a = modulus;
        BigInteger *b = bi;
        ModulusRing *mr = cli::gcnew<ModulusRing>(modulus);
        while(BigInteger::op_Inequality(b, 0U)) {
            if((step > 1)) 
            {
                BigInteger *pval = mr->Difference(p->at(0), BigInteger::op_Multiply(p->at(1), q->at(0)));
                p->at(0) = p->at(1);
                p->at(1) = pval;
            }
            cli::array<BigInteger*> *divret = multiByteDivide(a, b);
            q->at(0) = q->at(1);
            q->at(1) = divret->at(0);
            r->at(0) = r->at(1);
            r->at(1) = divret->at(1);
            a = b;
            b = divret->at(1);
            step++;
        }
        if(BigInteger::op_Inequality(r->at(0), 1U)) 
        {
            throw cli::gcnew<System::ArithmeticException>(_T("No inverse!"));
        }
        return mr->Difference(p->at(0), BigInteger::op_Multiply(p->at(1), q->at(0)));
    }
    
}}
namespace Mono { namespace Math {
    
    cli::array<uint32_t>*  BigInteger::smallPrimes;
    System::Security::Cryptography::RandomNumberGenerator*  BigInteger::rng;
    
    BigInteger::BigInteger()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void BigInteger::constructor() {
        this->data = (new cli::array<uint32_t>((int32_t)20U));
        this->length = 20U;
    }
    
    void BigInteger::constructor(Sign sign, uint32_t len) {
        this->data = (new cli::array<uint32_t>((int32_t)len));
        this->length = len;
    }
    
    void BigInteger::constructor(BigInteger* bi) {
        this->data = cli::cast<cli::array<uint32_t>*>(cli::import(bi->data)->Clone());
        this->length = bi->length;
    }
    
    void BigInteger::constructor(BigInteger* bi, uint32_t len) {
        this->data = (new cli::array<uint32_t>((int32_t)len));
        for(uint32_t i = 0U; (i < bi->length); i++) {
            this->data->at((int32_t)i) = bi->data->at((int32_t)i);
        }
        this->length = bi->length;
    }
    
    void BigInteger::constructor(cli::array<unsigned char>* inData) {
        if((inData->get_Length() ==  0)) 
        {
            inData = (new cli::array<unsigned char>(1));
        }
        this->length = ((uint32_t)inData->get_Length() >> 2);
        int32_t leftOver = (inData->get_Length() & 3);
        if((leftOver != 0)) 
        {
            this->length++;
        }
        this->data = (new cli::array<uint32_t>((int32_t)this->length));
        for(int32_t i = (inData->get_Length() - 1), j = 0; (i >= 3); (i = i - 4), j++){
            this->data->at(j) = (uint32_t)(((((int32_t)(inData->at((i - 3))) << 24) | ((int32_t)(inData->at((i - 2))) << 16)) | ((int32_t)(inData->at((i - 1))) << 8)) | (int32_t)(inData->at(i)));
        }
        switch(leftOver) {
            case 1: case_331: {
                this->data->at((int32_t)(this->length - 1U)) = (uint32_t)(inData->at(0));
                break;
            }
            case 2: case_332: {
                this->data->at((int32_t)(this->length - 1U)) = (uint32_t)(((int32_t)(inData->at(0)) << 8) | (int32_t)(inData->at(1)));
                break;
            }
            case 3: case_333: {
                this->data->at((int32_t)(this->length - 1U)) = (uint32_t)((((int32_t)(inData->at(0)) << 16) | ((int32_t)(inData->at(1)) << 8)) | (int32_t)(inData->at(2)));
                break;
            }
        }
        this->Normalize();
    }
    
    void BigInteger::constructor(cli::array<uint32_t>* inData) {
        if((inData->get_Length() ==  0)) 
        {
            inData = (new cli::array<uint32_t>(1));
        }
        this->length = (uint32_t)inData->get_Length();
        this->data = (new cli::array<uint32_t>((int32_t)this->length));
        for(int32_t i = ((int32_t)this->length - 1), j = 0; (i >= 0); i--, j++) {
            this->data->at(j) = inData->at(i);
        }
        this->Normalize();
    }
    
    void BigInteger::constructor(uint32_t ui) {
        this->data = (new cli::array<uint32_t>({ui}));
    }
    
    void BigInteger::constructor(uint64_t ul) {
        this->data = (new cli::array<uint32_t>({(System::UInt32)ul, (System::UInt32)(ul >> 32)}));
        this->length = 2U;
        this->Normalize();
    }
    
    void BigInteger::static_constructor() {
    }
    
    BigInteger* BigInteger::Parse(System::String* number) {
        if((number ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("number"));
        }
        int32_t i = 0, len = number->get_Length();
        char16_t c;
        bool digits_seen = false;
        BigInteger *val = cli::gcnew<BigInteger>(0U);
        if(((int32_t)(number->get_Chars(i)) ==  43)) 
        {
            i++;
        }
         else 
        {
            if(((int32_t)(number->get_Chars(i)) ==  45)) 
            {
                throw cli::gcnew<System::FormatException>(_T("Operation would return a negative value"));
            }
        }
        for(; (i < len); i++){
            c = number->get_Chars(i);
            if(((int32_t)(c) ==  0)) 
            {
                i = len;
                continue;
            }
            if((((int32_t)(c) >= 48) && ((int32_t)(c) <= 57))) 
            {
                val = op_Addition(op_Multiply2(val, 10), BigInteger::op_Implicit2(((int32_t)(c) - 48)));
                digits_seen = true;
            }
             else 
            {
                if(System::Char::IsWhiteSpace(c)) 
                {
                    for(i++; (i < len); i++){
                        if(!(System::Char::IsWhiteSpace(number->get_Chars(i)))) 
                        {
                            throw cli::gcnew<System::FormatException>();
                        }
                    }
                    break;
                }
                 else 
                {
                    throw cli::gcnew<System::FormatException>();
                }
            }
        }
        if(!(digits_seen)) 
        {
            throw cli::gcnew<System::FormatException>();
        }
        return val;
    }
    
    BigInteger* BigInteger::Add(BigInteger* bi1, BigInteger* bi2) {
        return op_Addition(bi1, bi2);
    }
    
    BigInteger* BigInteger::Subtract(BigInteger* bi1, BigInteger* bi2) {
        return op_Subtraction(bi1, bi2);
    }
    
    int32_t BigInteger::Modulus(BigInteger* bi, int32_t i) {
        return op_Modulus(bi, i);
    }
    
    uint32_t BigInteger::Modulus2(BigInteger* bi, uint32_t ui) {
        return op_Modulus2(bi, ui);
    }
    
    BigInteger* BigInteger::Modulus3(BigInteger* bi1, BigInteger* bi2) {
        return op_Modulus3(bi1, bi2);
    }
    
    BigInteger* BigInteger::Divid(BigInteger* bi, int32_t i) {
        return op_Division(bi, i);
    }
    
    BigInteger* BigInteger::Divid2(BigInteger* bi1, BigInteger* bi2) {
        return op_Division2(bi1, bi2);
    }
    
    BigInteger* BigInteger::Multiply(BigInteger* bi1, BigInteger* bi2) {
        return op_Multiply(bi1, bi2);
    }
    
    BigInteger* BigInteger::Multiply2(BigInteger* bi, int32_t i) {
        return op_Multiply2(bi, i);
    }
    
    BigInteger* BigInteger::GenerateRandom(int32_t bits, System::Security::Cryptography::RandomNumberGenerator* rng) {
        int32_t dwords = (bits >> 5);
        int32_t remBits = (bits & 31);
        if((remBits != 0)) 
        {
            dwords++;
        }
        BigInteger *ret = cli::gcnew<BigInteger>(Sign::Positive, ((uint32_t)dwords + 1U));
        cli::array<unsigned char> *random = (new cli::array<unsigned char>((dwords << 2)));
        rng->GetBytes_bf6c3bc1baf70dfd(random);
        System::Buffer::BlockCopy(random, 0, ret->data, 0, ((int32_t)(dwords) << 2));
        if((remBits != 0)) 
        {
            uint32_t mask = (uint32_t)(1 << ((remBits - 1) & 31));
            (ret->data->at((dwords - 1)) = ret->data->at((dwords - 1)) | mask);
            mask = (uint32_t)((4294967295U >> ((32 - remBits) & 31)));
            (ret->data->at((dwords - 1)) = ret->data->at((dwords - 1)) & mask);
        }
         else 
        {
            (ret->data->at((dwords - 1)) = ret->data->at((dwords - 1)) | 2147483648U);
        }
        ret->Normalize();
        return ret;
    }
    
    BigInteger* BigInteger::GenerateRandom2(int32_t bits) {
        return GenerateRandom(bits, BigInteger::get_Rng());
    }
    
    void BigInteger::Randomize(System::Security::Cryptography::RandomNumberGenerator* rng) {
        if(op_Equality(this, 0U)) 
        {
            return;
        }
        int32_t bits = this->BitCount();
        int32_t dwords = (bits >> 5);
        int32_t remBits = (bits & 31);
        if((remBits != 0)) 
        {
            dwords++;
        }
        cli::array<unsigned char> *random = (new cli::array<unsigned char>((dwords << 2)));
        rng->GetBytes_bf6c3bc1baf70dfd(random);
        System::Buffer::BlockCopy(random, 0, this->data, 0, ((int32_t)(dwords) << 2));
        if((remBits != 0)) 
        {
            uint32_t mask = (uint32_t)(1 << ((remBits - 1) & 31));
            (this->data->at((dwords - 1)) = this->data->at((dwords - 1)) | mask);
            mask = (uint32_t)((4294967295U >> ((32 - remBits) & 31)));
            (this->data->at((dwords - 1)) = this->data->at((dwords - 1)) & mask);
        }
         else 
        {
            (this->data->at((dwords - 1)) = this->data->at((dwords - 1)) | 2147483648U);
        }
        Normalize();
    }
    
    void BigInteger::Randomize2() {
        Randomize(BigInteger::get_Rng());
    }
    
    int32_t BigInteger::BitCount() {
        this->Normalize();
        uint32_t value = this->data->at((int32_t)(this->length - 1U));
        uint32_t mask = 2147483648U;
        uint32_t bits = 32U;
        while(((bits > 0U) && ((value & mask) ==  0U))) {
            bits--;
            (mask = mask >> 1);
        }
        (bits = bits + ((this->length - 1U) << 5));
        return (int32_t)bits;
    }
    
    bool BigInteger::TestBit(uint32_t bitNum) {
        uint32_t bytePos = (bitNum >> 5);
        unsigned char bitPos = (unsigned char)(bitNum & 31U);
        uint32_t mask = (1U << ((int32_t)(bitPos) & 31));
        return ((this->data->at((int32_t)bytePos) & mask) != 0U);
    }
    
    bool BigInteger::TestBit2(int32_t bitNum) {
        if((bitNum < 0)) 
        {
            throw cli::gcnew<System::IndexOutOfRangeException>(_T("bitNum out of range"));
        }
        uint32_t bytePos = ((uint32_t)bitNum >> 5);
        unsigned char bitPos = (unsigned char)(bitNum & 31);
        uint32_t mask = (1U << ((int32_t)(bitPos) & 31));
        return ((this->data->at((int32_t)bytePos) | mask) ==  this->data->at((int32_t)bytePos));
    }
    
    void BigInteger::SetBit(uint32_t bitNum) {
        SetBit2(bitNum, true);
    }
    
    void BigInteger::ClearBit(uint32_t bitNum) {
        SetBit2(bitNum, false);
    }
    
    void BigInteger::SetBit2(uint32_t bitNum, bool value) {
        uint32_t bytePos = (bitNum >> 5);
        if((bytePos < this->length)) 
        {
            uint32_t mask = (1U << ((int32_t)(bitNum & 31U) & 31));
            if(value) 
            {
                (this->data->at((int32_t)bytePos) = this->data->at((int32_t)bytePos) | mask);
            }
             else 
            {
                (this->data->at((int32_t)bytePos) = this->data->at((int32_t)bytePos) & ~(mask));
            }
        }
    }
    
    int32_t BigInteger::LowestSetBit() {
        if(op_Equality(this, 0U)) 
        {
            return -1;
        }
        int32_t i = 0;
        while(!(TestBit2(i))) i++;
        return i;
    }
    
    cli::array<unsigned char>* BigInteger::GetBytes() {
        if(op_Equality(this, 0U)) 
        {
            return (new cli::array<unsigned char>(1));
        }
        int32_t numBits = BitCount();
        int32_t numBytes = (numBits >> 3);
        if(((numBits & 7) != 0)) 
        {
            numBytes++;
        }
        cli::array<unsigned char> *result = (new cli::array<unsigned char>(numBytes));
        int32_t numBytesInWord = (numBytes & 3);
        if((numBytesInWord ==  0)) 
        {
            numBytesInWord = 4;
        }
        int32_t pos = 0;
        for(int32_t i = ((int32_t)this->length - 1); (i >= 0); i--){
            uint32_t val = this->data->at(i);
            for(int32_t j = (numBytesInWord - 1); (j >= 0); j--){
                result->at((pos + j)) = (unsigned char)(val & 255U);
                (val = val >> 8);
            }
            (pos = pos + numBytesInWord);
            numBytesInWord = 4;
        }
        return result;
    }
    
    Sign BigInteger::Compare(BigInteger* bi) {
        return Kernel::Compare(this, bi);
    }
    
    System::String* BigInteger::ToString2(uint32_t radix) {
        return ToString3(radix, _T("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"));
    }
    
    System::String* BigInteger::ToString3(uint32_t radix, System::String* characterSet) {
        if(((int64_t)(characterSet->get_Length()) < (int64_t)(radix))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("charSet length less than radix"), _T("characterSet"));
        }
        if((radix ==  1U)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("There is no such thing as radix one notation"), _T("radix"));
        }
        if(op_Equality(this, 0U)) 
        {
            return _T("0");
        }
        if(op_Equality(this, 1U)) 
        {
            return _T("1");
        }
        System::String *result = _T("");
        BigInteger *a = cli::gcnew<BigInteger>(this);
        while(op_Inequality(a, 0U)) {
            uint32_t rem = Kernel::SingleByteDivideInPlace(a, radix);
            result = cli::concat(cli::box(characterSet->get_Chars((int32_t)rem)), result);
        }
        return result;
    }
    
    void BigInteger::Normalize() {
        while(((this->length > 0U) && (this->data->at((int32_t)(this->length - 1U)) ==  0U))) this->length--;
        if((this->length ==  0U)) 
        {
            this->length++;
        }
    }
    
    void BigInteger::Clear() {
        for(int32_t i = 0; ((int64_t)(i) < (int64_t)(this->length)); i++) {
            this->data->at(i) = 0U;
        }
    }
    
    int32_t BigInteger::GetHashCode_6648aef0f235ee6c() {
        uint32_t val = 0U;
        for(uint32_t i = 0U; (i < this->length); i++) {
            (val = val ^ this->data->at((int32_t)i));
        }
        return (int32_t)val;
    }
    
    System::String* BigInteger::ToString_1636a0751cb9ac11() {
        return ToString2(10U);
    }
    
    bool BigInteger::Equals_ed975d2f4a7d193e(System::Object* o) {
        if((o ==  nullptr)) 
        {
            return false;
        }
        if(cli::is<System::Int32>(o)) 
        {
            return ((cli::unbox<int32_t>(o) >= 0) && op_Equality(this, cli::unbox<uint32_t>(o)));
        }
        BigInteger *bi = cli::as<BigInteger*>(o);
        if(op_Equality2(bi, nullptr)) 
        {
            return false;
        }
        return ((int32_t)(Kernel::Compare(this, bi)) ==  0);
    }
    
    BigInteger* BigInteger::GCD(BigInteger* bi) {
        return Kernel::gcd(this, bi);
    }
    
    BigInteger* BigInteger::ModInverse(BigInteger* modulus) {
        return Kernel::modInverse2(this, modulus);
    }
    
    BigInteger* BigInteger::ModPow(BigInteger* exp, BigInteger* n) {
        ModulusRing *mr = cli::gcnew<ModulusRing>(n);
        return mr->Pow(this, exp);
    }
    
    bool BigInteger::IsProbablePrime() {
        if(op_LessThanOrEqual(this, BigInteger::op_Implicit(smallPrimes->at((smallPrimes->get_Length() - 1))))) 
        {
            for(int32_t p = 0; (p < smallPrimes->get_Length()); p++){
                if(op_Equality(this, smallPrimes->at(p))) 
                {
                    return true;
                }
            }
            return false;
        }
        for(int32_t p = 0; (p < smallPrimes->get_Length()); p++){
            if((op_Modulus2(this, smallPrimes->at(p)) ==  0U)) 
            {
                return false;
            }
        }
        return Prime::PrimalityTests::Test(this, Prime::ConfidenceFactor::Medium);
    }
    
    BigInteger* BigInteger::NextHighestPrime(BigInteger* bi) {
        Prime::Generator::NextPrimeFinder *npf = cli::gcnew<Prime::Generator::NextPrimeFinder>();
        return npf->GenerateNewPrime_12472ea6101d74d5(0, bi);
    }
    
    BigInteger* BigInteger::GeneratePseudoPrime(int32_t bits) {
        Prime::Generator::SequentialSearchPrimeGeneratorBase *sspg = cli::gcnew<Prime::Generator::SequentialSearchPrimeGeneratorBase>();
        return sspg->GenerateNewPrime_96549c2617c35d0a(bits);
    }
    
    void BigInteger::Incr2() {
        int32_t i = 0;
        (this->data->at(0) = this->data->at(0) + 2U);
        if((this->data->at(0) < 2U)) 
        {
            this->data->at(++i)++;
            while((this->data->at(i++) ==  0U)) this->data->at(i)++;
            if((this->length ==  (uint32_t)i)) 
            {
                this->length++;
            }
        }
    }
    
    BigInteger* BigInteger::op_Implicit(uint32_t value) {
        return cli::gcnew<BigInteger>(value);
    }
    
    BigInteger* BigInteger::op_Implicit2(int32_t value) {
        if((value < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("value"));
        }
        return cli::gcnew<BigInteger>((uint32_t)value);
    }
    
    BigInteger* BigInteger::op_Implicit3(uint64_t value) {
        return cli::gcnew<BigInteger>(value);
    }
    
    BigInteger* BigInteger::op_Addition(BigInteger* bi1, BigInteger* bi2) {
        if(op_Equality(bi1, 0U)) 
        {
            return cli::gcnew<BigInteger>(bi2);
        }
         else 
        {
            if(op_Equality(bi2, 0U)) 
            {
                return cli::gcnew<BigInteger>(bi1);
            }
             else 
            {
                return Kernel::AddSameSign(bi1, bi2);
            }
        }
    }
    
    BigInteger* BigInteger::op_Subtraction(BigInteger* bi1, BigInteger* bi2) {
        if(op_Equality(bi2, 0U)) 
        {
            return cli::gcnew<BigInteger>(bi1);
        }
        if(op_Equality(bi1, 0U)) 
        {
            throw cli::gcnew<System::ArithmeticException>(_T("Operation would return a negative value"));
        }
        switch(Kernel::Compare(bi1, bi2)) {
            case Sign::Zero: case_334: {
                return BigInteger::op_Implicit2(0);
            }
            case Sign::Positive: case_335: {
                return Kernel::Subtract(bi1, bi2);
            }
            case Sign::Negative: case_336: {
                throw cli::gcnew<System::ArithmeticException>(_T("Operation would return a negative value"));
            }
            default: case_337: {
                throw cli::gcnew<System::Exception>();
            }
        }
    }
    
    int32_t BigInteger::op_Modulus(BigInteger* bi, int32_t i) {
        if((i > 0)) 
        {
            return (int32_t)Kernel::DwordMod(bi, (uint32_t)i);
        }
         else 
        {
            return -((int32_t)Kernel::DwordMod(bi, (uint32_t)-(i)));
        }
    }
    
    uint32_t BigInteger::op_Modulus2(BigInteger* bi, uint32_t ui) {
        return Kernel::DwordMod(bi, (uint32_t)(ui));
    }
    
    BigInteger* BigInteger::op_Modulus3(BigInteger* bi1, BigInteger* bi2) {
        return Kernel::multiByteDivide(bi1, bi2)->at(1);
    }
    
    BigInteger* BigInteger::op_Division(BigInteger* bi, int32_t i) {
        if((i > 0)) 
        {
            return Kernel::DwordDiv(bi, (uint32_t)i);
        }
        throw cli::gcnew<System::ArithmeticException>(_T("Operation would return a negative value"));
    }
    
    BigInteger* BigInteger::op_Division2(BigInteger* bi1, BigInteger* bi2) {
        return Kernel::multiByteDivide(bi1, bi2)->at(0);
    }
    
    BigInteger* BigInteger::op_Multiply(BigInteger* bi1, BigInteger* bi2) {
        if((op_Equality(bi1, 0U) || op_Equality(bi2, 0U))) 
        {
            return BigInteger::op_Implicit2(0);
        }
        if(((int64_t)(bi1->data->get_Length()) < (int64_t)(bi1->length))) 
        {
            throw cli::gcnew<System::IndexOutOfRangeException>(_T("bi1 out of range"));
        }
        if(((int64_t)(bi2->data->get_Length()) < (int64_t)(bi2->length))) 
        {
            throw cli::gcnew<System::IndexOutOfRangeException>(_T("bi2 out of range"));
        }
        BigInteger *ret = cli::gcnew<BigInteger>(Sign::Positive, (bi1->length + bi2->length));
        Kernel::Multiply(bi1->data, 0U, bi1->length, bi2->data, 0U, bi2->length, ret->data, 0U);
        ret->Normalize();
        return ret;
    }
    
    BigInteger* BigInteger::op_Multiply2(BigInteger* bi, int32_t i) {
        if((i < 0)) 
        {
            throw cli::gcnew<System::ArithmeticException>(_T("Operation would return a negative value"));
        }
        if((i ==  0)) 
        {
            return BigInteger::op_Implicit2(0);
        }
        if((i ==  1)) 
        {
            return cli::gcnew<BigInteger>(bi);
        }
        return Kernel::MultiplyByDword(bi, (uint32_t)i);
    }
    
    BigInteger* BigInteger::op_LeftShift(BigInteger* bi1, int32_t shiftVal) {
        return Kernel::LeftShift(bi1, shiftVal);
    }
    
    BigInteger* BigInteger::op_RightShift(BigInteger* bi1, int32_t shiftVal) {
        return Kernel::RightShift(bi1, shiftVal);
    }
    
    bool BigInteger::op_Equality(BigInteger* bi1, uint32_t ui) {
        if((bi1->length != 1U)) 
        {
            bi1->Normalize();
        }
        return ((bi1->length ==  1U) && (bi1->data->at(0) ==  ui));
    }
    
    bool BigInteger::op_Inequality(BigInteger* bi1, uint32_t ui) {
        if((bi1->length != 1U)) 
        {
            bi1->Normalize();
        }
        return !(((bi1->length ==  1U) && (bi1->data->at(0) ==  ui)));
    }
    
    bool BigInteger::op_Equality2(BigInteger* bi1, BigInteger* bi2) {
        if((cli::cast<System::Object*>(bi1) ==  cli::cast<System::Object*>(bi2))) 
        {
            return true;
        }
        if((op_Equality2(nullptr, bi1) || op_Equality2(nullptr, bi2))) 
        {
            return false;
        }
        return ((int32_t)(Kernel::Compare(bi1, bi2)) ==  0);
    }
    
    bool BigInteger::op_Inequality2(BigInteger* bi1, BigInteger* bi2) {
        if((cli::cast<System::Object*>(bi1) ==  cli::cast<System::Object*>(bi2))) 
        {
            return false;
        }
        if((op_Equality2(nullptr, bi1) || op_Equality2(nullptr, bi2))) 
        {
            return true;
        }
        return ((int32_t)(Kernel::Compare(bi1, bi2)) != 0);
    }
    
    bool BigInteger::op_GreaterThan(BigInteger* bi1, BigInteger* bi2) {
        return ((int32_t)(Kernel::Compare(bi1, bi2)) > 0);
    }
    
    bool BigInteger::op_LessThan(BigInteger* bi1, BigInteger* bi2) {
        return ((int32_t)(Kernel::Compare(bi1, bi2)) < 0);
    }
    
    bool BigInteger::op_GreaterThanOrEqual(BigInteger* bi1, BigInteger* bi2) {
        return ((int32_t)(Kernel::Compare(bi1, bi2)) >= 0);
    }
    
    bool BigInteger::op_LessThanOrEqual(BigInteger* bi1, BigInteger* bi2) {
        return ((int32_t)(Kernel::Compare(bi1, bi2)) <= 0);
    }
    
    System::Security::Cryptography::RandomNumberGenerator* BigInteger::get_Rng() {
        if((rng ==  nullptr)) 
        {
            rng = System::Security::Cryptography::RandomNumberGenerator::Create();
        }
        return rng;
    }
    
}}
namespace Mono { namespace Math { namespace Prime {
    
    
    void PrimalityTests::constructor() {
    }
    
    int32_t PrimalityTests::GetSPPRounds(Mono::Math::BigInteger* bi, ConfidenceFactor confidence) {
        int32_t bc = bi->BitCount();
        int32_t Rounds;
        if((bc <= 100)) 
        {
            Rounds = 27;
        }
         else 
        {
            if((bc <= 150)) 
            {
                Rounds = 18;
            }
             else 
            {
                if((bc <= 200)) 
                {
                    Rounds = 15;
                }
                 else 
                {
                    if((bc <= 250)) 
                    {
                        Rounds = 12;
                    }
                     else 
                    {
                        if((bc <= 300)) 
                        {
                            Rounds = 9;
                        }
                         else 
                        {
                            if((bc <= 350)) 
                            {
                                Rounds = 8;
                            }
                             else 
                            {
                                if((bc <= 400)) 
                                {
                                    Rounds = 7;
                                }
                                 else 
                                {
                                    if((bc <= 500)) 
                                    {
                                        Rounds = 6;
                                    }
                                     else 
                                    {
                                        if((bc <= 600)) 
                                        {
                                            Rounds = 5;
                                        }
                                         else 
                                        {
                                            if((bc <= 800)) 
                                            {
                                                Rounds = 4;
                                            }
                                             else 
                                            {
                                                if((bc <= 1250)) 
                                                {
                                                    Rounds = 3;
                                                }
                                                 else 
                                                {
                                                    Rounds = 2;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        switch(confidence) {
            case ConfidenceFactor::ExtraLow: case_338: {
                (Rounds = Rounds >> 2);
                return (Rounds != 0) ? Rounds : 1;
            }
            case ConfidenceFactor::Low: case_339: {
                (Rounds = Rounds >> 1);
                return (Rounds != 0) ? Rounds : 1;
            }
            case ConfidenceFactor::Medium: case_340: {
                return Rounds;
            }
            case ConfidenceFactor::High: case_341: {
                return (Rounds << 1);
            }
            case ConfidenceFactor::ExtraHigh: case_342: {
                return (Rounds << 2);
            }
            case ConfidenceFactor::Provable: case_343: {
                throw cli::gcnew<System::Exception>(_T("The Rabin-Miller test can not be executed in a way such that its results are provable"));
            }
            default: case_344: {
                throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("confidence"));
            }
        }
    }
    
    bool PrimalityTests::Test(Mono::Math::BigInteger* n, ConfidenceFactor confidence) {
        if((n->BitCount() < 33)) 
        {
            return SmallPrimeSppTest(n, confidence);
        }
         else 
        {
            return RabinMillerTest(n, confidence);
        }
    }
    
    bool PrimalityTests::RabinMillerTest(Mono::Math::BigInteger* n, ConfidenceFactor confidence) {
        int32_t bits = n->BitCount();
        int32_t t = GetSPPRounds(Mono::Math::BigInteger::op_Implicit2(bits), confidence);
        Mono::Math::BigInteger *n_minus_1 = Mono::Math::BigInteger::op_Subtraction(n, Mono::Math::BigInteger::op_Implicit2(1));
        int32_t s = n_minus_1->LowestSetBit();
        Mono::Math::BigInteger *r = Mono::Math::BigInteger::op_RightShift(n_minus_1, s);
        Mono::Math::ModulusRing *mr = cli::gcnew<Mono::Math::ModulusRing>(n);
        Mono::Math::BigInteger *y = nullptr;
        if((n->BitCount() > 100)) 
        {
            y = mr->Pow2(2U, r);
        }
        for(int32_t round = 0; (round < t); round++){
            if(((round > 0) || Mono::Math::BigInteger::op_Equality2(y, nullptr))) 
            {
                Mono::Math::BigInteger *a = nullptr;
                do {
                    a = Mono::Math::BigInteger::GenerateRandom2(bits);
                }
                while((Mono::Math::BigInteger::op_LessThanOrEqual(a, Mono::Math::BigInteger::op_Implicit2(2)) && Mono::Math::BigInteger::op_GreaterThanOrEqual(a, n_minus_1)));
                y = mr->Pow(a, r);
            }
            if(Mono::Math::BigInteger::op_Equality(y, 1U)) 
            {
                continue;
            }
            for(int32_t j = 0; ((j < s) && Mono::Math::BigInteger::op_Inequality2(y, n_minus_1)); j++){
                y = mr->Pow(y, Mono::Math::BigInteger::op_Implicit2(2));
                if(Mono::Math::BigInteger::op_Equality(y, 1U)) 
                {
                    return false;
                }
            }
            if(Mono::Math::BigInteger::op_Inequality2(y, n_minus_1)) 
            {
                return false;
            }
        }
        return true;
    }
    
    bool PrimalityTests::SmallPrimeSppTest(Mono::Math::BigInteger* bi, ConfidenceFactor confidence) {
        int32_t Rounds = GetSPPRounds(bi, confidence);
        Mono::Math::BigInteger *p_sub1 = Mono::Math::BigInteger::op_Subtraction(bi, Mono::Math::BigInteger::op_Implicit2(1));
        int32_t s = p_sub1->LowestSetBit();
        Mono::Math::BigInteger *t = Mono::Math::BigInteger::op_RightShift(p_sub1, s);
        Mono::Math::ModulusRing *mr = cli::gcnew<Mono::Math::ModulusRing>(bi);
        for(int32_t round = 0; (round < Rounds); round++){
            Mono::Math::BigInteger *b = mr->Pow2(Mono::Math::BigInteger::smallPrimes->at(round), t);
            if(Mono::Math::BigInteger::op_Equality(b, 1U)) 
            {
                continue;
            }
            bool result = false;
            for(int32_t j = 0; (j < s); j++){
                if(Mono::Math::BigInteger::op_Equality2(b, p_sub1)) 
                {
                    result = true;
                    break;
                }
                b = Mono::Math::BigInteger::op_Modulus3(Mono::Math::BigInteger::op_Multiply(b, b), bi);
            }
            if((result ==  false)) 
            {
                return false;
            }
        }
        return true;
    }
    
}}}
namespace Mono { namespace Math { namespace Prime { namespace Generator {
    
    
    void NextPrimeFinder::constructor() {
    }
    
    Mono::Math::BigInteger* NextPrimeFinder::GenerateSearchBase_e4e6b18ddceac6c(int32_t bits, System::Object* Context) {
        if((Context ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("Context"));
        }
        Mono::Math::BigInteger *ret = cli::gcnew<Mono::Math::BigInteger>(cli::cast<Mono::Math::BigInteger*>(Context));
        ret->SetBit(0U);
        return ret;
    }
    
}}}}
namespace Mono { namespace Math { namespace Prime { namespace Generator {
    
    
    void PrimeGeneratorBase::constructor() {
    }
    
    bool PrimeGeneratorBase::PostTrialDivisionTests(Mono::Math::BigInteger* bi) {
        return this->get_PrimalityTest_619b000b4f438aee()->Invoke(bi, this->get_Confidence_cc463f57ab65159());
    }
    
    Mono::Math::Prime::ConfidenceFactor PrimeGeneratorBase::get_Confidence_cc463f57ab65159() {
        return Mono::Math::Prime::ConfidenceFactor::Medium;
    }
    
    Mono::Math::Prime::PrimalityTest* PrimeGeneratorBase::get_PrimalityTest_619b000b4f438aee() {
        return cli::bind(&Mono::Math::Prime::PrimalityTests::RabinMillerTest);
    }
    
    int32_t PrimeGeneratorBase::get_TrialDivisionBounds_f004a39a5ebcd185() {
        return 4000;
    }
    
}}}}
namespace Mono { namespace Math { namespace Prime { namespace Generator {
    
    
    void SequentialSearchPrimeGeneratorBase::constructor() {
    }
    
    Mono::Math::BigInteger* SequentialSearchPrimeGeneratorBase::GenerateSearchBase_e4e6b18ddceac6c(int32_t bits, System::Object* context) {
        Mono::Math::BigInteger *ret = Mono::Math::BigInteger::GenerateRandom2(bits);
        ret->SetBit(0U);
        return ret;
    }
    
    Mono::Math::BigInteger* SequentialSearchPrimeGeneratorBase::GenerateNewPrime_96549c2617c35d0a(int32_t bits) {
        return GenerateNewPrime_12472ea6101d74d5(bits, nullptr);
    }
    
    Mono::Math::BigInteger* SequentialSearchPrimeGeneratorBase::GenerateNewPrime_12472ea6101d74d5(int32_t bits, System::Object* context) {
        Mono::Math::BigInteger *curVal = GenerateSearchBase_e4e6b18ddceac6c(bits, context);
        const uint32_t primeProd1 = 3234846615U;
        uint32_t pMod1 = Mono::Math::BigInteger::op_Modulus2(curVal, 3234846615U);
        int32_t DivisionBound = this->get_TrialDivisionBounds_f004a39a5ebcd185();
        cli::array<uint32_t> *SmallPrimes = Mono::Math::BigInteger::smallPrimes;
        while(true) {
            if(((pMod1 % 3U) ==  0U)) 
            {
                goto biNotPrime;
            }
            if(((pMod1 % 5U) ==  0U)) 
            {
                goto biNotPrime;
            }
            if(((pMod1 % 7U) ==  0U)) 
            {
                goto biNotPrime;
            }
            if(((pMod1 % 11U) ==  0U)) 
            {
                goto biNotPrime;
            }
            if(((pMod1 % 13U) ==  0U)) 
            {
                goto biNotPrime;
            }
            if(((pMod1 % 17U) ==  0U)) 
            {
                goto biNotPrime;
            }
            if(((pMod1 % 19U) ==  0U)) 
            {
                goto biNotPrime;
            }
            if(((pMod1 % 23U) ==  0U)) 
            {
                goto biNotPrime;
            }
            if(((pMod1 % 29U) ==  0U)) 
            {
                goto biNotPrime;
            }
            for(int32_t p = 10; ((p < SmallPrimes->get_Length()) && ((int64_t)(SmallPrimes->at(p)) <= (int64_t)(DivisionBound))); p++){
                if((Mono::Math::BigInteger::op_Modulus2(curVal, SmallPrimes->at(p)) ==  0U)) 
                {
                    goto biNotPrime;
                }
            }
            if(!(IsPrimeAcceptable_e3599ecc89096791(curVal, context))) 
            {
                goto biNotPrime;
            }
            if(this->get_PrimalityTest_619b000b4f438aee()->Invoke(curVal, this->get_Confidence_cc463f57ab65159())) 
            {
                return curVal;
            }
            biNotPrime:
            (pMod1 = pMod1 + 2U);
            if((pMod1 >= 3234846615U)) 
            {
                (pMod1 = pMod1 - 3234846615U);
            }
            curVal->Incr2();
        }
    }
    
    bool SequentialSearchPrimeGeneratorBase::IsPrimeAcceptable_e3599ecc89096791(Mono::Math::BigInteger* bi, System::Object* context) {
        return true;
    }
    
}}}}
namespace Mono { namespace Security {
    
    
    void ASN1::constructor() {
    }
    
    void ASN1::constructor(unsigned char tag) {
    }
    
    void ASN1::constructor(unsigned char tag, cli::array<unsigned char>* data) {
        this->m_nTag = tag;
        this->m_aValue = data;
    }
    
    void ASN1::constructor(cli::array<unsigned char>* data) {
        this->m_nTag = data->at(0);
        int32_t nLenLength = 0;
        int32_t nLength = (int32_t)(data->at(1));
        if((nLength > 128)) 
        {
            nLenLength = (nLength - 128);
            nLength = 0;
            for(int32_t i = 0; (i < nLenLength); i++){
                (nLength = nLength * 256);
                (nLength = nLength + (int32_t)(data->at((i + 2))));
            }
        }
         else 
        {
            if((nLength ==  128)) 
            {
                throw cli::gcnew<System::NotSupportedException>(_T("Undefined length encoding."));
            }
        }
        this->m_aValue = (new cli::array<unsigned char>(nLength));
        System::Buffer::BlockCopy(data, (2 + nLenLength), this->m_aValue, 0, nLength);
        if((((int32_t)(this->m_nTag) & 32) ==  32)) 
        {
            int32_t nStart = (2 + nLenLength);
            Decode(data, nStart, data->get_Length());
        }
    }
    
    bool ASN1::CompareArray(cli::array<unsigned char>* array1, cli::array<unsigned char>* array2) {
        bool bResult = (array1->get_Length() ==  array2->get_Length());
        if(bResult) 
        {
            for(int32_t i = 0; (i < array1->get_Length()); i++){
                if(((int32_t)(array1->at(i)) != (int32_t)(array2->at(i)))) 
                {
                    return false;
                }
            }
        }
        return bResult;
    }
    
    bool ASN1::Equals3(cli::array<unsigned char>* asn1) {
        return CompareArray(this->GetBytes_b91405229279a4ac(), asn1);
    }
    
    bool ASN1::CompareValue(cli::array<unsigned char>* value) {
        return CompareArray(this->m_aValue, value);
    }
    
    ASN1* ASN1::Add(ASN1* asn1) {
        if((asn1 != nullptr)) 
        {
            if((this->elist ==  nullptr)) 
            {
                this->elist = cli::gcnew<System::Collections::ArrayList>();
            }
            this->elist->Add_e6a92085999ce388(asn1);
        }
        return asn1;
    }
    
    cli::array<unsigned char>* ASN1::GetBytes_b91405229279a4ac() {
        cli::array<unsigned char> *val = nullptr;
        if((this->get_Count() > 0)) 
        {
            int32_t esize = 0;
            System::Collections::ArrayList *al = cli::gcnew<System::Collections::ArrayList>();
            for(auto tmp_54 : this->elist) {
                auto a = cli::cast<ASN1*>(tmp_54);
                {
                    cli::array<unsigned char> *item = a->GetBytes_b91405229279a4ac();
                    al->Add_e6a92085999ce388(item);
                    (esize = esize + item->get_Length());
                }
            }
            val = (new cli::array<unsigned char>(esize));
            int32_t pos = 0;
            for(int32_t i = 0; (i < this->elist->get_Count_2354963792616712()); i++){
                cli::array<unsigned char> *item = cli::cast<cli::array<unsigned char>*>(al->get_Item_fd0155f142ae570(i));
                System::Buffer::BlockCopy(item, 0, val, pos, item->get_Length());
                (pos = pos + item->get_Length());
            }
        }
         else 
        {
            if((this->m_aValue != nullptr)) 
            {
                val = this->m_aValue;
            }
        }
        cli::array<unsigned char> *der;
        int32_t nLengthLen = 0;
        if((val != nullptr)) 
        {
            int32_t nLength = val->get_Length();
            if((nLength > 127)) 
            {
                if((nLength <= 255)) 
                {
                    der = (new cli::array<unsigned char>((3 + nLength)));
                    System::Buffer::BlockCopy(val, 0, der, 3, nLength);
                    nLengthLen = 129;
                    der->at(2) = (unsigned char)nLength;
                }
                 else 
                {
                    if((nLength <= 65535)) 
                    {
                        der = (new cli::array<unsigned char>((4 + nLength)));
                        System::Buffer::BlockCopy(val, 0, der, 4, nLength);
                        nLengthLen = 130;
                        der->at(2) = (unsigned char)(nLength >> 8);
                        der->at(3) = (unsigned char)nLength;
                    }
                     else 
                    {
                        if((nLength <= 16777215)) 
                        {
                            der = (new cli::array<unsigned char>((5 + nLength)));
                            System::Buffer::BlockCopy(val, 0, der, 5, nLength);
                            nLengthLen = 131;
                            der->at(2) = (unsigned char)(nLength >> 16);
                            der->at(3) = (unsigned char)(nLength >> 8);
                            der->at(4) = (unsigned char)nLength;
                        }
                         else 
                        {
                            der = (new cli::array<unsigned char>((6 + nLength)));
                            System::Buffer::BlockCopy(val, 0, der, 6, nLength);
                            nLengthLen = 132;
                            der->at(2) = (unsigned char)(nLength >> 24);
                            der->at(3) = (unsigned char)(nLength >> 16);
                            der->at(4) = (unsigned char)(nLength >> 8);
                            der->at(5) = (unsigned char)nLength;
                        }
                    }
                }
            }
             else 
            {
                der = (new cli::array<unsigned char>((2 + nLength)));
                System::Buffer::BlockCopy(val, 0, der, 2, nLength);
                nLengthLen = nLength;
            }
            if((this->m_aValue ==  nullptr)) 
            {
                this->m_aValue = val;
            }
        }
         else 
        {
            der = (new cli::array<unsigned char>(2));
        }
        der->at(0) = this->m_nTag;
        der->at(1) = (unsigned char)nLengthLen;
        return der;
    }
    
    void ASN1::Decode(cli::array<unsigned char>* asn1, int32_t anPos, int32_t anLength) {
        unsigned char nTag;
        int32_t nLength;
        cli::array<unsigned char> *aValue;
        while((anPos < (anLength - 1))) {
            DecodeTLV(asn1, anPos, nTag, nLength, aValue);
            if(((int32_t)(nTag) ==  0)) 
            {
                continue;
            }
            ASN1 *elm = Add(cli::gcnew<ASN1>(nTag, aValue));
            if((((int32_t)(nTag) & 32) ==  32)) 
            {
                int32_t nConstructedPos = anPos;
                elm->Decode(asn1, nConstructedPos, (nConstructedPos + nLength));
            }
            (anPos = anPos + nLength);
        }
    }
    
    void ASN1::DecodeTLV(cli::array<unsigned char>* asn1, int32_t pos, unsigned char tag, int32_t length, cli::array<unsigned char>* content) {
        tag = asn1->at(pos++);
        length = (int32_t)(asn1->at(pos++));
        if(((length & 128) ==  128)) 
        {
            int32_t nLengthLen = (length & 127);
            length = 0;
            for(int32_t i = 0; (i < nLengthLen); i++) {
                length = ((length * 256) + (int32_t)(asn1->at(pos++)));
            }
        }
        content = (new cli::array<unsigned char>(length));
        System::Buffer::BlockCopy(asn1, pos, content, 0, length);
    }
    
    ASN1* ASN1::Element2(int32_t index, unsigned char anTag) {
        try {
            if(((this->elist ==  nullptr) || (index >= this->elist->get_Count_2354963792616712()))) 
            {
                return nullptr;
            }
            ASN1 *elm = cli::cast<ASN1*>(this->elist->get_Item_fd0155f142ae570(index));
            if(((int32_t)(elm->get_Tag()) ==  (int32_t)(anTag))) 
            {
                return elm;
            }
             else 
            {
                return nullptr;
            }
        }
        catch(System::ArgumentOutOfRangeException*) {
            return nullptr;
        }
    }
    
    System::String* ASN1::ToString_1636a0751cb9ac11() {
        System::Text::StringBuilder *hexLine = cli::gcnew<System::Text::StringBuilder>();
        hexLine->AppendFormat4(_T("Tag: {0} {1}"), cli::import(this->m_nTag)->ToString3(_T("X2")), System::Environment::get_NewLine());
        hexLine->AppendFormat4(_T("Length: {0} {1}"), cli::box(this->get_Value()->get_Length()), System::Environment::get_NewLine());
        hexLine->Append2(_T("Value: "));
        hexLine->Append2(System::Environment::get_NewLine());
        for(int32_t i = 0; (i < this->get_Value()->get_Length()); i++){
            hexLine->AppendFormat3(_T("{0} "), cli::import(this->get_Value()->at(i))->ToString3(_T("X2")));
            if((((i + 1) % 16) ==  0)) 
            {
                hexLine->AppendFormat(System::Environment::get_NewLine(), (new cli::array<System::Object*>({})));
            }
        }
        return hexLine->ToString_1636a0751cb9ac11();
    }
    
    void ASN1::SaveToFile(System::String* filename) {
        if((filename ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("filename"));
        }
        {
            /* USING - BLOCK */
            auto fs = System::IO::File::Create(filename);
            cli::using_guard{fs};
            cli::array<unsigned char> *data = GetBytes_b91405229279a4ac();
            fs->Write_1f8a1dbe71b0eb89(data, 0, data->get_Length());
        }
    }
    
    int32_t ASN1::get_Count() {
        if((this->elist ==  nullptr)) 
        {
            return 0;
        }
        return this->elist->get_Count_2354963792616712();
    }
    
    unsigned char ASN1::get_Tag() {
        return this->m_nTag;
    }
    
    int32_t ASN1::get_Length() {
        if((this->m_aValue != nullptr)) 
        {
            return this->m_aValue->get_Length();
        }
         else 
        {
            return 0;
        }
    }
    
    cli::array<unsigned char>* ASN1::get_Value() {
        if((this->m_aValue ==  nullptr)) 
        {
            GetBytes_b91405229279a4ac();
        }
        return cli::cast<cli::array<unsigned char>*>(cli::import(this->m_aValue)->Clone());
    }
    
    cli::array<unsigned char>* ASN1::set_Value(cli::array<unsigned char>* value) {
        if((value != nullptr)) 
        {
            this->m_aValue = cli::cast<cli::array<unsigned char>*>(cli::import(value)->Clone());
        }
        return get_Value();
    }
    
    ASN1* ASN1::get_Item(int32_t index) {
        try {
            if(((this->elist ==  nullptr) || (index >= this->elist->get_Count_2354963792616712()))) 
            {
                return nullptr;
            }
            return cli::cast<ASN1*>(this->elist->get_Item_fd0155f142ae570(index));
        }
        catch(System::ArgumentOutOfRangeException*) {
            return nullptr;
        }
    }
    
}}
namespace Mono { namespace Security {
    
    
    ASN1* ASN1Convert::FromDateTime(System::DateTime dt) {
        if((dt->get_Year() < 2050)) 
        {
            return cli::gcnew<ASN1>(23, System::Text::Encoding::get_ASCII()->GetBytes_49806e8e98b1c1db(cli::concat(dt->ToUniversalTime()->ToString5(_T("yyMMddHHmmss"), System::Globalization::CultureInfo::get_InvariantCulture()), _T("Z"))));
        }
         else 
        {
            return cli::gcnew<ASN1>(24, System::Text::Encoding::get_ASCII()->GetBytes_49806e8e98b1c1db(cli::concat(dt->ToUniversalTime()->ToString5(_T("yyyyMMddHHmmss"), System::Globalization::CultureInfo::get_InvariantCulture()), _T("Z"))));
        }
    }
    
    ASN1* ASN1Convert::FromInt32(int32_t value) {
        cli::array<unsigned char> *integer = BitConverterLE::GetBytes4(value);
        System::Array::Reverse(integer);
        int32_t x = 0;
        while(((x < integer->get_Length()) && ((int32_t)(integer->at(x)) ==  0))) x++;
        ASN1 *asn1 = cli::gcnew<ASN1>(2);
        switch(x) {
            case 0: case_345: {
                asn1->set_Value(integer);
                break;
            }
            case 4: case_346: {
                asn1->set_Value((new cli::array<unsigned char>(1)));
                break;
            }
            default: case_347: {
                cli::array<unsigned char> *smallerInt = (new cli::array<unsigned char>((4 - x)));
                System::Buffer::BlockCopy(integer, x, smallerInt, 0, smallerInt->get_Length());
                asn1->set_Value(smallerInt);
                break;
            }
        }
        return asn1;
    }
    
    ASN1* ASN1Convert::FromOid(System::String* oid) {
        if((oid ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("oid"));
        }
        return cli::gcnew<ASN1>(System::Security::Cryptography::CryptoConfig::EncodeOID(oid));
    }
    
    ASN1* ASN1Convert::FromUnsignedBigInteger(cli::array<unsigned char>* big) {
        if((big ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("big"));
        }
        if(((int32_t)(big->at(0)) >= 128)) 
        {
            int32_t length = (big->get_Length() + 1);
            cli::array<unsigned char> *uinteger = (new cli::array<unsigned char>(length));
            System::Buffer::BlockCopy(big, 0, uinteger, 1, (length - 1));
            big = uinteger;
        }
        return cli::gcnew<ASN1>(2, big);
    }
    
    int32_t ASN1Convert::ToInt32(ASN1* asn1) {
        if((asn1 ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("asn1"));
        }
        if(((int32_t)(asn1->get_Tag()) != 2)) 
        {
            throw cli::gcnew<System::FormatException>(_T("Only integer can be converted"));
        }
        int32_t x = 0;
        for(int32_t i = 0; (i < asn1->get_Value()->get_Length()); i++) {
            x = ((x << 8) + (int32_t)(asn1->get_Value()->at(i)));
        }
        return x;
    }
    
    System::String* ASN1Convert::ToOid(ASN1* asn1) {
        if((asn1 ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("asn1"));
        }
        cli::array<unsigned char> *aOID = asn1->get_Value();
        System::Text::StringBuilder *sb = cli::gcnew<System::Text::StringBuilder>();
        unsigned char x = (unsigned char)((int32_t)(aOID->at(0)) / 40);
        unsigned char y = (unsigned char)((int32_t)(aOID->at(0)) % 40);
        if(((int32_t)(x) > 2)) 
        {
            (y = (unsigned char)((int32_t)(y) + (int32_t)((unsigned char)(((int32_t)(x) - 2) * 40))));
            x = 2;
        }
        sb->Append2(cli::import(x)->ToString4(System::Globalization::CultureInfo::get_InvariantCulture()));
        sb->Append2(_T("."));
        sb->Append2(cli::import(y)->ToString4(System::Globalization::CultureInfo::get_InvariantCulture()));
        uint64_t val = 0UL;
        for(x = 1; ((int32_t)(x) < aOID->get_Length()); x++){
            val = ((val << 7) | (uint64_t)((unsigned char)((int32_t)(aOID->at((int32_t)(x))) & 127)));
            if(!((((int32_t)(aOID->at((int32_t)(x))) & 128) ==  128))) 
            {
                sb->Append2(_T("."));
                sb->Append2(cli::import(val)->ToString3(System::Globalization::CultureInfo::get_InvariantCulture()));
                val = 0UL;
            }
        }
        return sb->ToString_1636a0751cb9ac11();
    }
    
    System::DateTime ASN1Convert::ToDateTime(ASN1* time) {
        if((time ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("time"));
        }
        System::String *t = System::Text::Encoding::get_ASCII()->GetString_12d22365648431d7(time->get_Value());
        System::String *mask = nullptr;
        int32_t year;
        switch(t->get_Length()) {
            case 11: case_348: {
                mask = _T("yyMMddHHmmZ");
                break;
            }
            case 13: case_349: {
                year = (int32_t)(System::Convert::ToInt1613(t->Substring2(0, 2), System::Globalization::CultureInfo::get_InvariantCulture()));
                if((year >= 50)) 
                {
                    t = cli::concat(_T("19"), t);
                }
                 else 
                {
                    t = cli::concat(_T("20"), t);
                }
                mask = _T("yyyyMMddHHmmssZ");
                break;
            }
            case 15: case_350: {
                mask = _T("yyyyMMddHHmmssZ");
                break;
            }
            case 17: case_351: {
                year = (int32_t)(System::Convert::ToInt1613(t->Substring2(0, 2), System::Globalization::CultureInfo::get_InvariantCulture()));
                System::String *century = (year >= 50) ? _T("19") : _T("20");
                char16_t sign = ((int32_t)(t->get_Chars(12)) ==  43) ? u'-' : u'+';
                t = System::String::Format5(_T("{0}{1}{2}{3}{4}:{5}{6}"), (new cli::array<System::Object*>({century, t->Substring2(0, 12), cli::box(sign), cli::box(t->get_Chars(13)), cli::box(t->get_Chars(14)), cli::box(t->get_Chars(15)), cli::box(t->get_Chars(16))})));
                mask = _T("yyyyMMddHHmmsszzz");
                break;
            }
        }
        return System::DateTime::ParseExact2(t, mask, System::Globalization::CultureInfo::get_InvariantCulture(), System::Globalization::DateTimeStyles::AdjustToUniversal);
    }
    
}}
namespace Mono { namespace Security {
    
    
    void BitConverterLE::constructor() {
    }
    
    cli::array<unsigned char>* BitConverterLE::GetUShortBytes(unsigned char* bytes) {
        if(System::BitConverter::IsLittleEndian) 
        {
            return (new cli::array<unsigned char>({bytes[0], bytes[1]}));
        }
         else 
        {
            return (new cli::array<unsigned char>({bytes[1], bytes[0]}));
        }
    }
    
    cli::array<unsigned char>* BitConverterLE::GetUIntBytes(unsigned char* bytes) {
        if(System::BitConverter::IsLittleEndian) 
        {
            return (new cli::array<unsigned char>({bytes[0], bytes[1], bytes[2], bytes[3]}));
        }
         else 
        {
            return (new cli::array<unsigned char>({bytes[3], bytes[2], bytes[1], bytes[0]}));
        }
    }
    
    cli::array<unsigned char>* BitConverterLE::GetULongBytes(unsigned char* bytes) {
        if(System::BitConverter::IsLittleEndian) 
        {
            return (new cli::array<unsigned char>({bytes[0], bytes[1], bytes[2], bytes[3], bytes[4], bytes[5], bytes[6], bytes[7]}));
        }
         else 
        {
            return (new cli::array<unsigned char>({bytes[7], bytes[6], bytes[5], bytes[4], bytes[3], bytes[2], bytes[1], bytes[0]}));
        }
    }
    
    cli::array<unsigned char>* BitConverterLE::GetBytes(bool value) {
        return (new cli::array<unsigned char>({value ? 1 : 0}));
    }
    
    cli::array<unsigned char>* BitConverterLE::GetBytes2(char16_t value) {
        return GetUShortBytes((unsigned char*)(&(value)));
    }
    
    cli::array<unsigned char>* BitConverterLE::GetBytes3(int16_t value) {
        return GetUShortBytes((unsigned char*)(&(value)));
    }
    
    cli::array<unsigned char>* BitConverterLE::GetBytes4(int32_t value) {
        return GetUIntBytes((unsigned char*)(&(value)));
    }
    
    cli::array<unsigned char>* BitConverterLE::GetBytes5(int64_t value) {
        return GetULongBytes((unsigned char*)(&(value)));
    }
    
    cli::array<unsigned char>* BitConverterLE::GetBytes6(uint16_t value) {
        return GetUShortBytes((unsigned char*)(&(value)));
    }
    
    cli::array<unsigned char>* BitConverterLE::GetBytes7(uint32_t value) {
        return GetUIntBytes((unsigned char*)(&(value)));
    }
    
    cli::array<unsigned char>* BitConverterLE::GetBytes8(uint64_t value) {
        return GetULongBytes((unsigned char*)(&(value)));
    }
    
    cli::array<unsigned char>* BitConverterLE::GetBytes9(float value) {
        return GetUIntBytes((unsigned char*)(&(value)));
    }
    
    cli::array<unsigned char>* BitConverterLE::GetBytes10(double value) {
        return GetULongBytes((unsigned char*)(&(value)));
    }
    
    void BitConverterLE::UShortFromBytes(unsigned char* dst, cli::array<unsigned char>* src, int32_t startIndex) {
        if(System::BitConverter::IsLittleEndian) 
        {
            (*(dst + 0)) = src->at(startIndex);
            (*(dst + 1)) = src->at((startIndex + 1));
        }
         else 
        {
            (*(dst + 0)) = src->at((startIndex + 1));
            (*(dst + 1)) = src->at(startIndex);
        }
    }
    
    void BitConverterLE::UIntFromBytes(unsigned char* dst, cli::array<unsigned char>* src, int32_t startIndex) {
        if(System::BitConverter::IsLittleEndian) 
        {
            (*(dst + 0)) = src->at(startIndex);
            (*(dst + 1)) = src->at((startIndex + 1));
            (*(dst + 2)) = src->at((startIndex + 2));
            (*(dst + 3)) = src->at((startIndex + 3));
        }
         else 
        {
            (*(dst + 0)) = src->at((startIndex + 3));
            (*(dst + 1)) = src->at((startIndex + 2));
            (*(dst + 2)) = src->at((startIndex + 1));
            (*(dst + 3)) = src->at(startIndex);
        }
    }
    
    void BitConverterLE::ULongFromBytes(unsigned char* dst, cli::array<unsigned char>* src, int32_t startIndex) {
        if(System::BitConverter::IsLittleEndian) 
        {
            for(int32_t i = 0; (i < 8); ++i) {
                (*(dst + i)) = src->at((startIndex + i));
            }
        }
         else 
        {
            for(int32_t i = 0; (i < 8); ++i) {
                (*(dst + i)) = src->at((startIndex + (7 - i)));
            }
        }
    }
    
    bool BitConverterLE::ToBoolean(cli::array<unsigned char>* value, int32_t startIndex) {
        return ((int32_t)(value->at(startIndex)) != 0);
    }
    
    char16_t BitConverterLE::ToChar(cli::array<unsigned char>* value, int32_t startIndex) {
        char16_t ret;
        UShortFromBytes((unsigned char*)(&(ret)), value, startIndex);
        return ret;
    }
    
    int16_t BitConverterLE::ToInt16(cli::array<unsigned char>* value, int32_t startIndex) {
        int16_t ret;
        UShortFromBytes((unsigned char*)(&(ret)), value, startIndex);
        return ret;
    }
    
    int32_t BitConverterLE::ToInt32(cli::array<unsigned char>* value, int32_t startIndex) {
        int32_t ret;
        UIntFromBytes((unsigned char*)(&(ret)), value, startIndex);
        return ret;
    }
    
    int64_t BitConverterLE::ToInt64(cli::array<unsigned char>* value, int32_t startIndex) {
        int64_t ret;
        ULongFromBytes((unsigned char*)(&(ret)), value, startIndex);
        return ret;
    }
    
    uint16_t BitConverterLE::ToUInt16(cli::array<unsigned char>* value, int32_t startIndex) {
        uint16_t ret;
        UShortFromBytes((unsigned char*)(&(ret)), value, startIndex);
        return ret;
    }
    
    uint32_t BitConverterLE::ToUInt32(cli::array<unsigned char>* value, int32_t startIndex) {
        uint32_t ret;
        UIntFromBytes((unsigned char*)(&(ret)), value, startIndex);
        return ret;
    }
    
    uint64_t BitConverterLE::ToUInt64(cli::array<unsigned char>* value, int32_t startIndex) {
        uint64_t ret;
        ULongFromBytes((unsigned char*)(&(ret)), value, startIndex);
        return ret;
    }
    
    float BitConverterLE::ToSingle(cli::array<unsigned char>* value, int32_t startIndex) {
        float ret;
        UIntFromBytes((unsigned char*)(&(ret)), value, startIndex);
        return ret;
    }
    
    double BitConverterLE::ToDouble(cli::array<unsigned char>* value, int32_t startIndex) {
        double ret;
        ULongFromBytes((unsigned char*)(&(ret)), value, startIndex);
        return ret;
    }
    
}}
namespace Mono { namespace Security {
    
    
    void Oid::constructor() {
    }
    
}}
namespace Mono { namespace Security {
    
    
    void ContentInfo::constructor() {
        this->content = cli::gcnew<ASN1>(160);
    }
    
    void ContentInfo::constructor(System::String* oid) {
        this->contentType = oid;
    }
    
    void ContentInfo::constructor(cli::array<unsigned char>* data) {
    }
    
    void ContentInfo::constructor(ASN1* asn1) {
        if((((int32_t)(asn1->get_Tag()) != 48) || ((asn1->get_Count() < 1) && (asn1->get_Count() > 2)))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Invalid ASN1"));
        }
        if(((int32_t)(asn1->get_Item(0)->get_Tag()) != 6)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Invalid contentType"));
        }
        this->contentType = ASN1Convert::ToOid(asn1->get_Item(0));
        if((asn1->get_Count() > 1)) 
        {
            if(((int32_t)(asn1->get_Item(1)->get_Tag()) != 160)) 
            {
                throw cli::gcnew<System::ArgumentException>(_T("Invalid content"));
            }
            this->content = asn1->get_Item(1);
        }
    }
    
    ASN1* ContentInfo::GetASN1() {
        ASN1 *contentInfo = cli::gcnew<ASN1>(48);
        contentInfo->Add(ASN1Convert::FromOid(this->contentType));
        if(((this->content != nullptr) && (this->content->get_Count() > 0))) 
        {
            contentInfo->Add(this->content);
        }
        return contentInfo;
    }
    
    cli::array<unsigned char>* ContentInfo::GetBytes() {
        return GetASN1()->GetBytes_b91405229279a4ac();
    }
    
    ASN1* ContentInfo::get_ASN1() {
        return GetASN1();
    }
    
    ASN1* ContentInfo::get_Content() {
        return this->content;
    }
    
    ASN1* ContentInfo::set_Content(ASN1* value) {
        this->content = value;
        return get_Content();
    }
    
    System::String* ContentInfo::get_ContentType() {
        return this->contentType;
    }
    
    System::String* ContentInfo::set_ContentType(System::String* value) {
        this->contentType = value;
        return get_ContentType();
    }
    
}}
namespace Mono { namespace Security {
    
    
    void EncryptedData::constructor() {
        this->_version = 0;
    }
    
    void EncryptedData::constructor(cli::array<unsigned char>* data) {
    }
    
    void EncryptedData::constructor(ASN1* asn1) {
        if((((int32_t)(asn1->get_Tag()) != 48) || (asn1->get_Count() < 2))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Invalid EncryptedData"));
        }
        if(((int32_t)(asn1->get_Item(0)->get_Tag()) != 2)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Invalid version"));
        }
        this->_version = asn1->get_Item(0)->get_Value()->at(0);
        ASN1 *encryptedContentInfo = asn1->get_Item(1);
        if(((int32_t)(encryptedContentInfo->get_Tag()) != 48)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("missing EncryptedContentInfo"));
        }
        ASN1 *contentType = encryptedContentInfo->get_Item(0);
        if(((int32_t)(contentType->get_Tag()) != 6)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("missing EncryptedContentInfo.ContentType"));
        }
        this->_content = cli::gcnew<ContentInfo>(ASN1Convert::ToOid(contentType));
        ASN1 *contentEncryptionAlgorithm = encryptedContentInfo->get_Item(1);
        if(((int32_t)(contentEncryptionAlgorithm->get_Tag()) != 48)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("missing EncryptedContentInfo.ContentEncryptionAlgorithmIdentifier"));
        }
        this->_encryptionAlgorithm = cli::gcnew<ContentInfo>(ASN1Convert::ToOid(contentEncryptionAlgorithm->get_Item(0)));
        this->_encryptionAlgorithm->set_Content(contentEncryptionAlgorithm->get_Item(1));
        ASN1 *encryptedContent = encryptedContentInfo->get_Item(2);
        if(((int32_t)(encryptedContent->get_Tag()) != 128)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("missing EncryptedContentInfo.EncryptedContent"));
        }
        this->_encrypted = encryptedContent->get_Value();
    }
    
    ASN1* EncryptedData::GetASN1() {
        return nullptr;
    }
    
    cli::array<unsigned char>* EncryptedData::GetBytes() {
        return GetASN1()->GetBytes_b91405229279a4ac();
    }
    
    ASN1* EncryptedData::get_ASN1() {
        return GetASN1();
    }
    
    ContentInfo* EncryptedData::get_ContentInfo() {
        return this->_content;
    }
    
    ContentInfo* EncryptedData::get_EncryptionAlgorithm() {
        return this->_encryptionAlgorithm;
    }
    
    cli::array<unsigned char>* EncryptedData::get_EncryptedContent() {
        if((this->_encrypted ==  nullptr)) 
        {
            return nullptr;
        }
        return cli::cast<cli::array<unsigned char>*>(cli::import(this->_encrypted)->Clone());
    }
    
    unsigned char EncryptedData::get_Version() {
        return this->_version;
    }
    
    unsigned char EncryptedData::set_Version(unsigned char value) {
        this->_version = value;
        return get_Version();
    }
    
}}
namespace Mono { namespace Security {
    
    
    void EnvelopedData::constructor() {
        this->_version = 0;
        this->_content = cli::gcnew<ContentInfo>();
        this->_encryptionAlgorithm = cli::gcnew<ContentInfo>();
        this->_recipientInfos = cli::gcnew<System::Collections::ArrayList>();
    }
    
    void EnvelopedData::constructor(cli::array<unsigned char>* data) {
    }
    
    void EnvelopedData::constructor(ASN1* asn1) {
        if((((int32_t)(asn1->get_Item(0)->get_Tag()) != 48) || (asn1->get_Item(0)->get_Count() < 3))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Invalid EnvelopedData"));
        }
        if(((int32_t)(asn1->get_Item(0)->get_Item(0)->get_Tag()) != 2)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Invalid version"));
        }
        this->_version = asn1->get_Item(0)->get_Item(0)->get_Value()->at(0);
        ASN1 *recipientInfos = asn1->get_Item(0)->get_Item(1);
        if(((int32_t)(recipientInfos->get_Tag()) != 49)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("missing RecipientInfos"));
        }
        for(int32_t i = 0; (i < recipientInfos->get_Count()); i++){
            ASN1 *recipientInfo = recipientInfos->get_Item(i);
            this->_recipientInfos->Add_e6a92085999ce388(cli::gcnew<RecipientInfo>(recipientInfo));
        }
        ASN1 *encryptedContentInfo = asn1->get_Item(0)->get_Item(2);
        if(((int32_t)(encryptedContentInfo->get_Tag()) != 48)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("missing EncryptedContentInfo"));
        }
        ASN1 *contentType = encryptedContentInfo->get_Item(0);
        if(((int32_t)(contentType->get_Tag()) != 6)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("missing EncryptedContentInfo.ContentType"));
        }
        this->_content = cli::gcnew<ContentInfo>(ASN1Convert::ToOid(contentType));
        ASN1 *contentEncryptionAlgorithm = encryptedContentInfo->get_Item(1);
        if(((int32_t)(contentEncryptionAlgorithm->get_Tag()) != 48)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("missing EncryptedContentInfo.ContentEncryptionAlgorithmIdentifier"));
        }
        this->_encryptionAlgorithm = cli::gcnew<ContentInfo>(ASN1Convert::ToOid(contentEncryptionAlgorithm->get_Item(0)));
        this->_encryptionAlgorithm->set_Content(contentEncryptionAlgorithm->get_Item(1));
        ASN1 *encryptedContent = encryptedContentInfo->get_Item(2);
        if(((int32_t)(encryptedContent->get_Tag()) != 128)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("missing EncryptedContentInfo.EncryptedContent"));
        }
        this->_encrypted = encryptedContent->get_Value();
    }
    
    ASN1* EnvelopedData::GetASN1() {
        ASN1 *signedData = cli::gcnew<ASN1>(48);
        return signedData;
    }
    
    cli::array<unsigned char>* EnvelopedData::GetBytes() {
        return GetASN1()->GetBytes_b91405229279a4ac();
    }
    
    System::Collections::ArrayList* EnvelopedData::get_RecipientInfos() {
        return this->_recipientInfos;
    }
    
    ASN1* EnvelopedData::get_ASN1() {
        return GetASN1();
    }
    
    ContentInfo* EnvelopedData::get_ContentInfo() {
        return this->_content;
    }
    
    ContentInfo* EnvelopedData::get_EncryptionAlgorithm() {
        return this->_encryptionAlgorithm;
    }
    
    cli::array<unsigned char>* EnvelopedData::get_EncryptedContent() {
        if((this->_encrypted ==  nullptr)) 
        {
            return nullptr;
        }
        return cli::cast<cli::array<unsigned char>*>(cli::import(this->_encrypted)->Clone());
    }
    
    unsigned char EnvelopedData::get_Version() {
        return this->_version;
    }
    
    unsigned char EnvelopedData::set_Version(unsigned char value) {
        this->_version = value;
        return get_Version();
    }
    
}}
namespace Mono { namespace Security {
    
    
    void RecipientInfo::constructor() {
    }
    
    void RecipientInfo::constructor(ASN1* data) {
        if(((int32_t)(data->get_Tag()) != 48)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Invalid RecipientInfo"));
        }
        ASN1 *version = data->get_Item(0);
        if(((int32_t)(version->get_Tag()) != 2)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("missing Version"));
        }
        this->_version = (int32_t)(version->get_Value()->at(0));
        ASN1 *subjectIdentifierType = data->get_Item(1);
        if((((int32_t)(subjectIdentifierType->get_Tag()) ==  128) && (this->_version ==  3))) 
        {
            this->_ski = subjectIdentifierType->get_Value();
        }
         else 
        {
            this->_issuer = X509::X501::ToString2(subjectIdentifierType->get_Item(0));
            this->_serial = subjectIdentifierType->get_Item(1)->get_Value();
        }
        ASN1 *keyEncryptionAlgorithm = data->get_Item(2);
        this->_oid = ASN1Convert::ToOid(keyEncryptionAlgorithm->get_Item(0));
        ASN1 *encryptedKey = data->get_Item(3);
        this->_key = encryptedKey->get_Value();
    }
    
    System::String* RecipientInfo::get_Oid() {
        return this->_oid;
    }
    
    cli::array<unsigned char>* RecipientInfo::get_Key() {
        if((this->_key ==  nullptr)) 
        {
            return nullptr;
        }
        return cli::cast<cli::array<unsigned char>*>(cli::import(this->_key)->Clone());
    }
    
    cli::array<unsigned char>* RecipientInfo::get_SubjectKeyIdentifier() {
        if((this->_ski ==  nullptr)) 
        {
            return nullptr;
        }
        return cli::cast<cli::array<unsigned char>*>(cli::import(this->_ski)->Clone());
    }
    
    System::String* RecipientInfo::get_Issuer() {
        return this->_issuer;
    }
    
    cli::array<unsigned char>* RecipientInfo::get_Serial() {
        if((this->_serial ==  nullptr)) 
        {
            return nullptr;
        }
        return cli::cast<cli::array<unsigned char>*>(cli::import(this->_serial)->Clone());
    }
    
    int32_t RecipientInfo::get_Version() {
        return this->_version;
    }
    
}}
namespace Mono { namespace Security {
    
    
    void SignedData::constructor() {
        this->version = 1;
        this->contentInfo = cli::gcnew<ContentInfo>();
        this->certs = cli::gcnew<X509::X509CertificateCollection>();
        this->crls = cli::gcnew<System::Collections::ArrayList>();
        this->signerInfo = cli::gcnew<SignerInfo>();
        this->mda = true;
        this->signed_ = false;
    }
    
    void SignedData::constructor(cli::array<unsigned char>* data) {
    }
    
    void SignedData::constructor(ASN1* asn1) {
        if((((int32_t)(asn1->get_Item(0)->get_Tag()) != 48) || (asn1->get_Item(0)->get_Count() < 4))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Invalid SignedData"));
        }
        if(((int32_t)(asn1->get_Item(0)->get_Item(0)->get_Tag()) != 2)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Invalid version"));
        }
        this->version = asn1->get_Item(0)->get_Item(0)->get_Value()->at(0);
        this->contentInfo = cli::gcnew<ContentInfo>(asn1->get_Item(0)->get_Item(2));
        int32_t n = 3;
        this->certs = cli::gcnew<X509::X509CertificateCollection>();
        if(((int32_t)(asn1->get_Item(0)->get_Item(n)->get_Tag()) ==  160)) 
        {
            for(int32_t i = 0; (i < asn1->get_Item(0)->get_Item(n)->get_Count()); i++) {
                this->certs->Add2(cli::gcnew<X509::X509Certificate>(asn1->get_Item(0)->get_Item(n)->get_Item(i)->GetBytes_b91405229279a4ac()));
            }
            n++;
        }
        this->crls = cli::gcnew<System::Collections::ArrayList>();
        if(((int32_t)(asn1->get_Item(0)->get_Item(n)->get_Tag()) ==  161)) 
        {
            for(int32_t i = 0; (i < asn1->get_Item(0)->get_Item(n)->get_Count()); i++) {
                this->crls->Add_e6a92085999ce388(asn1->get_Item(0)->get_Item(n)->get_Item(i)->GetBytes_b91405229279a4ac());
            }
            n++;
        }
        if((asn1->get_Item(0)->get_Item(n)->get_Count() > 0)) 
        {
            this->signerInfo = cli::gcnew<SignerInfo>(asn1->get_Item(0)->get_Item(n));
        }
         else 
        {
            this->signerInfo = cli::gcnew<SignerInfo>();
        }
        if((this->signerInfo->get_HashName() != nullptr)) 
        {
            this->set_HashName(OidToName(this->signerInfo->get_HashName()));
        }
        this->mda = (this->signerInfo->get_AuthenticatedAttributes()->get_Count_2354963792616712() > 0);
    }
    
    bool SignedData::VerifySignature(System::Security::Cryptography::AsymmetricAlgorithm* aa) {
        if((aa ==  nullptr)) 
        {
            return false;
        }
        System::Security::Cryptography::RSAPKCS1SignatureDeformatter *r = cli::gcnew<System::Security::Cryptography::RSAPKCS1SignatureDeformatter>(aa);
        r->SetHashAlgorithm_5a7fb9c08aaf7ac9(this->hashAlgorithm);
        System::Security::Cryptography::HashAlgorithm *ha = System::Security::Cryptography::HashAlgorithm::Create2(this->hashAlgorithm);
        cli::array<unsigned char> *signature = this->signerInfo->get_Signature();
        cli::array<unsigned char> *hash = nullptr;
        if(this->mda) 
        {
            ASN1 *asn = cli::gcnew<ASN1>(49);
            for(auto tmp_55 : this->signerInfo->get_AuthenticatedAttributes()) {
                auto attr = cli::cast<ASN1*>(tmp_55);
                asn->Add(attr);
            }
            hash = ha->ComputeHash(asn->GetBytes_b91405229279a4ac());
        }
         else 
        {
            hash = ha->ComputeHash(this->contentInfo->get_Content()->get_Item(0)->get_Value());
        }
        if(((hash != nullptr) && (signature != nullptr))) 
        {
            return r->VerifySignature_ecf649797288645c(hash, signature);
        }
        return false;
    }
    
    System::String* SignedData::OidToName(System::String* oid) {
        System::String* tmp_56 = oid;
        ::System::Int32 tmp_57 = -1;
        if(::System::String::Equals3(tmp_56, _T("1.3.14.3.2.26"))) tmp_57 = 0;
        if(::System::String::Equals3(tmp_56, _T("1.2.840.113549.2.2"))) tmp_57 = 1;
        if(::System::String::Equals3(tmp_56, _T("1.2.840.113549.2.5"))) tmp_57 = 2;
        if(::System::String::Equals3(tmp_56, _T("2.16.840.1.101.3.4.1"))) tmp_57 = 3;
        if(::System::String::Equals3(tmp_56, _T("2.16.840.1.101.3.4.2"))) tmp_57 = 4;
        if(::System::String::Equals3(tmp_56, _T("2.16.840.1.101.3.4.3"))) tmp_57 = 5;
        switch(tmp_57)
        {
            case 0: case_352: 
            {
                return _T("SHA1");
            }
            case 1: case_353: 
            {
                return _T("MD2");
            }
            case 2: case_354: 
            {
                return _T("MD5");
            }
            case 3: case_355: 
            {
                return _T("SHA256");
            }
            case 4: case_356: 
            {
                return _T("SHA384");
            }
            case 5: case_357: 
            {
                return _T("SHA512");
            }
            default: case_358: 
            {
                break;
            }
        }
        return oid;
    }
    
    ASN1* SignedData::GetASN1() {
        ASN1 *signedData = cli::gcnew<ASN1>(48);
        cli::array<unsigned char> *ver = (new cli::array<unsigned char>({version}));
        signedData->Add(cli::gcnew<ASN1>(2, ver));
        ASN1 *digestAlgorithms = signedData->Add(cli::gcnew<ASN1>(49));
        if((this->hashAlgorithm != nullptr)) 
        {
            System::String *hashOid = System::Security::Cryptography::CryptoConfig::MapNameToOID(this->hashAlgorithm);
            digestAlgorithms->Add(PKCS7::AlgorithmIdentifier(hashOid));
        }
        ASN1 *ci = this->contentInfo->get_ASN1();
        signedData->Add(ci);
        if((!(this->signed_) && (this->hashAlgorithm != nullptr))) 
        {
            if(this->mda) 
            {
                ASN1 *ctattr = PKCS7::Attribute2(_T("1.2.840.113549.1.9.3"), ci->get_Item(0));
                this->signerInfo->get_AuthenticatedAttributes()->Add_e6a92085999ce388(ctattr);
                System::Security::Cryptography::HashAlgorithm *ha = System::Security::Cryptography::HashAlgorithm::Create2(this->hashAlgorithm);
                cli::array<unsigned char> *idcHash = ha->ComputeHash(ci->get_Item(1)->get_Item(0)->get_Value());
                ASN1 *md = cli::gcnew<ASN1>(48);
                ASN1 *mdattr = PKCS7::Attribute2(_T("1.2.840.113549.1.9.4"), md->Add(cli::gcnew<ASN1>(4, idcHash)));
                this->signerInfo->get_AuthenticatedAttributes()->Add_e6a92085999ce388(mdattr);
            }
             else 
            {
                System::Security::Cryptography::RSAPKCS1SignatureFormatter *r = cli::gcnew<System::Security::Cryptography::RSAPKCS1SignatureFormatter>(this->signerInfo->get_Key());
                r->SetHashAlgorithm_9029a89c4cb706ce(this->hashAlgorithm);
                System::Security::Cryptography::HashAlgorithm *ha = System::Security::Cryptography::HashAlgorithm::Create2(this->hashAlgorithm);
                cli::array<unsigned char> *sig = ha->ComputeHash(ci->get_Item(1)->get_Item(0)->get_Value());
                this->signerInfo->set_Signature(r->CreateSignature_119f8aceb75b0d2(sig));
            }
            this->signed_ = true;
        }
        if((this->certs->get_Count() > 0)) 
        {
            ASN1 *a0 = signedData->Add(cli::gcnew<ASN1>(160));
            for(auto tmp_58 : this->certs) {
                auto x = cli::cast<X509::X509Certificate*>(tmp_58);
                a0->Add(cli::gcnew<ASN1>(x->get_RawData_c0a18e988d76611c()));
            }
        }
        if((this->crls->get_Count_2354963792616712() > 0)) 
        {
            ASN1 *a1 = signedData->Add(cli::gcnew<ASN1>(161));
            for(auto tmp_59 : this->crls) {
                auto crl = cli::cast<cli::array<unsigned char>*>(tmp_59);
                a1->Add(cli::gcnew<ASN1>(crl));
            }
        }
        ASN1 *signerInfos = signedData->Add(cli::gcnew<ASN1>(49));
        if((this->signerInfo->get_Key() != nullptr)) 
        {
            signerInfos->Add(this->signerInfo->get_ASN1());
        }
        return signedData;
    }
    
    cli::array<unsigned char>* SignedData::GetBytes() {
        return GetASN1()->GetBytes_b91405229279a4ac();
    }
    
    ASN1* SignedData::get_ASN1() {
        return GetASN1();
    }
    
    X509::X509CertificateCollection* SignedData::get_Certificates() {
        return this->certs;
    }
    
    ContentInfo* SignedData::get_ContentInfo() {
        return this->contentInfo;
    }
    
    System::Collections::ArrayList* SignedData::get_Crls() {
        return this->crls;
    }
    
    System::String* SignedData::get_HashName() {
        return this->hashAlgorithm;
    }
    
    System::String* SignedData::set_HashName(System::String* value) {
        this->hashAlgorithm = value;
        this->signerInfo->set_HashName(value);
        return get_HashName();
    }
    
    SignerInfo* SignedData::get_SignerInfo() {
        return this->signerInfo;
    }
    
    unsigned char SignedData::get_Version() {
        return this->version;
    }
    
    unsigned char SignedData::set_Version(unsigned char value) {
        this->version = value;
        return get_Version();
    }
    
    bool SignedData::get_UseAuthenticatedAttributes() {
        return this->mda;
    }
    
    bool SignedData::set_UseAuthenticatedAttributes(bool value) {
        this->mda = value;
        return get_UseAuthenticatedAttributes();
    }
    
}}
namespace Mono { namespace Security {
    
    
    void SignerInfo::constructor() {
        this->version = 1;
        this->authenticatedAttributes = cli::gcnew<System::Collections::ArrayList>();
        this->unauthenticatedAttributes = cli::gcnew<System::Collections::ArrayList>();
    }
    
    void SignerInfo::constructor(cli::array<unsigned char>* data) {
    }
    
    void SignerInfo::constructor(ASN1* asn1) {
        if((((int32_t)(asn1->get_Item(0)->get_Tag()) != 48) || (asn1->get_Item(0)->get_Count() < 5))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Invalid SignedData"));
        }
        if(((int32_t)(asn1->get_Item(0)->get_Item(0)->get_Tag()) != 2)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Invalid version"));
        }
        this->version = asn1->get_Item(0)->get_Item(0)->get_Value()->at(0);
        ASN1 *subjectIdentifierType = asn1->get_Item(0)->get_Item(1);
        if((((int32_t)(subjectIdentifierType->get_Tag()) ==  128) && ((int32_t)(this->version) ==  3))) 
        {
            this->ski = subjectIdentifierType->get_Value();
        }
         else 
        {
            this->issuer = X509::X501::ToString2(subjectIdentifierType->get_Item(0));
            this->serial = subjectIdentifierType->get_Item(1)->get_Value();
        }
        ASN1 *digestAlgorithm = asn1->get_Item(0)->get_Item(2);
        this->hashAlgorithm = ASN1Convert::ToOid(digestAlgorithm->get_Item(0));
        int32_t n = 3;
        ASN1 *authAttributes = asn1->get_Item(0)->get_Item(n);
        if(((int32_t)(authAttributes->get_Tag()) ==  160)) 
        {
            n++;
            for(int32_t i = 0; (i < authAttributes->get_Count()); i++) {
                this->authenticatedAttributes->Add_e6a92085999ce388(authAttributes->get_Item(i));
            }
        }
        n++;
        ASN1 *encryptedDigest = asn1->get_Item(0)->get_Item(n++);
        if(((int32_t)(encryptedDigest->get_Tag()) ==  4)) 
        {
            this->signature = encryptedDigest->get_Value();
        }
        ASN1 *unauthAttributes = asn1->get_Item(0)->get_Item(n);
        if(((unauthAttributes != nullptr) && ((int32_t)(unauthAttributes->get_Tag()) ==  161))) 
        {
            for(int32_t i = 0; (i < unauthAttributes->get_Count()); i++) {
                this->unauthenticatedAttributes->Add_e6a92085999ce388(unauthAttributes->get_Item(i));
            }
        }
    }
    
    ASN1* SignerInfo::GetASN1() {
        if(((this->key ==  nullptr) || (this->hashAlgorithm ==  nullptr))) 
        {
            return nullptr;
        }
        cli::array<unsigned char> *ver = (new cli::array<unsigned char>({version}));
        ASN1 *signerInfo = cli::gcnew<ASN1>(48);
        signerInfo->Add(cli::gcnew<ASN1>(2, ver));
        signerInfo->Add(PKCS7::IssuerAndSerialNumber(this->x509));
        System::String *hashOid = System::Security::Cryptography::CryptoConfig::MapNameToOID(this->hashAlgorithm);
        signerInfo->Add(PKCS7::AlgorithmIdentifier(hashOid));
        ASN1 *aa = nullptr;
        if((this->authenticatedAttributes->get_Count_2354963792616712() > 0)) 
        {
            aa = signerInfo->Add(cli::gcnew<ASN1>(160));
            for(auto tmp_60 : this->authenticatedAttributes) {
                auto attr = cli::cast<ASN1*>(tmp_60);
                aa->Add(attr);
            }
        }
        if(cli::is<System::Security::Cryptography::RSA>(this->key)) 
        {
            signerInfo->Add(PKCS7::AlgorithmIdentifier(_T("1.2.840.113549.1.1.1")));
            if((aa != nullptr)) 
            {
                System::Security::Cryptography::RSAPKCS1SignatureFormatter *r = cli::gcnew<System::Security::Cryptography::RSAPKCS1SignatureFormatter>(this->key);
                r->SetHashAlgorithm_9029a89c4cb706ce(this->hashAlgorithm);
                cli::array<unsigned char> *tbs = aa->GetBytes_b91405229279a4ac();
                tbs->at(0) = 49;
                System::Security::Cryptography::HashAlgorithm *ha = System::Security::Cryptography::HashAlgorithm::Create2(this->hashAlgorithm);
                cli::array<unsigned char> *tbsHash = ha->ComputeHash(tbs);
                this->signature = r->CreateSignature_119f8aceb75b0d2(tbsHash);
            }
        }
         else 
        {
            if(cli::is<System::Security::Cryptography::DSA>(this->key)) 
            {
                throw cli::gcnew<System::NotImplementedException>(_T("not yet"));
            }
             else 
            {
                throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("Unknown assymetric algorithm"));
            }
        }
        signerInfo->Add(cli::gcnew<ASN1>(4, this->signature));
        if((this->unauthenticatedAttributes->get_Count_2354963792616712() > 0)) 
        {
            ASN1 *ua = signerInfo->Add(cli::gcnew<ASN1>(161));
            for(auto tmp_61 : this->unauthenticatedAttributes) {
                auto attr = cli::cast<ASN1*>(tmp_61);
                ua->Add(attr);
            }
        }
        return signerInfo;
    }
    
    cli::array<unsigned char>* SignerInfo::GetBytes() {
        return GetASN1()->GetBytes_b91405229279a4ac();
    }
    
    System::String* SignerInfo::get_IssuerName() {
        return this->issuer;
    }
    
    cli::array<unsigned char>* SignerInfo::get_SerialNumber() {
        if((this->serial ==  nullptr)) 
        {
            return nullptr;
        }
        return cli::cast<cli::array<unsigned char>*>(cli::import(this->serial)->Clone());
    }
    
    cli::array<unsigned char>* SignerInfo::get_SubjectKeyIdentifier() {
        if((this->ski ==  nullptr)) 
        {
            return nullptr;
        }
        return cli::cast<cli::array<unsigned char>*>(cli::import(this->ski)->Clone());
    }
    
    ASN1* SignerInfo::get_ASN1() {
        return GetASN1();
    }
    
    System::Collections::ArrayList* SignerInfo::get_AuthenticatedAttributes() {
        return this->authenticatedAttributes;
    }
    
    X509::X509Certificate* SignerInfo::get_Certificate() {
        return this->x509;
    }
    
    X509::X509Certificate* SignerInfo::set_Certificate(X509::X509Certificate* value) {
        this->x509 = value;
        return get_Certificate();
    }
    
    System::String* SignerInfo::get_HashName() {
        return this->hashAlgorithm;
    }
    
    System::String* SignerInfo::set_HashName(System::String* value) {
        this->hashAlgorithm = value;
        return get_HashName();
    }
    
    System::Security::Cryptography::AsymmetricAlgorithm* SignerInfo::get_Key() {
        return this->key;
    }
    
    System::Security::Cryptography::AsymmetricAlgorithm* SignerInfo::set_Key(System::Security::Cryptography::AsymmetricAlgorithm* value) {
        this->key = value;
        return get_Key();
    }
    
    cli::array<unsigned char>* SignerInfo::get_Signature() {
        if((this->signature ==  nullptr)) 
        {
            return nullptr;
        }
        return cli::cast<cli::array<unsigned char>*>(cli::import(this->signature)->Clone());
    }
    
    cli::array<unsigned char>* SignerInfo::set_Signature(cli::array<unsigned char>* value) {
        if((value != nullptr)) 
        {
            this->signature = cli::cast<cli::array<unsigned char>*>(cli::import(value)->Clone());
        }
        return get_Signature();
    }
    
    System::Collections::ArrayList* SignerInfo::get_UnauthenticatedAttributes() {
        return this->unauthenticatedAttributes;
    }
    
    unsigned char SignerInfo::get_Version() {
        return this->version;
    }
    
    unsigned char SignerInfo::set_Version(unsigned char value) {
        this->version = value;
        return get_Version();
    }
    
}}
namespace Mono { namespace Security {
    
    
    void PKCS7::constructor() {
    }
    
    ASN1* PKCS7::Attribute2(System::String* oid, ASN1* value) {
        ASN1 *attr = cli::gcnew<ASN1>(48);
        attr->Add(ASN1Convert::FromOid(oid));
        ASN1 *aset = attr->Add(cli::gcnew<ASN1>(49));
        aset->Add(value);
        return attr;
    }
    
    ASN1* PKCS7::AlgorithmIdentifier(System::String* oid) {
        ASN1 *ai = cli::gcnew<ASN1>(48);
        ai->Add(ASN1Convert::FromOid(oid));
        ai->Add(cli::gcnew<ASN1>(5));
        return ai;
    }
    
    ASN1* PKCS7::AlgorithmIdentifier2(System::String* oid, ASN1* parameters) {
        ASN1 *ai = cli::gcnew<ASN1>(48);
        ai->Add(ASN1Convert::FromOid(oid));
        ai->Add(parameters);
        return ai;
    }
    
    ASN1* PKCS7::IssuerAndSerialNumber(X509::X509Certificate* x509) {
        ASN1 *issuer = nullptr;
        ASN1 *serial = nullptr;
        ASN1 *cert = cli::gcnew<ASN1>(x509->get_RawData_c0a18e988d76611c());
        int32_t tbs = 0;
        bool flag = false;
        while((tbs < cert->get_Item(0)->get_Count())) {
            ASN1 *e = cert->get_Item(0)->get_Item(tbs++);
            if(((int32_t)(e->get_Tag()) ==  2)) 
            {
                serial = e;
            }
             else 
            {
                if(((int32_t)(e->get_Tag()) ==  48)) 
                {
                    if(flag) 
                    {
                        issuer = e;
                        break;
                    }
                    flag = true;
                }
            }
        }
        ASN1 *iasn = cli::gcnew<ASN1>(48);
        iasn->Add(issuer);
        iasn->Add(serial);
        return iasn;
    }
    
}}
namespace Mono { namespace Security {
    
    
    void StrongNameSignature::constructor() {
    }
    
    cli::array<unsigned char>* StrongNameSignature::get_Hash() {
        return this->hash;
    }
    
    cli::array<unsigned char>* StrongNameSignature::set_Hash(cli::array<unsigned char>* value) {
        this->hash = value;
        return get_Hash();
    }
    
    cli::array<unsigned char>* StrongNameSignature::get_Signature() {
        return this->signature;
    }
    
    cli::array<unsigned char>* StrongNameSignature::set_Signature(cli::array<unsigned char>* value) {
        this->signature = value;
        return get_Signature();
    }
    
    uint32_t StrongNameSignature::get_MetadataPosition() {
        return this->metadataPosition;
    }
    
    uint32_t StrongNameSignature::set_MetadataPosition(uint32_t value) {
        this->metadataPosition = value;
        return get_MetadataPosition();
    }
    
    uint32_t StrongNameSignature::get_MetadataLength() {
        return this->metadataLength;
    }
    
    uint32_t StrongNameSignature::set_MetadataLength(uint32_t value) {
        this->metadataLength = value;
        return get_MetadataLength();
    }
    
    uint32_t StrongNameSignature::get_SignaturePosition() {
        return this->signaturePosition;
    }
    
    uint32_t StrongNameSignature::set_SignaturePosition(uint32_t value) {
        this->signaturePosition = value;
        return get_SignaturePosition();
    }
    
    uint32_t StrongNameSignature::get_SignatureLength() {
        return this->signatureLength;
    }
    
    uint32_t StrongNameSignature::set_SignatureLength(uint32_t value) {
        this->signatureLength = value;
        return get_SignatureLength();
    }
    
    unsigned char StrongNameSignature::get_CliFlag() {
        return this->cliFlag;
    }
    
    unsigned char StrongNameSignature::set_CliFlag(unsigned char value) {
        this->cliFlag = value;
        return get_CliFlag();
    }
    
    uint32_t StrongNameSignature::get_CliFlagPosition() {
        return this->cliFlagPosition;
    }
    
    uint32_t StrongNameSignature::set_CliFlagPosition(uint32_t value) {
        this->cliFlagPosition = value;
        return get_CliFlagPosition();
    }
    
}}
namespace Mono { namespace Security {
    
    System::Object*  StrongName::lockObject;
    bool  StrongName::initialized;
    
    StrongName::StrongName()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void StrongName::constructor() {
    }
    
    void StrongName::constructor(int32_t keySize) {
        this->rsa = cli::gcnew<Cryptography::RSAManaged>(keySize);
    }
    
    void StrongName::constructor(cli::array<unsigned char>* data) {
        if((data ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("data"));
        }
        if((data->get_Length() ==  16)) 
        {
            int32_t i = 0;
            int32_t sum = 0;
            while((i < data->get_Length())) (sum = sum + (int32_t)(data->at(i++)));
            if((sum ==  4)) 
            {
                this->publicKey = cli::cast<cli::array<unsigned char>*>(cli::import(data)->Clone());
            }
        }
         else 
        {
            this->set_RSA(Cryptography::CryptoConvert::FromCapiKeyBlob(data));
            if((this->rsa ==  nullptr)) 
            {
                throw cli::gcnew<System::ArgumentException>(_T("data isn\'t a correctly encoded RSA public key"));
            }
        }
    }
    
    void StrongName::constructor(System::Security::Cryptography::RSA* rsa) {
        if((rsa ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("rsa"));
        }
        this->set_RSA(rsa);
    }
    
    void StrongName::static_constructor() {
    }
    
    void StrongName::InvalidateCache() {
        this->publicKey = nullptr;
        this->keyToken = nullptr;
    }
    
    cli::array<unsigned char>* StrongName::GetBytes() {
        return Cryptography::CryptoConvert::ToCapiPrivateKeyBlob(this->get_RSA());
    }
    
    uint32_t StrongName::RVAtoPosition(uint32_t r, int32_t sections, cli::array<unsigned char>* headers) {
        for(int32_t i = 0; (i < sections); i++){
            uint32_t p = BitConverterLE::ToUInt32(headers, ((i * 40) + 20));
            uint32_t s = BitConverterLE::ToUInt32(headers, ((i * 40) + 12));
            int32_t l = (int32_t)BitConverterLE::ToUInt32(headers, ((i * 40) + 8));
            if(((s <= r) && ((int64_t)(r) < ((int64_t)(s) + (int64_t)(l))))) 
            {
                return ((p + r) - s);
            }
        }
        return 0U;
    }
    
    StrongNameSignature* StrongName::StrongHash(System::IO::Stream* stream, StrongNameOptions options) {
        StrongNameSignature *info = cli::gcnew<StrongNameSignature>();
        System::Security::Cryptography::HashAlgorithm *hash = System::Security::Cryptography::HashAlgorithm::Create2(this->get_TokenAlgorithm());
        System::Security::Cryptography::CryptoStream *cs = cli::gcnew<System::Security::Cryptography::CryptoStream>(System::IO::Stream::Null, hash, System::Security::Cryptography::CryptoStreamMode::Write);
        cli::array<unsigned char> *mz = (new cli::array<unsigned char>(128));
        stream->Read_c0d6dde3943b413e(mz, 0, 128);
        if(((int32_t)(BitConverterLE::ToUInt16(mz, 0)) != 23117)) 
        {
            return nullptr;
        }
        uint32_t peHeader = BitConverterLE::ToUInt32(mz, 60);
        cs->Write_1f8a1dbe71b0eb89(mz, 0, 128);
        if((peHeader != 128U)) 
        {
            cli::array<unsigned char> *mzextra = (new cli::array<unsigned char>((int32_t)(peHeader - 128U)));
            stream->Read_c0d6dde3943b413e(mzextra, 0, mzextra->get_Length());
            cs->Write_1f8a1dbe71b0eb89(mzextra, 0, mzextra->get_Length());
        }
        cli::array<unsigned char> *pe = (new cli::array<unsigned char>(248));
        stream->Read_c0d6dde3943b413e(pe, 0, 248);
        if((BitConverterLE::ToUInt32(pe, 0) != 17744U)) 
        {
            return nullptr;
        }
        if(((int32_t)(BitConverterLE::ToUInt16(pe, 4)) != 332)) 
        {
            return nullptr;
        }
        cli::array<unsigned char> *v = (new cli::array<unsigned char>(8));
        System::Buffer::BlockCopy(v, 0, pe, 88, 4);
        System::Buffer::BlockCopy(v, 0, pe, 152, 8);
        cs->Write_1f8a1dbe71b0eb89(pe, 0, 248);
        uint16_t numSection = BitConverterLE::ToUInt16(pe, 6);
        int32_t sectionLength = ((int32_t)(numSection) * 40);
        cli::array<unsigned char> *sectionHeaders = (new cli::array<unsigned char>(sectionLength));
        stream->Read_c0d6dde3943b413e(sectionHeaders, 0, sectionLength);
        cs->Write_1f8a1dbe71b0eb89(sectionHeaders, 0, sectionLength);
        uint32_t cliHeaderRVA = BitConverterLE::ToUInt32(pe, 232);
        uint32_t cliHeaderPos = RVAtoPosition(cliHeaderRVA, (int32_t)(numSection), sectionHeaders);
        int32_t cliHeaderSiz = (int32_t)BitConverterLE::ToUInt32(pe, 236);
        cli::array<unsigned char> *cli_ = (new cli::array<unsigned char>(cliHeaderSiz));
        stream->set_Position_cfe1def757785ad((int64_t)(cliHeaderPos));
        stream->Read_c0d6dde3943b413e(cli_, 0, cliHeaderSiz);
        uint32_t strongNameSignatureRVA = BitConverterLE::ToUInt32(cli_, 32);
        info->set_SignaturePosition(RVAtoPosition(strongNameSignatureRVA, (int32_t)(numSection), sectionHeaders));
        info->set_SignatureLength(BitConverterLE::ToUInt32(cli_, 36));
        uint32_t metadataRVA = BitConverterLE::ToUInt32(cli_, 8);
        info->set_MetadataPosition(RVAtoPosition(metadataRVA, (int32_t)(numSection), sectionHeaders));
        info->set_MetadataLength(BitConverterLE::ToUInt32(cli_, 12));
        if(((int32_t)(options) ==  0)) 
        {
            cs->Close_59c62ed53ef2a481();
            hash->Initialize_4bdfe3e821ea432();
            cli::array<unsigned char> *metadata = (new cli::array<unsigned char>((int32_t)info->get_MetadataLength()));
            stream->set_Position_cfe1def757785ad((int64_t)(info->get_MetadataPosition()));
            stream->Read_c0d6dde3943b413e(metadata, 0, metadata->get_Length());
            info->set_Hash(hash->ComputeHash(metadata));
            return info;
        }
        for(int32_t i = 0; (i < (int32_t)(numSection)); i++){
            uint32_t start = BitConverterLE::ToUInt32(sectionHeaders, ((i * 40) + 20));
            int32_t length = (int32_t)BitConverterLE::ToUInt32(sectionHeaders, ((i * 40) + 16));
            cli::array<unsigned char> *section = (new cli::array<unsigned char>(length));
            stream->set_Position_cfe1def757785ad((int64_t)(start));
            stream->Read_c0d6dde3943b413e(section, 0, length);
            if(((start <= info->get_SignaturePosition()) && ((int64_t)(info->get_SignaturePosition()) < ((int64_t)(start) + (int64_t)(length))))) 
            {
                int32_t before = (int32_t)(info->get_SignaturePosition() - start);
                if((before > 0)) 
                {
                    cs->Write_1f8a1dbe71b0eb89(section, 0, before);
                }
                info->set_Signature((new cli::array<unsigned char>((int32_t)info->get_SignatureLength())));
                System::Buffer::BlockCopy(section, before, info->get_Signature(), 0, (int32_t)info->get_SignatureLength());
                System::Array::Reverse(info->get_Signature());
                int32_t s = (int32_t)((int64_t)(before) + (int64_t)(info->get_SignatureLength()));
                int32_t after = (int32_t)((length - s));
                if((after > 0)) 
                {
                    cs->Write_1f8a1dbe71b0eb89(section, s, after);
                }
            }
             else 
            {
                cs->Write_1f8a1dbe71b0eb89(section, 0, length);
            }
        }
        cs->Close_59c62ed53ef2a481();
        info->set_Hash(hash->get_Hash_cb65a3f211aa16df());
        return info;
    }
    
    cli::array<unsigned char>* StrongName::Hash2(System::String* fileName) {
        System::IO::FileStream *fs = System::IO::File::OpenRead(fileName);
        StrongNameSignature *sn = StrongHash(fs, StrongNameOptions::Metadata);
        fs->Close_59c62ed53ef2a481();
        return sn->get_Hash();
    }
    
    bool StrongName::Sign2(System::String* fileName) {
        bool result = false;
        StrongNameSignature *sn;
        {
            /* USING - BLOCK */
            auto fs = System::IO::File::OpenRead(fileName);
            cli::using_guard{fs};
            sn = StrongHash(fs, StrongNameOptions::Signature);
            fs->Close_59c62ed53ef2a481();
        }
        if((sn->get_Hash() ==  nullptr)) 
        {
            return false;
        }
        cli::array<unsigned char> *signature = nullptr;
        try {
            System::Security::Cryptography::RSAPKCS1SignatureFormatter *sign = cli::gcnew<System::Security::Cryptography::RSAPKCS1SignatureFormatter>(this->rsa);
            sign->SetHashAlgorithm_9029a89c4cb706ce(this->get_TokenAlgorithm());
            signature = sign->CreateSignature_119f8aceb75b0d2(sn->get_Hash());
            System::Array::Reverse(signature);
        }
        catch(System::Security::Cryptography::CryptographicException*) {
            return false;
        }
        {
            /* USING - BLOCK */
            auto fs = System::IO::File::OpenWrite(fileName);
            cli::using_guard{fs};
            fs->set_Position_cfe1def757785ad((int64_t)(sn->get_SignaturePosition()));
            fs->Write_1f8a1dbe71b0eb89(signature, 0, signature->get_Length());
            fs->Close_59c62ed53ef2a481();
            result = true;
        }
        return result;
    }
    
    bool StrongName::Verify(System::String* fileName) {
        bool result = false;
        {
            /* USING - BLOCK */
            auto fs = System::IO::File::OpenRead(fileName);
            cli::using_guard{fs};
            result = Verify2(fs);
            fs->Close_59c62ed53ef2a481();
        }
        return result;
    }
    
    bool StrongName::Verify2(System::IO::Stream* stream) {
        StrongNameSignature *sn = StrongHash(stream, StrongNameOptions::Signature);
        if((sn->get_Hash() ==  nullptr)) 
        {
            return false;
        }
        try {
            System::Configuration::Assemblies::AssemblyHashAlgorithm algorithm = System::Configuration::Assemblies::AssemblyHashAlgorithm::SHA12;
            if(System::String::op_Equality(this->tokenAlgorithm, _T("MD5"))) 
            {
                algorithm = System::Configuration::Assemblies::AssemblyHashAlgorithm::MD52;
            }
            return Verify3(this->rsa, algorithm, sn->get_Hash(), sn->get_Signature());
        }
        catch(System::Security::Cryptography::CryptographicException*) {
            return false;
        }
    }
    
    bool StrongName::IsAssemblyStrongnamed(System::String* assemblyName) {
        if(!(initialized)) 
        {
            {
                cli::lock_guard{lockObject};
                if(!(initialized)) 
                {
                    System::String *config = System::Environment::GetMachineConfigPath();
                    StrongNameManager::LoadConfig(config);
                    initialized = true;
                }
            }
        }
        try {
            System::Reflection::AssemblyName *an = System::Reflection::AssemblyName::GetAssemblyName(assemblyName);
            if((an ==  nullptr)) 
            {
                return false;
            }
            cli::array<unsigned char> *publicKey = StrongNameManager::GetMappedPublicKey(an->GetPublicKeyToken());
            if(((publicKey ==  nullptr) || (publicKey->get_Length() < 12))) 
            {
                publicKey = an->GetPublicKey();
                if(((publicKey ==  nullptr) || (publicKey->get_Length() < 12))) 
                {
                    return false;
                }
            }
            if(!(StrongNameManager::MustVerify(an))) 
            {
                return true;
            }
            System::Security::Cryptography::RSA *rsa = Cryptography::CryptoConvert::FromCapiPublicKeyBlob2(publicKey, 12);
            StrongName *sn = cli::gcnew<StrongName>(rsa);
            bool result = sn->Verify(assemblyName);
            return result;
        }
        catch(...) {
            return false;
        }
    }
    
    bool StrongName::VerifySignature(cli::array<unsigned char>* publicKey, int32_t algorithm, cli::array<unsigned char>* hash, cli::array<unsigned char>* signature) {
        try {
            System::Security::Cryptography::RSA *rsa = Cryptography::CryptoConvert::FromCapiPublicKeyBlob(publicKey);
            return Verify3(rsa, (System::Configuration::Assemblies::AssemblyHashAlgorithm)(algorithm), hash, signature);
        }
        catch(...) {
            return false;
        }
    }
    
    bool StrongName::Verify3(System::Security::Cryptography::RSA* rsa, System::Configuration::Assemblies::AssemblyHashAlgorithm algorithm, cli::array<unsigned char>* hash, cli::array<unsigned char>* signature) {
        System::Security::Cryptography::RSAPKCS1SignatureDeformatter *vrfy = cli::gcnew<System::Security::Cryptography::RSAPKCS1SignatureDeformatter>(rsa);
        switch(algorithm) {
            case System::Configuration::Assemblies::AssemblyHashAlgorithm::MD52: case_359: {
                vrfy->SetHashAlgorithm_5a7fb9c08aaf7ac9(_T("MD5"));
                break;
            }
            case System::Configuration::Assemblies::AssemblyHashAlgorithm::SHA12: case System::Configuration::Assemblies::AssemblyHashAlgorithm::None: default: case_360: {
                vrfy->SetHashAlgorithm_5a7fb9c08aaf7ac9(_T("SHA1"));
                break;
            }
        }
        return vrfy->VerifySignature_ecf649797288645c(hash, signature);
    }
    
    bool StrongName::get_CanSign() {
        if((this->rsa ==  nullptr)) 
        {
            return false;
        }
        if(cli::is<System::Security::Cryptography::RSACryptoServiceProvider>(this->get_RSA())) 
        {
            return !(cli::as<System::Security::Cryptography::RSACryptoServiceProvider*>(this->rsa)->get_PublicOnly());
        }
         else 
        {
            if(cli::is<Cryptography::RSAManaged>(this->get_RSA())) 
            {
                return !(cli::as<Cryptography::RSAManaged*>(this->rsa)->get_PublicOnly());
            }
             else 
            {
                try {
                    System::Security::Cryptography::RSAParameters p = this->rsa->ExportParameters_f406cf113d936197(true);
                    return (((p->D != nullptr) && (p->P != nullptr)) && (p->Q != nullptr));
                }
                catch(System::Security::Cryptography::CryptographicException*) {
                    return false;
                }
            }
        }
    }
    
    System::Security::Cryptography::RSA* StrongName::get_RSA() {
        if((this->rsa ==  nullptr)) 
        {
            this->rsa = cli::cast<System::Security::Cryptography::RSA*>(System::Security::Cryptography::RSA::Create3());
        }
        return this->rsa;
    }
    
    System::Security::Cryptography::RSA* StrongName::set_RSA(System::Security::Cryptography::RSA* value) {
        this->rsa = value;
        InvalidateCache();
        return get_RSA();
    }
    
    cli::array<unsigned char>* StrongName::get_PublicKey() {
        if((this->publicKey ==  nullptr)) 
        {
            cli::array<unsigned char> *keyPair = Cryptography::CryptoConvert::ToCapiKeyBlob2(this->rsa, false);
            this->publicKey = (new cli::array<unsigned char>((32 + (this->rsa->get_KeySize_6bd474632c551ac() >> 3))));
            this->publicKey->at(0) = keyPair->at(4);
            this->publicKey->at(1) = keyPair->at(5);
            this->publicKey->at(2) = keyPair->at(6);
            this->publicKey->at(3) = keyPair->at(7);
            this->publicKey->at(4) = 4;
            this->publicKey->at(5) = 128;
            this->publicKey->at(6) = 0;
            this->publicKey->at(7) = 0;
            cli::array<unsigned char> *lastPart = BitConverterLE::GetBytes4((this->publicKey->get_Length() - 12));
            this->publicKey->at(8) = lastPart->at(0);
            this->publicKey->at(9) = lastPart->at(1);
            this->publicKey->at(10) = lastPart->at(2);
            this->publicKey->at(11) = lastPart->at(3);
            this->publicKey->at(12) = 6;
            System::Buffer::BlockCopy(keyPair, 1, this->publicKey, 13, (this->publicKey->get_Length() - 13));
            this->publicKey->at(23) = 49;
        }
        return cli::cast<cli::array<unsigned char>*>(cli::import(this->publicKey)->Clone());
    }
    
    cli::array<unsigned char>* StrongName::get_PublicKeyToken() {
        if((this->keyToken ==  nullptr)) 
        {
            cli::array<unsigned char> *publicKey = this->get_PublicKey();
            if((publicKey ==  nullptr)) 
            {
                return nullptr;
            }
            System::Security::Cryptography::HashAlgorithm *ha = System::Security::Cryptography::HashAlgorithm::Create2(this->get_TokenAlgorithm());
            cli::array<unsigned char> *hash = ha->ComputeHash(publicKey);
            this->keyToken = (new cli::array<unsigned char>(8));
            System::Buffer::BlockCopy(hash, (hash->get_Length() - 8), this->keyToken, 0, 8);
            System::Array::Reverse2(this->keyToken, 0, 8);
        }
        return cli::cast<cli::array<unsigned char>*>(cli::import(this->keyToken)->Clone());
    }
    
    System::String* StrongName::get_TokenAlgorithm() {
        if((this->tokenAlgorithm ==  nullptr)) 
        {
            this->tokenAlgorithm = _T("SHA1");
        }
        return this->tokenAlgorithm;
    }
    
    System::String* StrongName::set_TokenAlgorithm(System::String* value) {
        System::String *algo = value->ToUpper2(System::Globalization::CultureInfo::get_InvariantCulture());
        if((System::String::op_Equality(algo, _T("SHA1")) || System::String::op_Equality(algo, _T("MD5")))) 
        {
            this->tokenAlgorithm = value;
            InvalidateCache();
        }
         else 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Unsupported hash algorithm for token"));
        }
        return get_TokenAlgorithm();
    }
    
}}
namespace Mono { namespace Security {
    
    
    void Element::constructor() {
        this->assemblies = cli::gcnew<System::Collections::Hashtable>();
    }
    
    void Element::constructor(System::String* assembly, System::String* users) {
        this->assemblies->Add_3f7ab157bcb41156(assembly, users);
    }
    
    System::String* Element::GetUsers(System::String* assembly) {
        return cli::cast<System::String*>(this->assemblies->get_Item_d75c6e706b965758(assembly));
    }
    
}}
namespace Mono { namespace Security {
    
    System::Collections::Hashtable*  StrongNameManager::mappings;
    System::Collections::Hashtable*  StrongNameManager::tokens;
    
    StrongNameManager::StrongNameManager()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void StrongNameManager::static_constructor() {
    }
    
    void StrongNameManager::constructor() {
    }
    
    void StrongNameManager::LoadConfig(System::String* filename) {
        if(System::IO::File::Exists(filename)) 
        {
            Mono::Xml::SecurityParser *sp = cli::gcnew<Mono::Xml::SecurityParser>();
            {
                /* USING - BLOCK */
                auto sr = cli::gcnew<System::IO::StreamReader>(filename);
                cli::using_guard{sr};
                System::String *xml = sr->ReadToEnd_f683943dd5002e1e();
                sp->LoadXml(xml);
            }
            System::Security::SecurityElement *root = sp->ToXml();
            if(((root != nullptr) && System::String::op_Equality(root->get_Tag(), _T("configuration")))) 
            {
                System::Security::SecurityElement *strongnames = root->SearchForChildByTag(_T("strongNames"));
                if(((strongnames != nullptr) && (strongnames->get_Children()->get_Count_2354963792616712() > 0))) 
                {
                    System::Security::SecurityElement *mapping = strongnames->SearchForChildByTag(_T("pubTokenMapping"));
                    if(((mapping != nullptr) && (mapping->get_Children()->get_Count_2354963792616712() > 0))) 
                    {
                        LoadMapping(mapping);
                    }
                    System::Security::SecurityElement *settings = strongnames->SearchForChildByTag(_T("verificationSettings"));
                    if(((settings != nullptr) && (settings->get_Children()->get_Count_2354963792616712() > 0))) 
                    {
                        LoadVerificationSettings(settings);
                    }
                }
            }
        }
    }
    
    void StrongNameManager::LoadMapping(System::Security::SecurityElement* mapping) {
        if((mappings ==  nullptr)) 
        {
            mappings = cli::gcnew<System::Collections::Hashtable>();
        }
        {
            cli::lock_guard{mappings->get_SyncRoot_2d1e4aa44bab8a0d()};
            for(auto tmp_62 : mapping->get_Children()) {
                auto item = cli::cast<System::Security::SecurityElement*>(tmp_62);
                {
                    if(System::String::op_Inequality(item->get_Tag(), _T("map"))) 
                    {
                        continue;
                    }
                    System::String *token = item->Attribute2(_T("Token"));
                    if(((token ==  nullptr) || (token->get_Length() != 16))) 
                    {
                        continue;
                    }
                    token = token->ToUpper2(System::Globalization::CultureInfo::get_InvariantCulture());
                    System::String *publicKey = item->Attribute2(_T("PublicKey"));
                    if((publicKey ==  nullptr)) 
                    {
                        continue;
                    }
                    if((mappings->get_Item_d75c6e706b965758(token) ==  nullptr)) 
                    {
                        mappings->Add_3f7ab157bcb41156(token, publicKey);
                    }
                     else 
                    {
                        mappings->set_Item_84c7e24d9caa09(token, publicKey);
                    }
                }
            }
        }
    }
    
    void StrongNameManager::LoadVerificationSettings(System::Security::SecurityElement* settings) {
        if((tokens ==  nullptr)) 
        {
            tokens = cli::gcnew<System::Collections::Hashtable>();
        }
        {
            cli::lock_guard{tokens->get_SyncRoot_2d1e4aa44bab8a0d()};
            for(auto tmp_63 : settings->get_Children()) {
                auto item = cli::cast<System::Security::SecurityElement*>(tmp_63);
                {
                    if(System::String::op_Inequality(item->get_Tag(), _T("skip"))) 
                    {
                        continue;
                    }
                    System::String *token = item->Attribute2(_T("Token"));
                    if((token ==  nullptr)) 
                    {
                        continue;
                    }
                    token = token->ToUpper2(System::Globalization::CultureInfo::get_InvariantCulture());
                    System::String *assembly = item->Attribute2(_T("Assembly"));
                    if((assembly ==  nullptr)) 
                    {
                        assembly = _T("*");
                    }
                    System::String *users = item->Attribute2(_T("Users"));
                    if((users ==  nullptr)) 
                    {
                        users = _T("*");
                    }
                    Element *el = cli::cast<Element*>(tokens->get_Item_d75c6e706b965758(token));
                    if((el ==  nullptr)) 
                    {
                        el = cli::gcnew<Element>(assembly, users);
                        tokens->Add_3f7ab157bcb41156(token, el);
                        continue;
                    }
                    System::String *a = cli::cast<System::String*>(el->assemblies->get_Item_d75c6e706b965758(assembly));
                    if((a ==  nullptr)) 
                    {
                        el->assemblies->Add_3f7ab157bcb41156(assembly, users);
                        continue;
                    }
                    if(System::String::op_Equality(users, _T("*"))) 
                    {
                        el->assemblies->set_Item_84c7e24d9caa09(assembly, _T("*"));
                        continue;
                    }
                    System::String *existing = cli::cast<System::String*>(el->assemblies->get_Item_d75c6e706b965758(assembly));
                    System::String *newusers = System::String::Concat6(existing, _T(","), users);
                    el->assemblies->set_Item_84c7e24d9caa09(assembly, newusers);
                }
            }
        }
    }
    
    cli::array<unsigned char>* StrongNameManager::GetMappedPublicKey(cli::array<unsigned char>* token) {
        if(((mappings ==  nullptr) || (token ==  nullptr))) 
        {
            return nullptr;
        }
        System::String *t = Cryptography::CryptoConvert::ToHex(token);
        System::String *pk = cli::cast<System::String*>(mappings->get_Item_d75c6e706b965758(t));
        if((pk ==  nullptr)) 
        {
            return nullptr;
        }
        return Cryptography::CryptoConvert::FromHex(pk);
    }
    
    bool StrongNameManager::MustVerify(System::Reflection::AssemblyName* an) {
        if(((an ==  nullptr) || (tokens ==  nullptr))) 
        {
            return true;
        }
        System::String *token = Cryptography::CryptoConvert::ToHex(an->GetPublicKeyToken());
        Element *el = cli::cast<Element*>(tokens->get_Item_d75c6e706b965758(token));
        if((el != nullptr)) 
        {
            System::String *users = el->GetUsers(an->get_Name());
            if((users ==  nullptr)) 
            {
                users = el->GetUsers(_T("*"));
            }
            if((users != nullptr)) 
            {
                if(System::String::op_Equality(users, _T("*"))) 
                {
                    return false;
                }
                return (users->IndexOf7(System::Environment::get_UserName()) < 0);
            }
        }
        return true;
    }
    
    System::String* StrongNameManager::ToString_1636a0751cb9ac11() {
        System::Text::StringBuilder *sb = cli::gcnew<System::Text::StringBuilder>();
        sb->Append2(_T("Public Key Token\tAssemblies\t\tUsers"));
        sb->Append2(System::Environment::get_NewLine());
        for(auto tmp_64 : tokens) {
            auto token = cli::cast<System::Collections::DictionaryEntry>(tmp_64);
            {
                sb->Append2(cli::cast<System::String*>(token->get_Key()));
                Element *t = cli::cast<Element*>(token->get_Value());
                bool first = true;
                for(auto tmp_65 : t->assemblies) {
                    auto assembly = cli::cast<System::Collections::DictionaryEntry>(tmp_65);
                    {
                        if(first) 
                        {
                            sb->Append2(_T("\t"));
                            first = false;
                        }
                         else 
                        {
                            sb->Append2(_T("\t\t\t"));
                        }
                        sb->Append2(cli::cast<System::String*>(assembly->get_Key()));
                        sb->Append2(_T("\t"));
                        System::String *users = cli::cast<System::String*>(assembly->get_Value());
                        if(System::String::op_Equality(users, _T("*"))) 
                        {
                            users = _T("All users");
                        }
                        sb->Append2(users);
                        sb->Append2(System::Environment::get_NewLine());
                    }
                }
            }
        }
        return sb->ToString_1636a0751cb9ac11();
    }
    
}}
namespace Mono { namespace Security {
    
    System::String*  Uri::hexUpperChars;
    System::String*  Uri::SchemeDelimiter;
    System::String*  Uri::UriSchemeFile;
    System::String*  Uri::UriSchemeFtp;
    System::String*  Uri::UriSchemeGopher;
    System::String*  Uri::UriSchemeHttp;
    System::String*  Uri::UriSchemeHttps;
    System::String*  Uri::UriSchemeMailto;
    System::String*  Uri::UriSchemeNews;
    System::String*  Uri::UriSchemeNntp;
    cli::array<UriScheme>*  Uri::schemes;
    System::Collections::Generic::Dictionary<System::String*, int32_t>*  Uri::__f__switch_map3;
    
    Uri::Uri()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void Uri::constructor(System::String* uriString) {
    }
    
    void Uri::constructor(System::String* uriString, bool dontEscape) {
        this->userEscaped = dontEscape;
        this->source = uriString;
        Parse();
    }
    
    void Uri::constructor(System::String* uriString, bool dontEscape, bool reduce) {
        this->userEscaped = dontEscape;
        this->source = uriString;
        this->reduce = reduce;
        Parse();
    }
    
    void Uri::constructor(Uri* baseUri, System::String* relativeUri) {
    }
    
    void Uri::constructor(Uri* baseUri, System::String* relativeUri, bool dontEscape) {
        if((baseUri ==  nullptr)) 
        {
            throw cli::gcnew<System::NullReferenceException>(_T("baseUri"));
        }
        this->userEscaped = dontEscape;
        if((relativeUri ==  nullptr)) 
        {
            throw cli::gcnew<System::NullReferenceException>(_T("relativeUri"));
        }
        if(relativeUri->StartsWith(_T("\\\\"))) 
        {
            this->source = relativeUri;
            Parse();
            return;
        }
        int32_t pos = relativeUri->IndexOf4(u':');
        if((pos != -1)) 
        {
            int32_t pos2 = relativeUri->IndexOfAny((new cli::array<char16_t>({u'/', u'\\', u'?'})));
            if(((pos2 > pos) || (pos2 < 0))) 
            {
                this->source = relativeUri;
                Parse();
                return;
            }
        }
        this->scheme = baseUri->scheme;
        this->host = baseUri->host;
        this->port = baseUri->port;
        this->userinfo = baseUri->userinfo;
        this->isUnc = baseUri->isUnc;
        this->isUnixFilePath = baseUri->isUnixFilePath;
        this->isOpaquePart = baseUri->isOpaquePart;
        if(System::String::op_Equality(relativeUri, System::String::Empty)) 
        {
            this->path = baseUri->path;
            this->query = baseUri->query;
            this->fragment = baseUri->fragment;
            return;
        }
        pos = relativeUri->IndexOf4(u'#');
        if((pos != -1)) 
        {
            this->fragment = relativeUri->Substring(pos);
            relativeUri = relativeUri->Substring2(0, pos);
        }
        pos = relativeUri->IndexOf4(u'?');
        if((pos != -1)) 
        {
            this->query = relativeUri->Substring(pos);
            if(!(this->userEscaped)) 
            {
                this->query = EscapeString(this->query);
            }
            relativeUri = relativeUri->Substring2(0, pos);
        }
        if(((relativeUri->get_Length() > 0) && ((int32_t)(relativeUri->get_Chars(0)) ==  47))) 
        {
            if(((relativeUri->get_Length() > 1) && ((int32_t)(relativeUri->get_Chars(1)) ==  47))) 
            {
                this->source = cli::concat(this->scheme, cli::box(u':'));
                Parse();
                return;
            }
             else 
            {
                this->path = relativeUri;
                if(!(this->userEscaped)) 
                {
                    this->path = EscapeString(this->path);
                }
                return;
            }
        }
        this->path = baseUri->path;
        if(((relativeUri->get_Length() > 0) || (this->query->get_Length() > 0))) 
        {
            pos = this->path->LastIndexOf4(u'/');
            if((pos >= 0)) 
            {
                this->path = this->path->Substring2(0, (pos + 1));
            }
        }
        if((relativeUri->get_Length() ==  0)) 
        {
            return;
        }
        (this->path = cli::concat(this->path, relativeUri));
        int32_t startIndex = 0;
        while(true) {
            pos = this->path->IndexOf8(_T("./"), startIndex);
            if((pos ==  -1)) 
            {
                break;
            }
            if((pos ==  0)) 
            {
                this->path = this->path->Remove2(0, 2);
            }
             else 
            {
                if(((int32_t)(this->path->get_Chars((pos - 1))) != 46)) 
                {
                    this->path = this->path->Remove2(pos, 2);
                }
                 else 
                {
                    startIndex = (pos + 1);
                }
            }
        }
        if((((this->path->get_Length() > 1) && ((int32_t)(this->path->get_Chars((this->path->get_Length() - 1))) ==  46)) && ((int32_t)(this->path->get_Chars((this->path->get_Length() - 2))) ==  47))) 
        {
            this->path = this->path->Remove2((this->path->get_Length() - 1), 1);
        }
        startIndex = 0;
        while(true) {
            pos = this->path->IndexOf8(_T("/../"), startIndex);
            if((pos ==  -1)) 
            {
                break;
            }
            if((pos ==  0)) 
            {
                startIndex = 3;
                continue;
            }
            int32_t pos2 = this->path->LastIndexOf5(u'/', (pos - 1));
            if((pos2 ==  -1)) 
            {
                startIndex = (pos + 1);
            }
             else 
            {
                if(System::String::op_Inequality(this->path->Substring2((pos2 + 1), ((pos - pos2) - 1)), _T(".."))) 
                {
                    this->path = this->path->Remove2((pos2 + 1), ((pos - pos2) + 3));
                }
                 else 
                {
                    startIndex = (pos + 1);
                }
            }
        }
        if(((this->path->get_Length() > 3) && this->path->EndsWith(_T("/..")))) 
        {
            pos = this->path->LastIndexOf5(u'/', (this->path->get_Length() - 4));
            if((pos != -1)) 
            {
                if(System::String::op_Inequality(this->path->Substring2((pos + 1), ((this->path->get_Length() - pos) - 4)), _T(".."))) 
                {
                    this->path = this->path->Remove2((pos + 1), ((this->path->get_Length() - pos) - 1));
                }
            }
        }
        if(!(this->userEscaped)) 
        {
            this->path = EscapeString(this->path);
        }
    }
    
    void Uri::static_constructor() {
    }
    
    bool Uri::IsIPv4Address(System::String* name) {
        cli::array<System::String*> *captures = name->Split((new cli::array<char16_t>({u'.'})));
        if((captures->get_Length() != 4)) 
        {
            return false;
        }
        for(int32_t i = 0; (i < 4); i++){
            try {
                int32_t d = System::Int32::Parse2(captures->at(i), System::Globalization::CultureInfo::get_InvariantCulture());
                if(((d < 0) || (d > 255))) 
                {
                    return false;
                }
            }
            catch(System::Exception*) {
                return false;
            }
        }
        return true;
    }
    
    bool Uri::IsDomainAddress(System::String* name) {
        int32_t len = name->get_Length();
        if(((int32_t)(name->get_Chars((len - 1))) ==  46)) 
        {
            return false;
        }
        int32_t count = 0;
        for(int32_t i = 0; (i < len); i++){
            char16_t c = name->get_Chars(i);
            if((count ==  0)) 
            {
                if(!(System::Char::IsLetterOrDigit(c))) 
                {
                    return false;
                }
            }
             else 
            {
                if(((int32_t)(c) ==  46)) 
                {
                    count = 0;
                }
                 else 
                {
                    if(((!(System::Char::IsLetterOrDigit(c)) && ((int32_t)(c) != 45)) && ((int32_t)(c) != 95))) 
                    {
                        return false;
                    }
                }
            }
            if((++count ==  64)) 
            {
                return false;
            }
        }
        return true;
    }
    
    bool Uri::CheckSchemeName(System::String* schemeName) {
        if(((schemeName ==  nullptr) || (schemeName->get_Length() ==  0))) 
        {
            return false;
        }
        if(!(System::Char::IsLetter(schemeName->get_Chars(0)))) 
        {
            return false;
        }
        int32_t len = schemeName->get_Length();
        for(int32_t i = 1; (i < len); i++){
            char16_t c = schemeName->get_Chars(i);
            if((((!(System::Char::IsLetterOrDigit(c)) && ((int32_t)(c) != 46)) && ((int32_t)(c) != 43)) && ((int32_t)(c) != 45))) 
            {
                return false;
            }
        }
        return true;
    }
    
    bool Uri::Equals_ed975d2f4a7d193e(System::Object* comparant) {
        if((comparant ==  nullptr)) 
        {
            return false;
        }
        Uri *uri = cli::as<Uri*>(comparant);
        if((uri ==  nullptr)) 
        {
            System::String *s = cli::as<System::String*>(comparant);
            if((s ==  nullptr)) 
            {
                return false;
            }
            uri = cli::gcnew<Uri>(s);
        }
        System::Globalization::CultureInfo *inv = System::Globalization::CultureInfo::get_InvariantCulture();
        return (((((System::String::op_Equality(this->scheme->ToLower2(inv), uri->scheme->ToLower2(inv)) && System::String::op_Equality(this->userinfo->ToLower2(inv), uri->userinfo->ToLower2(inv))) && System::String::op_Equality(this->host->ToLower2(inv), uri->host->ToLower2(inv))) && (this->port ==  uri->port)) && System::String::op_Equality(this->path, uri->path)) && System::String::op_Equality(this->query->ToLower2(inv), uri->query->ToLower2(inv)));
    }
    
    int32_t Uri::GetHashCode_6648aef0f235ee6c() {
        if((this->cachedHashCode ==  0)) 
        {
            this->cachedHashCode = (((((this->scheme->GetHashCode_6648aef0f235ee6c() + this->userinfo->GetHashCode_6648aef0f235ee6c()) + this->host->GetHashCode_6648aef0f235ee6c()) + this->port) + this->path->GetHashCode_6648aef0f235ee6c()) + this->query->GetHashCode_6648aef0f235ee6c());
        }
        return this->cachedHashCode;
    }
    
    System::String* Uri::GetLeftPart(UriPartial part) {
        int32_t defaultPort;
        switch(part) {
            case UriPartial::Scheme: case_361: {
                return cli::concat(this->scheme, GetOpaqueWiseSchemeDelimiter());
            }
            case UriPartial::Authority2: case_362: {
                if(((System::String::op_Equality(this->host, System::String::Empty) || System::String::op_Equality(this->scheme, UriSchemeMailto)) || System::String::op_Equality(this->scheme, UriSchemeNews))) 
                {
                    return System::String::Empty;
                }
                System::Text::StringBuilder *s = cli::gcnew<System::Text::StringBuilder>();
                s->Append2(this->scheme);
                s->Append2(GetOpaqueWiseSchemeDelimiter());
                if((((this->path->get_Length() > 1) && ((int32_t)(this->path->get_Chars(1)) ==  58)) && System::String::op_Equality(UriSchemeFile, this->scheme))) 
                {
                    s->Append16(u'/');
                }
                if((this->userinfo->get_Length() > 0)) 
                {
                    s->Append2(this->userinfo)->Append16(u'@');
                }
                s->Append2(this->host);
                defaultPort = GetDefaultPort(this->scheme);
                if(((this->port != -1) && (this->port != defaultPort))) 
                {
                    s->Append16(u':')->Append8(this->port);
                }
                return s->ToString_1636a0751cb9ac11();
            }
            case UriPartial::Path2: case_363: {
                System::Text::StringBuilder *sb = cli::gcnew<System::Text::StringBuilder>();
                sb->Append2(this->scheme);
                sb->Append2(GetOpaqueWiseSchemeDelimiter());
                if((((this->path->get_Length() > 1) && ((int32_t)(this->path->get_Chars(1)) ==  58)) && System::String::op_Equality(UriSchemeFile, this->scheme))) 
                {
                    sb->Append16(u'/');
                }
                if((this->userinfo->get_Length() > 0)) 
                {
                    sb->Append2(this->userinfo)->Append16(u'@');
                }
                sb->Append2(this->host);
                defaultPort = GetDefaultPort(this->scheme);
                if(((this->port != -1) && (this->port != defaultPort))) 
                {
                    sb->Append16(u':')->Append8(this->port);
                }
                sb->Append2(this->path);
                return sb->ToString_1636a0751cb9ac11();
            }
        }
        return nullptr;
    }
    
    int32_t Uri::FromHex(char16_t digit) {
        if(((48 <= (int32_t)(digit)) && ((int32_t)(digit) <= 57))) 
        {
            return (int32_t)(((int32_t)(digit) - 48));
        }
        if(((97 <= (int32_t)(digit)) && ((int32_t)(digit) <= 102))) 
        {
            return (int32_t)((((int32_t)(digit) - 97) + 10));
        }
        if(((65 <= (int32_t)(digit)) && ((int32_t)(digit) <= 70))) 
        {
            return (int32_t)((((int32_t)(digit) - 65) + 10));
        }
        throw cli::gcnew<System::ArgumentException>(_T("digit"));
    }
    
    System::String* Uri::HexEscape(char16_t character) {
        if(((int32_t)(character) > 255)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("character"));
        }
        return cli::concat(_T("%"), cli::box(hexUpperChars->get_Chars((((int32_t)(character) & 240) >> 4))));
    }
    
    char16_t Uri::HexUnescape(System::String* pattern, int32_t index) {
        if((pattern ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("pattern"));
        }
        if(((index < 0) || (index >= pattern->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("index"));
        }
        int32_t stage = 0;
        int32_t c = 0;
        do {
            if((((((index + 3) > pattern->get_Length()) || ((int32_t)(pattern->get_Chars(index)) != 37)) || !(IsHexDigit(pattern->get_Chars((index + 1))))) || !(IsHexDigit(pattern->get_Chars((index + 2)))))) 
            {
                if((stage ==  0)) 
                {
                    return pattern->get_Chars(index++);
                }
                break;
            }
            index++;
            int32_t msb = FromHex(pattern->get_Chars(index++));
            int32_t lsb = FromHex(pattern->get_Chars(index++));
            int32_t b = ((msb << 4) + lsb);
            if((stage ==  0)) 
            {
                if((b < 192)) 
                {
                    return (char16_t)b;
                }
                 else 
                {
                    if((b < 224)) 
                    {
                        c = (b - 192);
                        stage = 2;
                    }
                     else 
                    {
                        if((b < 240)) 
                        {
                            c = (b - 224);
                            stage = 3;
                        }
                         else 
                        {
                            if((b < 248)) 
                            {
                                c = (b - 240);
                                stage = 4;
                            }
                             else 
                            {
                                if((b < 251)) 
                                {
                                    c = (b - 248);
                                    stage = 5;
                                }
                                 else 
                                {
                                    if((b < 254)) 
                                    {
                                        c = (b - 252);
                                        stage = 6;
                                    }
                                }
                            }
                        }
                    }
                }
                (c = c << (((stage - 1) * 6) & 31));
            }
             else 
            {
                (c = c + ((b - 128) << (((stage - 1) * 6) & 31)));
            }
            stage--;
        }
        while((stage > 0));
        return (char16_t)c;
    }
    
    bool Uri::IsHexDigit(char16_t digit) {
        return ((((48 <= (int32_t)(digit)) && ((int32_t)(digit) <= 57)) || ((97 <= (int32_t)(digit)) && ((int32_t)(digit) <= 102))) || ((65 <= (int32_t)(digit)) && ((int32_t)(digit) <= 70)));
    }
    
    bool Uri::IsHexEncoding(System::String* pattern, int32_t index) {
        if(((index + 3) > pattern->get_Length())) 
        {
            return false;
        }
        return ((((int32_t)(pattern->get_Chars(index++)) ==  37) && IsHexDigit(pattern->get_Chars(index++))) && IsHexDigit(pattern->get_Chars(index)));
    }
    
    System::String* Uri::MakeRelative(Uri* toUri) {
        if((System::String::op_Inequality(this->get_Scheme(), toUri->get_Scheme()) || System::String::op_Inequality(this->get_Authority(), toUri->get_Authority()))) 
        {
            return toUri->ToString_1636a0751cb9ac11();
        }
        if(System::String::op_Equality(this->path, toUri->path)) 
        {
            return System::String::Empty;
        }
        cli::array<System::String*> *segments = this->get_Segments();
        cli::array<System::String*> *segments2 = toUri->get_Segments();
        int32_t k = 0;
        int32_t max = System::Math::Min5(segments->get_Length(), segments2->get_Length());
        for(; (k < max); k++) {
            if(System::String::op_Inequality(segments->at(k), segments2->at(k))) 
            {
                break;
            }
        }
        System::String *result = System::String::Empty;
        for(int32_t i = (k + 1); (i < segments->get_Length()); i++) {
            (result = cli::concat(result, _T("../")));
        }
        for(int32_t i = k; (i < segments2->get_Length()); i++) {
            (result = cli::concat(result, segments2->at(i)));
        }
        return result;
    }
    
    System::String* Uri::ToString_1636a0751cb9ac11() {
        if((this->cachedToString != nullptr)) 
        {
            return this->cachedToString;
        }
        System::String *q = this->query->StartsWith(_T("?")) ? cli::concat(cli::box(u'?'), Unescape(this->query->Substring(1))) : Unescape(this->query);
        this->cachedToString = cli::concat(Unescape2(GetLeftPart(UriPartial::Path2), true), q);
        return this->cachedToString;
    }
    
    void Uri::Escape2() {
        this->path = EscapeString(this->path);
    }
    
    System::String* Uri::EscapeString(System::String* str) {
        return EscapeString2(str, false, true, true);
    }
    
    System::String* Uri::EscapeString2(System::String* str, bool escapeReserved, bool escapeHex, bool escapeBrackets) {
        if((str ==  nullptr)) 
        {
            return System::String::Empty;
        }
        System::Text::StringBuilder *s = cli::gcnew<System::Text::StringBuilder>();
        int32_t len = str->get_Length();
        for(int32_t i = 0; (i < len); i++){
            if(IsHexEncoding(str, i)) 
            {
                s->Append2(str->Substring2(i, 3));
                (i = i + 2);
                continue;
            }
            cli::array<unsigned char> *data = System::Text::Encoding::get_UTF8()->GetBytes_c786a154203d1d3e((new cli::array<char16_t>({str->get_Chars(i)})));
            int32_t length = data->get_Length();
            for(int32_t j = 0; (j < length); j++){
                char16_t c = (char16_t)data->at(j);
                if((((((((int32_t)(c) <= 32) || ((int32_t)(c) >= 127)) || (_T("<>%\"{}|\\^`")->IndexOf4(c) != -1)) || (escapeHex && ((int32_t)(c) ==  35))) || (escapeBrackets && (((int32_t)(c) ==  91) || ((int32_t)(c) ==  93)))) || (escapeReserved && (_T(";/?:@&=+$,")->IndexOf4(c) != -1)))) 
                {
                    s->Append2(HexEscape(c));
                    continue;
                }
                s->Append16(c);
            }
        }
        return s->ToString_1636a0751cb9ac11();
    }
    
    void Uri::Parse() {
        Parse2(this->source);
        if(this->userEscaped) 
        {
            return;
        }
        this->host = EscapeString2(this->host, false, true, false);
        this->path = EscapeString(this->path);
    }
    
    System::String* Uri::Unescape(System::String* str) {
        return Unescape2(str, false);
    }
    
    System::String* Uri::Unescape2(System::String* str, bool excludeSharp) {
        if((str ==  nullptr)) 
        {
            return System::String::Empty;
        }
        System::Text::StringBuilder *s = cli::gcnew<System::Text::StringBuilder>();
        int32_t len = str->get_Length();
        for(int32_t i = 0; (i < len); i++){
            char16_t c = str->get_Chars(i);
            if(((int32_t)(c) ==  37)) 
            {
                char16_t x = HexUnescape(str, i);
                if((excludeSharp && ((int32_t)(x) ==  35))) 
                {
                    s->Append2(_T("%23"));
                }
                 else 
                {
                    s->Append16(x);
                }
                i--;
            }
             else 
            {
                s->Append16(c);
            }
        }
        return s->ToString_1636a0751cb9ac11();
    }
    
    void Uri::ParseAsWindowsUNC(System::String* uriString) {
        this->scheme = UriSchemeFile;
        this->port = -1;
        this->fragment = System::String::Empty;
        this->query = System::String::Empty;
        this->isUnc = true;
        uriString = uriString->TrimStart((new cli::array<char16_t>({u'\\'})));
        int32_t pos = uriString->IndexOf4(u'\\');
        if((pos > 0)) 
        {
            this->path = uriString->Substring(pos);
            this->host = uriString->Substring2(0, pos);
        }
         else 
        {
            this->host = uriString;
            this->path = System::String::Empty;
        }
        this->path = this->path->Replace2(_T("\\"), _T("/"));
    }
    
    void Uri::ParseAsWindowsAbsoluteFilePath(System::String* uriString) {
        if((((uriString->get_Length() > 2) && ((int32_t)(uriString->get_Chars(2)) != 92)) && ((int32_t)(uriString->get_Chars(2)) != 47))) 
        {
            throw cli::gcnew<System::FormatException>(_T("Relative file path is not allowed."));
        }
        this->scheme = UriSchemeFile;
        this->host = System::String::Empty;
        this->port = -1;
        this->path = uriString->Replace2(_T("\\"), _T("/"));
        this->fragment = System::String::Empty;
        this->query = System::String::Empty;
    }
    
    void Uri::ParseAsUnixAbsoluteFilePath(System::String* uriString) {
        this->isUnixFilePath = true;
        this->scheme = UriSchemeFile;
        this->port = -1;
        this->fragment = System::String::Empty;
        this->query = System::String::Empty;
        this->host = System::String::Empty;
        this->path = nullptr;
        if(uriString->StartsWith(_T("//"))) 
        {
            uriString = uriString->TrimStart((new cli::array<char16_t>({u'/'})));
            this->path = cli::concat(cli::box(u'/'), uriString);
        }
        if((this->path ==  nullptr)) 
        {
            this->path = uriString;
        }
    }
    
    void Uri::Parse2(System::String* uriString) {
        if((uriString ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("uriString"));
        }
        int32_t len = uriString->get_Length();
        if((len <= 1)) 
        {
            throw cli::gcnew<System::FormatException>();
        }
        int32_t pos = 0;
        pos = uriString->IndexOf4(u':');
        if((pos < 0)) 
        {
            if(((int32_t)(uriString->get_Chars(0)) ==  47)) 
            {
                ParseAsUnixAbsoluteFilePath(uriString);
            }
             else 
            {
                if(uriString->StartsWith(_T("\\\\"))) 
                {
                    ParseAsWindowsUNC(uriString);
                }
                 else 
                {
                    throw cli::gcnew<System::FormatException>(_T("URI scheme was not recognized, nor input string is not recognized as an absolute file path."));
                }
            }
            return;
        }
         else 
        {
            if((pos ==  1)) 
            {
                if(!(System::Char::IsLetter(uriString->get_Chars(0)))) 
                {
                    throw cli::gcnew<System::FormatException>(_T("URI scheme must start with alphabet character."));
                }
                ParseAsWindowsAbsoluteFilePath(uriString);
                return;
            }
        }
        this->scheme = uriString->Substring2(0, pos)->ToLower2(System::Globalization::CultureInfo::get_InvariantCulture());
        if(!(System::Char::IsLetter(this->scheme->get_Chars(0)))) 
        {
            throw cli::gcnew<System::FormatException>(_T("URI scheme must start with alphabet character."));
        }
        for(int32_t i = 1; (i < this->scheme->get_Length()); i++){
            if(!(System::Char::IsLetterOrDigit2(this->scheme, i))) 
            {
                switch(this->scheme->get_Chars(i)) {
                    case u'+': case u'-': case u'.': case_364: {
                        break;
                    }
                    default: case_365: {
                        throw cli::gcnew<System::FormatException>(_T("URI scheme must consist of one of alphabet, digits, \'+\', \'-\' or \'.\' character."));
                    }
                }
            }
        }
        uriString = uriString->Substring((pos + 1));
        pos = uriString->IndexOf4(u'#');
        if((!(this->get_IsUnc()) && (pos != -1))) 
        {
            this->fragment = uriString->Substring(pos);
            uriString = uriString->Substring2(0, pos);
        }
        pos = uriString->IndexOf4(u'?');
        if((pos != -1)) 
        {
            this->query = uriString->Substring(pos);
            uriString = uriString->Substring2(0, pos);
            if(!(this->userEscaped)) 
            {
                this->query = EscapeString(this->query);
            }
        }
        bool unixAbsPath = (System::String::op_Equality(this->scheme, UriSchemeFile) && uriString->StartsWith(_T("///")));
        if(uriString->StartsWith(_T("//"))) 
        {
            if(uriString->StartsWith(_T("////"))) 
            {
                unixAbsPath = false;
            }
            uriString = uriString->TrimStart((new cli::array<char16_t>({u'/'})));
            if(((uriString->get_Length() > 1) && ((int32_t)(uriString->get_Chars(1)) ==  58))) 
            {
                unixAbsPath = false;
            }
        }
         else 
        {
            if(!(IsPredefinedScheme(this->scheme))) 
            {
                this->path = uriString;
                this->isOpaquePart = true;
                return;
            }
        }
        pos = uriString->IndexOfAny((new cli::array<char16_t>({u'/'})));
        if(unixAbsPath) 
        {
            pos = -1;
        }
        if((pos ==  -1)) 
        {
            if(((System::String::op_Inequality(this->scheme, UriSchemeMailto) && System::String::op_Inequality(this->scheme, UriSchemeNews)) && System::String::op_Inequality(this->scheme, UriSchemeFile))) 
            {
                this->path = _T("/");
            }
        }
         else 
        {
            this->path = uriString->Substring(pos);
            uriString = uriString->Substring2(0, pos);
        }
        pos = uriString->IndexOf7(_T("@"));
        if((pos != -1)) 
        {
            this->userinfo = uriString->Substring2(0, pos);
            uriString = uriString->Remove2(0, (pos + 1));
        }
        this->port = -1;
        pos = uriString->LastIndexOf7(_T(":"));
        if(unixAbsPath) 
        {
            pos = -1;
        }
        if(((pos != -1) && (pos != (uriString->get_Length() - 1)))) 
        {
            System::String *portStr = uriString->Remove2(0, (pos + 1));
            if(((portStr->get_Length() > 1) && ((int32_t)(portStr->get_Chars((portStr->get_Length() - 1))) != 93))) 
            {
                try {
                    this->port = (int32_t)System::UInt32::Parse5(portStr, System::Globalization::CultureInfo::get_InvariantCulture());
                    uriString = uriString->Substring2(0, pos);
                }
                catch(System::Exception*) {
                    throw cli::gcnew<System::FormatException>(_T("Invalid URI: invalid port number"));
                }
            }
        }
        if((this->port ==  -1)) 
        {
            this->port = GetDefaultPort(this->scheme);
        }
        this->host = uriString;
        if(unixAbsPath) 
        {
            this->path = cli::concat(cli::box(u'/'), uriString);
            this->host = System::String::Empty;
        }
         else 
        {
            if(((this->host->get_Length() ==  2) && ((int32_t)(this->host->get_Chars(1)) ==  58))) 
            {
                this->path = cli::concat(this->host, this->path);
                this->host = System::String::Empty;
            }
             else 
            {
                if(this->isUnixFilePath) 
                {
                    uriString = cli::concat(_T("//"), uriString);
                    this->host = System::String::Empty;
                }
                 else 
                {
                    if((this->host->get_Length() ==  0)) 
                    {
                        throw cli::gcnew<System::FormatException>(_T("Invalid URI: The hostname could not be parsed"));
                    }
                     else 
                    {
                        if(System::String::op_Equality(this->scheme, UriSchemeFile)) 
                        {
                            this->isUnc = true;
                        }
                    }
                }
            }
        }
        if(((System::String::op_Inequality(this->scheme, UriSchemeMailto) && System::String::op_Inequality(this->scheme, UriSchemeNews)) && System::String::op_Inequality(this->scheme, UriSchemeFile))) 
        {
            if(this->reduce) 
            {
                this->path = Reduce(this->path);
            }
        }
    }
    
    System::String* Uri::Reduce(System::String* path) {
        path = path->Replace(u'\\', u'/');
        cli::array<System::String*> *parts = path->Split((new cli::array<char16_t>({u'/'})));
        System::Collections::Generic::List<System::String*> *result = cli::gcnew<System::Collections::Generic::List<System::String*>>();
        int32_t end = parts->get_Length();
        for(int32_t i = 0; (i < end); i++){
            System::String *current = parts->at(i);
            if(((current->get_Length() ==  0) || System::String::op_Equality(current, _T(".")))) 
            {
                continue;
            }
            if(System::String::op_Equality(current, _T(".."))) 
            {
                if((result->get_Count() ==  0)) 
                {
                    if((i ==  1)) 
                    {
                        continue;
                    }
                    throw cli::gcnew<System::Exception>(_T("Invalid path."));
                }
                result->RemoveAt((result->get_Count() - 1));
                continue;
            }
            result->Add(current);
        }
        if((result->get_Count() ==  0)) 
        {
            return _T("/");
        }
        result->Insert(0, System::String::Empty);
        System::String *res = System::String::Join(_T("/"), result->ToArray());
        if(path->EndsWith(_T("/"))) 
        {
            (res = cli::concat(res, cli::box(u'/')));
        }
        return res;
    }
    
    System::String* Uri::GetSchemeDelimiter(System::String* scheme) {
        for(int32_t i = 0; (i < schemes->get_Length()); i++) {
            if(System::String::op_Equality(schemes->at(i)->scheme, scheme)) 
            {
                return schemes->at(i)->delimiter;
            }
        }
        return SchemeDelimiter;
    }
    
    int32_t Uri::GetDefaultPort(System::String* scheme) {
        for(int32_t i = 0; (i < schemes->get_Length()); i++) {
            if(System::String::op_Equality(schemes->at(i)->scheme, scheme)) 
            {
                return schemes->at(i)->defaultPort;
            }
        }
        return -1;
    }
    
    System::String* Uri::GetOpaqueWiseSchemeDelimiter() {
        if(this->isOpaquePart) 
        {
            return _T(":");
        }
         else 
        {
            return GetSchemeDelimiter(this->scheme);
        }
    }
    
    bool Uri::IsBadFileSystemCharacter(char16_t ch) {
        int32_t chInt = (int32_t)(ch);
        if(((chInt < 32) || ((chInt < 64) && (chInt > 57)))) 
        {
            return true;
        }
        switch(chInt) {
            case 0: case 34: case 38: case 42: case 44: case 47: case 92: case 94: case 124: case_366: {
                return true;
            }
        }
        return false;
    }
    
    bool Uri::IsExcludedCharacter(char16_t ch) {
        if((((int32_t)(ch) <= 32) || ((int32_t)(ch) >= 127))) 
        {
            return true;
        }
        if(((((((((((((((int32_t)(ch) ==  34) || ((int32_t)(ch) ==  35)) || ((int32_t)(ch) ==  37)) || ((int32_t)(ch) ==  60)) || ((int32_t)(ch) ==  62)) || ((int32_t)(ch) ==  91)) || ((int32_t)(ch) ==  92)) || ((int32_t)(ch) ==  93)) || ((int32_t)(ch) ==  94)) || ((int32_t)(ch) ==  96)) || ((int32_t)(ch) ==  123)) || ((int32_t)(ch) ==  124)) || ((int32_t)(ch) ==  125))) 
        {
            return true;
        }
        return false;
    }
    
    bool Uri::IsPredefinedScheme(System::String* scheme) {
        System::String* tmp_66 = scheme;
        ::System::Int32 tmp_67 = -1;
        if(::System::String::Equals3(tmp_66, _T("http")) ||
        ::System::String::Equals3(tmp_66, _T("https")) ||
        ::System::String::Equals3(tmp_66, _T("file")) ||
        ::System::String::Equals3(tmp_66, _T("ftp")) ||
        ::System::String::Equals3(tmp_66, _T("nntp")) ||
        ::System::String::Equals3(tmp_66, _T("gopher")) ||
        ::System::String::Equals3(tmp_66, _T("mailto")) ||
        ::System::String::Equals3(tmp_66, _T("news"))) tmp_67 = 0;
        switch(tmp_67)
        {
            case 0: case_367: 
            {
                return true;
            }
            default: case_368: 
            {
                return false;
            }
        }
    }
    
    bool Uri::IsReservedCharacter(char16_t ch) {
        if(((((((((((int32_t)(ch) ==  36) || ((int32_t)(ch) ==  38)) || ((int32_t)(ch) ==  43)) || ((int32_t)(ch) ==  44)) || ((int32_t)(ch) ==  47)) || ((int32_t)(ch) ==  58)) || ((int32_t)(ch) ==  59)) || ((int32_t)(ch) ==  61)) || ((int32_t)(ch) ==  64))) 
        {
            return true;
        }
        return false;
    }
    
    System::String* Uri::get_AbsolutePath() {
        return this->path;
    }
    
    System::String* Uri::get_AbsoluteUri() {
        if((this->cachedAbsoluteUri ==  nullptr)) 
        {
            this->cachedAbsoluteUri = cli::concat(GetLeftPart(UriPartial::Path2), this->query);
        }
        return this->cachedAbsoluteUri;
    }
    
    System::String* Uri::get_Authority() {
        return (GetDefaultPort(this->scheme) ==  this->port) ? this->host : cli::concat(this->host, _T(":"));
    }
    
    System::String* Uri::get_Fragment() {
        return this->fragment;
    }
    
    System::String* Uri::get_Host() {
        return this->host;
    }
    
    bool Uri::get_IsDefaultPort() {
        return (GetDefaultPort(this->scheme) ==  this->port);
    }
    
    bool Uri::get_IsFile() {
        return System::String::op_Equality(this->scheme, UriSchemeFile);
    }
    
    bool Uri::get_IsLoopback() {
        if(System::String::op_Equality(this->host, System::String::Empty)) 
        {
            return false;
        }
        if((System::String::op_Equality(this->host, _T("loopback")) || System::String::op_Equality(this->host, _T("localhost")))) 
        {
            return true;
        }
        return false;
    }
    
    bool Uri::get_IsUnc() {
        return this->isUnc;
    }
    
    System::String* Uri::get_LocalPath() {
        if((this->cachedLocalPath != nullptr)) 
        {
            return this->cachedLocalPath;
        }
        if(!(this->get_IsFile())) 
        {
            return this->get_AbsolutePath();
        }
        bool windows = (((this->path->get_Length() > 3) && ((int32_t)(this->path->get_Chars(1)) ==  58)) && (((int32_t)(this->path->get_Chars(2)) ==  92) || ((int32_t)(this->path->get_Chars(2)) ==  47)));
        if(!(this->get_IsUnc())) 
        {
            System::String *p = Unescape(this->path);
            if((((int32_t)(System::IO::Path::DirectorySeparatorChar) ==  92) || windows)) 
            {
                this->cachedLocalPath = p->Replace(u'/', u'\\');
            }
             else 
            {
                this->cachedLocalPath = p;
            }
        }
         else 
        {
            if(((this->path->get_Length() > 1) && ((int32_t)(this->path->get_Chars(1)) ==  58))) 
            {
                this->cachedLocalPath = Unescape(this->path->Replace(System::IO::Path::AltDirectorySeparatorChar, System::IO::Path::DirectorySeparatorChar));
            }
             else 
            {
                if(((int32_t)(System::IO::Path::DirectorySeparatorChar) ==  92)) 
                {
                    this->cachedLocalPath = cli::concat(_T("\\\\"), Unescape(cli::concat(this->host, this->path->Replace(u'/', u'\\'))));
                }
                 else 
                {
                    this->cachedLocalPath = Unescape(this->path);
                }
            }
        }
        if(System::String::op_Equality(this->cachedLocalPath, System::String::Empty)) 
        {
            this->cachedLocalPath = cli::import(System::IO::Path::DirectorySeparatorChar)->ToString_1636a0751cb9ac11();
        }
        return this->cachedLocalPath;
    }
    
    System::String* Uri::get_PathAndQuery() {
        return cli::concat(this->path, this->query);
    }
    
    int32_t Uri::get_Port() {
        return this->port;
    }
    
    System::String* Uri::get_Query() {
        return this->query;
    }
    
    System::String* Uri::get_Scheme() {
        return this->scheme;
    }
    
    cli::array<System::String*>* Uri::get_Segments() {
        if((this->segments != nullptr)) 
        {
            return this->segments;
        }
        if((this->path->get_Length() ==  0)) 
        {
            this->segments = (new cli::array<System::String*>(0));
            return this->segments;
        }
        cli::array<System::String*> *parts = this->path->Split((new cli::array<char16_t>({u'/'})));
        this->segments = parts;
        bool endSlash = this->path->EndsWith(_T("/"));
        if(((parts->get_Length() > 0) && endSlash)) 
        {
            cli::array<System::String*> *newParts = (new cli::array<System::String*>((parts->get_Length() - 1)));
            System::Array::Copy2(parts, 0, newParts, 0, (parts->get_Length() - 1));
            parts = newParts;
        }
        int32_t i = 0;
        if(((this->get_IsFile() && (this->path->get_Length() > 1)) && ((int32_t)(this->path->get_Chars(1)) ==  58))) 
        {
            cli::array<System::String*> *newParts = (new cli::array<System::String*>((parts->get_Length() + 1)));
            System::Array::Copy2(parts, 1, newParts, 2, (parts->get_Length() - 1));
            parts = newParts;
            parts->at(0) = this->path->Substring2(0, 2);
            parts->at(1) = System::String::Empty;
            i++;
        }
        int32_t end = parts->get_Length();
        for(; (i < end); i++) {
            if(((i != (end - 1)) || endSlash)) 
            {
                System::String *t = parts->at(i);
                (t = cli::concat(t, cli::box(u'/')));
                parts->at(i) = t;
            }
        }
        this->segments = parts;
        return this->segments;
    }
    
    bool Uri::get_UserEscaped() {
        return this->userEscaped;
    }
    
    System::String* Uri::get_UserInfo() {
        return this->userinfo;
    }
    
}}
namespace Mono { namespace Security { namespace Authenticode {
    
    
    void AuthenticodeBase::constructor() {
        this->fileblock = (new cli::array<unsigned char>(4096));
    }
    
    void AuthenticodeBase::Open(System::String* filename) {
        if((this->fs != nullptr)) 
        {
            Close();
        }
        this->fs = cli::gcnew<System::IO::FileStream>(filename, System::IO::FileMode::Open, System::IO::FileAccess::Read, System::IO::FileShare::Read);
    }
    
    void AuthenticodeBase::Close() {
        if((this->fs != nullptr)) 
        {
            this->fs->Close_59c62ed53ef2a481();
            this->fs = nullptr;
            this->blockNo = 0;
        }
    }
    
    bool AuthenticodeBase::ReadFirstBlock() {
        if((this->fs ==  nullptr)) 
        {
            return false;
        }
        this->fs->set_Position_cfe1def757785ad(0L);
        this->blockLength = this->fs->Read_c0d6dde3943b413e(this->fileblock, 0, this->fileblock->get_Length());
        this->blockNo = 1;
        if((this->blockLength < 64)) 
        {
            return false;
        }
        if(((int32_t)(Mono::Security::BitConverterLE::ToUInt16(this->fileblock, 0)) != 23117)) 
        {
            return false;
        }
        this->peOffset = Mono::Security::BitConverterLE::ToInt32(this->fileblock, 60);
        if((this->peOffset > this->fileblock->get_Length())) 
        {
            System::String *msg = System::String::Format2(Locale::GetText(_T("Header size too big (> {0} bytes).")), cli::box(this->fileblock->get_Length()));
            throw cli::gcnew<System::NotSupportedException>(msg);
        }
        if(((int64_t)(this->peOffset) > this->fs->get_Length_ddb8b0d061db5350())) 
        {
            return false;
        }
        if((Mono::Security::BitConverterLE::ToUInt32(this->fileblock, this->peOffset) != 17744U)) 
        {
            return false;
        }
        this->dirSecurityOffset = Mono::Security::BitConverterLE::ToInt32(this->fileblock, (this->peOffset + 152));
        this->dirSecuritySize = Mono::Security::BitConverterLE::ToInt32(this->fileblock, (this->peOffset + 156));
        this->coffSymbolTableOffset = Mono::Security::BitConverterLE::ToInt32(this->fileblock, (this->peOffset + 12));
        return true;
    }
    
    cli::array<unsigned char>* AuthenticodeBase::GetSecurityEntry() {
        if((this->blockNo < 1)) 
        {
            ReadFirstBlock();
        }
        if((this->dirSecuritySize > 8)) 
        {
            cli::array<unsigned char> *secEntry = (new cli::array<unsigned char>((this->dirSecuritySize - 8)));
            this->fs->set_Position_cfe1def757785ad((int64_t)((this->dirSecurityOffset + 8)));
            this->fs->Read_c0d6dde3943b413e(secEntry, 0, secEntry->get_Length());
            return secEntry;
        }
        return nullptr;
    }
    
    cli::array<unsigned char>* AuthenticodeBase::GetHash(System::Security::Cryptography::HashAlgorithm* hash) {
        if((this->blockNo < 1)) 
        {
            ReadFirstBlock();
        }
        this->fs->set_Position_cfe1def757785ad((int64_t)(this->blockLength));
        int64_t n;
        int32_t addsize = 0;
        if((this->dirSecurityOffset > 0)) 
        {
            if((this->dirSecurityOffset < this->blockLength)) 
            {
                this->blockLength = this->dirSecurityOffset;
                n = 0L;
            }
             else 
            {
                n = (int64_t)((this->dirSecurityOffset - this->blockLength));
            }
        }
         else 
        {
            if((this->coffSymbolTableOffset > 0)) 
            {
                this->fileblock->at((this->get_PEOffset() + 12)) = 0;
                this->fileblock->at((this->get_PEOffset() + 13)) = 0;
                this->fileblock->at((this->get_PEOffset() + 14)) = 0;
                this->fileblock->at((this->get_PEOffset() + 15)) = 0;
                this->fileblock->at((this->get_PEOffset() + 16)) = 0;
                this->fileblock->at((this->get_PEOffset() + 17)) = 0;
                this->fileblock->at((this->get_PEOffset() + 18)) = 0;
                this->fileblock->at((this->get_PEOffset() + 19)) = 0;
                if((this->coffSymbolTableOffset < this->blockLength)) 
                {
                    this->blockLength = this->coffSymbolTableOffset;
                    n = 0L;
                }
                 else 
                {
                    n = (int64_t)((this->coffSymbolTableOffset - this->blockLength));
                }
            }
             else 
            {
                addsize = (int32_t)(this->fs->get_Length_ddb8b0d061db5350() & 7L);
                if((addsize > 0)) 
                {
                    addsize = (8 - addsize);
                }
                n = (this->fs->get_Length_ddb8b0d061db5350() - (int64_t)(this->blockLength));
            }
        }
        int32_t pe = (this->peOffset + 88);
        hash->TransformBlock(this->fileblock, 0, pe, this->fileblock, 0);
        (pe = pe + 4);
        hash->TransformBlock(this->fileblock, pe, 60, this->fileblock, pe);
        (pe = pe + 68);
        if((n ==  0L)) 
        {
            hash->TransformFinalBlock(this->fileblock, pe, (this->blockLength - pe));
        }
         else 
        {
            hash->TransformBlock(this->fileblock, pe, (this->blockLength - pe), this->fileblock, pe);
            int64_t blocks = (n >> 12);
            int32_t remainder = (int32_t)(n - (blocks << 12));
            if((remainder ==  0)) 
            {
                blocks--;
                remainder = 4096;
            }
            while((blocks-- > 0L)) {
                this->fs->Read_c0d6dde3943b413e(this->fileblock, 0, this->fileblock->get_Length());
                hash->TransformBlock(this->fileblock, 0, this->fileblock->get_Length(), this->fileblock, 0);
            }
            if((this->fs->Read_c0d6dde3943b413e(this->fileblock, 0, remainder) != remainder)) 
            {
                return nullptr;
            }
            if((addsize > 0)) 
            {
                hash->TransformBlock(this->fileblock, 0, remainder, this->fileblock, 0);
                hash->TransformFinalBlock((new cli::array<unsigned char>(addsize)), 0, addsize);
            }
             else 
            {
                hash->TransformFinalBlock(this->fileblock, 0, remainder);
            }
        }
        return hash->get_Hash_cb65a3f211aa16df();
    }
    
    cli::array<unsigned char>* AuthenticodeBase::HashFile(System::String* fileName, System::String* hashName) {
        try {
            Open(fileName);
            System::Security::Cryptography::HashAlgorithm *hash = System::Security::Cryptography::HashAlgorithm::Create2(hashName);
            cli::array<unsigned char> *result = GetHash(hash);
            Close();
            return result;
        }
        catch(...) {
            return nullptr;
        }
    }
    
    int32_t AuthenticodeBase::get_PEOffset() {
        if((this->blockNo < 1)) 
        {
            ReadFirstBlock();
        }
        return this->peOffset;
    }
    
    int32_t AuthenticodeBase::get_CoffSymbolTableOffset() {
        if((this->blockNo < 1)) 
        {
            ReadFirstBlock();
        }
        return this->coffSymbolTableOffset;
    }
    
    int32_t AuthenticodeBase::get_SecurityOffset() {
        if((this->blockNo < 1)) 
        {
            ReadFirstBlock();
        }
        return this->dirSecurityOffset;
    }
    
}}}
namespace Mono { namespace Security { namespace Authenticode {
    
    
    void AuthenticodeDeformatter::constructor() {
        this->reason = -1;
        this->signerChain = cli::gcnew<Mono::Security::X509::X509Chain>();
        this->timestampChain = cli::gcnew<Mono::Security::X509::X509Chain>();
    }
    
    void AuthenticodeDeformatter::constructor(System::String* fileName) {
        this->set_FileName(fileName);
    }
    
    bool AuthenticodeDeformatter::IsTrusted() {
        if((this->entry ==  nullptr)) 
        {
            this->reason = 1;
            return false;
        }
        if((this->signingCertificate ==  nullptr)) 
        {
            this->reason = 7;
            return false;
        }
        if(((this->signerChain->get_Root() ==  nullptr) || !(this->trustedRoot))) 
        {
            this->reason = 6;
            return false;
        }
        if(System::DateTime::op_Inequality(this->timestamp, (*System::DateTime::MinValue))) 
        {
            if(((this->timestampChain->get_Root() ==  nullptr) || !(this->trustedTimestampRoot))) 
            {
                this->reason = 6;
                return false;
            }
            if(!(this->signingCertificate->WasCurrent(this->get_Timestamp()))) 
            {
                this->reason = 4;
                return false;
            }
        }
         else 
        {
            if(!(this->signingCertificate->get_IsCurrent())) 
            {
                this->reason = 8;
                return false;
            }
        }
        if((this->reason ==  -1)) 
        {
            this->reason = 0;
        }
        return true;
    }
    
    bool AuthenticodeDeformatter::CheckSignature(System::String* fileName) {
        this->filename = fileName;
        AuthenticodeBase::Open(this->filename);
        this->entry = AuthenticodeBase::GetSecurityEntry();
        if((this->entry ==  nullptr)) 
        {
            this->reason = 1;
            AuthenticodeBase::Close();
            return false;
        }
        Mono::Security::ContentInfo *ci = cli::gcnew<Mono::Security::ContentInfo>(this->entry);
        if(System::String::op_Inequality(ci->get_ContentType(), _T("1.2.840.113549.1.7.2"))) 
        {
            AuthenticodeBase::Close();
            return false;
        }
        Mono::Security::SignedData *sd = cli::gcnew<Mono::Security::SignedData>(ci->get_Content());
        if(System::String::op_Inequality(sd->get_ContentInfo()->get_ContentType(), _T("1.3.6.1.4.1.311.2.1.4"))) 
        {
            AuthenticodeBase::Close();
            return false;
        }
        this->coll = sd->get_Certificates();
        Mono::Security::ASN1 *spc = sd->get_ContentInfo()->get_Content();
        this->signedHash = spc->get_Item(0)->get_Item(1)->get_Item(1);
        System::Security::Cryptography::HashAlgorithm *ha = nullptr;
        switch(this->signedHash->get_Length()) {
            case 16: case_369: {
                ha = System::Security::Cryptography::HashAlgorithm::Create2(_T("MD5"));
                this->hash = AuthenticodeBase::GetHash(ha);
                break;
            }
            case 20: case_370: {
                ha = System::Security::Cryptography::HashAlgorithm::Create2(_T("SHA1"));
                this->hash = AuthenticodeBase::GetHash(ha);
                break;
            }
            default: case_371: {
                this->reason = 5;
                AuthenticodeBase::Close();
                return false;
            }
        }
        AuthenticodeBase::Close();
        if(!(this->signedHash->CompareValue(this->hash))) 
        {
            this->reason = 2;
        }
        cli::array<unsigned char> *spcIDC = spc->get_Item(0)->get_Value();
        ha->Initialize_4bdfe3e821ea432();
        cli::array<unsigned char> *messageDigest = ha->ComputeHash(spcIDC);
        bool sign = VerifySignature(sd, messageDigest, ha);
        return (sign && (this->reason ==  0));
    }
    
    bool AuthenticodeDeformatter::CompareIssuerSerial(System::String* issuer, cli::array<unsigned char>* serial, Mono::Security::X509::X509Certificate* x509) {
        if(System::String::op_Inequality(issuer, x509->get_IssuerName_25458e2c269ceeaa())) 
        {
            return false;
        }
        if((serial->get_Length() != x509->get_SerialNumber_ac6911419cae47b0()->get_Length())) 
        {
            return false;
        }
        int32_t n = serial->get_Length();
        for(int32_t i = 0; (i < serial->get_Length()); i++){
            if(((int32_t)(serial->at(i)) != (int32_t)(x509->get_SerialNumber_ac6911419cae47b0()->at(--n)))) 
            {
                return false;
            }
        }
        return true;
    }
    
    bool AuthenticodeDeformatter::VerifySignature(Mono::Security::SignedData* sd, cli::array<unsigned char>* calculatedMessageDigest, System::Security::Cryptography::HashAlgorithm* ha) {
        System::String *contentType = nullptr;
        Mono::Security::ASN1 *messageDigest = nullptr;
        for(int32_t i = 0; (i < sd->get_SignerInfo()->get_AuthenticatedAttributes()->get_Count_2354963792616712()); i++){
            Mono::Security::ASN1 *attr = cli::cast<Mono::Security::ASN1*>(sd->get_SignerInfo()->get_AuthenticatedAttributes()->get_Item_fd0155f142ae570(i));
            System::String *oid = Mono::Security::ASN1Convert::ToOid(attr->get_Item(0));
            System::String* tmp_68 = oid;
            ::System::Int32 tmp_69 = -1;
            if(::System::String::Equals3(tmp_68, _T("1.2.840.113549.1.9.3"))) tmp_69 = 0;
            if(::System::String::Equals3(tmp_68, _T("1.2.840.113549.1.9.4"))) tmp_69 = 1;
            if(::System::String::Equals3(tmp_68, _T("1.3.6.1.4.1.311.2.1.11"))) tmp_69 = 2;
            if(::System::String::Equals3(tmp_68, _T("1.3.6.1.4.1.311.2.1.12"))) tmp_69 = 3;
            switch(tmp_69)
            {
                case 0: case_372: 
                {
                    contentType = Mono::Security::ASN1Convert::ToOid(attr->get_Item(1)->get_Item(0));
                    break;
                }
                case 1: case_373: 
                {
                    messageDigest = attr->get_Item(1)->get_Item(0);
                    break;
                }
                case 2: case_374: 
                {
                    break;
                }
                case 3: case_375: 
                {
                    break;
                }
                default: case_376: 
                {
                    break;
                }
            }
        }
        if(System::String::op_Inequality(contentType, _T("1.3.6.1.4.1.311.2.1.4"))) 
        {
            return false;
        }
        if((messageDigest ==  nullptr)) 
        {
            return false;
        }
        if(!(messageDigest->CompareValue(calculatedMessageDigest))) 
        {
            return false;
        }
        System::String *hashOID = System::Security::Cryptography::CryptoConfig::MapNameToOID(ha->ToString_1636a0751cb9ac11());
        Mono::Security::ASN1 *aa = cli::gcnew<Mono::Security::ASN1>(49);
        for(auto tmp_70 : sd->get_SignerInfo()->get_AuthenticatedAttributes()) {
            auto a = cli::cast<Mono::Security::ASN1*>(tmp_70);
            aa->Add(a);
        }
        ha->Initialize_4bdfe3e821ea432();
        cli::array<unsigned char> *p7hash = ha->ComputeHash(aa->GetBytes_b91405229279a4ac());
        cli::array<unsigned char> *signature = sd->get_SignerInfo()->get_Signature();
        System::String *issuer = sd->get_SignerInfo()->get_IssuerName();
        cli::array<unsigned char> *serial = sd->get_SignerInfo()->get_SerialNumber();
        for(auto tmp_71 : this->coll) {
            auto x509 = cli::cast<Mono::Security::X509::X509Certificate*>(tmp_71);
            {
                if(CompareIssuerSerial(issuer, serial, x509)) 
                {
                    if((x509->get_PublicKey_bbce0ec4cf2d16e()->get_Length() > (signature->get_Length() >> 3))) 
                    {
                        this->signingCertificate = x509;
                        System::Security::Cryptography::RSACryptoServiceProvider *rsa = cli::cast<System::Security::Cryptography::RSACryptoServiceProvider*>(x509->get_RSA_32368d0ddec581fa());
                        if(rsa->VerifyHash(p7hash, hashOID, signature)) 
                        {
                            this->signerChain->LoadCertificates(this->coll);
                            this->trustedRoot = this->signerChain->Build(x509);
                            break;
                        }
                    }
                }
            }
        }
        if((sd->get_SignerInfo()->get_UnauthenticatedAttributes()->get_Count_2354963792616712() ==  0)) 
        {
            this->trustedTimestampRoot = true;
        }
         else 
        {
            for(int32_t i = 0; (i < sd->get_SignerInfo()->get_UnauthenticatedAttributes()->get_Count_2354963792616712()); i++){
                Mono::Security::ASN1 *attr = cli::cast<Mono::Security::ASN1*>(sd->get_SignerInfo()->get_UnauthenticatedAttributes()->get_Item_fd0155f142ae570(i));
                System::String *oid = Mono::Security::ASN1Convert::ToOid(attr->get_Item(0));
                System::String* tmp_72 = oid;
                ::System::Int32 tmp_73 = -1;
                if(::System::String::Equals3(tmp_72, _T("1.2.840.113549.1.9.6"))) tmp_73 = 0;
                switch(tmp_73)
                {
                    case 0: case_377: 
                    {
                        Mono::Security::SignerInfo *cs = cli::gcnew<Mono::Security::SignerInfo>(attr->get_Item(1));
                        this->trustedTimestampRoot = VerifyCounterSignature(cs, signature);
                        break;
                    }
                    default: case_378: 
                    {
                        break;
                    }
                }
            }
        }
        return (this->trustedRoot && this->trustedTimestampRoot);
    }
    
    bool AuthenticodeDeformatter::VerifyCounterSignature(Mono::Security::SignerInfo* cs, cli::array<unsigned char>* signature) {
        if(((int32_t)(cs->get_Version()) != 1)) 
        {
            return false;
        }
        System::String *contentType = nullptr;
        Mono::Security::ASN1 *messageDigest = nullptr;
        for(int32_t i = 0; (i < cs->get_AuthenticatedAttributes()->get_Count_2354963792616712()); i++){
            Mono::Security::ASN1 *attr = cli::cast<Mono::Security::ASN1*>(cs->get_AuthenticatedAttributes()->get_Item_fd0155f142ae570(i));
            System::String *oid = Mono::Security::ASN1Convert::ToOid(attr->get_Item(0));
            System::String* tmp_74 = oid;
            ::System::Int32 tmp_75 = -1;
            if(::System::String::Equals3(tmp_74, _T("1.2.840.113549.1.9.3"))) tmp_75 = 0;
            if(::System::String::Equals3(tmp_74, _T("1.2.840.113549.1.9.4"))) tmp_75 = 1;
            if(::System::String::Equals3(tmp_74, _T("1.2.840.113549.1.9.5"))) tmp_75 = 2;
            switch(tmp_75)
            {
                case 0: case_379: 
                {
                    contentType = Mono::Security::ASN1Convert::ToOid(attr->get_Item(1)->get_Item(0));
                    break;
                }
                case 1: case_380: 
                {
                    messageDigest = attr->get_Item(1)->get_Item(0);
                    break;
                }
                case 2: case_381: 
                {
                    this->timestamp = Mono::Security::ASN1Convert::ToDateTime(attr->get_Item(1)->get_Item(0));
                    break;
                }
                default: case_382: 
                {
                    break;
                }
            }
        }
        if(System::String::op_Inequality(contentType, _T("1.2.840.113549.1.7.1"))) 
        {
            return false;
        }
        if((messageDigest ==  nullptr)) 
        {
            return false;
        }
        System::String *hashName = nullptr;
        switch(messageDigest->get_Length()) {
            case 16: case_383: {
                hashName = _T("MD5");
                break;
            }
            case 20: case_384: {
                hashName = _T("SHA1");
                break;
            }
        }
        System::Security::Cryptography::HashAlgorithm *ha = System::Security::Cryptography::HashAlgorithm::Create2(hashName);
        if(!(messageDigest->CompareValue(ha->ComputeHash(signature)))) 
        {
            return false;
        }
        cli::array<unsigned char> *counterSignature = cs->get_Signature();
        Mono::Security::ASN1 *aa = cli::gcnew<Mono::Security::ASN1>(49);
        for(auto tmp_76 : cs->get_AuthenticatedAttributes()) {
            auto a = cli::cast<Mono::Security::ASN1*>(tmp_76);
            aa->Add(a);
        }
        cli::array<unsigned char> *p7hash = ha->ComputeHash(aa->GetBytes_b91405229279a4ac());
        System::String *issuer = cs->get_IssuerName();
        cli::array<unsigned char> *serial = cs->get_SerialNumber();
        for(auto tmp_77 : this->coll) {
            auto x509 = cli::cast<Mono::Security::X509::X509Certificate*>(tmp_77);
            {
                if(CompareIssuerSerial(issuer, serial, x509)) 
                {
                    if((x509->get_PublicKey_bbce0ec4cf2d16e()->get_Length() > counterSignature->get_Length())) 
                    {
                        System::Security::Cryptography::RSACryptoServiceProvider *rsa = cli::cast<System::Security::Cryptography::RSACryptoServiceProvider*>(x509->get_RSA_32368d0ddec581fa());
                        Mono::Security::Cryptography::RSAManaged *rsam = cli::gcnew<Mono::Security::Cryptography::RSAManaged>();
                        rsam->ImportParameters_43620ad65e380dd(rsa->ExportParameters_f406cf113d936197(false));
                        if(Mono::Security::Cryptography::PKCS1::Verify_v152(rsam, ha, p7hash, counterSignature, true)) 
                        {
                            this->timestampChain->LoadCertificates(this->coll);
                            return this->timestampChain->Build(x509);
                        }
                    }
                }
            }
        }
        return false;
    }
    
    void AuthenticodeDeformatter::Reset() {
        this->filename = nullptr;
        this->entry = nullptr;
        this->hash = nullptr;
        this->signedHash = nullptr;
        this->signingCertificate = nullptr;
        this->reason = -1;
        this->trustedRoot = false;
        this->trustedTimestampRoot = false;
        this->signerChain->Reset();
        this->timestampChain->Reset();
        this->timestamp = (*System::DateTime::MinValue);
    }
    
    System::String* AuthenticodeDeformatter::get_FileName() {
        return this->filename;
    }
    
    System::String* AuthenticodeDeformatter::set_FileName(System::String* value) {
        Reset();
        try {
            CheckSignature(value);
        }
        catch(System::Security::SecurityException*) {
            throw ;
        }
        catch(System::Exception*) {
            this->reason = 1;
        }
        return get_FileName();
    }
    
    cli::array<unsigned char>* AuthenticodeDeformatter::get_Hash() {
        if((this->signedHash ==  nullptr)) 
        {
            return nullptr;
        }
        return cli::cast<cli::array<unsigned char>*>(cli::import(this->signedHash->get_Value())->Clone());
    }
    
    int32_t AuthenticodeDeformatter::get_Reason() {
        if((this->reason ==  -1)) 
        {
            IsTrusted();
        }
        return this->reason;
    }
    
    cli::array<unsigned char>* AuthenticodeDeformatter::get_Signature() {
        if((this->entry ==  nullptr)) 
        {
            return nullptr;
        }
        return cli::cast<cli::array<unsigned char>*>(cli::import(this->entry)->Clone());
    }
    
    System::DateTime AuthenticodeDeformatter::get_Timestamp() {
        return this->timestamp;
    }
    
    Mono::Security::X509::X509CertificateCollection* AuthenticodeDeformatter::get_Certificates() {
        return this->coll;
    }
    
    Mono::Security::X509::X509Certificate* AuthenticodeDeformatter::get_SigningCertificate() {
        return this->signingCertificate;
    }
    
}}}
namespace Mono { namespace Security { namespace Cryptography {
    
    
    void CryptoConvert::constructor() {
    }
    
    int32_t CryptoConvert::ToInt32LE(cli::array<unsigned char>* bytes, int32_t offset) {
        return (((((int32_t)(bytes->at((offset + 3))) << 24) | ((int32_t)(bytes->at((offset + 2))) << 16)) | ((int32_t)(bytes->at((offset + 1))) << 8)) | (int32_t)(bytes->at(offset)));
    }
    
    uint32_t CryptoConvert::ToUInt32LE(cli::array<unsigned char>* bytes, int32_t offset) {
        return (uint32_t)(((((int32_t)(bytes->at((offset + 3))) << 24) | ((int32_t)(bytes->at((offset + 2))) << 16)) | ((int32_t)(bytes->at((offset + 1))) << 8)) | (int32_t)(bytes->at(offset)));
    }
    
    cli::array<unsigned char>* CryptoConvert::GetBytesLE(int32_t val) {
        return (new cli::array<unsigned char>({(System::Byte)(val & 255), (System::Byte)((val >> 8) & 255), (System::Byte)((val >> 16) & 255), (System::Byte)((val >> 24) & 255)}));
    }
    
    cli::array<unsigned char>* CryptoConvert::Trim(cli::array<unsigned char>* array) {
        for(int32_t i = 0; (i < array->get_Length()); i++){
            if(((int32_t)(array->at(i)) != 0)) 
            {
                cli::array<unsigned char> *result = (new cli::array<unsigned char>((array->get_Length() - i)));
                System::Buffer::BlockCopy(array, i, result, 0, result->get_Length());
                return result;
            }
        }
        return nullptr;
    }
    
    System::Security::Cryptography::RSA* CryptoConvert::FromCapiPrivateKeyBlob(cli::array<unsigned char>* blob) {
        return FromCapiPrivateKeyBlob2(blob, 0);
    }
    
    System::Security::Cryptography::RSA* CryptoConvert::FromCapiPrivateKeyBlob2(cli::array<unsigned char>* blob, int32_t offset) {
        if((blob ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("blob"));
        }
        if((offset >= blob->get_Length())) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("blob is too small."));
        }
        System::Security::Cryptography::RSAParameters rsap = cli::ctor<System::Security::Cryptography::RSAParameters>();
        try {
            if(((((((int32_t)(blob->at(offset)) != 7) || ((int32_t)(blob->at((offset + 1))) != 2)) || ((int32_t)(blob->at((offset + 2))) != 0)) || ((int32_t)(blob->at((offset + 3))) != 0)) || (ToUInt32LE(blob, (offset + 8)) != 843141970U))) 
            {
                throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("Invalid blob header"));
            }
            int32_t bitLen = ToInt32LE(blob, (offset + 12));
            cli::array<unsigned char> *exp = (new cli::array<unsigned char>(4));
            System::Buffer::BlockCopy(blob, (offset + 16), exp, 0, 4);
            System::Array::Reverse(exp);
            rsap->Exponent = Trim(exp);
            int32_t pos = (offset + 20);
            int32_t byteLen = (bitLen >> 3);
            rsap->Modulus = (new cli::array<unsigned char>(byteLen));
            System::Buffer::BlockCopy(blob, pos, rsap->Modulus, 0, byteLen);
            System::Array::Reverse(rsap->Modulus);
            (pos = pos + byteLen);
            int32_t byteHalfLen = (byteLen >> 1);
            rsap->P = (new cli::array<unsigned char>(byteHalfLen));
            System::Buffer::BlockCopy(blob, pos, rsap->P, 0, byteHalfLen);
            System::Array::Reverse(rsap->P);
            (pos = pos + byteHalfLen);
            rsap->Q = (new cli::array<unsigned char>(byteHalfLen));
            System::Buffer::BlockCopy(blob, pos, rsap->Q, 0, byteHalfLen);
            System::Array::Reverse(rsap->Q);
            (pos = pos + byteHalfLen);
            rsap->DP = (new cli::array<unsigned char>(byteHalfLen));
            System::Buffer::BlockCopy(blob, pos, rsap->DP, 0, byteHalfLen);
            System::Array::Reverse(rsap->DP);
            (pos = pos + byteHalfLen);
            rsap->DQ = (new cli::array<unsigned char>(byteHalfLen));
            System::Buffer::BlockCopy(blob, pos, rsap->DQ, 0, byteHalfLen);
            System::Array::Reverse(rsap->DQ);
            (pos = pos + byteHalfLen);
            rsap->InverseQ = (new cli::array<unsigned char>(byteHalfLen));
            System::Buffer::BlockCopy(blob, pos, rsap->InverseQ, 0, byteHalfLen);
            System::Array::Reverse(rsap->InverseQ);
            (pos = pos + byteHalfLen);
            rsap->D = (new cli::array<unsigned char>(byteLen));
            if((((pos + byteLen) + offset) <= blob->get_Length())) 
            {
                System::Buffer::BlockCopy(blob, pos, rsap->D, 0, byteLen);
                System::Array::Reverse(rsap->D);
            }
        }
        catch(System::Exception* e) {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("Invalid blob."), e);
        }
        System::Security::Cryptography::RSA *rsa = nullptr;
        try {
            rsa = System::Security::Cryptography::RSA::Create3();
            rsa->ImportParameters_43620ad65e380dd(rsap);
        }
        catch(System::Security::Cryptography::CryptographicException* ce) {
            try {
                System::Security::Cryptography::CspParameters *csp = cli::gcnew<System::Security::Cryptography::CspParameters>();
                csp->set_Flags(System::Security::Cryptography::CspProviderFlags::UseMachineKeyStore);
                rsa = cli::gcnew<System::Security::Cryptography::RSACryptoServiceProvider>(csp);
                rsa->ImportParameters_43620ad65e380dd(rsap);
            }
            catch(...) {
                throw ce;
            }
        }
        return rsa;
    }
    
    System::Security::Cryptography::DSA* CryptoConvert::FromCapiPrivateKeyBlobDSA(cli::array<unsigned char>* blob) {
        return FromCapiPrivateKeyBlobDSA2(blob, 0);
    }
    
    System::Security::Cryptography::DSA* CryptoConvert::FromCapiPrivateKeyBlobDSA2(cli::array<unsigned char>* blob, int32_t offset) {
        if((blob ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("blob"));
        }
        if((offset >= blob->get_Length())) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("blob is too small."));
        }
        System::Security::Cryptography::DSAParameters dsap = cli::ctor<System::Security::Cryptography::DSAParameters>();
        try {
            if(((((((int32_t)(blob->at(offset)) != 7) || ((int32_t)(blob->at((offset + 1))) != 2)) || ((int32_t)(blob->at((offset + 2))) != 0)) || ((int32_t)(blob->at((offset + 3))) != 0)) || (ToUInt32LE(blob, (offset + 8)) != 844321604U))) 
            {
                throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("Invalid blob header"));
            }
            int32_t bitlen = ToInt32LE(blob, (offset + 12));
            int32_t bytelen = (bitlen >> 3);
            int32_t pos = (offset + 16);
            dsap->P = (new cli::array<unsigned char>(bytelen));
            System::Buffer::BlockCopy(blob, pos, dsap->P, 0, bytelen);
            System::Array::Reverse(dsap->P);
            (pos = pos + bytelen);
            dsap->Q = (new cli::array<unsigned char>(20));
            System::Buffer::BlockCopy(blob, pos, dsap->Q, 0, 20);
            System::Array::Reverse(dsap->Q);
            (pos = pos + 20);
            dsap->G = (new cli::array<unsigned char>(bytelen));
            System::Buffer::BlockCopy(blob, pos, dsap->G, 0, bytelen);
            System::Array::Reverse(dsap->G);
            (pos = pos + bytelen);
            dsap->X = (new cli::array<unsigned char>(20));
            System::Buffer::BlockCopy(blob, pos, dsap->X, 0, 20);
            System::Array::Reverse(dsap->X);
            (pos = pos + 20);
            dsap->Counter = ToInt32LE(blob, pos);
            (pos = pos + 4);
            dsap->Seed = (new cli::array<unsigned char>(20));
            System::Buffer::BlockCopy(blob, pos, dsap->Seed, 0, 20);
            System::Array::Reverse(dsap->Seed);
            (pos = pos + 20);
        }
        catch(System::Exception* e) {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("Invalid blob."), e);
        }
        System::Security::Cryptography::DSA *dsa = nullptr;
        try {
            dsa = cli::cast<System::Security::Cryptography::DSA*>(System::Security::Cryptography::DSA::Create3());
            dsa->ImportParameters_42bffe0948290f21(dsap);
        }
        catch(System::Security::Cryptography::CryptographicException* ce) {
            try {
                System::Security::Cryptography::CspParameters *csp = cli::gcnew<System::Security::Cryptography::CspParameters>();
                csp->set_Flags(System::Security::Cryptography::CspProviderFlags::UseMachineKeyStore);
                dsa = cli::gcnew<System::Security::Cryptography::DSACryptoServiceProvider>(csp);
                dsa->ImportParameters_42bffe0948290f21(dsap);
            }
            catch(...) {
                throw ce;
            }
        }
        return dsa;
    }
    
    cli::array<unsigned char>* CryptoConvert::ToCapiPrivateKeyBlob(System::Security::Cryptography::RSA* rsa) {
        System::Security::Cryptography::RSAParameters p = rsa->ExportParameters_f406cf113d936197(true);
        int32_t keyLength = p->Modulus->get_Length();
        cli::array<unsigned char> *blob = (new cli::array<unsigned char>(((20 + (keyLength << 2)) + (keyLength >> 1))));
        blob->at(0) = 7;
        blob->at(1) = 2;
        blob->at(5) = 36;
        blob->at(8) = 82;
        blob->at(9) = 83;
        blob->at(10) = 65;
        blob->at(11) = 50;
        cli::array<unsigned char> *bitlen = GetBytesLE((keyLength << 3));
        blob->at(12) = bitlen->at(0);
        blob->at(13) = bitlen->at(1);
        blob->at(14) = bitlen->at(2);
        blob->at(15) = bitlen->at(3);
        int32_t pos = 16;
        int32_t n = p->Exponent->get_Length();
        while((n > 0)) blob->at(pos++) = p->Exponent->at(--n);
        pos = 20;
        cli::array<unsigned char> *part = p->Modulus;
        int32_t len = part->get_Length();
        System::Array::Reverse2(part, 0, len);
        System::Buffer::BlockCopy(part, 0, blob, pos, len);
        (pos = pos + len);
        part = p->P;
        len = part->get_Length();
        System::Array::Reverse2(part, 0, len);
        System::Buffer::BlockCopy(part, 0, blob, pos, len);
        (pos = pos + len);
        part = p->Q;
        len = part->get_Length();
        System::Array::Reverse2(part, 0, len);
        System::Buffer::BlockCopy(part, 0, blob, pos, len);
        (pos = pos + len);
        part = p->DP;
        len = part->get_Length();
        System::Array::Reverse2(part, 0, len);
        System::Buffer::BlockCopy(part, 0, blob, pos, len);
        (pos = pos + len);
        part = p->DQ;
        len = part->get_Length();
        System::Array::Reverse2(part, 0, len);
        System::Buffer::BlockCopy(part, 0, blob, pos, len);
        (pos = pos + len);
        part = p->InverseQ;
        len = part->get_Length();
        System::Array::Reverse2(part, 0, len);
        System::Buffer::BlockCopy(part, 0, blob, pos, len);
        (pos = pos + len);
        part = p->D;
        len = part->get_Length();
        System::Array::Reverse2(part, 0, len);
        System::Buffer::BlockCopy(part, 0, blob, pos, len);
        return blob;
    }
    
    cli::array<unsigned char>* CryptoConvert::ToCapiPrivateKeyBlob2(System::Security::Cryptography::DSA* dsa) {
        System::Security::Cryptography::DSAParameters p = dsa->ExportParameters_c041d0915f31506(true);
        int32_t keyLength = p->P->get_Length();
        cli::array<unsigned char> *blob = (new cli::array<unsigned char>(((((((16 + keyLength) + 20) + keyLength) + 20) + 4) + 20)));
        blob->at(0) = 7;
        blob->at(1) = 2;
        blob->at(5) = 34;
        blob->at(8) = 68;
        blob->at(9) = 83;
        blob->at(10) = 83;
        blob->at(11) = 50;
        cli::array<unsigned char> *bitlen = GetBytesLE((keyLength << 3));
        blob->at(12) = bitlen->at(0);
        blob->at(13) = bitlen->at(1);
        blob->at(14) = bitlen->at(2);
        blob->at(15) = bitlen->at(3);
        int32_t pos = 16;
        cli::array<unsigned char> *part = p->P;
        System::Array::Reverse(part);
        System::Buffer::BlockCopy(part, 0, blob, pos, keyLength);
        (pos = pos + keyLength);
        part = p->Q;
        System::Array::Reverse(part);
        System::Buffer::BlockCopy(part, 0, blob, pos, 20);
        (pos = pos + 20);
        part = p->G;
        System::Array::Reverse(part);
        System::Buffer::BlockCopy(part, 0, blob, pos, keyLength);
        (pos = pos + keyLength);
        part = p->X;
        System::Array::Reverse(part);
        System::Buffer::BlockCopy(part, 0, blob, pos, 20);
        (pos = pos + 20);
        System::Buffer::BlockCopy(GetBytesLE(p->Counter), 0, blob, pos, 4);
        (pos = pos + 4);
        part = p->Seed;
        System::Array::Reverse(part);
        System::Buffer::BlockCopy(part, 0, blob, pos, 20);
        return blob;
    }
    
    System::Security::Cryptography::RSA* CryptoConvert::FromCapiPublicKeyBlob(cli::array<unsigned char>* blob) {
        return FromCapiPublicKeyBlob2(blob, 0);
    }
    
    System::Security::Cryptography::RSA* CryptoConvert::FromCapiPublicKeyBlob2(cli::array<unsigned char>* blob, int32_t offset) {
        if((blob ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("blob"));
        }
        if((offset >= blob->get_Length())) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("blob is too small."));
        }
        try {
            if(((((((int32_t)(blob->at(offset)) != 6) || ((int32_t)(blob->at((offset + 1))) != 2)) || ((int32_t)(blob->at((offset + 2))) != 0)) || ((int32_t)(blob->at((offset + 3))) != 0)) || (ToUInt32LE(blob, (offset + 8)) != 826364754U))) 
            {
                throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("Invalid blob header"));
            }
            int32_t bitLen = ToInt32LE(blob, (offset + 12));
            System::Security::Cryptography::RSAParameters rsap = cli::ctor<System::Security::Cryptography::RSAParameters>();
            rsap->Exponent = (new cli::array<unsigned char>(3));
            rsap->Exponent->at(0) = blob->at((offset + 18));
            rsap->Exponent->at(1) = blob->at((offset + 17));
            rsap->Exponent->at(2) = blob->at((offset + 16));
            int32_t pos = (offset + 20);
            int32_t byteLen = (bitLen >> 3);
            rsap->Modulus = (new cli::array<unsigned char>(byteLen));
            System::Buffer::BlockCopy(blob, pos, rsap->Modulus, 0, byteLen);
            System::Array::Reverse(rsap->Modulus);
            System::Security::Cryptography::RSA *rsa = nullptr;
            try {
                rsa = System::Security::Cryptography::RSA::Create3();
                rsa->ImportParameters_43620ad65e380dd(rsap);
            }
            catch(System::Security::Cryptography::CryptographicException*) {
                System::Security::Cryptography::CspParameters *csp = cli::gcnew<System::Security::Cryptography::CspParameters>();
                csp->set_Flags(System::Security::Cryptography::CspProviderFlags::UseMachineKeyStore);
                rsa = cli::gcnew<System::Security::Cryptography::RSACryptoServiceProvider>(csp);
                rsa->ImportParameters_43620ad65e380dd(rsap);
            }
            return rsa;
        }
        catch(System::Exception* e) {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("Invalid blob."), e);
        }
    }
    
    System::Security::Cryptography::DSA* CryptoConvert::FromCapiPublicKeyBlobDSA(cli::array<unsigned char>* blob) {
        return FromCapiPublicKeyBlobDSA2(blob, 0);
    }
    
    System::Security::Cryptography::DSA* CryptoConvert::FromCapiPublicKeyBlobDSA2(cli::array<unsigned char>* blob, int32_t offset) {
        if((blob ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("blob"));
        }
        if((offset >= blob->get_Length())) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("blob is too small."));
        }
        try {
            if(((((((int32_t)(blob->at(offset)) != 6) || ((int32_t)(blob->at((offset + 1))) != 2)) || ((int32_t)(blob->at((offset + 2))) != 0)) || ((int32_t)(blob->at((offset + 3))) != 0)) || (ToUInt32LE(blob, (offset + 8)) != 827544388U))) 
            {
                throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("Invalid blob header"));
            }
            int32_t bitlen = ToInt32LE(blob, (offset + 12));
            System::Security::Cryptography::DSAParameters dsap = cli::ctor<System::Security::Cryptography::DSAParameters>();
            int32_t bytelen = (bitlen >> 3);
            int32_t pos = (offset + 16);
            dsap->P = (new cli::array<unsigned char>(bytelen));
            System::Buffer::BlockCopy(blob, pos, dsap->P, 0, bytelen);
            System::Array::Reverse(dsap->P);
            (pos = pos + bytelen);
            dsap->Q = (new cli::array<unsigned char>(20));
            System::Buffer::BlockCopy(blob, pos, dsap->Q, 0, 20);
            System::Array::Reverse(dsap->Q);
            (pos = pos + 20);
            dsap->G = (new cli::array<unsigned char>(bytelen));
            System::Buffer::BlockCopy(blob, pos, dsap->G, 0, bytelen);
            System::Array::Reverse(dsap->G);
            (pos = pos + bytelen);
            dsap->Y = (new cli::array<unsigned char>(bytelen));
            System::Buffer::BlockCopy(blob, pos, dsap->Y, 0, bytelen);
            System::Array::Reverse(dsap->Y);
            (pos = pos + bytelen);
            dsap->Counter = ToInt32LE(blob, pos);
            (pos = pos + 4);
            dsap->Seed = (new cli::array<unsigned char>(20));
            System::Buffer::BlockCopy(blob, pos, dsap->Seed, 0, 20);
            System::Array::Reverse(dsap->Seed);
            (pos = pos + 20);
            System::Security::Cryptography::DSA *dsa = cli::cast<System::Security::Cryptography::DSA*>(System::Security::Cryptography::DSA::Create3());
            dsa->ImportParameters_42bffe0948290f21(dsap);
            return dsa;
        }
        catch(System::Exception* e) {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("Invalid blob."), e);
        }
    }
    
    cli::array<unsigned char>* CryptoConvert::ToCapiPublicKeyBlob(System::Security::Cryptography::RSA* rsa) {
        System::Security::Cryptography::RSAParameters p = rsa->ExportParameters_f406cf113d936197(false);
        int32_t keyLength = p->Modulus->get_Length();
        cli::array<unsigned char> *blob = (new cli::array<unsigned char>((20 + keyLength)));
        blob->at(0) = 6;
        blob->at(1) = 2;
        blob->at(5) = 36;
        blob->at(8) = 82;
        blob->at(9) = 83;
        blob->at(10) = 65;
        blob->at(11) = 49;
        cli::array<unsigned char> *bitlen = GetBytesLE((keyLength << 3));
        blob->at(12) = bitlen->at(0);
        blob->at(13) = bitlen->at(1);
        blob->at(14) = bitlen->at(2);
        blob->at(15) = bitlen->at(3);
        int32_t pos = 16;
        int32_t n = p->Exponent->get_Length();
        while((n > 0)) blob->at(pos++) = p->Exponent->at(--n);
        pos = 20;
        cli::array<unsigned char> *part = p->Modulus;
        int32_t len = part->get_Length();
        System::Array::Reverse2(part, 0, len);
        System::Buffer::BlockCopy(part, 0, blob, pos, len);
        (pos = pos + len);
        return blob;
    }
    
    cli::array<unsigned char>* CryptoConvert::ToCapiPublicKeyBlob2(System::Security::Cryptography::DSA* dsa) {
        System::Security::Cryptography::DSAParameters p = dsa->ExportParameters_c041d0915f31506(false);
        int32_t keyLength = p->P->get_Length();
        cli::array<unsigned char> *blob = (new cli::array<unsigned char>(((((((16 + keyLength) + 20) + keyLength) + keyLength) + 4) + 20)));
        blob->at(0) = 6;
        blob->at(1) = 2;
        blob->at(5) = 34;
        blob->at(8) = 68;
        blob->at(9) = 83;
        blob->at(10) = 83;
        blob->at(11) = 49;
        cli::array<unsigned char> *bitlen = GetBytesLE((keyLength << 3));
        blob->at(12) = bitlen->at(0);
        blob->at(13) = bitlen->at(1);
        blob->at(14) = bitlen->at(2);
        blob->at(15) = bitlen->at(3);
        int32_t pos = 16;
        cli::array<unsigned char> *part;
        part = p->P;
        System::Array::Reverse(part);
        System::Buffer::BlockCopy(part, 0, blob, pos, keyLength);
        (pos = pos + keyLength);
        part = p->Q;
        System::Array::Reverse(part);
        System::Buffer::BlockCopy(part, 0, blob, pos, 20);
        (pos = pos + 20);
        part = p->G;
        System::Array::Reverse(part);
        System::Buffer::BlockCopy(part, 0, blob, pos, keyLength);
        (pos = pos + keyLength);
        part = p->Y;
        System::Array::Reverse(part);
        System::Buffer::BlockCopy(part, 0, blob, pos, keyLength);
        (pos = pos + keyLength);
        System::Buffer::BlockCopy(GetBytesLE(p->Counter), 0, blob, pos, 4);
        (pos = pos + 4);
        part = p->Seed;
        System::Array::Reverse(part);
        System::Buffer::BlockCopy(part, 0, blob, pos, 20);
        return blob;
    }
    
    System::Security::Cryptography::RSA* CryptoConvert::FromCapiKeyBlob(cli::array<unsigned char>* blob) {
        return FromCapiKeyBlob2(blob, 0);
    }
    
    System::Security::Cryptography::RSA* CryptoConvert::FromCapiKeyBlob2(cli::array<unsigned char>* blob, int32_t offset) {
        if((blob ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("blob"));
        }
        if((offset >= blob->get_Length())) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("blob is too small."));
        }
        switch(blob->at(offset)) {
            case 0: case_385: {
                if(((int32_t)(blob->at((offset + 12))) ==  6)) 
                {
                    return FromCapiPublicKeyBlob2(blob, (offset + 12));
                }
                break;
            }
            case 6: case_386: {
                return FromCapiPublicKeyBlob2(blob, offset);
            }
            case 7: case_387: {
                return FromCapiPrivateKeyBlob2(blob, offset);
            }
        }
        throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("Unknown blob format."));
    }
    
    System::Security::Cryptography::DSA* CryptoConvert::FromCapiKeyBlobDSA(cli::array<unsigned char>* blob) {
        return FromCapiKeyBlobDSA2(blob, 0);
    }
    
    System::Security::Cryptography::DSA* CryptoConvert::FromCapiKeyBlobDSA2(cli::array<unsigned char>* blob, int32_t offset) {
        if((blob ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("blob"));
        }
        if((offset >= blob->get_Length())) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("blob is too small."));
        }
        switch(blob->at(offset)) {
            case 6: case_388: {
                return FromCapiPublicKeyBlobDSA2(blob, offset);
            }
            case 7: case_389: {
                return FromCapiPrivateKeyBlobDSA2(blob, offset);
            }
        }
        throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("Unknown blob format."));
    }
    
    cli::array<unsigned char>* CryptoConvert::ToCapiKeyBlob(System::Security::Cryptography::AsymmetricAlgorithm* keypair, bool includePrivateKey) {
        if((keypair ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("keypair"));
        }
        if(cli::is<System::Security::Cryptography::RSA>(keypair)) 
        {
            return ToCapiKeyBlob2(cli::cast<System::Security::Cryptography::RSA*>(keypair), includePrivateKey);
        }
         else 
        {
            if(cli::is<System::Security::Cryptography::DSA>(keypair)) 
            {
                return ToCapiKeyBlob3(cli::cast<System::Security::Cryptography::DSA*>(keypair), includePrivateKey);
            }
             else 
            {
                return nullptr;
            }
        }
    }
    
    cli::array<unsigned char>* CryptoConvert::ToCapiKeyBlob2(System::Security::Cryptography::RSA* rsa, bool includePrivateKey) {
        if((rsa ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("rsa"));
        }
        if(includePrivateKey) 
        {
            return ToCapiPrivateKeyBlob(rsa);
        }
         else 
        {
            return ToCapiPublicKeyBlob(rsa);
        }
    }
    
    cli::array<unsigned char>* CryptoConvert::ToCapiKeyBlob3(System::Security::Cryptography::DSA* dsa, bool includePrivateKey) {
        if((dsa ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("dsa"));
        }
        if(includePrivateKey) 
        {
            return ToCapiPrivateKeyBlob2(dsa);
        }
         else 
        {
            return ToCapiPublicKeyBlob2(dsa);
        }
    }
    
    System::String* CryptoConvert::ToHex(cli::array<unsigned char>* input) {
        if((input ==  nullptr)) 
        {
            return nullptr;
        }
        System::Text::StringBuilder *sb = cli::gcnew<System::Text::StringBuilder>((input->get_Length() * 2));
        for(auto tmp_78 : input) {
            auto b = cli::cast<unsigned char>(tmp_78);
            {
                sb->Append2(cli::import(b)->ToString5(_T("X2"), System::Globalization::CultureInfo::get_InvariantCulture()));
            }
        }
        return sb->ToString_1636a0751cb9ac11();
    }
    
    unsigned char CryptoConvert::FromHexChar(char16_t c) {
        if((((int32_t)(c) >= 97) && ((int32_t)(c) <= 102))) 
        {
            return (unsigned char)(((int32_t)(c) - 97) + 10);
        }
        if((((int32_t)(c) >= 65) && ((int32_t)(c) <= 70))) 
        {
            return (unsigned char)(((int32_t)(c) - 65) + 10);
        }
        if((((int32_t)(c) >= 48) && ((int32_t)(c) <= 57))) 
        {
            return (unsigned char)((int32_t)(c) - 48);
        }
        throw cli::gcnew<System::ArgumentException>(_T("invalid hex char"));
    }
    
    cli::array<unsigned char>* CryptoConvert::FromHex(System::String* hex) {
        if((hex ==  nullptr)) 
        {
            return nullptr;
        }
        if(((hex->get_Length() & 1) ==  1)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Length must be a multiple of 2"));
        }
        cli::array<unsigned char> *result = (new cli::array<unsigned char>((hex->get_Length() >> 1)));
        int32_t n = 0;
        int32_t i = 0;
        while((n < result->get_Length())) {
            result->at(n) = (unsigned char)((int32_t)(FromHexChar(hex->get_Chars(i++))) << 4);
            (result->at(n++) = (unsigned char)((int32_t)(result->at(n++)) + (int32_t)(FromHexChar(hex->get_Chars(i++)))));
        }
        return result;
    }
    
}}}
namespace Mono { namespace Security { namespace Cryptography {
    
    System::Security::Cryptography::RandomNumberGenerator*  KeyBuilder::rng;
    
    void KeyBuilder::constructor() {
    }
    
    cli::array<unsigned char>* KeyBuilder::Key2(int32_t size) {
        cli::array<unsigned char> *key = (new cli::array<unsigned char>(size));
        KeyBuilder::get_Rng()->GetBytes_bf6c3bc1baf70dfd(key);
        return key;
    }
    
    cli::array<unsigned char>* KeyBuilder::IV(int32_t size) {
        cli::array<unsigned char> *iv = (new cli::array<unsigned char>(size));
        KeyBuilder::get_Rng()->GetBytes_bf6c3bc1baf70dfd(iv);
        return iv;
    }
    
    System::Security::Cryptography::RandomNumberGenerator* KeyBuilder::get_Rng() {
        if((rng ==  nullptr)) 
        {
            rng = System::Security::Cryptography::RandomNumberGenerator::Create();
        }
        return rng;
    }
    
}}}
namespace Mono { namespace Security { namespace Cryptography {
    
    
    void BlockProcessor::constructor(System::Security::Cryptography::ICryptoTransform* transform) {
    }
    
    void BlockProcessor::constructor(System::Security::Cryptography::ICryptoTransform* transform, int32_t blockSize) {
        this->transform = transform;
        this->blockSize = blockSize;
        this->block = (new cli::array<unsigned char>(blockSize));
    }
    
    void BlockProcessor::Finalize_d15966cd3f681596() {
        {
            cli::finally_guard([&]() {
                Finalize_b946fbc32e26afd6();
            });
            System::Array::Clear2(this->block, 0, this->blockSize);
        }
    }
    
    void BlockProcessor::Initialize() {
        System::Array::Clear2(this->block, 0, this->blockSize);
        this->blockCount = 0;
    }
    
    void BlockProcessor::Core(cli::array<unsigned char>* rgb) {
        Core2(rgb, 0, rgb->get_Length());
    }
    
    void BlockProcessor::Core2(cli::array<unsigned char>* rgb, int32_t ib, int32_t cb) {
        int32_t n = System::Math::Min5((this->blockSize - this->blockCount), cb);
        System::Buffer::BlockCopy(rgb, ib, this->block, this->blockCount, n);
        (this->blockCount = this->blockCount + n);
        if((this->blockCount ==  this->blockSize)) 
        {
            this->transform->TransformBlock_66947c2464acaa4b(this->block, 0, this->blockSize, this->block, 0);
            int32_t b = (int32_t)(((cb - n) / this->blockSize));
            for(int32_t i = 0; (i < b); i++){
                this->transform->TransformBlock_66947c2464acaa4b(rgb, (n + ib), this->blockSize, this->block, 0);
                (n = n + this->blockSize);
            }
            this->blockCount = (cb - n);
            if((this->blockCount > 0)) 
            {
                System::Buffer::BlockCopy(rgb, (n + ib), this->block, 0, this->blockCount);
            }
        }
    }
    
    cli::array<unsigned char>* BlockProcessor::Final() {
        return this->transform->TransformFinalBlock_24eabce3605cc4ff(this->block, 0, this->blockCount);
    }
    
}}}
namespace Mono { namespace Security { namespace Cryptography {
    
    
    void DSAManaged::constructor() {
    }
    
    void DSAManaged::constructor(int32_t dwKeySize) {
        this->KeySizeValue = dwKeySize;
        this->LegalKeySizesValue = (new cli::array<System::Security::Cryptography::KeySizes*>(1));
        this->LegalKeySizesValue->at(0) = cli::gcnew<System::Security::Cryptography::KeySizes>(512, 1024, 64);
    }
    
    void DSAManaged::Finalize_a7ad61d560f2a251() {
        {
            cli::finally_guard([&]() {
                Finalize_b946fbc32e26afd6();
            });
            System::Security::Cryptography::AsymmetricAlgorithm::Dispose_2369c0ba816a26e4(false);
        }
    }
    
    void DSAManaged::Generate() {
        GenerateParams(System::Security::Cryptography::DSA::get_KeySize_6bd474632c551ac());
        GenerateKeyPair();
        this->keypairGenerated = true;
        if((this->KeyGenerated != nullptr)) 
        {
            this->KeyGenerated->Invoke(this, nullptr);
        }
    }
    
    void DSAManaged::GenerateKeyPair() {
        this->x = Mono::Math::BigInteger::GenerateRandom2(160);
        while((Mono::Math::BigInteger::op_Equality(this->x, 0U) || Mono::Math::BigInteger::op_GreaterThanOrEqual(this->x, this->q))) {
            this->x->Randomize2();
        }
        this->y = this->g->ModPow(this->x, this->p);
    }
    
    void DSAManaged::add(cli::array<unsigned char>* a, cli::array<unsigned char>* b, int32_t value) {
        uint32_t x = (uint32_t)(((int32_t)(b->at((b->get_Length() - 1))) & 255) + value);
        a->at((b->get_Length() - 1)) = (unsigned char)x;
        (x = x >> 8);
        for(int32_t i = (b->get_Length() - 2); (i >= 0); i--){
            (x = x + (uint32_t)((int32_t)(b->at(i)) & 255));
            a->at(i) = (unsigned char)x;
            (x = x >> 8);
        }
    }
    
    void DSAManaged::GenerateParams(int32_t keyLength) {
        cli::array<unsigned char> *seed = (new cli::array<unsigned char>(20));
        cli::array<unsigned char> *part1 = (new cli::array<unsigned char>(20));
        cli::array<unsigned char> *part2 = (new cli::array<unsigned char>(20));
        cli::array<unsigned char> *u = (new cli::array<unsigned char>(20));
        System::Security::Cryptography::SHA1 *sha = System::Security::Cryptography::SHA1::Create3();
        int32_t n = ((keyLength - 1) / 160);
        cli::array<unsigned char> *w = (new cli::array<unsigned char>((keyLength / 8)));
        bool primesFound = false;
        while(!(primesFound)) {
            do {
                this->get_Random()->GetBytes_bf6c3bc1baf70dfd(seed);
                part1 = sha->ComputeHash(seed);
                System::Array::Copy2(seed, 0, part2, 0, seed->get_Length());
                add(part2, seed, 1);
                part2 = sha->ComputeHash(part2);
                for(int32_t i = 0; (i != u->get_Length()); i++) {
                    u->at(i) = (unsigned char)((int32_t)(part1->at(i)) ^ (int32_t)(part2->at(i)));
                }
                (u->at(0) = (unsigned char)((int32_t)(u->at(0)) | 128));
                (u->at(19) = (unsigned char)((int32_t)(u->at(19)) | 1));
                this->q = cli::gcnew<Mono::Math::BigInteger>(u);
            }
            while(!(this->q->IsProbablePrime()));
            this->counter = 0;
            int32_t offset = 2;
            while((this->counter < 4096)) {
                for(int32_t k = 0; (k < n); k++){
                    add(part1, seed, (offset + k));
                    part1 = sha->ComputeHash(part1);
                    System::Array::Copy2(part1, 0, w, (w->get_Length() - ((k + 1) * part1->get_Length())), part1->get_Length());
                }
                add(part1, seed, (offset + n));
                part1 = sha->ComputeHash(part1);
                System::Array::Copy2(part1, (part1->get_Length() - (w->get_Length() - (n * part1->get_Length()))), w, 0, (w->get_Length() - (n * part1->get_Length())));
                (w->at(0) = (unsigned char)((int32_t)(w->at(0)) | 128));
                Mono::Math::BigInteger *x = cli::gcnew<Mono::Math::BigInteger>(w);
                Mono::Math::BigInteger *c = Mono::Math::BigInteger::op_Modulus3(x, Mono::Math::BigInteger::op_Multiply2(this->q, 2));
                this->p = Mono::Math::BigInteger::op_Subtraction(x, Mono::Math::BigInteger::op_Subtraction(c, Mono::Math::BigInteger::op_Implicit2(1)));
                if(this->p->TestBit((uint32_t)(keyLength - 1))) 
                {
                    if(this->p->IsProbablePrime()) 
                    {
                        primesFound = true;
                        break;
                    }
                }
                (this->counter = this->counter + 1);
                (offset = offset + (n + 1));
            }
        }
        Mono::Math::BigInteger *pMinusOneOverQ = Mono::Math::BigInteger::op_Division2(Mono::Math::BigInteger::op_Subtraction(this->p, Mono::Math::BigInteger::op_Implicit2(1)), this->q);
        for(; ; ){
            Mono::Math::BigInteger *h = Mono::Math::BigInteger::GenerateRandom2(keyLength);
            if((Mono::Math::BigInteger::op_LessThanOrEqual(h, Mono::Math::BigInteger::op_Implicit2(1)) || Mono::Math::BigInteger::op_GreaterThanOrEqual(h, Mono::Math::BigInteger::op_Subtraction(this->p, Mono::Math::BigInteger::op_Implicit2(1))))) 
            {
                continue;
            }
            this->g = h->ModPow(pMinusOneOverQ, this->p);
            if(Mono::Math::BigInteger::op_LessThanOrEqual(this->g, Mono::Math::BigInteger::op_Implicit2(1))) 
            {
                continue;
            }
            break;
        }
        this->seed = cli::gcnew<Mono::Math::BigInteger>(seed);
        this->j = Mono::Math::BigInteger::op_Division2(Mono::Math::BigInteger::op_Subtraction(this->p, Mono::Math::BigInteger::op_Implicit2(1)), this->q);
    }
    
    cli::array<unsigned char>* DSAManaged::NormalizeArray(cli::array<unsigned char>* array) {
        int32_t n = (array->get_Length() % 4);
        if((n > 0)) 
        {
            cli::array<unsigned char> *temp = (new cli::array<unsigned char>(((array->get_Length() + 4) - n)));
            System::Array::Copy2(array, 0, temp, (4 - n), array->get_Length());
            return temp;
        }
         else 
        {
            return array;
        }
    }
    
    System::Security::Cryptography::DSAParameters DSAManaged::ExportParameters_c041d0915f31506(bool includePrivateParameters) {
        if(this->m_disposed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(Locale::GetText(_T("Keypair was disposed")));
        }
        if(!(this->keypairGenerated)) 
        {
            Generate();
        }
        if((includePrivateParameters && Mono::Math::BigInteger::op_Equality2(this->x, nullptr))) 
        {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("no private key to export"));
        }
        System::Security::Cryptography::DSAParameters param = cli::ctor<System::Security::Cryptography::DSAParameters>();
        param->P = NormalizeArray(this->p->GetBytes());
        param->Q = NormalizeArray(this->q->GetBytes());
        param->G = NormalizeArray(this->g->GetBytes());
        param->Y = NormalizeArray(this->y->GetBytes());
        if(!(this->j_missing)) 
        {
            param->J = NormalizeArray(this->j->GetBytes());
        }
        if(Mono::Math::BigInteger::op_Inequality(this->seed, 0U)) 
        {
            param->Seed = NormalizeArray(this->seed->GetBytes());
            param->Counter = this->counter;
        }
        if(includePrivateParameters) 
        {
            cli::array<unsigned char> *privateKey = this->x->GetBytes();
            if((privateKey->get_Length() ==  20)) 
            {
                param->X = NormalizeArray(privateKey);
            }
        }
        return param;
    }
    
    void DSAManaged::ImportParameters_42bffe0948290f21(System::Security::Cryptography::DSAParameters parameters) {
        if(this->m_disposed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(Locale::GetText(_T("Keypair was disposed")));
        }
        if((((parameters->P ==  nullptr) || (parameters->Q ==  nullptr)) || (parameters->G ==  nullptr))) 
        {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(Locale::GetText(_T("Missing mandatory DSA parameters (P, Q or G).")));
        }
        if(((parameters->X ==  nullptr) && (parameters->Y ==  nullptr))) 
        {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(Locale::GetText(_T("Missing both public (Y) and private (X) keys.")));
        }
        this->p = cli::gcnew<Mono::Math::BigInteger>(parameters->P);
        this->q = cli::gcnew<Mono::Math::BigInteger>(parameters->Q);
        this->g = cli::gcnew<Mono::Math::BigInteger>(parameters->G);
        if((parameters->X != nullptr)) 
        {
            this->x = cli::gcnew<Mono::Math::BigInteger>(parameters->X);
        }
         else 
        {
            this->x = nullptr;
        }
        if((parameters->Y != nullptr)) 
        {
            this->y = cli::gcnew<Mono::Math::BigInteger>(parameters->Y);
        }
         else 
        {
            this->y = this->g->ModPow(this->x, this->p);
        }
        if((parameters->J != nullptr)) 
        {
            this->j = cli::gcnew<Mono::Math::BigInteger>(parameters->J);
        }
         else 
        {
            this->j = Mono::Math::BigInteger::op_Division2(Mono::Math::BigInteger::op_Subtraction(this->p, Mono::Math::BigInteger::op_Implicit2(1)), this->q);
            this->j_missing = true;
        }
        if((parameters->Seed != nullptr)) 
        {
            this->seed = cli::gcnew<Mono::Math::BigInteger>(parameters->Seed);
            this->counter = parameters->Counter;
        }
         else 
        {
            this->seed = Mono::Math::BigInteger::op_Implicit2(0);
        }
        this->keypairGenerated = true;
    }
    
    cli::array<unsigned char>* DSAManaged::CreateSignature_9fa6bb91f702a4df(cli::array<unsigned char>* rgbHash) {
        if(this->m_disposed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(Locale::GetText(_T("Keypair was disposed")));
        }
        if((rgbHash ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("rgbHash"));
        }
        if((rgbHash->get_Length() != 20)) 
        {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("invalid hash length"));
        }
        if(!(this->keypairGenerated)) 
        {
            Generate();
        }
        if(Mono::Math::BigInteger::op_Equality2(this->x, nullptr)) 
        {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("no private key available for signature"));
        }
        Mono::Math::BigInteger *m = cli::gcnew<Mono::Math::BigInteger>(rgbHash);
        Mono::Math::BigInteger *k = Mono::Math::BigInteger::GenerateRandom2(160);
        while(Mono::Math::BigInteger::op_GreaterThanOrEqual(k, this->q)) k->Randomize2();
        Mono::Math::BigInteger *r = Mono::Math::BigInteger::op_Modulus3(this->g->ModPow(k, this->p), this->q);
        Mono::Math::BigInteger *s = Mono::Math::BigInteger::op_Modulus3(Mono::Math::BigInteger::op_Multiply(k->ModInverse(this->q), Mono::Math::BigInteger::op_Addition(m, Mono::Math::BigInteger::op_Multiply(this->x, r))), this->q);
        cli::array<unsigned char> *signature = (new cli::array<unsigned char>(40));
        cli::array<unsigned char> *part1 = r->GetBytes();
        cli::array<unsigned char> *part2 = s->GetBytes();
        int32_t start = (20 - part1->get_Length());
        System::Array::Copy2(part1, 0, signature, start, part1->get_Length());
        start = (40 - part2->get_Length());
        System::Array::Copy2(part2, 0, signature, start, part2->get_Length());
        return signature;
    }
    
    bool DSAManaged::VerifySignature_a25545e0d63f0901(cli::array<unsigned char>* rgbHash, cli::array<unsigned char>* rgbSignature) {
        if(this->m_disposed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(Locale::GetText(_T("Keypair was disposed")));
        }
        if((rgbHash ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("rgbHash"));
        }
        if((rgbSignature ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("rgbSignature"));
        }
        if((rgbHash->get_Length() != 20)) 
        {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("invalid hash length"));
        }
        if((rgbSignature->get_Length() != 40)) 
        {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("invalid signature length"));
        }
        if(!(this->keypairGenerated)) 
        {
            return false;
        }
        try {
            Mono::Math::BigInteger *m = cli::gcnew<Mono::Math::BigInteger>(rgbHash);
            cli::array<unsigned char> *half = (new cli::array<unsigned char>(20));
            System::Array::Copy2(rgbSignature, 0, half, 0, 20);
            Mono::Math::BigInteger *r = cli::gcnew<Mono::Math::BigInteger>(half);
            System::Array::Copy2(rgbSignature, 20, half, 0, 20);
            Mono::Math::BigInteger *s = cli::gcnew<Mono::Math::BigInteger>(half);
            if((Mono::Math::BigInteger::op_LessThan(r, Mono::Math::BigInteger::op_Implicit2(0)) || Mono::Math::BigInteger::op_LessThanOrEqual(this->q, r))) 
            {
                return false;
            }
            if((Mono::Math::BigInteger::op_LessThan(s, Mono::Math::BigInteger::op_Implicit2(0)) || Mono::Math::BigInteger::op_LessThanOrEqual(this->q, s))) 
            {
                return false;
            }
            Mono::Math::BigInteger *w = s->ModInverse(this->q);
            Mono::Math::BigInteger *u1 = Mono::Math::BigInteger::op_Modulus3(Mono::Math::BigInteger::op_Multiply(m, w), this->q);
            Mono::Math::BigInteger *u2 = Mono::Math::BigInteger::op_Modulus3(Mono::Math::BigInteger::op_Multiply(r, w), this->q);
            u1 = this->g->ModPow(u1, this->p);
            u2 = this->y->ModPow(u2, this->p);
            Mono::Math::BigInteger *v = Mono::Math::BigInteger::op_Modulus3(Mono::Math::BigInteger::op_Modulus3(Mono::Math::BigInteger::op_Multiply(u1, u2), this->p), this->q);
            return Mono::Math::BigInteger::op_Equality2(v, r);
        }
        catch(...) {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("couldn\'t compute signature verification"));
        }
    }
    
    void DSAManaged::Dispose_2369c0ba816a26e4(bool disposing) {
        if(!(this->m_disposed)) 
        {
            if(Mono::Math::BigInteger::op_Inequality2(this->x, nullptr)) 
            {
                this->x->Clear();
                this->x = nullptr;
            }
            if(disposing) 
            {
                if(Mono::Math::BigInteger::op_Inequality2(this->p, nullptr)) 
                {
                    this->p->Clear();
                    this->p = nullptr;
                }
                if(Mono::Math::BigInteger::op_Inequality2(this->q, nullptr)) 
                {
                    this->q->Clear();
                    this->q = nullptr;
                }
                if(Mono::Math::BigInteger::op_Inequality2(this->g, nullptr)) 
                {
                    this->g->Clear();
                    this->g = nullptr;
                }
                if(Mono::Math::BigInteger::op_Inequality2(this->j, nullptr)) 
                {
                    this->j->Clear();
                    this->j = nullptr;
                }
                if(Mono::Math::BigInteger::op_Inequality2(this->seed, nullptr)) 
                {
                    this->seed->Clear();
                    this->seed = nullptr;
                }
                if(Mono::Math::BigInteger::op_Inequality2(this->y, nullptr)) 
                {
                    this->y->Clear();
                    this->y = nullptr;
                }
            }
        }
        this->m_disposed = true;
    }
    
    System::Security::Cryptography::RandomNumberGenerator* DSAManaged::get_Random() {
        if((this->rng ==  nullptr)) 
        {
            this->rng = System::Security::Cryptography::RandomNumberGenerator::Create();
        }
        return this->rng;
    }
    
    int32_t DSAManaged::get_KeySize_6bd474632c551ac() {
        if(this->keypairGenerated) 
        {
            return this->p->BitCount();
        }
         else 
        {
            return System::Security::Cryptography::DSA::get_KeySize_6bd474632c551ac();
        }
    }
    
    System::String* DSAManaged::get_KeyExchangeAlgorithm_e4956689b1767b62() {
        return nullptr;
    }
    
    bool DSAManaged::get_PublicOnly() {
        return (this->keypairGenerated && Mono::Math::BigInteger::op_Equality2(this->x, nullptr));
    }
    
    System::String* DSAManaged::get_SignatureAlgorithm_94f2ebe82aebde31() {
        return _T("http://www.w3.org/2000/09/xmldsig#dsa-sha1");
    }
    
    void DSAManaged::add_KeyGenerated(KeyGeneratedEventHandler* value) {
      // TODO: "Implement automatic events!"
    }
    
    void DSAManaged::remove_KeyGenerated(KeyGeneratedEventHandler* value) {
      // TODO: "Implement automatic events!"
    }
    
}}}
namespace Mono { namespace Security { namespace Cryptography {
    
    
    void HMACAlgorithm::constructor(System::String* algoName) {
        CreateHash(algoName);
    }
    
    void HMACAlgorithm::Finalize_76e0a35fcdd856df() {
        {
            cli::finally_guard([&]() {
                Finalize_b946fbc32e26afd6();
            });
            Dispose();
        }
    }
    
    void HMACAlgorithm::CreateHash(System::String* algoName) {
        this->algo = System::Security::Cryptography::HashAlgorithm::Create2(algoName);
        this->hashName = algoName;
        this->block = cli::gcnew<BlockProcessor>(this->algo, 8);
    }
    
    void HMACAlgorithm::Dispose() {
        if((this->key != nullptr)) 
        {
            System::Array::Clear2(this->key, 0, this->key->get_Length());
        }
    }
    
    void HMACAlgorithm::Initialize() {
        this->hash = nullptr;
        this->block->Initialize();
        cli::array<unsigned char> *buf = KeySetup(this->key, 54);
        this->algo->Initialize_4bdfe3e821ea432();
        this->block->Core(buf);
        System::Array::Clear2(buf, 0, buf->get_Length());
    }
    
    cli::array<unsigned char>* HMACAlgorithm::KeySetup(cli::array<unsigned char>* key, unsigned char padding) {
        cli::array<unsigned char> *buf = (new cli::array<unsigned char>(64));
        for(int32_t i = 0; (i < key->get_Length()); ++i) {
            buf->at(i) = (unsigned char)((int32_t)(key->at(i)) ^ (int32_t)(padding));
        }
        for(int32_t i = key->get_Length(); (i < 64); ++i) {
            buf->at(i) = padding;
        }
        return buf;
    }
    
    void HMACAlgorithm::Core(cli::array<unsigned char>* rgb, int32_t ib, int32_t cb) {
        this->block->Core2(rgb, ib, cb);
    }
    
    cli::array<unsigned char>* HMACAlgorithm::Final() {
        this->block->Final();
        cli::array<unsigned char> *intermediate = this->algo->get_Hash_cb65a3f211aa16df();
        cli::array<unsigned char> *buf = KeySetup(this->key, 92);
        this->algo->Initialize_4bdfe3e821ea432();
        this->algo->TransformBlock(buf, 0, buf->get_Length(), buf, 0);
        this->algo->TransformFinalBlock(intermediate, 0, intermediate->get_Length());
        this->hash = this->algo->get_Hash_cb65a3f211aa16df();
        this->algo->Clear();
        System::Array::Clear2(buf, 0, buf->get_Length());
        System::Array::Clear2(intermediate, 0, intermediate->get_Length());
        return this->hash;
    }
    
    System::Security::Cryptography::HashAlgorithm* HMACAlgorithm::get_Algo() {
        return this->algo;
    }
    
    System::String* HMACAlgorithm::get_HashName() {
        return this->hashName;
    }
    
    System::String* HMACAlgorithm::set_HashName(System::String* value) {
        CreateHash(value);
        return get_HashName();
    }
    
    cli::array<unsigned char>* HMACAlgorithm::get_Key() {
        return this->key;
    }
    
    cli::array<unsigned char>* HMACAlgorithm::set_Key(cli::array<unsigned char>* value) {
        if(((value != nullptr) && (value->get_Length() > 64))) 
        {
            this->key = this->algo->ComputeHash(value);
        }
         else 
        {
            this->key = cli::cast<cli::array<unsigned char>*>(cli::import(value)->Clone());
        }
        return get_Key();
    }
    
}}}
namespace Mono { namespace Security { namespace Cryptography {
    
    bool  KeyPairPersistence::_userPathExists;
    System::String*  KeyPairPersistence::_userPath;
    bool  KeyPairPersistence::_machinePathExists;
    System::String*  KeyPairPersistence::_machinePath;
    System::Object*  KeyPairPersistence::lockobj;
    
    KeyPairPersistence::KeyPairPersistence()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void KeyPairPersistence::constructor(System::Security::Cryptography::CspParameters* parameters) {
    }
    
    void KeyPairPersistence::constructor(System::Security::Cryptography::CspParameters* parameters, System::String* keyPair) {
        if((parameters ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("parameters"));
        }
        this->_params = Copy(parameters);
        this->_keyvalue = keyPair;
    }
    
    void KeyPairPersistence::static_constructor() {
    }
    
    bool KeyPairPersistence::Load() {
        bool result = System::IO::File::Exists(this->get_Filename());
        if(result) 
        {
            {
                /* USING - BLOCK */
                auto sr = System::IO::File::OpenText(this->get_Filename());
                cli::using_guard{sr};
                FromXml(sr->ReadToEnd_f683943dd5002e1e());
            }
        }
        return result;
    }
    
    void KeyPairPersistence::Save() {
        {
            /* USING - BLOCK */
            auto fs = System::IO::File::Open(this->get_Filename(), System::IO::FileMode::Create);
            cli::using_guard{fs};
            System::IO::StreamWriter *sw = cli::gcnew<System::IO::StreamWriter>(fs, System::Text::Encoding::get_UTF8());
            sw->Write_dcf5e45abd9e11c4(this->ToXml());
            sw->Close_745be624b802d9f6();
        }
        if(this->get_UseMachineKeyStore()) 
        {
            ProtectMachine(this->get_Filename());
        }
         else 
        {
            ProtectUser(this->get_Filename());
        }
    }
    
    void KeyPairPersistence::Remove() {
        System::IO::File::Delete(this->get_Filename());
    }
    
    bool KeyPairPersistence::_CanSecure(System::String* root) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool KeyPairPersistence::_ProtectUser(System::String* path) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool KeyPairPersistence::_ProtectMachine(System::String* path) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool KeyPairPersistence::_IsUserProtected(System::String* path) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool KeyPairPersistence::_IsMachineProtected(System::String* path) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool KeyPairPersistence::CanSecure(System::String* path) {
        int32_t platform = (int32_t)(System::Environment::get_OSVersion()->get_Platform());
        if((((platform ==  4) || (platform ==  128)) || (platform ==  6))) 
        {
            return true;
        }
        return _CanSecure(System::IO::Path::GetPathRoot(path));
    }
    
    bool KeyPairPersistence::ProtectUser(System::String* path) {
        if(CanSecure(path)) 
        {
            return _ProtectUser(path);
        }
        return true;
    }
    
    bool KeyPairPersistence::ProtectMachine(System::String* path) {
        if(CanSecure(path)) 
        {
            return _ProtectMachine(path);
        }
        return true;
    }
    
    bool KeyPairPersistence::IsUserProtected(System::String* path) {
        if(CanSecure(path)) 
        {
            return _IsUserProtected(path);
        }
        return true;
    }
    
    bool KeyPairPersistence::IsMachineProtected(System::String* path) {
        if(CanSecure(path)) 
        {
            return _IsMachineProtected(path);
        }
        return true;
    }
    
    System::Security::Cryptography::CspParameters* KeyPairPersistence::Copy(System::Security::Cryptography::CspParameters* p) {
        System::Security::Cryptography::CspParameters *copy = cli::gcnew<System::Security::Cryptography::CspParameters>(p->ProviderType, p->ProviderName, p->KeyContainerName);
        copy->KeyNumber2 = p->KeyNumber2;
        copy->set_Flags(p->get_Flags());
        return copy;
    }
    
    void KeyPairPersistence::FromXml(System::String* xml) {
        Mono::Xml::SecurityParser *sp = cli::gcnew<Mono::Xml::SecurityParser>();
        sp->LoadXml(xml);
        System::Security::SecurityElement *root = sp->ToXml();
        if(System::String::op_Equality(root->get_Tag(), _T("KeyPair"))) 
        {
            System::Security::SecurityElement *keyv = root->SearchForChildByTag(_T("KeyValue"));
            if((keyv->get_Children()->get_Count_2354963792616712() > 0)) 
            {
                this->_keyvalue = keyv->get_Children()->get_Item_fd0155f142ae570(0)->ToString_1636a0751cb9ac11();
            }
        }
    }
    
    System::String* KeyPairPersistence::ToXml() {
        System::Text::StringBuilder *xml = cli::gcnew<System::Text::StringBuilder>();
        xml->AppendFormat3(_T("<KeyPair>{0}\t<Properties>{0}\t\t<Provider "), System::Environment::get_NewLine());
        if(((this->_params->ProviderName != nullptr) && (this->_params->ProviderName->get_Length() != 0))) 
        {
            xml->AppendFormat3(_T("Name=\"{0}\" "), this->_params->ProviderName);
        }
        xml->AppendFormat4(_T("Type=\"{0}\" />{1}\t\t<Container "), cli::box(this->_params->ProviderType), System::Environment::get_NewLine());
        xml->AppendFormat4(_T("Name=\"{0}\" />{1}\t</Properties>{1}\t<KeyValue"), this->get_ContainerName(), System::Environment::get_NewLine());
        if((this->_params->KeyNumber2 != -1)) 
        {
            xml->AppendFormat3(_T(" Id=\"{0}\" "), cli::box(this->_params->KeyNumber2));
        }
        xml->AppendFormat4(_T(">{1}\t\t{0}{1}\t</KeyValue>{1}</KeyPair>{1}"), this->get_KeyValue(), System::Environment::get_NewLine());
        return xml->ToString_1636a0751cb9ac11();
    }
    
    System::String* KeyPairPersistence::get_Filename() {
        if((this->_filename ==  nullptr)) 
        {
            this->_filename = System::String::Format6(System::Globalization::CultureInfo::get_InvariantCulture(), _T("[{0}][{1}][{2}].xml"), (new cli::array<System::Object*>({cli::box(this->_params->ProviderType), this->get_ContainerName(), cli::box(this->_params->KeyNumber2)})));
            if(this->get_UseMachineKeyStore()) 
            {
                this->_filename = System::IO::Path::Combine(KeyPairPersistence::get_MachinePath(), this->_filename);
            }
             else 
            {
                this->_filename = System::IO::Path::Combine(KeyPairPersistence::get_UserPath(), this->_filename);
            }
        }
        return this->_filename;
    }
    
    System::String* KeyPairPersistence::get_KeyValue() {
        return this->_keyvalue;
    }
    
    System::String* KeyPairPersistence::set_KeyValue(System::String* value) {
        if(this->get_CanChange()) 
        {
            this->_keyvalue = value;
        }
        return get_KeyValue();
    }
    
    System::Security::Cryptography::CspParameters* KeyPairPersistence::get_Parameters() {
        return Copy(this->_params);
    }
    
    System::String* KeyPairPersistence::get_UserPath() {
        {
            cli::lock_guard{lockobj};
            if(((_userPath ==  nullptr) || !(_userPathExists))) 
            {
                _userPath = System::IO::Path::Combine(System::Environment::GetFolderPath(System::SpecialFolder::ApplicationData), _T(".mono"));
                _userPath = System::IO::Path::Combine(_userPath, _T("keypairs"));
                _userPathExists = System::IO::Directory::Exists(_userPath);
                if(!(_userPathExists)) 
                {
                    try {
                        System::IO::Directory::CreateDirectory(_userPath);
                        ProtectUser(_userPath);
                        _userPathExists = true;
                    }
                    catch(System::Exception* e) {
                        System::String *msg = Locale::GetText(_T("Could not create user key store \'{0}\'."));
                        throw cli::gcnew<System::Security::Cryptography::CryptographicException>(System::String::Format2(msg, _userPath), e);
                    }
                }
            }
        }
        if(!(IsUserProtected(_userPath))) 
        {
            System::String *msg = Locale::GetText(_T("Improperly protected user\'s key pairs in \'{0}\'."));
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(System::String::Format2(msg, _userPath));
        }
        return _userPath;
    }
    
    System::String* KeyPairPersistence::get_MachinePath() {
        {
            cli::lock_guard{lockobj};
            if(((_machinePath ==  nullptr) || !(_machinePathExists))) 
            {
                _machinePath = System::IO::Path::Combine(System::Environment::GetFolderPath(System::SpecialFolder::CommonApplicationData), _T(".mono"));
                _machinePath = System::IO::Path::Combine(_machinePath, _T("keypairs"));
                _machinePathExists = System::IO::Directory::Exists(_machinePath);
                if(!(_machinePathExists)) 
                {
                    try {
                        System::IO::Directory::CreateDirectory(_machinePath);
                        ProtectMachine(_machinePath);
                        _machinePathExists = true;
                    }
                    catch(System::Exception* e) {
                        System::String *msg = Locale::GetText(_T("Could not create machine key store \'{0}\'."));
                        throw cli::gcnew<System::Security::Cryptography::CryptographicException>(System::String::Format2(msg, _machinePath), e);
                    }
                }
            }
        }
        if(!(IsMachineProtected(_machinePath))) 
        {
            System::String *msg = Locale::GetText(_T("Improperly protected machine\'s key pairs in \'{0}\'."));
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(System::String::Format2(msg, _machinePath));
        }
        return _machinePath;
    }
    
    bool KeyPairPersistence::get_CanChange() {
        return (this->_keyvalue ==  nullptr);
    }
    
    bool KeyPairPersistence::get_UseDefaultKeyContainer() {
        return ((int32_t)(((int32_t)(this->_params->get_Flags()) & 2)) ==  2);
    }
    
    bool KeyPairPersistence::get_UseMachineKeyStore() {
        return ((int32_t)(((int32_t)(this->_params->get_Flags()) & 1)) ==  1);
    }
    
    System::String* KeyPairPersistence::get_ContainerName() {
        if((this->_container ==  nullptr)) 
        {
            if(this->get_UseDefaultKeyContainer()) 
            {
                this->_container = _T("default");
            }
             else 
            {
                if(((this->_params->KeyContainerName ==  nullptr) || (this->_params->KeyContainerName->get_Length() ==  0))) 
                {
                    this->_container = System::Guid::NewGuid()->ToString_1636a0751cb9ac11();
                }
                 else 
                {
                    cli::array<unsigned char> *data = System::Text::Encoding::get_UTF8()->GetBytes_49806e8e98b1c1db(this->_params->KeyContainerName);
                    System::Security::Cryptography::MD5 *hash = System::Security::Cryptography::MD5::Create3();
                    cli::array<unsigned char> *result = hash->ComputeHash(data);
                    this->_container = cli::ctor<System::Guid>(result)->ToString_1636a0751cb9ac11();
                }
            }
        }
        return this->_container;
    }
    
}}}
namespace Mono { namespace Security { namespace Cryptography {
    
    
    void MACAlgorithm::constructor(System::Security::Cryptography::SymmetricAlgorithm* algorithm) {
        this->algo = cli::cast<System::Security::Cryptography::SymmetricAlgorithm*>(algorithm);
        this->algo->set_Mode_b4ebd08a4556d807(System::Security::Cryptography::CipherMode::CBC);
        this->blockSize = (this->algo->get_BlockSize_7a5a96e8187bef27() >> 3);
        this->algo->set_IV_5f86e84678ef1565((new cli::array<unsigned char>(this->blockSize)));
        this->block = (new cli::array<unsigned char>(this->blockSize));
    }
    
    void MACAlgorithm::Initialize(cli::array<unsigned char>* key) {
        this->algo->set_Key_9b56e7a05d7e4c8f(key);
        if((this->enc ==  nullptr)) 
        {
            this->enc = this->algo->CreateEncryptor_f7057afd90cae836();
        }
        System::Array::Clear2(this->block, 0, this->blockSize);
        this->blockCount = 0;
    }
    
    void MACAlgorithm::Core(cli::array<unsigned char>* rgb, int32_t ib, int32_t cb) {
        int32_t n = System::Math::Min5((this->blockSize - this->blockCount), cb);
        System::Array::Copy2(rgb, ib, this->block, this->blockCount, n);
        (this->blockCount = this->blockCount + n);
        if((this->blockCount ==  this->blockSize)) 
        {
            this->enc->TransformBlock_66947c2464acaa4b(this->block, 0, this->blockSize, this->block, 0);
            int32_t b = (int32_t)(((cb - n) / this->blockSize));
            for(int32_t i = 0; (i < b); i++){
                this->enc->TransformBlock_66947c2464acaa4b(rgb, n, this->blockSize, this->block, 0);
                (n = n + this->blockSize);
            }
            this->blockCount = (cb - n);
            if((this->blockCount > 0)) 
            {
                System::Array::Copy2(rgb, n, this->block, 0, this->blockCount);
            }
        }
    }
    
    cli::array<unsigned char>* MACAlgorithm::Final() {
        cli::array<unsigned char> *result;
        if(((this->blockCount > 0) || (((int32_t)(this->algo->get_Padding_4e1745ee57afb026()) != 3) && ((int32_t)(this->algo->get_Padding_4e1745ee57afb026()) != 1)))) 
        {
            result = this->enc->TransformFinalBlock_24eabce3605cc4ff(this->block, 0, this->blockCount);
        }
         else 
        {
            result = cli::cast<cli::array<unsigned char>*>(cli::import(this->block)->Clone());
        }
        if(!(this->enc->get_CanReuseTransform_a8f6dfeea811518b())) 
        {
            this->enc->Dispose_95cb2516542c2f97();
            this->enc = nullptr;
        }
        return result;
    }
    
}}}
namespace Mono { namespace Security { namespace Cryptography {
    
    cli::array<unsigned char>*  PKCS1::emptySHA1;
    cli::array<unsigned char>*  PKCS1::emptySHA256;
    cli::array<unsigned char>*  PKCS1::emptySHA384;
    cli::array<unsigned char>*  PKCS1::emptySHA512;
    
    PKCS1::PKCS1()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void PKCS1::constructor() {
    }
    
    void PKCS1::static_constructor() {
    }
    
    bool PKCS1::Compare(cli::array<unsigned char>* array1, cli::array<unsigned char>* array2) {
        bool result = (array1->get_Length() ==  array2->get_Length());
        if(result) 
        {
            for(int32_t i = 0; (i < array1->get_Length()); i++) {
                if(((int32_t)(array1->at(i)) != (int32_t)(array2->at(i)))) 
                {
                    return false;
                }
            }
        }
        return result;
    }
    
    cli::array<unsigned char>* PKCS1::xor_(cli::array<unsigned char>* array1, cli::array<unsigned char>* array2) {
        cli::array<unsigned char> *result = (new cli::array<unsigned char>(array1->get_Length()));
        for(int32_t i = 0; (i < result->get_Length()); i++) {
            result->at(i) = (unsigned char)((int32_t)(array1->at(i)) ^ (int32_t)(array2->at(i)));
        }
        return result;
    }
    
    cli::array<unsigned char>* PKCS1::GetEmptyHash(System::Security::Cryptography::HashAlgorithm* hash) {
        if(cli::is<System::Security::Cryptography::SHA1>(hash)) 
        {
            return emptySHA1;
        }
         else 
        {
            if(cli::is<System::Security::Cryptography::SHA256>(hash)) 
            {
                return emptySHA256;
            }
             else 
            {
                if(cli::is<System::Security::Cryptography::SHA384>(hash)) 
                {
                    return emptySHA384;
                }
                 else 
                {
                    if(cli::is<System::Security::Cryptography::SHA512>(hash)) 
                    {
                        return emptySHA512;
                    }
                     else 
                    {
                        return hash->ComputeHash(nullptr);
                    }
                }
            }
        }
    }
    
    cli::array<unsigned char>* PKCS1::I2OSP(int32_t x, int32_t size) {
        cli::array<unsigned char> *array = Mono::Security::BitConverterLE::GetBytes4(x);
        System::Array::Reverse2(array, 0, array->get_Length());
        return I2OSP2(array, size);
    }
    
    cli::array<unsigned char>* PKCS1::I2OSP2(cli::array<unsigned char>* x, int32_t size) {
        cli::array<unsigned char> *result = (new cli::array<unsigned char>(size));
        System::Buffer::BlockCopy(x, 0, result, (result->get_Length() - x->get_Length()), x->get_Length());
        return result;
    }
    
    cli::array<unsigned char>* PKCS1::OS2IP(cli::array<unsigned char>* x) {
        int32_t i = 0;
        while((((int32_t)(x->at(i++)) ==  0) && (i < x->get_Length()))) {
        }
        i--;
        if((i > 0)) 
        {
            cli::array<unsigned char> *result = (new cli::array<unsigned char>((x->get_Length() - i)));
            System::Buffer::BlockCopy(x, i, result, 0, result->get_Length());
            return result;
        }
         else 
        {
            return x;
        }
    }
    
    cli::array<unsigned char>* PKCS1::RSAEP(System::Security::Cryptography::RSA* rsa, cli::array<unsigned char>* m) {
        return rsa->EncryptValue_16a44acec74209ed(m);
    }
    
    cli::array<unsigned char>* PKCS1::RSADP(System::Security::Cryptography::RSA* rsa, cli::array<unsigned char>* c) {
        return rsa->DecryptValue_e0f03fff133976bf(c);
    }
    
    cli::array<unsigned char>* PKCS1::RSASP1(System::Security::Cryptography::RSA* rsa, cli::array<unsigned char>* m) {
        return rsa->DecryptValue_e0f03fff133976bf(m);
    }
    
    cli::array<unsigned char>* PKCS1::RSAVP1(System::Security::Cryptography::RSA* rsa, cli::array<unsigned char>* s) {
        return rsa->EncryptValue_16a44acec74209ed(s);
    }
    
    cli::array<unsigned char>* PKCS1::Encrypt_OAEP(System::Security::Cryptography::RSA* rsa, System::Security::Cryptography::HashAlgorithm* hash, System::Security::Cryptography::RandomNumberGenerator* rng, cli::array<unsigned char>* M) {
        int32_t size = (rsa->get_KeySize_6bd474632c551ac() / 8);
        int32_t hLen = (hash->get_HashSize_9f628c7f48e4ff01() / 8);
        if((M->get_Length() > ((size - (2 * hLen)) - 2))) 
        {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("message too long"));
        }
        cli::array<unsigned char> *lHash = GetEmptyHash(hash);
        int32_t PSLength = (((size - M->get_Length()) - (2 * hLen)) - 2);
        cli::array<unsigned char> *DB = (new cli::array<unsigned char>((((lHash->get_Length() + PSLength) + 1) + M->get_Length())));
        System::Buffer::BlockCopy(lHash, 0, DB, 0, lHash->get_Length());
        DB->at((lHash->get_Length() + PSLength)) = 1;
        System::Buffer::BlockCopy(M, 0, DB, (DB->get_Length() - M->get_Length()), M->get_Length());
        cli::array<unsigned char> *seed = (new cli::array<unsigned char>(hLen));
        rng->GetBytes_bf6c3bc1baf70dfd(seed);
        cli::array<unsigned char> *dbMask = MGF1(hash, seed, ((size - hLen) - 1));
        cli::array<unsigned char> *maskedDB = xor_(DB, dbMask);
        cli::array<unsigned char> *seedMask = MGF1(hash, maskedDB, hLen);
        cli::array<unsigned char> *maskedSeed = xor_(seed, seedMask);
        cli::array<unsigned char> *EM = (new cli::array<unsigned char>(((maskedSeed->get_Length() + maskedDB->get_Length()) + 1)));
        System::Buffer::BlockCopy(maskedSeed, 0, EM, 1, maskedSeed->get_Length());
        System::Buffer::BlockCopy(maskedDB, 0, EM, (maskedSeed->get_Length() + 1), maskedDB->get_Length());
        cli::array<unsigned char> *m = OS2IP(EM);
        cli::array<unsigned char> *c = RSAEP(rsa, m);
        return I2OSP2(c, size);
    }
    
    cli::array<unsigned char>* PKCS1::Decrypt_OAEP(System::Security::Cryptography::RSA* rsa, System::Security::Cryptography::HashAlgorithm* hash, cli::array<unsigned char>* C) {
        int32_t size = (rsa->get_KeySize_6bd474632c551ac() / 8);
        int32_t hLen = (hash->get_HashSize_9f628c7f48e4ff01() / 8);
        if(((size < ((2 * hLen) + 2)) || (C->get_Length() != size))) 
        {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("decryption error"));
        }
        cli::array<unsigned char> *c = OS2IP(C);
        cli::array<unsigned char> *m = RSADP(rsa, c);
        cli::array<unsigned char> *EM = I2OSP2(m, size);
        cli::array<unsigned char> *maskedSeed = (new cli::array<unsigned char>(hLen));
        System::Buffer::BlockCopy(EM, 1, maskedSeed, 0, maskedSeed->get_Length());
        cli::array<unsigned char> *maskedDB = (new cli::array<unsigned char>(((size - hLen) - 1)));
        System::Buffer::BlockCopy(EM, (EM->get_Length() - maskedDB->get_Length()), maskedDB, 0, maskedDB->get_Length());
        cli::array<unsigned char> *seedMask = MGF1(hash, maskedDB, hLen);
        cli::array<unsigned char> *seed = xor_(maskedSeed, seedMask);
        cli::array<unsigned char> *dbMask = MGF1(hash, seed, ((size - hLen) - 1));
        cli::array<unsigned char> *DB = xor_(maskedDB, dbMask);
        cli::array<unsigned char> *lHash = GetEmptyHash(hash);
        cli::array<unsigned char> *dbHash = (new cli::array<unsigned char>(lHash->get_Length()));
        System::Buffer::BlockCopy(DB, 0, dbHash, 0, dbHash->get_Length());
        bool h = Compare(lHash, dbHash);
        int32_t nPos = lHash->get_Length();
        while(((int32_t)(DB->at(nPos)) ==  0)) nPos++;
        int32_t Msize = ((DB->get_Length() - nPos) - 1);
        cli::array<unsigned char> *M = (new cli::array<unsigned char>(Msize));
        System::Buffer::BlockCopy(DB, (nPos + 1), M, 0, Msize);
        if(((((int32_t)(EM->at(0)) != 0) || !(h)) || ((int32_t)(DB->at(nPos)) != 1))) 
        {
            return nullptr;
        }
        return M;
    }
    
    cli::array<unsigned char>* PKCS1::Encrypt_v15(System::Security::Cryptography::RSA* rsa, System::Security::Cryptography::RandomNumberGenerator* rng, cli::array<unsigned char>* M) {
        int32_t size = (rsa->get_KeySize_6bd474632c551ac() / 8);
        if((M->get_Length() > (size - 11))) 
        {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("message too long"));
        }
        int32_t PSLength = System::Math::Max5(8, ((size - M->get_Length()) - 3));
        cli::array<unsigned char> *PS = (new cli::array<unsigned char>(PSLength));
        rng->GetNonZeroBytes_eb33fce7e843c67b(PS);
        cli::array<unsigned char> *EM = (new cli::array<unsigned char>(size));
        EM->at(1) = 2;
        System::Buffer::BlockCopy(PS, 0, EM, 2, PSLength);
        System::Buffer::BlockCopy(M, 0, EM, (size - M->get_Length()), M->get_Length());
        cli::array<unsigned char> *m = OS2IP(EM);
        cli::array<unsigned char> *c = RSAEP(rsa, m);
        cli::array<unsigned char> *C = I2OSP2(c, size);
        return C;
    }
    
    cli::array<unsigned char>* PKCS1::Decrypt_v15(System::Security::Cryptography::RSA* rsa, cli::array<unsigned char>* C) {
        int32_t size = (rsa->get_KeySize_6bd474632c551ac() >> 3);
        if(((size < 11) || (C->get_Length() > size))) 
        {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("decryption error"));
        }
        cli::array<unsigned char> *c = OS2IP(C);
        cli::array<unsigned char> *m = RSADP(rsa, c);
        cli::array<unsigned char> *EM = I2OSP2(m, size);
        if((((int32_t)(EM->at(0)) != 0) || ((int32_t)(EM->at(1)) != 2))) 
        {
            return nullptr;
        }
        int32_t mPos = 10;
        while((((int32_t)(EM->at(mPos)) != 0) && (mPos < EM->get_Length()))) mPos++;
        if(((int32_t)(EM->at(mPos)) != 0)) 
        {
            return nullptr;
        }
        mPos++;
        cli::array<unsigned char> *M = (new cli::array<unsigned char>((EM->get_Length() - mPos)));
        System::Buffer::BlockCopy(EM, mPos, M, 0, M->get_Length());
        return M;
    }
    
    cli::array<unsigned char>* PKCS1::Sign_v15(System::Security::Cryptography::RSA* rsa, System::Security::Cryptography::HashAlgorithm* hash, cli::array<unsigned char>* hashValue) {
        int32_t size = (rsa->get_KeySize_6bd474632c551ac() >> 3);
        cli::array<unsigned char> *EM = Encode_v15(hash, hashValue, size);
        cli::array<unsigned char> *m = OS2IP(EM);
        cli::array<unsigned char> *s = RSASP1(rsa, m);
        cli::array<unsigned char> *S = I2OSP2(s, size);
        return S;
    }
    
    bool PKCS1::Verify_v15(System::Security::Cryptography::RSA* rsa, System::Security::Cryptography::HashAlgorithm* hash, cli::array<unsigned char>* hashValue, cli::array<unsigned char>* signature) {
        return Verify_v152(rsa, hash, hashValue, signature, false);
    }
    
    bool PKCS1::Verify_v152(System::Security::Cryptography::RSA* rsa, System::Security::Cryptography::HashAlgorithm* hash, cli::array<unsigned char>* hashValue, cli::array<unsigned char>* signature, bool tryNonStandardEncoding) {
        int32_t size = (rsa->get_KeySize_6bd474632c551ac() >> 3);
        cli::array<unsigned char> *s = OS2IP(signature);
        cli::array<unsigned char> *m = RSAVP1(rsa, s);
        cli::array<unsigned char> *EM2 = I2OSP2(m, size);
        cli::array<unsigned char> *EM = Encode_v15(hash, hashValue, size);
        bool result = Compare(EM, EM2);
        if((result || !(tryNonStandardEncoding))) 
        {
            return result;
        }
        if((((int32_t)(EM2->at(0)) != 0) || ((int32_t)(EM2->at(1)) != 1))) 
        {
            return false;
        }
        int32_t i;
        for(i = 2; (i < ((EM2->get_Length() - hashValue->get_Length()) - 1)); i++){
            if(((int32_t)(EM2->at(i)) != 255)) 
            {
                return false;
            }
        }
        if(((int32_t)(EM2->at(i++)) != 0)) 
        {
            return false;
        }
        cli::array<unsigned char> *decryptedHash = (new cli::array<unsigned char>(hashValue->get_Length()));
        System::Buffer::BlockCopy(EM2, i, decryptedHash, 0, decryptedHash->get_Length());
        return Compare(decryptedHash, hashValue);
    }
    
    cli::array<unsigned char>* PKCS1::Encode_v15(System::Security::Cryptography::HashAlgorithm* hash, cli::array<unsigned char>* hashValue, int32_t emLength) {
        if((hashValue->get_Length() != (hash->get_HashSize_9f628c7f48e4ff01() >> 3))) 
        {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(cli::concat(_T("bad hash length for "), hash->ToString_1636a0751cb9ac11()));
        }
        cli::array<unsigned char> *t = nullptr;
        System::String *oid = System::Security::Cryptography::CryptoConfig::MapNameToOID(hash->ToString_1636a0751cb9ac11());
        if((oid != nullptr)) 
        {
            Mono::Security::ASN1 *digestAlgorithm = cli::gcnew<Mono::Security::ASN1>(48);
            digestAlgorithm->Add(cli::gcnew<Mono::Security::ASN1>(System::Security::Cryptography::CryptoConfig::EncodeOID(oid)));
            digestAlgorithm->Add(cli::gcnew<Mono::Security::ASN1>(5));
            Mono::Security::ASN1 *digest = cli::gcnew<Mono::Security::ASN1>(4, hashValue);
            Mono::Security::ASN1 *digestInfo = cli::gcnew<Mono::Security::ASN1>(48);
            digestInfo->Add(digestAlgorithm);
            digestInfo->Add(digest);
            t = digestInfo->GetBytes_b91405229279a4ac();
        }
         else 
        {
            t = hashValue;
        }
        System::Buffer::BlockCopy(hashValue, 0, t, (t->get_Length() - hashValue->get_Length()), hashValue->get_Length());
        int32_t PSLength = System::Math::Max5(8, ((emLength - t->get_Length()) - 3));
        cli::array<unsigned char> *EM = (new cli::array<unsigned char>(((PSLength + t->get_Length()) + 3)));
        EM->at(1) = 1;
        for(int32_t i = 2; (i < (PSLength + 2)); i++) {
            EM->at(i) = 255;
        }
        System::Buffer::BlockCopy(t, 0, EM, (PSLength + 3), t->get_Length());
        return EM;
    }
    
    cli::array<unsigned char>* PKCS1::MGF1(System::Security::Cryptography::HashAlgorithm* hash, cli::array<unsigned char>* mgfSeed, int32_t maskLen) {
        if((maskLen < 0)) 
        {
            throw cli::gcnew<System::OverflowException>();
        }
        int32_t mgfSeedLength = mgfSeed->get_Length();
        int32_t hLen = (hash->get_HashSize_9f628c7f48e4ff01() >> 3);
        int32_t iterations = (maskLen / hLen);
        if(((maskLen % hLen) != 0)) 
        {
            iterations++;
        }
        cli::array<unsigned char> *T = (new cli::array<unsigned char>((iterations * hLen)));
        cli::array<unsigned char> *toBeHashed = (new cli::array<unsigned char>((mgfSeedLength + 4)));
        int32_t pos = 0;
        for(int32_t counter = 0; (counter < iterations); counter++){
            cli::array<unsigned char> *C = I2OSP(counter, 4);
            System::Buffer::BlockCopy(mgfSeed, 0, toBeHashed, 0, mgfSeedLength);
            System::Buffer::BlockCopy(C, 0, toBeHashed, mgfSeedLength, 4);
            cli::array<unsigned char> *output = hash->ComputeHash(toBeHashed);
            System::Buffer::BlockCopy(output, 0, T, pos, hLen);
            (pos = pos + mgfSeedLength);
        }
        cli::array<unsigned char> *mask = (new cli::array<unsigned char>(maskLen));
        System::Buffer::BlockCopy(T, 0, mask, 0, maskLen);
        return mask;
    }
    
}}}
namespace Mono { namespace Security { namespace Cryptography {
    
    
    void PrivateKeyInfo::constructor() {
        this->_version = 0;
        this->_list = cli::gcnew<System::Collections::ArrayList>();
    }
    
    void PrivateKeyInfo::constructor(cli::array<unsigned char>* data) {
        Decode(data);
    }
    
    void PrivateKeyInfo::Decode(cli::array<unsigned char>* data) {
        Mono::Security::ASN1 *privateKeyInfo = cli::gcnew<Mono::Security::ASN1>(data);
        if(((int32_t)(privateKeyInfo->get_Tag()) != 48)) 
        {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("invalid PrivateKeyInfo"));
        }
        Mono::Security::ASN1 *version = privateKeyInfo->get_Item(0);
        if(((int32_t)(version->get_Tag()) != 2)) 
        {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("invalid version"));
        }
        this->_version = (int32_t)(version->get_Value()->at(0));
        Mono::Security::ASN1 *privateKeyAlgorithm = privateKeyInfo->get_Item(1);
        if(((int32_t)(privateKeyAlgorithm->get_Tag()) != 48)) 
        {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("invalid algorithm"));
        }
        Mono::Security::ASN1 *algorithm = privateKeyAlgorithm->get_Item(0);
        if(((int32_t)(algorithm->get_Tag()) != 6)) 
        {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("missing algorithm OID"));
        }
        this->_algorithm = Mono::Security::ASN1Convert::ToOid(algorithm);
        Mono::Security::ASN1 *privateKey = privateKeyInfo->get_Item(2);
        this->_key = privateKey->get_Value();
        if((privateKeyInfo->get_Count() > 3)) 
        {
            Mono::Security::ASN1 *attributes = privateKeyInfo->get_Item(3);
            for(int32_t i = 0; (i < attributes->get_Count()); i++){
                this->_list->Add_e6a92085999ce388(attributes->get_Item(i));
            }
        }
    }
    
    cli::array<unsigned char>* PrivateKeyInfo::GetBytes() {
        Mono::Security::ASN1 *privateKeyAlgorithm = cli::gcnew<Mono::Security::ASN1>(48);
        privateKeyAlgorithm->Add(Mono::Security::ASN1Convert::FromOid(this->_algorithm));
        privateKeyAlgorithm->Add(cli::gcnew<Mono::Security::ASN1>(5));
        Mono::Security::ASN1 *pki = cli::gcnew<Mono::Security::ASN1>(48);
        pki->Add(cli::gcnew<Mono::Security::ASN1>(2, (new cli::array<unsigned char>({(System::Byte)this->_version}))));
        pki->Add(privateKeyAlgorithm);
        pki->Add(cli::gcnew<Mono::Security::ASN1>(4, this->_key));
        if((this->_list->get_Count_2354963792616712() > 0)) 
        {
            Mono::Security::ASN1 *attributes = cli::gcnew<Mono::Security::ASN1>(160);
            for(auto tmp_79 : this->_list) {
                auto attribute = cli::cast<Mono::Security::ASN1*>(tmp_79);
                {
                    attributes->Add(attribute);
                }
            }
            pki->Add(attributes);
        }
        return pki->GetBytes_b91405229279a4ac();
    }
    
    cli::array<unsigned char>* PrivateKeyInfo::RemoveLeadingZero(cli::array<unsigned char>* bigInt) {
        int32_t start = 0;
        int32_t length = bigInt->get_Length();
        if(((int32_t)(bigInt->at(0)) ==  0)) 
        {
            start = 1;
            length--;
        }
        cli::array<unsigned char> *bi = (new cli::array<unsigned char>(length));
        System::Buffer::BlockCopy(bigInt, start, bi, 0, length);
        return bi;
    }
    
    cli::array<unsigned char>* PrivateKeyInfo::Normalize(cli::array<unsigned char>* bigInt, int32_t length) {
        if((bigInt->get_Length() ==  length)) 
        {
            return bigInt;
        }
         else 
        {
            if((bigInt->get_Length() > length)) 
            {
                return RemoveLeadingZero(bigInt);
            }
             else 
            {
                cli::array<unsigned char> *bi = (new cli::array<unsigned char>(length));
                System::Buffer::BlockCopy(bigInt, 0, bi, (length - bigInt->get_Length()), bigInt->get_Length());
                return bi;
            }
        }
    }
    
    System::Security::Cryptography::RSA* PrivateKeyInfo::DecodeRSA(cli::array<unsigned char>* keypair) {
        Mono::Security::ASN1 *privateKey = cli::gcnew<Mono::Security::ASN1>(keypair);
        if(((int32_t)(privateKey->get_Tag()) != 48)) 
        {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("invalid private key format"));
        }
        Mono::Security::ASN1 *version = privateKey->get_Item(0);
        if(((int32_t)(version->get_Tag()) != 2)) 
        {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("missing version"));
        }
        if((privateKey->get_Count() < 9)) 
        {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("not enough key parameters"));
        }
        System::Security::Cryptography::RSAParameters param = cli::ctor<System::Security::Cryptography::RSAParameters>();
        param->Modulus = RemoveLeadingZero(privateKey->get_Item(1)->get_Value());
        int32_t keysize = param->Modulus->get_Length();
        int32_t keysize2 = (keysize >> 1);
        param->D = Normalize(privateKey->get_Item(3)->get_Value(), keysize);
        param->DP = Normalize(privateKey->get_Item(6)->get_Value(), keysize2);
        param->DQ = Normalize(privateKey->get_Item(7)->get_Value(), keysize2);
        param->Exponent = RemoveLeadingZero(privateKey->get_Item(2)->get_Value());
        param->InverseQ = Normalize(privateKey->get_Item(8)->get_Value(), keysize2);
        param->P = Normalize(privateKey->get_Item(4)->get_Value(), keysize2);
        param->Q = Normalize(privateKey->get_Item(5)->get_Value(), keysize2);
        System::Security::Cryptography::RSA *rsa = nullptr;
        try {
            rsa = System::Security::Cryptography::RSA::Create3();
            rsa->ImportParameters_43620ad65e380dd(param);
        }
        catch(System::Security::Cryptography::CryptographicException*) {
            System::Security::Cryptography::CspParameters *csp = cli::gcnew<System::Security::Cryptography::CspParameters>();
            csp->set_Flags(System::Security::Cryptography::CspProviderFlags::UseMachineKeyStore);
            rsa = cli::gcnew<System::Security::Cryptography::RSACryptoServiceProvider>(csp);
            rsa->ImportParameters_43620ad65e380dd(param);
        }
        return rsa;
    }
    
    cli::array<unsigned char>* PrivateKeyInfo::Encode(System::Security::Cryptography::RSA* rsa) {
        System::Security::Cryptography::RSAParameters param = rsa->ExportParameters_f406cf113d936197(true);
        Mono::Security::ASN1 *rsaPrivateKey = cli::gcnew<Mono::Security::ASN1>(48);
        rsaPrivateKey->Add(cli::gcnew<Mono::Security::ASN1>(2, (new cli::array<unsigned char>({0}))));
        rsaPrivateKey->Add(Mono::Security::ASN1Convert::FromUnsignedBigInteger(param->Modulus));
        rsaPrivateKey->Add(Mono::Security::ASN1Convert::FromUnsignedBigInteger(param->Exponent));
        rsaPrivateKey->Add(Mono::Security::ASN1Convert::FromUnsignedBigInteger(param->D));
        rsaPrivateKey->Add(Mono::Security::ASN1Convert::FromUnsignedBigInteger(param->P));
        rsaPrivateKey->Add(Mono::Security::ASN1Convert::FromUnsignedBigInteger(param->Q));
        rsaPrivateKey->Add(Mono::Security::ASN1Convert::FromUnsignedBigInteger(param->DP));
        rsaPrivateKey->Add(Mono::Security::ASN1Convert::FromUnsignedBigInteger(param->DQ));
        rsaPrivateKey->Add(Mono::Security::ASN1Convert::FromUnsignedBigInteger(param->InverseQ));
        return rsaPrivateKey->GetBytes_b91405229279a4ac();
    }
    
    System::Security::Cryptography::DSA* PrivateKeyInfo::DecodeDSA(cli::array<unsigned char>* privateKey, System::Security::Cryptography::DSAParameters dsaParameters) {
        Mono::Security::ASN1 *pvk = cli::gcnew<Mono::Security::ASN1>(privateKey);
        if(((int32_t)(pvk->get_Tag()) != 2)) 
        {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("invalid private key format"));
        }
        dsaParameters->X = Normalize(pvk->get_Value(), 20);
        System::Security::Cryptography::DSA *dsa = System::Security::Cryptography::DSA::Create3();
        dsa->ImportParameters_42bffe0948290f21(dsaParameters);
        return dsa;
    }
    
    cli::array<unsigned char>* PrivateKeyInfo::Encode2(System::Security::Cryptography::DSA* dsa) {
        System::Security::Cryptography::DSAParameters param = dsa->ExportParameters_c041d0915f31506(true);
        return Mono::Security::ASN1Convert::FromUnsignedBigInteger(param->X)->GetBytes_b91405229279a4ac();
    }
    
    cli::array<unsigned char>* PrivateKeyInfo::Encode3(System::Security::Cryptography::AsymmetricAlgorithm* aa) {
        if(cli::is<System::Security::Cryptography::RSA>(aa)) 
        {
            return Encode(cli::cast<System::Security::Cryptography::RSA*>(aa));
        }
         else 
        {
            if(cli::is<System::Security::Cryptography::DSA>(aa)) 
            {
                return Encode2(cli::cast<System::Security::Cryptography::DSA*>(aa));
            }
             else 
            {
                throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("Unknown asymmetric algorithm {0}"), aa->ToString_1636a0751cb9ac11());
            }
        }
    }
    
    System::String* PrivateKeyInfo::get_Algorithm() {
        return this->_algorithm;
    }
    
    System::String* PrivateKeyInfo::set_Algorithm(System::String* value) {
        this->_algorithm = value;
        return get_Algorithm();
    }
    
    System::Collections::ArrayList* PrivateKeyInfo::get_Attributes() {
        return this->_list;
    }
    
    cli::array<unsigned char>* PrivateKeyInfo::get_PrivateKey() {
        if((this->_key ==  nullptr)) 
        {
            return nullptr;
        }
        return cli::cast<cli::array<unsigned char>*>(cli::import(this->_key)->Clone());
    }
    
    cli::array<unsigned char>* PrivateKeyInfo::set_PrivateKey(cli::array<unsigned char>* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("PrivateKey"));
        }
        this->_key = cli::cast<cli::array<unsigned char>*>(cli::import(value)->Clone());
        return get_PrivateKey();
    }
    
    int32_t PrivateKeyInfo::get_Version() {
        return this->_version;
    }
    
    int32_t PrivateKeyInfo::set_Version(int32_t value) {
        if((value < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("negative version"));
        }
        this->_version = value;
        return get_Version();
    }
    
}}}
namespace Mono { namespace Security { namespace Cryptography {
    
    
    void EncryptedPrivateKeyInfo::constructor() {
    }
    
    void EncryptedPrivateKeyInfo::constructor(cli::array<unsigned char>* data) {
        Decode(data);
    }
    
    void EncryptedPrivateKeyInfo::Decode(cli::array<unsigned char>* data) {
        Mono::Security::ASN1 *encryptedPrivateKeyInfo = cli::gcnew<Mono::Security::ASN1>(data);
        if(((int32_t)(encryptedPrivateKeyInfo->get_Tag()) != 48)) 
        {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("invalid EncryptedPrivateKeyInfo"));
        }
        Mono::Security::ASN1 *encryptionAlgorithm = encryptedPrivateKeyInfo->get_Item(0);
        if(((int32_t)(encryptionAlgorithm->get_Tag()) != 48)) 
        {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("invalid encryptionAlgorithm"));
        }
        Mono::Security::ASN1 *algorithm = encryptionAlgorithm->get_Item(0);
        if(((int32_t)(algorithm->get_Tag()) != 6)) 
        {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("invalid algorithm"));
        }
        this->_algorithm = Mono::Security::ASN1Convert::ToOid(algorithm);
        if((encryptionAlgorithm->get_Count() > 1)) 
        {
            Mono::Security::ASN1 *parameters = encryptionAlgorithm->get_Item(1);
            if(((int32_t)(parameters->get_Tag()) != 48)) 
            {
                throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("invalid parameters"));
            }
            Mono::Security::ASN1 *salt = parameters->get_Item(0);
            if(((int32_t)(salt->get_Tag()) != 4)) 
            {
                throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("invalid salt"));
            }
            this->_salt = salt->get_Value();
            Mono::Security::ASN1 *iterationCount = parameters->get_Item(1);
            if(((int32_t)(iterationCount->get_Tag()) != 2)) 
            {
                throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("invalid iterationCount"));
            }
            this->_iterations = Mono::Security::ASN1Convert::ToInt32(iterationCount);
        }
        Mono::Security::ASN1 *encryptedData = encryptedPrivateKeyInfo->get_Item(1);
        if(((int32_t)(encryptedData->get_Tag()) != 4)) 
        {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("invalid EncryptedData"));
        }
        this->_data = encryptedData->get_Value();
    }
    
    cli::array<unsigned char>* EncryptedPrivateKeyInfo::GetBytes() {
        if((this->_algorithm ==  nullptr)) 
        {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("No algorithm OID specified"));
        }
        Mono::Security::ASN1 *encryptionAlgorithm = cli::gcnew<Mono::Security::ASN1>(48);
        encryptionAlgorithm->Add(Mono::Security::ASN1Convert::FromOid(this->_algorithm));
        if(((this->_iterations > 0) || (this->_salt != nullptr))) 
        {
            Mono::Security::ASN1 *salt = cli::gcnew<Mono::Security::ASN1>(4, this->_salt);
            Mono::Security::ASN1 *iterations = Mono::Security::ASN1Convert::FromInt32(this->_iterations);
            Mono::Security::ASN1 *parameters = cli::gcnew<Mono::Security::ASN1>(48);
            parameters->Add(salt);
            parameters->Add(iterations);
            encryptionAlgorithm->Add(parameters);
        }
        Mono::Security::ASN1 *encryptedData = cli::gcnew<Mono::Security::ASN1>(4, this->_data);
        Mono::Security::ASN1 *encryptedPrivateKeyInfo = cli::gcnew<Mono::Security::ASN1>(48);
        encryptedPrivateKeyInfo->Add(encryptionAlgorithm);
        encryptedPrivateKeyInfo->Add(encryptedData);
        return encryptedPrivateKeyInfo->GetBytes_b91405229279a4ac();
    }
    
    System::String* EncryptedPrivateKeyInfo::get_Algorithm() {
        return this->_algorithm;
    }
    
    System::String* EncryptedPrivateKeyInfo::set_Algorithm(System::String* value) {
        this->_algorithm = value;
        return get_Algorithm();
    }
    
    cli::array<unsigned char>* EncryptedPrivateKeyInfo::get_EncryptedData() {
        return (this->_data ==  nullptr) ? nullptr : cli::cast<cli::array<unsigned char>*>(cli::import(this->_data)->Clone());
    }
    
    cli::array<unsigned char>* EncryptedPrivateKeyInfo::set_EncryptedData(cli::array<unsigned char>* value) {
        this->_data = (value ==  nullptr) ? nullptr : cli::cast<cli::array<unsigned char>*>(cli::import(value)->Clone());
        return get_EncryptedData();
    }
    
    cli::array<unsigned char>* EncryptedPrivateKeyInfo::get_Salt() {
        if((this->_salt ==  nullptr)) 
        {
            System::Security::Cryptography::RandomNumberGenerator *rng = System::Security::Cryptography::RandomNumberGenerator::Create();
            this->_salt = (new cli::array<unsigned char>(8));
            rng->GetBytes_bf6c3bc1baf70dfd(this->_salt);
        }
        return cli::cast<cli::array<unsigned char>*>(cli::import(this->_salt)->Clone());
    }
    
    cli::array<unsigned char>* EncryptedPrivateKeyInfo::set_Salt(cli::array<unsigned char>* value) {
        this->_salt = cli::cast<cli::array<unsigned char>*>(cli::import(value)->Clone());
        return get_Salt();
    }
    
    int32_t EncryptedPrivateKeyInfo::get_IterationCount() {
        return this->_iterations;
    }
    
    int32_t EncryptedPrivateKeyInfo::set_IterationCount(int32_t value) {
        if((value < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("IterationCount"), _T("Negative"));
        }
        this->_iterations = value;
        return get_IterationCount();
    }
    
}}}
namespace Mono { namespace Security { namespace Cryptography {
    
    
    void PKCS8::constructor() {
    }
    
    KeyInfo PKCS8::GetType2(cli::array<unsigned char>* data) {
        if((data ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("data"));
        }
        KeyInfo ki = KeyInfo::Unknown;
        try {
            Mono::Security::ASN1 *top = cli::gcnew<Mono::Security::ASN1>(data);
            if((((int32_t)(top->get_Tag()) ==  48) && (top->get_Count() > 0))) 
            {
                Mono::Security::ASN1 *firstLevel = top->get_Item(0);
                switch(firstLevel->get_Tag()) {
                    case 2: case_390: {
                        ki = KeyInfo::PrivateKey;
                        break;
                    }
                    case 48: case_391: {
                        ki = KeyInfo::EncryptedPrivateKey;
                        break;
                    }
                }
            }
        }
        catch(...) {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("invalid ASN.1 data"));
        }
        return ki;
    }
    
}}}
namespace Mono { namespace Security { namespace Cryptography {
    
    
    void RSAManaged::constructor() {
    }
    
    void RSAManaged::constructor(int32_t keySize) {
        this->LegalKeySizesValue = (new cli::array<System::Security::Cryptography::KeySizes*>(1));
        this->LegalKeySizesValue->at(0) = cli::gcnew<System::Security::Cryptography::KeySizes>(384, 16384, 8);
        System::Security::Cryptography::RSA::set_KeySize_16a33b99cbf5525b(keySize);
    }
    
    void RSAManaged::Finalize_3e5c4b545ea2b716() {
        {
            cli::finally_guard([&]() {
                Finalize_b946fbc32e26afd6();
            });
            System::Security::Cryptography::AsymmetricAlgorithm::Dispose_2369c0ba816a26e4(false);
        }
    }
    
    void RSAManaged::GenerateKeyPair() {
        int32_t pbitlength = ((this->get_KeySize_6bd474632c551ac() + 1) >> 1);
        int32_t qbitlength = (this->get_KeySize_6bd474632c551ac() - pbitlength);
        const uint32_t uint_e = 17;
        this->e = Mono::Math::BigInteger::op_Implicit(17U);
        for(; ; ){
            this->p = Mono::Math::BigInteger::GeneratePseudoPrime(pbitlength);
            if((Mono::Math::BigInteger::op_Modulus2(this->p, 17U) != 1U)) 
            {
                break;
            }
        }
        for(; ; ){
            for(; ; ){
                this->q = Mono::Math::BigInteger::GeneratePseudoPrime(qbitlength);
                if(((Mono::Math::BigInteger::op_Modulus2(this->q, 17U) != 1U) && Mono::Math::BigInteger::op_Inequality2(this->p, this->q))) 
                {
                    break;
                }
            }
            this->n = Mono::Math::BigInteger::op_Multiply(this->p, this->q);
            if((this->n->BitCount() ==  this->get_KeySize_6bd474632c551ac())) 
            {
                break;
            }
            if(Mono::Math::BigInteger::op_LessThan(this->p, this->q)) 
            {
                this->p = this->q;
            }
        }
        Mono::Math::BigInteger *pSub1 = Mono::Math::BigInteger::op_Subtraction(this->p, Mono::Math::BigInteger::op_Implicit2(1));
        Mono::Math::BigInteger *qSub1 = Mono::Math::BigInteger::op_Subtraction(this->q, Mono::Math::BigInteger::op_Implicit2(1));
        Mono::Math::BigInteger *phi = Mono::Math::BigInteger::op_Multiply(pSub1, qSub1);
        this->d = this->e->ModInverse(phi);
        this->dp = Mono::Math::BigInteger::op_Modulus3(this->d, pSub1);
        this->dq = Mono::Math::BigInteger::op_Modulus3(this->d, qSub1);
        this->qInv = this->q->ModInverse(this->p);
        this->keypairGenerated = true;
        this->isCRTpossible = true;
        if((this->KeyGenerated != nullptr)) 
        {
            this->KeyGenerated->Invoke(this, nullptr);
        }
    }
    
    cli::array<unsigned char>* RSAManaged::DecryptValue_e0f03fff133976bf(cli::array<unsigned char>* rgb) {
        if(this->m_disposed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("private key"));
        }
        if(!(this->keypairGenerated)) 
        {
            GenerateKeyPair();
        }
        Mono::Math::BigInteger *input = cli::gcnew<Mono::Math::BigInteger>(rgb);
        Mono::Math::BigInteger *r = nullptr;
        if(this->keyBlinding) 
        {
            r = Mono::Math::BigInteger::GenerateRandom2(this->n->BitCount());
            input = Mono::Math::BigInteger::op_Modulus3(Mono::Math::BigInteger::op_Multiply(r->ModPow(this->e, this->n), input), this->n);
        }
        Mono::Math::BigInteger *output;
        if(this->isCRTpossible) 
        {
            Mono::Math::BigInteger *m1 = input->ModPow(this->dp, this->p);
            Mono::Math::BigInteger *m2 = input->ModPow(this->dq, this->q);
            Mono::Math::BigInteger *h;
            if(Mono::Math::BigInteger::op_GreaterThan(m2, m1)) 
            {
                h = Mono::Math::BigInteger::op_Subtraction(this->p, Mono::Math::BigInteger::op_Modulus3(Mono::Math::BigInteger::op_Multiply(Mono::Math::BigInteger::op_Subtraction(m2, m1), this->qInv), this->p));
                output = Mono::Math::BigInteger::op_Addition(m2, Mono::Math::BigInteger::op_Multiply(this->q, h));
            }
             else 
            {
                h = Mono::Math::BigInteger::op_Modulus3(Mono::Math::BigInteger::op_Multiply(Mono::Math::BigInteger::op_Subtraction(m1, m2), this->qInv), this->p);
                output = Mono::Math::BigInteger::op_Addition(m2, Mono::Math::BigInteger::op_Multiply(this->q, h));
            }
        }
         else 
        {
            if(!(this->get_PublicOnly())) 
            {
                output = input->ModPow(this->d, this->n);
            }
             else 
            {
                throw cli::gcnew<System::Security::Cryptography::CryptographicException>(Locale::GetText(_T("Missing private key to decrypt value.")));
            }
        }
        if(this->keyBlinding) 
        {
            output = Mono::Math::BigInteger::op_Modulus3(Mono::Math::BigInteger::op_Multiply(output, r->ModInverse(this->n)), this->n);
            r->Clear();
        }
        cli::array<unsigned char> *result = GetPaddedValue(output, (this->get_KeySize_6bd474632c551ac() >> 3));
        input->Clear();
        output->Clear();
        return result;
    }
    
    cli::array<unsigned char>* RSAManaged::EncryptValue_16a44acec74209ed(cli::array<unsigned char>* rgb) {
        if(this->m_disposed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("public key"));
        }
        if(!(this->keypairGenerated)) 
        {
            GenerateKeyPair();
        }
        Mono::Math::BigInteger *input = cli::gcnew<Mono::Math::BigInteger>(rgb);
        Mono::Math::BigInteger *output = input->ModPow(this->e, this->n);
        cli::array<unsigned char> *result = GetPaddedValue(output, (this->get_KeySize_6bd474632c551ac() >> 3));
        input->Clear();
        output->Clear();
        return result;
    }
    
    System::Security::Cryptography::RSAParameters RSAManaged::ExportParameters_f406cf113d936197(bool includePrivateParameters) {
        if(this->m_disposed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(Locale::GetText(_T("Keypair was disposed")));
        }
        if(!(this->keypairGenerated)) 
        {
            GenerateKeyPair();
        }
        System::Security::Cryptography::RSAParameters param = cli::ctor<System::Security::Cryptography::RSAParameters>();
        param->Exponent = this->e->GetBytes();
        param->Modulus = this->n->GetBytes();
        if(includePrivateParameters) 
        {
            if(Mono::Math::BigInteger::op_Equality2(this->d, nullptr)) 
            {
                throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("Missing private key"));
            }
            param->D = this->d->GetBytes();
            if((param->D->get_Length() != param->Modulus->get_Length())) 
            {
                cli::array<unsigned char> *normalizedD = (new cli::array<unsigned char>(param->Modulus->get_Length()));
                System::Buffer::BlockCopy(param->D, 0, normalizedD, (normalizedD->get_Length() - param->D->get_Length()), param->D->get_Length());
                param->D = normalizedD;
            }
            if(((((Mono::Math::BigInteger::op_Inequality2(this->p, nullptr) && Mono::Math::BigInteger::op_Inequality2(this->q, nullptr)) && Mono::Math::BigInteger::op_Inequality2(this->dp, nullptr)) && Mono::Math::BigInteger::op_Inequality2(this->dq, nullptr)) && Mono::Math::BigInteger::op_Inequality2(this->qInv, nullptr))) 
            {
                int32_t length = (this->get_KeySize_6bd474632c551ac() >> 4);
                param->P = GetPaddedValue(this->p, length);
                param->Q = GetPaddedValue(this->q, length);
                param->DP = GetPaddedValue(this->dp, length);
                param->DQ = GetPaddedValue(this->dq, length);
                param->InverseQ = GetPaddedValue(this->qInv, length);
            }
        }
        return param;
    }
    
    void RSAManaged::ImportParameters_43620ad65e380dd(System::Security::Cryptography::RSAParameters parameters) {
        if(this->m_disposed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(Locale::GetText(_T("Keypair was disposed")));
        }
        if((parameters->Exponent ==  nullptr)) 
        {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(Locale::GetText(_T("Missing Exponent")));
        }
        if((parameters->Modulus ==  nullptr)) 
        {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(Locale::GetText(_T("Missing Modulus")));
        }
        this->e = cli::gcnew<Mono::Math::BigInteger>(parameters->Exponent);
        this->n = cli::gcnew<Mono::Math::BigInteger>(parameters->Modulus);
        if((parameters->D != nullptr)) 
        {
            this->d = cli::gcnew<Mono::Math::BigInteger>(parameters->D);
        }
        if((parameters->DP != nullptr)) 
        {
            this->dp = cli::gcnew<Mono::Math::BigInteger>(parameters->DP);
        }
        if((parameters->DQ != nullptr)) 
        {
            this->dq = cli::gcnew<Mono::Math::BigInteger>(parameters->DQ);
        }
        if((parameters->InverseQ != nullptr)) 
        {
            this->qInv = cli::gcnew<Mono::Math::BigInteger>(parameters->InverseQ);
        }
        if((parameters->P != nullptr)) 
        {
            this->p = cli::gcnew<Mono::Math::BigInteger>(parameters->P);
        }
        if((parameters->Q != nullptr)) 
        {
            this->q = cli::gcnew<Mono::Math::BigInteger>(parameters->Q);
        }
        this->keypairGenerated = true;
        bool privateKey = ((Mono::Math::BigInteger::op_Inequality2(this->p, nullptr) && Mono::Math::BigInteger::op_Inequality2(this->q, nullptr)) && Mono::Math::BigInteger::op_Inequality2(this->dp, nullptr));
        this->isCRTpossible = ((privateKey && Mono::Math::BigInteger::op_Inequality2(this->dq, nullptr)) && Mono::Math::BigInteger::op_Inequality2(this->qInv, nullptr));
        if(!(privateKey)) 
        {
            return;
        }
        bool ok = Mono::Math::BigInteger::op_Equality2(this->n, Mono::Math::BigInteger::op_Multiply(this->p, this->q));
        if(ok) 
        {
            Mono::Math::BigInteger *pSub1 = Mono::Math::BigInteger::op_Subtraction(this->p, Mono::Math::BigInteger::op_Implicit2(1));
            Mono::Math::BigInteger *qSub1 = Mono::Math::BigInteger::op_Subtraction(this->q, Mono::Math::BigInteger::op_Implicit2(1));
            Mono::Math::BigInteger *phi = Mono::Math::BigInteger::op_Multiply(pSub1, qSub1);
            Mono::Math::BigInteger *dcheck = this->e->ModInverse(phi);
            ok = Mono::Math::BigInteger::op_Equality2(this->d, dcheck);
            if((!(ok) && this->isCRTpossible)) 
            {
                ok = ((Mono::Math::BigInteger::op_Equality2(this->dp, Mono::Math::BigInteger::op_Modulus3(dcheck, pSub1)) && Mono::Math::BigInteger::op_Equality2(this->dq, Mono::Math::BigInteger::op_Modulus3(dcheck, qSub1))) && Mono::Math::BigInteger::op_Equality2(this->qInv, this->q->ModInverse(this->p)));
            }
        }
        if(!(ok)) 
        {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(Locale::GetText(_T("Private/public key mismatch")));
        }
    }
    
    void RSAManaged::Dispose_2369c0ba816a26e4(bool disposing) {
        if(!(this->m_disposed)) 
        {
            if(Mono::Math::BigInteger::op_Inequality2(this->d, nullptr)) 
            {
                this->d->Clear();
                this->d = nullptr;
            }
            if(Mono::Math::BigInteger::op_Inequality2(this->p, nullptr)) 
            {
                this->p->Clear();
                this->p = nullptr;
            }
            if(Mono::Math::BigInteger::op_Inequality2(this->q, nullptr)) 
            {
                this->q->Clear();
                this->q = nullptr;
            }
            if(Mono::Math::BigInteger::op_Inequality2(this->dp, nullptr)) 
            {
                this->dp->Clear();
                this->dp = nullptr;
            }
            if(Mono::Math::BigInteger::op_Inequality2(this->dq, nullptr)) 
            {
                this->dq->Clear();
                this->dq = nullptr;
            }
            if(Mono::Math::BigInteger::op_Inequality2(this->qInv, nullptr)) 
            {
                this->qInv->Clear();
                this->qInv = nullptr;
            }
            if(disposing) 
            {
                if(Mono::Math::BigInteger::op_Inequality2(this->e, nullptr)) 
                {
                    this->e->Clear();
                    this->e = nullptr;
                }
                if(Mono::Math::BigInteger::op_Inequality2(this->n, nullptr)) 
                {
                    this->n->Clear();
                    this->n = nullptr;
                }
            }
        }
        this->m_disposed = true;
    }
    
    System::String* RSAManaged::ToXmlString_681b6b8ae145c576(bool includePrivateParameters) {
        System::Text::StringBuilder *sb = cli::gcnew<System::Text::StringBuilder>();
        System::Security::Cryptography::RSAParameters rsaParams = RSAManaged::ExportParameters_f406cf113d936197(includePrivateParameters);
        try {
            sb->Append2(_T("<RSAKeyValue>"));
            sb->Append2(_T("<Modulus>"));
            sb->Append2(System::Convert::ToBase64String(rsaParams->Modulus));
            sb->Append2(_T("</Modulus>"));
            sb->Append2(_T("<Exponent>"));
            sb->Append2(System::Convert::ToBase64String(rsaParams->Exponent));
            sb->Append2(_T("</Exponent>"));
            if(includePrivateParameters) 
            {
                if((rsaParams->P != nullptr)) 
                {
                    sb->Append2(_T("<P>"));
                    sb->Append2(System::Convert::ToBase64String(rsaParams->P));
                    sb->Append2(_T("</P>"));
                }
                if((rsaParams->Q != nullptr)) 
                {
                    sb->Append2(_T("<Q>"));
                    sb->Append2(System::Convert::ToBase64String(rsaParams->Q));
                    sb->Append2(_T("</Q>"));
                }
                if((rsaParams->DP != nullptr)) 
                {
                    sb->Append2(_T("<DP>"));
                    sb->Append2(System::Convert::ToBase64String(rsaParams->DP));
                    sb->Append2(_T("</DP>"));
                }
                if((rsaParams->DQ != nullptr)) 
                {
                    sb->Append2(_T("<DQ>"));
                    sb->Append2(System::Convert::ToBase64String(rsaParams->DQ));
                    sb->Append2(_T("</DQ>"));
                }
                if((rsaParams->InverseQ != nullptr)) 
                {
                    sb->Append2(_T("<InverseQ>"));
                    sb->Append2(System::Convert::ToBase64String(rsaParams->InverseQ));
                    sb->Append2(_T("</InverseQ>"));
                }
                sb->Append2(_T("<D>"));
                sb->Append2(System::Convert::ToBase64String(rsaParams->D));
                sb->Append2(_T("</D>"));
            }
            sb->Append2(_T("</RSAKeyValue>"));
        }
        catch(...) {
            if((rsaParams->P != nullptr)) 
            {
                System::Array::Clear2(rsaParams->P, 0, rsaParams->P->get_Length());
            }
            if((rsaParams->Q != nullptr)) 
            {
                System::Array::Clear2(rsaParams->Q, 0, rsaParams->Q->get_Length());
            }
            if((rsaParams->DP != nullptr)) 
            {
                System::Array::Clear2(rsaParams->DP, 0, rsaParams->DP->get_Length());
            }
            if((rsaParams->DQ != nullptr)) 
            {
                System::Array::Clear2(rsaParams->DQ, 0, rsaParams->DQ->get_Length());
            }
            if((rsaParams->InverseQ != nullptr)) 
            {
                System::Array::Clear2(rsaParams->InverseQ, 0, rsaParams->InverseQ->get_Length());
            }
            if((rsaParams->D != nullptr)) 
            {
                System::Array::Clear2(rsaParams->D, 0, rsaParams->D->get_Length());
            }
            throw ;
        }
        return sb->ToString_1636a0751cb9ac11();
    }
    
    cli::array<unsigned char>* RSAManaged::GetPaddedValue(Mono::Math::BigInteger* value, int32_t length) {
        cli::array<unsigned char> *result = value->GetBytes();
        if((result->get_Length() >= length)) 
        {
            return result;
        }
        cli::array<unsigned char> *padded = (new cli::array<unsigned char>(length));
        System::Buffer::BlockCopy(result, 0, padded, (length - result->get_Length()), result->get_Length());
        System::Array::Clear2(result, 0, result->get_Length());
        return padded;
    }
    
    int32_t RSAManaged::get_KeySize_6bd474632c551ac() {
        if(this->keypairGenerated) 
        {
            int32_t ks = this->n->BitCount();
            if(((ks & 7) != 0)) 
            {
                ks = (ks + (8 - (ks & 7)));
            }
            return ks;
        }
         else 
        {
            return System::Security::Cryptography::RSA::get_KeySize_6bd474632c551ac();
        }
    }
    
    System::String* RSAManaged::get_KeyExchangeAlgorithm_e4956689b1767b62() {
        return _T("RSA-PKCS1-KeyEx");
    }
    
    bool RSAManaged::get_PublicOnly() {
        return (this->keypairGenerated && (Mono::Math::BigInteger::op_Equality2(this->d, nullptr) || Mono::Math::BigInteger::op_Equality2(this->n, nullptr)));
    }
    
    System::String* RSAManaged::get_SignatureAlgorithm_94f2ebe82aebde31() {
        return _T("http://www.w3.org/2000/09/xmldsig#rsa-sha1");
    }
    
    bool RSAManaged::get_UseKeyBlinding() {
        return this->keyBlinding;
    }
    
    bool RSAManaged::set_UseKeyBlinding(bool value) {
        this->keyBlinding = value;
        return get_UseKeyBlinding();
    }
    
    bool RSAManaged::get_IsCrtPossible() {
        return (!(this->keypairGenerated) || this->isCRTpossible);
    }
    
    void RSAManaged::add_KeyGenerated(KeyGeneratedEventHandler2* value) {
      // TODO: "Implement automatic events!"
    }
    
    void RSAManaged::remove_KeyGenerated(KeyGeneratedEventHandler2* value) {
      // TODO: "Implement automatic events!"
    }
    
}}}
namespace Mono { namespace Security { namespace Cryptography {
    
    
    void SymmetricTransform::constructor(System::Security::Cryptography::SymmetricAlgorithm* symmAlgo, bool encryption, cli::array<unsigned char>* rgbIV) {
        this->algo = symmAlgo;
        this->encrypt = encryption;
        this->BlockSizeByte = (this->algo->get_BlockSize_7a5a96e8187bef27() >> 3);
        if((rgbIV ==  nullptr)) 
        {
            rgbIV = KeyBuilder::IV(this->BlockSizeByte);
        }
         else 
        {
            rgbIV = cli::cast<cli::array<unsigned char>*>(cli::import(rgbIV)->Clone());
        }
        if((rgbIV->get_Length() < this->BlockSizeByte)) 
        {
            System::String *msg = Locale::GetText2(_T("IV is too small ({0} bytes), it should be {1} bytes long."), (new cli::array<System::Object*>({cli::box(rgbIV->get_Length()), cli::box(this->BlockSizeByte)})));
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(msg);
        }
        this->temp = (new cli::array<unsigned char>(this->BlockSizeByte));
        System::Buffer::BlockCopy(rgbIV, 0, this->temp, 0, System::Math::Min5(this->BlockSizeByte, rgbIV->get_Length()));
        this->temp2 = (new cli::array<unsigned char>(this->BlockSizeByte));
        this->FeedBackByte = (this->algo->get_FeedbackSize_fac329115f28c49a() >> 3);
        if((this->FeedBackByte != 0)) 
        {
            this->FeedBackIter = ((int32_t)(this->BlockSizeByte) / this->FeedBackByte);
        }
        this->workBuff = (new cli::array<unsigned char>(this->BlockSizeByte));
        this->workout = (new cli::array<unsigned char>(this->BlockSizeByte));
    }
    
    void SymmetricTransform::Finalize_6cd8b3965c03e7ad() {
        {
            cli::finally_guard([&]() {
                Finalize_b946fbc32e26afd6();
            });
            Dispose_c0fd0d8ff386db0d(false);
        }
    }
    
    void SymmetricTransform::Dispose() {
        Dispose_c0fd0d8ff386db0d(true);
        System::GC::SuppressFinalize(this);
    }
    
    void SymmetricTransform::Dispose_c0fd0d8ff386db0d(bool disposing) {
        if(!(this->m_disposed)) 
        {
            if(disposing) 
            {
                System::Array::Clear2(this->temp, 0, this->BlockSizeByte);
                this->temp = nullptr;
                System::Array::Clear2(this->temp2, 0, this->BlockSizeByte);
                this->temp2 = nullptr;
            }
            this->m_disposed = true;
        }
    }
    
    void SymmetricTransform::Transform_62e95237619eb355(cli::array<unsigned char>* input, cli::array<unsigned char>* output) {
        switch(this->algo->get_Mode_248883f5619349b8()) {
            case System::Security::Cryptography::CipherMode::ECB: case_392: {
                ECB_94d714c69347f447(input, output);
                break;
            }
            case System::Security::Cryptography::CipherMode::CBC: case_393: {
                CBC_58d409ffea331cd7(input, output);
                break;
            }
            case System::Security::Cryptography::CipherMode::CFB: case_394: {
                CFB_77060e157a789d8(input, output);
                break;
            }
            case System::Security::Cryptography::CipherMode::OFB: case_395: {
                OFB_b1a409b313d2f57e(input, output);
                break;
            }
            case System::Security::Cryptography::CipherMode::CTS: case_396: {
                CTS_f5f5f34419061f62(input, output);
                break;
            }
            default: case_397: {
                throw cli::gcnew<System::NotImplementedException>(cli::concat(_T("Unkown CipherMode"), cli::import(this->algo->get_Mode_248883f5619349b8())->ToString_1636a0751cb9ac11()));
            }
        }
    }
    
    void SymmetricTransform::CBC_58d409ffea331cd7(cli::array<unsigned char>* input, cli::array<unsigned char>* output) {
        if(this->encrypt) 
        {
            for(int32_t i = 0; (i < this->BlockSizeByte); i++) {
                (this->temp->at(i) = (unsigned char)((int32_t)(this->temp->at(i)) ^ (int32_t)(input->at(i))));
            }
            ECB_94d714c69347f447(this->temp, output);
            System::Buffer::BlockCopy(output, 0, this->temp, 0, this->BlockSizeByte);
        }
         else 
        {
            System::Buffer::BlockCopy(input, 0, this->temp2, 0, this->BlockSizeByte);
            ECB_94d714c69347f447(input, output);
            for(int32_t i = 0; (i < this->BlockSizeByte); i++) {
                (output->at(i) = (unsigned char)((int32_t)(output->at(i)) ^ (int32_t)(this->temp->at(i))));
            }
            System::Buffer::BlockCopy(this->temp2, 0, this->temp, 0, this->BlockSizeByte);
        }
    }
    
    void SymmetricTransform::CFB_77060e157a789d8(cli::array<unsigned char>* input, cli::array<unsigned char>* output) {
        if(this->encrypt) 
        {
            for(int32_t x = 0; (x < this->FeedBackIter); x++){
                ECB_94d714c69347f447(this->temp, this->temp2);
                for(int32_t i = 0; (i < this->FeedBackByte); i++) {
                    output->at((i + x)) = (unsigned char)((int32_t)(this->temp2->at(i)) ^ (int32_t)(input->at((i + x))));
                }
                System::Buffer::BlockCopy(this->temp, this->FeedBackByte, this->temp, 0, (this->BlockSizeByte - this->FeedBackByte));
                System::Buffer::BlockCopy(output, x, this->temp, (this->BlockSizeByte - this->FeedBackByte), this->FeedBackByte);
            }
        }
         else 
        {
            for(int32_t x = 0; (x < this->FeedBackIter); x++){
                this->encrypt = true;
                ECB_94d714c69347f447(this->temp, this->temp2);
                this->encrypt = false;
                System::Buffer::BlockCopy(this->temp, this->FeedBackByte, this->temp, 0, (this->BlockSizeByte - this->FeedBackByte));
                System::Buffer::BlockCopy(input, x, this->temp, (this->BlockSizeByte - this->FeedBackByte), this->FeedBackByte);
                for(int32_t i = 0; (i < this->FeedBackByte); i++) {
                    output->at((i + x)) = (unsigned char)((int32_t)(this->temp2->at(i)) ^ (int32_t)(input->at((i + x))));
                }
            }
        }
    }
    
    void SymmetricTransform::OFB_b1a409b313d2f57e(cli::array<unsigned char>* input, cli::array<unsigned char>* output) {
        throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("OFB isn\'t supported by the framework"));
    }
    
    void SymmetricTransform::CTS_f5f5f34419061f62(cli::array<unsigned char>* input, cli::array<unsigned char>* output) {
        throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("CTS isn\'t supported by the framework"));
    }
    
    void SymmetricTransform::CheckInput(cli::array<unsigned char>* inputBuffer, int32_t inputOffset, int32_t inputCount) {
        if((inputBuffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("inputBuffer"));
        }
        if((inputOffset < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("inputOffset"), _T("< 0"));
        }
        if((inputCount < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("inputCount"), _T("< 0"));
        }
        if((inputOffset > (inputBuffer->get_Length() - inputCount))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("inputBuffer"), Locale::GetText(_T("Overflow")));
        }
    }
    
    int32_t SymmetricTransform::TransformBlock_ae7940e12ac19b2d(cli::array<unsigned char>* inputBuffer, int32_t inputOffset, int32_t inputCount, cli::array<unsigned char>* outputBuffer, int32_t outputOffset) {
        if(this->m_disposed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("Object is disposed"));
        }
        CheckInput(inputBuffer, inputOffset, inputCount);
        if((outputBuffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("outputBuffer"));
        }
        if((outputOffset < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("outputOffset"), _T("< 0"));
        }
        int32_t len = ((outputBuffer->get_Length() - inputCount) - outputOffset);
        if(((!(this->encrypt) && (0 > len)) && (((int32_t)(this->algo->get_Padding_4e1745ee57afb026()) ==  1) || ((int32_t)(this->algo->get_Padding_4e1745ee57afb026()) ==  3)))) 
        {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("outputBuffer"), Locale::GetText(_T("Overflow")));
        }
         else 
        {
            if(this->get_KeepLastBlock()) 
            {
                if((0 > (len + this->BlockSizeByte))) 
                {
                    throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("outputBuffer"), Locale::GetText(_T("Overflow")));
                }
            }
             else 
            {
                if((0 > len)) 
                {
                    if((((inputBuffer->get_Length() - inputOffset) - outputBuffer->get_Length()) ==  this->BlockSizeByte)) 
                    {
                        inputCount = (outputBuffer->get_Length() - outputOffset);
                    }
                     else 
                    {
                        throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("outputBuffer"), Locale::GetText(_T("Overflow")));
                    }
                }
            }
        }
        return InternalTransformBlock(inputBuffer, inputOffset, inputCount, outputBuffer, outputOffset);
    }
    
    int32_t SymmetricTransform::InternalTransformBlock(cli::array<unsigned char>* inputBuffer, int32_t inputOffset, int32_t inputCount, cli::array<unsigned char>* outputBuffer, int32_t outputOffset) {
        int32_t offs = inputOffset;
        int32_t full;
        if((inputCount != this->BlockSizeByte)) 
        {
            if(((inputCount % this->BlockSizeByte) != 0)) 
            {
                throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("Invalid input block size."));
            }
            full = (inputCount / this->BlockSizeByte);
        }
         else 
        {
            full = 1;
        }
        if(this->get_KeepLastBlock()) 
        {
            full--;
        }
        int32_t total = 0;
        if(this->lastBlock) 
        {
            Transform_62e95237619eb355(this->workBuff, this->workout);
            System::Buffer::BlockCopy(this->workout, 0, outputBuffer, outputOffset, this->BlockSizeByte);
            (outputOffset = outputOffset + this->BlockSizeByte);
            (total = total + this->BlockSizeByte);
            this->lastBlock = false;
        }
        for(int32_t i = 0; (i < full); i++){
            System::Buffer::BlockCopy(inputBuffer, offs, this->workBuff, 0, this->BlockSizeByte);
            Transform_62e95237619eb355(this->workBuff, this->workout);
            System::Buffer::BlockCopy(this->workout, 0, outputBuffer, outputOffset, this->BlockSizeByte);
            (offs = offs + this->BlockSizeByte);
            (outputOffset = outputOffset + this->BlockSizeByte);
            (total = total + this->BlockSizeByte);
        }
        if(this->get_KeepLastBlock()) 
        {
            System::Buffer::BlockCopy(inputBuffer, offs, this->workBuff, 0, this->BlockSizeByte);
            this->lastBlock = true;
        }
        return total;
    }
    
    void SymmetricTransform::Random2(cli::array<unsigned char>* buffer, int32_t start, int32_t length) {
        if((this->_rng ==  nullptr)) 
        {
            this->_rng = System::Security::Cryptography::RandomNumberGenerator::Create();
        }
        cli::array<unsigned char> *random = (new cli::array<unsigned char>(length));
        this->_rng->GetBytes_bf6c3bc1baf70dfd(random);
        System::Buffer::BlockCopy(random, 0, buffer, start, length);
    }
    
    void SymmetricTransform::ThrowBadPaddingException(System::Security::Cryptography::PaddingMode padding, int32_t length, int32_t position) {
        System::String *msg = System::String::Format2(Locale::GetText(_T("Bad {0} padding.")), cli::box(padding));
        if((length >= 0)) 
        {
            (msg = cli::concat(msg, System::String::Format2(Locale::GetText(_T(" Invalid length {0}.")), cli::box(length))));
        }
        if((position >= 0)) 
        {
            (msg = cli::concat(msg, System::String::Format2(Locale::GetText(_T(" Error found at position {0}.")), cli::box(position))));
        }
        throw cli::gcnew<System::Security::Cryptography::CryptographicException>(msg);
    }
    
    cli::array<unsigned char>* SymmetricTransform::FinalEncrypt(cli::array<unsigned char>* inputBuffer, int32_t inputOffset, int32_t inputCount) {
        int32_t full = ((inputCount / this->BlockSizeByte) * this->BlockSizeByte);
        int32_t rem = (inputCount - full);
        int32_t total = full;
        switch(this->algo->get_Padding_4e1745ee57afb026()) {
            case System::Security::Cryptography::PaddingMode::ANSIX923: case System::Security::Cryptography::PaddingMode::ISO10126: case System::Security::Cryptography::PaddingMode::PKCS72: case_398: {
                (total = total + this->BlockSizeByte);
                break;
            }
            default: case_399: {
                if((inputCount ==  0)) 
                {
                    return (new cli::array<unsigned char>(0));
                }
                if((rem != 0)) 
                {
                    if(((int32_t)(this->algo->get_Padding_4e1745ee57afb026()) ==  1)) 
                    {
                        throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("invalid block length"));
                    }
                    cli::array<unsigned char> *paddedInput = (new cli::array<unsigned char>((full + this->BlockSizeByte)));
                    System::Buffer::BlockCopy(inputBuffer, inputOffset, paddedInput, 0, inputCount);
                    inputBuffer = paddedInput;
                    inputOffset = 0;
                    inputCount = paddedInput->get_Length();
                    total = inputCount;
                }
                break;
            }
        }
        cli::array<unsigned char> *res = (new cli::array<unsigned char>(total));
        int32_t outputOffset = 0;
        while((total > this->BlockSizeByte)) {
            InternalTransformBlock(inputBuffer, inputOffset, this->BlockSizeByte, res, outputOffset);
            (inputOffset = inputOffset + this->BlockSizeByte);
            (outputOffset = outputOffset + this->BlockSizeByte);
            (total = total - this->BlockSizeByte);
        }
        unsigned char padding = (unsigned char)(this->BlockSizeByte - rem);
        switch(this->algo->get_Padding_4e1745ee57afb026()) {
            case System::Security::Cryptography::PaddingMode::ANSIX923: case_400: {
                res->at((res->get_Length() - 1)) = padding;
                System::Buffer::BlockCopy(inputBuffer, inputOffset, res, full, rem);
                InternalTransformBlock(res, full, this->BlockSizeByte, res, full);
                break;
            }
            case System::Security::Cryptography::PaddingMode::ISO10126: case_401: {
                Random2(res, (res->get_Length() - (int32_t)(padding)), ((int32_t)(padding) - 1));
                res->at((res->get_Length() - 1)) = padding;
                System::Buffer::BlockCopy(inputBuffer, inputOffset, res, full, rem);
                InternalTransformBlock(res, full, this->BlockSizeByte, res, full);
                break;
            }
            case System::Security::Cryptography::PaddingMode::PKCS72: case_402: {
                for(int32_t i = res->get_Length(); (--i >= (res->get_Length() - (int32_t)(padding))); ) {
                    res->at(i) = padding;
                }
                System::Buffer::BlockCopy(inputBuffer, inputOffset, res, full, rem);
                InternalTransformBlock(res, full, this->BlockSizeByte, res, full);
                break;
            }
            default: case_403: {
                InternalTransformBlock(inputBuffer, inputOffset, this->BlockSizeByte, res, outputOffset);
                break;
            }
        }
        return res;
    }
    
    cli::array<unsigned char>* SymmetricTransform::FinalDecrypt(cli::array<unsigned char>* inputBuffer, int32_t inputOffset, int32_t inputCount) {
        if(((inputCount % this->BlockSizeByte) > 0)) 
        {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("Invalid input block size."));
        }
        int32_t total = inputCount;
        if(this->lastBlock) 
        {
            (total = total + this->BlockSizeByte);
        }
        cli::array<unsigned char> *res = (new cli::array<unsigned char>(total));
        int32_t outputOffset = 0;
        while((inputCount > 0)) {
            int32_t len = InternalTransformBlock(inputBuffer, inputOffset, this->BlockSizeByte, res, outputOffset);
            (inputOffset = inputOffset + this->BlockSizeByte);
            (outputOffset = outputOffset + len);
            (inputCount = inputCount - this->BlockSizeByte);
        }
        if(this->lastBlock) 
        {
            Transform_62e95237619eb355(this->workBuff, this->workout);
            System::Buffer::BlockCopy(this->workout, 0, res, outputOffset, this->BlockSizeByte);
            (outputOffset = outputOffset + this->BlockSizeByte);
            this->lastBlock = false;
        }
        unsigned char padding = (total > 0) ? res->at((total - 1)) : 0;
        switch(this->algo->get_Padding_4e1745ee57afb026()) {
            case System::Security::Cryptography::PaddingMode::ANSIX923: case_404: {
                if((((int32_t)(padding) ==  0) || ((int32_t)(padding) > this->BlockSizeByte))) 
                {
                    ThrowBadPaddingException(this->algo->get_Padding_4e1745ee57afb026(), (int32_t)(padding), -1);
                }
                for(int32_t i = ((int32_t)(padding) - 1); (i > 0); i--){
                    if(((int32_t)(res->at(((total - 1) - i))) != 0)) 
                    {
                        ThrowBadPaddingException(this->algo->get_Padding_4e1745ee57afb026(), -1, i);
                    }
                }
                (total = total - (int32_t)(padding));
                break;
            }
            case System::Security::Cryptography::PaddingMode::ISO10126: case_405: {
                if((((int32_t)(padding) ==  0) || ((int32_t)(padding) > this->BlockSizeByte))) 
                {
                    ThrowBadPaddingException(this->algo->get_Padding_4e1745ee57afb026(), (int32_t)(padding), -1);
                }
                (total = total - (int32_t)(padding));
                break;
            }
            case System::Security::Cryptography::PaddingMode::PKCS72: case_406: {
                if((((int32_t)(padding) ==  0) || ((int32_t)(padding) > this->BlockSizeByte))) 
                {
                    ThrowBadPaddingException(this->algo->get_Padding_4e1745ee57afb026(), (int32_t)(padding), -1);
                }
                for(int32_t i = ((int32_t)(padding) - 1); (i > 0); i--){
                    if(((int32_t)(res->at(((total - 1) - i))) != (int32_t)(padding))) 
                    {
                        ThrowBadPaddingException(this->algo->get_Padding_4e1745ee57afb026(), -1, i);
                    }
                }
                (total = total - (int32_t)(padding));
                break;
            }
            case System::Security::Cryptography::PaddingMode::None: case System::Security::Cryptography::PaddingMode::Zeros: case_407: {
                break;
            }
        }
        if((total > 0)) 
        {
            cli::array<unsigned char> *data = (new cli::array<unsigned char>(total));
            System::Buffer::BlockCopy(res, 0, data, 0, total);
            System::Array::Clear2(res, 0, res->get_Length());
            return data;
        }
         else 
        {
            return (new cli::array<unsigned char>(0));
        }
    }
    
    cli::array<unsigned char>* SymmetricTransform::TransformFinalBlock_b50acf58c03aba0a(cli::array<unsigned char>* inputBuffer, int32_t inputOffset, int32_t inputCount) {
        if(this->m_disposed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("Object is disposed"));
        }
        CheckInput(inputBuffer, inputOffset, inputCount);
        if(this->encrypt) 
        {
            return FinalEncrypt(inputBuffer, inputOffset, inputCount);
        }
         else 
        {
            return FinalDecrypt(inputBuffer, inputOffset, inputCount);
        }
    }
    
    bool SymmetricTransform::get_CanTransformMultipleBlocks_6ab5f7b44ce018f3() {
        return true;
    }
    
    bool SymmetricTransform::get_CanReuseTransform_dc6193f5d984ad67() {
        return false;
    }
    
    int32_t SymmetricTransform::get_InputBlockSize_ffe7482408103da5() {
        return this->BlockSizeByte;
    }
    
    int32_t SymmetricTransform::get_OutputBlockSize_97555d7a856ef43b() {
        return this->BlockSizeByte;
    }
    
    bool SymmetricTransform::get_KeepLastBlock() {
        return ((!(this->encrypt) && ((int32_t)(this->algo->get_Padding_4e1745ee57afb026()) != 1)) && ((int32_t)(this->algo->get_Padding_4e1745ee57afb026()) != 3));
    }
    
}}}
namespace Mono { namespace Security { namespace X509 {
    
    
    void PKCS5::constructor() {
    }
    
}}}
namespace Mono { namespace Security { namespace X509 {
    
    
    void PKCS9::constructor() {
    }
    
}}}
namespace Mono { namespace Security { namespace X509 {
    
    
    void SafeBag::constructor(System::String* bagOID, Mono::Security::ASN1* asn1) {
        this->_bagOID = bagOID;
        this->_asn1 = asn1;
    }
    
    System::String* SafeBag::get_BagOID() {
        return this->_bagOID;
    }
    
    Mono::Security::ASN1* SafeBag::get_ASN1() {
        return this->_asn1;
    }
    
}}}
namespace Mono { namespace Security { namespace X509 {
    
    cli::array<unsigned char>*  DeriveBytes::keyDiversifier;
    cli::array<unsigned char>*  DeriveBytes::ivDiversifier;
    cli::array<unsigned char>*  DeriveBytes::macDiversifier;
    
    DeriveBytes::DeriveBytes()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void DeriveBytes::constructor() {
    }
    
    void DeriveBytes::static_constructor() {
    }
    
    void DeriveBytes::Adjust(cli::array<unsigned char>* a, int32_t aOff, cli::array<unsigned char>* b) {
        int32_t x = ((((int32_t)(b->at((b->get_Length() - 1))) & 255) + ((int32_t)(a->at(((aOff + b->get_Length()) - 1))) & 255)) + 1);
        a->at(((aOff + b->get_Length()) - 1)) = (unsigned char)x;
        (x = x >> 8);
        for(int32_t i = (b->get_Length() - 2); (i >= 0); i--){
            (x = x + (((int32_t)(b->at(i)) & 255) + ((int32_t)(a->at((aOff + i))) & 255)));
            a->at((aOff + i)) = (unsigned char)x;
            (x = x >> 8);
        }
    }
    
    cli::array<unsigned char>* DeriveBytes::Derive(cli::array<unsigned char>* diversifier, int32_t n) {
        System::Security::Cryptography::HashAlgorithm *digest = System::Security::Cryptography::HashAlgorithm::Create2(this->_hashName);
        int32_t u = (digest->get_HashSize_9f628c7f48e4ff01() >> 3);
        int32_t v = 64;
        cli::array<unsigned char> *dKey = (new cli::array<unsigned char>(n));
        cli::array<unsigned char> *S;
        if(((this->_salt != nullptr) && (this->_salt->get_Length() != 0))) 
        {
            S = (new cli::array<unsigned char>((v * (((this->_salt->get_Length() + v) - 1) / v))));
            for(int32_t i = 0; (i != S->get_Length()); i++){
                S->at(i) = this->_salt->at((i % this->_salt->get_Length()));
            }
        }
         else 
        {
            S = (new cli::array<unsigned char>(0));
        }
        cli::array<unsigned char> *P;
        if(((this->_password != nullptr) && (this->_password->get_Length() != 0))) 
        {
            P = (new cli::array<unsigned char>((v * (((this->_password->get_Length() + v) - 1) / v))));
            for(int32_t i = 0; (i != P->get_Length()); i++){
                P->at(i) = this->_password->at((i % this->_password->get_Length()));
            }
        }
         else 
        {
            P = (new cli::array<unsigned char>(0));
        }
        cli::array<unsigned char> *I = (new cli::array<unsigned char>((S->get_Length() + P->get_Length())));
        System::Buffer::BlockCopy(S, 0, I, 0, S->get_Length());
        System::Buffer::BlockCopy(P, 0, I, S->get_Length(), P->get_Length());
        cli::array<unsigned char> *B = (new cli::array<unsigned char>(v));
        int32_t c = (((n + u) - 1) / u);
        for(int32_t i = 1; (i <= c); i++){
            digest->TransformBlock(diversifier, 0, diversifier->get_Length(), diversifier, 0);
            digest->TransformFinalBlock(I, 0, I->get_Length());
            cli::array<unsigned char> *A = digest->get_Hash_cb65a3f211aa16df();
            digest->Initialize_4bdfe3e821ea432();
            for(int32_t j = 1; (j != this->_iterations); j++){
                A = digest->ComputeHash2(A, 0, A->get_Length());
            }
            for(int32_t j = 0; (j != B->get_Length()); j++){
                B->at(j) = A->at((j % A->get_Length()));
            }
            for(int32_t j = 0; (j != (I->get_Length() / v)); j++){
                Adjust(I, (j * v), B);
            }
            if((i ==  c)) 
            {
                System::Buffer::BlockCopy(A, 0, dKey, ((i - 1) * u), (dKey->get_Length() - ((i - 1) * u)));
            }
             else 
            {
                System::Buffer::BlockCopy(A, 0, dKey, ((i - 1) * u), A->get_Length());
            }
        }
        return dKey;
    }
    
    cli::array<unsigned char>* DeriveBytes::DeriveKey(int32_t size) {
        return Derive(keyDiversifier, size);
    }
    
    cli::array<unsigned char>* DeriveBytes::DeriveIV(int32_t size) {
        return Derive(ivDiversifier, size);
    }
    
    cli::array<unsigned char>* DeriveBytes::DeriveMAC(int32_t size) {
        return Derive(macDiversifier, size);
    }
    
    System::String* DeriveBytes::get_HashName() {
        return this->_hashName;
    }
    
    System::String* DeriveBytes::set_HashName(System::String* value) {
        this->_hashName = value;
        return get_HashName();
    }
    
    int32_t DeriveBytes::get_IterationCount() {
        return this->_iterations;
    }
    
    int32_t DeriveBytes::set_IterationCount(int32_t value) {
        this->_iterations = value;
        return get_IterationCount();
    }
    
    cli::array<unsigned char>* DeriveBytes::get_Password() {
        return cli::cast<cli::array<unsigned char>*>(cli::import(this->_password)->Clone());
    }
    
    cli::array<unsigned char>* DeriveBytes::set_Password(cli::array<unsigned char>* value) {
        if((value ==  nullptr)) 
        {
            this->_password = (new cli::array<unsigned char>(0));
        }
         else 
        {
            this->_password = cli::cast<cli::array<unsigned char>*>(cli::import(value)->Clone());
        }
        return get_Password();
    }
    
    cli::array<unsigned char>* DeriveBytes::get_Salt() {
        return cli::cast<cli::array<unsigned char>*>(cli::import(this->_salt)->Clone());
    }
    
    cli::array<unsigned char>* DeriveBytes::set_Salt(cli::array<unsigned char>* value) {
        if((value != nullptr)) 
        {
            this->_salt = cli::cast<cli::array<unsigned char>*>(cli::import(value)->Clone());
        }
         else 
        {
            this->_salt = nullptr;
        }
        return get_Salt();
    }
    
}}}
namespace Mono { namespace Security { namespace X509 {
    
    int32_t  PKCS12::recommendedIterationCount;
    int32_t  PKCS12::password_max_length;
    System::Collections::Generic::Dictionary<System::String*, int32_t>*  PKCS12::__f__switch_map4;
    
    PKCS12::PKCS12()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void PKCS12::constructor() {
        this->_iterations = recommendedIterationCount;
        this->_keyBags = cli::gcnew<System::Collections::ArrayList>();
        this->_secretBags = cli::gcnew<System::Collections::ArrayList>();
        this->_certs = cli::gcnew<X509CertificateCollection>();
        this->_keyBagsChanged = false;
        this->_secretBagsChanged = false;
        this->_certsChanged = false;
        this->_safeBags = cli::gcnew<System::Collections::ArrayList>();
    }
    
    void PKCS12::constructor(cli::array<unsigned char>* data) {
        this->set_Password(nullptr);
        Decode(data);
    }
    
    void PKCS12::constructor(cli::array<unsigned char>* data, System::String* password) {
        this->set_Password(password);
        Decode(data);
    }
    
    void PKCS12::constructor(cli::array<unsigned char>* data, cli::array<unsigned char>* password) {
        this->_password = password;
        Decode(data);
    }
    
    void PKCS12::static_constructor() {
    }
    
    void PKCS12::Finalize_f05b2c1a942579d3() {
        {
            cli::finally_guard([&]() {
                Finalize_b946fbc32e26afd6();
            });
            if((this->_password != nullptr)) 
            {
                System::Array::Clear2(this->_password, 0, this->_password->get_Length());
            }
            this->_password = nullptr;
        }
    }
    
    void PKCS12::Decode(cli::array<unsigned char>* data) {
        Mono::Security::ASN1 *pfx = cli::gcnew<Mono::Security::ASN1>(data);
        if(((int32_t)(pfx->get_Tag()) != 48)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("invalid data"));
        }
        Mono::Security::ASN1 *version = pfx->get_Item(0);
        if(((int32_t)(version->get_Tag()) != 2)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("invalid PFX version"));
        }
        Mono::Security::ContentInfo *authSafe = cli::gcnew<Mono::Security::ContentInfo>(pfx->get_Item(1));
        if(System::String::op_Inequality(authSafe->get_ContentType(), _T("1.2.840.113549.1.7.1"))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("invalid authenticated safe"));
        }
        if((pfx->get_Count() > 2)) 
        {
            Mono::Security::ASN1 *macData = pfx->get_Item(2);
            if(((int32_t)(macData->get_Tag()) != 48)) 
            {
                throw cli::gcnew<System::ArgumentException>(_T("invalid MAC"));
            }
            Mono::Security::ASN1 *mac = macData->get_Item(0);
            if(((int32_t)(mac->get_Tag()) != 48)) 
            {
                throw cli::gcnew<System::ArgumentException>(_T("invalid MAC"));
            }
            Mono::Security::ASN1 *macAlgorithm = mac->get_Item(0);
            System::String *macOid = Mono::Security::ASN1Convert::ToOid(macAlgorithm->get_Item(0));
            if(System::String::op_Inequality(macOid, _T("1.3.14.3.2.26"))) 
            {
                throw cli::gcnew<System::ArgumentException>(_T("unsupported HMAC"));
            }
            cli::array<unsigned char> *macValue = mac->get_Item(1)->get_Value();
            Mono::Security::ASN1 *macSalt = macData->get_Item(1);
            if(((int32_t)(macSalt->get_Tag()) != 4)) 
            {
                throw cli::gcnew<System::ArgumentException>(_T("missing MAC salt"));
            }
            this->_iterations = 1;
            if((macData->get_Count() > 2)) 
            {
                Mono::Security::ASN1 *iters = macData->get_Item(2);
                if(((int32_t)(iters->get_Tag()) != 2)) 
                {
                    throw cli::gcnew<System::ArgumentException>(_T("invalid MAC iteration"));
                }
                this->_iterations = Mono::Security::ASN1Convert::ToInt32(iters);
            }
            cli::array<unsigned char> *authSafeData = authSafe->get_Content()->get_Item(0)->get_Value();
            cli::array<unsigned char> *calculatedMac = MAC(this->_password, macSalt->get_Value(), this->_iterations, authSafeData);
            if(!(Compare(macValue, calculatedMac))) 
            {
                throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("Invalid MAC - file may have been tampered!"));
            }
        }
        Mono::Security::ASN1 *authenticatedSafe = cli::gcnew<Mono::Security::ASN1>(authSafe->get_Content()->get_Item(0)->get_Value());
        for(int32_t i = 0; (i < authenticatedSafe->get_Count()); i++){
            Mono::Security::ContentInfo *ci = cli::gcnew<Mono::Security::ContentInfo>(authenticatedSafe->get_Item(i));
            System::String* tmp_80 = ci->get_ContentType();
            ::System::Int32 tmp_81 = -1;
            if(::System::String::Equals3(tmp_80, _T("1.2.840.113549.1.7.1"))) tmp_81 = 0;
            if(::System::String::Equals3(tmp_80, _T("1.2.840.113549.1.7.6"))) tmp_81 = 1;
            if(::System::String::Equals3(tmp_80, _T("1.2.840.113549.1.7.3"))) tmp_81 = 2;
            switch(tmp_81)
            {
                case 0: case_408: 
                {
                    Mono::Security::ASN1 *safeContents = cli::gcnew<Mono::Security::ASN1>(ci->get_Content()->get_Item(0)->get_Value());
                    for(int32_t j = 0; (j < safeContents->get_Count()); j++){
                        Mono::Security::ASN1 *safeBag = safeContents->get_Item(j);
                        ReadSafeBag(safeBag);
                    }
                    break;
                }
                case 1: case_409: 
                {
                    Mono::Security::EncryptedData *ed = cli::gcnew<Mono::Security::EncryptedData>(ci->get_Content()->get_Item(0));
                    Mono::Security::ASN1 *decrypted = cli::gcnew<Mono::Security::ASN1>(Decrypt2(ed));
                    for(int32_t j = 0; (j < decrypted->get_Count()); j++){
                        Mono::Security::ASN1 *safeBag = decrypted->get_Item(j);
                        ReadSafeBag(safeBag);
                    }
                    break;
                }
                case 2: case_410: 
                {
                    throw cli::gcnew<System::NotImplementedException>(_T("public key encrypted"));
                }
                default: case_411: 
                {
                    throw cli::gcnew<System::ArgumentException>(_T("unknown authenticatedSafe"));
                }
            }
        }
    }
    
    bool PKCS12::Compare(cli::array<unsigned char>* expected, cli::array<unsigned char>* actual) {
        bool compare = false;
        if((expected->get_Length() ==  actual->get_Length())) 
        {
            for(int32_t i = 0; (i < expected->get_Length()); i++){
                if(((int32_t)(expected->at(i)) != (int32_t)(actual->at(i)))) 
                {
                    return false;
                }
            }
            compare = true;
        }
        return compare;
    }
    
    System::Security::Cryptography::SymmetricAlgorithm* PKCS12::GetSymmetricAlgorithm(System::String* algorithmOid, cli::array<unsigned char>* salt, int32_t iterationCount) {
        System::String *algorithm = nullptr;
        int32_t keyLength = 8;
        int32_t ivLength = 8;
        DeriveBytes *pd = cli::gcnew<DeriveBytes>();
        pd->set_Password(this->_password);
        pd->set_Salt(salt);
        pd->set_IterationCount(iterationCount);
        System::String* tmp_82 = algorithmOid;
        ::System::Int32 tmp_83 = -1;
        if(::System::String::Equals3(tmp_82, _T("0"))) tmp_83 = 0;
        if(::System::String::Equals3(tmp_82, _T("1"))) tmp_83 = 1;
        if(::System::String::Equals3(tmp_82, _T("2"))) tmp_83 = 2;
        if(::System::String::Equals3(tmp_82, _T("3"))) tmp_83 = 3;
        if(::System::String::Equals3(tmp_82, _T("4"))) tmp_83 = 4;
        if(::System::String::Equals3(tmp_82, _T("5"))) tmp_83 = 5;
        if(::System::String::Equals3(tmp_82, _T("6"))) tmp_83 = 6;
        if(::System::String::Equals3(tmp_82, _T("7"))) tmp_83 = 7;
        if(::System::String::Equals3(tmp_82, _T("8"))) tmp_83 = 8;
        if(::System::String::Equals3(tmp_82, _T("9"))) tmp_83 = 9;
        if(::System::String::Equals3(tmp_82, _T("10"))) tmp_83 = 10;
        if(::System::String::Equals3(tmp_82, _T("11"))) tmp_83 = 11;
        switch(tmp_83)
        {
            case 0: case_412: 
            {
                pd->set_HashName(_T("MD2"));
                algorithm = _T("DES");
                break;
            }
            case 1: case_413: 
            {
                pd->set_HashName(_T("MD5"));
                algorithm = _T("DES");
                break;
            }
            case 2: case_414: 
            {
                pd->set_HashName(_T("MD2"));
                algorithm = _T("RC2");
                keyLength = 4;
                break;
            }
            case 3: case_415: 
            {
                pd->set_HashName(_T("MD5"));
                algorithm = _T("RC2");
                keyLength = 4;
                break;
            }
            case 4: case_416: 
            {
                pd->set_HashName(_T("SHA1"));
                algorithm = _T("DES");
                break;
            }
            case 5: case_417: 
            {
                pd->set_HashName(_T("SHA1"));
                algorithm = _T("RC2");
                keyLength = 4;
                break;
            }
            case 6: case_418: 
            {
                pd->set_HashName(_T("SHA1"));
                algorithm = _T("RC4");
                keyLength = 16;
                ivLength = 0;
                break;
            }
            case 7: case_419: 
            {
                pd->set_HashName(_T("SHA1"));
                algorithm = _T("RC4");
                keyLength = 5;
                ivLength = 0;
                break;
            }
            case 8: case_420: 
            {
                pd->set_HashName(_T("SHA1"));
                algorithm = _T("TripleDES");
                keyLength = 24;
                break;
            }
            case 9: case_421: 
            {
                pd->set_HashName(_T("SHA1"));
                algorithm = _T("TripleDES");
                keyLength = 16;
                break;
            }
            case 10: case_422: 
            {
                pd->set_HashName(_T("SHA1"));
                algorithm = _T("RC2");
                keyLength = 16;
                break;
            }
            case 11: case_423: 
            {
                pd->set_HashName(_T("SHA1"));
                algorithm = _T("RC2");
                keyLength = 5;
                break;
            }
            default: case_424: 
            {
                throw cli::gcnew<System::NotSupportedException>(cli::concat(_T("unknown oid "), algorithm));
            }
        }
        System::Security::Cryptography::SymmetricAlgorithm *sa = System::Security::Cryptography::SymmetricAlgorithm::Create2(algorithm);
        sa->set_Key_9b56e7a05d7e4c8f(pd->DeriveKey(keyLength));
        if((ivLength > 0)) 
        {
            sa->set_IV_5f86e84678ef1565(pd->DeriveIV(ivLength));
            sa->set_Mode_b4ebd08a4556d807(System::Security::Cryptography::CipherMode::CBC);
        }
        return sa;
    }
    
    cli::array<unsigned char>* PKCS12::Decrypt(System::String* algorithmOid, cli::array<unsigned char>* salt, int32_t iterationCount, cli::array<unsigned char>* encryptedData) {
        System::Security::Cryptography::SymmetricAlgorithm *sa = nullptr;
        cli::array<unsigned char> *result = nullptr;
        {
            cli::finally_guard([&]() {
                if((sa != nullptr)) 
                {
                    sa->Clear();
                }
            });
            sa = GetSymmetricAlgorithm(algorithmOid, salt, iterationCount);
            System::Security::Cryptography::ICryptoTransform *ct = sa->CreateDecryptor_2ed655dc8e27df59();
            result = ct->TransformFinalBlock_24eabce3605cc4ff(encryptedData, 0, encryptedData->get_Length());
        }
        return result;
    }
    
    cli::array<unsigned char>* PKCS12::Decrypt2(Mono::Security::EncryptedData* ed) {
        return Decrypt(ed->get_EncryptionAlgorithm()->get_ContentType(), ed->get_EncryptionAlgorithm()->get_Content()->get_Item(0)->get_Value(), Mono::Security::ASN1Convert::ToInt32(ed->get_EncryptionAlgorithm()->get_Content()->get_Item(1)), ed->get_EncryptedContent());
    }
    
    cli::array<unsigned char>* PKCS12::Encrypt(System::String* algorithmOid, cli::array<unsigned char>* salt, int32_t iterationCount, cli::array<unsigned char>* data) {
        cli::array<unsigned char> *result = nullptr;
        {
            /* USING - BLOCK */
            auto sa = GetSymmetricAlgorithm(algorithmOid, salt, iterationCount);
            cli::using_guard{sa};
            System::Security::Cryptography::ICryptoTransform *ct = sa->CreateEncryptor_f7057afd90cae836();
            result = ct->TransformFinalBlock_24eabce3605cc4ff(data, 0, data->get_Length());
        }
        return result;
    }
    
    System::Security::Cryptography::DSAParameters PKCS12::GetExistingParameters(bool found) {
        for(auto tmp_84 : this->get_Certificates()) {
            auto cert = cli::cast<X509Certificate*>(tmp_84);
            {
                if((cert->get_KeyAlgorithmParameters_7dd2925ed6c97721() != nullptr)) 
                {
                    System::Security::Cryptography::DSA *dsa = cert->get_DSA();
                    if((dsa != nullptr)) 
                    {
                        found = true;
                        return dsa->ExportParameters_c041d0915f31506(false);
                    }
                }
            }
        }
        found = false;
        return cli::ctor<System::Security::Cryptography::DSAParameters>();
    }
    
    void PKCS12::AddPrivateKey(Mono::Security::Cryptography::PrivateKeyInfo* pki) {
        cli::array<unsigned char> *privateKey = pki->get_PrivateKey();
        switch(privateKey->at(0)) {
            case 2: case_425: {
                bool found;
                System::Security::Cryptography::DSAParameters p = GetExistingParameters(found);
                if(found) 
                {
                    this->_keyBags->Add_e6a92085999ce388(Mono::Security::Cryptography::PrivateKeyInfo::DecodeDSA(privateKey, p));
                }
                break;
            }
            case 48: case_426: {
                this->_keyBags->Add_e6a92085999ce388(Mono::Security::Cryptography::PrivateKeyInfo::DecodeRSA(privateKey));
                break;
            }
            default: case_427: {
                System::Array::Clear2(privateKey, 0, privateKey->get_Length());
                throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("Unknown private key format"));
            }
        }
        System::Array::Clear2(privateKey, 0, privateKey->get_Length());
    }
    
    void PKCS12::ReadSafeBag(Mono::Security::ASN1* safeBag) {
        if(((int32_t)(safeBag->get_Tag()) != 48)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("invalid safeBag"));
        }
        Mono::Security::ASN1 *bagId = safeBag->get_Item(0);
        if(((int32_t)(bagId->get_Tag()) != 6)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("invalid safeBag id"));
        }
        Mono::Security::ASN1 *bagValue = safeBag->get_Item(1);
        System::String *oid = Mono::Security::ASN1Convert::ToOid(bagId);
        System::String* tmp_85 = oid;
        ::System::Int32 tmp_86 = -1;
        if(::System::String::Equals3(tmp_85, _T("1.2.840.113549.1.12.10.1.1"))) tmp_86 = 0;
        if(::System::String::Equals3(tmp_85, _T("1.2.840.113549.1.12.10.1.2"))) tmp_86 = 1;
        if(::System::String::Equals3(tmp_85, _T("1.2.840.113549.1.12.10.1.3"))) tmp_86 = 2;
        if(::System::String::Equals3(tmp_85, _T("1.2.840.113549.1.12.10.1.4"))) tmp_86 = 3;
        if(::System::String::Equals3(tmp_85, _T("1.2.840.113549.1.12.10.1.5"))) tmp_86 = 4;
        if(::System::String::Equals3(tmp_85, _T("1.2.840.113549.1.12.10.1.6"))) tmp_86 = 5;
        switch(tmp_86)
        {
            case 0: case_428: 
            {
                AddPrivateKey(cli::gcnew<Mono::Security::Cryptography::PrivateKeyInfo>(bagValue->get_Value()));
                break;
            }
            case 1: case_429: 
            {
                Mono::Security::Cryptography::EncryptedPrivateKeyInfo *epki = cli::gcnew<Mono::Security::Cryptography::EncryptedPrivateKeyInfo>(bagValue->get_Value());
                cli::array<unsigned char> *decrypted = Decrypt(epki->get_Algorithm(), epki->get_Salt(), epki->get_IterationCount(), epki->get_EncryptedData());
                AddPrivateKey(cli::gcnew<Mono::Security::Cryptography::PrivateKeyInfo>(decrypted));
                System::Array::Clear2(decrypted, 0, decrypted->get_Length());
                break;
            }
            case 2: case_430: 
            {
                Mono::Security::ContentInfo *cert = cli::gcnew<Mono::Security::ContentInfo>(bagValue->get_Value());
                if(System::String::op_Inequality(cert->get_ContentType(), _T("1.2.840.113549.1.9.22.1"))) 
                {
                    throw cli::gcnew<System::NotSupportedException>(_T("unsupport certificate type"));
                }
                X509Certificate *x509 = cli::gcnew<X509Certificate>(cert->get_Content()->get_Item(0)->get_Value());
                this->_certs->Add2(x509);
                break;
            }
            case 3: case_431: 
            {
                break;
            }
            case 4: case_432: 
            {
                cli::array<unsigned char> *secret = bagValue->get_Value();
                this->_secretBags->Add_e6a92085999ce388(secret);
                break;
            }
            case 5: case_433: 
            {
                break;
            }
            default: case_434: 
            {
                throw cli::gcnew<System::ArgumentException>(_T("unknown safeBag oid"));
            }
        }
        if((safeBag->get_Count() > 2)) 
        {
            Mono::Security::ASN1 *bagAttributes = safeBag->get_Item(2);
            if(((int32_t)(bagAttributes->get_Tag()) != 49)) 
            {
                throw cli::gcnew<System::ArgumentException>(_T("invalid safeBag attributes id"));
            }
            for(int32_t i = 0; (i < bagAttributes->get_Count()); i++){
                Mono::Security::ASN1 *pkcs12Attribute = bagAttributes->get_Item(i);
                if(((int32_t)(pkcs12Attribute->get_Tag()) != 48)) 
                {
                    throw cli::gcnew<System::ArgumentException>(_T("invalid PKCS12 attributes id"));
                }
                Mono::Security::ASN1 *attrId = pkcs12Attribute->get_Item(0);
                if(((int32_t)(attrId->get_Tag()) != 6)) 
                {
                    throw cli::gcnew<System::ArgumentException>(_T("invalid attribute id"));
                }
                System::String *attrOid = Mono::Security::ASN1Convert::ToOid(attrId);
                Mono::Security::ASN1 *attrValues = pkcs12Attribute->get_Item(1);
                for(int32_t j = 0; (j < attrValues->get_Count()); j++){
                    Mono::Security::ASN1 *attrValue = attrValues->get_Item(j);
                    System::String* tmp_87 = attrOid;
                    ::System::Int32 tmp_88 = -1;
                    if(::System::String::Equals3(tmp_87, _T("1.2.840.113549.1.9.20"))) tmp_88 = 0;
                    if(::System::String::Equals3(tmp_87, _T("1.2.840.113549.1.9.21"))) tmp_88 = 1;
                    switch(tmp_88)
                    {
                        case 0: case_435: 
                        {
                            if(((int32_t)(attrValue->get_Tag()) != 30)) 
                            {
                                throw cli::gcnew<System::ArgumentException>(_T("invalid attribute value id"));
                            }
                            break;
                        }
                        case 1: case_436: 
                        {
                            if(((int32_t)(attrValue->get_Tag()) != 4)) 
                            {
                                throw cli::gcnew<System::ArgumentException>(_T("invalid attribute value id"));
                            }
                            break;
                        }
                        default: case_437: 
                        {
                            break;
                        }
                    }
                }
            }
        }
        this->_safeBags->Add_e6a92085999ce388(cli::gcnew<SafeBag>(oid, safeBag));
    }
    
    Mono::Security::ASN1* PKCS12::Pkcs8ShroudedKeyBagSafeBag(System::Security::Cryptography::AsymmetricAlgorithm* aa, System::Collections::IDictionary* attributes) {
        Mono::Security::Cryptography::PrivateKeyInfo *pki = cli::gcnew<Mono::Security::Cryptography::PrivateKeyInfo>();
        if(cli::is<System::Security::Cryptography::RSA>(aa)) 
        {
            pki->set_Algorithm(_T("1.2.840.113549.1.1.1"));
            pki->set_PrivateKey(Mono::Security::Cryptography::PrivateKeyInfo::Encode(cli::cast<System::Security::Cryptography::RSA*>(aa)));
        }
         else 
        {
            if(cli::is<System::Security::Cryptography::DSA>(aa)) 
            {
                pki->set_Algorithm(nullptr);
                pki->set_PrivateKey(Mono::Security::Cryptography::PrivateKeyInfo::Encode2(cli::cast<System::Security::Cryptography::DSA*>(aa)));
            }
             else 
            {
                throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("Unknown asymmetric algorithm {0}"), aa->ToString_1636a0751cb9ac11());
            }
        }
        Mono::Security::Cryptography::EncryptedPrivateKeyInfo *epki = cli::gcnew<Mono::Security::Cryptography::EncryptedPrivateKeyInfo>();
        epki->set_Algorithm(_T("1.2.840.113549.1.12.1.3"));
        epki->set_IterationCount(this->_iterations);
        epki->set_EncryptedData(Encrypt(_T("1.2.840.113549.1.12.1.3"), epki->get_Salt(), this->_iterations, pki->GetBytes()));
        Mono::Security::ASN1 *safeBag = cli::gcnew<Mono::Security::ASN1>(48);
        safeBag->Add(Mono::Security::ASN1Convert::FromOid(_T("1.2.840.113549.1.12.10.1.2")));
        Mono::Security::ASN1 *bagValue = cli::gcnew<Mono::Security::ASN1>(160);
        bagValue->Add(cli::gcnew<Mono::Security::ASN1>(epki->GetBytes()));
        safeBag->Add(bagValue);
        if((attributes != nullptr)) 
        {
            Mono::Security::ASN1 *bagAttributes = cli::gcnew<Mono::Security::ASN1>(49);
            System::Collections::IDictionaryEnumerator *de = attributes->GetEnumerator_40657fcb15842551();
            while(de->MoveNext_4e78e145935f5417()) {
                System::String *oid = cli::cast<System::String*>(de->get_Key_ed7954531cb20258());
                System::String* tmp_89 = oid;
                ::System::Int32 tmp_90 = -1;
                if(::System::String::Equals3(tmp_89, _T("1.2.840.113549.1.9.20"))) tmp_90 = 0;
                if(::System::String::Equals3(tmp_89, _T("1.2.840.113549.1.9.21"))) tmp_90 = 1;
                switch(tmp_90)
                {
                    case 0: case_438: 
                    {
                        System::Collections::ArrayList *names = cli::cast<System::Collections::ArrayList*>(de->get_Value_889e0f410f0d67ef());
                        if((names->get_Count_2354963792616712() > 0)) 
                        {
                            Mono::Security::ASN1 *pkcs12Attribute = cli::gcnew<Mono::Security::ASN1>(48);
                            pkcs12Attribute->Add(Mono::Security::ASN1Convert::FromOid(_T("1.2.840.113549.1.9.20")));
                            Mono::Security::ASN1 *attrValues = cli::gcnew<Mono::Security::ASN1>(49);
                            for(auto tmp_91 : names) {
                                auto name = cli::cast<cli::array<unsigned char>*>(tmp_91);
                                {
                                    Mono::Security::ASN1 *attrValue = cli::gcnew<Mono::Security::ASN1>(30);
                                    attrValue->set_Value(name);
                                    attrValues->Add(attrValue);
                                }
                            }
                            pkcs12Attribute->Add(attrValues);
                            bagAttributes->Add(pkcs12Attribute);
                        }
                        break;
                    }
                    case 1: case_439: 
                    {
                        System::Collections::ArrayList *keys = cli::cast<System::Collections::ArrayList*>(de->get_Value_889e0f410f0d67ef());
                        if((keys->get_Count_2354963792616712() > 0)) 
                        {
                            Mono::Security::ASN1 *pkcs12Attribute = cli::gcnew<Mono::Security::ASN1>(48);
                            pkcs12Attribute->Add(Mono::Security::ASN1Convert::FromOid(_T("1.2.840.113549.1.9.21")));
                            Mono::Security::ASN1 *attrValues = cli::gcnew<Mono::Security::ASN1>(49);
                            for(auto tmp_92 : keys) {
                                auto key = cli::cast<cli::array<unsigned char>*>(tmp_92);
                                {
                                    Mono::Security::ASN1 *attrValue = cli::gcnew<Mono::Security::ASN1>(4);
                                    attrValue->set_Value(key);
                                    attrValues->Add(attrValue);
                                }
                            }
                            pkcs12Attribute->Add(attrValues);
                            bagAttributes->Add(pkcs12Attribute);
                        }
                        break;
                    }
                    default: case_440: 
                    {
                        break;
                    }
                }
            }
            if((bagAttributes->get_Count() > 0)) 
            {
                safeBag->Add(bagAttributes);
            }
        }
        return safeBag;
    }
    
    Mono::Security::ASN1* PKCS12::KeyBagSafeBag(System::Security::Cryptography::AsymmetricAlgorithm* aa, System::Collections::IDictionary* attributes) {
        Mono::Security::Cryptography::PrivateKeyInfo *pki = cli::gcnew<Mono::Security::Cryptography::PrivateKeyInfo>();
        if(cli::is<System::Security::Cryptography::RSA>(aa)) 
        {
            pki->set_Algorithm(_T("1.2.840.113549.1.1.1"));
            pki->set_PrivateKey(Mono::Security::Cryptography::PrivateKeyInfo::Encode(cli::cast<System::Security::Cryptography::RSA*>(aa)));
        }
         else 
        {
            if(cli::is<System::Security::Cryptography::DSA>(aa)) 
            {
                pki->set_Algorithm(nullptr);
                pki->set_PrivateKey(Mono::Security::Cryptography::PrivateKeyInfo::Encode2(cli::cast<System::Security::Cryptography::DSA*>(aa)));
            }
             else 
            {
                throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("Unknown asymmetric algorithm {0}"), aa->ToString_1636a0751cb9ac11());
            }
        }
        Mono::Security::ASN1 *safeBag = cli::gcnew<Mono::Security::ASN1>(48);
        safeBag->Add(Mono::Security::ASN1Convert::FromOid(_T("1.2.840.113549.1.12.10.1.1")));
        Mono::Security::ASN1 *bagValue = cli::gcnew<Mono::Security::ASN1>(160);
        bagValue->Add(cli::gcnew<Mono::Security::ASN1>(pki->GetBytes()));
        safeBag->Add(bagValue);
        if((attributes != nullptr)) 
        {
            Mono::Security::ASN1 *bagAttributes = cli::gcnew<Mono::Security::ASN1>(49);
            System::Collections::IDictionaryEnumerator *de = attributes->GetEnumerator_40657fcb15842551();
            while(de->MoveNext_4e78e145935f5417()) {
                System::String *oid = cli::cast<System::String*>(de->get_Key_ed7954531cb20258());
                System::String* tmp_93 = oid;
                ::System::Int32 tmp_94 = -1;
                if(::System::String::Equals3(tmp_93, _T("1.2.840.113549.1.9.20"))) tmp_94 = 0;
                if(::System::String::Equals3(tmp_93, _T("1.2.840.113549.1.9.21"))) tmp_94 = 1;
                switch(tmp_94)
                {
                    case 0: case_441: 
                    {
                        System::Collections::ArrayList *names = cli::cast<System::Collections::ArrayList*>(de->get_Value_889e0f410f0d67ef());
                        if((names->get_Count_2354963792616712() > 0)) 
                        {
                            Mono::Security::ASN1 *pkcs12Attribute = cli::gcnew<Mono::Security::ASN1>(48);
                            pkcs12Attribute->Add(Mono::Security::ASN1Convert::FromOid(_T("1.2.840.113549.1.9.20")));
                            Mono::Security::ASN1 *attrValues = cli::gcnew<Mono::Security::ASN1>(49);
                            for(auto tmp_95 : names) {
                                auto name = cli::cast<cli::array<unsigned char>*>(tmp_95);
                                {
                                    Mono::Security::ASN1 *attrValue = cli::gcnew<Mono::Security::ASN1>(30);
                                    attrValue->set_Value(name);
                                    attrValues->Add(attrValue);
                                }
                            }
                            pkcs12Attribute->Add(attrValues);
                            bagAttributes->Add(pkcs12Attribute);
                        }
                        break;
                    }
                    case 1: case_442: 
                    {
                        System::Collections::ArrayList *keys = cli::cast<System::Collections::ArrayList*>(de->get_Value_889e0f410f0d67ef());
                        if((keys->get_Count_2354963792616712() > 0)) 
                        {
                            Mono::Security::ASN1 *pkcs12Attribute = cli::gcnew<Mono::Security::ASN1>(48);
                            pkcs12Attribute->Add(Mono::Security::ASN1Convert::FromOid(_T("1.2.840.113549.1.9.21")));
                            Mono::Security::ASN1 *attrValues = cli::gcnew<Mono::Security::ASN1>(49);
                            for(auto tmp_96 : keys) {
                                auto key = cli::cast<cli::array<unsigned char>*>(tmp_96);
                                {
                                    Mono::Security::ASN1 *attrValue = cli::gcnew<Mono::Security::ASN1>(4);
                                    attrValue->set_Value(key);
                                    attrValues->Add(attrValue);
                                }
                            }
                            pkcs12Attribute->Add(attrValues);
                            bagAttributes->Add(pkcs12Attribute);
                        }
                        break;
                    }
                    default: case_443: 
                    {
                        break;
                    }
                }
            }
            if((bagAttributes->get_Count() > 0)) 
            {
                safeBag->Add(bagAttributes);
            }
        }
        return safeBag;
    }
    
    Mono::Security::ASN1* PKCS12::SecretBagSafeBag(cli::array<unsigned char>* secret, System::Collections::IDictionary* attributes) {
        Mono::Security::ASN1 *safeBag = cli::gcnew<Mono::Security::ASN1>(48);
        safeBag->Add(Mono::Security::ASN1Convert::FromOid(_T("1.2.840.113549.1.12.10.1.5")));
        Mono::Security::ASN1 *bagValue = cli::gcnew<Mono::Security::ASN1>(128, secret);
        safeBag->Add(bagValue);
        if((attributes != nullptr)) 
        {
            Mono::Security::ASN1 *bagAttributes = cli::gcnew<Mono::Security::ASN1>(49);
            System::Collections::IDictionaryEnumerator *de = attributes->GetEnumerator_40657fcb15842551();
            while(de->MoveNext_4e78e145935f5417()) {
                System::String *oid = cli::cast<System::String*>(de->get_Key_ed7954531cb20258());
                System::String* tmp_97 = oid;
                ::System::Int32 tmp_98 = -1;
                if(::System::String::Equals3(tmp_97, _T("1.2.840.113549.1.9.20"))) tmp_98 = 0;
                if(::System::String::Equals3(tmp_97, _T("1.2.840.113549.1.9.21"))) tmp_98 = 1;
                switch(tmp_98)
                {
                    case 0: case_444: 
                    {
                        System::Collections::ArrayList *names = cli::cast<System::Collections::ArrayList*>(de->get_Value_889e0f410f0d67ef());
                        if((names->get_Count_2354963792616712() > 0)) 
                        {
                            Mono::Security::ASN1 *pkcs12Attribute = cli::gcnew<Mono::Security::ASN1>(48);
                            pkcs12Attribute->Add(Mono::Security::ASN1Convert::FromOid(_T("1.2.840.113549.1.9.20")));
                            Mono::Security::ASN1 *attrValues = cli::gcnew<Mono::Security::ASN1>(49);
                            for(auto tmp_99 : names) {
                                auto name = cli::cast<cli::array<unsigned char>*>(tmp_99);
                                {
                                    Mono::Security::ASN1 *attrValue = cli::gcnew<Mono::Security::ASN1>(30);
                                    attrValue->set_Value(name);
                                    attrValues->Add(attrValue);
                                }
                            }
                            pkcs12Attribute->Add(attrValues);
                            bagAttributes->Add(pkcs12Attribute);
                        }
                        break;
                    }
                    case 1: case_445: 
                    {
                        System::Collections::ArrayList *keys = cli::cast<System::Collections::ArrayList*>(de->get_Value_889e0f410f0d67ef());
                        if((keys->get_Count_2354963792616712() > 0)) 
                        {
                            Mono::Security::ASN1 *pkcs12Attribute = cli::gcnew<Mono::Security::ASN1>(48);
                            pkcs12Attribute->Add(Mono::Security::ASN1Convert::FromOid(_T("1.2.840.113549.1.9.21")));
                            Mono::Security::ASN1 *attrValues = cli::gcnew<Mono::Security::ASN1>(49);
                            for(auto tmp_100 : keys) {
                                auto key = cli::cast<cli::array<unsigned char>*>(tmp_100);
                                {
                                    Mono::Security::ASN1 *attrValue = cli::gcnew<Mono::Security::ASN1>(4);
                                    attrValue->set_Value(key);
                                    attrValues->Add(attrValue);
                                }
                            }
                            pkcs12Attribute->Add(attrValues);
                            bagAttributes->Add(pkcs12Attribute);
                        }
                        break;
                    }
                    default: case_446: 
                    {
                        break;
                    }
                }
            }
            if((bagAttributes->get_Count() > 0)) 
            {
                safeBag->Add(bagAttributes);
            }
        }
        return safeBag;
    }
    
    Mono::Security::ASN1* PKCS12::CertificateSafeBag(X509Certificate* x509, System::Collections::IDictionary* attributes) {
        Mono::Security::ASN1 *encapsulatedCertificate = cli::gcnew<Mono::Security::ASN1>(4, x509->get_RawData_c0a18e988d76611c());
        Mono::Security::ContentInfo *ci = cli::gcnew<Mono::Security::ContentInfo>();
        ci->set_ContentType(_T("1.2.840.113549.1.9.22.1"));
        ci->get_Content()->Add(encapsulatedCertificate);
        Mono::Security::ASN1 *bagValue = cli::gcnew<Mono::Security::ASN1>(160);
        bagValue->Add(ci->get_ASN1());
        Mono::Security::ASN1 *safeBag = cli::gcnew<Mono::Security::ASN1>(48);
        safeBag->Add(Mono::Security::ASN1Convert::FromOid(_T("1.2.840.113549.1.12.10.1.3")));
        safeBag->Add(bagValue);
        if((attributes != nullptr)) 
        {
            Mono::Security::ASN1 *bagAttributes = cli::gcnew<Mono::Security::ASN1>(49);
            System::Collections::IDictionaryEnumerator *de = attributes->GetEnumerator_40657fcb15842551();
            while(de->MoveNext_4e78e145935f5417()) {
                System::String *oid = cli::cast<System::String*>(de->get_Key_ed7954531cb20258());
                System::String* tmp_101 = oid;
                ::System::Int32 tmp_102 = -1;
                if(::System::String::Equals3(tmp_101, _T("1.2.840.113549.1.9.20"))) tmp_102 = 0;
                if(::System::String::Equals3(tmp_101, _T("1.2.840.113549.1.9.21"))) tmp_102 = 1;
                switch(tmp_102)
                {
                    case 0: case_447: 
                    {
                        System::Collections::ArrayList *names = cli::cast<System::Collections::ArrayList*>(de->get_Value_889e0f410f0d67ef());
                        if((names->get_Count_2354963792616712() > 0)) 
                        {
                            Mono::Security::ASN1 *pkcs12Attribute = cli::gcnew<Mono::Security::ASN1>(48);
                            pkcs12Attribute->Add(Mono::Security::ASN1Convert::FromOid(_T("1.2.840.113549.1.9.20")));
                            Mono::Security::ASN1 *attrValues = cli::gcnew<Mono::Security::ASN1>(49);
                            for(auto tmp_103 : names) {
                                auto name = cli::cast<cli::array<unsigned char>*>(tmp_103);
                                {
                                    Mono::Security::ASN1 *attrValue = cli::gcnew<Mono::Security::ASN1>(30);
                                    attrValue->set_Value(name);
                                    attrValues->Add(attrValue);
                                }
                            }
                            pkcs12Attribute->Add(attrValues);
                            bagAttributes->Add(pkcs12Attribute);
                        }
                        break;
                    }
                    case 1: case_448: 
                    {
                        System::Collections::ArrayList *keys = cli::cast<System::Collections::ArrayList*>(de->get_Value_889e0f410f0d67ef());
                        if((keys->get_Count_2354963792616712() > 0)) 
                        {
                            Mono::Security::ASN1 *pkcs12Attribute = cli::gcnew<Mono::Security::ASN1>(48);
                            pkcs12Attribute->Add(Mono::Security::ASN1Convert::FromOid(_T("1.2.840.113549.1.9.21")));
                            Mono::Security::ASN1 *attrValues = cli::gcnew<Mono::Security::ASN1>(49);
                            for(auto tmp_104 : keys) {
                                auto key = cli::cast<cli::array<unsigned char>*>(tmp_104);
                                {
                                    Mono::Security::ASN1 *attrValue = cli::gcnew<Mono::Security::ASN1>(4);
                                    attrValue->set_Value(key);
                                    attrValues->Add(attrValue);
                                }
                            }
                            pkcs12Attribute->Add(attrValues);
                            bagAttributes->Add(pkcs12Attribute);
                        }
                        break;
                    }
                    default: case_449: 
                    {
                        break;
                    }
                }
            }
            if((bagAttributes->get_Count() > 0)) 
            {
                safeBag->Add(bagAttributes);
            }
        }
        return safeBag;
    }
    
    cli::array<unsigned char>* PKCS12::MAC(cli::array<unsigned char>* password, cli::array<unsigned char>* salt, int32_t iterations, cli::array<unsigned char>* data) {
        DeriveBytes *pd = cli::gcnew<DeriveBytes>();
        pd->set_HashName(_T("SHA1"));
        pd->set_Password(password);
        pd->set_Salt(salt);
        pd->set_IterationCount(iterations);
        System::Security::Cryptography::HMACSHA1 *hmac = cli::cast<System::Security::Cryptography::HMACSHA1*>(System::Security::Cryptography::HMAC::Create());
        hmac->set_Key_3e476ff3afc5eb94(pd->DeriveMAC(20));
        return hmac->ComputeHash2(data, 0, data->get_Length());
    }
    
    cli::array<unsigned char>* PKCS12::GetBytes() {
        Mono::Security::ASN1 *safeBagSequence = cli::gcnew<Mono::Security::ASN1>(48);
        System::Collections::ArrayList *scs = cli::gcnew<System::Collections::ArrayList>();
        for(auto tmp_105 : this->_safeBags) {
            auto sb = cli::cast<SafeBag*>(tmp_105);
            {
                if(sb->get_BagOID()->Equals5(_T("1.2.840.113549.1.12.10.1.3"))) 
                {
                    Mono::Security::ASN1 *safeBag = sb->get_ASN1();
                    Mono::Security::ASN1 *bagValue = safeBag->get_Item(1);
                    Mono::Security::ContentInfo *cert = cli::gcnew<Mono::Security::ContentInfo>(bagValue->get_Value());
                    scs->Add_e6a92085999ce388(cli::gcnew<X509Certificate>(cert->get_Content()->get_Item(0)->get_Value()));
                }
            }
        }
        System::Collections::ArrayList *addcerts = cli::gcnew<System::Collections::ArrayList>();
        System::Collections::ArrayList *removecerts = cli::gcnew<System::Collections::ArrayList>();
        for(auto tmp_106 : this->get_Certificates()) {
            auto c = cli::cast<X509Certificate*>(tmp_106);
            {
                bool found = false;
                for(auto tmp_107 : scs) {
                    auto lc = cli::cast<X509Certificate*>(tmp_107);
                    {
                        if(Compare(c->get_RawData_c0a18e988d76611c(), lc->get_RawData_c0a18e988d76611c())) 
                        {
                            found = true;
                        }
                    }
                }
                if(!(found)) 
                {
                    addcerts->Add_e6a92085999ce388(c);
                }
            }
        }
        for(auto tmp_108 : scs) {
            auto c = cli::cast<X509Certificate*>(tmp_108);
            {
                bool found = false;
                for(auto tmp_109 : this->get_Certificates()) {
                    auto lc = cli::cast<X509Certificate*>(tmp_109);
                    {
                        if(Compare(c->get_RawData_c0a18e988d76611c(), lc->get_RawData_c0a18e988d76611c())) 
                        {
                            found = true;
                        }
                    }
                }
                if(!(found)) 
                {
                    removecerts->Add_e6a92085999ce388(c);
                }
            }
        }
        for(auto tmp_110 : removecerts) {
            auto c = cli::cast<X509Certificate*>(tmp_110);
            {
                RemoveCertificate(c);
            }
        }
        for(auto tmp_111 : addcerts) {
            auto c = cli::cast<X509Certificate*>(tmp_111);
            {
                AddCertificate(c);
            }
        }
        if((this->_safeBags->get_Count_2354963792616712() > 0)) 
        {
            Mono::Security::ASN1 *certsSafeBag = cli::gcnew<Mono::Security::ASN1>(48);
            for(auto tmp_112 : this->_safeBags) {
                auto sb = cli::cast<SafeBag*>(tmp_112);
                {
                    if(sb->get_BagOID()->Equals5(_T("1.2.840.113549.1.12.10.1.3"))) 
                    {
                        certsSafeBag->Add(sb->get_ASN1());
                    }
                }
            }
            if((certsSafeBag->get_Count() > 0)) 
            {
                Mono::Security::ContentInfo *contentInfo = EncryptedContentInfo(certsSafeBag, _T("1.2.840.113549.1.12.1.3"));
                safeBagSequence->Add(contentInfo->get_ASN1());
            }
        }
        if((this->_safeBags->get_Count_2354963792616712() > 0)) 
        {
            Mono::Security::ASN1 *safeContents = cli::gcnew<Mono::Security::ASN1>(48);
            for(auto tmp_113 : this->_safeBags) {
                auto sb = cli::cast<SafeBag*>(tmp_113);
                {
                    if((sb->get_BagOID()->Equals5(_T("1.2.840.113549.1.12.10.1.1")) || sb->get_BagOID()->Equals5(_T("1.2.840.113549.1.12.10.1.2")))) 
                    {
                        safeContents->Add(sb->get_ASN1());
                    }
                }
            }
            if((safeContents->get_Count() > 0)) 
            {
                Mono::Security::ASN1 *content = cli::gcnew<Mono::Security::ASN1>(160);
                content->Add(cli::gcnew<Mono::Security::ASN1>(4, safeContents->GetBytes_b91405229279a4ac()));
                Mono::Security::ContentInfo *keyBag = cli::gcnew<Mono::Security::ContentInfo>(_T("1.2.840.113549.1.7.1"));
                keyBag->set_Content(content);
                safeBagSequence->Add(keyBag->get_ASN1());
            }
        }
        if((this->_safeBags->get_Count_2354963792616712() > 0)) 
        {
            Mono::Security::ASN1 *secretsSafeBag = cli::gcnew<Mono::Security::ASN1>(48);
            for(auto tmp_114 : this->_safeBags) {
                auto sb = cli::cast<SafeBag*>(tmp_114);
                {
                    if(sb->get_BagOID()->Equals5(_T("1.2.840.113549.1.12.10.1.5"))) 
                    {
                        secretsSafeBag->Add(sb->get_ASN1());
                    }
                }
            }
            if((secretsSafeBag->get_Count() > 0)) 
            {
                Mono::Security::ContentInfo *contentInfo = EncryptedContentInfo(secretsSafeBag, _T("1.2.840.113549.1.12.1.3"));
                safeBagSequence->Add(contentInfo->get_ASN1());
            }
        }
        Mono::Security::ASN1 *encapsulates = cli::gcnew<Mono::Security::ASN1>(4, safeBagSequence->GetBytes_b91405229279a4ac());
        Mono::Security::ASN1 *ci = cli::gcnew<Mono::Security::ASN1>(160);
        ci->Add(encapsulates);
        Mono::Security::ContentInfo *authSafe = cli::gcnew<Mono::Security::ContentInfo>(_T("1.2.840.113549.1.7.1"));
        authSafe->set_Content(ci);
        Mono::Security::ASN1 *macData = cli::gcnew<Mono::Security::ASN1>(48);
        if((this->_password != nullptr)) 
        {
            cli::array<unsigned char> *salt = (new cli::array<unsigned char>(20));
            this->get_RNG()->GetBytes_bf6c3bc1baf70dfd(salt);
            cli::array<unsigned char> *macValue = MAC(this->_password, salt, this->_iterations, authSafe->get_Content()->get_Item(0)->get_Value());
            Mono::Security::ASN1 *oidSeq = cli::gcnew<Mono::Security::ASN1>(48);
            oidSeq->Add(Mono::Security::ASN1Convert::FromOid(_T("1.3.14.3.2.26")));
            oidSeq->Add(cli::gcnew<Mono::Security::ASN1>(5));
            Mono::Security::ASN1 *mac = cli::gcnew<Mono::Security::ASN1>(48);
            mac->Add(oidSeq);
            mac->Add(cli::gcnew<Mono::Security::ASN1>(4, macValue));
            macData->Add(mac);
            macData->Add(cli::gcnew<Mono::Security::ASN1>(4, salt));
            macData->Add(Mono::Security::ASN1Convert::FromInt32(this->_iterations));
        }
        Mono::Security::ASN1 *version = cli::gcnew<Mono::Security::ASN1>(2, (new cli::array<unsigned char>({3})));
        Mono::Security::ASN1 *pfx = cli::gcnew<Mono::Security::ASN1>(48);
        pfx->Add(version);
        pfx->Add(authSafe->get_ASN1());
        if((macData->get_Count() > 0)) 
        {
            pfx->Add(macData);
        }
        return pfx->GetBytes_b91405229279a4ac();
    }
    
    Mono::Security::ContentInfo* PKCS12::EncryptedContentInfo(Mono::Security::ASN1* safeBags, System::String* algorithmOid) {
        cli::array<unsigned char> *salt = (new cli::array<unsigned char>(8));
        this->get_RNG()->GetBytes_bf6c3bc1baf70dfd(salt);
        Mono::Security::ASN1 *seqParams = cli::gcnew<Mono::Security::ASN1>(48);
        seqParams->Add(cli::gcnew<Mono::Security::ASN1>(4, salt));
        seqParams->Add(Mono::Security::ASN1Convert::FromInt32(this->_iterations));
        Mono::Security::ASN1 *seqPbe = cli::gcnew<Mono::Security::ASN1>(48);
        seqPbe->Add(Mono::Security::ASN1Convert::FromOid(algorithmOid));
        seqPbe->Add(seqParams);
        cli::array<unsigned char> *encrypted = Encrypt(algorithmOid, salt, this->_iterations, safeBags->GetBytes_b91405229279a4ac());
        Mono::Security::ASN1 *encryptedContent = cli::gcnew<Mono::Security::ASN1>(128, encrypted);
        Mono::Security::ASN1 *seq = cli::gcnew<Mono::Security::ASN1>(48);
        seq->Add(Mono::Security::ASN1Convert::FromOid(_T("1.2.840.113549.1.7.1")));
        seq->Add(seqPbe);
        seq->Add(encryptedContent);
        Mono::Security::ASN1 *version = cli::gcnew<Mono::Security::ASN1>(2, (new cli::array<unsigned char>({0})));
        Mono::Security::ASN1 *encData = cli::gcnew<Mono::Security::ASN1>(48);
        encData->Add(version);
        encData->Add(seq);
        Mono::Security::ASN1 *finalContent = cli::gcnew<Mono::Security::ASN1>(160);
        finalContent->Add(encData);
        Mono::Security::ContentInfo *bag = cli::gcnew<Mono::Security::ContentInfo>(_T("1.2.840.113549.1.7.6"));
        bag->set_Content(finalContent);
        return bag;
    }
    
    void PKCS12::AddCertificate(X509Certificate* cert) {
        AddCertificate2(cert, nullptr);
    }
    
    void PKCS12::AddCertificate2(X509Certificate* cert, System::Collections::IDictionary* attributes) {
        bool found = false;
        for(int32_t i = 0; (!(found) && (i < this->_safeBags->get_Count_2354963792616712())); i++){
            SafeBag *sb = cli::cast<SafeBag*>(this->_safeBags->get_Item_fd0155f142ae570(i));
            if(sb->get_BagOID()->Equals5(_T("1.2.840.113549.1.12.10.1.3"))) 
            {
                Mono::Security::ASN1 *safeBag = sb->get_ASN1();
                Mono::Security::ASN1 *bagValue = safeBag->get_Item(1);
                Mono::Security::ContentInfo *crt = cli::gcnew<Mono::Security::ContentInfo>(bagValue->get_Value());
                X509Certificate *c = cli::gcnew<X509Certificate>(crt->get_Content()->get_Item(0)->get_Value());
                if(Compare(cert->get_RawData_c0a18e988d76611c(), c->get_RawData_c0a18e988d76611c())) 
                {
                    found = true;
                }
            }
        }
        if(!(found)) 
        {
            this->_safeBags->Add_e6a92085999ce388(cli::gcnew<SafeBag>(_T("1.2.840.113549.1.12.10.1.3"), CertificateSafeBag(cert, attributes)));
            this->_certsChanged = true;
        }
    }
    
    void PKCS12::RemoveCertificate(X509Certificate* cert) {
        RemoveCertificate2(cert, nullptr);
    }
    
    void PKCS12::RemoveCertificate2(X509Certificate* cert, System::Collections::IDictionary* attrs) {
        int32_t certIndex = -1;
        for(int32_t i = 0; ((certIndex ==  -1) && (i < this->_safeBags->get_Count_2354963792616712())); i++){
            SafeBag *sb = cli::cast<SafeBag*>(this->_safeBags->get_Item_fd0155f142ae570(i));
            if(sb->get_BagOID()->Equals5(_T("1.2.840.113549.1.12.10.1.3"))) 
            {
                Mono::Security::ASN1 *safeBag = sb->get_ASN1();
                Mono::Security::ASN1 *bagValue = safeBag->get_Item(1);
                Mono::Security::ContentInfo *crt = cli::gcnew<Mono::Security::ContentInfo>(bagValue->get_Value());
                X509Certificate *c = cli::gcnew<X509Certificate>(crt->get_Content()->get_Item(0)->get_Value());
                if(Compare(cert->get_RawData_c0a18e988d76611c(), c->get_RawData_c0a18e988d76611c())) 
                {
                    if((attrs != nullptr)) 
                    {
                        if((safeBag->get_Count() ==  3)) 
                        {
                            Mono::Security::ASN1 *bagAttributes = safeBag->get_Item(2);
                            int32_t bagAttributesFound = 0;
                            for(int32_t j = 0; (j < bagAttributes->get_Count()); j++){
                                Mono::Security::ASN1 *pkcs12Attribute = bagAttributes->get_Item(j);
                                Mono::Security::ASN1 *attrId = pkcs12Attribute->get_Item(0);
                                System::String *ao = Mono::Security::ASN1Convert::ToOid(attrId);
                                System::Collections::ArrayList *dattrValues = cli::cast<System::Collections::ArrayList*>(attrs->get_Item_95688dd349c069c0(ao));
                                if((dattrValues != nullptr)) 
                                {
                                    Mono::Security::ASN1 *attrValues = pkcs12Attribute->get_Item(1);
                                    if((dattrValues->get_Count_2354963792616712() ==  attrValues->get_Count())) 
                                    {
                                        int32_t attrValuesFound = 0;
                                        for(int32_t k = 0; (k < attrValues->get_Count()); k++){
                                            Mono::Security::ASN1 *attrValue = attrValues->get_Item(k);
                                            cli::array<unsigned char> *value = cli::cast<cli::array<unsigned char>*>(dattrValues->get_Item_fd0155f142ae570(k));
                                            if(Compare(value, attrValue->get_Value())) 
                                            {
                                                (attrValuesFound = attrValuesFound + 1);
                                            }
                                        }
                                        if((attrValuesFound ==  attrValues->get_Count())) 
                                        {
                                            (bagAttributesFound = bagAttributesFound + 1);
                                        }
                                    }
                                }
                            }
                            if((bagAttributesFound ==  bagAttributes->get_Count())) 
                            {
                                certIndex = i;
                            }
                        }
                    }
                     else 
                    {
                        certIndex = i;
                    }
                }
            }
        }
        if((certIndex != -1)) 
        {
            this->_safeBags->RemoveAt_2abea768d3273318(certIndex);
            this->_certsChanged = true;
        }
    }
    
    bool PKCS12::CompareAsymmetricAlgorithm(System::Security::Cryptography::AsymmetricAlgorithm* a1, System::Security::Cryptography::AsymmetricAlgorithm* a2) {
        if((a1->get_KeySize_6bd474632c551ac() != a2->get_KeySize_6bd474632c551ac())) 
        {
            return false;
        }
        return System::String::op_Equality(a1->ToXmlString_681b6b8ae145c576(false), a2->ToXmlString_681b6b8ae145c576(false));
    }
    
    void PKCS12::AddPkcs8ShroudedKeyBag(System::Security::Cryptography::AsymmetricAlgorithm* aa) {
        AddPkcs8ShroudedKeyBag2(aa, nullptr);
    }
    
    void PKCS12::AddPkcs8ShroudedKeyBag2(System::Security::Cryptography::AsymmetricAlgorithm* aa, System::Collections::IDictionary* attributes) {
        bool found = false;
        for(int32_t i = 0; (!(found) && (i < this->_safeBags->get_Count_2354963792616712())); i++){
            SafeBag *sb = cli::cast<SafeBag*>(this->_safeBags->get_Item_fd0155f142ae570(i));
            if(sb->get_BagOID()->Equals5(_T("1.2.840.113549.1.12.10.1.2"))) 
            {
                Mono::Security::ASN1 *bagValue = sb->get_ASN1()->get_Item(1);
                Mono::Security::Cryptography::EncryptedPrivateKeyInfo *epki = cli::gcnew<Mono::Security::Cryptography::EncryptedPrivateKeyInfo>(bagValue->get_Value());
                cli::array<unsigned char> *decrypted = Decrypt(epki->get_Algorithm(), epki->get_Salt(), epki->get_IterationCount(), epki->get_EncryptedData());
                Mono::Security::Cryptography::PrivateKeyInfo *pki = cli::gcnew<Mono::Security::Cryptography::PrivateKeyInfo>(decrypted);
                cli::array<unsigned char> *privateKey = pki->get_PrivateKey();
                System::Security::Cryptography::AsymmetricAlgorithm *saa = nullptr;
                switch(privateKey->at(0)) {
                    case 2: case_450: {
                        System::Security::Cryptography::DSAParameters p = cli::ctor<System::Security::Cryptography::DSAParameters>();
                        saa = Mono::Security::Cryptography::PrivateKeyInfo::DecodeDSA(privateKey, p);
                        break;
                    }
                    case 48: case_451: {
                        saa = Mono::Security::Cryptography::PrivateKeyInfo::DecodeRSA(privateKey);
                        break;
                    }
                    default: case_452: {
                        System::Array::Clear2(decrypted, 0, decrypted->get_Length());
                        System::Array::Clear2(privateKey, 0, privateKey->get_Length());
                        throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("Unknown private key format"));
                    }
                }
                System::Array::Clear2(decrypted, 0, decrypted->get_Length());
                System::Array::Clear2(privateKey, 0, privateKey->get_Length());
                if(CompareAsymmetricAlgorithm(aa, saa)) 
                {
                    found = true;
                }
            }
        }
        if(!(found)) 
        {
            this->_safeBags->Add_e6a92085999ce388(cli::gcnew<SafeBag>(_T("1.2.840.113549.1.12.10.1.2"), Pkcs8ShroudedKeyBagSafeBag(aa, attributes)));
            this->_keyBagsChanged = true;
        }
    }
    
    void PKCS12::RemovePkcs8ShroudedKeyBag(System::Security::Cryptography::AsymmetricAlgorithm* aa) {
        int32_t aaIndex = -1;
        for(int32_t i = 0; ((aaIndex ==  -1) && (i < this->_safeBags->get_Count_2354963792616712())); i++){
            SafeBag *sb = cli::cast<SafeBag*>(this->_safeBags->get_Item_fd0155f142ae570(i));
            if(sb->get_BagOID()->Equals5(_T("1.2.840.113549.1.12.10.1.2"))) 
            {
                Mono::Security::ASN1 *bagValue = sb->get_ASN1()->get_Item(1);
                Mono::Security::Cryptography::EncryptedPrivateKeyInfo *epki = cli::gcnew<Mono::Security::Cryptography::EncryptedPrivateKeyInfo>(bagValue->get_Value());
                cli::array<unsigned char> *decrypted = Decrypt(epki->get_Algorithm(), epki->get_Salt(), epki->get_IterationCount(), epki->get_EncryptedData());
                Mono::Security::Cryptography::PrivateKeyInfo *pki = cli::gcnew<Mono::Security::Cryptography::PrivateKeyInfo>(decrypted);
                cli::array<unsigned char> *privateKey = pki->get_PrivateKey();
                System::Security::Cryptography::AsymmetricAlgorithm *saa = nullptr;
                switch(privateKey->at(0)) {
                    case 2: case_453: {
                        System::Security::Cryptography::DSAParameters p = cli::ctor<System::Security::Cryptography::DSAParameters>();
                        saa = Mono::Security::Cryptography::PrivateKeyInfo::DecodeDSA(privateKey, p);
                        break;
                    }
                    case 48: case_454: {
                        saa = Mono::Security::Cryptography::PrivateKeyInfo::DecodeRSA(privateKey);
                        break;
                    }
                    default: case_455: {
                        System::Array::Clear2(decrypted, 0, decrypted->get_Length());
                        System::Array::Clear2(privateKey, 0, privateKey->get_Length());
                        throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("Unknown private key format"));
                    }
                }
                System::Array::Clear2(decrypted, 0, decrypted->get_Length());
                System::Array::Clear2(privateKey, 0, privateKey->get_Length());
                if(CompareAsymmetricAlgorithm(aa, saa)) 
                {
                    aaIndex = i;
                }
            }
        }
        if((aaIndex != -1)) 
        {
            this->_safeBags->RemoveAt_2abea768d3273318(aaIndex);
            this->_keyBagsChanged = true;
        }
    }
    
    void PKCS12::AddKeyBag(System::Security::Cryptography::AsymmetricAlgorithm* aa) {
        AddKeyBag2(aa, nullptr);
    }
    
    void PKCS12::AddKeyBag2(System::Security::Cryptography::AsymmetricAlgorithm* aa, System::Collections::IDictionary* attributes) {
        bool found = false;
        for(int32_t i = 0; (!(found) && (i < this->_safeBags->get_Count_2354963792616712())); i++){
            SafeBag *sb = cli::cast<SafeBag*>(this->_safeBags->get_Item_fd0155f142ae570(i));
            if(sb->get_BagOID()->Equals5(_T("1.2.840.113549.1.12.10.1.1"))) 
            {
                Mono::Security::ASN1 *bagValue = sb->get_ASN1()->get_Item(1);
                Mono::Security::Cryptography::PrivateKeyInfo *pki = cli::gcnew<Mono::Security::Cryptography::PrivateKeyInfo>(bagValue->get_Value());
                cli::array<unsigned char> *privateKey = pki->get_PrivateKey();
                System::Security::Cryptography::AsymmetricAlgorithm *saa = nullptr;
                switch(privateKey->at(0)) {
                    case 2: case_456: {
                        System::Security::Cryptography::DSAParameters p = cli::ctor<System::Security::Cryptography::DSAParameters>();
                        saa = Mono::Security::Cryptography::PrivateKeyInfo::DecodeDSA(privateKey, p);
                        break;
                    }
                    case 48: case_457: {
                        saa = Mono::Security::Cryptography::PrivateKeyInfo::DecodeRSA(privateKey);
                        break;
                    }
                    default: case_458: {
                        System::Array::Clear2(privateKey, 0, privateKey->get_Length());
                        throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("Unknown private key format"));
                    }
                }
                System::Array::Clear2(privateKey, 0, privateKey->get_Length());
                if(CompareAsymmetricAlgorithm(aa, saa)) 
                {
                    found = true;
                }
            }
        }
        if(!(found)) 
        {
            this->_safeBags->Add_e6a92085999ce388(cli::gcnew<SafeBag>(_T("1.2.840.113549.1.12.10.1.1"), KeyBagSafeBag(aa, attributes)));
            this->_keyBagsChanged = true;
        }
    }
    
    void PKCS12::RemoveKeyBag(System::Security::Cryptography::AsymmetricAlgorithm* aa) {
        int32_t aaIndex = -1;
        for(int32_t i = 0; ((aaIndex ==  -1) && (i < this->_safeBags->get_Count_2354963792616712())); i++){
            SafeBag *sb = cli::cast<SafeBag*>(this->_safeBags->get_Item_fd0155f142ae570(i));
            if(sb->get_BagOID()->Equals5(_T("1.2.840.113549.1.12.10.1.1"))) 
            {
                Mono::Security::ASN1 *bagValue = sb->get_ASN1()->get_Item(1);
                Mono::Security::Cryptography::PrivateKeyInfo *pki = cli::gcnew<Mono::Security::Cryptography::PrivateKeyInfo>(bagValue->get_Value());
                cli::array<unsigned char> *privateKey = pki->get_PrivateKey();
                System::Security::Cryptography::AsymmetricAlgorithm *saa = nullptr;
                switch(privateKey->at(0)) {
                    case 2: case_459: {
                        System::Security::Cryptography::DSAParameters p = cli::ctor<System::Security::Cryptography::DSAParameters>();
                        saa = Mono::Security::Cryptography::PrivateKeyInfo::DecodeDSA(privateKey, p);
                        break;
                    }
                    case 48: case_460: {
                        saa = Mono::Security::Cryptography::PrivateKeyInfo::DecodeRSA(privateKey);
                        break;
                    }
                    default: case_461: {
                        System::Array::Clear2(privateKey, 0, privateKey->get_Length());
                        throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("Unknown private key format"));
                    }
                }
                System::Array::Clear2(privateKey, 0, privateKey->get_Length());
                if(CompareAsymmetricAlgorithm(aa, saa)) 
                {
                    aaIndex = i;
                }
            }
        }
        if((aaIndex != -1)) 
        {
            this->_safeBags->RemoveAt_2abea768d3273318(aaIndex);
            this->_keyBagsChanged = true;
        }
    }
    
    void PKCS12::AddSecretBag(cli::array<unsigned char>* secret) {
        AddSecretBag2(secret, nullptr);
    }
    
    void PKCS12::AddSecretBag2(cli::array<unsigned char>* secret, System::Collections::IDictionary* attributes) {
        bool found = false;
        for(int32_t i = 0; (!(found) && (i < this->_safeBags->get_Count_2354963792616712())); i++){
            SafeBag *sb = cli::cast<SafeBag*>(this->_safeBags->get_Item_fd0155f142ae570(i));
            if(sb->get_BagOID()->Equals5(_T("1.2.840.113549.1.12.10.1.5"))) 
            {
                Mono::Security::ASN1 *bagValue = sb->get_ASN1()->get_Item(1);
                cli::array<unsigned char> *ssecret = bagValue->get_Value();
                if(Compare(secret, ssecret)) 
                {
                    found = true;
                }
            }
        }
        if(!(found)) 
        {
            this->_safeBags->Add_e6a92085999ce388(cli::gcnew<SafeBag>(_T("1.2.840.113549.1.12.10.1.5"), SecretBagSafeBag(secret, attributes)));
            this->_secretBagsChanged = true;
        }
    }
    
    void PKCS12::RemoveSecretBag(cli::array<unsigned char>* secret) {
        int32_t sIndex = -1;
        for(int32_t i = 0; ((sIndex ==  -1) && (i < this->_safeBags->get_Count_2354963792616712())); i++){
            SafeBag *sb = cli::cast<SafeBag*>(this->_safeBags->get_Item_fd0155f142ae570(i));
            if(sb->get_BagOID()->Equals5(_T("1.2.840.113549.1.12.10.1.5"))) 
            {
                Mono::Security::ASN1 *bagValue = sb->get_ASN1()->get_Item(1);
                cli::array<unsigned char> *ssecret = bagValue->get_Value();
                if(Compare(secret, ssecret)) 
                {
                    sIndex = i;
                }
            }
        }
        if((sIndex != -1)) 
        {
            this->_safeBags->RemoveAt_2abea768d3273318(sIndex);
            this->_secretBagsChanged = true;
        }
    }
    
    System::Security::Cryptography::AsymmetricAlgorithm* PKCS12::GetAsymmetricAlgorithm(System::Collections::IDictionary* attrs) {
        for(auto tmp_115 : this->_safeBags) {
            auto sb = cli::cast<SafeBag*>(tmp_115);
            {
                if((sb->get_BagOID()->Equals5(_T("1.2.840.113549.1.12.10.1.1")) || sb->get_BagOID()->Equals5(_T("1.2.840.113549.1.12.10.1.2")))) 
                {
                    Mono::Security::ASN1 *safeBag = sb->get_ASN1();
                    if((safeBag->get_Count() ==  3)) 
                    {
                        Mono::Security::ASN1 *bagAttributes = safeBag->get_Item(2);
                        int32_t bagAttributesFound = 0;
                        for(int32_t i = 0; (i < bagAttributes->get_Count()); i++){
                            Mono::Security::ASN1 *pkcs12Attribute = bagAttributes->get_Item(i);
                            Mono::Security::ASN1 *attrId = pkcs12Attribute->get_Item(0);
                            System::String *ao = Mono::Security::ASN1Convert::ToOid(attrId);
                            System::Collections::ArrayList *dattrValues = cli::cast<System::Collections::ArrayList*>(attrs->get_Item_95688dd349c069c0(ao));
                            if((dattrValues != nullptr)) 
                            {
                                Mono::Security::ASN1 *attrValues = pkcs12Attribute->get_Item(1);
                                if((dattrValues->get_Count_2354963792616712() ==  attrValues->get_Count())) 
                                {
                                    int32_t attrValuesFound = 0;
                                    for(int32_t j = 0; (j < attrValues->get_Count()); j++){
                                        Mono::Security::ASN1 *attrValue = attrValues->get_Item(j);
                                        cli::array<unsigned char> *value = cli::cast<cli::array<unsigned char>*>(dattrValues->get_Item_fd0155f142ae570(j));
                                        if(Compare(value, attrValue->get_Value())) 
                                        {
                                            (attrValuesFound = attrValuesFound + 1);
                                        }
                                    }
                                    if((attrValuesFound ==  attrValues->get_Count())) 
                                    {
                                        (bagAttributesFound = bagAttributesFound + 1);
                                    }
                                }
                            }
                        }
                        if((bagAttributesFound ==  bagAttributes->get_Count())) 
                        {
                            Mono::Security::ASN1 *bagValue = safeBag->get_Item(1);
                            System::Security::Cryptography::AsymmetricAlgorithm *aa = nullptr;
                            if(sb->get_BagOID()->Equals5(_T("1.2.840.113549.1.12.10.1.1"))) 
                            {
                                Mono::Security::Cryptography::PrivateKeyInfo *pki = cli::gcnew<Mono::Security::Cryptography::PrivateKeyInfo>(bagValue->get_Value());
                                cli::array<unsigned char> *privateKey = pki->get_PrivateKey();
                                switch(privateKey->at(0)) {
                                    case 2: case_462: {
                                        System::Security::Cryptography::DSAParameters p = cli::ctor<System::Security::Cryptography::DSAParameters>();
                                        aa = Mono::Security::Cryptography::PrivateKeyInfo::DecodeDSA(privateKey, p);
                                        break;
                                    }
                                    case 48: case_463: {
                                        aa = Mono::Security::Cryptography::PrivateKeyInfo::DecodeRSA(privateKey);
                                        break;
                                    }
                                    default: case_464: {
                                        break;
                                    }
                                }
                                System::Array::Clear2(privateKey, 0, privateKey->get_Length());
                            }
                             else 
                            {
                                if(sb->get_BagOID()->Equals5(_T("1.2.840.113549.1.12.10.1.2"))) 
                                {
                                    Mono::Security::Cryptography::EncryptedPrivateKeyInfo *epki = cli::gcnew<Mono::Security::Cryptography::EncryptedPrivateKeyInfo>(bagValue->get_Value());
                                    cli::array<unsigned char> *decrypted = Decrypt(epki->get_Algorithm(), epki->get_Salt(), epki->get_IterationCount(), epki->get_EncryptedData());
                                    Mono::Security::Cryptography::PrivateKeyInfo *pki = cli::gcnew<Mono::Security::Cryptography::PrivateKeyInfo>(decrypted);
                                    cli::array<unsigned char> *privateKey = pki->get_PrivateKey();
                                    switch(privateKey->at(0)) {
                                        case 2: case_465: {
                                            System::Security::Cryptography::DSAParameters p = cli::ctor<System::Security::Cryptography::DSAParameters>();
                                            aa = Mono::Security::Cryptography::PrivateKeyInfo::DecodeDSA(privateKey, p);
                                            break;
                                        }
                                        case 48: case_466: {
                                            aa = Mono::Security::Cryptography::PrivateKeyInfo::DecodeRSA(privateKey);
                                            break;
                                        }
                                        default: case_467: {
                                            break;
                                        }
                                    }
                                    System::Array::Clear2(privateKey, 0, privateKey->get_Length());
                                    System::Array::Clear2(decrypted, 0, decrypted->get_Length());
                                }
                            }
                            return aa;
                        }
                    }
                }
            }
        }
        return nullptr;
    }
    
    cli::array<unsigned char>* PKCS12::GetSecret(System::Collections::IDictionary* attrs) {
        for(auto tmp_116 : this->_safeBags) {
            auto sb = cli::cast<SafeBag*>(tmp_116);
            {
                if(sb->get_BagOID()->Equals5(_T("1.2.840.113549.1.12.10.1.5"))) 
                {
                    Mono::Security::ASN1 *safeBag = sb->get_ASN1();
                    if((safeBag->get_Count() ==  3)) 
                    {
                        Mono::Security::ASN1 *bagAttributes = safeBag->get_Item(2);
                        int32_t bagAttributesFound = 0;
                        for(int32_t i = 0; (i < bagAttributes->get_Count()); i++){
                            Mono::Security::ASN1 *pkcs12Attribute = bagAttributes->get_Item(i);
                            Mono::Security::ASN1 *attrId = pkcs12Attribute->get_Item(0);
                            System::String *ao = Mono::Security::ASN1Convert::ToOid(attrId);
                            System::Collections::ArrayList *dattrValues = cli::cast<System::Collections::ArrayList*>(attrs->get_Item_95688dd349c069c0(ao));
                            if((dattrValues != nullptr)) 
                            {
                                Mono::Security::ASN1 *attrValues = pkcs12Attribute->get_Item(1);
                                if((dattrValues->get_Count_2354963792616712() ==  attrValues->get_Count())) 
                                {
                                    int32_t attrValuesFound = 0;
                                    for(int32_t j = 0; (j < attrValues->get_Count()); j++){
                                        Mono::Security::ASN1 *attrValue = attrValues->get_Item(j);
                                        cli::array<unsigned char> *value = cli::cast<cli::array<unsigned char>*>(dattrValues->get_Item_fd0155f142ae570(j));
                                        if(Compare(value, attrValue->get_Value())) 
                                        {
                                            (attrValuesFound = attrValuesFound + 1);
                                        }
                                    }
                                    if((attrValuesFound ==  attrValues->get_Count())) 
                                    {
                                        (bagAttributesFound = bagAttributesFound + 1);
                                    }
                                }
                            }
                        }
                        if((bagAttributesFound ==  bagAttributes->get_Count())) 
                        {
                            Mono::Security::ASN1 *bagValue = safeBag->get_Item(1);
                            return bagValue->get_Value();
                        }
                    }
                }
            }
        }
        return nullptr;
    }
    
    X509Certificate* PKCS12::GetCertificate(System::Collections::IDictionary* attrs) {
        for(auto tmp_117 : this->_safeBags) {
            auto sb = cli::cast<SafeBag*>(tmp_117);
            {
                if(sb->get_BagOID()->Equals5(_T("1.2.840.113549.1.12.10.1.3"))) 
                {
                    Mono::Security::ASN1 *safeBag = sb->get_ASN1();
                    if((safeBag->get_Count() ==  3)) 
                    {
                        Mono::Security::ASN1 *bagAttributes = safeBag->get_Item(2);
                        int32_t bagAttributesFound = 0;
                        for(int32_t i = 0; (i < bagAttributes->get_Count()); i++){
                            Mono::Security::ASN1 *pkcs12Attribute = bagAttributes->get_Item(i);
                            Mono::Security::ASN1 *attrId = pkcs12Attribute->get_Item(0);
                            System::String *ao = Mono::Security::ASN1Convert::ToOid(attrId);
                            System::Collections::ArrayList *dattrValues = cli::cast<System::Collections::ArrayList*>(attrs->get_Item_95688dd349c069c0(ao));
                            if((dattrValues != nullptr)) 
                            {
                                Mono::Security::ASN1 *attrValues = pkcs12Attribute->get_Item(1);
                                if((dattrValues->get_Count_2354963792616712() ==  attrValues->get_Count())) 
                                {
                                    int32_t attrValuesFound = 0;
                                    for(int32_t j = 0; (j < attrValues->get_Count()); j++){
                                        Mono::Security::ASN1 *attrValue = attrValues->get_Item(j);
                                        cli::array<unsigned char> *value = cli::cast<cli::array<unsigned char>*>(dattrValues->get_Item_fd0155f142ae570(j));
                                        if(Compare(value, attrValue->get_Value())) 
                                        {
                                            (attrValuesFound = attrValuesFound + 1);
                                        }
                                    }
                                    if((attrValuesFound ==  attrValues->get_Count())) 
                                    {
                                        (bagAttributesFound = bagAttributesFound + 1);
                                    }
                                }
                            }
                        }
                        if((bagAttributesFound ==  bagAttributes->get_Count())) 
                        {
                            Mono::Security::ASN1 *bagValue = safeBag->get_Item(1);
                            Mono::Security::ContentInfo *crt = cli::gcnew<Mono::Security::ContentInfo>(bagValue->get_Value());
                            return cli::gcnew<X509Certificate>(crt->get_Content()->get_Item(0)->get_Value());
                        }
                    }
                }
            }
        }
        return nullptr;
    }
    
    System::Collections::IDictionary* PKCS12::GetAttributes(System::Security::Cryptography::AsymmetricAlgorithm* aa) {
        System::Collections::IDictionary *result = cli::gcnew<System::Collections::Hashtable>();
        for(auto tmp_118 : this->_safeBags) {
            auto sb = cli::cast<SafeBag*>(tmp_118);
            {
                if((sb->get_BagOID()->Equals5(_T("1.2.840.113549.1.12.10.1.1")) || sb->get_BagOID()->Equals5(_T("1.2.840.113549.1.12.10.1.2")))) 
                {
                    Mono::Security::ASN1 *safeBag = sb->get_ASN1();
                    Mono::Security::ASN1 *bagValue = safeBag->get_Item(1);
                    System::Security::Cryptography::AsymmetricAlgorithm *saa = nullptr;
                    if(sb->get_BagOID()->Equals5(_T("1.2.840.113549.1.12.10.1.1"))) 
                    {
                        Mono::Security::Cryptography::PrivateKeyInfo *pki = cli::gcnew<Mono::Security::Cryptography::PrivateKeyInfo>(bagValue->get_Value());
                        cli::array<unsigned char> *privateKey = pki->get_PrivateKey();
                        switch(privateKey->at(0)) {
                            case 2: case_468: {
                                System::Security::Cryptography::DSAParameters p = cli::ctor<System::Security::Cryptography::DSAParameters>();
                                saa = Mono::Security::Cryptography::PrivateKeyInfo::DecodeDSA(privateKey, p);
                                break;
                            }
                            case 48: case_469: {
                                saa = Mono::Security::Cryptography::PrivateKeyInfo::DecodeRSA(privateKey);
                                break;
                            }
                            default: case_470: {
                                break;
                            }
                        }
                        System::Array::Clear2(privateKey, 0, privateKey->get_Length());
                    }
                     else 
                    {
                        if(sb->get_BagOID()->Equals5(_T("1.2.840.113549.1.12.10.1.2"))) 
                        {
                            Mono::Security::Cryptography::EncryptedPrivateKeyInfo *epki = cli::gcnew<Mono::Security::Cryptography::EncryptedPrivateKeyInfo>(bagValue->get_Value());
                            cli::array<unsigned char> *decrypted = Decrypt(epki->get_Algorithm(), epki->get_Salt(), epki->get_IterationCount(), epki->get_EncryptedData());
                            Mono::Security::Cryptography::PrivateKeyInfo *pki = cli::gcnew<Mono::Security::Cryptography::PrivateKeyInfo>(decrypted);
                            cli::array<unsigned char> *privateKey = pki->get_PrivateKey();
                            switch(privateKey->at(0)) {
                                case 2: case_471: {
                                    System::Security::Cryptography::DSAParameters p = cli::ctor<System::Security::Cryptography::DSAParameters>();
                                    saa = Mono::Security::Cryptography::PrivateKeyInfo::DecodeDSA(privateKey, p);
                                    break;
                                }
                                case 48: case_472: {
                                    saa = Mono::Security::Cryptography::PrivateKeyInfo::DecodeRSA(privateKey);
                                    break;
                                }
                                default: case_473: {
                                    break;
                                }
                            }
                            System::Array::Clear2(privateKey, 0, privateKey->get_Length());
                            System::Array::Clear2(decrypted, 0, decrypted->get_Length());
                        }
                    }
                    if(((saa != nullptr) && CompareAsymmetricAlgorithm(saa, aa))) 
                    {
                        if((safeBag->get_Count() ==  3)) 
                        {
                            Mono::Security::ASN1 *bagAttributes = safeBag->get_Item(2);
                            for(int32_t i = 0; (i < bagAttributes->get_Count()); i++){
                                Mono::Security::ASN1 *pkcs12Attribute = bagAttributes->get_Item(i);
                                Mono::Security::ASN1 *attrId = pkcs12Attribute->get_Item(0);
                                System::String *aOid = Mono::Security::ASN1Convert::ToOid(attrId);
                                System::Collections::ArrayList *aValues = cli::gcnew<System::Collections::ArrayList>();
                                Mono::Security::ASN1 *attrValues = pkcs12Attribute->get_Item(1);
                                for(int32_t j = 0; (j < attrValues->get_Count()); j++){
                                    Mono::Security::ASN1 *attrValue = attrValues->get_Item(j);
                                    aValues->Add_e6a92085999ce388(attrValue->get_Value());
                                }
                                result->Add_642542cf7a4cae38(aOid, aValues);
                            }
                        }
                    }
                }
            }
        }
        return result;
    }
    
    System::Collections::IDictionary* PKCS12::GetAttributes2(X509Certificate* cert) {
        System::Collections::IDictionary *result = cli::gcnew<System::Collections::Hashtable>();
        for(auto tmp_119 : this->_safeBags) {
            auto sb = cli::cast<SafeBag*>(tmp_119);
            {
                if(sb->get_BagOID()->Equals5(_T("1.2.840.113549.1.12.10.1.3"))) 
                {
                    Mono::Security::ASN1 *safeBag = sb->get_ASN1();
                    Mono::Security::ASN1 *bagValue = safeBag->get_Item(1);
                    Mono::Security::ContentInfo *crt = cli::gcnew<Mono::Security::ContentInfo>(bagValue->get_Value());
                    X509Certificate *xc = cli::gcnew<X509Certificate>(crt->get_Content()->get_Item(0)->get_Value());
                    if(Compare(cert->get_RawData_c0a18e988d76611c(), xc->get_RawData_c0a18e988d76611c())) 
                    {
                        if((safeBag->get_Count() ==  3)) 
                        {
                            Mono::Security::ASN1 *bagAttributes = safeBag->get_Item(2);
                            for(int32_t i = 0; (i < bagAttributes->get_Count()); i++){
                                Mono::Security::ASN1 *pkcs12Attribute = bagAttributes->get_Item(i);
                                Mono::Security::ASN1 *attrId = pkcs12Attribute->get_Item(0);
                                System::String *aOid = Mono::Security::ASN1Convert::ToOid(attrId);
                                System::Collections::ArrayList *aValues = cli::gcnew<System::Collections::ArrayList>();
                                Mono::Security::ASN1 *attrValues = pkcs12Attribute->get_Item(1);
                                for(int32_t j = 0; (j < attrValues->get_Count()); j++){
                                    Mono::Security::ASN1 *attrValue = attrValues->get_Item(j);
                                    aValues->Add_e6a92085999ce388(attrValue->get_Value());
                                }
                                result->Add_642542cf7a4cae38(aOid, aValues);
                            }
                        }
                    }
                }
            }
        }
        return result;
    }
    
    void PKCS12::SaveToFile(System::String* filename) {
        if((filename ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("filename"));
        }
        {
            /* USING - BLOCK */
            auto fs = System::IO::File::Create(filename);
            cli::using_guard{fs};
            cli::array<unsigned char> *data = GetBytes();
            fs->Write_1f8a1dbe71b0eb89(data, 0, data->get_Length());
        }
    }
    
    System::Object* PKCS12::Clone() {
        PKCS12 *clone = nullptr;
        if((this->_password != nullptr)) 
        {
            clone = cli::gcnew<PKCS12>(GetBytes(), System::Text::Encoding::get_BigEndianUnicode()->GetString_12d22365648431d7(this->_password));
        }
         else 
        {
            clone = cli::gcnew<PKCS12>(GetBytes());
        }
        clone->set_IterationCount(this->get_IterationCount());
        return clone;
    }
    
    cli::array<unsigned char>* PKCS12::LoadFile(System::String* filename) {
        cli::array<unsigned char> *data = nullptr;
        {
            /* USING - BLOCK */
            auto fs = System::IO::File::OpenRead(filename);
            cli::using_guard{fs};
            data = (new cli::array<unsigned char>((int32_t)fs->get_Length_ddb8b0d061db5350()));
            fs->Read_c0d6dde3943b413e(data, 0, data->get_Length());
            fs->Close_59c62ed53ef2a481();
        }
        return data;
    }
    
    PKCS12* PKCS12::LoadFromFile(System::String* filename) {
        if((filename ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("filename"));
        }
        return cli::gcnew<PKCS12>(LoadFile(filename));
    }
    
    PKCS12* PKCS12::LoadFromFile2(System::String* filename, System::String* password) {
        if((filename ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("filename"));
        }
        return cli::gcnew<PKCS12>(LoadFile(filename), password);
    }
    
    void PKCS12::set_Password(System::String* value) {
        if((value != nullptr)) 
        {
            if((value->get_Length() > 0)) 
            {
                int32_t size = value->get_Length();
                int32_t nul = 0;
                if((size < PKCS12::get_MaximumPasswordLength())) 
                {
                    if(((int32_t)(value->get_Chars((size - 1))) != 0)) 
                    {
                        nul = 1;
                    }
                }
                 else 
                {
                    size = get_MaximumPasswordLength();
                }
                this->_password = (new cli::array<unsigned char>(((size + nul) << 1)));
                System::Text::Encoding::get_BigEndianUnicode()->GetBytes_3384066dd8b91ed8(value, 0, size, this->_password, 0);
            }
             else 
            {
                this->_password = (new cli::array<unsigned char>(2));
            }
        }
         else 
        {
            this->_password = nullptr;
        }
        return;
    }
    
    int32_t PKCS12::get_IterationCount() {
        return this->_iterations;
    }
    
    int32_t PKCS12::set_IterationCount(int32_t value) {
        this->_iterations = value;
        return get_IterationCount();
    }
    
    System::Collections::ArrayList* PKCS12::get_Keys() {
        if(this->_keyBagsChanged) 
        {
            this->_keyBags->Clear_cd6654e5a40f5056();
            for(auto tmp_120 : this->_safeBags) {
                auto sb = cli::cast<SafeBag*>(tmp_120);
                {
                    if(sb->get_BagOID()->Equals5(_T("1.2.840.113549.1.12.10.1.1"))) 
                    {
                        Mono::Security::ASN1 *safeBag = sb->get_ASN1();
                        Mono::Security::ASN1 *bagValue = safeBag->get_Item(1);
                        Mono::Security::Cryptography::PrivateKeyInfo *pki = cli::gcnew<Mono::Security::Cryptography::PrivateKeyInfo>(bagValue->get_Value());
                        cli::array<unsigned char> *privateKey = pki->get_PrivateKey();
                        switch(privateKey->at(0)) {
                            case 2: case_474: {
                                System::Security::Cryptography::DSAParameters p = cli::ctor<System::Security::Cryptography::DSAParameters>();
                                this->_keyBags->Add_e6a92085999ce388(Mono::Security::Cryptography::PrivateKeyInfo::DecodeDSA(privateKey, p));
                                break;
                            }
                            case 48: case_475: {
                                this->_keyBags->Add_e6a92085999ce388(Mono::Security::Cryptography::PrivateKeyInfo::DecodeRSA(privateKey));
                                break;
                            }
                            default: case_476: {
                                break;
                            }
                        }
                        System::Array::Clear2(privateKey, 0, privateKey->get_Length());
                    }
                     else 
                    {
                        if(sb->get_BagOID()->Equals5(_T("1.2.840.113549.1.12.10.1.2"))) 
                        {
                            Mono::Security::ASN1 *safeBag = sb->get_ASN1();
                            Mono::Security::ASN1 *bagValue = safeBag->get_Item(1);
                            Mono::Security::Cryptography::EncryptedPrivateKeyInfo *epki = cli::gcnew<Mono::Security::Cryptography::EncryptedPrivateKeyInfo>(bagValue->get_Value());
                            cli::array<unsigned char> *decrypted = Decrypt(epki->get_Algorithm(), epki->get_Salt(), epki->get_IterationCount(), epki->get_EncryptedData());
                            Mono::Security::Cryptography::PrivateKeyInfo *pki = cli::gcnew<Mono::Security::Cryptography::PrivateKeyInfo>(decrypted);
                            cli::array<unsigned char> *privateKey = pki->get_PrivateKey();
                            switch(privateKey->at(0)) {
                                case 2: case_477: {
                                    System::Security::Cryptography::DSAParameters p = cli::ctor<System::Security::Cryptography::DSAParameters>();
                                    this->_keyBags->Add_e6a92085999ce388(Mono::Security::Cryptography::PrivateKeyInfo::DecodeDSA(privateKey, p));
                                    break;
                                }
                                case 48: case_478: {
                                    this->_keyBags->Add_e6a92085999ce388(Mono::Security::Cryptography::PrivateKeyInfo::DecodeRSA(privateKey));
                                    break;
                                }
                                default: case_479: {
                                    break;
                                }
                            }
                            System::Array::Clear2(privateKey, 0, privateKey->get_Length());
                            System::Array::Clear2(decrypted, 0, decrypted->get_Length());
                        }
                    }
                }
            }
            this->_keyBagsChanged = false;
        }
        return System::Collections::ArrayList::ReadOnly(this->_keyBags);
    }
    
    System::Collections::ArrayList* PKCS12::get_Secrets() {
        if(this->_secretBagsChanged) 
        {
            this->_secretBags->Clear_cd6654e5a40f5056();
            for(auto tmp_121 : this->_safeBags) {
                auto sb = cli::cast<SafeBag*>(tmp_121);
                {
                    if(sb->get_BagOID()->Equals5(_T("1.2.840.113549.1.12.10.1.5"))) 
                    {
                        Mono::Security::ASN1 *safeBag = sb->get_ASN1();
                        Mono::Security::ASN1 *bagValue = safeBag->get_Item(1);
                        cli::array<unsigned char> *secret = bagValue->get_Value();
                        this->_secretBags->Add_e6a92085999ce388(secret);
                    }
                }
            }
            this->_secretBagsChanged = false;
        }
        return System::Collections::ArrayList::ReadOnly(this->_secretBags);
    }
    
    X509CertificateCollection* PKCS12::get_Certificates() {
        if(this->_certsChanged) 
        {
            this->_certs->Clear();
            for(auto tmp_122 : this->_safeBags) {
                auto sb = cli::cast<SafeBag*>(tmp_122);
                {
                    if(sb->get_BagOID()->Equals5(_T("1.2.840.113549.1.12.10.1.3"))) 
                    {
                        Mono::Security::ASN1 *safeBag = sb->get_ASN1();
                        Mono::Security::ASN1 *bagValue = safeBag->get_Item(1);
                        Mono::Security::ContentInfo *cert = cli::gcnew<Mono::Security::ContentInfo>(bagValue->get_Value());
                        this->_certs->Add2(cli::gcnew<X509Certificate>(cert->get_Content()->get_Item(0)->get_Value()));
                    }
                }
            }
            this->_certsChanged = false;
        }
        return this->_certs;
    }
    
    System::Security::Cryptography::RandomNumberGenerator* PKCS12::get_RNG() {
        if((this->_rng ==  nullptr)) 
        {
            this->_rng = System::Security::Cryptography::RandomNumberGenerator::Create();
        }
        return this->_rng;
    }
    
    int32_t PKCS12::get_MaximumPasswordLength() {
        return password_max_length;
    }
    
    int32_t PKCS12::set_MaximumPasswordLength(int32_t value) {
        if((value < 32)) 
        {
            System::String *msg = Locale::GetText2(_T("Maximum password length cannot be less than {0}."), (new cli::array<System::Object*>({cli::box(32)})));
            throw cli::gcnew<System::ArgumentOutOfRangeException>(msg);
        }
        password_max_length = value;
        return get_MaximumPasswordLength();
    }
    
}}}
namespace Mono { namespace Security { namespace X509 {
    
    cli::array<unsigned char>*  TestAnchors::rootagency;
    cli::array<unsigned char>*  TestAnchors::monoTestRoot;
    
    TestAnchors::TestAnchors()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void TestAnchors::static_constructor() {
        TrustAnchors::coll->Add2(cli::gcnew<X509Certificate>(rootagency));
        TrustAnchors::coll->Add2(cli::gcnew<X509Certificate>(monoTestRoot));
    }
    
    void TestAnchors::constructor() {
    }
    
}}}
namespace Mono { namespace Security { namespace X509 {
    
    cli::array<unsigned char>*  TrustAnchors::msroot;
    cli::array<unsigned char>*  TrustAnchors::verisign;
    cli::array<unsigned char>*  TrustAnchors::verisign_ts_root;
    cli::array<unsigned char>*  TrustAnchors::oldverisign;
    cli::array<unsigned char>*  TrustAnchors::thawte;
    X509CertificateCollection*  TrustAnchors::coll;
    
    TrustAnchors::TrustAnchors()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void TrustAnchors::static_constructor() {
        coll = cli::gcnew<X509CertificateCollection>();
        coll->Add2(cli::gcnew<X509Certificate>(msroot));
        coll->Add2(cli::gcnew<X509Certificate>(verisign));
        coll->Add2(cli::gcnew<X509Certificate>(verisign_ts_root));
        coll->Add2(cli::gcnew<X509Certificate>(thawte));
    }
    
    void TrustAnchors::constructor() {
    }
    
    X509CertificateCollection* TrustAnchors::get_Anchors() {
        return coll;
    }
    
}}}
namespace Mono { namespace Security { namespace X509 {
    
    cli::array<unsigned char>*  X501::countryName;
    cli::array<unsigned char>*  X501::organizationName;
    cli::array<unsigned char>*  X501::organizationalUnitName;
    cli::array<unsigned char>*  X501::commonName;
    cli::array<unsigned char>*  X501::localityName;
    cli::array<unsigned char>*  X501::stateOrProvinceName;
    cli::array<unsigned char>*  X501::streetAddress;
    cli::array<unsigned char>*  X501::domainComponent;
    cli::array<unsigned char>*  X501::userid;
    cli::array<unsigned char>*  X501::email;
    cli::array<unsigned char>*  X501::dnQualifier;
    cli::array<unsigned char>*  X501::title;
    cli::array<unsigned char>*  X501::surname;
    cli::array<unsigned char>*  X501::givenName;
    cli::array<unsigned char>*  X501::initial;
    System::Collections::Generic::Dictionary<System::String*, int32_t>*  X501::__f__switch_map5;
    
    X501::X501()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void X501::constructor() {
    }
    
    void X501::static_constructor() {
    }
    
    System::String* X501::ToString2(Mono::Security::ASN1* seq) {
        System::Text::StringBuilder *sb = cli::gcnew<System::Text::StringBuilder>();
        for(int32_t i = 0; (i < seq->get_Count()); i++){
            Mono::Security::ASN1 *entry = seq->get_Item(i);
            AppendEntry(sb, entry, true);
            if((i < (seq->get_Count() - 1))) 
            {
                sb->Append2(_T(", "));
            }
        }
        return sb->ToString_1636a0751cb9ac11();
    }
    
    System::String* X501::ToString3(Mono::Security::ASN1* seq, bool reversed, System::String* separator, bool quotes) {
        System::Text::StringBuilder *sb = cli::gcnew<System::Text::StringBuilder>();
        if(reversed) 
        {
            for(int32_t i = (seq->get_Count() - 1); (i >= 0); i--){
                Mono::Security::ASN1 *entry = seq->get_Item(i);
                AppendEntry(sb, entry, quotes);
                if((i > 0)) 
                {
                    sb->Append2(separator);
                }
            }
        }
         else 
        {
            for(int32_t i = 0; (i < seq->get_Count()); i++){
                Mono::Security::ASN1 *entry = seq->get_Item(i);
                AppendEntry(sb, entry, quotes);
                if((i < (seq->get_Count() - 1))) 
                {
                    sb->Append2(separator);
                }
            }
        }
        return sb->ToString_1636a0751cb9ac11();
    }
    
    void X501::AppendEntry(System::Text::StringBuilder* sb, Mono::Security::ASN1* entry, bool quotes) {
        for(int32_t k = 0; (k < entry->get_Count()); k++){
            Mono::Security::ASN1 *pair = entry->get_Item(k);
            Mono::Security::ASN1 *s = pair->get_Item(1);
            if((s ==  nullptr)) 
            {
                continue;
            }
            Mono::Security::ASN1 *poid = pair->get_Item(0);
            if((poid ==  nullptr)) 
            {
                continue;
            }
            if(poid->CompareValue(countryName)) 
            {
                sb->Append2(_T("C="));
            }
             else 
            {
                if(poid->CompareValue(organizationName)) 
                {
                    sb->Append2(_T("O="));
                }
                 else 
                {
                    if(poid->CompareValue(organizationalUnitName)) 
                    {
                        sb->Append2(_T("OU="));
                    }
                     else 
                    {
                        if(poid->CompareValue(commonName)) 
                        {
                            sb->Append2(_T("CN="));
                        }
                         else 
                        {
                            if(poid->CompareValue(localityName)) 
                            {
                                sb->Append2(_T("L="));
                            }
                             else 
                            {
                                if(poid->CompareValue(stateOrProvinceName)) 
                                {
                                    sb->Append2(_T("S="));
                                }
                                 else 
                                {
                                    if(poid->CompareValue(streetAddress)) 
                                    {
                                        sb->Append2(_T("STREET="));
                                    }
                                     else 
                                    {
                                        if(poid->CompareValue(domainComponent)) 
                                        {
                                            sb->Append2(_T("DC="));
                                        }
                                         else 
                                        {
                                            if(poid->CompareValue(userid)) 
                                            {
                                                sb->Append2(_T("UID="));
                                            }
                                             else 
                                            {
                                                if(poid->CompareValue(email)) 
                                                {
                                                    sb->Append2(_T("E="));
                                                }
                                                 else 
                                                {
                                                    if(poid->CompareValue(dnQualifier)) 
                                                    {
                                                        sb->Append2(_T("dnQualifier="));
                                                    }
                                                     else 
                                                    {
                                                        if(poid->CompareValue(title)) 
                                                        {
                                                            sb->Append2(_T("T="));
                                                        }
                                                         else 
                                                        {
                                                            if(poid->CompareValue(surname)) 
                                                            {
                                                                sb->Append2(_T("SN="));
                                                            }
                                                             else 
                                                            {
                                                                if(poid->CompareValue(givenName)) 
                                                                {
                                                                    sb->Append2(_T("G="));
                                                                }
                                                                 else 
                                                                {
                                                                    if(poid->CompareValue(initial)) 
                                                                    {
                                                                        sb->Append2(_T("I="));
                                                                    }
                                                                     else 
                                                                    {
                                                                        sb->Append2(_T("OID."));
                                                                        sb->Append2(Mono::Security::ASN1Convert::ToOid(poid));
                                                                        sb->Append2(_T("="));
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            System::String *sValue = nullptr;
            if(((int32_t)(s->get_Tag()) ==  30)) 
            {
                System::Text::StringBuilder *sb2 = cli::gcnew<System::Text::StringBuilder>();
                for(int32_t j = 1; (j < s->get_Value()->get_Length()); (j = j + 2)) {
                    sb2->Append16((char16_t)s->get_Value()->at(j));
                }
                sValue = sb2->ToString_1636a0751cb9ac11();
            }
             else 
            {
                if(((int32_t)(s->get_Tag()) ==  20)) 
                {
                    sValue = System::Text::Encoding::get_UTF7()->GetString_12d22365648431d7(s->get_Value());
                }
                 else 
                {
                    sValue = System::Text::Encoding::get_UTF8()->GetString_12d22365648431d7(s->get_Value());
                }
                cli::array<char16_t> *specials = (new cli::array<char16_t>({u',', u'+', u'"', u'\\', u'<', u'>', u';'}));
                if(quotes) 
                {
                    if((((sValue->IndexOfAny3(specials, 0, sValue->get_Length()) > 0) || sValue->StartsWith(_T(" "))) || sValue->EndsWith(_T(" ")))) 
                    {
                        sValue = cli::concat(_T("\""), sValue);
                    }
                }
            }
            sb->Append2(sValue);
            if((k < (entry->get_Count() - 1))) 
            {
                sb->Append2(_T(", "));
            }
        }
    }
    
    AttributeTypeAndValue* X501::GetAttributeFromOid(System::String* attributeType) {
        System::String *s = attributeType->ToUpper2(System::Globalization::CultureInfo::get_InvariantCulture())->Trim();
        System::String* tmp_123 = s;
        ::System::Int32 tmp_124 = -1;
        if(::System::String::Equals3(tmp_123, _T("C"))) tmp_124 = 0;
        if(::System::String::Equals3(tmp_123, _T("O"))) tmp_124 = 1;
        if(::System::String::Equals3(tmp_123, _T("OU"))) tmp_124 = 2;
        if(::System::String::Equals3(tmp_123, _T("CN"))) tmp_124 = 3;
        if(::System::String::Equals3(tmp_123, _T("L"))) tmp_124 = 4;
        if(::System::String::Equals3(tmp_123, _T("S")) ||
        ::System::String::Equals3(tmp_123, _T("ST"))) tmp_124 = 5;
        if(::System::String::Equals3(tmp_123, _T("E"))) tmp_124 = 6;
        if(::System::String::Equals3(tmp_123, _T("DC"))) tmp_124 = 7;
        if(::System::String::Equals3(tmp_123, _T("UID"))) tmp_124 = 8;
        if(::System::String::Equals3(tmp_123, _T("DNQUALIFIER"))) tmp_124 = 9;
        if(::System::String::Equals3(tmp_123, _T("T"))) tmp_124 = 10;
        if(::System::String::Equals3(tmp_123, _T("SN"))) tmp_124 = 11;
        if(::System::String::Equals3(tmp_123, _T("G"))) tmp_124 = 12;
        if(::System::String::Equals3(tmp_123, _T("I"))) tmp_124 = 13;
        switch(tmp_124)
        {
            case 0: case_480: 
            {
                return cli::gcnew<CountryName>();
            }
            case 1: case_481: 
            {
                return cli::gcnew<OrganizationName>();
            }
            case 2: case_482: 
            {
                return cli::gcnew<OrganizationalUnitName>();
            }
            case 3: case_483: 
            {
                return cli::gcnew<CommonName>();
            }
            case 4: case_484: 
            {
                return cli::gcnew<LocalityName>();
            }
            case 5: case_485: 
            {
                return cli::gcnew<StateOrProvinceName>();
            }
            case 6: case_486: 
            {
                return cli::gcnew<EmailAddress>();
            }
            case 7: case_487: 
            {
                return cli::gcnew<DomainComponent>();
            }
            case 8: case_488: 
            {
                return cli::gcnew<UserId>();
            }
            case 9: case_489: 
            {
                return cli::gcnew<DnQualifier>();
            }
            case 10: case_490: 
            {
                return cli::gcnew<Title>();
            }
            case 11: case_491: 
            {
                return cli::gcnew<Surname>();
            }
            case 12: case_492: 
            {
                return cli::gcnew<GivenName>();
            }
            case 13: case_493: 
            {
                return cli::gcnew<Initial>();
            }
            default: case_494: 
            {
                if(s->StartsWith(_T("OID."))) 
                {
                    return cli::gcnew<Oid2>(s->Substring(4));
                }
                 else 
                {
                    if(IsOid(s)) 
                    {
                        return cli::gcnew<Oid2>(s);
                    }
                     else 
                    {
                        return nullptr;
                    }
                }
            }
        }
    }
    
    bool X501::IsOid(System::String* oid) {
        try {
            Mono::Security::ASN1 *asn = Mono::Security::ASN1Convert::FromOid(oid);
            return ((int32_t)(asn->get_Tag()) ==  6);
        }
        catch(...) {
            return false;
        }
    }
    
    AttributeTypeAndValue* X501::ReadAttribute(System::String* value, int32_t pos) {
        while((((int32_t)(value->get_Chars(pos)) ==  32) && (pos < value->get_Length()))) pos++;
        int32_t equal = value->IndexOf5(u'=', pos);
        if((equal ==  -1)) 
        {
            System::String *msg = Locale::GetText(_T("No attribute found."));
            throw cli::gcnew<System::FormatException>(msg);
        }
        System::String *s = value->Substring2(pos, (equal - pos));
        AttributeTypeAndValue *atv = GetAttributeFromOid(s);
        if((atv ==  nullptr)) 
        {
            System::String *msg = Locale::GetText(_T("Unknown attribute \'{0}\'."));
            throw cli::gcnew<System::FormatException>(System::String::Format2(msg, s));
        }
        pos = (equal + 1);
        return atv;
    }
    
    bool X501::IsHex(char16_t c) {
        if(System::Char::IsDigit(c)) 
        {
            return true;
        }
        char16_t up = System::Char::ToUpper2(c, System::Globalization::CultureInfo::get_InvariantCulture());
        return (((int32_t)(up) >= 65) && ((int32_t)(up) <= 70));
    }
    
    System::String* X501::ReadHex(System::String* value, int32_t pos) {
        System::Text::StringBuilder *sb = cli::gcnew<System::Text::StringBuilder>();
        sb->Append16(value->get_Chars(pos++));
        sb->Append16(value->get_Chars(pos));
        if((((pos < (value->get_Length() - 4)) && ((int32_t)(value->get_Chars((pos + 1))) ==  92)) && IsHex(value->get_Chars((pos + 2))))) 
        {
            (pos = pos + 2);
            sb->Append16(value->get_Chars(pos++));
            sb->Append16(value->get_Chars(pos));
        }
        cli::array<unsigned char> *data = Mono::Security::Cryptography::CryptoConvert::FromHex(sb->ToString_1636a0751cb9ac11());
        return System::Text::Encoding::get_UTF8()->GetString_12d22365648431d7(data);
    }
    
    int32_t X501::ReadEscaped(System::Text::StringBuilder* sb, System::String* value, int32_t pos) {
        switch(value->get_Chars(pos)) {
            case u'\\': case u'"': case u'=': case u';': case u'<': case u'>': case u'+': case u'#': case u',': case_495: {
                sb->Append16(value->get_Chars(pos));
                return pos;
            }
            default: case_496: {
                if((pos >= (value->get_Length() - 2))) 
                {
                    System::String *msg = Locale::GetText(_T("Malformed escaped value \'{0}\'."));
                    throw cli::gcnew<System::FormatException>(System::String::Format2(msg, value->Substring(pos)));
                }
                sb->Append2(ReadHex(value, pos));
                return pos;
            }
        }
    }
    
    int32_t X501::ReadQuoted(System::Text::StringBuilder* sb, System::String* value, int32_t pos) {
        int32_t original = pos;
        while((pos <= value->get_Length())) {
            switch(value->get_Chars(pos)) {
                case u'"': case_497: {
                    return pos;
                }
                case u'\\': case_498: {
                    return ReadEscaped(sb, value, pos);
                }
                default: case_499: {
                    sb->Append16(value->get_Chars(pos));
                    pos++;
                    break;
                }
            }
        }
        System::String *msg = Locale::GetText(_T("Malformed quoted value \'{0}\'."));
        throw cli::gcnew<System::FormatException>(System::String::Format2(msg, value->Substring(original)));
    }
    
    System::String* X501::ReadValue(System::String* value, int32_t pos) {
        int32_t original = pos;
        System::Text::StringBuilder *sb = cli::gcnew<System::Text::StringBuilder>();
        while((pos < value->get_Length())) {
            switch(value->get_Chars(pos)) {
                case u'\\': case_500: {
                    pos = ReadEscaped(sb, value, ++pos);
                    break;
                }
                case u'"': case_501: {
                    pos = ReadQuoted(sb, value, ++pos);
                    break;
                }
                case u'=': case u';': case u'<': case u'>': case_502: {
                    System::String *msg = Locale::GetText(_T("Malformed value \'{0}\' contains \'{1}\' outside quotes."));
                    throw cli::gcnew<System::FormatException>(System::String::Format3(msg, value->Substring(original), cli::box(value->get_Chars(pos))));
                }
                case u'+': case u'#': case_503: {
                    throw cli::gcnew<System::NotImplementedException>();
                }
                case u',': case_504: {
                    pos++;
                    return sb->ToString_1636a0751cb9ac11();
                }
                default: case_505: {
                    sb->Append16(value->get_Chars(pos));
                    break;
                }
            }
            pos++;
        }
        return sb->ToString_1636a0751cb9ac11();
    }
    
    Mono::Security::ASN1* X501::FromString(System::String* rdn) {
        if((rdn ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("rdn"));
        }
        int32_t pos = 0;
        Mono::Security::ASN1 *asn1 = cli::gcnew<Mono::Security::ASN1>(48);
        while((pos < rdn->get_Length())) {
            AttributeTypeAndValue *atv = ReadAttribute(rdn, pos);
            atv->set_Value(ReadValue(rdn, pos));
            Mono::Security::ASN1 *sequence = cli::gcnew<Mono::Security::ASN1>(49);
            sequence->Add(atv->GetASN12());
            asn1->Add(sequence);
        }
        return asn1;
    }
    
}}}
namespace Mono { namespace Security { namespace X509 {
    
    System::String*  X509Certificate::encoding_error;
    
    X509Certificate::X509Certificate()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void X509Certificate::constructor(cli::array<unsigned char>* data) {
        if((data != nullptr)) 
        {
            if(((data->get_Length() > 0) && ((int32_t)(data->at(0)) != 48))) 
            {
                try {
                    data = PEM(_T("CERTIFICATE"), data);
                }
                catch(System::Exception* ex) {
                    throw cli::gcnew<System::Security::Cryptography::CryptographicException>(encoding_error, ex);
                }
            }
            Parse(data);
        }
    }
    
    void X509Certificate::constructor(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        Parse(cli::cast<cli::array<unsigned char>*>(info->GetValue(_T("raw"), cli::typeof<System::Type>::info)));
    }
    
    void X509Certificate::static_constructor() {
    }
    
    void X509Certificate::Parse(cli::array<unsigned char>* data) {
        try {
            this->decoder = cli::gcnew<Mono::Security::ASN1>(data);
            if(((int32_t)(this->decoder->get_Tag()) != 48)) 
            {
                throw cli::gcnew<System::Security::Cryptography::CryptographicException>(encoding_error);
            }
            if(((int32_t)(this->decoder->get_Item(0)->get_Tag()) != 48)) 
            {
                throw cli::gcnew<System::Security::Cryptography::CryptographicException>(encoding_error);
            }
            Mono::Security::ASN1 *tbsCertificate = this->decoder->get_Item(0);
            int32_t tbs = 0;
            Mono::Security::ASN1 *v = this->decoder->get_Item(0)->get_Item(tbs);
            this->version = 1;
            if((((int32_t)(v->get_Tag()) ==  160) && (v->get_Count() > 0))) 
            {
                (this->version = this->version + (int32_t)(v->get_Item(0)->get_Value()->at(0)));
                tbs++;
            }
            Mono::Security::ASN1 *sn = this->decoder->get_Item(0)->get_Item(tbs++);
            if(((int32_t)(sn->get_Tag()) != 2)) 
            {
                throw cli::gcnew<System::Security::Cryptography::CryptographicException>(encoding_error);
            }
            this->serialnumber = sn->get_Value();
            System::Array::Reverse2(this->serialnumber, 0, this->serialnumber->get_Length());
            tbs++;
            this->issuer = tbsCertificate->Element2(tbs++, 48);
            this->m_issuername = X501::ToString2(this->issuer);
            Mono::Security::ASN1 *validity = tbsCertificate->Element2(tbs++, 48);
            Mono::Security::ASN1 *notBefore = validity->get_Item(0);
            this->m_from = Mono::Security::ASN1Convert::ToDateTime(notBefore);
            Mono::Security::ASN1 *notAfter = validity->get_Item(1);
            this->m_until = Mono::Security::ASN1Convert::ToDateTime(notAfter);
            this->subject = tbsCertificate->Element2(tbs++, 48);
            this->m_subject = X501::ToString2(this->subject);
            Mono::Security::ASN1 *subjectPublicKeyInfo = tbsCertificate->Element2(tbs++, 48);
            Mono::Security::ASN1 *algorithm = subjectPublicKeyInfo->Element2(0, 48);
            Mono::Security::ASN1 *algo = algorithm->Element2(0, 6);
            this->m_keyalgo = Mono::Security::ASN1Convert::ToOid(algo);
            Mono::Security::ASN1 *parameters = algorithm->get_Item(1);
            this->m_keyalgoparams = (algorithm->get_Count() > 1) ? parameters->GetBytes_b91405229279a4ac() : nullptr;
            Mono::Security::ASN1 *subjectPublicKey = subjectPublicKeyInfo->Element2(1, 3);
            int32_t n = (subjectPublicKey->get_Length() - 1);
            this->m_publickey = (new cli::array<unsigned char>(n));
            System::Buffer::BlockCopy(subjectPublicKey->get_Value(), 1, this->m_publickey, 0, n);
            cli::array<unsigned char> *bitstring = this->decoder->get_Item(2)->get_Value();
            this->signature = (new cli::array<unsigned char>((bitstring->get_Length() - 1)));
            System::Buffer::BlockCopy(bitstring, 1, this->signature, 0, this->signature->get_Length());
            algorithm = this->decoder->get_Item(1);
            algo = algorithm->Element2(0, 6);
            this->m_signaturealgo = Mono::Security::ASN1Convert::ToOid(algo);
            parameters = algorithm->get_Item(1);
            if((parameters != nullptr)) 
            {
                this->m_signaturealgoparams = parameters->GetBytes_b91405229279a4ac();
            }
             else 
            {
                this->m_signaturealgoparams = nullptr;
            }
            Mono::Security::ASN1 *issuerUID = tbsCertificate->Element2(tbs, 129);
            if((issuerUID != nullptr)) 
            {
                tbs++;
                this->issuerUniqueID = issuerUID->get_Value();
            }
            Mono::Security::ASN1 *subjectUID = tbsCertificate->Element2(tbs, 130);
            if((subjectUID != nullptr)) 
            {
                tbs++;
                this->subjectUniqueID = subjectUID->get_Value();
            }
            Mono::Security::ASN1 *extns = tbsCertificate->Element2(tbs, 163);
            if(((extns != nullptr) && (extns->get_Count() ==  1))) 
            {
                this->extensions = cli::gcnew<X509ExtensionCollection>(extns->get_Item(0));
            }
             else 
            {
                this->extensions = cli::gcnew<X509ExtensionCollection>(nullptr);
            }
            this->m_encodedcert = cli::cast<cli::array<unsigned char>*>(cli::import(data)->Clone());
        }
        catch(System::Exception* ex) {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(encoding_error, ex);
        }
    }
    
    cli::array<unsigned char>* X509Certificate::GetUnsignedBigInteger(cli::array<unsigned char>* integer) {
        if(((int32_t)(integer->at(0)) ==  0)) 
        {
            int32_t length = (integer->get_Length() - 1);
            cli::array<unsigned char> *uinteger = (new cli::array<unsigned char>(length));
            System::Buffer::BlockCopy(integer, 1, uinteger, 0, length);
            return uinteger;
        }
         else 
        {
            return integer;
        }
    }
    
    bool X509Certificate::WasCurrent(System::DateTime instant) {
        return (System::DateTime::op_GreaterThan(instant, this->get_ValidFrom_b9a836b86f941230()) && System::DateTime::op_LessThanOrEqual(instant, this->get_ValidUntil_63987634a232abc0()));
    }
    
    bool X509Certificate::VerifySignature(System::Security::Cryptography::DSA* dsa) {
        System::Security::Cryptography::DSASignatureDeformatter *v = cli::gcnew<System::Security::Cryptography::DSASignatureDeformatter>(dsa);
        v->SetHashAlgorithm_5a7fb9c08aaf7ac9(_T("SHA1"));
        return v->VerifySignature_ecf649797288645c(this->get_Hash(), this->get_Signature_70c9a3cf49c25627());
    }
    
    System::String* X509Certificate::GetHashNameFromOID(System::String* oid) {
        System::String* tmp_125 = oid;
        ::System::Int32 tmp_126 = -1;
        if(::System::String::Equals3(tmp_125, _T("1.2.840.113549.1.1.2"))) tmp_126 = 0;
        if(::System::String::Equals3(tmp_125, _T("1.2.840.113549.1.1.4"))) tmp_126 = 1;
        if(::System::String::Equals3(tmp_125, _T("1.2.840.113549.1.1.5")) ||
        ::System::String::Equals3(tmp_125, _T("1.3.14.3.2.29"))) tmp_126 = 2;
        switch(tmp_126)
        {
            case 0: case_506: 
            {
                return _T("MD2");
            }
            case 1: case_507: 
            {
                return _T("MD5");
            }
            case 2: case_508: 
            {
                return _T("SHA1");
            }
            default: case_509: 
            {
                return nullptr;
            }
        }
    }
    
    bool X509Certificate::VerifySignature2(System::Security::Cryptography::RSA* rsa) {
        System::Security::Cryptography::RSAPKCS1SignatureDeformatter *v = cli::gcnew<System::Security::Cryptography::RSAPKCS1SignatureDeformatter>(rsa);
        System::String *hashName = GetHashNameFromOID(this->m_signaturealgo);
        if((hashName ==  nullptr)) 
        {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(cli::concat(_T("Unsupported hash algorithm: "), this->m_signaturealgo));
        }
        v->SetHashAlgorithm_5a7fb9c08aaf7ac9(hashName);
        return v->VerifySignature_ecf649797288645c(this->get_Hash(), this->get_Signature_70c9a3cf49c25627());
    }
    
    bool X509Certificate::VerifySignature3(System::Security::Cryptography::AsymmetricAlgorithm* aa) {
        if((aa ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("aa"));
        }
        if(cli::is<System::Security::Cryptography::RSA>(aa)) 
        {
            return VerifySignature2(cli::as<System::Security::Cryptography::RSA*>(aa));
        }
         else 
        {
            if(cli::is<System::Security::Cryptography::DSA>(aa)) 
            {
                return VerifySignature(cli::as<System::Security::Cryptography::DSA*>(aa));
            }
             else 
            {
                throw cli::gcnew<System::NotSupportedException>(cli::concat(_T("Unknown Asymmetric Algorithm "), aa->ToString_1636a0751cb9ac11()));
            }
        }
    }
    
    bool X509Certificate::CheckSignature(cli::array<unsigned char>* hash, System::String* hashAlgorithm, cli::array<unsigned char>* signature) {
        System::Security::Cryptography::RSACryptoServiceProvider *r = cli::cast<System::Security::Cryptography::RSACryptoServiceProvider*>(this->get_RSA_32368d0ddec581fa());
        return r->VerifyHash(hash, hashAlgorithm, signature);
    }
    
    Mono::Security::ASN1* X509Certificate::GetIssuerName() {
        return this->issuer;
    }
    
    Mono::Security::ASN1* X509Certificate::GetSubjectName() {
        return this->subject;
    }
    
    void X509Certificate::GetObjectData_d40d37eb78c2fb36(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        info->AddValue16(_T("raw"), this->m_encodedcert);
    }
    
    cli::array<unsigned char>* X509Certificate::PEM(System::String* type, cli::array<unsigned char>* data) {
        System::String *pem = System::Text::Encoding::get_ASCII()->GetString_12d22365648431d7(data);
        System::String *header = System::String::Format2(_T("-----BEGIN {0}-----"), type);
        System::String *footer = System::String::Format2(_T("-----END {0}-----"), type);
        int32_t start = (pem->IndexOf7(header) + header->get_Length());
        int32_t end = pem->IndexOf8(footer, start);
        System::String *base64 = pem->Substring2(start, (end - start));
        return System::Convert::FromBase64String(base64);
    }
    
    System::Security::Cryptography::DSA* X509Certificate::get_DSA() {
        if((this->m_keyalgoparams ==  nullptr)) 
        {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(_T("Missing key algorithm parameters."));
        }
        if((this->_dsa ==  nullptr)) 
        {
            System::Security::Cryptography::DSAParameters dsaParams = cli::ctor<System::Security::Cryptography::DSAParameters>();
            Mono::Security::ASN1 *pubkey = cli::gcnew<Mono::Security::ASN1>(this->m_publickey);
            if(((pubkey ==  nullptr) || ((int32_t)(pubkey->get_Tag()) != 2))) 
            {
                return nullptr;
            }
            dsaParams->Y = GetUnsignedBigInteger(pubkey->get_Value());
            Mono::Security::ASN1 *param = cli::gcnew<Mono::Security::ASN1>(this->m_keyalgoparams);
            if((((param ==  nullptr) || ((int32_t)(param->get_Tag()) != 48)) || (param->get_Count() < 3))) 
            {
                return nullptr;
            }
            if(((((int32_t)(param->get_Item(0)->get_Tag()) != 2) || ((int32_t)(param->get_Item(1)->get_Tag()) != 2)) || ((int32_t)(param->get_Item(2)->get_Tag()) != 2))) 
            {
                return nullptr;
            }
            dsaParams->P = GetUnsignedBigInteger(param->get_Item(0)->get_Value());
            dsaParams->Q = GetUnsignedBigInteger(param->get_Item(1)->get_Value());
            dsaParams->G = GetUnsignedBigInteger(param->get_Item(2)->get_Value());
            this->_dsa = cli::cast<System::Security::Cryptography::DSA*>(cli::gcnew<System::Security::Cryptography::DSACryptoServiceProvider>((dsaParams->Y->get_Length() << 3)));
            this->_dsa->ImportParameters_42bffe0948290f21(dsaParams);
        }
        return this->_dsa;
    }
    
    System::Security::Cryptography::DSA* X509Certificate::set_DSA(System::Security::Cryptography::DSA* value) {
        this->_dsa = value;
        if((value != nullptr)) 
        {
            this->_rsa = nullptr;
        }
        return get_DSA();
    }
    
    X509ExtensionCollection* X509Certificate::get_Extensions() {
        return this->extensions;
    }
    
    cli::array<unsigned char>* X509Certificate::get_Hash() {
        if((this->certhash ==  nullptr)) 
        {
            System::Security::Cryptography::HashAlgorithm *hash = nullptr;
            System::String* tmp_127 = this->m_signaturealgo;
            ::System::Int32 tmp_128 = -1;
            if(::System::String::Equals3(tmp_127, _T("1.2.840.113549.1.1.2"))) tmp_128 = 0;
            if(::System::String::Equals3(tmp_127, _T("1.2.840.113549.1.1.4"))) tmp_128 = 1;
            if(::System::String::Equals3(tmp_127, _T("1.2.840.113549.1.1.5")) ||
            ::System::String::Equals3(tmp_127, _T("1.3.14.3.2.29")) ||
            ::System::String::Equals3(tmp_127, _T("1.2.840.10040.4.3"))) tmp_128 = 2;
            switch(tmp_128)
            {
                case 0: case_510: 
                {
                    hash = System::Security::Cryptography::HashAlgorithm::Create2(_T("MD2"));
                    break;
                }
                case 1: case_511: 
                {
                    hash = System::Security::Cryptography::MD5::Create3();
                    break;
                }
                case 2: case_512: 
                {
                    hash = System::Security::Cryptography::SHA1::Create3();
                    break;
                }
                default: case_513: 
                {
                    return nullptr;
                }
            }
            if(((this->decoder ==  nullptr) || (this->decoder->get_Count() < 1))) 
            {
                return nullptr;
            }
            cli::array<unsigned char> *toBeSigned = this->decoder->get_Item(0)->GetBytes_b91405229279a4ac();
            this->certhash = hash->ComputeHash2(toBeSigned, 0, toBeSigned->get_Length());
        }
        return cli::cast<cli::array<unsigned char>*>(cli::import(this->certhash)->Clone());
    }
    
    System::String* X509Certificate::get_IssuerName_25458e2c269ceeaa() {
        return this->m_issuername;
    }
    
    System::String* X509Certificate::get_KeyAlgorithm_26169b6c5ae631ca() {
        return this->m_keyalgo;
    }
    
    cli::array<unsigned char>* X509Certificate::get_KeyAlgorithmParameters_7dd2925ed6c97721() {
        if((this->m_keyalgoparams ==  nullptr)) 
        {
            return nullptr;
        }
        return cli::cast<cli::array<unsigned char>*>(cli::import(this->m_keyalgoparams)->Clone());
    }
    
    cli::array<unsigned char>* X509Certificate::set_KeyAlgorithmParameters_801b9760d32c6ea0(cli::array<unsigned char>* value) {
        this->m_keyalgoparams = value;
        return get_KeyAlgorithmParameters_7dd2925ed6c97721();
    }
    
    cli::array<unsigned char>* X509Certificate::get_PublicKey_bbce0ec4cf2d16e() {
        if((this->m_publickey ==  nullptr)) 
        {
            return nullptr;
        }
        return cli::cast<cli::array<unsigned char>*>(cli::import(this->m_publickey)->Clone());
    }
    
    System::Security::Cryptography::RSA* X509Certificate::get_RSA_32368d0ddec581fa() {
        if((this->_rsa ==  nullptr)) 
        {
            System::Security::Cryptography::RSAParameters rsaParams = cli::ctor<System::Security::Cryptography::RSAParameters>();
            Mono::Security::ASN1 *pubkey = cli::gcnew<Mono::Security::ASN1>(this->m_publickey);
            Mono::Security::ASN1 *modulus = pubkey->get_Item(0);
            if(((modulus ==  nullptr) || ((int32_t)(modulus->get_Tag()) != 2))) 
            {
                return nullptr;
            }
            Mono::Security::ASN1 *exponent = pubkey->get_Item(1);
            if(((int32_t)(exponent->get_Tag()) != 2)) 
            {
                return nullptr;
            }
            rsaParams->Modulus = GetUnsignedBigInteger(modulus->get_Value());
            rsaParams->Exponent = exponent->get_Value();
            int32_t keySize = (rsaParams->Modulus->get_Length() << 3);
            this->_rsa = cli::cast<System::Security::Cryptography::RSA*>(cli::gcnew<System::Security::Cryptography::RSACryptoServiceProvider>(keySize));
            this->_rsa->ImportParameters_43620ad65e380dd(rsaParams);
        }
        return this->_rsa;
    }
    
    System::Security::Cryptography::RSA* X509Certificate::set_RSA_c0bdcd7611af9c2e(System::Security::Cryptography::RSA* value) {
        if((value != nullptr)) 
        {
            this->_dsa = nullptr;
        }
        this->_rsa = value;
        return get_RSA_32368d0ddec581fa();
    }
    
    cli::array<unsigned char>* X509Certificate::get_RawData_c0a18e988d76611c() {
        if((this->m_encodedcert ==  nullptr)) 
        {
            return nullptr;
        }
        return cli::cast<cli::array<unsigned char>*>(cli::import(this->m_encodedcert)->Clone());
    }
    
    cli::array<unsigned char>* X509Certificate::get_SerialNumber_ac6911419cae47b0() {
        if((this->serialnumber ==  nullptr)) 
        {
            return nullptr;
        }
        return cli::cast<cli::array<unsigned char>*>(cli::import(this->serialnumber)->Clone());
    }
    
    cli::array<unsigned char>* X509Certificate::get_Signature_70c9a3cf49c25627() {
        if((this->signature ==  nullptr)) 
        {
            return nullptr;
        }
        System::String* tmp_129 = this->m_signaturealgo;
        ::System::Int32 tmp_130 = -1;
        if(::System::String::Equals3(tmp_129, _T("1.2.840.113549.1.1.2")) ||
        ::System::String::Equals3(tmp_129, _T("1.2.840.113549.1.1.4")) ||
        ::System::String::Equals3(tmp_129, _T("1.2.840.113549.1.1.5")) ||
        ::System::String::Equals3(tmp_129, _T("1.3.14.3.2.29"))) tmp_130 = 0;
        if(::System::String::Equals3(tmp_129, _T("1.2.840.10040.4.3"))) tmp_130 = 1;
        switch(tmp_130)
        {
            case 0: case_514: 
            {
                return cli::cast<cli::array<unsigned char>*>(cli::import(this->signature)->Clone());
            }
            case 1: case_515: 
            {
                Mono::Security::ASN1 *sign = cli::gcnew<Mono::Security::ASN1>(this->signature);
                if(((sign ==  nullptr) || (sign->get_Count() != 2))) 
                {
                    return nullptr;
                }
                cli::array<unsigned char> *part1 = sign->get_Item(0)->get_Value();
                cli::array<unsigned char> *part2 = sign->get_Item(1)->get_Value();
                cli::array<unsigned char> *sig = (new cli::array<unsigned char>(40));
                int32_t s1 = System::Math::Max5(0, (part1->get_Length() - 20));
                int32_t e1 = System::Math::Max5(0, (20 - part1->get_Length()));
                System::Buffer::BlockCopy(part1, s1, sig, e1, (part1->get_Length() - s1));
                int32_t s2 = System::Math::Max5(0, (part2->get_Length() - 20));
                int32_t e2 = System::Math::Max5(20, (40 - part2->get_Length()));
                System::Buffer::BlockCopy(part2, s2, sig, e2, (part2->get_Length() - s2));
                return sig;
            }
            default: case_516: 
            {
                throw cli::gcnew<System::Security::Cryptography::CryptographicException>(cli::concat(_T("Unsupported hash algorithm: "), this->m_signaturealgo));
            }
        }
    }
    
    System::String* X509Certificate::get_SignatureAlgorithm_95f3bb8eaa3ff774() {
        return this->m_signaturealgo;
    }
    
    cli::array<unsigned char>* X509Certificate::get_SignatureAlgorithmParameters_40b5c25a4236cd23() {
        if((this->m_signaturealgoparams ==  nullptr)) 
        {
            return this->m_signaturealgoparams;
        }
        return cli::cast<cli::array<unsigned char>*>(cli::import(this->m_signaturealgoparams)->Clone());
    }
    
    System::String* X509Certificate::get_SubjectName_8e1ad5a09a5c9697() {
        return this->m_subject;
    }
    
    System::DateTime X509Certificate::get_ValidFrom_b9a836b86f941230() {
        return this->m_from;
    }
    
    System::DateTime X509Certificate::get_ValidUntil_63987634a232abc0() {
        return this->m_until;
    }
    
    int32_t X509Certificate::get_Version() {
        return this->version;
    }
    
    bool X509Certificate::get_IsCurrent() {
        return WasCurrent(System::DateTime::get_UtcNow());
    }
    
    cli::array<unsigned char>* X509Certificate::get_IssuerUniqueIdentifier() {
        if((this->issuerUniqueID ==  nullptr)) 
        {
            return nullptr;
        }
        return cli::cast<cli::array<unsigned char>*>(cli::import(this->issuerUniqueID)->Clone());
    }
    
    cli::array<unsigned char>* X509Certificate::get_SubjectUniqueIdentifier() {
        if((this->subjectUniqueID ==  nullptr)) 
        {
            return nullptr;
        }
        return cli::cast<cli::array<unsigned char>*>(cli::import(this->subjectUniqueID)->Clone());
    }
    
    bool X509Certificate::get_IsSelfSigned() {
        if(System::String::op_Equality(this->m_issuername, this->m_subject)) 
        {
            return VerifySignature2(this->get_RSA_32368d0ddec581fa());
        }
         else 
        {
            return false;
        }
    }
    
}}}
namespace Mono { namespace Security { namespace X509 {
    
    
    void X509CertificateEnumerator::constructor(X509CertificateCollection* mappings) {
        this->enumerator = cli::cast<System::Collections::IEnumerable*>(mappings)->GetEnumerator_674ad93a972a4d67();
    }
    
    bool X509CertificateEnumerator::MoveNext() {
        return this->enumerator->MoveNext_4e78e145935f5417();
    }
    
    void X509CertificateEnumerator::Reset() {
        this->enumerator->Reset_bcd82381eed41868();
    }
    
    bool X509CertificateEnumerator::MoveNext2() {
        return this->enumerator->MoveNext_4e78e145935f5417();
    }
    
    void X509CertificateEnumerator::Reset2() {
        this->enumerator->Reset_bcd82381eed41868();
    }
    
    X509Certificate* X509CertificateEnumerator::get_Current() {
        return cli::cast<X509Certificate*>(this->enumerator->get_Current_8eca9b3da02b123a());
    }
    
    System::Object* X509CertificateEnumerator::get_Current2() {
        return this->enumerator->get_Current_8eca9b3da02b123a();
    }
    
}}}
namespace Mono { namespace Security { namespace X509 {
    
    
    void X509CertificateCollection::constructor() {
    }
    
    void X509CertificateCollection::constructor(cli::array<X509Certificate*>* value) {
        AddRange(value);
    }
    
    void X509CertificateCollection::constructor(X509CertificateCollection* value) {
        AddRange2(value);
    }
    
    int32_t X509CertificateCollection::Add2(X509Certificate* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("value"));
        }
        return this->get_InnerList()->Add_e6a92085999ce388(value);
    }
    
    void X509CertificateCollection::AddRange(cli::array<X509Certificate*>* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("value"));
        }
        for(int32_t i = 0; (i < value->get_Length()); i++) {
            this->get_InnerList()->Add_e6a92085999ce388(value->at(i));
        }
    }
    
    void X509CertificateCollection::AddRange2(X509CertificateCollection* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("value"));
        }
        for(int32_t i = 0; (i < value->get_InnerList()->get_Count_2354963792616712()); i++) {
            this->get_InnerList()->Add_e6a92085999ce388(value->get_Item2(i));
        }
    }
    
    bool X509CertificateCollection::Contains2(X509Certificate* value) {
        return (IndexOf2(value) != -1);
    }
    
    void X509CertificateCollection::CopyTo2(cli::array<X509Certificate*>* array, int32_t index) {
        this->get_InnerList()->CopyTo_2bc540dad3c25b9e(array, index);
    }
    
    X509CertificateEnumerator* X509CertificateCollection::GetEnumerator2() {
        return cli::gcnew<X509CertificateEnumerator>(this);
    }
    
    System::Collections::IEnumerator* X509CertificateCollection::GetEnumerator3() {
        return this->get_InnerList()->GetEnumerator_84e3ba8f2fdefd62();
    }
    
    int32_t X509CertificateCollection::GetHashCode_6648aef0f235ee6c() {
        return this->get_InnerList()->GetHashCode_6648aef0f235ee6c();
    }
    
    int32_t X509CertificateCollection::IndexOf2(X509Certificate* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("value"));
        }
        cli::array<unsigned char> *hash = value->get_Hash();
        for(int32_t i = 0; (i < this->get_InnerList()->get_Count_2354963792616712()); i++){
            X509Certificate *x509 = cli::cast<X509Certificate*>(this->get_InnerList()->get_Item_fd0155f142ae570(i));
            if(Compare(x509->get_Hash(), hash)) 
            {
                return i;
            }
        }
        return -1;
    }
    
    void X509CertificateCollection::Insert2(int32_t index, X509Certificate* value) {
        this->get_InnerList()->Insert_59557a2615bf3b8e(index, value);
    }
    
    void X509CertificateCollection::Remove2(X509Certificate* value) {
        this->get_InnerList()->Remove_2225381aaf812c6d(value);
    }
    
    bool X509CertificateCollection::Compare(cli::array<unsigned char>* array1, cli::array<unsigned char>* array2) {
        if(((array1 ==  nullptr) && (array2 ==  nullptr))) 
        {
            return true;
        }
        if(((array1 ==  nullptr) || (array2 ==  nullptr))) 
        {
            return false;
        }
        if((array1->get_Length() != array2->get_Length())) 
        {
            return false;
        }
        for(int32_t i = 0; (i < array1->get_Length()); i++){
            if(((int32_t)(array1->at(i)) != (int32_t)(array2->at(i)))) 
            {
                return false;
            }
        }
        return true;
    }
    
    X509Certificate* X509CertificateCollection::get_Item2(int32_t index) {
        return cli::cast<X509Certificate*>(this->get_InnerList()->get_Item_fd0155f142ae570(index));
    }
    
    X509Certificate* X509CertificateCollection::set_Item2(int32_t index, X509Certificate* value) {
        this->get_InnerList()->set_Item_9f12782653a34813(index, value);
        return get_Item2(index);
    }
    
}}}
namespace Mono { namespace Security { namespace X509 {
    
    
    void X509Chain::constructor() {
        this->certs = cli::gcnew<X509CertificateCollection>();
    }
    
    void X509Chain::constructor(X509CertificateCollection* chain) {
        this->_chain = cli::gcnew<X509CertificateCollection>();
        this->_chain->AddRange2(chain);
    }
    
    void X509Chain::LoadCertificate(X509Certificate* x509) {
        this->certs->Add2(x509);
    }
    
    void X509Chain::LoadCertificates(X509CertificateCollection* collection) {
        this->certs->AddRange2(collection);
    }
    
    X509Certificate* X509Chain::FindByIssuerName(System::String* issuerName) {
        for(auto tmp_131 : this->certs) {
            auto x = cli::cast<X509Certificate*>(tmp_131);
            {
                if(System::String::op_Equality(x->get_IssuerName_25458e2c269ceeaa(), issuerName)) 
                {
                    return x;
                }
            }
        }
        return nullptr;
    }
    
    bool X509Chain::Build(X509Certificate* leaf) {
        this->_status = X509ChainStatusFlags::NoError;
        if((this->_chain ==  nullptr)) 
        {
            this->_chain = cli::gcnew<X509CertificateCollection>();
            X509Certificate *x = leaf;
            X509Certificate *tmp = x;
            while(((x != nullptr) && !(x->get_IsSelfSigned()))) {
                tmp = x;
                this->_chain->Add2(x);
                x = FindCertificateParent(x);
            }
            this->_root = FindCertificateRoot(tmp);
        }
         else 
        {
            int32_t last = this->_chain->get_Count();
            if((last > 0)) 
            {
                if(IsParent(leaf, this->_chain->get_Item2(0))) 
                {
                    int32_t i = 1;
                    for(; (i < last); i++){
                        if(!(IsParent(this->_chain->get_Item2((i - 1)), this->_chain->get_Item2(i)))) 
                        {
                            break;
                        }
                    }
                    if((i ==  last)) 
                    {
                        this->_root = FindCertificateRoot(this->_chain->get_Item2((last - 1)));
                    }
                }
            }
             else 
            {
                this->_root = FindCertificateRoot(leaf);
            }
        }
        if(((this->_chain != nullptr) && ((int32_t)(this->_status) ==  0))) 
        {
            for(auto tmp_132 : this->_chain) {
                auto x = cli::cast<X509Certificate*>(tmp_132);
                {
                    if(!(IsValid(x))) 
                    {
                        return false;
                    }
                }
            }
            if(!(IsValid(leaf))) 
            {
                if(((int32_t)(this->_status) ==  2)) 
                {
                    this->_status = X509ChainStatusFlags::NotTimeValid;
                }
                return false;
            }
            if(((this->_root != nullptr) && !(IsValid(this->_root)))) 
            {
                return false;
            }
        }
        return ((int32_t)(this->_status) ==  0);
    }
    
    void X509Chain::Reset() {
        this->_status = X509ChainStatusFlags::NoError;
        this->roots = nullptr;
        this->certs->Clear();
        if((this->_chain != nullptr)) 
        {
            this->_chain->Clear();
        }
    }
    
    bool X509Chain::IsValid(X509Certificate* cert) {
        if(!(cert->get_IsCurrent())) 
        {
            this->_status = X509ChainStatusFlags::NotTimeNested;
            return false;
        }
        return true;
    }
    
    X509Certificate* X509Chain::FindCertificateParent(X509Certificate* child) {
        for(auto tmp_133 : this->certs) {
            auto potentialParent = cli::cast<X509Certificate*>(tmp_133);
            {
                if(IsParent(child, potentialParent)) 
                {
                    return potentialParent;
                }
            }
        }
        return nullptr;
    }
    
    X509Certificate* X509Chain::FindCertificateRoot(X509Certificate* potentialRoot) {
        if((potentialRoot ==  nullptr)) 
        {
            this->_status = X509ChainStatusFlags::PartialChain;
            return nullptr;
        }
        if(IsTrusted(potentialRoot)) 
        {
            return potentialRoot;
        }
        for(auto tmp_134 : this->get_TrustAnchors()) {
            auto root = cli::cast<X509Certificate*>(tmp_134);
            {
                if(IsParent(potentialRoot, root)) 
                {
                    return root;
                }
            }
        }
        if(potentialRoot->get_IsSelfSigned()) 
        {
            this->_status = X509ChainStatusFlags::UntrustedRoot;
            return potentialRoot;
        }
        this->_status = X509ChainStatusFlags::PartialChain;
        return nullptr;
    }
    
    bool X509Chain::IsTrusted(X509Certificate* potentialTrusted) {
        return this->get_TrustAnchors()->Contains2(potentialTrusted);
    }
    
    bool X509Chain::IsParent(X509Certificate* child, X509Certificate* parent) {
        if(System::String::op_Inequality(child->get_IssuerName_25458e2c269ceeaa(), parent->get_SubjectName_8e1ad5a09a5c9697())) 
        {
            return false;
        }
        if(((parent->get_Version() > 2) && !(IsTrusted(parent)))) 
        {
            X509Extension *ext = parent->get_Extensions()->get_Item3(_T("2.5.29.19"));
            if((ext != nullptr)) 
            {
                Extensions::BasicConstraintsExtension *bc = cli::gcnew<Extensions::BasicConstraintsExtension>(ext);
                if(!(bc->get_CertificateAuthority())) 
                {
                    this->_status = X509ChainStatusFlags::InvalidBasicConstraints;
                }
            }
             else 
            {
                this->_status = X509ChainStatusFlags::InvalidBasicConstraints;
            }
        }
        if(!(child->VerifySignature2(parent->get_RSA_32368d0ddec581fa()))) 
        {
            this->_status = X509ChainStatusFlags::NotSignatureValid;
            return false;
        }
        return true;
    }
    
    X509CertificateCollection* X509Chain::get_Chain() {
        return this->_chain;
    }
    
    X509Certificate* X509Chain::get_Root() {
        return this->_root;
    }
    
    X509ChainStatusFlags X509Chain::get_Status() {
        return this->_status;
    }
    
    X509CertificateCollection* X509Chain::get_TrustAnchors() {
        if((this->roots ==  nullptr)) 
        {
            this->roots = cli::gcnew<X509CertificateCollection>();
            this->roots->AddRange2(X509StoreManager::get_TrustedRootCertificates());
            return this->roots;
        }
        return this->roots;
    }
    
    X509CertificateCollection* X509Chain::set_TrustAnchors(X509CertificateCollection* value) {
        this->roots = value;
        return get_TrustAnchors();
    }
    
}}}
namespace Mono { namespace Security { namespace X509 {
    
    
    void X509CrlEntry::constructor(cli::array<unsigned char>* serialNumber, System::DateTime revocationDate, X509ExtensionCollection* extensions) {
        this->sn = serialNumber;
        this->revocationDate = revocationDate;
        if((extensions ==  nullptr)) 
        {
            this->extensions = cli::gcnew<X509ExtensionCollection>();
        }
         else 
        {
            this->extensions = extensions;
        }
    }
    
    void X509CrlEntry::constructor(Mono::Security::ASN1* entry) {
        this->sn = entry->get_Item(0)->get_Value();
        System::Array::Reverse(this->sn);
        this->revocationDate = Mono::Security::ASN1Convert::ToDateTime(entry->get_Item(1));
        this->extensions = cli::gcnew<X509ExtensionCollection>(entry->get_Item(2));
    }
    
    cli::array<unsigned char>* X509CrlEntry::GetBytes() {
        Mono::Security::ASN1 *sequence = cli::gcnew<Mono::Security::ASN1>(48);
        sequence->Add(cli::gcnew<Mono::Security::ASN1>(2, this->sn));
        sequence->Add(Mono::Security::ASN1Convert::FromDateTime(this->revocationDate));
        if((this->extensions->get_Count() > 0)) 
        {
            sequence->Add(cli::gcnew<Mono::Security::ASN1>(this->extensions->GetBytes()));
        }
        return sequence->GetBytes_b91405229279a4ac();
    }
    
    cli::array<unsigned char>* X509CrlEntry::get_SerialNumber() {
        return cli::cast<cli::array<unsigned char>*>(cli::import(this->sn)->Clone());
    }
    
    System::DateTime X509CrlEntry::get_RevocationDate() {
        return this->revocationDate;
    }
    
    X509ExtensionCollection* X509CrlEntry::get_Extensions() {
        return this->extensions;
    }
    
}}}
namespace Mono { namespace Security { namespace X509 {
    
    
    void X509Crl::constructor(cli::array<unsigned char>* crl) {
        if((crl ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("crl"));
        }
        this->encoded = cli::cast<cli::array<unsigned char>*>(cli::import(crl)->Clone());
        Parse(this->encoded);
    }
    
    void X509Crl::Parse(cli::array<unsigned char>* crl) {
        System::String *e = _T("Input data cannot be coded as a valid CRL.");
        try {
            Mono::Security::ASN1 *encodedCRL = cli::gcnew<Mono::Security::ASN1>(this->encoded);
            if((((int32_t)(encodedCRL->get_Tag()) != 48) || (encodedCRL->get_Count() != 3))) 
            {
                throw cli::gcnew<System::Security::Cryptography::CryptographicException>(e);
            }
            Mono::Security::ASN1 *toBeSigned = encodedCRL->get_Item(0);
            if((((int32_t)(toBeSigned->get_Tag()) != 48) || (toBeSigned->get_Count() < 3))) 
            {
                throw cli::gcnew<System::Security::Cryptography::CryptographicException>(e);
            }
            int32_t n = 0;
            if(((int32_t)(toBeSigned->get_Item(n)->get_Tag()) ==  2)) 
            {
                this->version = (unsigned char)((int32_t)(toBeSigned->get_Item(n++)->get_Value()->at(0)) + 1);
            }
             else 
            {
                this->version = 1;
            }
            this->signatureOID = Mono::Security::ASN1Convert::ToOid(toBeSigned->get_Item(n++)->get_Item(0));
            this->issuer = X501::ToString2(toBeSigned->get_Item(n++));
            this->thisUpdate = Mono::Security::ASN1Convert::ToDateTime(toBeSigned->get_Item(n++));
            Mono::Security::ASN1 *next = toBeSigned->get_Item(n++);
            if((((int32_t)(next->get_Tag()) ==  23) || ((int32_t)(next->get_Tag()) ==  24))) 
            {
                this->nextUpdate = Mono::Security::ASN1Convert::ToDateTime(next);
                next = toBeSigned->get_Item(n++);
            }
            this->entries = cli::gcnew<System::Collections::ArrayList>();
            if(((next != nullptr) && ((int32_t)(next->get_Tag()) ==  48))) 
            {
                Mono::Security::ASN1 *revokedCertificates = next;
                for(int32_t i = 0; (i < revokedCertificates->get_Count()); i++){
                    this->entries->Add_e6a92085999ce388(cli::gcnew<X509CrlEntry>(revokedCertificates->get_Item(i)));
                }
            }
             else 
            {
                n--;
            }
            Mono::Security::ASN1 *extns = toBeSigned->get_Item(n);
            if((((extns != nullptr) && ((int32_t)(extns->get_Tag()) ==  160)) && (extns->get_Count() ==  1))) 
            {
                this->extensions = cli::gcnew<X509ExtensionCollection>(extns->get_Item(0));
            }
             else 
            {
                this->extensions = cli::gcnew<X509ExtensionCollection>(nullptr);
            }
            System::String *signatureAlgorithm = Mono::Security::ASN1Convert::ToOid(encodedCRL->get_Item(1)->get_Item(0));
            if(System::String::op_Inequality(this->signatureOID, signatureAlgorithm)) 
            {
                throw cli::gcnew<System::Security::Cryptography::CryptographicException>(cli::concat(e, _T(" [Non-matching signature algorithms in CRL]")));
            }
            cli::array<unsigned char> *bitstring = encodedCRL->get_Item(2)->get_Value();
            this->signature = (new cli::array<unsigned char>((bitstring->get_Length() - 1)));
            System::Buffer::BlockCopy(bitstring, 1, this->signature, 0, this->signature->get_Length());
        }
        catch(...) {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(e);
        }
    }
    
    bool X509Crl::WasCurrent(System::DateTime instant) {
        if(System::DateTime::op_Equality(this->nextUpdate, (*System::DateTime::MinValue))) 
        {
            return System::DateTime::op_GreaterThanOrEqual(instant, this->thisUpdate);
        }
         else 
        {
            return (System::DateTime::op_GreaterThanOrEqual(instant, this->thisUpdate) && System::DateTime::op_LessThanOrEqual(instant, this->nextUpdate));
        }
    }
    
    cli::array<unsigned char>* X509Crl::GetBytes() {
        return cli::cast<cli::array<unsigned char>*>(cli::import(this->encoded)->Clone());
    }
    
    bool X509Crl::Compare(cli::array<unsigned char>* array1, cli::array<unsigned char>* array2) {
        if(((array1 ==  nullptr) && (array2 ==  nullptr))) 
        {
            return true;
        }
        if(((array1 ==  nullptr) || (array2 ==  nullptr))) 
        {
            return false;
        }
        if((array1->get_Length() != array2->get_Length())) 
        {
            return false;
        }
        for(int32_t i = 0; (i < array1->get_Length()); i++){
            if(((int32_t)(array1->at(i)) != (int32_t)(array2->at(i)))) 
            {
                return false;
            }
        }
        return true;
    }
    
    X509CrlEntry* X509Crl::GetCrlEntry(X509Certificate* x509) {
        if((x509 ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("x509"));
        }
        return GetCrlEntry2(x509->get_SerialNumber_ac6911419cae47b0());
    }
    
    X509CrlEntry* X509Crl::GetCrlEntry2(cli::array<unsigned char>* serialNumber) {
        if((serialNumber ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("serialNumber"));
        }
        for(int32_t i = 0; (i < this->entries->get_Count_2354963792616712()); i++){
            X509CrlEntry *entry = cli::cast<X509CrlEntry*>(this->entries->get_Item_fd0155f142ae570(i));
            if(Compare(serialNumber, entry->get_SerialNumber())) 
            {
                return entry;
            }
        }
        return nullptr;
    }
    
    bool X509Crl::VerifySignature(X509Certificate* x509) {
        if((x509 ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("x509"));
        }
        if((x509->get_Version() >= 3)) 
        {
            X509Extension *ext = x509->get_Extensions()->get_Item3(_T("2.5.29.15"));
            if((ext != nullptr)) 
            {
                Extensions::KeyUsageExtension *keyUsage = cli::gcnew<Extensions::KeyUsageExtension>(ext);
                if(!(keyUsage->Support(Extensions::KeyUsages::cRLSign))) 
                {
                    return false;
                }
            }
            ext = x509->get_Extensions()->get_Item3(_T("2.5.29.19"));
            if((ext != nullptr)) 
            {
                Extensions::BasicConstraintsExtension *basicConstraints = cli::gcnew<Extensions::BasicConstraintsExtension>(ext);
                if(!(basicConstraints->get_CertificateAuthority())) 
                {
                    return false;
                }
            }
        }
        if(System::String::op_Inequality(this->issuer, x509->get_SubjectName_8e1ad5a09a5c9697())) 
        {
            return false;
        }
        System::String* tmp_135 = this->signatureOID;
        ::System::Int32 tmp_136 = -1;
        if(::System::String::Equals3(tmp_135, _T("1.2.840.10040.4.3"))) tmp_136 = 0;
        switch(tmp_136)
        {
            case 0: case_517: 
            {
                return VerifySignature2(x509->get_DSA());
            }
            default: case_518: 
            {
                return VerifySignature3(x509->get_RSA_32368d0ddec581fa());
            }
        }
    }
    
    System::String* X509Crl::GetHashName() {
        System::String* tmp_137 = this->signatureOID;
        ::System::Int32 tmp_138 = -1;
        if(::System::String::Equals3(tmp_137, _T("1.2.840.113549.1.1.2"))) tmp_138 = 0;
        if(::System::String::Equals3(tmp_137, _T("1.2.840.113549.1.1.4"))) tmp_138 = 1;
        if(::System::String::Equals3(tmp_137, _T("1.2.840.10040.4.3")) ||
        ::System::String::Equals3(tmp_137, _T("1.2.840.113549.1.1.5"))) tmp_138 = 2;
        switch(tmp_138)
        {
            case 0: case_519: 
            {
                return _T("MD2");
            }
            case 1: case_520: 
            {
                return _T("MD5");
            }
            case 2: case_521: 
            {
                return _T("SHA1");
            }
            default: case_522: 
            {
                throw cli::gcnew<System::Security::Cryptography::CryptographicException>(cli::concat(_T("Unsupported hash algorithm: "), this->signatureOID));
            }
        }
    }
    
    bool X509Crl::VerifySignature2(System::Security::Cryptography::DSA* dsa) {
        if(System::String::op_Inequality(this->signatureOID, _T("1.2.840.10040.4.3"))) 
        {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(cli::concat(_T("Unsupported hash algorithm: "), this->signatureOID));
        }
        System::Security::Cryptography::DSASignatureDeformatter *v = cli::gcnew<System::Security::Cryptography::DSASignatureDeformatter>(dsa);
        v->SetHashAlgorithm_5a7fb9c08aaf7ac9(_T("SHA1"));
        Mono::Security::ASN1 *sign = cli::gcnew<Mono::Security::ASN1>(this->signature);
        if(((sign ==  nullptr) || (sign->get_Count() != 2))) 
        {
            return false;
        }
        cli::array<unsigned char> *part1 = sign->get_Item(0)->get_Value();
        cli::array<unsigned char> *part2 = sign->get_Item(1)->get_Value();
        cli::array<unsigned char> *sig = (new cli::array<unsigned char>(40));
        int32_t s1 = System::Math::Max5(0, (part1->get_Length() - 20));
        int32_t e1 = System::Math::Max5(0, (20 - part1->get_Length()));
        System::Buffer::BlockCopy(part1, s1, sig, e1, (part1->get_Length() - s1));
        int32_t s2 = System::Math::Max5(0, (part2->get_Length() - 20));
        int32_t e2 = System::Math::Max5(20, (40 - part2->get_Length()));
        System::Buffer::BlockCopy(part2, s2, sig, e2, (part2->get_Length() - s2));
        return v->VerifySignature_ecf649797288645c(this->get_Hash(), sig);
    }
    
    bool X509Crl::VerifySignature3(System::Security::Cryptography::RSA* rsa) {
        System::Security::Cryptography::RSAPKCS1SignatureDeformatter *v = cli::gcnew<System::Security::Cryptography::RSAPKCS1SignatureDeformatter>(rsa);
        v->SetHashAlgorithm_5a7fb9c08aaf7ac9(GetHashName());
        return v->VerifySignature_ecf649797288645c(this->get_Hash(), this->signature);
    }
    
    bool X509Crl::VerifySignature4(System::Security::Cryptography::AsymmetricAlgorithm* aa) {
        if((aa ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("aa"));
        }
        if(cli::is<System::Security::Cryptography::RSA>(aa)) 
        {
            return VerifySignature3(cli::as<System::Security::Cryptography::RSA*>(aa));
        }
         else 
        {
            if(cli::is<System::Security::Cryptography::DSA>(aa)) 
            {
                return VerifySignature2(cli::as<System::Security::Cryptography::DSA*>(aa));
            }
             else 
            {
                throw cli::gcnew<System::NotSupportedException>(cli::concat(_T("Unknown Asymmetric Algorithm "), aa->ToString_1636a0751cb9ac11()));
            }
        }
    }
    
    X509Crl* X509Crl::CreateFromFile(System::String* filename) {
        cli::array<unsigned char> *crl = nullptr;
        {
            /* USING - BLOCK */
            auto fs = System::IO::File::Open3(filename, System::IO::FileMode::Open, System::IO::FileAccess::Read, System::IO::FileShare::Read);
            cli::using_guard{fs};
            crl = (new cli::array<unsigned char>((int32_t)fs->get_Length_ddb8b0d061db5350()));
            fs->Read_c0d6dde3943b413e(crl, 0, crl->get_Length());
            fs->Close_59c62ed53ef2a481();
        }
        return cli::gcnew<X509Crl>(crl);
    }
    
    System::Collections::ArrayList* X509Crl::get_Entries() {
        return System::Collections::ArrayList::ReadOnly(this->entries);
    }
    
    X509CrlEntry* X509Crl::get_Item(int32_t index) {
        return cli::cast<X509CrlEntry*>(this->entries->get_Item_fd0155f142ae570(index));
    }
    
    X509CrlEntry* X509Crl::get_Item2(cli::array<unsigned char>* serialNumber) {
        return GetCrlEntry2(serialNumber);
    }
    
    X509ExtensionCollection* X509Crl::get_Extensions() {
        return this->extensions;
    }
    
    cli::array<unsigned char>* X509Crl::get_Hash() {
        if((this->hash_value ==  nullptr)) 
        {
            Mono::Security::ASN1 *encodedCRL = cli::gcnew<Mono::Security::ASN1>(this->encoded);
            cli::array<unsigned char> *toBeSigned = encodedCRL->get_Item(0)->GetBytes_b91405229279a4ac();
            System::Security::Cryptography::HashAlgorithm *ha = System::Security::Cryptography::HashAlgorithm::Create2(GetHashName());
            this->hash_value = ha->ComputeHash(toBeSigned);
        }
        return this->hash_value;
    }
    
    System::String* X509Crl::get_IssuerName() {
        return this->issuer;
    }
    
    System::DateTime X509Crl::get_NextUpdate() {
        return this->nextUpdate;
    }
    
    System::DateTime X509Crl::get_ThisUpdate() {
        return this->thisUpdate;
    }
    
    System::String* X509Crl::get_SignatureAlgorithm() {
        return this->signatureOID;
    }
    
    cli::array<unsigned char>* X509Crl::get_Signature() {
        if((this->signature ==  nullptr)) 
        {
            return nullptr;
        }
        return cli::cast<cli::array<unsigned char>*>(cli::import(this->signature)->Clone());
    }
    
    cli::array<unsigned char>* X509Crl::get_RawData() {
        return cli::cast<cli::array<unsigned char>*>(cli::import(this->encoded)->Clone());
    }
    
    unsigned char X509Crl::get_Version() {
        return this->version;
    }
    
    bool X509Crl::get_IsCurrent() {
        return WasCurrent(System::DateTime::get_Now());
    }
    
}}}
namespace Mono { namespace Security { namespace X509 {
    
    
    void X509Extension::constructor() {
        this->extnCritical = false;
    }
    
    void X509Extension::constructor(Mono::Security::ASN1* asn1) {
        if((((int32_t)(asn1->get_Tag()) != 48) || (asn1->get_Count() < 2))) 
        {
            throw cli::gcnew<System::ArgumentException>(Locale::GetText(_T("Invalid X.509 extension.")));
        }
        if(((int32_t)(asn1->get_Item(0)->get_Tag()) != 6)) 
        {
            throw cli::gcnew<System::ArgumentException>(Locale::GetText(_T("Invalid X.509 extension.")));
        }
        this->extnOid = Mono::Security::ASN1Convert::ToOid(asn1->get_Item(0));
        this->extnCritical = (((int32_t)(asn1->get_Item(1)->get_Tag()) ==  1) && ((int32_t)(asn1->get_Item(1)->get_Value()->at(0)) ==  255));
        this->extnValue = asn1->get_Item((asn1->get_Count() - 1));
        if(((((int32_t)(this->extnValue->get_Tag()) ==  4) && (this->extnValue->get_Length() > 0)) && (this->extnValue->get_Count() ==  0))) 
        {
            try {
                Mono::Security::ASN1 *encapsulated = cli::gcnew<Mono::Security::ASN1>(this->extnValue->get_Value());
                this->extnValue->set_Value(nullptr);
                this->extnValue->Add(encapsulated);
            }
            catch(...) {
            }
        }
        Decode_cefcb854d4bf305c();
    }
    
    void X509Extension::constructor(X509Extension* extension) {
        if((extension ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("extension"));
        }
        if((((extension->get_Value() ==  nullptr) || ((int32_t)(extension->get_Value()->get_Tag()) != 4)) || (extension->get_Value()->get_Count() != 1))) 
        {
            throw cli::gcnew<System::ArgumentException>(Locale::GetText(_T("Invalid X.509 extension.")));
        }
        this->extnOid = extension->get_Oid();
        this->extnCritical = extension->get_Critical();
        this->extnValue = extension->get_Value();
        Decode_cefcb854d4bf305c();
    }
    
    void X509Extension::Decode_cefcb854d4bf305c() {
    }
    
    void X509Extension::Encode_e7b55e24a6cbc279() {
    }
    
    bool X509Extension::Equals_ed975d2f4a7d193e(System::Object* obj) {
        if((obj ==  nullptr)) 
        {
            return false;
        }
        X509Extension *ex = cli::as<X509Extension*>(obj);
        if((ex ==  nullptr)) 
        {
            return false;
        }
        if((this->extnCritical != ex->extnCritical)) 
        {
            return false;
        }
        if(System::String::op_Inequality(this->extnOid, ex->extnOid)) 
        {
            return false;
        }
        if((this->extnValue->get_Length() != ex->extnValue->get_Length())) 
        {
            return false;
        }
        for(int32_t i = 0; (i < this->extnValue->get_Length()); i++){
            if((this->extnValue->get_Item(i) != ex->extnValue->get_Item(i))) 
            {
                return false;
            }
        }
        return true;
    }
    
    cli::array<unsigned char>* X509Extension::GetBytes() {
        return this->get_ASN1()->GetBytes_b91405229279a4ac();
    }
    
    int32_t X509Extension::GetHashCode_6648aef0f235ee6c() {
        return this->extnOid->GetHashCode_6648aef0f235ee6c();
    }
    
    void X509Extension::WriteLine(System::Text::StringBuilder* sb, int32_t n, int32_t pos) {
        cli::array<unsigned char> *value = this->extnValue->get_Value();
        int32_t p = pos;
        for(int32_t j = 0; (j < 8); j++){
            if((j < n)) 
            {
                sb->Append2(cli::import(value->at(p++))->ToString5(_T("X2"), System::Globalization::CultureInfo::get_InvariantCulture()));
                sb->Append2(_T(" "));
            }
             else 
            {
                sb->Append2(_T("   "));
            }
        }
        sb->Append2(_T("  "));
        p = pos;
        for(int32_t j = 0; (j < n); j++){
            unsigned char b = value->at(p++);
            if(((int32_t)(b) < 32)) 
            {
                sb->Append2(_T("."));
            }
             else 
            {
                sb->Append16(System::Convert::ToChar2(b));
            }
        }
        sb->Append2(System::Environment::get_NewLine());
    }
    
    System::String* X509Extension::ToString_1636a0751cb9ac11() {
        System::Text::StringBuilder *sb = cli::gcnew<System::Text::StringBuilder>();
        int32_t div = (this->extnValue->get_Length() >> 3);
        int32_t rem = (this->extnValue->get_Length() - (div << 3));
        int32_t x = 0;
        for(int32_t i = 0; (i < div); i++){
            WriteLine(sb, 8, x);
            (x = x + 8);
        }
        WriteLine(sb, rem, x);
        return sb->ToString_1636a0751cb9ac11();
    }
    
    Mono::Security::ASN1* X509Extension::get_ASN1() {
        Mono::Security::ASN1 *extension = cli::gcnew<Mono::Security::ASN1>(48);
        extension->Add(Mono::Security::ASN1Convert::FromOid(this->extnOid));
        if(this->extnCritical) 
        {
            extension->Add(cli::gcnew<Mono::Security::ASN1>(1, (new cli::array<unsigned char>({255}))));
        }
        Encode_e7b55e24a6cbc279();
        extension->Add(this->extnValue);
        return extension;
    }
    
    System::String* X509Extension::get_Oid() {
        return this->extnOid;
    }
    
    bool X509Extension::get_Critical() {
        return this->extnCritical;
    }
    
    bool X509Extension::set_Critical(bool value) {
        this->extnCritical = value;
        return get_Critical();
    }
    
    System::String* X509Extension::get_Name_7f87430b0f20607() {
        return this->extnOid;
    }
    
    Mono::Security::ASN1* X509Extension::get_Value() {
        if((this->extnValue ==  nullptr)) 
        {
            Encode_e7b55e24a6cbc279();
        }
        return this->extnValue;
    }
    
}}}
namespace Mono { namespace Security { namespace X509 {
    
    
    void X509ExtensionCollection::constructor() {
    }
    
    void X509ExtensionCollection::constructor(Mono::Security::ASN1* asn1) {
        this->readOnly = true;
        if((asn1 ==  nullptr)) 
        {
            return;
        }
        if(((int32_t)(asn1->get_Tag()) != 48)) 
        {
            throw cli::gcnew<System::Exception>(_T("Invalid extensions format"));
        }
        for(int32_t i = 0; (i < asn1->get_Count()); i++){
            X509Extension *extension = cli::gcnew<X509Extension>(asn1->get_Item(i));
            this->get_InnerList()->Add_e6a92085999ce388(extension);
        }
    }
    
    int32_t X509ExtensionCollection::Add2(X509Extension* extension) {
        if((extension ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("extension"));
        }
        if(this->readOnly) 
        {
            throw cli::gcnew<System::NotSupportedException>(_T("Extensions are read only"));
        }
        return this->get_InnerList()->Add_e6a92085999ce388(extension);
    }
    
    void X509ExtensionCollection::AddRange(cli::array<X509Extension*>* extension) {
        if((extension ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("extension"));
        }
        if(this->readOnly) 
        {
            throw cli::gcnew<System::NotSupportedException>(_T("Extensions are read only"));
        }
        for(int32_t i = 0; (i < extension->get_Length()); i++) {
            this->get_InnerList()->Add_e6a92085999ce388(extension->at(i));
        }
    }
    
    void X509ExtensionCollection::AddRange2(X509ExtensionCollection* collection) {
        if((collection ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("collection"));
        }
        if(this->readOnly) 
        {
            throw cli::gcnew<System::NotSupportedException>(_T("Extensions are read only"));
        }
        for(int32_t i = 0; (i < collection->get_InnerList()->get_Count_2354963792616712()); i++) {
            this->get_InnerList()->Add_e6a92085999ce388(collection->get_Item2(i));
        }
    }
    
    bool X509ExtensionCollection::Contains2(X509Extension* extension) {
        return (IndexOf2(extension) != -1);
    }
    
    bool X509ExtensionCollection::Contains3(System::String* oid) {
        return (IndexOf3(oid) != -1);
    }
    
    void X509ExtensionCollection::CopyTo2(cli::array<X509Extension*>* extensions, int32_t index) {
        if((extensions ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("extensions"));
        }
        this->get_InnerList()->CopyTo_2bc540dad3c25b9e(extensions, index);
    }
    
    int32_t X509ExtensionCollection::IndexOf2(X509Extension* extension) {
        if((extension ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("extension"));
        }
        for(int32_t i = 0; (i < this->get_InnerList()->get_Count_2354963792616712()); i++){
            X509Extension *ex = cli::cast<X509Extension*>(this->get_InnerList()->get_Item_fd0155f142ae570(i));
            if(ex->Equals_ed975d2f4a7d193e(extension)) 
            {
                return i;
            }
        }
        return -1;
    }
    
    int32_t X509ExtensionCollection::IndexOf3(System::String* oid) {
        if((oid ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("oid"));
        }
        for(int32_t i = 0; (i < this->get_InnerList()->get_Count_2354963792616712()); i++){
            X509Extension *ex = cli::cast<X509Extension*>(this->get_InnerList()->get_Item_fd0155f142ae570(i));
            if(System::String::op_Equality(ex->get_Oid(), oid)) 
            {
                return i;
            }
        }
        return -1;
    }
    
    void X509ExtensionCollection::Insert2(int32_t index, X509Extension* extension) {
        if((extension ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("extension"));
        }
        this->get_InnerList()->Insert_59557a2615bf3b8e(index, extension);
    }
    
    void X509ExtensionCollection::Remove2(X509Extension* extension) {
        if((extension ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("extension"));
        }
        this->get_InnerList()->Remove_2225381aaf812c6d(extension);
    }
    
    void X509ExtensionCollection::Remove3(System::String* oid) {
        if((oid ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("oid"));
        }
        int32_t index = IndexOf3(oid);
        if((index != -1)) 
        {
            this->get_InnerList()->RemoveAt_2abea768d3273318(index);
        }
    }
    
    System::Collections::IEnumerator* X509ExtensionCollection::GetEnumerator2() {
        return this->get_InnerList()->GetEnumerator_84e3ba8f2fdefd62();
    }
    
    cli::array<unsigned char>* X509ExtensionCollection::GetBytes() {
        if((this->get_InnerList()->get_Count_2354963792616712() < 1)) 
        {
            return nullptr;
        }
        Mono::Security::ASN1 *sequence = cli::gcnew<Mono::Security::ASN1>(48);
        for(int32_t i = 0; (i < this->get_InnerList()->get_Count_2354963792616712()); i++){
            X509Extension *x = cli::cast<X509Extension*>(this->get_InnerList()->get_Item_fd0155f142ae570(i));
            sequence->Add(x->get_ASN1());
        }
        return sequence->GetBytes_b91405229279a4ac();
    }
    
    X509Extension* X509ExtensionCollection::get_Item2(int32_t index) {
        return cli::cast<X509Extension*>(this->get_InnerList()->get_Item_fd0155f142ae570(index));
    }
    
    X509Extension* X509ExtensionCollection::get_Item3(System::String* oid) {
        int32_t index = IndexOf3(oid);
        if((index ==  -1)) 
        {
            return nullptr;
        }
        return cli::cast<X509Extension*>(this->get_InnerList()->get_Item_fd0155f142ae570(index));
    }
    
}}}
namespace Mono { namespace Security { namespace X509 {
    
    
    void X509Store::constructor(System::String* path, bool crl) {
        this->_storePath = path;
        this->_crl = crl;
    }
    
    void X509Store::Clear() {
        if((this->_certificates != nullptr)) 
        {
            this->_certificates->Clear();
        }
        this->_certificates = nullptr;
        if((this->_crls != nullptr)) 
        {
            this->_crls->Clear_cd6654e5a40f5056();
        }
        this->_crls = nullptr;
    }
    
    void X509Store::Import(X509Certificate* certificate) {
        CheckStore(this->_storePath, true);
        System::String *filename = System::IO::Path::Combine(this->_storePath, GetUniqueName(certificate));
        if(!(System::IO::File::Exists(filename))) 
        {
            {
                /* USING - BLOCK */
                auto fs = System::IO::File::Create(filename);
                cli::using_guard{fs};
                cli::array<unsigned char> *data = certificate->get_RawData_c0a18e988d76611c();
                fs->Write_1f8a1dbe71b0eb89(data, 0, data->get_Length());
                fs->Close_59c62ed53ef2a481();
            }
        }
        System::Security::Cryptography::CspParameters *cspParams = cli::gcnew<System::Security::Cryptography::CspParameters>();
        cspParams->KeyContainerName = Mono::Security::Cryptography::CryptoConvert::ToHex(certificate->get_Hash());
        if(this->_storePath->StartsWith(X509StoreManager::get_LocalMachinePath())) 
        {
            cspParams->set_Flags(System::Security::Cryptography::CspProviderFlags::UseMachineKeyStore);
        }
        ImportPrivateKey(certificate, cspParams);
    }
    
    void X509Store::Import2(X509Crl* crl) {
        CheckStore(this->_storePath, true);
        System::String *filename = System::IO::Path::Combine(this->_storePath, GetUniqueName2(crl));
        if(!(System::IO::File::Exists(filename))) 
        {
            {
                /* USING - BLOCK */
                auto fs = System::IO::File::Create(filename);
                cli::using_guard{fs};
                cli::array<unsigned char> *data = crl->get_RawData();
                fs->Write_1f8a1dbe71b0eb89(data, 0, data->get_Length());
            }
        }
    }
    
    void X509Store::Remove(X509Certificate* certificate) {
        System::String *filename = System::IO::Path::Combine(this->_storePath, GetUniqueName(certificate));
        if(System::IO::File::Exists(filename)) 
        {
            System::IO::File::Delete(filename);
        }
    }
    
    void X509Store::Remove2(X509Crl* crl) {
        System::String *filename = System::IO::Path::Combine(this->_storePath, GetUniqueName2(crl));
        if(System::IO::File::Exists(filename)) 
        {
            System::IO::File::Delete(filename);
        }
    }
    
    System::String* X509Store::GetUniqueName(X509Certificate* certificate) {
        System::String *method;
        cli::array<unsigned char> *name = GetUniqueName3(certificate->get_Extensions());
        if((name ==  nullptr)) 
        {
            method = _T("tbp");
            name = certificate->get_Hash();
        }
         else 
        {
            method = _T("ski");
        }
        return GetUniqueName4(method, name, _T(".cer"));
    }
    
    System::String* X509Store::GetUniqueName2(X509Crl* crl) {
        System::String *method;
        cli::array<unsigned char> *name = GetUniqueName3(crl->get_Extensions());
        if((name ==  nullptr)) 
        {
            method = _T("tbp");
            name = crl->get_Hash();
        }
         else 
        {
            method = _T("ski");
        }
        return GetUniqueName4(method, name, _T(".crl"));
    }
    
    cli::array<unsigned char>* X509Store::GetUniqueName3(X509ExtensionCollection* extensions) {
        X509Extension *ext = extensions->get_Item3(_T("2.5.29.14"));
        if((ext ==  nullptr)) 
        {
            return nullptr;
        }
        Extensions::SubjectKeyIdentifierExtension *ski = cli::gcnew<Extensions::SubjectKeyIdentifierExtension>(ext);
        return ski->get_Identifier();
    }
    
    System::String* X509Store::GetUniqueName4(System::String* method, cli::array<unsigned char>* name, System::String* fileExtension) {
        System::Text::StringBuilder *sb = cli::gcnew<System::Text::StringBuilder>(method);
        sb->Append2(_T("-"));
        for(auto tmp_139 : name) {
            auto b = cli::cast<unsigned char>(tmp_139);
            {
                sb->Append2(cli::import(b)->ToString5(_T("X2"), System::Globalization::CultureInfo::get_InvariantCulture()));
            }
        }
        sb->Append2(fileExtension);
        return sb->ToString_1636a0751cb9ac11();
    }
    
    cli::array<unsigned char>* X509Store::Load(System::String* filename) {
        cli::array<unsigned char> *data = nullptr;
        {
            /* USING - BLOCK */
            auto fs = System::IO::File::OpenRead(filename);
            cli::using_guard{fs};
            data = (new cli::array<unsigned char>((int32_t)fs->get_Length_ddb8b0d061db5350()));
            fs->Read_c0d6dde3943b413e(data, 0, data->get_Length());
            fs->Close_59c62ed53ef2a481();
        }
        return data;
    }
    
    X509Certificate* X509Store::LoadCertificate(System::String* filename) {
        cli::array<unsigned char> *data = Load(filename);
        X509Certificate *cert = cli::gcnew<X509Certificate>(data);
        System::Security::Cryptography::CspParameters *cspParams = cli::gcnew<System::Security::Cryptography::CspParameters>();
        cspParams->KeyContainerName = Mono::Security::Cryptography::CryptoConvert::ToHex(cert->get_Hash());
        if(this->_storePath->StartsWith(X509StoreManager::get_LocalMachinePath())) 
        {
            cspParams->set_Flags(System::Security::Cryptography::CspProviderFlags::UseMachineKeyStore);
        }
        Mono::Security::Cryptography::KeyPairPersistence *kpp = cli::gcnew<Mono::Security::Cryptography::KeyPairPersistence>(cspParams);
        if(!(kpp->Load())) 
        {
            return cert;
        }
        if((cert->get_RSA_32368d0ddec581fa() != nullptr)) 
        {
            cert->set_RSA_c0bdcd7611af9c2e(cli::gcnew<System::Security::Cryptography::RSACryptoServiceProvider>(cspParams));
        }
         else 
        {
            if((cert->get_DSA() != nullptr)) 
            {
                cert->set_DSA(cli::gcnew<System::Security::Cryptography::DSACryptoServiceProvider>(cspParams));
            }
        }
        return cert;
    }
    
    X509Crl* X509Store::LoadCrl(System::String* filename) {
        cli::array<unsigned char> *data = Load(filename);
        X509Crl *crl = cli::gcnew<X509Crl>(data);
        return crl;
    }
    
    bool X509Store::CheckStore(System::String* path, bool throwException) {
        try {
            if(System::IO::Directory::Exists(path)) 
            {
                return true;
            }
            System::IO::Directory::CreateDirectory(path);
            return System::IO::Directory::Exists(path);
        }
        catch(...) {
            if(throwException) 
            {
                throw ;
            }
            return false;
        }
    }
    
    X509CertificateCollection* X509Store::BuildCertificatesCollection(System::String* storeName) {
        X509CertificateCollection *coll = cli::gcnew<X509CertificateCollection>();
        System::String *path = System::IO::Path::Combine(this->_storePath, storeName);
        if(!(CheckStore(path, false))) 
        {
            return coll;
        }
        cli::array<System::String*> *files = System::IO::Directory::GetFiles2(path, _T("*.cer"));
        if(((files != nullptr) && (files->get_Length() > 0))) 
        {
            for(auto tmp_140 : files) {
                auto file = cli::cast<System::String*>(tmp_140);
                {
                    try {
                        X509Certificate *cert = LoadCertificate(file);
                        coll->Add2(cert);
                    }
                    catch(...) {
                    }
                }
            }
        }
        return coll;
    }
    
    System::Collections::ArrayList* X509Store::BuildCrlsCollection(System::String* storeName) {
        System::Collections::ArrayList *list = cli::gcnew<System::Collections::ArrayList>();
        System::String *path = System::IO::Path::Combine(this->_storePath, storeName);
        if(!(CheckStore(path, false))) 
        {
            return list;
        }
        cli::array<System::String*> *files = System::IO::Directory::GetFiles2(path, _T("*.crl"));
        if(((files != nullptr) && (files->get_Length() > 0))) 
        {
            for(auto tmp_141 : files) {
                auto file = cli::cast<System::String*>(tmp_141);
                {
                    try {
                        X509Crl *crl = LoadCrl(file);
                        list->Add_e6a92085999ce388(crl);
                    }
                    catch(...) {
                    }
                }
            }
        }
        return list;
    }
    
    void X509Store::ImportPrivateKey(X509Certificate* certificate, System::Security::Cryptography::CspParameters* cspParams) {
        System::Security::Cryptography::RSACryptoServiceProvider *rsaCsp = cli::as<System::Security::Cryptography::RSACryptoServiceProvider*>(certificate->get_RSA_32368d0ddec581fa());
        if((rsaCsp != nullptr)) 
        {
            if(rsaCsp->get_PublicOnly()) 
            {
                return;
            }
            System::Security::Cryptography::RSACryptoServiceProvider *csp = cli::gcnew<System::Security::Cryptography::RSACryptoServiceProvider>(cspParams);
            csp->ImportParameters_43620ad65e380dd(rsaCsp->ExportParameters_f406cf113d936197(true));
            csp->set_PersistKeyInCsp(true);
            return;
        }
        Mono::Security::Cryptography::RSAManaged *rsaMng = cli::as<Mono::Security::Cryptography::RSAManaged*>(certificate->get_RSA_32368d0ddec581fa());
        if((rsaMng != nullptr)) 
        {
            if(rsaMng->get_PublicOnly()) 
            {
                return;
            }
            System::Security::Cryptography::RSACryptoServiceProvider *csp = cli::gcnew<System::Security::Cryptography::RSACryptoServiceProvider>(cspParams);
            csp->ImportParameters_43620ad65e380dd(rsaMng->ExportParameters_f406cf113d936197(true));
            csp->set_PersistKeyInCsp(true);
            return;
        }
        System::Security::Cryptography::DSACryptoServiceProvider *dsaCsp = cli::as<System::Security::Cryptography::DSACryptoServiceProvider*>(certificate->get_DSA());
        if((dsaCsp != nullptr)) 
        {
            if(dsaCsp->get_PublicOnly()) 
            {
                return;
            }
            System::Security::Cryptography::DSACryptoServiceProvider *csp = cli::gcnew<System::Security::Cryptography::DSACryptoServiceProvider>(cspParams);
            csp->ImportParameters_42bffe0948290f21(dsaCsp->ExportParameters_c041d0915f31506(true));
            csp->set_PersistKeyInCsp(true);
        }
    }
    
    X509CertificateCollection* X509Store::get_Certificates() {
        if((this->_certificates ==  nullptr)) 
        {
            this->_certificates = BuildCertificatesCollection(this->_storePath);
        }
        return this->_certificates;
    }
    
    System::Collections::ArrayList* X509Store::get_Crls() {
        if(!(this->_crl)) 
        {
            this->_crls = cli::gcnew<System::Collections::ArrayList>();
        }
        if((this->_crls ==  nullptr)) 
        {
            this->_crls = BuildCrlsCollection(this->_storePath);
        }
        return this->_crls;
    }
    
    System::String* X509Store::get_Name() {
        if((this->_name ==  nullptr)) 
        {
            int32_t n = this->_storePath->LastIndexOf4(System::IO::Path::DirectorySeparatorChar);
            this->_name = this->_storePath->Substring((n + 1));
        }
        return this->_name;
    }
    
}}}
namespace Mono { namespace Security { namespace X509 {
    
    System::String*  X509StoreManager::_userPath;
    System::String*  X509StoreManager::_localMachinePath;
    X509Stores*  X509StoreManager::_userStore;
    X509Stores*  X509StoreManager::_machineStore;
    
    void X509StoreManager::constructor() {
    }
    
    System::String* X509StoreManager::get_CurrentUserPath() {
        if((_userPath ==  nullptr)) 
        {
            _userPath = System::IO::Path::Combine(System::Environment::GetFolderPath(System::SpecialFolder::ApplicationData), _T(".mono"));
            _userPath = System::IO::Path::Combine(_userPath, _T("certs"));
        }
        return _userPath;
    }
    
    System::String* X509StoreManager::get_LocalMachinePath() {
        if((_localMachinePath ==  nullptr)) 
        {
            _localMachinePath = System::IO::Path::Combine(System::Environment::GetFolderPath(System::SpecialFolder::CommonApplicationData), _T(".mono"));
            _localMachinePath = System::IO::Path::Combine(_localMachinePath, _T("certs"));
        }
        return _localMachinePath;
    }
    
    X509Stores* X509StoreManager::get_CurrentUser() {
        if((_userStore ==  nullptr)) 
        {
            _userStore = cli::gcnew<X509Stores>(X509StoreManager::get_CurrentUserPath());
        }
        return _userStore;
    }
    
    X509Stores* X509StoreManager::get_LocalMachine() {
        if((_machineStore ==  nullptr)) 
        {
            _machineStore = cli::gcnew<X509Stores>(X509StoreManager::get_LocalMachinePath());
        }
        return _machineStore;
    }
    
    X509CertificateCollection* X509StoreManager::get_IntermediateCACertificates() {
        X509CertificateCollection *intermediateCerts = cli::gcnew<X509CertificateCollection>();
        intermediateCerts->AddRange2(X509StoreManager::get_CurrentUser()->get_IntermediateCA()->get_Certificates());
        intermediateCerts->AddRange2(X509StoreManager::get_LocalMachine()->get_IntermediateCA()->get_Certificates());
        return intermediateCerts;
    }
    
    System::Collections::ArrayList* X509StoreManager::get_IntermediateCACrls() {
        System::Collections::ArrayList *intermediateCRLs = cli::gcnew<System::Collections::ArrayList>();
        intermediateCRLs->AddRange_a8bb4db32a72ffe(X509StoreManager::get_CurrentUser()->get_IntermediateCA()->get_Crls());
        intermediateCRLs->AddRange_a8bb4db32a72ffe(X509StoreManager::get_LocalMachine()->get_IntermediateCA()->get_Crls());
        return intermediateCRLs;
    }
    
    X509CertificateCollection* X509StoreManager::get_TrustedRootCertificates() {
        X509CertificateCollection *trustedCerts = cli::gcnew<X509CertificateCollection>();
        trustedCerts->AddRange2(X509StoreManager::get_CurrentUser()->get_TrustedRoot()->get_Certificates());
        trustedCerts->AddRange2(X509StoreManager::get_LocalMachine()->get_TrustedRoot()->get_Certificates());
        return trustedCerts;
    }
    
    System::Collections::ArrayList* X509StoreManager::get_TrustedRootCACrls() {
        System::Collections::ArrayList *trustedCRLs = cli::gcnew<System::Collections::ArrayList>();
        trustedCRLs->AddRange_a8bb4db32a72ffe(X509StoreManager::get_CurrentUser()->get_TrustedRoot()->get_Crls());
        trustedCRLs->AddRange_a8bb4db32a72ffe(X509StoreManager::get_LocalMachine()->get_TrustedRoot()->get_Crls());
        return trustedCRLs;
    }
    
    X509CertificateCollection* X509StoreManager::get_UntrustedCertificates() {
        X509CertificateCollection *untrustedCerts = cli::gcnew<X509CertificateCollection>();
        untrustedCerts->AddRange2(X509StoreManager::get_CurrentUser()->get_Untrusted()->get_Certificates());
        untrustedCerts->AddRange2(X509StoreManager::get_LocalMachine()->get_Untrusted()->get_Certificates());
        return untrustedCerts;
    }
    
}}}
namespace Mono { namespace Security { namespace X509 {
    
    
    void Names::constructor() {
    }
    
}}}
namespace Mono { namespace Security { namespace X509 {
    
    
    void X509Stores::constructor(System::String* path) {
        this->_storePath = path;
    }
    
    void X509Stores::Clear() {
        if((this->_personal != nullptr)) 
        {
            this->_personal->Clear();
        }
        this->_personal = nullptr;
        if((this->_other != nullptr)) 
        {
            this->_other->Clear();
        }
        this->_other = nullptr;
        if((this->_intermediate != nullptr)) 
        {
            this->_intermediate->Clear();
        }
        this->_intermediate = nullptr;
        if((this->_trusted != nullptr)) 
        {
            this->_trusted->Clear();
        }
        this->_trusted = nullptr;
        if((this->_untrusted != nullptr)) 
        {
            this->_untrusted->Clear();
        }
        this->_untrusted = nullptr;
    }
    
    X509Store* X509Stores::Open(System::String* storeName, bool create) {
        if((storeName ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("storeName"));
        }
        System::String *path = System::IO::Path::Combine(this->_storePath, storeName);
        if((!(create) && !(System::IO::Directory::Exists(path)))) 
        {
            return nullptr;
        }
        return cli::gcnew<X509Store>(path, true);
    }
    
    X509Store* X509Stores::get_Personal() {
        if((this->_personal ==  nullptr)) 
        {
            System::String *path = System::IO::Path::Combine(this->_storePath, _T("My"));
            this->_personal = cli::gcnew<X509Store>(path, false);
        }
        return this->_personal;
    }
    
    X509Store* X509Stores::get_OtherPeople() {
        if((this->_other ==  nullptr)) 
        {
            System::String *path = System::IO::Path::Combine(this->_storePath, _T("AddressBook"));
            this->_other = cli::gcnew<X509Store>(path, false);
        }
        return this->_other;
    }
    
    X509Store* X509Stores::get_IntermediateCA() {
        if((this->_intermediate ==  nullptr)) 
        {
            System::String *path = System::IO::Path::Combine(this->_storePath, _T("CA"));
            this->_intermediate = cli::gcnew<X509Store>(path, true);
        }
        return this->_intermediate;
    }
    
    X509Store* X509Stores::get_TrustedRoot() {
        if((this->_trusted ==  nullptr)) 
        {
            System::String *path = System::IO::Path::Combine(this->_storePath, _T("Trust"));
            this->_trusted = cli::gcnew<X509Store>(path, true);
        }
        return this->_trusted;
    }
    
    X509Store* X509Stores::get_Untrusted() {
        if((this->_untrusted ==  nullptr)) 
        {
            System::String *path = System::IO::Path::Combine(this->_storePath, _T("Disallowed"));
            this->_untrusted = cli::gcnew<X509Store>(path, false);
        }
        return this->_untrusted;
    }
    
}}}
namespace Mono { namespace Security { namespace X509 {
    
    
    void AttributeTypeAndValue::constructor(System::String* oid, int32_t upperBound) {
        this->oid = oid;
        this->upperBound = upperBound;
        this->encoding = 255;
    }
    
    void AttributeTypeAndValue::constructor(System::String* oid, int32_t upperBound, unsigned char encoding) {
        this->oid = oid;
        this->upperBound = upperBound;
        this->encoding = encoding;
    }
    
    Mono::Security::ASN1* AttributeTypeAndValue::GetASN1(unsigned char encoding) {
        unsigned char encode = encoding;
        if(((int32_t)(encode) ==  255)) 
        {
            encode = SelectBestEncoding();
        }
        Mono::Security::ASN1 *asn1 = cli::gcnew<Mono::Security::ASN1>(48);
        asn1->Add(Mono::Security::ASN1Convert::FromOid(this->oid));
        switch(encode) {
            case 19: case_523: {
                asn1->Add(cli::gcnew<Mono::Security::ASN1>(19, System::Text::Encoding::get_ASCII()->GetBytes_49806e8e98b1c1db(this->attrValue)));
                break;
            }
            case 22: case_524: {
                asn1->Add(cli::gcnew<Mono::Security::ASN1>(22, System::Text::Encoding::get_ASCII()->GetBytes_49806e8e98b1c1db(this->attrValue)));
                break;
            }
            case 30: case_525: {
                asn1->Add(cli::gcnew<Mono::Security::ASN1>(30, System::Text::Encoding::get_BigEndianUnicode()->GetBytes_49806e8e98b1c1db(this->attrValue)));
                break;
            }
        }
        return asn1;
    }
    
    Mono::Security::ASN1* AttributeTypeAndValue::GetASN12() {
        return GetASN1(this->encoding);
    }
    
    cli::array<unsigned char>* AttributeTypeAndValue::GetBytes(unsigned char encoding) {
        return GetASN1(encoding)->GetBytes_b91405229279a4ac();
    }
    
    cli::array<unsigned char>* AttributeTypeAndValue::GetBytes2() {
        return GetASN12()->GetBytes_b91405229279a4ac();
    }
    
    unsigned char AttributeTypeAndValue::SelectBestEncoding() {
        for(auto tmp_142 : this->attrValue) {
            auto c = cli::cast<char16_t>(tmp_142);
            {
                switch(c) {
                    case u'@': case u'_': case_526: {
                        return 30;
                    }
                    default: case_527: {
                        if(((int32_t)(c) > 127)) 
                        {
                            return 30;
                        }
                        break;
                    }
                }
            }
        }
        return 19;
    }
    
    System::String* AttributeTypeAndValue::get_Value() {
        return this->attrValue;
    }
    
    System::String* AttributeTypeAndValue::set_Value(System::String* value) {
        if(((this->attrValue != nullptr) && (this->attrValue->get_Length() > this->upperBound))) 
        {
            System::String *msg = Locale::GetText(_T("Value length bigger than upperbound ({0})."));
            throw cli::gcnew<System::FormatException>(System::String::Format2(msg, cli::box(this->upperBound)));
        }
        this->attrValue = value;
        return get_Value();
    }
    
    Mono::Security::ASN1* AttributeTypeAndValue::get_ASN1() {
        return GetASN12();
    }
    
}}}
namespace Mono { namespace Security { namespace X509 {
    
    
    void Name::constructor() {
    }
    
}}}
namespace Mono { namespace Security { namespace X509 {
    
    
    void CommonName::constructor() {
    }
    
}}}
namespace Mono { namespace Security { namespace X509 {
    
    
    void SerialNumber::constructor() {
    }
    
}}}
namespace Mono { namespace Security { namespace X509 {
    
    
    void LocalityName::constructor() {
    }
    
}}}
namespace Mono { namespace Security { namespace X509 {
    
    
    void StateOrProvinceName::constructor() {
    }
    
}}}
namespace Mono { namespace Security { namespace X509 {
    
    
    void OrganizationName::constructor() {
    }
    
}}}
namespace Mono { namespace Security { namespace X509 {
    
    
    void OrganizationalUnitName::constructor() {
    }
    
}}}
namespace Mono { namespace Security { namespace X509 {
    
    
    void EmailAddress::constructor() {
    }
    
}}}
namespace Mono { namespace Security { namespace X509 {
    
    
    void DomainComponent::constructor() {
    }
    
}}}
namespace Mono { namespace Security { namespace X509 {
    
    
    void UserId::constructor() {
    }
    
}}}
namespace Mono { namespace Security { namespace X509 {
    
    
    void Oid2::constructor(System::String* oid) {
    }
    
}}}
namespace Mono { namespace Security { namespace X509 {
    
    
    void Title::constructor() {
    }
    
}}}
namespace Mono { namespace Security { namespace X509 {
    
    
    void CountryName::constructor() {
    }
    
}}}
namespace Mono { namespace Security { namespace X509 {
    
    
    void DnQualifier::constructor() {
    }
    
}}}
namespace Mono { namespace Security { namespace X509 {
    
    
    void Surname::constructor() {
    }
    
}}}
namespace Mono { namespace Security { namespace X509 {
    
    
    void GivenName::constructor() {
    }
    
}}}
namespace Mono { namespace Security { namespace X509 {
    
    
    void Initial::constructor() {
    }
    
}}}
namespace Mono { namespace Security { namespace X509 {
    
    
    void X520::constructor() {
    }
    
}}}
namespace Mono { namespace Security { namespace X509 { namespace Extensions {
    
    
    void BasicConstraintsExtension::constructor() {
        this->extnOid = _T("2.5.29.19");
        this->pathLenConstraint = -1;
    }
    
    void BasicConstraintsExtension::constructor(Mono::Security::ASN1* asn1) {
    }
    
    void BasicConstraintsExtension::constructor(Mono::Security::X509::X509Extension* extension) {
    }
    
    void BasicConstraintsExtension::Decode_cefcb854d4bf305c() {
        this->cA = false;
        this->pathLenConstraint = -1;
        Mono::Security::ASN1 *sequence = cli::gcnew<Mono::Security::ASN1>(this->extnValue->get_Value());
        if(((int32_t)(sequence->get_Tag()) != 48)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Invalid BasicConstraints extension"));
        }
        int32_t n = 0;
        Mono::Security::ASN1 *a = sequence->get_Item(n++);
        if(((a != nullptr) && ((int32_t)(a->get_Tag()) ==  1))) 
        {
            this->cA = ((int32_t)(a->get_Value()->at(0)) ==  255);
            a = sequence->get_Item(n++);
        }
        if(((a != nullptr) && ((int32_t)(a->get_Tag()) ==  2))) 
        {
            this->pathLenConstraint = Mono::Security::ASN1Convert::ToInt32(a);
        }
    }
    
    void BasicConstraintsExtension::Encode_e7b55e24a6cbc279() {
        Mono::Security::ASN1 *seq = cli::gcnew<Mono::Security::ASN1>(48);
        if(this->cA) 
        {
            seq->Add(cli::gcnew<Mono::Security::ASN1>(1, (new cli::array<unsigned char>({255}))));
        }
        if((this->cA && (this->pathLenConstraint >= 0))) 
        {
            seq->Add(Mono::Security::ASN1Convert::FromInt32(this->pathLenConstraint));
        }
        this->extnValue = cli::gcnew<Mono::Security::ASN1>(4);
        this->extnValue->Add(seq);
    }
    
    System::String* BasicConstraintsExtension::ToString_1636a0751cb9ac11() {
        System::Text::StringBuilder *sb = cli::gcnew<System::Text::StringBuilder>();
        sb->Append2(_T("Subject Type="));
        sb->Append2(this->cA ? _T("CA") : _T("End Entity"));
        sb->Append2(System::Environment::get_NewLine());
        sb->Append2(_T("Path Length Constraint="));
        if((this->pathLenConstraint ==  -1)) 
        {
            sb->Append2(_T("None"));
        }
         else 
        {
            sb->Append2(cli::import(this->pathLenConstraint)->ToString3(System::Globalization::CultureInfo::get_InvariantCulture()));
        }
        sb->Append2(System::Environment::get_NewLine());
        return sb->ToString_1636a0751cb9ac11();
    }
    
    bool BasicConstraintsExtension::get_CertificateAuthority() {
        return this->cA;
    }
    
    bool BasicConstraintsExtension::set_CertificateAuthority(bool value) {
        this->cA = value;
        return get_CertificateAuthority();
    }
    
    System::String* BasicConstraintsExtension::get_Name_7f87430b0f20607() {
        return _T("Basic Constraints");
    }
    
    int32_t BasicConstraintsExtension::get_PathLenConstraint() {
        return this->pathLenConstraint;
    }
    
    int32_t BasicConstraintsExtension::set_PathLenConstraint(int32_t value) {
        if((value < -1)) 
        {
            System::String *msg = Locale::GetText2(_T("PathLenConstraint must be positive or -1 for none ({0})."), (new cli::array<System::Object*>({cli::box(value)})));
            throw cli::gcnew<System::ArgumentOutOfRangeException>(msg);
        }
        this->pathLenConstraint = value;
        return get_PathLenConstraint();
    }
    
}}}}
namespace Mono { namespace Security { namespace X509 { namespace Extensions {
    
    
    void KeyUsageExtension::constructor(Mono::Security::ASN1* asn1) {
    }
    
    void KeyUsageExtension::constructor(Mono::Security::X509::X509Extension* extension) {
    }
    
    void KeyUsageExtension::constructor() {
        this->extnOid = _T("2.5.29.15");
    }
    
    void KeyUsageExtension::Decode_cefcb854d4bf305c() {
        Mono::Security::ASN1 *bitString = cli::gcnew<Mono::Security::ASN1>(this->extnValue->get_Value());
        if(((int32_t)(bitString->get_Tag()) != 3)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Invalid KeyUsage extension"));
        }
        int32_t i = 1;
        while((i < bitString->get_Value()->get_Length())) this->kubits = ((this->kubits << 8) + (int32_t)(bitString->get_Value()->at(i++)));
    }
    
    void KeyUsageExtension::Encode_e7b55e24a6cbc279() {
        this->extnValue = cli::gcnew<Mono::Security::ASN1>(4);
        uint16_t ku = (uint16_t)this->kubits;
        unsigned char unused = 16;
        if(((int32_t)(ku) > 0)) 
        {
            for(unused = 15; ((int32_t)(unused) > 0); unused--){
                if((((int32_t)(ku) & 32768) ==  32768)) 
                {
                    break;
                }
                (ku = (uint16_t)((int32_t)(ku) << 1));
            }
            if((this->kubits > 255)) 
            {
                (unused = (unsigned char)((int32_t)(unused) - 8));
                this->extnValue->Add(cli::gcnew<Mono::Security::ASN1>(3, (new cli::array<unsigned char>({unused, (System::Byte)this->kubits, (System::Byte)(this->kubits >> 8)}))));
            }
             else 
            {
                this->extnValue->Add(cli::gcnew<Mono::Security::ASN1>(3, (new cli::array<unsigned char>({unused, (System::Byte)this->kubits}))));
            }
        }
         else 
        {
            this->extnValue->Add(cli::gcnew<Mono::Security::ASN1>(3, (new cli::array<unsigned char>({7, 0}))));
        }
    }
    
    bool KeyUsageExtension::Support(KeyUsages usage) {
        int32_t x = System::Convert::ToInt3219(cli::box(usage), System::Globalization::CultureInfo::get_InvariantCulture());
        return ((x & this->kubits) ==  x);
    }
    
    System::String* KeyUsageExtension::ToString_1636a0751cb9ac11() {
        const System::String *separator = _T(" , ");
        System::Text::StringBuilder *sb = cli::gcnew<System::Text::StringBuilder>();
        if(Support(KeyUsages::digitalSignature)) 
        {
            sb->Append2(_T("Digital Signature"));
        }
        if(Support(KeyUsages::nonRepudiation)) 
        {
            if((sb->get_Length() > 0)) 
            {
                sb->Append2(_T(" , "));
            }
            sb->Append2(_T("Non-Repudiation"));
        }
        if(Support(KeyUsages::keyEncipherment)) 
        {
            if((sb->get_Length() > 0)) 
            {
                sb->Append2(_T(" , "));
            }
            sb->Append2(_T("Key Encipherment"));
        }
        if(Support(KeyUsages::dataEncipherment)) 
        {
            if((sb->get_Length() > 0)) 
            {
                sb->Append2(_T(" , "));
            }
            sb->Append2(_T("Data Encipherment"));
        }
        if(Support(KeyUsages::keyAgreement)) 
        {
            if((sb->get_Length() > 0)) 
            {
                sb->Append2(_T(" , "));
            }
            sb->Append2(_T("Key Agreement"));
        }
        if(Support(KeyUsages::keyCertSign)) 
        {
            if((sb->get_Length() > 0)) 
            {
                sb->Append2(_T(" , "));
            }
            sb->Append2(_T("Certificate Signing"));
        }
        if(Support(KeyUsages::cRLSign)) 
        {
            if((sb->get_Length() > 0)) 
            {
                sb->Append2(_T(" , "));
            }
            sb->Append2(_T("CRL Signing"));
        }
        if(Support(KeyUsages::encipherOnly)) 
        {
            if((sb->get_Length() > 0)) 
            {
                sb->Append2(_T(" , "));
            }
            sb->Append2(_T("Encipher Only "));
        }
        if(Support(KeyUsages::decipherOnly)) 
        {
            if((sb->get_Length() > 0)) 
            {
                sb->Append2(_T(" , "));
            }
            sb->Append2(_T("Decipher Only"));
        }
        sb->Append2(_T("("));
        sb->Append2(cli::import(this->kubits)->ToString5(_T("X2"), System::Globalization::CultureInfo::get_InvariantCulture()));
        sb->Append2(_T(")"));
        sb->Append2(System::Environment::get_NewLine());
        return sb->ToString_1636a0751cb9ac11();
    }
    
    KeyUsages KeyUsageExtension::get_KeyUsage() {
        return (KeyUsages)(this->kubits);
    }
    
    KeyUsages KeyUsageExtension::set_KeyUsage(KeyUsages value) {
        this->kubits = System::Convert::ToInt3219(cli::box(value), System::Globalization::CultureInfo::get_InvariantCulture());
        return get_KeyUsage();
    }
    
    System::String* KeyUsageExtension::get_Name_7f87430b0f20607() {
        return _T("Key Usage");
    }
    
}}}}
namespace Mono { namespace Security { namespace X509 { namespace Extensions {
    
    
    void SubjectKeyIdentifierExtension::constructor() {
        this->extnOid = _T("2.5.29.14");
    }
    
    void SubjectKeyIdentifierExtension::constructor(Mono::Security::ASN1* asn1) {
    }
    
    void SubjectKeyIdentifierExtension::constructor(Mono::Security::X509::X509Extension* extension) {
    }
    
    void SubjectKeyIdentifierExtension::Decode_cefcb854d4bf305c() {
        Mono::Security::ASN1 *sequence = cli::gcnew<Mono::Security::ASN1>(this->extnValue->get_Value());
        if(((int32_t)(sequence->get_Tag()) != 4)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Invalid SubjectKeyIdentifier extension"));
        }
        this->ski = sequence->get_Value();
    }
    
    System::String* SubjectKeyIdentifierExtension::ToString_1636a0751cb9ac11() {
        if((this->ski ==  nullptr)) 
        {
            return nullptr;
        }
        System::Text::StringBuilder *sb = cli::gcnew<System::Text::StringBuilder>();
        int32_t x = 0;
        while((x < this->ski->get_Length())) {
            sb->Append2(cli::import(this->ski->at(x))->ToString5(_T("X2"), System::Globalization::CultureInfo::get_InvariantCulture()));
            if(((x % 2) ==  1)) 
            {
                sb->Append2(_T(" "));
            }
            x++;
        }
        return sb->ToString_1636a0751cb9ac11();
    }
    
    System::String* SubjectKeyIdentifierExtension::get_Name_7f87430b0f20607() {
        return _T("Subject Key Identifier");
    }
    
    cli::array<unsigned char>* SubjectKeyIdentifierExtension::get_Identifier() {
        if((this->ski ==  nullptr)) 
        {
            return nullptr;
        }
        return cli::cast<cli::array<unsigned char>*>(cli::import(this->ski)->Clone());
    }
    
}}}}
namespace Mono { namespace Xml {
    
    
    void SecurityParser::constructor() {
        this->stack = cli::gcnew<System::Collections::Stack>();
    }
    
    void SecurityParser::LoadXml(System::String* xml) {
        this->root = nullptr;
        this->stack->Clear_8c8c25624b18372d();
        SmallXmlParser::Parse(cli::gcnew<System::IO::StringReader>(xml), this);
    }
    
    System::Security::SecurityElement* SecurityParser::ToXml() {
        return this->root;
    }
    
    void SecurityParser::OnStartParsing(SmallXmlParser* parser) {
    }
    
    void SecurityParser::OnProcessingInstruction(System::String* name, System::String* text) {
    }
    
    void SecurityParser::OnIgnorableWhitespace(System::String* s) {
    }
    
    void SecurityParser::OnStartElement(System::String* name, IAttrList* attrs) {
        System::Security::SecurityElement *newel = cli::gcnew<System::Security::SecurityElement>(name);
        if((this->root ==  nullptr)) 
        {
            this->root = newel;
            this->current = newel;
        }
         else 
        {
            System::Security::SecurityElement *parent = cli::cast<System::Security::SecurityElement*>(this->stack->Peek_6b91e1254bdabd34());
            parent->AddChild(newel);
        }
        this->stack->Push_9a8495c8210a673(newel);
        this->current = newel;
        int32_t n = attrs->get_Length_4ee791fdf528d8a();
        for(int32_t i = 0; (i < n); i++) {
            this->current->AddAttribute(attrs->GetName_71efa89033fbba85(i), System::Security::SecurityElement::Escape2(attrs->GetValue_e96b4d39015c72a4(i)));
        }
    }
    
    void SecurityParser::OnEndElement(System::String* name) {
        this->current = cli::cast<System::Security::SecurityElement*>(this->stack->Pop_9492442210514403());
    }
    
    void SecurityParser::OnChars(System::String* ch) {
        this->current->set_Text(System::Security::SecurityElement::Escape2(ch));
    }
    
    void SecurityParser::OnEndParsing(SmallXmlParser* parser) {
    }
    
}}
namespace Mono { namespace Xml {
    
    
    void DefaultHandler::constructor() {
    }
    
    void DefaultHandler::OnStartParsing(SmallXmlParser* parser) {
    }
    
    void DefaultHandler::OnEndParsing(SmallXmlParser* parser) {
    }
    
    void DefaultHandler::OnStartElement(System::String* name, IAttrList* attrs) {
    }
    
    void DefaultHandler::OnEndElement(System::String* name) {
    }
    
    void DefaultHandler::OnChars(System::String* s) {
    }
    
    void DefaultHandler::OnIgnorableWhitespace(System::String* s) {
    }
    
    void DefaultHandler::OnProcessingInstruction(System::String* name, System::String* text) {
    }
    
}}
namespace Mono { namespace Xml {
    
    
    void AttrListImpl::constructor() {
    }
    
    System::String* AttrListImpl::GetName(int32_t i) {
        return this->attrNames->get_Item(i);
    }
    
    System::String* AttrListImpl::GetValue(int32_t i) {
        return this->attrValues->get_Item(i);
    }
    
    System::String* AttrListImpl::GetValue2(System::String* name) {
        for(int32_t i = 0; (i < this->attrNames->get_Count()); i++) {
            if(System::String::op_Equality(this->attrNames->get_Item(i), name)) 
            {
                return this->attrValues->get_Item(i);
            }
        }
        return nullptr;
    }
    
    void AttrListImpl::Clear() {
        this->attrNames->Clear();
        this->attrValues->Clear();
    }
    
    void AttrListImpl::Add(System::String* name, System::String* value) {
        this->attrNames->Add(name);
        this->attrValues->Add(value);
    }
    
    int32_t AttrListImpl::get_Length() {
        return this->attrNames->get_Count();
    }
    
    bool AttrListImpl::get_IsEmpty() {
        return (this->attrNames->get_Count() ==  0);
    }
    
    cli::array<System::String*>* AttrListImpl::get_Names() {
        return this->attrNames->ToArray();
    }
    
    cli::array<System::String*>* AttrListImpl::get_Values() {
        return this->attrValues->ToArray();
    }
    
}}
namespace Mono { namespace Xml {
    
    
    void SmallXmlParser::constructor() {
    }
    
    System::Exception* SmallXmlParser::Error(System::String* msg) {
        return cli::gcnew<SmallXmlParserException>(msg, this->line, this->column);
    }
    
    System::Exception* SmallXmlParser::UnexpectedEndError() {
        cli::array<System::String*> *arr = (new cli::array<System::String*>(this->elementNames->get_Count_a768d394e63a6b27()));
        this->elementNames->CopyTo_f10714ed2802c46b(arr, 0);
        return Error(System::String::Format2(_T("Unexpected end of stream. Element stack content is {0}"), System::String::Join(_T(","), arr)));
    }
    
    bool SmallXmlParser::IsNameChar(char16_t c, bool start) {
        switch(c) {
            case u':': case u'_': case_528: {
                return true;
            }
            case u'-': case u'.': case_529: {
                return !(start);
            }
        }
        if(((int32_t)(c) > 256)) 
        {
            switch(c) {
                case u'\x559': case u'\x6e5': case u'\x6e6': case_530: {
                    return true;
                }
            }
            if(((699 <= (int32_t)(c)) && ((int32_t)(c) <= 705))) 
            {
                return true;
            }
        }
        switch(System::Char::GetUnicodeCategory(c)) {
            case System::Globalization::UnicodeCategory::LowercaseLetter: case System::Globalization::UnicodeCategory::UppercaseLetter: case System::Globalization::UnicodeCategory::OtherLetter: case System::Globalization::UnicodeCategory::TitlecaseLetter: case System::Globalization::UnicodeCategory::LetterNumber: case_531: {
                return true;
            }
            case System::Globalization::UnicodeCategory::SpacingCombiningMark: case System::Globalization::UnicodeCategory::EnclosingMark: case System::Globalization::UnicodeCategory::NonSpacingMark: case System::Globalization::UnicodeCategory::ModifierLetter: case System::Globalization::UnicodeCategory::DecimalDigitNumber: case_532: {
                return !(start);
            }
            default: case_533: {
                return false;
            }
        }
    }
    
    bool SmallXmlParser::IsWhitespace(int32_t c) {
        switch(c) {
            case 32: case 13: case 9: case 10: case_534: {
                return true;
            }
            default: case_535: {
                return false;
            }
        }
    }
    
    void SmallXmlParser::SkipWhitespaces() {
        SkipWhitespaces2(false);
    }
    
    void SmallXmlParser::HandleWhitespaces() {
        while(IsWhitespace(Peek())) this->buffer->Append16((char16_t)Read());
        if(((Peek() != 60) && (Peek() >= 0))) 
        {
            this->isWhitespace = false;
        }
    }
    
    void SmallXmlParser::SkipWhitespaces2(bool expected) {
        while(true) {
            switch(Peek()) {
                case 32: case 13: case 9: case 10: case_536: {
                    Read();
                    if(expected) 
                    {
                        expected = false;
                    }
                    continue;
                }
            }
            if(expected) 
            {
                throw Error(_T("Whitespace is expected."));
            }
            return;
        }
    }
    
    int32_t SmallXmlParser::Peek() {
        return this->reader->Peek_82f04bf3cd196dfd();
    }
    
    int32_t SmallXmlParser::Read() {
        int32_t i = this->reader->Read_1d437d5ac2290f2b();
        if((i ==  10)) 
        {
            this->resetColumn = true;
        }
        if(this->resetColumn) 
        {
            this->line++;
            this->resetColumn = false;
            this->column = 1;
        }
         else 
        {
            this->column++;
        }
        return i;
    }
    
    void SmallXmlParser::Expect(int32_t c) {
        int32_t p = Read();
        if((p < 0)) 
        {
            throw UnexpectedEndError();
        }
         else 
        {
            if((p != c)) 
            {
                throw Error(System::String::Format3(_T("Expected \'{0}\' but got {1}"), cli::box((char16_t)c), cli::box((char16_t)p)));
            }
        }
    }
    
    System::String* SmallXmlParser::ReadUntil(char16_t until, bool handleReferences) {
        while(true) {
            if((Peek() < 0)) 
            {
                throw UnexpectedEndError();
            }
            char16_t c = (char16_t)Read();
            if(((int32_t)(c) ==  (int32_t)(until))) 
            {
                break;
            }
             else 
            {
                if((handleReferences && ((int32_t)(c) ==  38))) 
                {
                    ReadReference();
                }
                 else 
                {
                    this->buffer->Append16(c);
                }
            }
        }
        System::String *ret = this->buffer->ToString_1636a0751cb9ac11();
        this->buffer->set_Length(0);
        return ret;
    }
    
    System::String* SmallXmlParser::ReadName() {
        int32_t idx = 0;
        if(((Peek() < 0) || !(IsNameChar((char16_t)Peek(), true)))) 
        {
            throw Error(_T("XML name start character is expected."));
        }
        for(int32_t i = Peek(); (i >= 0); i = Peek()){
            char16_t c = (char16_t)i;
            if(!(IsNameChar(c, false))) 
            {
                break;
            }
            if((idx ==  this->nameBuffer->get_Length())) 
            {
                cli::array<char16_t> *tmp = (new cli::array<char16_t>((idx * 2)));
                System::Array::Copy(this->nameBuffer, tmp, idx);
                this->nameBuffer = tmp;
            }
            this->nameBuffer->at(idx++) = c;
            Read();
        }
        if((idx ==  0)) 
        {
            throw Error(_T("Valid XML name is expected."));
        }
        return cli::gcnew<System::String>(this->nameBuffer, 0, idx);
    }
    
    void SmallXmlParser::Parse(System::IO::TextReader* input, IContentHandler* handler) {
        this->reader = input;
        this->handler = handler;
        handler->OnStartParsing_60c119bf90baa608(this);
        while((Peek() >= 0)) ReadContent();
        HandleBufferedContent();
        if((this->elementNames->get_Count_a768d394e63a6b27() > 0)) 
        {
            throw Error(System::String::Format2(_T("Insufficient close tag: {0}"), this->elementNames->Peek_6b91e1254bdabd34()));
        }
        handler->OnEndParsing_ddf0252ce1c74235(this);
        Cleanup();
    }
    
    void SmallXmlParser::Cleanup() {
        this->line = 1;
        this->column = 0;
        this->handler = nullptr;
        this->reader = nullptr;
        this->elementNames->Clear_8c8c25624b18372d();
        this->xmlSpaces->Clear_8c8c25624b18372d();
        this->attributes->Clear();
        this->buffer->set_Length(0);
        this->xmlSpace = nullptr;
        this->isWhitespace = false;
    }
    
    void SmallXmlParser::ReadContent() {
        System::String *name;
        if(IsWhitespace(Peek())) 
        {
            if((this->buffer->get_Length() ==  0)) 
            {
                this->isWhitespace = true;
            }
            HandleWhitespaces();
        }
        if((Peek() ==  60)) 
        {
            Read();
            switch(Peek()) {
                case 33: case_537: {
                    Read();
                    if((Peek() ==  91)) 
                    {
                        Read();
                        if(System::String::op_Inequality(ReadName(), _T("CDATA"))) 
                        {
                            throw Error(_T("Invalid declaration markup"));
                        }
                        Expect(91);
                        ReadCDATASection();
                        return;
                    }
                     else 
                    {
                        if((Peek() ==  45)) 
                        {
                            ReadComment();
                            return;
                        }
                         else 
                        {
                            if(System::String::op_Inequality(ReadName(), _T("DOCTYPE"))) 
                            {
                                throw Error(_T("Invalid declaration markup."));
                            }
                             else 
                            {
                                throw Error(_T("This parser does not support document type."));
                            }
                        }
                    }
                }
                case 63: case_538: {
                    HandleBufferedContent();
                    Read();
                    name = ReadName();
                    SkipWhitespaces();
                    System::String *text = System::String::Empty;
                    if((Peek() != 63)) 
                    {
                        while(true) {
                            (text = cli::concat(text, ReadUntil(u'?', false)));
                            if((Peek() ==  62)) 
                            {
                                break;
                            }
                            (text = cli::concat(text, _T("?")));
                        }
                    }
                    this->handler->OnProcessingInstruction_eeedb82cbfe7ab40(name, text);
                    Expect(62);
                    return;
                }
                case 47: case_539: {
                    HandleBufferedContent();
                    if((this->elementNames->get_Count_a768d394e63a6b27() ==  0)) 
                    {
                        throw UnexpectedEndError();
                    }
                    Read();
                    name = ReadName();
                    SkipWhitespaces();
                    System::String *expected = cli::cast<System::String*>(this->elementNames->Pop_9492442210514403());
                    this->xmlSpaces->Pop_9492442210514403();
                    if((this->xmlSpaces->get_Count_a768d394e63a6b27() > 0)) 
                    {
                        this->xmlSpace = cli::cast<System::String*>(this->xmlSpaces->Peek_6b91e1254bdabd34());
                    }
                     else 
                    {
                        this->xmlSpace = nullptr;
                    }
                    if(System::String::op_Inequality(name, expected)) 
                    {
                        throw Error(System::String::Format3(_T("End tag mismatch: expected {0} but found {1}"), expected, name));
                    }
                    this->handler->OnEndElement_47dd703957202fcd(name);
                    Expect(62);
                    return;
                }
                default: case_540: {
                    HandleBufferedContent();
                    name = ReadName();
                    while(((Peek() != 62) && (Peek() != 47))) ReadAttribute(this->attributes);
                    this->handler->OnStartElement_431a5ecd1484562f(name, this->attributes);
                    this->attributes->Clear();
                    SkipWhitespaces();
                    if((Peek() ==  47)) 
                    {
                        Read();
                        this->handler->OnEndElement_47dd703957202fcd(name);
                    }
                     else 
                    {
                        this->elementNames->Push_9a8495c8210a673(name);
                        this->xmlSpaces->Push_9a8495c8210a673(this->xmlSpace);
                    }
                    Expect(62);
                    return;
                }
            }
        }
         else 
        {
            ReadCharacters();
        }
    }
    
    void SmallXmlParser::HandleBufferedContent() {
        if((this->buffer->get_Length() ==  0)) 
        {
            return;
        }
        if(this->isWhitespace) 
        {
            this->handler->OnIgnorableWhitespace_39f85fe38215782c(this->buffer->ToString_1636a0751cb9ac11());
        }
         else 
        {
            this->handler->OnChars_23545ef97e4c205b(this->buffer->ToString_1636a0751cb9ac11());
        }
        this->buffer->set_Length(0);
        this->isWhitespace = false;
    }
    
    void SmallXmlParser::ReadCharacters() {
        this->isWhitespace = false;
        while(true) {
            int32_t i = Peek();
            switch(i) {
                case -1: case_541: {
                    return;
                }
                case 60: case_542: {
                    return;
                }
                case 38: case_543: {
                    Read();
                    ReadReference();
                    continue;
                }
                default: case_544: {
                    this->buffer->Append16((char16_t)Read());
                    continue;
                }
            }
        }
    }
    
    void SmallXmlParser::ReadReference() {
        if((Peek() ==  35)) 
        {
            Read();
            ReadCharacterReference();
        }
         else 
        {
            System::String *name = ReadName();
            Expect(59);
            System::String* tmp_143 = name;
            ::System::Int32 tmp_144 = -1;
            if(::System::String::Equals3(tmp_143, _T("amp"))) tmp_144 = 0;
            if(::System::String::Equals3(tmp_143, _T("quot"))) tmp_144 = 1;
            if(::System::String::Equals3(tmp_143, _T("apos"))) tmp_144 = 2;
            if(::System::String::Equals3(tmp_143, _T("lt"))) tmp_144 = 3;
            if(::System::String::Equals3(tmp_143, _T("gt"))) tmp_144 = 4;
            switch(tmp_144)
            {
                case 0: case_545: 
                {
                    this->buffer->Append16(u'&');
                    break;
                }
                case 1: case_546: 
                {
                    this->buffer->Append16(u'"');
                    break;
                }
                case 2: case_547: 
                {
                    this->buffer->Append16(u'\'');
                    break;
                }
                case 3: case_548: 
                {
                    this->buffer->Append16(u'<');
                    break;
                }
                case 4: case_549: 
                {
                    this->buffer->Append16(u'>');
                    break;
                }
                default: case_550: 
                {
                    throw Error(_T("General non-predefined entity reference is not supported in this parser."));
                }
            }
        }
    }
    
    int32_t SmallXmlParser::ReadCharacterReference() {
        int32_t n = 0;
        if((Peek() ==  120)) 
        {
            Read();
            for(int32_t i = Peek(); (i >= 0); i = Peek()){
                if(((48 <= i) && (i <= 57))) 
                {
                    n = (n << (((4 + i) - 48) & 31));
                }
                 else 
                {
                    if(((65 <= i) && (i <= 70))) 
                    {
                        n = (n << ((((4 + i) - 65) + 10) & 31));
                    }
                     else 
                    {
                        if(((97 <= i) && (i <= 102))) 
                        {
                            n = (n << ((((4 + i) - 97) + 10) & 31));
                        }
                         else 
                        {
                            break;
                        }
                    }
                }
                Read();
            }
        }
         else 
        {
            for(int32_t i = Peek(); (i >= 0); i = Peek()){
                if(((48 <= i) && (i <= 57))) 
                {
                    n = (n << (((4 + i) - 48) & 31));
                }
                 else 
                {
                    break;
                }
                Read();
            }
        }
        return n;
    }
    
    void SmallXmlParser::ReadAttribute(AttrListImpl* a) {
        SkipWhitespaces2(true);
        if(((Peek() ==  47) || (Peek() ==  62))) 
        {
            return;
        }
        System::String *name = ReadName();
        System::String *value;
        SkipWhitespaces();
        Expect(61);
        SkipWhitespaces();
        switch(Read()) {
            case 39: case_551: {
                value = ReadUntil(u'\'', true);
                break;
            }
            case 34: case_552: {
                value = ReadUntil(u'"', true);
                break;
            }
            default: case_553: {
                throw Error(_T("Invalid attribute value markup."));
            }
        }
        if(System::String::op_Equality(name, _T("xml:space"))) 
        {
            this->xmlSpace = value;
        }
        a->Add(name, value);
    }
    
    void SmallXmlParser::ReadCDATASection() {
        int32_t nBracket = 0;
        while(true) {
            if((Peek() < 0)) 
            {
                throw UnexpectedEndError();
            }
            char16_t c = (char16_t)Read();
            if(((int32_t)(c) ==  93)) 
            {
                nBracket++;
            }
             else 
            {
                if((((int32_t)(c) ==  62) && (nBracket > 1))) 
                {
                    for(int32_t i = nBracket; (i > 2); i--) {
                        this->buffer->Append16(u']');
                    }
                    break;
                }
                 else 
                {
                    for(int32_t i = 0; (i < nBracket); i++) {
                        this->buffer->Append16(u']');
                    }
                    nBracket = 0;
                    this->buffer->Append16(c);
                }
            }
        }
    }
    
    void SmallXmlParser::ReadComment() {
        Expect(45);
        Expect(45);
        while(true) {
            if((Read() != 45)) 
            {
                continue;
            }
            if((Read() != 45)) 
            {
                continue;
            }
            if((Read() != 62)) 
            {
                throw Error(_T("\'--\' is not allowed inside comment markup."));
            }
            break;
        }
    }
    
}}
namespace Mono { namespace Xml {
    
    
    void SmallXmlParserException::constructor(System::String* msg, int32_t line, int32_t column) {
        this->line = line;
        this->column = column;
    }
    
    int32_t SmallXmlParserException::get_Line() {
        return this->line;
    }
    
    int32_t SmallXmlParserException::get_Column() {
        return this->column;
    }
    
}}
namespace System {
    
    
    void AccessViolationException::constructor() {
        this->set_HResult(-2147467261);
    }
    
    void AccessViolationException::constructor(String* message) {
        this->set_HResult(-2147467261);
    }
    
    void AccessViolationException::constructor(String* message, Exception* innerException) {
        this->set_HResult(-2147467261);
    }
    
    void AccessViolationException::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
    }
    
}
namespace System {
    
    
    void ActivationContext::constructor(ApplicationIdentity* identity) {
        this->_appid = identity;
    }
    
    void ActivationContext::Finalize_1e60813e63b360d0() {
        {
            cli::finally_guard([&]() {
                Finalize_b946fbc32e26afd6();
            });
            Dispose2(false);
        }
    }
    
    ActivationContext* ActivationContext::CreatePartialActivationContext(ApplicationIdentity* identity) {
        if((identity ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("identity"));
        }
        return cli::gcnew<ActivationContext>(identity);
    }
    
    ActivationContext* ActivationContext::CreatePartialActivationContext2(ApplicationIdentity* identity, cli::array<String*>* manifestPaths) {
        if((identity ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("identity"));
        }
        if((manifestPaths ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("manifestPaths"));
        }
        return cli::gcnew<ActivationContext>(identity);
    }
    
    void ActivationContext::Dispose() {
        Dispose2(true);
        GC::SuppressFinalize(this);
    }
    
    void ActivationContext::Dispose2(bool disposing) {
        if(this->_disposed) 
        {
            if(disposing) 
            {
            }
            this->_disposed = true;
        }
    }
    
    void ActivationContext::GetObjectData(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        if((info ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("info"));
        }
    }
    
    ContextForm ActivationContext::get_Form() {
        return this->_form;
    }
    
    ApplicationIdentity* ActivationContext::get_Identity() {
        return this->_appid;
    }
    
}
namespace System {
    
    
    void Activator::constructor() {
    }
    
    Runtime::Remoting::ObjectHandle* Activator::CreateComInstanceFrom(String* assemblyName, String* typeName) {
        if((assemblyName ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("assemblyName"));
        }
        if((typeName ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("typeName"));
        }
        if((assemblyName->get_Length() ==  0)) 
        {
            throw cli::gcnew<ArgumentException>(_T("assemblyName"));
        }
        throw cli::gcnew<NotImplementedException>();
    }
    
    Runtime::Remoting::ObjectHandle* Activator::CreateComInstanceFrom2(String* assemblyName, String* typeName, cli::array<unsigned char>* hashValue, Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm) {
        if((assemblyName ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("assemblyName"));
        }
        if((typeName ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("typeName"));
        }
        if((assemblyName->get_Length() ==  0)) 
        {
            throw cli::gcnew<ArgumentException>(_T("assemblyName"));
        }
        throw cli::gcnew<NotImplementedException>();
    }
    
    Runtime::Remoting::ObjectHandle* Activator::CreateInstanceFrom(String* assemblyFile, String* typeName) {
        return CreateInstanceFrom2(assemblyFile, typeName, nullptr);
    }
    
    Runtime::Remoting::ObjectHandle* Activator::CreateInstanceFrom2(String* assemblyFile, String* typeName, cli::array<Object*>* activationAttributes) {
        return Activator::CreateInstanceFrom3(assemblyFile, typeName, false, (Reflection::BindingFlags)532L, nullptr, nullptr, nullptr, activationAttributes, nullptr);
    }
    
    Runtime::Remoting::ObjectHandle* Activator::CreateInstanceFrom3(String* assemblyFile, String* typeName, bool ignoreCase, Reflection::BindingFlags bindingAttr, Reflection::Binder* binder, cli::array<Object*>* args, Globalization::CultureInfo* culture, cli::array<Object*>* activationAttributes, Security::Policy::Evidence* securityInfo) {
        Reflection::Assembly *assembly = Reflection::Assembly::LoadFrom3(assemblyFile, securityInfo);
        if(Reflection::Assembly::op_Equality(assembly, nullptr)) 
        {
            return nullptr;
        }
        Type *type = assembly->GetType_30e9b2dcc4956479(typeName, true, ignoreCase);
        if(Type::op_Equality2(type, nullptr)) 
        {
            return nullptr;
        }
        Object *obj = CreateInstance12(type, bindingAttr, binder, args, culture, activationAttributes);
        return (obj != nullptr) ? cli::gcnew<Runtime::Remoting::ObjectHandle>(obj) : nullptr;
    }
    
    Runtime::Remoting::ObjectHandle* Activator::CreateInstance(String* assemblyName, String* typeName) {
        if((assemblyName ==  nullptr)) 
        {
            assemblyName = Reflection::Assembly::GetCallingAssembly()->GetName_7088a38b93d0dcc5()->get_Name();
        }
        return Activator::CreateInstance2(assemblyName, typeName, nullptr);
    }
    
    Runtime::Remoting::ObjectHandle* Activator::CreateInstance2(String* assemblyName, String* typeName, cli::array<Object*>* activationAttributes) {
        if((assemblyName ==  nullptr)) 
        {
            assemblyName = Reflection::Assembly::GetCallingAssembly()->GetName_7088a38b93d0dcc5()->get_Name();
        }
        return Activator::CreateInstance3(assemblyName, typeName, false, (Reflection::BindingFlags)532L, nullptr, nullptr, nullptr, activationAttributes, nullptr);
    }
    
    Runtime::Remoting::ObjectHandle* Activator::CreateInstance3(String* assemblyName, String* typeName, bool ignoreCase, Reflection::BindingFlags bindingAttr, Reflection::Binder* binder, cli::array<Object*>* args, Globalization::CultureInfo* culture, cli::array<Object*>* activationAttributes, Security::Policy::Evidence* securityInfo) {
        Reflection::Assembly *assembly = nullptr;
        if((assemblyName ==  nullptr)) 
        {
            assembly = Reflection::Assembly::GetCallingAssembly();
        }
         else 
        {
            assembly = Reflection::Assembly::Load2(assemblyName, securityInfo);
        }
        Type *type = assembly->GetType_30e9b2dcc4956479(typeName, true, ignoreCase);
        Object *obj = CreateInstance12(type, bindingAttr, binder, args, culture, activationAttributes);
        return (obj != nullptr) ? cli::gcnew<Runtime::Remoting::ObjectHandle>(obj) : nullptr;
    }
    
    Runtime::Remoting::ObjectHandle* Activator::CreateInstance4(ActivationContext* activationContext) {
        throw cli::gcnew<NotImplementedException>();
    }
    
    Runtime::Remoting::ObjectHandle* Activator::CreateInstance5(ActivationContext* activationContext, cli::array<String*>* activationCustomData) {
        throw cli::gcnew<NotImplementedException>();
    }
    
    Runtime::Remoting::ObjectHandle* Activator::CreateInstanceFrom4(AppDomain* domain, String* assemblyFile, String* typeName) {
        if((domain ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("domain"));
        }
        return domain->CreateInstanceFrom2(assemblyFile, typeName);
    }
    
    Runtime::Remoting::ObjectHandle* Activator::CreateInstanceFrom5(AppDomain* domain, String* assemblyFile, String* typeName, bool ignoreCase, Reflection::BindingFlags bindingAttr, Reflection::Binder* binder, cli::array<Object*>* args, Globalization::CultureInfo* culture, cli::array<Object*>* activationAttributes, Security::Policy::Evidence* securityAttributes) {
        if((domain ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("domain"));
        }
        return domain->CreateInstanceFrom4(assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes);
    }
    
    Runtime::Remoting::ObjectHandle* Activator::CreateInstance6(AppDomain* domain, String* assemblyName, String* typeName) {
        if((domain ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("domain"));
        }
        return domain->CreateInstance(assemblyName, typeName);
    }
    
    Runtime::Remoting::ObjectHandle* Activator::CreateInstance7(AppDomain* domain, String* assemblyName, String* typeName, bool ignoreCase, Reflection::BindingFlags bindingAttr, Reflection::Binder* binder, cli::array<Object*>* args, Globalization::CultureInfo* culture, cli::array<Object*>* activationAttributes, Security::Policy::Evidence* securityAttributes) {
        if((domain ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("domain"));
        }
        return domain->CreateInstance3(assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes);
    }
    
    Object* Activator::CreateInstance8(Type* type) {
        return CreateInstance13(type, false);
    }
    
    Object* Activator::CreateInstance9(Type* type, cli::array<Object*>* args) {
        return CreateInstance10(type, args, (new cli::array<Object*>(0)));
    }
    
    Object* Activator::CreateInstance10(Type* type, cli::array<Object*>* args, cli::array<Object*>* activationAttributes) {
        return CreateInstance12(type, Reflection::BindingFlags::Default2, Reflection::Binder::get_DefaultBinder(), args, nullptr, activationAttributes);
    }
    
    Object* Activator::CreateInstance11(Type* type, Reflection::BindingFlags bindingAttr, Reflection::Binder* binder, cli::array<Object*>* args, Globalization::CultureInfo* culture) {
        return CreateInstance12(type, bindingAttr, binder, args, culture, (new cli::array<Object*>(0)));
    }
    
    Object* Activator::CreateInstance12(Type* type, Reflection::BindingFlags bindingAttr, Reflection::Binder* binder, cli::array<Object*>* args, Globalization::CultureInfo* culture, cli::array<Object*>* activationAttributes) {
        CheckType(type);
        if(type->get_ContainsGenericParameters_19598881dd690ad3()) 
        {
            throw cli::gcnew<ArgumentException>(cli::concat(type, _T(" is an open generic type")), _T("type"));
        }
        if(((int32_t)(((int32_t)(bindingAttr) & 127)) ==  0)) 
        {
            (bindingAttr = (Reflection::BindingFlags)(((int32_t)(bindingAttr) | 20)));
        }
        if((binder ==  nullptr)) 
        {
            binder = Reflection::Binder::get_DefaultBinder();
        }
        Object *state;
        Reflection::ConstructorInfo *ctor = cli::cast<Reflection::ConstructorInfo*>(binder->BindToMethod_c4d067cd0e5ef7a(bindingAttr, type->GetConstructors_736b6e990b94b352(bindingAttr)->template CovariantCast<Reflection::MethodBase*>(), args, nullptr, nullptr, nullptr, state));
        if(Reflection::ConstructorInfo::op_Equality(ctor, nullptr)) 
        {
            if((type->get_IsValueType() && ((args ==  nullptr) || (args->get_Length() ==  0)))) 
            {
                return CreateInstanceInternal(type);
            }
            Text::StringBuilder *sb = cli::gcnew<Text::StringBuilder>();
            if((args != nullptr)) 
            {
                for(int32_t i = 0; (i < args->get_Length()); i++){
                    if((i > 0)) 
                    {
                        sb->Append2(_T(", "));
                    }
                    Object *argument = args->at(i);
                    Type *arg_type = (argument != nullptr) ? argument->GetType() : nullptr;
                    sb->Append2(Type::op_Inequality2(arg_type, nullptr) ? arg_type->ToString_1636a0751cb9ac11() : _T("(unknown)"));
                }
            }
            throw cli::gcnew<MissingMethodException>(String::Format3(Locale::GetText(_T("No constructor found for {0}::.ctor({1})")), type->get_FullName_7e8fa72ba225e1a4(), sb));
        }
        CheckAbstractType(type);
        if(((activationAttributes != nullptr) && (activationAttributes->get_Length() > 0))) 
        {
            if(!(type->get_IsMarshalByRef())) 
            {
                String *msg = Locale::GetText2(_T("Type \'{0}\' doesn\'t derive from MarshalByRefObject."), (new cli::array<Object*>({type->get_FullName_7e8fa72ba225e1a4()})));
                throw cli::gcnew<NotSupportedException>(msg);
            }
            Object *newOb = Runtime::Remoting::Activation::ActivationServices::CreateProxyFromAttributes(type, activationAttributes);
            if((newOb != nullptr)) 
            {
                ctor->Invoke_ba5f4e14507fdb95(newOb, bindingAttr, binder, args, culture);
                return newOb;
            }
        }
        return ctor->Invoke_d9ede2dfc2f2dd62(bindingAttr, binder, args, culture);
    }
    
    Object* Activator::CreateInstance13(Type* type, bool nonPublic) {
        CheckType(type);
        if(type->get_ContainsGenericParameters_19598881dd690ad3()) 
        {
            throw cli::gcnew<ArgumentException>(cli::concat(type, _T(" is an open generic type")), _T("type"));
        }
        CheckAbstractType(type);
        Reflection::ConstructorInfo *ctor;
        MonoType *monoType = cli::as<MonoType*>(type);
        if(Type::op_Inequality2(monoType, nullptr)) 
        {
            ctor = monoType->GetDefaultConstructor();
            if(((!(nonPublic) && Reflection::ConstructorInfo::op_Inequality(ctor, nullptr)) && !(ctor->get_IsPublic()))) 
            {
                ctor = nullptr;
            }
        }
         else 
        {
            Reflection::BindingFlags flags = (Reflection::BindingFlags)20L;
            if(nonPublic) 
            {
                (flags = (Reflection::BindingFlags)(((int32_t)(flags) | 32)));
            }
            ctor = type->GetConstructor4(flags, nullptr, Reflection::CallingConventions::Any, Type::EmptyTypes, nullptr);
        }
        if(Reflection::ConstructorInfo::op_Equality(ctor, nullptr)) 
        {
            if(type->get_IsValueType()) 
            {
                return CreateInstanceInternal(type);
            }
            throw cli::gcnew<MissingMethodException>(Locale::GetText(cli::concat(_T("Default constructor not found for type "), type->get_FullName_7e8fa72ba225e1a4())));
        }
        return ctor->Invoke(nullptr);
    }
    
    void Activator::CheckType(Type* type) {
        if(Type::op_Equality2(type, nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("type"));
        }
        if((((Type::op_Equality2(type, cli::typeof<Type>::info) || Type::op_Equality2(type, cli::typeof<Type>::info)) || Type::op_Equality2(type, cli::typeof<Type>::info)) || Type::op_Equality2(type, cli::typeof<Type>::info))) 
        {
            String *msg = Locale::GetText2(_T("CreateInstance cannot be used to create this type ({0})."), (new cli::array<Object*>({type->get_FullName_7e8fa72ba225e1a4()})));
            throw cli::gcnew<NotSupportedException>(msg);
        }
    }
    
    void Activator::CheckAbstractType(Type* type) {
        if(type->get_IsAbstract()) 
        {
            String *msg = Locale::GetText2(_T("Cannot create an abstract class \'{0}\'."), (new cli::array<Object*>({type->get_FullName_7e8fa72ba225e1a4()})));
            throw cli::gcnew<MissingMethodException>(msg);
        }
    }
    
    Object* Activator::GetObject(Type* type, String* url) {
        if(Type::op_Equality2(type, nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("type"));
        }
        return Runtime::Remoting::RemotingServices::Connect(type, url);
    }
    
    Object* Activator::GetObject2(Type* type, String* url, Object* state) {
        if(Type::op_Equality2(type, nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("type"));
        }
        return Runtime::Remoting::RemotingServices::Connect2(type, url, state);
    }
    
    Object* Activator::CreateInstanceInternal(Type* type) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Activator::GetIDsOfNames(Guid riid, void* rgszNames, uint32_t cNames, uint32_t lcid, void* rgDispId) {
        throw cli::gcnew<NotImplementedException>();
    }
    
    void Activator::GetTypeInfo(uint32_t iTInfo, uint32_t lcid, void* ppTInfo) {
        throw cli::gcnew<NotImplementedException>();
    }
    
    void Activator::GetTypeInfoCount(uint32_t pcTInfo) {
        throw cli::gcnew<NotImplementedException>();
    }
    
    void Activator::Invoke(uint32_t dispIdMember, Guid riid, uint32_t lcid, int16_t wFlags, void* pDispParams, void* pVarResult, void* pExcepInfo, void* puArgErr) {
        throw cli::gcnew<NotImplementedException>();
    }
    
    Runtime::Remoting::ObjectHandle* Activator::CreateInstance14(String* assemblyName, String* typeName, bool ignoreCase, Reflection::BindingFlags bindingAttr, Reflection::Binder* binder, cli::array<Object*>* args, Globalization::CultureInfo* culture, cli::array<Object*>* activationAttributes) {
        Reflection::Assembly *assembly = nullptr;
        if((assemblyName ==  nullptr)) 
        {
            assembly = Reflection::Assembly::GetCallingAssembly();
        }
         else 
        {
            assembly = Reflection::Assembly::Load(assemblyName);
        }
        Type *type = assembly->GetType_30e9b2dcc4956479(typeName, true, ignoreCase);
        Object *obj = CreateInstance12(type, bindingAttr, binder, args, culture, activationAttributes);
        return (obj != nullptr) ? cli::gcnew<Runtime::Remoting::ObjectHandle>(obj) : nullptr;
    }
    
    Runtime::Remoting::ObjectHandle* Activator::CreateInstance15(AppDomain* domain, String* assemblyName, String* typeName, bool ignoreCase, Reflection::BindingFlags bindingAttr, Reflection::Binder* binder, cli::array<Object*>* args, Globalization::CultureInfo* culture, cli::array<Object*>* activationAttributes) {
        if((domain ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("domain"));
        }
        return domain->CreateInstance4(assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes);
    }
    
    Runtime::Remoting::ObjectHandle* Activator::CreateInstanceFrom6(String* assemblyFile, String* typeName, bool ignoreCase, Reflection::BindingFlags bindingAttr, Reflection::Binder* binder, cli::array<Object*>* args, Globalization::CultureInfo* culture, cli::array<Object*>* activationAttributes) {
        Reflection::Assembly *assembly = Reflection::Assembly::LoadFrom2(assemblyFile);
        if(Reflection::Assembly::op_Equality(assembly, nullptr)) 
        {
            return nullptr;
        }
        Type *type = assembly->GetType_30e9b2dcc4956479(typeName, true, ignoreCase);
        if(Type::op_Equality2(type, nullptr)) 
        {
            return nullptr;
        }
        Object *obj = CreateInstance12(type, bindingAttr, binder, args, culture, activationAttributes);
        return (obj != nullptr) ? cli::gcnew<Runtime::Remoting::ObjectHandle>(obj) : nullptr;
    }
    
    Runtime::Remoting::ObjectHandle* Activator::CreateInstanceFrom7(AppDomain* domain, String* assemblyFile, String* typeName, bool ignoreCase, Reflection::BindingFlags bindingAttr, Reflection::Binder* binder, cli::array<Object*>* args, Globalization::CultureInfo* culture, cli::array<Object*>* activationAttributes) {
        if((domain ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("domain"));
        }
        return domain->CreateInstanceFrom(assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes);
    }
    
}
namespace System {
    
    
    void AggregateException::constructor() {
    }
    
    void AggregateException::constructor(String* message) {
    }
    
    void AggregateException::constructor(String* message, Exception* innerException) {
        if((innerException ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("innerException"));
        }
        this->innerExceptions->Add(innerException);
    }
    
    void AggregateException::constructor(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
    }
    
    void AggregateException::constructor(cli::array<Exception*>* innerExceptions) {
    }
    
    void AggregateException::constructor(String* message, cli::array<Exception*>* innerExceptions) {
        if((innerExceptions ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("innerExceptions"));
        }
        for(auto tmp_145 : innerExceptions) {
            auto exception = cli::cast<Exception*>(tmp_145);
            if((exception ==  nullptr)) 
            {
                throw cli::gcnew<ArgumentException>(_T("One of the inner exception is null"), _T("innerExceptions"));
            }
        }
        this->innerExceptions->AddRange(innerExceptions);
    }
    
    void AggregateException::constructor(Collections::Generic::IEnumerable2<Exception*>* innerExceptions) {
    }
    
    void AggregateException::constructor(String* message, Collections::Generic::IEnumerable2<Exception*>* innerExceptions) {
    }
    
    AggregateException* AggregateException::Flatten() {
        Collections::Generic::List<Exception*> *inner = cli::gcnew<Collections::Generic::List<Exception*>>();
        for(auto tmp_146 : this->innerExceptions) {
            auto e = cli::cast<Exception*>(tmp_146);
            {
                AggregateException *aggEx = cli::as<AggregateException*>(e);
                if((aggEx != nullptr)) 
                {
                    inner->AddRange(aggEx->Flatten()->get_InnerExceptions());
                }
                 else 
                {
                    inner->Add(e);
                }
            }
        }
        return cli::gcnew<AggregateException>(inner);
    }
    
    void AggregateException::Handle(Func2<Exception*, bool>* predicate) {
        Collections::Generic::List<Exception*> *failed = cli::gcnew<Collections::Generic::List<Exception*>>();
        for(auto tmp_147 : this->innerExceptions) {
            auto e = cli::cast<Exception*>(tmp_147);
            {
                try {
                    if(!(predicate->Invoke(e))) 
                    {
                        failed->Add(e);
                    }
                }
                catch(...) {
                    throw cli::gcnew<AggregateException>(failed);
                }
            }
        }
        if((failed->get_Count() > 0)) 
        {
            throw cli::gcnew<AggregateException>(failed);
        }
    }
    
    void AggregateException::AddChildException(AggregateException* childEx) {
        if((this->innerExceptions ==  nullptr)) 
        {
            this->innerExceptions = cli::gcnew<Collections::Generic::List<Exception*>>();
        }
        if((childEx ==  nullptr)) 
        {
            return;
        }
        this->innerExceptions->Add(childEx);
    }
    
    String* AggregateException::ToString_1636a0751cb9ac11() {
        Text::StringBuilder *finalMessage = cli::gcnew<Text::StringBuilder>(Exception::ToString_1636a0751cb9ac11());
        int32_t currentIndex = -1;
        for(auto tmp_148 : this->innerExceptions) {
            auto e = cli::cast<Exception*>(tmp_148);
            {
                finalMessage->Append2(Environment::get_NewLine());
                finalMessage->Append2(_T(" --> (Inner exception "));
                finalMessage->Append8(++currentIndex);
                finalMessage->Append2(_T(") "));
                finalMessage->Append2(e->ToString_1636a0751cb9ac11());
                finalMessage->Append2(Environment::get_NewLine());
            }
        }
        return finalMessage->ToString_1636a0751cb9ac11();
    }
    
    void AggregateException::GetObjectData_bc9b88d7eb43b6d8(Runtime::Serialization::SerializationInfo* info, Runtime::Serialization::StreamingContext context) {
        throw cli::gcnew<NotImplementedException>();
    }
    
    Exception* AggregateException::GetBaseException_3c80088934e2347b() {
        if(((this->innerExceptions ==  nullptr) || (this->innerExceptions->get_Count() ==  0))) 
        {
            return this;
        }
        return this->innerExceptions->get_Item(0)->GetBaseException_3c80088934e2347b();
    }
    
    Collections::ObjectModel::ReadOnlyCollection<Exception*>* AggregateException::get_InnerExceptions() {
        return this->innerExceptions->AsReadOnly();
    }
    
}
namespace System {
    
    
    void Loader::constructor(String* assembly) {
        this->assembly = assembly;
    }
    
    void Loader::Load() {
        Reflection::Assembly::LoadFrom2(this->assembly);
    }
    
}
namespace System {
    
    
    void Initializer::constructor(AppDomainInitializer* initializer, cli::array<String*>* arguments) {
        this->initializer = initializer;
        this->arguments = arguments;
    }
    
    void Initializer::Initialize() {
        this->initializer->Invoke(this->arguments);
    }
    
}
namespace System {
    
    String*  AppDomain::_process_guid;
    Collections::Hashtable*  AppDomain::type_resolve_in_progress;
    Collections::Hashtable*  AppDomain::assembly_resolve_in_progress;
    Collections::Hashtable*  AppDomain::assembly_resolve_in_progress_refonly;
    Security::Principal::IPrincipal*  AppDomain::_principal;
    AppDomain*  AppDomain::default_domain;
    
    void AppDomain::constructor() {
    }
    
    AppDomainSetup* AppDomain::getSetup() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    String* AppDomain::getFriendlyName() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    AppDomain* AppDomain::getCurDomain() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    AppDomain* AppDomain::getRootDomain() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void AppDomain::AppendPrivatePath(String* path) {
        if(((path ==  nullptr) || (path->get_Length() ==  0))) 
        {
            return;
        }
        AppDomainSetup *setup = this->get_SetupInformationNoCopy();
        String *pp = setup->get_PrivateBinPath();
        if(((pp ==  nullptr) || (pp->get_Length() ==  0))) 
        {
            setup->set_PrivateBinPath(path);
            return;
        }
        pp = pp->Trim();
        if(((int32_t)(pp->get_Chars((pp->get_Length() - 1))) != (int32_t)(IO::Path::PathSeparator))) 
        {
            (pp = cli::concat(pp, cli::box(IO::Path::PathSeparator)));
        }
        setup->set_PrivateBinPath(cli::concat(pp, path));
    }
    
    void AppDomain::ClearPrivatePath() {
        this->get_SetupInformationNoCopy()->set_PrivateBinPath(String::Empty);
    }
    
    void AppDomain::ClearShadowCopyPath() {
        this->get_SetupInformationNoCopy()->set_ShadowCopyDirectories(String::Empty);
    }
    
    Runtime::Remoting::ObjectHandle* AppDomain::CreateComInstanceFrom(String* assemblyName, String* typeName) {
        return Activator::CreateComInstanceFrom(assemblyName, typeName);
    }
    
    Runtime::Remoting::ObjectHandle* AppDomain::CreateComInstanceFrom2(String* assemblyFile, String* typeName, cli::array<unsigned char>* hashValue, Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm) {
        return Activator::CreateComInstanceFrom2(assemblyFile, typeName, hashValue, hashAlgorithm);
    }
    
    Runtime::Remoting::ObjectHandle* AppDomain::CreateInstance(String* assemblyName, String* typeName) {
        if((assemblyName ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("assemblyName"));
        }
        return Activator::CreateInstance(assemblyName, typeName);
    }
    
    Runtime::Remoting::ObjectHandle* AppDomain::CreateInstance2(String* assemblyName, String* typeName, cli::array<Object*>* activationAttributes) {
        if((assemblyName ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("assemblyName"));
        }
        return Activator::CreateInstance2(assemblyName, typeName, activationAttributes);
    }
    
    Runtime::Remoting::ObjectHandle* AppDomain::CreateInstance3(String* assemblyName, String* typeName, bool ignoreCase, Reflection::BindingFlags bindingAttr, Reflection::Binder* binder, cli::array<Object*>* args, Globalization::CultureInfo* culture, cli::array<Object*>* activationAttributes, Security::Policy::Evidence* securityAttributes) {
        if((assemblyName ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("assemblyName"));
        }
        return Activator::CreateInstance3(assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes);
    }
    
    Object* AppDomain::CreateInstanceAndUnwrap(String* assemblyName, String* typeName) {
        Runtime::Remoting::ObjectHandle *oh = CreateInstance(assemblyName, typeName);
        return (oh != nullptr) ? oh->Unwrap() : nullptr;
    }
    
    Object* AppDomain::CreateInstanceAndUnwrap2(String* assemblyName, String* typeName, cli::array<Object*>* activationAttributes) {
        Runtime::Remoting::ObjectHandle *oh = CreateInstance2(assemblyName, typeName, activationAttributes);
        return (oh != nullptr) ? oh->Unwrap() : nullptr;
    }
    
    Object* AppDomain::CreateInstanceAndUnwrap3(String* assemblyName, String* typeName, bool ignoreCase, Reflection::BindingFlags bindingAttr, Reflection::Binder* binder, cli::array<Object*>* args, Globalization::CultureInfo* culture, cli::array<Object*>* activationAttributes, Security::Policy::Evidence* securityAttributes) {
        Runtime::Remoting::ObjectHandle *oh = CreateInstance3(assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes);
        return (oh != nullptr) ? oh->Unwrap() : nullptr;
    }
    
    Runtime::Remoting::ObjectHandle* AppDomain::CreateInstance4(String* assemblyName, String* typeName, bool ignoreCase, Reflection::BindingFlags bindingAttr, Reflection::Binder* binder, cli::array<Object*>* args, Globalization::CultureInfo* culture, cli::array<Object*>* activationAttributes) {
        if((assemblyName ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("assemblyName"));
        }
        return Activator::CreateInstance3(assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, nullptr);
    }
    
    Object* AppDomain::CreateInstanceAndUnwrap4(String* assemblyName, String* typeName, bool ignoreCase, Reflection::BindingFlags bindingAttr, Reflection::Binder* binder, cli::array<Object*>* args, Globalization::CultureInfo* culture, cli::array<Object*>* activationAttributes) {
        Runtime::Remoting::ObjectHandle *oh = CreateInstance4(assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes);
        return (oh != nullptr) ? oh->Unwrap() : nullptr;
    }
    
    Runtime::Remoting::ObjectHandle* AppDomain::CreateInstanceFrom(String* assemblyFile, String* typeName, bool ignoreCase, Reflection::BindingFlags bindingAttr, Reflection::Binder* binder, cli::array<Object*>* args, Globalization::CultureInfo* culture, cli::array<Object*>* activationAttributes) {
        if((assemblyFile ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("assemblyFile"));
        }
        return Activator::CreateInstanceFrom3(assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, nullptr);
    }
    
    Object* AppDomain::CreateInstanceFromAndUnwrap(String* assemblyFile, String* typeName, bool ignoreCase, Reflection::BindingFlags bindingAttr, Reflection::Binder* binder, cli::array<Object*>* args, Globalization::CultureInfo* culture, cli::array<Object*>* activationAttributes) {
        Runtime::Remoting::ObjectHandle *oh = CreateInstanceFrom(assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes);
        return (oh != nullptr) ? oh->Unwrap() : nullptr;
    }
    
    Runtime::Remoting::ObjectHandle* AppDomain::CreateInstanceFrom2(String* assemblyFile, String* typeName) {
        if((assemblyFile ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("assemblyFile"));
        }
        return Activator::CreateInstanceFrom(assemblyFile, typeName);
    }
    
    Runtime::Remoting::ObjectHandle* AppDomain::CreateInstanceFrom3(String* assemblyFile, String* typeName, cli::array<Object*>* activationAttributes) {
        if((assemblyFile ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("assemblyFile"));
        }
        return Activator::CreateInstanceFrom2(assemblyFile, typeName, activationAttributes);
    }
    
    Runtime::Remoting::ObjectHandle* AppDomain::CreateInstanceFrom4(String* assemblyFile, String* typeName, bool ignoreCase, Reflection::BindingFlags bindingAttr, Reflection::Binder* binder, cli::array<Object*>* args, Globalization::CultureInfo* culture, cli::array<Object*>* activationAttributes, Security::Policy::Evidence* securityAttributes) {
        if((assemblyFile ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("assemblyFile"));
        }
        return Activator::CreateInstanceFrom3(assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes);
    }
    
    Object* AppDomain::CreateInstanceFromAndUnwrap2(String* assemblyName, String* typeName) {
        Runtime::Remoting::ObjectHandle *oh = CreateInstanceFrom2(assemblyName, typeName);
        return (oh != nullptr) ? oh->Unwrap() : nullptr;
    }
    
    Object* AppDomain::CreateInstanceFromAndUnwrap3(String* assemblyName, String* typeName, cli::array<Object*>* activationAttributes) {
        Runtime::Remoting::ObjectHandle *oh = CreateInstanceFrom3(assemblyName, typeName, activationAttributes);
        return (oh != nullptr) ? oh->Unwrap() : nullptr;
    }
    
    Object* AppDomain::CreateInstanceFromAndUnwrap4(String* assemblyName, String* typeName, bool ignoreCase, Reflection::BindingFlags bindingAttr, Reflection::Binder* binder, cli::array<Object*>* args, Globalization::CultureInfo* culture, cli::array<Object*>* activationAttributes, Security::Policy::Evidence* securityAttributes) {
        Runtime::Remoting::ObjectHandle *oh = CreateInstanceFrom4(assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes);
        return (oh != nullptr) ? oh->Unwrap() : nullptr;
    }
    
    Reflection::Emit::AssemblyBuilder* AppDomain::DefineDynamicAssembly(Reflection::AssemblyName* name, Reflection::Emit::AssemblyBuilderAccess access) {
        return DefineDynamicAssembly9(name, access, nullptr, nullptr, nullptr, nullptr, nullptr, false);
    }
    
    Reflection::Emit::AssemblyBuilder* AppDomain::DefineDynamicAssembly2(Reflection::AssemblyName* name, Reflection::Emit::AssemblyBuilderAccess access, Security::Policy::Evidence* evidence) {
        return DefineDynamicAssembly9(name, access, nullptr, evidence, nullptr, nullptr, nullptr, false);
    }
    
    Reflection::Emit::AssemblyBuilder* AppDomain::DefineDynamicAssembly3(Reflection::AssemblyName* name, Reflection::Emit::AssemblyBuilderAccess access, String* dir) {
        return DefineDynamicAssembly9(name, access, dir, nullptr, nullptr, nullptr, nullptr, false);
    }
    
    Reflection::Emit::AssemblyBuilder* AppDomain::DefineDynamicAssembly4(Reflection::AssemblyName* name, Reflection::Emit::AssemblyBuilderAccess access, String* dir, Security::Policy::Evidence* evidence) {
        return DefineDynamicAssembly9(name, access, dir, evidence, nullptr, nullptr, nullptr, false);
    }
    
    Reflection::Emit::AssemblyBuilder* AppDomain::DefineDynamicAssembly5(Reflection::AssemblyName* name, Reflection::Emit::AssemblyBuilderAccess access, Security::PermissionSet* requiredPermissions, Security::PermissionSet* optionalPermissions, Security::PermissionSet* refusedPermissions) {
        return DefineDynamicAssembly9(name, access, nullptr, nullptr, requiredPermissions, optionalPermissions, refusedPermissions, false);
    }
    
    Reflection::Emit::AssemblyBuilder* AppDomain::DefineDynamicAssembly6(Reflection::AssemblyName* name, Reflection::Emit::AssemblyBuilderAccess access, Security::Policy::Evidence* evidence, Security::PermissionSet* requiredPermissions, Security::PermissionSet* optionalPermissions, Security::PermissionSet* refusedPermissions) {
        return DefineDynamicAssembly9(name, access, nullptr, evidence, requiredPermissions, optionalPermissions, refusedPermissions, false);
    }
    
    Reflection::Emit::AssemblyBuilder* AppDomain::DefineDynamicAssembly7(Reflection::AssemblyName* name, Reflection::Emit::AssemblyBuilderAccess access, String* dir, Security::PermissionSet* requiredPermissions, Security::PermissionSet* optionalPermissions, Security::PermissionSet* refusedPermissions) {
        return DefineDynamicAssembly9(name, access, dir, nullptr, requiredPermissions, optionalPermissions, refusedPermissions, false);
    }
    
    Reflection::Emit::AssemblyBuilder* AppDomain::DefineDynamicAssembly8(Reflection::AssemblyName* name, Reflection::Emit::AssemblyBuilderAccess access, String* dir, Security::Policy::Evidence* evidence, Security::PermissionSet* requiredPermissions, Security::PermissionSet* optionalPermissions, Security::PermissionSet* refusedPermissions) {
        return DefineDynamicAssembly9(name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions, false);
    }
    
    Reflection::Emit::AssemblyBuilder* AppDomain::DefineDynamicAssembly9(Reflection::AssemblyName* name, Reflection::Emit::AssemblyBuilderAccess access, String* dir, Security::Policy::Evidence* evidence, Security::PermissionSet* requiredPermissions, Security::PermissionSet* optionalPermissions, Security::PermissionSet* refusedPermissions, bool isSynchronized) {
        if((name ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("name"));
        }
        ValidateAssemblyName(name->get_Name());
        Reflection::Emit::AssemblyBuilder *ab = cli::gcnew<Reflection::Emit::AssemblyBuilder>(name, dir, access, false);
        ab->AddPermissionRequests(requiredPermissions, optionalPermissions, refusedPermissions);
        return ab;
    }
    
    Reflection::Emit::AssemblyBuilder* AppDomain::DefineDynamicAssembly10(Reflection::AssemblyName* name, Reflection::Emit::AssemblyBuilderAccess access, String* dir, Security::Policy::Evidence* evidence, Security::PermissionSet* requiredPermissions, Security::PermissionSet* optionalPermissions, Security::PermissionSet* refusedPermissions, bool isSynchronized, Collections::Generic::IEnumerable2<Reflection::Emit::CustomAttributeBuilder*>* assemblyAttributes) {
        Reflection::Emit::AssemblyBuilder *ab = DefineDynamicAssembly9(name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions, isSynchronized);
        if((assemblyAttributes != nullptr)) 
        {
            for(auto tmp_149 : assemblyAttributes) {
                auto cb = cli::cast<Reflection::Emit::CustomAttributeBuilder*>(tmp_149);
                {
                    ab->SetCustomAttribute(cb);
                }
            }
        }
        return ab;
    }
    
    Reflection::Emit::AssemblyBuilder* AppDomain::DefineDynamicAssembly11(Reflection::AssemblyName* name, Reflection::Emit::AssemblyBuilderAccess access, Collections::Generic::IEnumerable2<Reflection::Emit::CustomAttributeBuilder*>* assemblyAttributes) {
        return DefineDynamicAssembly10(name, access, nullptr, nullptr, nullptr, nullptr, nullptr, false, assemblyAttributes);
    }
    
    Reflection::Emit::AssemblyBuilder* AppDomain::DefineDynamicAssembly12(Reflection::AssemblyName* name, Reflection::Emit::AssemblyBuilderAccess access, String* dir, bool isSynchronized, Collections::Generic::IEnumerable2<Reflection::Emit::CustomAttributeBuilder*>* assemblyAttributes) {
        return DefineDynamicAssembly10(name, access, dir, nullptr, nullptr, nullptr, nullptr, isSynchronized, assemblyAttributes);
    }
    
    Reflection::Emit::AssemblyBuilder* AppDomain::DefineDynamicAssembly13(Reflection::AssemblyName* name, Reflection::Emit::AssemblyBuilderAccess access, Collections::Generic::IEnumerable2<Reflection::Emit::CustomAttributeBuilder*>* assemblyAttributes, Security::SecurityContextSource securityContextSource) {
        return DefineDynamicAssembly11(name, access, assemblyAttributes);
    }
    
    Reflection::Emit::AssemblyBuilder* AppDomain::DefineInternalDynamicAssembly(Reflection::AssemblyName* name, Reflection::Emit::AssemblyBuilderAccess access) {
        return cli::gcnew<Reflection::Emit::AssemblyBuilder>(name, nullptr, access, true);
    }
    
    void AppDomain::DoCallBack(CrossAppDomainDelegate* callBackDelegate) {
        if((callBackDelegate != nullptr)) 
        {
            callBackDelegate->Invoke();
        }
    }
    
    int32_t AppDomain::ExecuteAssembly(String* assemblyFile) {
        return ExecuteAssembly3(assemblyFile, nullptr, nullptr);
    }
    
    int32_t AppDomain::ExecuteAssembly2(String* assemblyFile, Security::Policy::Evidence* assemblySecurity) {
        return ExecuteAssembly3(assemblyFile, assemblySecurity, nullptr);
    }
    
    int32_t AppDomain::ExecuteAssembly3(String* assemblyFile, Security::Policy::Evidence* assemblySecurity, cli::array<String*>* args) {
        Reflection::Assembly *a = Reflection::Assembly::LoadFrom3(assemblyFile, assemblySecurity);
        return ExecuteAssemblyInternal(a, args);
    }
    
    int32_t AppDomain::ExecuteAssembly4(String* assemblyFile, Security::Policy::Evidence* assemblySecurity, cli::array<String*>* args, cli::array<unsigned char>* hashValue, Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm) {
        Reflection::Assembly *a = Reflection::Assembly::LoadFrom4(assemblyFile, assemblySecurity, hashValue, hashAlgorithm);
        return ExecuteAssemblyInternal(a, args);
    }
    
    int32_t AppDomain::ExecuteAssembly5(String* assemblyFile, cli::array<String*>* args) {
        Reflection::Assembly *a = Reflection::Assembly::LoadFrom3(assemblyFile, nullptr);
        return ExecuteAssemblyInternal(a, args);
    }
    
    int32_t AppDomain::ExecuteAssembly6(String* assemblyFile, cli::array<String*>* args, cli::array<unsigned char>* hashValue, Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm) {
        Reflection::Assembly *a = Reflection::Assembly::LoadFrom4(assemblyFile, nullptr, hashValue, hashAlgorithm);
        return ExecuteAssemblyInternal(a, args);
    }
    
    int32_t AppDomain::ExecuteAssemblyInternal(Reflection::Assembly* a, cli::array<String*>* args) {
        if(Reflection::MethodInfo::op_Equality(a->get_EntryPoint_63c1ef73cc6df57c(), nullptr)) 
        {
            throw cli::gcnew<MissingMethodException>(cli::concat(_T("Entry point not found in assembly \'"), a->get_FullName_abd52da7f47cce07()));
        }
        return ExecuteAssembly7(a, args);
    }
    
    int32_t AppDomain::ExecuteAssembly7(Reflection::Assembly* a, cli::array<String*>* args) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    cli::array<Reflection::Assembly*>* AppDomain::GetAssemblies(bool refOnly) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    cli::array<Reflection::Assembly*>* AppDomain::GetAssemblies2() {
        return GetAssemblies(false);
    }
    
    Object* AppDomain::GetData(String* name) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    Type* AppDomain::GetType() {
        return MarshalByRefObject::GetType();
    }
    
    Object* AppDomain::InitializeLifetimeService_8f02e9c96ffbe30f() {
        return nullptr;
    }
    
    Reflection::Assembly* AppDomain::LoadAssembly(String* assemblyRef, Security::Policy::Evidence* securityEvidence, bool refOnly) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    Reflection::Assembly* AppDomain::Load(Reflection::AssemblyName* assemblyRef) {
        return Load2(assemblyRef, nullptr);
    }
    
    Reflection::Assembly* AppDomain::LoadSatellite(Reflection::AssemblyName* assemblyRef, bool throwOnError) {
        if((assemblyRef ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("assemblyRef"));
        }
        Reflection::Assembly *result = LoadAssembly(assemblyRef->get_FullName(), nullptr, false);
        if((Reflection::Assembly::op_Equality(result, nullptr) && throwOnError)) 
        {
            throw cli::gcnew<IO::FileNotFoundException>(nullptr, assemblyRef->get_Name());
        }
        return result;
    }
    
    Reflection::Assembly* AppDomain::Load2(Reflection::AssemblyName* assemblyRef, Security::Policy::Evidence* assemblySecurity) {
        if((assemblyRef ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("assemblyRef"));
        }
        if(((assemblyRef->get_Name() ==  nullptr) || (assemblyRef->get_Name()->get_Length() ==  0))) 
        {
            if((assemblyRef->get_CodeBase() != nullptr)) 
            {
                return Reflection::Assembly::LoadFrom3(assemblyRef->get_CodeBase(), assemblySecurity);
            }
             else 
            {
                throw cli::gcnew<ArgumentException>(Locale::GetText(_T("assemblyRef.Name cannot be empty.")), _T("assemblyRef"));
            }
        }
        Reflection::Assembly *assembly = LoadAssembly(assemblyRef->get_FullName(), assemblySecurity, false);
        if(Reflection::Assembly::op_Inequality(assembly, nullptr)) 
        {
            return assembly;
        }
        if((assemblyRef->get_CodeBase() ==  nullptr)) 
        {
            throw cli::gcnew<IO::FileNotFoundException>(nullptr, assemblyRef->get_Name());
        }
        String *cb = assemblyRef->get_CodeBase();
        if(cb->ToLower2(Globalization::CultureInfo::get_InvariantCulture())->StartsWith(_T("file://"))) 
        {
            cb = cli::gcnew<Mono::Security::Uri>(cb)->get_LocalPath();
        }
        try {
            assembly = Reflection::Assembly::LoadFrom3(cb, assemblySecurity);
        }
        catch(...) {
            throw cli::gcnew<IO::FileNotFoundException>(nullptr, assemblyRef->get_Name());
        }
        Reflection::AssemblyName *aname = assembly->GetName_7088a38b93d0dcc5();
        if(String::op_Inequality(assemblyRef->get_Name(), aname->get_Name())) 
        {
            throw cli::gcnew<IO::FileNotFoundException>(nullptr, assemblyRef->get_Name());
        }
        if(((Version::op_Inequality(assemblyRef->get_Version(), nullptr) && Version::op_Inequality(assemblyRef->get_Version(), cli::gcnew<Version>(0, 0, 0, 0))) && Version::op_Inequality(assemblyRef->get_Version(), aname->get_Version()))) 
        {
            throw cli::gcnew<IO::FileNotFoundException>(nullptr, assemblyRef->get_Name());
        }
        if(((assemblyRef->get_CultureInfo() != nullptr) && assemblyRef->get_CultureInfo()->Equals_ed975d2f4a7d193e(aname))) 
        {
            throw cli::gcnew<IO::FileNotFoundException>(nullptr, assemblyRef->get_Name());
        }
        cli::array<unsigned char> *pt = assemblyRef->GetPublicKeyToken();
        if(((pt != nullptr) && (pt->get_Length() != 0))) 
        {
            cli::array<unsigned char> *loaded_pt = aname->GetPublicKeyToken();
            if(((loaded_pt ==  nullptr) || (pt->get_Length() != loaded_pt->get_Length()))) 
            {
                throw cli::gcnew<IO::FileNotFoundException>(nullptr, assemblyRef->get_Name());
            }
            for(int32_t i = (pt->get_Length() - 1); (i >= 0); i--) {
                if(((int32_t)(loaded_pt->at(i)) != (int32_t)(pt->at(i)))) 
                {
                    throw cli::gcnew<IO::FileNotFoundException>(nullptr, assemblyRef->get_Name());
                }
            }
        }
        return assembly;
    }
    
    Reflection::Assembly* AppDomain::Load3(String* assemblyString) {
        return Load5(assemblyString, nullptr, false);
    }
    
    Reflection::Assembly* AppDomain::Load4(String* assemblyString, Security::Policy::Evidence* assemblySecurity) {
        return Load5(assemblyString, assemblySecurity, false);
    }
    
    Reflection::Assembly* AppDomain::Load5(String* assemblyString, Security::Policy::Evidence* assemblySecurity, bool refonly) {
        if((assemblyString ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("assemblyString"));
        }
        if((assemblyString->get_Length() ==  0)) 
        {
            throw cli::gcnew<ArgumentException>(_T("assemblyString cannot have zero length"));
        }
        Reflection::Assembly *assembly = LoadAssembly(assemblyString, assemblySecurity, refonly);
        if(Reflection::Assembly::op_Equality(assembly, nullptr)) 
        {
            throw cli::gcnew<IO::FileNotFoundException>(nullptr, assemblyString);
        }
        return assembly;
    }
    
    Reflection::Assembly* AppDomain::Load6(cli::array<unsigned char>* rawAssembly) {
        return Load8(rawAssembly, nullptr, nullptr);
    }
    
    Reflection::Assembly* AppDomain::Load7(cli::array<unsigned char>* rawAssembly, cli::array<unsigned char>* rawSymbolStore) {
        return Load8(rawAssembly, rawSymbolStore, nullptr);
    }
    
    Reflection::Assembly* AppDomain::LoadAssemblyRaw(cli::array<unsigned char>* rawAssembly, cli::array<unsigned char>* rawSymbolStore, Security::Policy::Evidence* securityEvidence, bool refonly) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    Reflection::Assembly* AppDomain::Load8(cli::array<unsigned char>* rawAssembly, cli::array<unsigned char>* rawSymbolStore, Security::Policy::Evidence* securityEvidence) {
        return Load9(rawAssembly, rawSymbolStore, securityEvidence, false);
    }
    
    Reflection::Assembly* AppDomain::Load9(cli::array<unsigned char>* rawAssembly, cli::array<unsigned char>* rawSymbolStore, Security::Policy::Evidence* securityEvidence, bool refonly) {
        if((rawAssembly ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("rawAssembly"));
        }
        Reflection::Assembly *assembly = LoadAssemblyRaw(rawAssembly, rawSymbolStore, securityEvidence, refonly);
        assembly->set_FromByteArray(true);
        return assembly;
    }
    
    void AppDomain::SetAppDomainPolicy(Security::Policy::PolicyLevel* domainPolicy) {
        if((domainPolicy ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("domainPolicy"));
        }
        if((this->_granted != nullptr)) 
        {
            throw cli::gcnew<Security::Policy::PolicyException>(Locale::GetText(_T("An AppDomain policy is already specified.")));
        }
        if(IsFinalizingForUnload()) 
        {
            throw cli::gcnew<AppDomainUnloadedException>();
        }
        Security::Policy::PolicyStatement *ps = domainPolicy->Resolve(this->_evidence);
        this->_granted = ps->get_PermissionSet();
    }
    
    void AppDomain::SetCachePath(String* path) {
        this->get_SetupInformationNoCopy()->set_CachePath(path);
    }
    
    void AppDomain::SetPrincipalPolicy(Security::Principal::PrincipalPolicy policy) {
        if(IsFinalizingForUnload()) 
        {
            throw cli::gcnew<AppDomainUnloadedException>();
        }
        this->_principalPolicy = policy;
        _principal = nullptr;
    }
    
    void AppDomain::SetShadowCopyFiles() {
        this->get_SetupInformationNoCopy()->set_ShadowCopyFiles(_T("true"));
    }
    
    void AppDomain::SetShadowCopyPath(String* path) {
        this->get_SetupInformationNoCopy()->set_ShadowCopyDirectories(path);
    }
    
    void AppDomain::SetThreadPrincipal(Security::Principal::IPrincipal* principal) {
        if((principal ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("principal"));
        }
        if((_principal != nullptr)) 
        {
            throw cli::gcnew<Security::Policy::PolicyException>(Locale::GetText(_T("principal already present.")));
        }
        if(IsFinalizingForUnload()) 
        {
            throw cli::gcnew<AppDomainUnloadedException>();
        }
        _principal = principal;
    }
    
    AppDomain* AppDomain::InternalSetDomainByID(int32_t domain_id) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    AppDomain* AppDomain::InternalSetDomain(AppDomain* context) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void AppDomain::InternalPushDomainRef(AppDomain* domain) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void AppDomain::InternalPushDomainRefByID(int32_t domain_id) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void AppDomain::InternalPopDomainRef() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    Runtime::Remoting::Contexts::Context2* AppDomain::InternalSetContext(Runtime::Remoting::Contexts::Context2* context) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    Runtime::Remoting::Contexts::Context2* AppDomain::InternalGetContext() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    Runtime::Remoting::Contexts::Context2* AppDomain::InternalGetDefaultContext() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    String* AppDomain::InternalGetProcessGuid(String* newguid) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    Object* AppDomain::InvokeInDomain(AppDomain* domain, Reflection::MethodInfo* method, Object* obj, cli::array<Object*>* args) {
        AppDomain *current = get_CurrentDomain();
        bool pushed = false;
        {
            cli::finally_guard([&]() {
                InternalSetDomain(current);
                if(pushed) 
                {
                    InternalPopDomainRef();
                }
            });
            Exception *exc;
            InternalPushDomainRef(domain);
            pushed = true;
            InternalSetDomain(domain);
            Object *o = cli::cast<Reflection::MonoMethod*>(method)->InternalInvoke(obj, args, exc);
            if((exc != nullptr)) 
            {
                throw exc;
            }
            return o;
        }
    }
    
    Object* AppDomain::InvokeInDomainByID(int32_t domain_id, Reflection::MethodInfo* method, Object* obj, cli::array<Object*>* args) {
        AppDomain *current = get_CurrentDomain();
        bool pushed = false;
        {
            cli::finally_guard([&]() {
                InternalSetDomain(current);
                if(pushed) 
                {
                    InternalPopDomainRef();
                }
            });
            Exception *exc;
            InternalPushDomainRefByID(domain_id);
            pushed = true;
            InternalSetDomainByID(domain_id);
            Object *o = cli::cast<Reflection::MonoMethod*>(method)->InternalInvoke(obj, args, exc);
            if((exc != nullptr)) 
            {
                throw exc;
            }
            return o;
        }
    }
    
    String* AppDomain::GetProcessGuid() {
        if((_process_guid ==  nullptr)) 
        {
            _process_guid = InternalGetProcessGuid(Guid::NewGuid()->ToString_1636a0751cb9ac11());
        }
        return _process_guid;
    }
    
    AppDomain* AppDomain::CreateDomain(String* friendlyName) {
        return CreateDomain3(friendlyName, nullptr, nullptr);
    }
    
    AppDomain* AppDomain::CreateDomain2(String* friendlyName, Security::Policy::Evidence* securityInfo) {
        return CreateDomain3(friendlyName, securityInfo, nullptr);
    }
    
    AppDomain* AppDomain::createDomain(String* friendlyName, AppDomainSetup* info) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    AppDomain* AppDomain::CreateDomain3(String* friendlyName, Security::Policy::Evidence* securityInfo, AppDomainSetup* info) {
        if((friendlyName ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("friendlyName"));
        }
        AppDomain *def = get_DefaultDomain();
        if((info ==  nullptr)) 
        {
            if((def ==  nullptr)) 
            {
                info = cli::gcnew<AppDomainSetup>();
            }
             else 
            {
                info = def->get_SetupInformation();
            }
        }
         else 
        {
            info = cli::gcnew<AppDomainSetup>(info);
        }
        if((def != nullptr)) 
        {
            if(!(info->Equals_ed975d2f4a7d193e(def->get_SetupInformation()))) 
            {
                if((info->get_ApplicationBase() ==  nullptr)) 
                {
                    info->set_ApplicationBase(def->get_SetupInformation()->get_ApplicationBase());
                }
                if((info->get_ConfigurationFile() ==  nullptr)) 
                {
                    info->set_ConfigurationFile(IO::Path::GetFileName(def->get_SetupInformation()->get_ConfigurationFile()));
                }
            }
        }
         else 
        {
            if((info->get_ConfigurationFile() ==  nullptr)) 
            {
                info->set_ConfigurationFile(_T("[I don\'t have a config file]"));
            }
        }
        if((info->get_AppDomainInitializer() != nullptr)) 
        {
            if(!(info->get_AppDomainInitializer()->get_Method()->get_IsStatic())) 
            {
                throw cli::gcnew<ArgumentException>(_T("Non-static methods cannot be invoked as an appdomain initializer"));
            }
        }
        info->SerializeNonPrimitives();
        AppDomain *ad = cli::cast<AppDomain*>(Runtime::Remoting::RemotingServices::GetDomainProxy(createDomain(friendlyName, info)));
        if((securityInfo ==  nullptr)) 
        {
            if((def ==  nullptr)) 
            {
                ad->_evidence = nullptr;
            }
             else 
            {
                ad->_evidence = def->get_Evidence();
            }
        }
         else 
        {
            ad->_evidence = cli::gcnew<Security::Policy::Evidence>(securityInfo);
        }
        if((info->get_AppDomainInitializer() != nullptr)) 
        {
            Loader *loader = cli::gcnew<Loader>(info->get_AppDomainInitializer()->get_Method()->get_DeclaringType_6121cd6a84393166()->get_Assembly_3aae0acbf2a6d696()->get_Location_3a7779d7eb72fa50());
            ad->DoCallBack(cli::bind(loader, &Loader::Load));
            Initializer *initializer = cli::gcnew<Initializer>(info->get_AppDomainInitializer(), info->get_AppDomainInitializerArguments());
            ad->DoCallBack(cli::bind(initializer, &Initializer::Initialize));
        }
        return ad;
    }
    
    AppDomain* AppDomain::CreateDomain4(String* friendlyName, Security::Policy::Evidence* securityInfo, String* appBasePath, String* appRelativeSearchPath, bool shadowCopyFiles) {
        return CreateDomain3(friendlyName, securityInfo, CreateDomainSetup(appBasePath, appRelativeSearchPath, shadowCopyFiles));
    }
    
    AppDomain* AppDomain::CreateDomain5(String* friendlyName, Security::Policy::Evidence* securityInfo, AppDomainSetup* info, Security::PermissionSet* grantSet, cli::array<Security::Policy::StrongName2*>* fullTrustAssemblies) {
        if((info ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("info"));
        }
        info->set_ApplicationTrust(cli::gcnew<Security::Policy::ApplicationTrust>(grantSet, ([&]() {
            cli::array<Security::Policy::StrongName2*>* tmp_150 = fullTrustAssemblies;
            if(tmp_150 == nullptr) {
                return (new cli::array<Security::Policy::StrongName2*>(0));
            } else
                return tmp_150;
        })()
        ));
        return CreateDomain3(friendlyName, securityInfo, info);
    }
    
    AppDomainSetup* AppDomain::CreateDomainSetup(String* appBasePath, String* appRelativeSearchPath, bool shadowCopyFiles) {
        AppDomainSetup *info = cli::gcnew<AppDomainSetup>();
        info->set_ApplicationBase(appBasePath);
        info->set_PrivateBinPath(appRelativeSearchPath);
        if(shadowCopyFiles) 
        {
            info->set_ShadowCopyFiles(_T("true"));
        }
         else 
        {
            info->set_ShadowCopyFiles(_T("false"));
        }
        return info;
    }
    
    bool AppDomain::InternalIsFinalizingForUnload(int32_t domain_id) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool AppDomain::IsFinalizingForUnload() {
        return InternalIsFinalizingForUnload(getDomainID());
    }
    
    void AppDomain::InternalUnload(int32_t domain_id) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t AppDomain::getDomainID() {
        return Threading::Thread::GetDomainID();
    }
    
    void AppDomain::Unload(AppDomain* domain) {
        if((domain ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("domain"));
        }
        InternalUnload(domain->getDomainID());
    }
    
    void AppDomain::SetData(String* name, Object* data) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void AppDomain::SetData2(String* name, Object* data, Security::IPermission* permission) {
        SetData(name, data);
    }
    
    void AppDomain::SetDynamicBase(String* path) {
        this->get_SetupInformationNoCopy()->set_DynamicBase(path);
    }
    
    int32_t AppDomain::GetCurrentThreadId() {
        return Threading::Thread::get_CurrentThreadId();
    }
    
    String* AppDomain::ToString_1636a0751cb9ac11() {
        return getFriendlyName();
    }
    
    void AppDomain::ValidateAssemblyName(String* name) {
        if(((name ==  nullptr) || (name->get_Length() ==  0))) 
        {
            throw cli::gcnew<ArgumentException>(_T("The Name of AssemblyName cannot be null or a zero-length string."));
        }
        bool isValid = true;
        for(int32_t i = 0; (i < name->get_Length()); i++){
            char16_t c = name->get_Chars(i);
            if(((i ==  0) && Char::IsWhiteSpace(c))) 
            {
                isValid = false;
                break;
            }
            if(((((int32_t)(c) ==  47) || ((int32_t)(c) ==  92)) || ((int32_t)(c) ==  58))) 
            {
                isValid = false;
                break;
            }
        }
        if(!(isValid)) 
        {
            throw cli::gcnew<ArgumentException>(_T("The Name of AssemblyName cannot start with whitespace, or contain \'/\', \'\\\'  or \':\'."));
        }
    }
    
    void AppDomain::DoAssemblyLoad(Reflection::Assembly* assembly) {
        if((this->AssemblyLoad ==  nullptr)) 
        {
            return;
        }
        this->AssemblyLoad->Invoke(this, cli::gcnew<AssemblyLoadEventArgs>(assembly));
    }
    
    Reflection::Assembly* AppDomain::DoAssemblyResolve(String* name, bool refonly) {
        ResolveEventHandler *del;
        if(refonly) 
        {
            del = this->ReflectionOnlyAssemblyResolve;
        }
         else 
        {
            del = this->AssemblyResolve;
        }
        if((del ==  nullptr)) 
        {
            return nullptr;
        }
        Collections::Hashtable *ht;
        if(refonly) 
        {
            ht = assembly_resolve_in_progress_refonly;
            if((ht ==  nullptr)) 
            {
                ht = cli::gcnew<Collections::Hashtable>();
                assembly_resolve_in_progress_refonly = ht;
            }
        }
         else 
        {
            ht = assembly_resolve_in_progress;
            if((ht ==  nullptr)) 
            {
                ht = cli::gcnew<Collections::Hashtable>();
                assembly_resolve_in_progress = ht;
            }
        }
        String *s = cli::cast<String*>(ht->get_Item_d75c6e706b965758(name));
        if((s != nullptr)) 
        {
            return nullptr;
        }
        ht->set_Item_84c7e24d9caa09(name, name);
        {
            cli::finally_guard([&]() {
                ht->Remove_fd653674dd8a5ac4(name);
            });
            cli::array<Delegate*> *invocation_list = del->GetInvocationList_8fef0390be027d95();
            for(auto tmp_151 : invocation_list) {
                auto eh = cli::cast<Delegate*>(tmp_151);
                {
                    ResolveEventHandler *handler = cli::cast<ResolveEventHandler*>(eh);
                    Reflection::Assembly *assembly = handler->Invoke(this, cli::gcnew<ResolveEventArgs>(name));
                    if(Reflection::Assembly::op_Inequality(assembly, nullptr)) 
                    {
                        return assembly;
                    }
                }
            }
            return nullptr;
        }
    }
    
    Reflection::Assembly* AppDomain::DoTypeResolve(Object* name_or_tb) {
        if((this->TypeResolve ==  nullptr)) 
        {
            return nullptr;
        }
        String *name;
        if(cli::is<Reflection::Emit::TypeBuilder>(name_or_tb)) 
        {
            name = cli::cast<Reflection::Emit::TypeBuilder*>(name_or_tb)->get_FullName_7e8fa72ba225e1a4();
        }
         else 
        {
            name = cli::cast<String*>(name_or_tb);
        }
        Collections::Hashtable *ht = type_resolve_in_progress;
        if((ht ==  nullptr)) 
        {
            ht = cli::gcnew<Collections::Hashtable>();
            type_resolve_in_progress = ht;
        }
        if(ht->Contains_be7d0f2741618cb4(name)) 
        {
            return nullptr;
        }
         else 
        {
            ht->set_Item_84c7e24d9caa09(name, name);
        }
        {
            cli::finally_guard([&]() {
                ht->Remove_fd653674dd8a5ac4(name);
            });
            for(auto tmp_152 : this->TypeResolve->GetInvocationList_8fef0390be027d95()) {
                auto d = cli::cast<Delegate*>(tmp_152);
                {
                    ResolveEventHandler *eh = cli::cast<ResolveEventHandler*>(d);
                    Reflection::Assembly *assembly = eh->Invoke(this, cli::gcnew<ResolveEventArgs>(name));
                    if(Reflection::Assembly::op_Inequality(assembly, nullptr)) 
                    {
                        return assembly;
                    }
                }
            }
            return nullptr;
        }
    }
    
    Reflection::Assembly* AppDomain::DoResourceResolve(String* name, Reflection::Assembly* requesting) {
        if((this->ResourceResolve ==  nullptr)) 
        {
            return nullptr;
        }
        cli::array<Delegate*> *invocation_list = this->ResourceResolve->GetInvocationList_8fef0390be027d95();
        for(auto tmp_153 : invocation_list) {
            auto eh = cli::cast<Delegate*>(tmp_153);
            {
                ResolveEventHandler *handler = cli::cast<ResolveEventHandler*>(eh);
                Reflection::Assembly *assembly = handler->Invoke(this, cli::gcnew<ResolveEventArgs>(name, requesting));
                if(Reflection::Assembly::op_Inequality(assembly, nullptr)) 
                {
                    return assembly;
                }
            }
        }
        return nullptr;
    }
    
    void AppDomain::DoDomainUnload() {
        if((this->DomainUnload != nullptr)) 
        {
            this->DomainUnload->Invoke(this, nullptr);
        }
    }
    
    cli::array<unsigned char>* AppDomain::GetMarshalledDomainObjRef() {
        Runtime::Remoting::ObjRef *oref = Runtime::Remoting::RemotingServices::Marshal4(AppDomain::get_CurrentDomain(), nullptr, cli::typeof<Type>::info);
        return Runtime::Remoting::Channels::CADSerializer::SerializeObject(oref)->GetBuffer_21f804ce00c165c2();
    }
    
    void AppDomain::ProcessMessageInDomain(cli::array<unsigned char>* arrRequest, Runtime::Remoting::Messaging::CADMethodCallMessage* cadMsg, cli::array<unsigned char>* arrResponse, Runtime::Remoting::Messaging::CADMethodReturnMessage* cadMrm) {
        Runtime::Remoting::Messaging::IMessage *reqDomMsg;
        if((arrRequest != nullptr)) 
        {
            reqDomMsg = Runtime::Remoting::Channels::CADSerializer::DeserializeMessage(cli::gcnew<IO::MemoryStream>(arrRequest), nullptr);
        }
         else 
        {
            reqDomMsg = cli::gcnew<Runtime::Remoting::Messaging::MethodCall>(cadMsg);
        }
        Runtime::Remoting::Messaging::IMessage *retDomMsg = Runtime::Remoting::Channels::ChannelServices::SyncDispatchMessage(reqDomMsg);
        cadMrm = Runtime::Remoting::Messaging::CADMethodReturnMessage::Create(retDomMsg);
        if((cadMrm ==  nullptr)) 
        {
            arrResponse = Runtime::Remoting::Channels::CADSerializer::SerializeMessage(retDomMsg)->GetBuffer_21f804ce00c165c2();
        }
         else 
        {
            arrResponse = nullptr;
        }
    }
    
    String* AppDomain::ApplyPolicy(String* assemblyName) {
        if((assemblyName ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("assemblyName"));
        }
        if((assemblyName->get_Length() ==  0)) 
        {
            throw cli::gcnew<ArgumentException>(_T("assemblyName"));
        }
        return assemblyName;
    }
    
    AppDomain* AppDomain::CreateDomain6(String* friendlyName, Security::Policy::Evidence* securityInfo, String* appBasePath, String* appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer* adInit, cli::array<String*>* adInitArgs) {
        AppDomainSetup *info = CreateDomainSetup(appBasePath, appRelativeSearchPath, shadowCopyFiles);
        info->set_AppDomainInitializerArguments(adInitArgs);
        info->set_AppDomainInitializer(adInit);
        return CreateDomain3(friendlyName, securityInfo, info);
    }
    
    int32_t AppDomain::ExecuteAssemblyByName(String* assemblyName) {
        return ExecuteAssemblyByName3(assemblyName, nullptr, nullptr);
    }
    
    int32_t AppDomain::ExecuteAssemblyByName2(String* assemblyName, Security::Policy::Evidence* assemblySecurity) {
        return ExecuteAssemblyByName3(assemblyName, assemblySecurity, nullptr);
    }
    
    int32_t AppDomain::ExecuteAssemblyByName3(String* assemblyName, Security::Policy::Evidence* assemblySecurity, cli::array<String*>* args) {
        Reflection::Assembly *a = Reflection::Assembly::Load2(assemblyName, assemblySecurity);
        return ExecuteAssemblyInternal(a, args);
    }
    
    int32_t AppDomain::ExecuteAssemblyByName4(Reflection::AssemblyName* assemblyName, Security::Policy::Evidence* assemblySecurity, cli::array<String*>* args) {
        Reflection::Assembly *a = Reflection::Assembly::Load4(assemblyName, assemblySecurity);
        return ExecuteAssemblyInternal(a, args);
    }
    
    int32_t AppDomain::ExecuteAssemblyByName5(String* assemblyName, cli::array<String*>* args) {
        Reflection::Assembly *a = Reflection::Assembly::Load2(assemblyName, nullptr);
        return ExecuteAssemblyInternal(a, args);
    }
    
    int32_t AppDomain::ExecuteAssemblyByName6(Reflection::AssemblyName* assemblyName, cli::array<String*>* args) {
        Reflection::Assembly *a = Reflection::Assembly::Load4(assemblyName, nullptr);
        return ExecuteAssemblyInternal(a, args);
    }
    
    bool AppDomain::IsDefaultAppDomain() {
        return Object::ReferenceEquals(this, AppDomain::get_DefaultDomain());
    }
    
    cli::array<Reflection::Assembly*>* AppDomain::ReflectionOnlyGetAssemblies() {
        return GetAssemblies(true);
    }
    
    void AppDomain::GetIDsOfNames(Guid riid, void* rgszNames, uint32_t cNames, uint32_t lcid, void* rgDispId) {
        throw cli::gcnew<NotImplementedException>();
    }
    
    void AppDomain::GetTypeInfo(uint32_t iTInfo, uint32_t lcid, void* ppTInfo) {
        throw cli::gcnew<NotImplementedException>();
    }
    
    void AppDomain::GetTypeInfoCount(uint32_t pcTInfo) {
        throw cli::gcnew<NotImplementedException>();
    }
    
    void AppDomain::Invoke(uint32_t dispIdMember, Guid riid, uint32_t lcid, int16_t wFlags, void* pDispParams, void* pVarResult, void* pExcepInfo, void* puArgErr) {
        throw cli::gcnew<NotImplementedException>();
    }
    
    Nullable2<bool> AppDomain::IsCompatibilitySwitchSet(String* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<ArgumentNullException>(_T("value"));
        }
        return cli::wrap_nullable(((this->compatibility_switch != nullptr) && this->compatibility_switch->Contains(value)));
    }
    
    void AppDomain::SetCompatibilitySwitch(String* value) {
        if((this->compatibility_switch ==  nullptr)) 
        {
            this->compatibility_switch = cli::gcnew<Collections::Generic::List<String*>>();
        }
        this->compatibility_switch->Add(value);
    }
    
    AppDomainSetup* AppDomain::get_SetupInformationNoCopy() {
        return getSetup();
    }
    
    AppDomainSetup* AppDomain::get_SetupInformation() {
        AppDomainSetup *setup = getSetup();
        return cli::gcnew<AppDomainSetup>(setup);
    }
    
    Security::Policy::ApplicationTrust* AppDomain::get_ApplicationTrust() {
        throw cli::gcnew<NotImplementedException>();
    }
    
    String* AppDomain::get_BaseDirectory() {
        String *path = this->get_SetupInformationNoCopy()->get_ApplicationBase();
        if(((Security::SecurityManager::get_SecurityEnabled() && (path != nullptr)) && (path->get_Length() > 0))) 
        {
            cli::gcnew<Security::Permissions::FileIOPermission>(Security::Permissions::FileIOPermissionAccess::PathDiscovery, path)->Demand();
        }
        return path;
    }
    
    String* AppDomain::get_RelativeSearchPath() {
        String *path = this->get_SetupInformationNoCopy()->get_PrivateBinPath();
        if(((Security::SecurityManager::get_SecurityEnabled() && (path != nullptr)) && (path->get_Length() > 0))) 
        {
            cli::gcnew<Security::Permissions::FileIOPermission>(Security::Permissions::FileIOPermissionAccess::PathDiscovery, path)->Demand();
        }
        return path;
    }
    
    String* AppDomain::get_DynamicDirectory() {
        AppDomainSetup *setup = this->get_SetupInformationNoCopy();
        if((setup->get_DynamicBase() ==  nullptr)) 
        {
            return nullptr;
        }
        String *path = IO::Path::Combine(setup->get_DynamicBase(), setup->get_ApplicationName());
        if(((Security::SecurityManager::get_SecurityEnabled() && (path != nullptr)) && (path->get_Length() > 0))) 
        {
            cli::gcnew<Security::Permissions::FileIOPermission>(Security::Permissions::FileIOPermissionAccess::PathDiscovery, path)->Demand();
        }
        return path;
    }
    
    bool AppDomain::get_ShadowCopyFiles() {
        return String::op_Equality(this->get_SetupInformationNoCopy()->get_ShadowCopyFiles(), _T("true"));
    }
    
    String* AppDomain::get_FriendlyName() {
        return getFriendlyName();
    }
    
    Security::Policy::Evidence* AppDomain::get_Evidence() {
        if((this->_evidence ==  nullptr)) 
        {
            {
                cli::lock_guard{this};
                Reflection::Assembly *a = Reflection::Assembly::GetEntryAssembly();
                if(Reflection::Assembly::op_Equality(a, nullptr)) 
                {
                    if((this ==  AppDomain::get_DefaultDomain())) 
                    {
                        return cli::gcnew<Security::Policy::Evidence>();
                    }
                     else 
                    {
                        this->_evidence = AppDomain::get_DefaultDomain()->get_Evidence();
                    }
                }
                 else 
                {
                    this->_evidence = Security::Policy::Evidence::GetDefaultHostEvidence(a);
                }
            }
        }
        return cli::gcnew<Security::Policy::Evidence>(this->_evidence);
    }
    
    Security::Principal::IPrincipal* AppDomain::get_DefaultPrincipal() {
        if((_principal ==  nullptr)) 
        {
            switch(this->_principalPolicy) {
                case Security::Principal::PrincipalPolicy::UnauthenticatedPrincipal: case_554: {
                    _principal = cli::gcnew<Security::Principal::GenericPrincipal>(cli::gcnew<Security::Principal::GenericIdentity>(String::Empty, String::Empty), nullptr);
                    break;
                }
                case Security::Principal::PrincipalPolicy::WindowsPrincipal2: case_555: {
                    _principal = cli::gcnew<Security::Principal::WindowsPrincipal>(Security::Principal::WindowsIdentity::GetCurrent());
                    break;
                }
            }
        }
        return _principal;
    }
    
    Security::PermissionSet* AppDomain::get_GrantedPermissionSet() {
        return this->_granted;
    }
    
    Security::PermissionSet* AppDomain::get_PermissionSet() {
        return ([&]() {
            Security::PermissionSet* tmp_154 = this->_granted;
            if(tmp_154 == nullptr) {
                return this->_granted = cli::gcnew<Security::PermissionSet>(Security::Permissions::PermissionState::Unrestricted);
            } else
                return tmp_154;
        })();
    }
    
    AppDomain* AppDomain::get_CurrentDomain() {
        return getCurDomain();
    }
    
    AppDomain* AppDomain::get_DefaultDomain() {
        if((default_domain ==  nullptr)) 
        {
            AppDomain *rd = getRootDomain();
            if((rd ==  AppDomain::get_CurrentDomain())) 
            {
                default_domain = rd;
            }
             else 
            {
                default_domain = cli::cast<AppDomain*>(Runtime::Remoting::RemotingServices::GetDomainProxy(rd));
            }
        }
        return default_domain;
    }
    
    bool AppDomain::get_IsHomogenous() {
        return true;
    }
    
    bool AppDomain::get_IsFullyTrusted() {
        return true;
    }
    
    AppDomainManager* AppDomain::get_DomainManager() {
        return this->_domain_manager;
    }
    
    ActivationContext* AppDomain::get_ActivationContext() {
        return this->_activation;
    }
    
    ApplicationIdentity* AppDomain::get_ApplicationIdentity() {
        return this->_applicationIdentity;
    }
    
    int32_t AppDomain::get_Id() {
        return getDomainID();
    }
    
    bool AppDomain::get_MonitoringIsEnabled() {
        return false;
    }
    
    bool AppDomain::set_MonitoringIsEnabled(bool value) {
        throw cli::gcnew<NotImplementedException>();
        return get_MonitoringIsEnabled();
    }
    
    int64_t AppDomain::get_MonitoringSurvivedMemorySize() {
        throw cli::gcnew<NotImplementedException>();
    }
    
    int64_t AppDomain::get_MonitoringSurvivedProcessMemorySize() {
        throw cli::gcnew<NotImplementedException>();
    }
    
    int64_t AppDomain::get_MonitoringTotalAllocatedMemorySize() {
        throw cli::gcnew<NotImplementedException>();
    }
    
    TimeSpan AppDomain::get_MonitoringTotalProcessorTime() {
        throw cli::gcnew<NotImplementedException>();
    }
    
    void AppDomain::add_AssemblyLoad(AssemblyLoadEventHandler* value) {
      // TODO: "Implement automatic events!"
    }
    
    void AppDomain::remove_AssemblyLoad(AssemblyLoadEventHandler* value) {
      // TODO: "Implement automatic events!"
    }
    
    void AppDomain::add_AssemblyResolve(ResolveEventHandler* value) {
      // TODO: "Implement automatic events!"
    }
    
    void AppDomain::remove_AssemblyResolve(ResolveEventHandler* value) {
      // TODO: "Implement automatic events!"
    }
    
    void AppDomain::add_DomainUnload(EventHandler* value) {
      // TODO: "Implement automatic events!"
    }
    
    void AppDomain::remove_DomainUnload(EventHandler* value) {
      // TODO: "Implement automatic events!"
    }
    
    void AppDomain::add_ProcessExit(EventHandler* value) {
      // TODO: "Implement automatic events!"
    }
    
    void AppDomain::remove_ProcessExit(EventHandler* value) {
      // TODO: "Implement automatic events!"
    }
    
    void AppDomain::add_ResourceResolve(ResolveEventHandler* value) {
      // TODO: "Implement automatic events!"
    }
    
    void AppDomain::remove_ResourceResolve(ResolveEventHandler* value) {
      // TODO: "Implement automatic events!"
    }
    
    void AppDomain::add_TypeResolve(ResolveEventHandler* value) {
      // TODO: "Implement automatic events!"
    }
    
    void AppDomain::remove_TypeResolve(ResolveEventHandler* value) {
      // TODO: "Implement automatic events!"
    }
    
    void AppDomain::add_UnhandledException(UnhandledExceptionEventHandler* value) {
      // TODO: "Implement automatic events!"
    }
    
    void AppDomain::remove_UnhandledException(UnhandledExceptionEventHandler* value) {
      // TODO: "Implement automatic events!"
    }
    
    void AppDomain::add_ReflectionOnlyAssemblyResolve(ResolveEventHandler* value) {
      // TODO: "Implement automatic events!"
    }
    
    void AppDomain::remove_ReflectionOnlyAssemblyResolve(ResolveEventHandler* value) {
      // TODO: "Implement automatic events!"
    }
    
}
