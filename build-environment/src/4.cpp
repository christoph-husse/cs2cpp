#include "stdafx_mscorlib.hpp"

namespace System { namespace Security { namespace Cryptography {
    
    
    void DeriveBytes2::constructor() {
    }
    
    void DeriveBytes2::Dispose() {
        Dispose_803fca5f32415300(true);
    }
    
    void DeriveBytes2::Dispose_803fca5f32415300(bool disposing) {
        if(!(this->m_disposed)) 
        {
            if(disposing) 
            {
            }
            this->m_disposed = true;
        }
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    cli::array<unsigned char>*  DES::weakKeys;
    cli::array<unsigned char>*  DES::semiWeakKeys;
    
    DES::DES()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void DES::constructor() {
        this->KeySizeValue = 64;
        this->BlockSizeValue = 64;
        this->FeedbackSizeValue = 8;
        this->LegalKeySizesValue = (new cli::array<KeySizes*>(1));
        this->LegalKeySizesValue->at(0) = cli::gcnew<KeySizes>(64, 64, 0);
        this->LegalBlockSizesValue = (new cli::array<KeySizes*>(1));
        this->LegalBlockSizesValue->at(0) = cli::gcnew<KeySizes>(64, 64, 0);
    }
    
    void DES::static_constructor() {
    }
    
    DES* DES::Create3() {
        return Create4(_T("System.Security.Cryptography.DES"));
    }
    
    DES* DES::Create4(System::String* algName) {
        return cli::cast<DES*>(CryptoConfig::CreateFromName(algName));
    }
    
    bool DES::IsWeakKey(cli::array<unsigned char>* rgbKey) {
        if((rgbKey ==  nullptr)) 
        {
            throw cli::gcnew<CryptographicException>(Locale::GetText(_T("Null Key")));
        }
        if((rgbKey->get_Length() != 8)) 
        {
            throw cli::gcnew<CryptographicException>(Locale::GetText(_T("Wrong Key Length")));
        }
        for(int32_t i = 0; (i < rgbKey->get_Length()); i++){
            switch(((int32_t)(rgbKey->at(i)) | 17)) {
                case 17: case 31: case 241: case 255: case_1656: {
                    break;
                }
                default: case_1657: {
                    return false;
                }
            }
        }
        for(int32_t i = 0; (i < (weakKeys->get_Length() >> 3)); i++){
            int32_t j = 0;
            for(; (j < rgbKey->get_Length()); j++){
                if((((int32_t)(rgbKey->at(j)) ^ (int32_t)(weakKeys->at(i, j))) > 1)) 
                {
                    break;
                }
            }
            if((j ==  8)) 
            {
                return true;
            }
        }
        return false;
    }
    
    bool DES::IsSemiWeakKey(cli::array<unsigned char>* rgbKey) {
        if((rgbKey ==  nullptr)) 
        {
            throw cli::gcnew<CryptographicException>(Locale::GetText(_T("Null Key")));
        }
        if((rgbKey->get_Length() != 8)) 
        {
            throw cli::gcnew<CryptographicException>(Locale::GetText(_T("Wrong Key Length")));
        }
        for(int32_t i = 0; (i < rgbKey->get_Length()); i++){
            switch(((int32_t)(rgbKey->at(i)) | 17)) {
                case 17: case 31: case 241: case 255: case_1658: {
                    break;
                }
                default: case_1659: {
                    return false;
                }
            }
        }
        for(int32_t i = 0; (i < (semiWeakKeys->get_Length() >> 3)); i++){
            int32_t j = 0;
            for(; (j < rgbKey->get_Length()); j++){
                if((((int32_t)(rgbKey->at(j)) ^ (int32_t)(semiWeakKeys->at(i, j))) > 1)) 
                {
                    break;
                }
            }
            if((j ==  8)) 
            {
                return true;
            }
        }
        return false;
    }
    
    cli::array<unsigned char>* DES::get_Key_79a2c753d4f0f561() {
        if((this->KeyValue ==  nullptr)) 
        {
            GenerateKey_a6a62018358dfc76();
        }
        return cli::cast<cli::array<unsigned char>*>(cli::import(this->KeyValue)->Clone());
    }
    
    cli::array<unsigned char>* DES::set_Key_9b56e7a05d7e4c8f(cli::array<unsigned char>* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("Key"));
        }
        if((value->get_Length() != 8)) 
        {
            throw cli::gcnew<System::ArgumentException>(Locale::GetText(_T("Wrong Key Length")));
        }
        if(IsWeakKey(value)) 
        {
            throw cli::gcnew<CryptographicException>(Locale::GetText(_T("Weak Key")));
        }
        if(IsSemiWeakKey(value)) 
        {
            throw cli::gcnew<CryptographicException>(Locale::GetText(_T("Semi Weak Key")));
        }
        this->KeyValue = cli::cast<cli::array<unsigned char>*>(cli::import(value)->Clone());
        return get_Key_79a2c753d4f0f561();
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    int32_t  DESTransform::KEY_BIT_SIZE;
    int32_t  DESTransform::KEY_BYTE_SIZE;
    int32_t  DESTransform::BLOCK_BIT_SIZE;
    int32_t  DESTransform::BLOCK_BYTE_SIZE;
    cli::array<uint32_t>*  DESTransform::spBoxes;
    cli::array<unsigned char>*  DESTransform::PC1;
    cli::array<unsigned char>*  DESTransform::leftRotTotal;
    cli::array<unsigned char>*  DESTransform::PC2;
    cli::array<uint32_t>*  DESTransform::ipTab;
    cli::array<uint32_t>*  DESTransform::fpTab;
    
    DESTransform::DESTransform()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void DESTransform::constructor(SymmetricAlgorithm* symmAlgo, bool encryption, cli::array<unsigned char>* key, cli::array<unsigned char>* iv) {
        cli::array<unsigned char> *clonedKey = nullptr;
        if((key ==  nullptr)) 
        {
            key = GetStrongKey();
            clonedKey = key;
        }
        if((DES::IsWeakKey(key) || DES::IsSemiWeakKey(key))) 
        {
            System::String *msg = Locale::GetText(_T("This is a known weak, or semi-weak, key."));
            throw cli::gcnew<CryptographicException>(msg);
        }
        if((clonedKey ==  nullptr)) 
        {
            clonedKey = cli::cast<cli::array<unsigned char>*>(cli::import(key)->Clone());
        }
        this->keySchedule = (new cli::array<unsigned char>((KEY_BYTE_SIZE * 16)));
        this->byteBuff = (new cli::array<unsigned char>(BLOCK_BYTE_SIZE));
        this->dwordBuff = (new cli::array<uint32_t>((BLOCK_BYTE_SIZE / 4)));
        SetKey(clonedKey);
    }
    
    void DESTransform::static_constructor() {
    }
    
    uint32_t DESTransform::CipherFunct(uint32_t r, int32_t n) {
        uint32_t res = 0U;
        cli::array<unsigned char> *subkey = this->keySchedule;
        int32_t i = (n << 3);
        uint32_t rt = ((r >> 1) | (r << 31));
        (res = res | spBoxes->at((int32_t)(((rt >> 26) ^ (uint32_t)(subkey->at(i++))) & 63U)));
        (res = res | spBoxes->at((int32_t)(64U + (((rt >> 22) ^ (uint32_t)(subkey->at(i++))) & 63U))));
        (res = res | spBoxes->at((int32_t)(128U + (((rt >> 18) ^ (uint32_t)(subkey->at(i++))) & 63U))));
        (res = res | spBoxes->at((int32_t)(192U + (((rt >> 14) ^ (uint32_t)(subkey->at(i++))) & 63U))));
        (res = res | spBoxes->at((int32_t)(256U + (((rt >> 10) ^ (uint32_t)(subkey->at(i++))) & 63U))));
        (res = res | spBoxes->at((int32_t)(320U + (((rt >> 6) ^ (uint32_t)(subkey->at(i++))) & 63U))));
        (res = res | spBoxes->at((int32_t)(384U + (((rt >> 2) ^ (uint32_t)(subkey->at(i++))) & 63U))));
        rt = ((r << 1) | (r >> 31));
        (res = res | spBoxes->at((int32_t)(448U + ((rt ^ (uint32_t)(subkey->at(i))) & 63U))));
        return res;
    }
    
    void DESTransform::Permutation(cli::array<unsigned char>* input, cli::array<unsigned char>* output, cli::array<uint32_t>* permTab, bool preSwap) {
        if((preSwap && System::BitConverter::IsLittleEndian)) 
        {
            BSwap(input);
        }
        int32_t offs1 = (((int32_t)(input->at(0)) >> 4) << 1);
        int32_t offs2 = (32 + (((int32_t)(input->at(0)) & 15) << 1));
        uint32_t d1 = (permTab->at(offs1++) | permTab->at(offs2++));
        uint32_t d2 = (permTab->at(offs1) | permTab->at(offs2));
        int32_t max = (BLOCK_BYTE_SIZE << 1);
        for(int32_t i = 2, indx = 1; (i < max); (i = i + 2), indx++){
            int32_t ii = (int32_t)(input->at(indx));
            offs1 = ((i << 5) + ((ii >> 4) << 1));
            offs2 = (((i + 1) << 5) + ((ii & 15) << 1));
            (d1 = d1 | (permTab->at(offs1++) | permTab->at(offs2++)));
            (d2 = d2 | (permTab->at(offs1) | permTab->at(offs2)));
        }
        if((preSwap || !(System::BitConverter::IsLittleEndian))) 
        {
            output->at(0) = (unsigned char)d1;
            output->at(1) = (unsigned char)(d1 >> 8);
            output->at(2) = (unsigned char)(d1 >> 16);
            output->at(3) = (unsigned char)(d1 >> 24);
            output->at(4) = (unsigned char)d2;
            output->at(5) = (unsigned char)(d2 >> 8);
            output->at(6) = (unsigned char)(d2 >> 16);
            output->at(7) = (unsigned char)(d2 >> 24);
        }
         else 
        {
            output->at(0) = (unsigned char)(d1 >> 24);
            output->at(1) = (unsigned char)(d1 >> 16);
            output->at(2) = (unsigned char)(d1 >> 8);
            output->at(3) = (unsigned char)d1;
            output->at(4) = (unsigned char)(d2 >> 24);
            output->at(5) = (unsigned char)(d2 >> 16);
            output->at(6) = (unsigned char)(d2 >> 8);
            output->at(7) = (unsigned char)d2;
        }
    }
    
    void DESTransform::BSwap(cli::array<unsigned char>* byteBuff) {
        unsigned char t = byteBuff->at(0);
        byteBuff->at(0) = byteBuff->at(3);
        byteBuff->at(3) = t;
        t = byteBuff->at(1);
        byteBuff->at(1) = byteBuff->at(2);
        byteBuff->at(2) = t;
        t = byteBuff->at(4);
        byteBuff->at(4) = byteBuff->at(7);
        byteBuff->at(7) = t;
        t = byteBuff->at(5);
        byteBuff->at(5) = byteBuff->at(6);
        byteBuff->at(6) = t;
    }
    
    void DESTransform::SetKey(cli::array<unsigned char>* key) {
        System::Array::Clear2(this->keySchedule, 0, this->keySchedule->get_Length());
        int32_t keyBitSize = PC1->get_Length();
        cli::array<unsigned char> *keyPC1 = (new cli::array<unsigned char>(keyBitSize));
        cli::array<unsigned char> *keyRot = (new cli::array<unsigned char>(keyBitSize));
        int32_t indx = 0;
        for(auto tmp_518 : PC1) {
            auto bitPos = cli::cast<unsigned char>(tmp_518);
            {
                keyPC1->at(indx++) = (unsigned char)(((int32_t)(key->at(((int32_t)(bitPos) >> 3))) >> ((7 ^ ((int32_t)(bitPos) & 7)) & 31)) & 1);
            }
        }
        int32_t j;
        for(int32_t i = 0; (i < (KEY_BYTE_SIZE * 2)); i++){
            int32_t b = (keyBitSize >> 1);
            for(j = 0; (j < b); j++){
                int32_t s = (j + (int32_t)(leftRotTotal->at(i)));
                keyRot->at(j) = keyPC1->at((s < b) ? s : (s - b));
            }
            for(j = b; (j < keyBitSize); j++){
                int32_t s = (j + (int32_t)(leftRotTotal->at(i)));
                keyRot->at(j) = keyPC1->at((s < keyBitSize) ? s : (s - b));
            }
            int32_t keyOffs = (i * KEY_BYTE_SIZE);
            j = 0;
            for(auto tmp_519 : PC2) {
                auto bitPos = cli::cast<unsigned char>(tmp_519);
                {
                    if(((int32_t)(keyRot->at((int32_t)(bitPos))) != 0)) 
                    {
                        (this->keySchedule->at((keyOffs + (j / 6))) = (unsigned char)((int32_t)(this->keySchedule->at((keyOffs + (j / 6)))) | (int32_t)((unsigned char)(128 >> (((j % 6) + 2) & 31)))));
                    }
                    j++;
                }
            }
        }
    }
    
    void DESTransform::ProcessBlock(cli::array<unsigned char>* input, cli::array<unsigned char>* output) {
        System::Buffer::BlockCopy(input, 0, this->dwordBuff, 0, BLOCK_BYTE_SIZE);
        if(this->encrypt) 
        {
            uint32_t d0 = this->dwordBuff->at(0);
            uint32_t d1 = this->dwordBuff->at(1);
            (d0 = d0 ^ CipherFunct(d1, 0));
            (d1 = d1 ^ CipherFunct(d0, 1));
            (d0 = d0 ^ CipherFunct(d1, 2));
            (d1 = d1 ^ CipherFunct(d0, 3));
            (d0 = d0 ^ CipherFunct(d1, 4));
            (d1 = d1 ^ CipherFunct(d0, 5));
            (d0 = d0 ^ CipherFunct(d1, 6));
            (d1 = d1 ^ CipherFunct(d0, 7));
            (d0 = d0 ^ CipherFunct(d1, 8));
            (d1 = d1 ^ CipherFunct(d0, 9));
            (d0 = d0 ^ CipherFunct(d1, 10));
            (d1 = d1 ^ CipherFunct(d0, 11));
            (d0 = d0 ^ CipherFunct(d1, 12));
            (d1 = d1 ^ CipherFunct(d0, 13));
            (d0 = d0 ^ CipherFunct(d1, 14));
            (d1 = d1 ^ CipherFunct(d0, 15));
            this->dwordBuff->at(0) = d1;
            this->dwordBuff->at(1) = d0;
        }
         else 
        {
            uint32_t d1 = this->dwordBuff->at(0);
            uint32_t d0 = this->dwordBuff->at(1);
            (d1 = d1 ^ CipherFunct(d0, 15));
            (d0 = d0 ^ CipherFunct(d1, 14));
            (d1 = d1 ^ CipherFunct(d0, 13));
            (d0 = d0 ^ CipherFunct(d1, 12));
            (d1 = d1 ^ CipherFunct(d0, 11));
            (d0 = d0 ^ CipherFunct(d1, 10));
            (d1 = d1 ^ CipherFunct(d0, 9));
            (d0 = d0 ^ CipherFunct(d1, 8));
            (d1 = d1 ^ CipherFunct(d0, 7));
            (d0 = d0 ^ CipherFunct(d1, 6));
            (d1 = d1 ^ CipherFunct(d0, 5));
            (d0 = d0 ^ CipherFunct(d1, 4));
            (d1 = d1 ^ CipherFunct(d0, 3));
            (d0 = d0 ^ CipherFunct(d1, 2));
            (d1 = d1 ^ CipherFunct(d0, 1));
            (d0 = d0 ^ CipherFunct(d1, 0));
            this->dwordBuff->at(0) = d0;
            this->dwordBuff->at(1) = d1;
        }
        System::Buffer::BlockCopy(this->dwordBuff, 0, output, 0, BLOCK_BYTE_SIZE);
    }
    
    void DESTransform::ECB_94d714c69347f447(cli::array<unsigned char>* input, cli::array<unsigned char>* output) {
        Permutation(input, output, ipTab, false);
        ProcessBlock(output, this->byteBuff);
        Permutation(this->byteBuff, output, fpTab, true);
    }
    
    cli::array<unsigned char>* DESTransform::GetStrongKey() {
        cli::array<unsigned char> *key = Mono::Security::Cryptography::KeyBuilder::Key2(KEY_BYTE_SIZE);
        while((DES::IsWeakKey(key) || DES::IsSemiWeakKey(key))) key = Mono::Security::Cryptography::KeyBuilder::Key2(KEY_BYTE_SIZE);
        return key;
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    
    void DESCryptoServiceProvider::constructor() {
    }
    
    ICryptoTransform* DESCryptoServiceProvider::CreateDecryptor_80e9c787d56cc5d1(cli::array<unsigned char>* rgbKey, cli::array<unsigned char>* rgbIV) {
        return cli::gcnew<DESTransform>(this, false, rgbKey, rgbIV);
    }
    
    ICryptoTransform* DESCryptoServiceProvider::CreateEncryptor_5ed1e69e3ba0a86a(cli::array<unsigned char>* rgbKey, cli::array<unsigned char>* rgbIV) {
        return cli::gcnew<DESTransform>(this, true, rgbKey, rgbIV);
    }
    
    void DESCryptoServiceProvider::GenerateIV_df3473e2513c2b00() {
        this->IVValue = Mono::Security::Cryptography::KeyBuilder::IV(DESTransform::BLOCK_BYTE_SIZE);
    }
    
    void DESCryptoServiceProvider::GenerateKey_a6a62018358dfc76() {
        this->KeyValue = DESTransform::GetStrongKey();
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    
    void DSA::constructor() {
    }
    
    DSA* DSA::Create3() {
        return Create4(_T("System.Security.Cryptography.DSA"));
    }
    
    DSA* DSA::Create4(System::String* algName) {
        return cli::cast<DSA*>(CryptoConfig::CreateFromName(algName));
    }
    
    void DSA::ZeroizePrivateKey(DSAParameters parameters) {
        if((parameters->X != nullptr)) 
        {
            System::Array::Clear2(parameters->X, 0, parameters->X->get_Length());
        }
    }
    
    void DSA::FromXmlString_ec36cca6166e6990(System::String* xmlString) {
        if((xmlString ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("xmlString"));
        }
        DSAParameters dsaParams = cli::ctor<DSAParameters>();
        try
        {
            cli::finally_guard([&]() {
                ZeroizePrivateKey(dsaParams);
            });
            dsaParams->P = AsymmetricAlgorithm::GetNamedParam(xmlString, _T("P"));
            dsaParams->Q = AsymmetricAlgorithm::GetNamedParam(xmlString, _T("Q"));
            dsaParams->G = AsymmetricAlgorithm::GetNamedParam(xmlString, _T("G"));
            dsaParams->J = AsymmetricAlgorithm::GetNamedParam(xmlString, _T("J"));
            dsaParams->Y = AsymmetricAlgorithm::GetNamedParam(xmlString, _T("Y"));
            dsaParams->X = AsymmetricAlgorithm::GetNamedParam(xmlString, _T("X"));
            dsaParams->Seed = AsymmetricAlgorithm::GetNamedParam(xmlString, _T("Seed"));
            cli::array<unsigned char> *counter = AsymmetricAlgorithm::GetNamedParam(xmlString, _T("PgenCounter"));
            if((counter != nullptr)) 
            {
                cli::array<unsigned char> *counter4b = (new cli::array<unsigned char>(4));
                System::Buffer::BlockCopy(counter, 0, counter4b, 0, counter->get_Length());
                dsaParams->Counter = Mono::Security::BitConverterLE::ToInt32(counter4b, 0);
            }
            ImportParameters_42bffe0948290f21(dsaParams);
        }
        catch(...) {
            ZeroizePrivateKey(dsaParams);
            throw ;
        }
    }
    
    System::String* DSA::ToXmlString_681b6b8ae145c576(bool includePrivateParameters) {
        System::Text::StringBuilder *sb = cli::gcnew<System::Text::StringBuilder>();
        DSAParameters dsaParams = ExportParameters_c041d0915f31506(includePrivateParameters);
        try {
            sb->Append2(_T("<DSAKeyValue>"));
            sb->Append2(_T("<P>"));
            sb->Append2(System::Convert::ToBase64String(dsaParams->P));
            sb->Append2(_T("</P>"));
            sb->Append2(_T("<Q>"));
            sb->Append2(System::Convert::ToBase64String(dsaParams->Q));
            sb->Append2(_T("</Q>"));
            sb->Append2(_T("<G>"));
            sb->Append2(System::Convert::ToBase64String(dsaParams->G));
            sb->Append2(_T("</G>"));
            sb->Append2(_T("<Y>"));
            sb->Append2(System::Convert::ToBase64String(dsaParams->Y));
            sb->Append2(_T("</Y>"));
            if((dsaParams->J != nullptr)) 
            {
                sb->Append2(_T("<J>"));
                sb->Append2(System::Convert::ToBase64String(dsaParams->J));
                sb->Append2(_T("</J>"));
            }
            if((dsaParams->Seed != nullptr)) 
            {
                sb->Append2(_T("<Seed>"));
                sb->Append2(System::Convert::ToBase64String(dsaParams->Seed));
                sb->Append2(_T("</Seed>"));
                sb->Append2(_T("<PgenCounter>"));
                if((dsaParams->Counter != 0)) 
                {
                    cli::array<unsigned char> *inArr = Mono::Security::BitConverterLE::GetBytes4(dsaParams->Counter);
                    int32_t l = inArr->get_Length();
                    while(((int32_t)(inArr->at((l - 1))) ==  0)) l--;
                    sb->Append2(System::Convert::ToBase64String2(inArr, 0, l));
                }
                 else 
                {
                    sb->Append2(_T("AA=="));
                }
                sb->Append2(_T("</PgenCounter>"));
            }
            if((dsaParams->X != nullptr)) 
            {
                sb->Append2(_T("<X>"));
                sb->Append2(System::Convert::ToBase64String(dsaParams->X));
                sb->Append2(_T("</X>"));
            }
             else 
            {
                if(includePrivateParameters) 
                {
                    throw cli::gcnew<System::ArgumentNullException>(_T("X"));
                }
            }
            sb->Append2(_T("</DSAKeyValue>"));
        }
        catch(...) {
            ZeroizePrivateKey(dsaParams);
            throw ;
        }
        return sb->ToString_1636a0751cb9ac11();
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    bool  DSACryptoServiceProvider::useMachineKeyStore;
    
    DSACryptoServiceProvider::DSACryptoServiceProvider()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void DSACryptoServiceProvider::constructor() {
    }
    
    void DSACryptoServiceProvider::constructor(CspParameters* parameters) {
    }
    
    void DSACryptoServiceProvider::constructor(int32_t dwKeySize) {
    }
    
    void DSACryptoServiceProvider::constructor(int32_t dwKeySize, CspParameters* parameters) {
        this->LegalKeySizesValue = (new cli::array<KeySizes*>(1));
        this->LegalKeySizesValue->at(0) = cli::gcnew<KeySizes>(512, 1024, 64);
        this->set_KeySize_16a33b99cbf5525b(dwKeySize);
        this->dsa = cli::gcnew<Mono::Security::Cryptography::DSAManaged>(dwKeySize);
        this->dsa->add_KeyGenerated(cli::bind(this, &DSACryptoServiceProvider::OnKeyGenerated));
        this->persistKey = (parameters != nullptr);
        if((parameters ==  nullptr)) 
        {
            parameters = cli::gcnew<CspParameters>(13);
            if(useMachineKeyStore) 
            {
                (parameters->set_Flags((CspProviderFlags)(((int32_t)(parameters->get_Flags()) | 1))));
            }
            this->store = cli::gcnew<Mono::Security::Cryptography::KeyPairPersistence>(parameters);
        }
         else 
        {
            this->store = cli::gcnew<Mono::Security::Cryptography::KeyPairPersistence>(parameters);
            this->store->Load();
            if((this->store->get_KeyValue() != nullptr)) 
            {
                this->persisted = true;
                this->FromXmlString_ec36cca6166e6990(this->store->get_KeyValue());
            }
        }
    }
    
    void DSACryptoServiceProvider::static_constructor() {
    }
    
    void DSACryptoServiceProvider::Finalize_bd77f2b481781f93() {
        {
            cli::finally_guard([&]() {
                Finalize_b946fbc32e26afd6();
            });
            AsymmetricAlgorithm::Dispose_2369c0ba816a26e4(false);
        }
    }
    
    DSAParameters DSACryptoServiceProvider::ExportParameters_c041d0915f31506(bool includePrivateParameters) {
        if((includePrivateParameters && !(this->privateKeyExportable))) 
        {
            throw cli::gcnew<CryptographicException>(Locale::GetText(_T("Cannot export private key")));
        }
        return this->dsa->ExportParameters_c041d0915f31506(includePrivateParameters);
    }
    
    void DSACryptoServiceProvider::ImportParameters_42bffe0948290f21(DSAParameters parameters) {
        this->dsa->ImportParameters_42bffe0948290f21(parameters);
    }
    
    cli::array<unsigned char>* DSACryptoServiceProvider::CreateSignature_9fa6bb91f702a4df(cli::array<unsigned char>* rgbHash) {
        return this->dsa->CreateSignature_9fa6bb91f702a4df(rgbHash);
    }
    
    cli::array<unsigned char>* DSACryptoServiceProvider::SignData(cli::array<unsigned char>* buffer) {
        HashAlgorithm *hash = SHA1::Create3();
        cli::array<unsigned char> *toBeSigned = hash->ComputeHash(buffer);
        return this->dsa->CreateSignature_9fa6bb91f702a4df(toBeSigned);
    }
    
    cli::array<unsigned char>* DSACryptoServiceProvider::SignData2(cli::array<unsigned char>* buffer, int32_t offset, int32_t count) {
        HashAlgorithm *hash = SHA1::Create3();
        cli::array<unsigned char> *toBeSigned = hash->ComputeHash2(buffer, offset, count);
        return this->dsa->CreateSignature_9fa6bb91f702a4df(toBeSigned);
    }
    
    cli::array<unsigned char>* DSACryptoServiceProvider::SignData3(System::IO::Stream* inputStream) {
        HashAlgorithm *hash = SHA1::Create3();
        cli::array<unsigned char> *toBeSigned = hash->ComputeHash3(inputStream);
        return this->dsa->CreateSignature_9fa6bb91f702a4df(toBeSigned);
    }
    
    cli::array<unsigned char>* DSACryptoServiceProvider::SignHash(cli::array<unsigned char>* rgbHash, System::String* str) {
        if((System::String::Compare3(str, _T("SHA1"), true, System::Globalization::CultureInfo::get_InvariantCulture()) != 0)) 
        {
            throw cli::gcnew<CryptographicException>(Locale::GetText(_T("Only SHA1 is supported.")));
        }
        return this->dsa->CreateSignature_9fa6bb91f702a4df(rgbHash);
    }
    
    bool DSACryptoServiceProvider::VerifyData(cli::array<unsigned char>* rgbData, cli::array<unsigned char>* rgbSignature) {
        HashAlgorithm *hash = SHA1::Create3();
        cli::array<unsigned char> *toBeVerified = hash->ComputeHash(rgbData);
        return this->dsa->VerifySignature_a25545e0d63f0901(toBeVerified, rgbSignature);
    }
    
    bool DSACryptoServiceProvider::VerifyHash(cli::array<unsigned char>* rgbHash, System::String* str, cli::array<unsigned char>* rgbSignature) {
        if((str ==  nullptr)) 
        {
            str = _T("SHA1");
        }
        if((System::String::Compare3(str, _T("SHA1"), true, System::Globalization::CultureInfo::get_InvariantCulture()) != 0)) 
        {
            throw cli::gcnew<CryptographicException>(Locale::GetText(_T("Only SHA1 is supported.")));
        }
        return this->dsa->VerifySignature_a25545e0d63f0901(rgbHash, rgbSignature);
    }
    
    bool DSACryptoServiceProvider::VerifySignature_a25545e0d63f0901(cli::array<unsigned char>* rgbHash, cli::array<unsigned char>* rgbSignature) {
        return this->dsa->VerifySignature_a25545e0d63f0901(rgbHash, rgbSignature);
    }
    
    void DSACryptoServiceProvider::Dispose_2369c0ba816a26e4(bool disposing) {
        if(!(this->m_disposed)) 
        {
            if((this->persisted && !(this->persistKey))) 
            {
                this->store->Remove();
            }
            if((this->dsa != nullptr)) 
            {
                this->dsa->Clear();
            }
            this->m_disposed = true;
        }
    }
    
    void DSACryptoServiceProvider::OnKeyGenerated(System::Object* sender, System::EventArgs* e) {
        if((this->persistKey && !(this->persisted))) 
        {
            this->store->set_KeyValue(this->ToXmlString_681b6b8ae145c576(!(this->dsa->get_PublicOnly())));
            this->store->Save();
            this->persisted = true;
        }
    }
    
    cli::array<unsigned char>* DSACryptoServiceProvider::ExportCspBlob(bool includePrivateParameters) {
        cli::array<unsigned char> *blob = nullptr;
        if(includePrivateParameters) 
        {
            blob = Mono::Security::Cryptography::CryptoConvert::ToCapiPrivateKeyBlob2(this);
        }
         else 
        {
            blob = Mono::Security::Cryptography::CryptoConvert::ToCapiPublicKeyBlob2(this);
        }
        return blob;
    }
    
    void DSACryptoServiceProvider::ImportCspBlob(cli::array<unsigned char>* keyBlob) {
        if((keyBlob ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("keyBlob"));
        }
        DSA *dsa = Mono::Security::Cryptography::CryptoConvert::FromCapiKeyBlobDSA(keyBlob);
        if(cli::is<DSACryptoServiceProvider>(dsa)) 
        {
            DSAParameters dsap = dsa->ExportParameters_c041d0915f31506(!(cli::as<DSACryptoServiceProvider*>(dsa)->get_PublicOnly()));
            DSACryptoServiceProvider::ImportParameters_42bffe0948290f21(dsap);
        }
         else 
        {
            try {
                DSAParameters dsap = dsa->ExportParameters_c041d0915f31506(true);
                DSACryptoServiceProvider::ImportParameters_42bffe0948290f21(dsap);
            }
            catch(...) {
                DSAParameters dsap = dsa->ExportParameters_c041d0915f31506(false);
                DSACryptoServiceProvider::ImportParameters_42bffe0948290f21(dsap);
            }
        }
    }
    
    System::String* DSACryptoServiceProvider::get_KeyExchangeAlgorithm_e4956689b1767b62() {
        return nullptr;
    }
    
    int32_t DSACryptoServiceProvider::get_KeySize_6bd474632c551ac() {
        return this->dsa->get_KeySize_6bd474632c551ac();
    }
    
    bool DSACryptoServiceProvider::get_PersistKeyInCsp() {
        return this->persistKey;
    }
    
    bool DSACryptoServiceProvider::set_PersistKeyInCsp(bool value) {
        this->persistKey = value;
        return get_PersistKeyInCsp();
    }
    
    bool DSACryptoServiceProvider::get_PublicOnly() {
        return this->dsa->get_PublicOnly();
    }
    
    System::String* DSACryptoServiceProvider::get_SignatureAlgorithm_94f2ebe82aebde31() {
        return _T("http://www.w3.org/2000/09/xmldsig#dsa-sha1");
    }
    
    bool DSACryptoServiceProvider::get_UseMachineKeyStore() {
        return useMachineKeyStore;
    }
    
    bool DSACryptoServiceProvider::set_UseMachineKeyStore(bool value) {
        useMachineKeyStore = value;
        return get_UseMachineKeyStore();
    }
    
    CspKeyContainerInfo* DSACryptoServiceProvider::get_CspKeyContainerInfo() {
        return nullptr;
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    
    void DSASignatureDeformatter::constructor() {
    }
    
    void DSASignatureDeformatter::constructor(AsymmetricAlgorithm* key) {
        DSASignatureDeformatter::SetKey_d453955f9571ca18(key);
    }
    
    void DSASignatureDeformatter::SetHashAlgorithm_5a7fb9c08aaf7ac9(System::String* strName) {
        if((strName ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("strName"));
        }
        try {
            SHA1::Create4(strName);
        }
        catch(System::InvalidCastException*) {
            throw cli::gcnew<CryptographicUnexpectedOperationException>(Locale::GetText(_T("DSA requires SHA1")));
        }
    }
    
    void DSASignatureDeformatter::SetKey_d453955f9571ca18(AsymmetricAlgorithm* key) {
        if((key != nullptr)) 
        {
            this->dsa = cli::cast<DSA*>(key);
        }
         else 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("key"));
        }
    }
    
    bool DSASignatureDeformatter::VerifySignature_ecf649797288645c(cli::array<unsigned char>* rgbHash, cli::array<unsigned char>* rgbSignature) {
        if((this->dsa ==  nullptr)) 
        {
            throw cli::gcnew<CryptographicUnexpectedOperationException>(Locale::GetText(_T("missing key")));
        }
        return this->dsa->VerifySignature_a25545e0d63f0901(rgbHash, rgbSignature);
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    
    void DSASignatureFormatter::constructor() {
    }
    
    void DSASignatureFormatter::constructor(AsymmetricAlgorithm* key) {
        DSASignatureFormatter::SetKey_1b1967336b333b5c(key);
    }
    
    cli::array<unsigned char>* DSASignatureFormatter::CreateSignature_119f8aceb75b0d2(cli::array<unsigned char>* rgbHash) {
        if((this->dsa ==  nullptr)) 
        {
            throw cli::gcnew<CryptographicUnexpectedOperationException>(Locale::GetText(_T("missing key")));
        }
        return this->dsa->CreateSignature_9fa6bb91f702a4df(rgbHash);
    }
    
    void DSASignatureFormatter::SetHashAlgorithm_9029a89c4cb706ce(System::String* strName) {
        if((strName ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("strName"));
        }
        try {
            SHA1::Create4(strName);
        }
        catch(System::InvalidCastException*) {
            throw cli::gcnew<CryptographicUnexpectedOperationException>(Locale::GetText(_T("DSA requires SHA1")));
        }
    }
    
    void DSASignatureFormatter::SetKey_1b1967336b333b5c(AsymmetricAlgorithm* key) {
        if((key != nullptr)) 
        {
            this->dsa = cli::cast<DSA*>(key);
        }
         else 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("key"));
        }
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    
    void FromBase64Transform::constructor() {
    }
    
    void FromBase64Transform::constructor(FromBase64TransformMode whitespaces) {
        this->mode = whitespaces;
        this->accumulator = (new cli::array<unsigned char>(4));
        this->accPtr = 0;
        this->m_disposed = false;
    }
    
    void FromBase64Transform::Finalize_a1463e6a115c6ea6() {
        {
            cli::finally_guard([&]() {
                Finalize_b946fbc32e26afd6();
            });
            Dispose_c94b8ed911b70760(false);
        }
    }
    
    void FromBase64Transform::Clear() {
        Dispose_c94b8ed911b70760(true);
    }
    
    void FromBase64Transform::Dispose() {
        Dispose_c94b8ed911b70760(true);
        System::GC::SuppressFinalize(this);
    }
    
    void FromBase64Transform::Dispose_c94b8ed911b70760(bool disposing) {
        if(!(this->m_disposed)) 
        {
            if((this->accumulator != nullptr)) 
            {
                System::Array::Clear2(this->accumulator, 0, this->accumulator->get_Length());
            }
            if(disposing) 
            {
                this->accumulator = nullptr;
            }
            this->m_disposed = true;
        }
    }
    
    unsigned char FromBase64Transform::lookup(unsigned char input) {
        if(((int32_t)(input) >= this->lookupTable->get_Length())) 
        {
            throw cli::gcnew<System::FormatException>(Locale::GetText(_T("Invalid character in a Base-64 string.")));
        }
        unsigned char ret = this->lookupTable->at((int32_t)(input));
        if(((int32_t)(ret) ==  255)) 
        {
            throw cli::gcnew<System::FormatException>(Locale::GetText(_T("Invalid character in a Base-64 string.")));
        }
        return ret;
    }
    
    int32_t FromBase64Transform::ProcessBlock(cli::array<unsigned char>* output, int32_t offset) {
        int32_t rem = 0;
        if(((int32_t)(this->accumulator->at(3)) ==  61)) 
        {
            rem++;
        }
        if(((int32_t)(this->accumulator->at(2)) ==  61)) 
        {
            rem++;
        }
        this->lookupTable = Base64Constants::DecodeTable;
        int32_t b0, b1, b2, b3;
        switch(rem) {
            case 0: case_1660: {
                b0 = (int32_t)(lookup(this->accumulator->at(0)));
                b1 = (int32_t)(lookup(this->accumulator->at(1)));
                b2 = (int32_t)(lookup(this->accumulator->at(2)));
                b3 = (int32_t)(lookup(this->accumulator->at(3)));
                output->at(offset++) = (unsigned char)((b0 << 2) | (b1 >> 4));
                output->at(offset++) = (unsigned char)((b1 << 4) | (b2 >> 2));
                output->at(offset) = (unsigned char)((b2 << 6) | b3);
                break;
            }
            case 1: case_1661: {
                b0 = (int32_t)(lookup(this->accumulator->at(0)));
                b1 = (int32_t)(lookup(this->accumulator->at(1)));
                b2 = (int32_t)(lookup(this->accumulator->at(2)));
                output->at(offset++) = (unsigned char)((b0 << 2) | (b1 >> 4));
                output->at(offset) = (unsigned char)((b1 << 4) | (b2 >> 2));
                break;
            }
            case 2: case_1662: {
                b0 = (int32_t)(lookup(this->accumulator->at(0)));
                b1 = (int32_t)(lookup(this->accumulator->at(1)));
                output->at(offset) = (unsigned char)((b0 << 2) | (b1 >> 4));
                break;
            }
        }
        return (3 - rem);
    }
    
    void FromBase64Transform::CheckInputParameters(cli::array<unsigned char>* inputBuffer, int32_t inputOffset, int32_t inputCount) {
        if((inputBuffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("inputBuffer"));
        }
        if((inputOffset < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("inputOffset"), _T("< 0"));
        }
        if((inputCount > inputBuffer->get_Length())) 
        {
            throw cli::gcnew<System::OutOfMemoryException>(cli::concat(_T("inputCount "), Locale::GetText(_T("Overflow"))));
        }
        if((inputOffset > (inputBuffer->get_Length() - inputCount))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("inputOffset"), Locale::GetText(_T("Overflow")));
        }
        if((inputCount < 0)) 
        {
            throw cli::gcnew<System::OverflowException>(_T("inputCount < 0"));
        }
    }
    
    int32_t FromBase64Transform::TransformBlock(cli::array<unsigned char>* inputBuffer, int32_t inputOffset, int32_t inputCount, cli::array<unsigned char>* outputBuffer, int32_t outputOffset) {
        if(this->m_disposed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("FromBase64Transform"));
        }
        CheckInputParameters(inputBuffer, inputOffset, inputCount);
        if(((outputBuffer ==  nullptr) || (outputOffset < 0))) 
        {
            throw cli::gcnew<System::FormatException>(_T("outputBuffer"));
        }
        int32_t res = 0;
        while((inputCount > 0)) {
            if((this->accPtr < 4)) 
            {
                unsigned char b = inputBuffer->at(inputOffset++);
                if(((int32_t)(this->mode) ==  0)) 
                {
                    if(!(System::Char::IsWhiteSpace((char16_t)b))) 
                    {
                        this->accumulator->at(this->accPtr++) = b;
                    }
                }
                 else 
                {
                    this->accumulator->at(this->accPtr++) = b;
                }
            }
            if((this->accPtr ==  4)) 
            {
                (res = res + ProcessBlock(outputBuffer, outputOffset));
                (outputOffset = outputOffset + 3);
                this->accPtr = 0;
            }
            inputCount--;
        }
        return res;
    }
    
    cli::array<unsigned char>* FromBase64Transform::TransformFinalBlock(cli::array<unsigned char>* inputBuffer, int32_t inputOffset, int32_t inputCount) {
        if(this->m_disposed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("FromBase64Transform"));
        }
        CheckInputParameters(inputBuffer, inputOffset, inputCount);
        int32_t ws = 0;
        int32_t terminator = 0;
        if(((int32_t)(this->mode) ==  0)) 
        {
            for(int32_t i = inputOffset, j = 0; (j < inputCount); i++, j++){
                if(System::Char::IsWhiteSpace((char16_t)inputBuffer->at(i))) 
                {
                    ws++;
                }
            }
            if((ws ==  inputCount)) 
            {
                return (new cli::array<unsigned char>(0));
            }
            int32_t k = ((inputOffset + inputCount) - 1);
            int32_t n = System::Math::Min5(2, inputCount);
            while((n > 0)) {
                char16_t c = (char16_t)inputBuffer->at(k--);
                if(((int32_t)(c) ==  61)) 
                {
                    terminator++;
                    n--;
                }
                 else 
                {
                    if(System::Char::IsWhiteSpace(c)) 
                    {
                        continue;
                    }
                     else 
                    {
                        break;
                    }
                }
            }
        }
         else 
        {
            if(((int32_t)(inputBuffer->at(((inputOffset + inputCount) - 1))) ==  61)) 
            {
                terminator++;
            }
            if(((int32_t)(inputBuffer->at(((inputOffset + inputCount) - 2))) ==  61)) 
            {
                terminator++;
            }
        }
        if(((inputCount < 4) && (terminator < 2))) 
        {
            if(((this->accPtr > 2) && ((int32_t)(this->accumulator->at(3)) ==  61))) 
            {
                terminator++;
            }
            if(((this->accPtr > 1) && ((int32_t)(this->accumulator->at(2)) ==  61))) 
            {
                terminator++;
            }
        }
        int32_t count = (((((this->accPtr + inputCount) - ws) >> 2) * 3) - terminator);
        if((count <= 0)) 
        {
            return (new cli::array<unsigned char>(0));
        }
        cli::array<unsigned char> *result = (new cli::array<unsigned char>(count));
        TransformBlock(inputBuffer, inputOffset, inputCount, result, 0);
        return result;
    }
    
    bool FromBase64Transform::get_CanTransformMultipleBlocks() {
        return false;
    }
    
    bool FromBase64Transform::get_CanReuseTransform_8fc1dde1dff87aad() {
        return true;
    }
    
    int32_t FromBase64Transform::get_InputBlockSize() {
        return 1;
    }
    
    int32_t FromBase64Transform::get_OutputBlockSize() {
        return 3;
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    
    void HashAlgorithm::constructor() {
        this->disposed = false;
    }
    
    void HashAlgorithm::Clear() {
        Dispose_66239c1dbe6eca10(true);
    }
    
    cli::array<unsigned char>* HashAlgorithm::ComputeHash(cli::array<unsigned char>* buffer) {
        if((buffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("buffer"));
        }
        return ComputeHash2(buffer, 0, buffer->get_Length());
    }
    
    cli::array<unsigned char>* HashAlgorithm::ComputeHash2(cli::array<unsigned char>* buffer, int32_t offset, int32_t count) {
        if(this->disposed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("HashAlgorithm"));
        }
        if((buffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("buffer"));
        }
        if((offset < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("offset"), _T("< 0"));
        }
        if((count < 0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("count"), _T("< 0"));
        }
        if((offset > (buffer->get_Length() - count))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("offset + count"), Locale::GetText(_T("Overflow")));
        }
        HashCore_8c4be9c0eca56be6(buffer, offset, count);
        this->HashValue = HashFinal_58940e7c7f2519b1();
        Initialize_4bdfe3e821ea432();
        return this->HashValue;
    }
    
    cli::array<unsigned char>* HashAlgorithm::ComputeHash3(System::IO::Stream* inputStream) {
        if(this->disposed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("HashAlgorithm"));
        }
        cli::array<unsigned char> *buffer = (new cli::array<unsigned char>(4096));
        int32_t len = inputStream->Read_c0d6dde3943b413e(buffer, 0, 4096);
        while((len > 0)) {
            HashCore_8c4be9c0eca56be6(buffer, 0, len);
            len = inputStream->Read_c0d6dde3943b413e(buffer, 0, 4096);
        }
        this->HashValue = HashFinal_58940e7c7f2519b1();
        Initialize_4bdfe3e821ea432();
        return this->HashValue;
    }
    
    HashAlgorithm* HashAlgorithm::Create() {
        return Create2(_T("System.Security.Cryptography.HashAlgorithm"));
    }
    
    HashAlgorithm* HashAlgorithm::Create2(System::String* hashName) {
        return cli::cast<HashAlgorithm*>(CryptoConfig::CreateFromName(hashName));
    }
    
    void HashAlgorithm::Dispose_66239c1dbe6eca10(bool disposing) {
        this->disposed = true;
    }
    
    void HashAlgorithm::Dispose2() {
        Dispose_66239c1dbe6eca10(true);
        System::GC::SuppressFinalize(this);
    }
    
    int32_t HashAlgorithm::TransformBlock(cli::array<unsigned char>* inputBuffer, int32_t inputOffset, int32_t inputCount, cli::array<unsigned char>* outputBuffer, int32_t outputOffset) {
        if((inputBuffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("inputBuffer"));
        }
        if((inputOffset < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("inputOffset"), _T("< 0"));
        }
        if((inputCount < 0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("inputCount"));
        }
        if(((inputOffset < 0) || (inputOffset > (inputBuffer->get_Length() - inputCount)))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("inputBuffer"));
        }
        if((outputBuffer != nullptr)) 
        {
            if((outputOffset < 0)) 
            {
                throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("outputOffset"), _T("< 0"));
            }
            if((outputOffset > (outputBuffer->get_Length() - inputCount))) 
            {
                throw cli::gcnew<System::ArgumentException>(_T("outputOffset + inputCount"), Locale::GetText(_T("Overflow")));
            }
        }
        HashCore_8c4be9c0eca56be6(inputBuffer, inputOffset, inputCount);
        if((outputBuffer != nullptr)) 
        {
            System::Buffer::BlockCopy(inputBuffer, inputOffset, outputBuffer, outputOffset, inputCount);
        }
        return inputCount;
    }
    
    cli::array<unsigned char>* HashAlgorithm::TransformFinalBlock(cli::array<unsigned char>* inputBuffer, int32_t inputOffset, int32_t inputCount) {
        if((inputBuffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("inputBuffer"));
        }
        if((inputCount < 0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("inputCount"));
        }
        if((inputOffset > (inputBuffer->get_Length() - inputCount))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("inputOffset + inputCount"), Locale::GetText(_T("Overflow")));
        }
        cli::array<unsigned char> *outputBuffer = (new cli::array<unsigned char>(inputCount));
        System::Buffer::BlockCopy(inputBuffer, inputOffset, outputBuffer, 0, inputCount);
        HashCore_8c4be9c0eca56be6(inputBuffer, inputOffset, inputCount);
        this->HashValue = HashFinal_58940e7c7f2519b1();
        Initialize_4bdfe3e821ea432();
        return outputBuffer;
    }
    
    bool HashAlgorithm::get_CanTransformMultipleBlocks_fb3bd2c8e857f691() {
        return true;
    }
    
    bool HashAlgorithm::get_CanReuseTransform_19ba0450c5bf43f9() {
        return true;
    }
    
    cli::array<unsigned char>* HashAlgorithm::get_Hash_cb65a3f211aa16df() {
        if((this->HashValue ==  nullptr)) 
        {
            throw cli::gcnew<CryptographicUnexpectedOperationException>(Locale::GetText(_T("No hash value computed.")));
        }
        return this->HashValue;
    }
    
    int32_t HashAlgorithm::get_HashSize_9f628c7f48e4ff01() {
        return this->HashSizeValue;
    }
    
    int32_t HashAlgorithm::get_InputBlockSize_76e25e14b1426491() {
        return 1;
    }
    
    int32_t HashAlgorithm::get_OutputBlockSize_ade2f52ae475c349() {
        return 1;
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    
    void HMAC::constructor() {
        this->_disposed = false;
        this->_blockSizeValue = 64;
    }
    
    cli::array<unsigned char>* HMAC::KeySetup(cli::array<unsigned char>* key, unsigned char padding) {
        cli::array<unsigned char> *buf = (new cli::array<unsigned char>(this->get_BlockSizeValue()));
        for(int32_t i = 0; (i < key->get_Length()); ++i) {
            buf->at(i) = (unsigned char)((int32_t)(key->at(i)) ^ (int32_t)(padding));
        }
        for(int32_t i = key->get_Length(); (i < this->get_BlockSizeValue()); ++i) {
            buf->at(i) = padding;
        }
        return buf;
    }
    
    void HMAC::Dispose_66239c1dbe6eca10(bool disposing) {
        if(!(this->_disposed)) 
        {
            KeyedHashAlgorithm::Dispose_66239c1dbe6eca10(disposing);
        }
    }
    
    void HMAC::HashCore_8c4be9c0eca56be6(cli::array<unsigned char>* rgb, int32_t ib, int32_t cb) {
        if(this->_disposed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("HMACSHA1"));
        }
        if((this->State ==  0)) 
        {
            HMAC::Initialize_4bdfe3e821ea432();
            this->State = 1;
        }
        this->get_Block()->Core2(rgb, ib, cb);
    }
    
    cli::array<unsigned char>* HMAC::HashFinal_58940e7c7f2519b1() {
        if(this->_disposed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("HMAC"));
        }
        this->State = 0;
        this->get_Block()->Final();
        cli::array<unsigned char> *intermediate = this->_algo->get_Hash_cb65a3f211aa16df();
        cli::array<unsigned char> *buf = KeySetup(this->get_Key_326b1bef7df09fc3(), 92);
        this->_algo->Initialize_4bdfe3e821ea432();
        this->_algo->TransformBlock(buf, 0, buf->get_Length(), buf, 0);
        this->_algo->TransformFinalBlock(intermediate, 0, intermediate->get_Length());
        cli::array<unsigned char> *hash = this->_algo->get_Hash_cb65a3f211aa16df();
        this->_algo->Initialize_4bdfe3e821ea432();
        System::Array::Clear2(buf, 0, buf->get_Length());
        System::Array::Clear2(intermediate, 0, intermediate->get_Length());
        return hash;
    }
    
    void HMAC::Initialize_4bdfe3e821ea432() {
        if(this->_disposed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("HMAC"));
        }
        this->State = 0;
        this->get_Block()->Initialize();
        cli::array<unsigned char> *buf = KeySetup(this->get_Key_326b1bef7df09fc3(), 54);
        this->_algo->Initialize_4bdfe3e821ea432();
        this->get_Block()->Core(buf);
        System::Array::Clear2(buf, 0, buf->get_Length());
    }
    
    HMAC* HMAC::Create() {
        return Create2(_T("System.Security.Cryptography.HMAC"));
    }
    
    HMAC* HMAC::Create2(System::String* algorithmName) {
        return cli::cast<HMAC*>(CryptoConfig::CreateFromName(algorithmName));
    }
    
    int32_t HMAC::get_BlockSizeValue() {
        return this->_blockSizeValue;
    }
    
    int32_t HMAC::set_BlockSizeValue(int32_t value) {
        this->_blockSizeValue = value;
        return get_BlockSizeValue();
    }
    
    System::String* HMAC::get_HashName() {
        return this->_hashName;
    }
    
    System::String* HMAC::set_HashName(System::String* value) {
        this->_hashName = value;
        this->_algo = HashAlgorithm::Create2(this->_hashName);
        return get_HashName();
    }
    
    cli::array<unsigned char>* HMAC::get_Key_326b1bef7df09fc3() {
        return cli::cast<cli::array<unsigned char>*>(cli::import(KeyedHashAlgorithm::get_Key_326b1bef7df09fc3())->Clone());
    }
    
    cli::array<unsigned char>* HMAC::set_Key_3e476ff3afc5eb94(cli::array<unsigned char>* value) {
        if(((value != nullptr) && (value->get_Length() > this->get_BlockSizeValue()))) 
        {
            KeyedHashAlgorithm::set_Key_3e476ff3afc5eb94(this->_algo->ComputeHash(value));
        }
         else 
        {
            KeyedHashAlgorithm::set_Key_3e476ff3afc5eb94(cli::cast<cli::array<unsigned char>*>(cli::import(value)->Clone()));
        }
        return get_Key_326b1bef7df09fc3();
    }
    
    Mono::Security::Cryptography::BlockProcessor* HMAC::get_Block() {
        if((this->_block ==  nullptr)) 
        {
            this->_block = cli::gcnew<Mono::Security::Cryptography::BlockProcessor>(this->_algo, (this->get_BlockSizeValue() >> 3));
        }
        return this->_block;
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    
    void HMACMD5::constructor() {
    }
    
    void HMACMD5::constructor(cli::array<unsigned char>* key) {
        this->set_HashName(_T("MD5"));
        this->HashSizeValue = 128;
        this->set_Key_3e476ff3afc5eb94(key);
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    
    void HMACRIPEMD160::constructor() {
    }
    
    void HMACRIPEMD160::constructor(cli::array<unsigned char>* key) {
        this->set_HashName(_T("RIPEMD160"));
        this->HashSizeValue = 160;
        this->set_Key_3e476ff3afc5eb94(key);
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    
    void HMACSHA1::constructor() {
    }
    
    void HMACSHA1::constructor(cli::array<unsigned char>* key) {
        this->set_HashName(_T("SHA1"));
        this->HashSizeValue = 160;
        this->set_Key_3e476ff3afc5eb94(key);
    }
    
    void HMACSHA1::constructor(cli::array<unsigned char>* key, bool useManagedSha1) {
        this->set_HashName(cli::concat(_T("System.Security.Cryptography.SHA1"), useManagedSha1 ? _T("Managed") : _T("CryptoServiceProvider")));
        this->HashSizeValue = 160;
        this->set_Key_3e476ff3afc5eb94(key);
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    
    void HMACSHA256::constructor() {
    }
    
    void HMACSHA256::constructor(cli::array<unsigned char>* key) {
        this->set_HashName(_T("SHA256"));
        this->HashSizeValue = 256;
        this->set_Key_3e476ff3afc5eb94(key);
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    bool  HMACSHA384::legacy_mode;
    
    HMACSHA384::HMACSHA384()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void HMACSHA384::static_constructor() {
        legacy_mode = System::String::op_Equality(System::Environment::GetEnvironmentVariable(_T("legacyHMACMode")), _T("1"));
    }
    
    void HMACSHA384::constructor() {
        this->set_ProduceLegacyHmacValues(legacy_mode);
    }
    
    void HMACSHA384::constructor(cli::array<unsigned char>* key) {
        this->set_ProduceLegacyHmacValues(legacy_mode);
        this->set_HashName(_T("SHA384"));
        this->HashSizeValue = 384;
        this->set_Key_3e476ff3afc5eb94(key);
    }
    
    bool HMACSHA384::get_ProduceLegacyHmacValues() {
        return this->legacy;
    }
    
    bool HMACSHA384::set_ProduceLegacyHmacValues(bool value) {
        this->legacy = value;
        this->set_BlockSizeValue(this->legacy ? 64 : 128);
        return get_ProduceLegacyHmacValues();
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    bool  HMACSHA512::legacy_mode;
    
    HMACSHA512::HMACSHA512()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void HMACSHA512::static_constructor() {
        legacy_mode = System::String::op_Equality(System::Environment::GetEnvironmentVariable(_T("legacyHMACMode")), _T("1"));
    }
    
    void HMACSHA512::constructor() {
        this->set_ProduceLegacyHmacValues(legacy_mode);
    }
    
    void HMACSHA512::constructor(cli::array<unsigned char>* key) {
        this->set_ProduceLegacyHmacValues(legacy_mode);
        this->set_HashName(_T("SHA512"));
        this->HashSizeValue = 512;
        this->set_Key_3e476ff3afc5eb94(key);
    }
    
    bool HMACSHA512::get_ProduceLegacyHmacValues() {
        return this->legacy;
    }
    
    bool HMACSHA512::set_ProduceLegacyHmacValues(bool value) {
        this->legacy = value;
        this->set_BlockSizeValue(this->legacy ? 64 : 128);
        return get_ProduceLegacyHmacValues();
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    
    void KeyedHashAlgorithm::constructor() {
    }
    
    void KeyedHashAlgorithm::Finalize_56679ddda2765c0c() {
        {
            cli::finally_guard([&]() {
                Finalize_b946fbc32e26afd6();
            });
            HashAlgorithm::Dispose_66239c1dbe6eca10(false);
        }
    }
    
    void KeyedHashAlgorithm::Dispose_66239c1dbe6eca10(bool disposing) {
        ZeroizeKey();
        HashAlgorithm::Dispose_66239c1dbe6eca10(disposing);
    }
    
    void KeyedHashAlgorithm::ZeroizeKey() {
        if((this->KeyValue != nullptr)) 
        {
            System::Array::Clear2(this->KeyValue, 0, this->KeyValue->get_Length());
        }
    }
    
    KeyedHashAlgorithm* KeyedHashAlgorithm::Create3() {
        return Create4(_T("System.Security.Cryptography.KeyedHashAlgorithm"));
    }
    
    KeyedHashAlgorithm* KeyedHashAlgorithm::Create4(System::String* algName) {
        return cli::cast<KeyedHashAlgorithm*>(CryptoConfig::CreateFromName(algName));
    }
    
    cli::array<unsigned char>* KeyedHashAlgorithm::get_Key_326b1bef7df09fc3() {
        return cli::cast<cli::array<unsigned char>*>(cli::import(this->KeyValue)->Clone());
    }
    
    cli::array<unsigned char>* KeyedHashAlgorithm::set_Key_3e476ff3afc5eb94(cli::array<unsigned char>* value) {
        if((this->State != 0)) 
        {
            throw cli::gcnew<CryptographicException>(Locale::GetText(_T("Key can\'t be changed at this state.")));
        }
        ZeroizeKey();
        this->KeyValue = cli::cast<cli::array<unsigned char>*>(cli::import(value)->Clone());
        return get_Key_326b1bef7df09fc3();
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    
    void KeySizes::constructor(int32_t minSize, int32_t maxSize, int32_t skipSize) {
        this->_maxSize = maxSize;
        this->_minSize = minSize;
        this->_skipSize = skipSize;
    }
    
    bool KeySizes::IsLegal(int32_t keySize) {
        int32_t ks = (keySize - this->get_MinSize());
        bool result = ((ks >= 0) && (keySize <= this->get_MaxSize()));
        return (this->get_SkipSize() ==  0) ? result : (result && ((ks % this->get_SkipSize()) ==  0));
    }
    
    bool KeySizes::IsLegalKeySize(cli::array<KeySizes*>* legalKeys, int32_t size) {
        for(auto tmp_520 : legalKeys) {
            auto legalKeySize = cli::cast<KeySizes*>(tmp_520);
            {
                if(legalKeySize->IsLegal(size)) 
                {
                    return true;
                }
            }
        }
        return false;
    }
    
    int32_t KeySizes::get_MaxSize() {
        return this->_maxSize;
    }
    
    int32_t KeySizes::get_MinSize() {
        return this->_minSize;
    }
    
    int32_t KeySizes::get_SkipSize() {
        return this->_skipSize;
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    
    void MACTripleDES::constructor() {
        Setup(_T("TripleDES"), nullptr);
    }
    
    void MACTripleDES::constructor(cli::array<unsigned char>* rgbKey) {
        if((rgbKey ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("rgbKey"));
        }
        Setup(_T("TripleDES"), rgbKey);
    }
    
    void MACTripleDES::constructor(System::String* strTripleDES, cli::array<unsigned char>* rgbKey) {
        if((rgbKey ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("rgbKey"));
        }
        if((strTripleDES ==  nullptr)) 
        {
            Setup(_T("TripleDES"), rgbKey);
        }
         else 
        {
            Setup(strTripleDES, rgbKey);
        }
    }
    
    void MACTripleDES::Finalize_e2d491b8234f80a8() {
        {
            cli::finally_guard([&]() {
                Finalize_56679ddda2765c0c();
            });
            HashAlgorithm::Dispose_66239c1dbe6eca10(false);
        }
    }
    
    void MACTripleDES::Setup(System::String* strTripleDES, cli::array<unsigned char>* rgbKey) {
        this->tdes = TripleDES::Create4(strTripleDES);
        this->tdes->set_Padding_2e9637021e7fe5c6(PaddingMode::Zeros);
        if((rgbKey != nullptr)) 
        {
            this->tdes->set_Key_9b56e7a05d7e4c8f(rgbKey);
        }
        this->HashSizeValue = this->tdes->get_BlockSize_7a5a96e8187bef27();
        this->set_Key_3e476ff3afc5eb94(this->tdes->get_Key_79a2c753d4f0f561());
        this->mac = cli::gcnew<Mono::Security::Cryptography::MACAlgorithm>(this->tdes);
        this->m_disposed = false;
    }
    
    void MACTripleDES::Dispose_66239c1dbe6eca10(bool disposing) {
        if(!(this->m_disposed)) 
        {
            if((this->KeyValue != nullptr)) 
            {
                System::Array::Clear2(this->KeyValue, 0, this->KeyValue->get_Length());
            }
            if((this->tdes != nullptr)) 
            {
                this->tdes->Clear();
            }
            if(disposing) 
            {
                this->KeyValue = nullptr;
                this->tdes = nullptr;
            }
            KeyedHashAlgorithm::Dispose_66239c1dbe6eca10(disposing);
            this->m_disposed = true;
        }
    }
    
    void MACTripleDES::Initialize_4bdfe3e821ea432() {
        if(this->m_disposed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("MACTripleDES"));
        }
        this->State = 0;
        this->mac->Initialize(this->KeyValue);
    }
    
    void MACTripleDES::HashCore_8c4be9c0eca56be6(cli::array<unsigned char>* rgbData, int32_t ibStart, int32_t cbSize) {
        if(this->m_disposed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("MACTripleDES"));
        }
        if((this->State ==  0)) 
        {
            MACTripleDES::Initialize_4bdfe3e821ea432();
            this->State = 1;
        }
        this->mac->Core(rgbData, ibStart, cbSize);
    }
    
    cli::array<unsigned char>* MACTripleDES::HashFinal_58940e7c7f2519b1() {
        if(this->m_disposed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("MACTripleDES"));
        }
        this->State = 0;
        return this->mac->Final();
    }
    
    PaddingMode MACTripleDES::get_Padding() {
        return this->tdes->get_Padding_4e1745ee57afb026();
    }
    
    PaddingMode MACTripleDES::set_Padding(PaddingMode value) {
        this->tdes->set_Padding_2e9637021e7fe5c6(value);
        return get_Padding();
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    
    void MaskGenerationMethod::constructor() {
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    
    void MD5::constructor() {
        this->HashSizeValue = 128;
    }
    
    MD5* MD5::Create3() {
        return Create4(_T("System.Security.Cryptography.MD5"));
    }
    
    MD5* MD5::Create4(System::String* algName) {
        return cli::cast<MD5*>(CryptoConfig::CreateFromName(algName));
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    cli::array<uint32_t>*  MD5CryptoServiceProvider::K;
    
    MD5CryptoServiceProvider::MD5CryptoServiceProvider()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void MD5CryptoServiceProvider::constructor() {
        this->_H = (new cli::array<uint32_t>(4));
        this->buff = (new cli::array<uint32_t>(16));
        this->_ProcessingBuffer = (new cli::array<unsigned char>(64));
        MD5CryptoServiceProvider::Initialize_4bdfe3e821ea432();
    }
    
    void MD5CryptoServiceProvider::static_constructor() {
    }
    
    void MD5CryptoServiceProvider::Finalize_6f64855bf1dfddf4() {
        {
            cli::finally_guard([&]() {
                Finalize_b946fbc32e26afd6();
            });
            HashAlgorithm::Dispose_66239c1dbe6eca10(false);
        }
    }
    
    void MD5CryptoServiceProvider::Dispose_66239c1dbe6eca10(bool disposing) {
        if((this->_ProcessingBuffer != nullptr)) 
        {
            System::Array::Clear2(this->_ProcessingBuffer, 0, this->_ProcessingBuffer->get_Length());
            this->_ProcessingBuffer = nullptr;
        }
        if((this->_H != nullptr)) 
        {
            System::Array::Clear2(this->_H, 0, this->_H->get_Length());
            this->_H = nullptr;
        }
        if((this->buff != nullptr)) 
        {
            System::Array::Clear2(this->buff, 0, this->buff->get_Length());
            this->buff = nullptr;
        }
    }
    
    void MD5CryptoServiceProvider::HashCore_8c4be9c0eca56be6(cli::array<unsigned char>* rgb, int32_t ibStart, int32_t cbSize) {
        int32_t i;
        this->State = 1;
        if((this->_ProcessingBufferCount != 0)) 
        {
            if((cbSize < (64 - this->_ProcessingBufferCount))) 
            {
                System::Buffer::BlockCopy(rgb, ibStart, this->_ProcessingBuffer, this->_ProcessingBufferCount, cbSize);
                (this->_ProcessingBufferCount = this->_ProcessingBufferCount + cbSize);
                return;
            }
             else 
            {
                i = (64 - this->_ProcessingBufferCount);
                System::Buffer::BlockCopy(rgb, ibStart, this->_ProcessingBuffer, this->_ProcessingBufferCount, i);
                ProcessBlock(this->_ProcessingBuffer, 0);
                this->_ProcessingBufferCount = 0;
                (ibStart = ibStart + i);
                (cbSize = cbSize - i);
            }
        }
        for(i = 0; (i < (cbSize - (cbSize % 64))); (i = i + 64)){
            ProcessBlock(rgb, (ibStart + i));
        }
        if(((cbSize % 64) != 0)) 
        {
            System::Buffer::BlockCopy(rgb, ((cbSize - (cbSize % 64)) + ibStart), this->_ProcessingBuffer, 0, (cbSize % 64));
            this->_ProcessingBufferCount = (cbSize % 64);
        }
    }
    
    cli::array<unsigned char>* MD5CryptoServiceProvider::HashFinal_58940e7c7f2519b1() {
        cli::array<unsigned char> *hash = (new cli::array<unsigned char>(16));
        int32_t i, j;
        ProcessFinalBlock(this->_ProcessingBuffer, 0, this->_ProcessingBufferCount);
        for(i = 0; (i < 4); i++){
            for(j = 0; (j < 4); j++){
                hash->at(((i * 4) + j)) = (unsigned char)(this->_H->at(i) >> ((j * 8) & 31));
            }
        }
        return hash;
    }
    
    void MD5CryptoServiceProvider::Initialize_4bdfe3e821ea432() {
        this->count = 0UL;
        this->_ProcessingBufferCount = 0;
        this->_H->at(0) = 1732584193U;
        this->_H->at(1) = 4023233417U;
        this->_H->at(2) = 2562383102U;
        this->_H->at(3) = 271733878U;
    }
    
    void MD5CryptoServiceProvider::ProcessBlock(cli::array<unsigned char>* inputBuffer, int32_t inputOffset) {
        uint32_t a, b, c, d;
        int32_t i;
        (this->count = this->count + 64UL);
        for(i = 0; (i < 16); i++){
            this->buff->at(i) = ((((uint32_t)(inputBuffer->at((inputOffset + (4 * i)))) | ((uint32_t)(inputBuffer->at(((inputOffset + (4 * i)) + 1))) << 8)) | ((uint32_t)(inputBuffer->at(((inputOffset + (4 * i)) + 2))) << 16)) | ((uint32_t)(inputBuffer->at(((inputOffset + (4 * i)) + 3))) << 24));
        }
        a = this->_H->at(0);
        b = this->_H->at(1);
        c = this->_H->at(2);
        d = this->_H->at(3);
        (a = a + (((((c ^ d) & b) ^ d) + (uint32_t)(K->at(0))) + this->buff->at(0)));
        a = ((a << 7) | (a >> 25));
        (a = a + b);
        (d = d + (((((b ^ c) & a) ^ c) + (uint32_t)(K->at(1))) + this->buff->at(1)));
        d = ((d << 12) | (d >> 20));
        (d = d + a);
        (c = c + (((((a ^ b) & d) ^ b) + (uint32_t)(K->at(2))) + this->buff->at(2)));
        c = ((c << 17) | (c >> 15));
        (c = c + d);
        (b = b + (((((d ^ a) & c) ^ a) + (uint32_t)(K->at(3))) + this->buff->at(3)));
        b = ((b << 22) | (b >> 10));
        (b = b + c);
        (a = a + (((((c ^ d) & b) ^ d) + (uint32_t)(K->at(4))) + this->buff->at(4)));
        a = ((a << 7) | (a >> 25));
        (a = a + b);
        (d = d + (((((b ^ c) & a) ^ c) + (uint32_t)(K->at(5))) + this->buff->at(5)));
        d = ((d << 12) | (d >> 20));
        (d = d + a);
        (c = c + (((((a ^ b) & d) ^ b) + (uint32_t)(K->at(6))) + this->buff->at(6)));
        c = ((c << 17) | (c >> 15));
        (c = c + d);
        (b = b + (((((d ^ a) & c) ^ a) + (uint32_t)(K->at(7))) + this->buff->at(7)));
        b = ((b << 22) | (b >> 10));
        (b = b + c);
        (a = a + (((((c ^ d) & b) ^ d) + (uint32_t)(K->at(8))) + this->buff->at(8)));
        a = ((a << 7) | (a >> 25));
        (a = a + b);
        (d = d + (((((b ^ c) & a) ^ c) + (uint32_t)(K->at(9))) + this->buff->at(9)));
        d = ((d << 12) | (d >> 20));
        (d = d + a);
        (c = c + (((((a ^ b) & d) ^ b) + (uint32_t)(K->at(10))) + this->buff->at(10)));
        c = ((c << 17) | (c >> 15));
        (c = c + d);
        (b = b + (((((d ^ a) & c) ^ a) + (uint32_t)(K->at(11))) + this->buff->at(11)));
        b = ((b << 22) | (b >> 10));
        (b = b + c);
        (a = a + (((((c ^ d) & b) ^ d) + (uint32_t)(K->at(12))) + this->buff->at(12)));
        a = ((a << 7) | (a >> 25));
        (a = a + b);
        (d = d + (((((b ^ c) & a) ^ c) + (uint32_t)(K->at(13))) + this->buff->at(13)));
        d = ((d << 12) | (d >> 20));
        (d = d + a);
        (c = c + (((((a ^ b) & d) ^ b) + (uint32_t)(K->at(14))) + this->buff->at(14)));
        c = ((c << 17) | (c >> 15));
        (c = c + d);
        (b = b + (((((d ^ a) & c) ^ a) + (uint32_t)(K->at(15))) + this->buff->at(15)));
        b = ((b << 22) | (b >> 10));
        (b = b + c);
        (a = a + (((((b ^ c) & d) ^ c) + (uint32_t)(K->at(16))) + this->buff->at(1)));
        a = ((a << 5) | (a >> 27));
        (a = a + b);
        (d = d + (((((a ^ b) & c) ^ b) + (uint32_t)(K->at(17))) + this->buff->at(6)));
        d = ((d << 9) | (d >> 23));
        (d = d + a);
        (c = c + (((((d ^ a) & b) ^ a) + (uint32_t)(K->at(18))) + this->buff->at(11)));
        c = ((c << 14) | (c >> 18));
        (c = c + d);
        (b = b + (((((c ^ d) & a) ^ d) + (uint32_t)(K->at(19))) + this->buff->at(0)));
        b = ((b << 20) | (b >> 12));
        (b = b + c);
        (a = a + (((((b ^ c) & d) ^ c) + (uint32_t)(K->at(20))) + this->buff->at(5)));
        a = ((a << 5) | (a >> 27));
        (a = a + b);
        (d = d + (((((a ^ b) & c) ^ b) + (uint32_t)(K->at(21))) + this->buff->at(10)));
        d = ((d << 9) | (d >> 23));
        (d = d + a);
        (c = c + (((((d ^ a) & b) ^ a) + (uint32_t)(K->at(22))) + this->buff->at(15)));
        c = ((c << 14) | (c >> 18));
        (c = c + d);
        (b = b + (((((c ^ d) & a) ^ d) + (uint32_t)(K->at(23))) + this->buff->at(4)));
        b = ((b << 20) | (b >> 12));
        (b = b + c);
        (a = a + (((((b ^ c) & d) ^ c) + (uint32_t)(K->at(24))) + this->buff->at(9)));
        a = ((a << 5) | (a >> 27));
        (a = a + b);
        (d = d + (((((a ^ b) & c) ^ b) + (uint32_t)(K->at(25))) + this->buff->at(14)));
        d = ((d << 9) | (d >> 23));
        (d = d + a);
        (c = c + (((((d ^ a) & b) ^ a) + (uint32_t)(K->at(26))) + this->buff->at(3)));
        c = ((c << 14) | (c >> 18));
        (c = c + d);
        (b = b + (((((c ^ d) & a) ^ d) + (uint32_t)(K->at(27))) + this->buff->at(8)));
        b = ((b << 20) | (b >> 12));
        (b = b + c);
        (a = a + (((((b ^ c) & d) ^ c) + (uint32_t)(K->at(28))) + this->buff->at(13)));
        a = ((a << 5) | (a >> 27));
        (a = a + b);
        (d = d + (((((a ^ b) & c) ^ b) + (uint32_t)(K->at(29))) + this->buff->at(2)));
        d = ((d << 9) | (d >> 23));
        (d = d + a);
        (c = c + (((((d ^ a) & b) ^ a) + (uint32_t)(K->at(30))) + this->buff->at(7)));
        c = ((c << 14) | (c >> 18));
        (c = c + d);
        (b = b + (((((c ^ d) & a) ^ d) + (uint32_t)(K->at(31))) + this->buff->at(12)));
        b = ((b << 20) | (b >> 12));
        (b = b + c);
        (a = a + ((((b ^ c) ^ d) + (uint32_t)(K->at(32))) + this->buff->at(5)));
        a = ((a << 4) | (a >> 28));
        (a = a + b);
        (d = d + ((((a ^ b) ^ c) + (uint32_t)(K->at(33))) + this->buff->at(8)));
        d = ((d << 11) | (d >> 21));
        (d = d + a);
        (c = c + ((((d ^ a) ^ b) + (uint32_t)(K->at(34))) + this->buff->at(11)));
        c = ((c << 16) | (c >> 16));
        (c = c + d);
        (b = b + ((((c ^ d) ^ a) + (uint32_t)(K->at(35))) + this->buff->at(14)));
        b = ((b << 23) | (b >> 9));
        (b = b + c);
        (a = a + ((((b ^ c) ^ d) + (uint32_t)(K->at(36))) + this->buff->at(1)));
        a = ((a << 4) | (a >> 28));
        (a = a + b);
        (d = d + ((((a ^ b) ^ c) + (uint32_t)(K->at(37))) + this->buff->at(4)));
        d = ((d << 11) | (d >> 21));
        (d = d + a);
        (c = c + ((((d ^ a) ^ b) + (uint32_t)(K->at(38))) + this->buff->at(7)));
        c = ((c << 16) | (c >> 16));
        (c = c + d);
        (b = b + ((((c ^ d) ^ a) + (uint32_t)(K->at(39))) + this->buff->at(10)));
        b = ((b << 23) | (b >> 9));
        (b = b + c);
        (a = a + ((((b ^ c) ^ d) + (uint32_t)(K->at(40))) + this->buff->at(13)));
        a = ((a << 4) | (a >> 28));
        (a = a + b);
        (d = d + ((((a ^ b) ^ c) + (uint32_t)(K->at(41))) + this->buff->at(0)));
        d = ((d << 11) | (d >> 21));
        (d = d + a);
        (c = c + ((((d ^ a) ^ b) + (uint32_t)(K->at(42))) + this->buff->at(3)));
        c = ((c << 16) | (c >> 16));
        (c = c + d);
        (b = b + ((((c ^ d) ^ a) + (uint32_t)(K->at(43))) + this->buff->at(6)));
        b = ((b << 23) | (b >> 9));
        (b = b + c);
        (a = a + ((((b ^ c) ^ d) + (uint32_t)(K->at(44))) + this->buff->at(9)));
        a = ((a << 4) | (a >> 28));
        (a = a + b);
        (d = d + ((((a ^ b) ^ c) + (uint32_t)(K->at(45))) + this->buff->at(12)));
        d = ((d << 11) | (d >> 21));
        (d = d + a);
        (c = c + ((((d ^ a) ^ b) + (uint32_t)(K->at(46))) + this->buff->at(15)));
        c = ((c << 16) | (c >> 16));
        (c = c + d);
        (b = b + ((((c ^ d) ^ a) + (uint32_t)(K->at(47))) + this->buff->at(2)));
        b = ((b << 23) | (b >> 9));
        (b = b + c);
        (a = a + ((((~(d) | b) ^ c) + (uint32_t)(K->at(48))) + this->buff->at(0)));
        a = ((a << 6) | (a >> 26));
        (a = a + b);
        (d = d + ((((~(c) | a) ^ b) + (uint32_t)(K->at(49))) + this->buff->at(7)));
        d = ((d << 10) | (d >> 22));
        (d = d + a);
        (c = c + ((((~(b) | d) ^ a) + (uint32_t)(K->at(50))) + this->buff->at(14)));
        c = ((c << 15) | (c >> 17));
        (c = c + d);
        (b = b + ((((~(a) | c) ^ d) + (uint32_t)(K->at(51))) + this->buff->at(5)));
        b = ((b << 21) | (b >> 11));
        (b = b + c);
        (a = a + ((((~(d) | b) ^ c) + (uint32_t)(K->at(52))) + this->buff->at(12)));
        a = ((a << 6) | (a >> 26));
        (a = a + b);
        (d = d + ((((~(c) | a) ^ b) + (uint32_t)(K->at(53))) + this->buff->at(3)));
        d = ((d << 10) | (d >> 22));
        (d = d + a);
        (c = c + ((((~(b) | d) ^ a) + (uint32_t)(K->at(54))) + this->buff->at(10)));
        c = ((c << 15) | (c >> 17));
        (c = c + d);
        (b = b + ((((~(a) | c) ^ d) + (uint32_t)(K->at(55))) + this->buff->at(1)));
        b = ((b << 21) | (b >> 11));
        (b = b + c);
        (a = a + ((((~(d) | b) ^ c) + (uint32_t)(K->at(56))) + this->buff->at(8)));
        a = ((a << 6) | (a >> 26));
        (a = a + b);
        (d = d + ((((~(c) | a) ^ b) + (uint32_t)(K->at(57))) + this->buff->at(15)));
        d = ((d << 10) | (d >> 22));
        (d = d + a);
        (c = c + ((((~(b) | d) ^ a) + (uint32_t)(K->at(58))) + this->buff->at(6)));
        c = ((c << 15) | (c >> 17));
        (c = c + d);
        (b = b + ((((~(a) | c) ^ d) + (uint32_t)(K->at(59))) + this->buff->at(13)));
        b = ((b << 21) | (b >> 11));
        (b = b + c);
        (a = a + ((((~(d) | b) ^ c) + (uint32_t)(K->at(60))) + this->buff->at(4)));
        a = ((a << 6) | (a >> 26));
        (a = a + b);
        (d = d + ((((~(c) | a) ^ b) + (uint32_t)(K->at(61))) + this->buff->at(11)));
        d = ((d << 10) | (d >> 22));
        (d = d + a);
        (c = c + ((((~(b) | d) ^ a) + (uint32_t)(K->at(62))) + this->buff->at(2)));
        c = ((c << 15) | (c >> 17));
        (c = c + d);
        (b = b + ((((~(a) | c) ^ d) + (uint32_t)(K->at(63))) + this->buff->at(9)));
        b = ((b << 21) | (b >> 11));
        (b = b + c);
        (this->_H->at(0) = this->_H->at(0) + a);
        (this->_H->at(1) = this->_H->at(1) + b);
        (this->_H->at(2) = this->_H->at(2) + c);
        (this->_H->at(3) = this->_H->at(3) + d);
    }
    
    void MD5CryptoServiceProvider::ProcessFinalBlock(cli::array<unsigned char>* inputBuffer, int32_t inputOffset, int32_t inputCount) {
        uint64_t total = (this->count + (uint64_t)inputCount);
        int32_t paddingSize = (int32_t)(56UL - (total % 64UL));
        if((paddingSize < 1)) 
        {
            (paddingSize = paddingSize + 64);
        }
        cli::array<unsigned char> *fooBuffer = (new cli::array<unsigned char>(((inputCount + paddingSize) + 8)));
        for(int32_t i = 0; (i < inputCount); i++){
            fooBuffer->at(i) = inputBuffer->at((i + inputOffset));
        }
        fooBuffer->at(inputCount) = 128;
        for(int32_t i = (inputCount + 1); (i < (inputCount + paddingSize)); i++){
            fooBuffer->at(i) = 0;
        }
        uint64_t size = (total << 3);
        AddLength(size, fooBuffer, (inputCount + paddingSize));
        ProcessBlock(fooBuffer, 0);
        if((((inputCount + paddingSize) + 8) ==  128)) 
        {
            ProcessBlock(fooBuffer, 64);
        }
    }
    
    void MD5CryptoServiceProvider::AddLength(uint64_t length, cli::array<unsigned char>* buffer, int32_t position) {
        buffer->at(position++) = (unsigned char)length;
        buffer->at(position++) = (unsigned char)(length >> 8);
        buffer->at(position++) = (unsigned char)(length >> 16);
        buffer->at(position++) = (unsigned char)(length >> 24);
        buffer->at(position++) = (unsigned char)(length >> 32);
        buffer->at(position++) = (unsigned char)(length >> 40);
        buffer->at(position++) = (unsigned char)(length >> 48);
        buffer->at(position) = (unsigned char)(length >> 56);
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    
    void PasswordDeriveBytes::constructor(System::String* strPassword, cli::array<unsigned char>* rgbSalt) {
        Prepare(strPassword, rgbSalt, _T("SHA1"), 100);
    }
    
    void PasswordDeriveBytes::constructor(System::String* strPassword, cli::array<unsigned char>* rgbSalt, CspParameters* cspParams) {
        Prepare(strPassword, rgbSalt, _T("SHA1"), 100);
        if((cspParams != nullptr)) 
        {
            throw cli::gcnew<System::NotSupportedException>(Locale::GetText(_T("CspParameters not supported by Mono for PasswordDeriveBytes.")));
        }
    }
    
    void PasswordDeriveBytes::constructor(System::String* strPassword, cli::array<unsigned char>* rgbSalt, System::String* strHashName, int32_t iterations) {
        Prepare(strPassword, rgbSalt, strHashName, iterations);
    }
    
    void PasswordDeriveBytes::constructor(System::String* strPassword, cli::array<unsigned char>* rgbSalt, System::String* strHashName, int32_t iterations, CspParameters* cspParams) {
        Prepare(strPassword, rgbSalt, strHashName, iterations);
        if((cspParams != nullptr)) 
        {
            throw cli::gcnew<System::NotSupportedException>(Locale::GetText(_T("CspParameters not supported by Mono for PasswordDeriveBytes.")));
        }
    }
    
    void PasswordDeriveBytes::constructor(cli::array<unsigned char>* password, cli::array<unsigned char>* salt) {
        Prepare2(password, salt, _T("SHA1"), 100);
    }
    
    void PasswordDeriveBytes::constructor(cli::array<unsigned char>* password, cli::array<unsigned char>* salt, CspParameters* cspParams) {
        Prepare2(password, salt, _T("SHA1"), 100);
        if((cspParams != nullptr)) 
        {
            throw cli::gcnew<System::NotSupportedException>(Locale::GetText(_T("CspParameters not supported by Mono for PasswordDeriveBytes.")));
        }
    }
    
    void PasswordDeriveBytes::constructor(cli::array<unsigned char>* password, cli::array<unsigned char>* salt, System::String* hashName, int32_t iterations) {
        Prepare2(password, salt, hashName, iterations);
    }
    
    void PasswordDeriveBytes::constructor(cli::array<unsigned char>* password, cli::array<unsigned char>* salt, System::String* hashName, int32_t iterations, CspParameters* cspParams) {
        Prepare2(password, salt, hashName, iterations);
        if((cspParams != nullptr)) 
        {
            throw cli::gcnew<System::NotSupportedException>(Locale::GetText(_T("CspParameters not supported by Mono for PasswordDeriveBytes.")));
        }
    }
    
    void PasswordDeriveBytes::Finalize_9e228aaafe1da17f() {
        {
            cli::finally_guard([&]() {
                Finalize_b946fbc32e26afd6();
            });
            DeriveBytes2::Dispose_803fca5f32415300(false);
        }
    }
    
    void PasswordDeriveBytes::Dispose_803fca5f32415300(bool disposing) {
        if((this->initial != nullptr)) 
        {
            System::Array::Clear2(this->initial, 0, this->initial->get_Length());
            this->initial = nullptr;
        }
        System::Array::Clear2(this->password, 0, this->password->get_Length());
        DeriveBytes2::Dispose_803fca5f32415300(disposing);
    }
    
    void PasswordDeriveBytes::Prepare(System::String* strPassword, cli::array<unsigned char>* rgbSalt, System::String* strHashName, int32_t iterations) {
        if((strPassword ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("strPassword"));
        }
        cli::array<unsigned char> *pwd = System::Text::Encoding::get_UTF8()->GetBytes_49806e8e98b1c1db(strPassword);
        Prepare2(pwd, rgbSalt, strHashName, iterations);
        System::Array::Clear2(pwd, 0, pwd->get_Length());
    }
    
    void PasswordDeriveBytes::Prepare2(cli::array<unsigned char>* password, cli::array<unsigned char>* rgbSalt, System::String* strHashName, int32_t iterations) {
        if((password ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("password"));
        }
        this->password = cli::cast<cli::array<unsigned char>*>(cli::import(password)->Clone());
        this->set_Salt(rgbSalt);
        this->set_HashName(strHashName);
        this->set_IterationCount(iterations);
        this->state = 0;
    }
    
    cli::array<unsigned char>* PasswordDeriveBytes::CryptDeriveKey(System::String* algname, System::String* alghashname, int32_t keySize, cli::array<unsigned char>* rgbIV) {
        if((keySize > 128)) 
        {
            throw cli::gcnew<CryptographicException>(Locale::GetText(_T("Key Size can\'t be greater than 128 bits")));
        }
        throw cli::gcnew<System::NotSupportedException>(Locale::GetText(_T("CspParameters not supported by Mono")));
    }
    
    cli::array<unsigned char>* PasswordDeriveBytes::GetBytes_ad106635b376b402(int32_t cb) {
        if((cb < 1)) 
        {
            throw cli::gcnew<System::IndexOutOfRangeException>(_T("cb"));
        }
        if((this->state ==  0)) 
        {
            PasswordDeriveBytes::Reset_638e8b09d94d54e4();
            this->state = 1;
        }
        cli::array<unsigned char> *result = (new cli::array<unsigned char>(cb));
        int32_t cpos = 0;
        int32_t iter = System::Math::Max5(1, (this->IterationsValue - 1));
        if((this->output ==  nullptr)) 
        {
            this->output = this->initial;
            for(int32_t i = 0; (i < (iter - 1)); i++) {
                this->output = this->hash->ComputeHash(this->output);
            }
        }
        while((cpos < cb)) {
            cli::array<unsigned char> *output2 = nullptr;
            if((this->hashnumber ==  0)) 
            {
                output2 = this->hash->ComputeHash(this->output);
            }
             else 
            {
                if((this->hashnumber < 1000)) 
                {
                    System::String *n = System::Convert::ToString17(this->hashnumber);
                    output2 = (new cli::array<unsigned char>((this->output->get_Length() + n->get_Length())));
                    for(int32_t j = 0; (j < n->get_Length()); j++) {
                        output2->at(j) = (unsigned char)n->get_Chars(j);
                    }
                    System::Buffer::BlockCopy(this->output, 0, output2, n->get_Length(), this->output->get_Length());
                    output2 = this->hash->ComputeHash(output2);
                }
                 else 
                {
                    throw cli::gcnew<CryptographicException>(Locale::GetText(_T("too long")));
                }
            }
            int32_t rem = (output2->get_Length() - this->position);
            int32_t l = System::Math::Min5((cb - cpos), rem);
            System::Buffer::BlockCopy(output2, this->position, result, cpos, l);
            (cpos = cpos + l);
            (this->position = this->position + l);
            while((this->position >= output2->get_Length())) {
                (this->position = this->position - output2->get_Length());
                this->hashnumber++;
            }
        }
        return result;
    }
    
    void PasswordDeriveBytes::Reset_638e8b09d94d54e4() {
        this->state = 0;
        this->position = 0;
        this->hashnumber = 0;
        this->hash = HashAlgorithm::Create2(this->HashNameValue);
        if((this->SaltValue != nullptr)) 
        {
            this->hash->TransformBlock(this->password, 0, this->password->get_Length(), this->password, 0);
            this->hash->TransformFinalBlock(this->SaltValue, 0, this->SaltValue->get_Length());
            this->initial = this->hash->get_Hash_cb65a3f211aa16df();
        }
         else 
        {
            this->initial = this->hash->ComputeHash(this->password);
        }
    }
    
    System::String* PasswordDeriveBytes::get_HashName() {
        return this->HashNameValue;
    }
    
    System::String* PasswordDeriveBytes::set_HashName(System::String* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("HashName"));
        }
        if((this->state != 0)) 
        {
            throw cli::gcnew<CryptographicException>(Locale::GetText(_T("Can\'t change this property at this stage")));
        }
        this->HashNameValue = value;
        return get_HashName();
    }
    
    int32_t PasswordDeriveBytes::get_IterationCount() {
        return this->IterationsValue;
    }
    
    int32_t PasswordDeriveBytes::set_IterationCount(int32_t value) {
        if((value < 1)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("> 0"), _T("IterationCount"));
        }
        if((this->state != 0)) 
        {
            throw cli::gcnew<CryptographicException>(Locale::GetText(_T("Can\'t change this property at this stage")));
        }
        this->IterationsValue = value;
        return get_IterationCount();
    }
    
    cli::array<unsigned char>* PasswordDeriveBytes::get_Salt() {
        if((this->SaltValue ==  nullptr)) 
        {
            return nullptr;
        }
        return cli::cast<cli::array<unsigned char>*>(cli::import(this->SaltValue)->Clone());
    }
    
    cli::array<unsigned char>* PasswordDeriveBytes::set_Salt(cli::array<unsigned char>* value) {
        if((this->state != 0)) 
        {
            throw cli::gcnew<CryptographicException>(Locale::GetText(_T("Can\'t change this property at this stage")));
        }
        if((value != nullptr)) 
        {
            this->SaltValue = cli::cast<cli::array<unsigned char>*>(cli::import(value)->Clone());
        }
         else 
        {
            this->SaltValue = nullptr;
        }
        return get_Salt();
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    
    void PKCS1MaskGenerationMethod::constructor() {
        this->hashName = _T("SHA1");
    }
    
    cli::array<unsigned char>* PKCS1MaskGenerationMethod::GenerateMask_234a8635eaf4eb53(cli::array<unsigned char>* rgbSeed, int32_t cbReturn) {
        HashAlgorithm *hash = HashAlgorithm::Create2(this->hashName);
        return Mono::Security::Cryptography::PKCS1::MGF1(hash, rgbSeed, cbReturn);
    }
    
    System::String* PKCS1MaskGenerationMethod::get_HashName() {
        return this->hashName;
    }
    
    System::String* PKCS1MaskGenerationMethod::set_HashName(System::String* value) {
        this->hashName = (value ==  nullptr) ? _T("SHA1") : value;
        return get_HashName();
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    
    void RandomNumberGenerator::constructor() {
    }
    
    RandomNumberGenerator* RandomNumberGenerator::Create() {
        return Create2(_T("System.Security.Cryptography.RandomNumberGenerator"));
    }
    
    RandomNumberGenerator* RandomNumberGenerator::Create2(System::String* rngName) {
        return cli::cast<RandomNumberGenerator*>(CryptoConfig::CreateFromName(rngName));
    }
    
    void RandomNumberGenerator::Dispose() {
        Dispose_322058ebc1ad4f39(true);
    }
    
    void RandomNumberGenerator::Dispose_322058ebc1ad4f39(bool disposing) {
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    
    void RC2::constructor() {
        this->KeySizeValue = 128;
        this->BlockSizeValue = 64;
        this->FeedbackSizeValue = 8;
        this->LegalKeySizesValue = (new cli::array<KeySizes*>(1));
        this->LegalKeySizesValue->at(0) = cli::gcnew<KeySizes>(40, 128, 8);
        this->LegalBlockSizesValue = (new cli::array<KeySizes*>(1));
        this->LegalBlockSizesValue->at(0) = cli::gcnew<KeySizes>(64, 64, 0);
    }
    
    RC2* RC2::Create3() {
        return Create4(_T("System.Security.Cryptography.RC2"));
    }
    
    RC2* RC2::Create4(System::String* AlgName) {
        return cli::cast<RC2*>(CryptoConfig::CreateFromName(AlgName));
    }
    
    int32_t RC2::get_EffectiveKeySize_5d48beb267b8d37a() {
        if((this->EffectiveKeySizeValue ==  0)) 
        {
            return this->KeySizeValue;
        }
         else 
        {
            return this->EffectiveKeySizeValue;
        }
    }
    
    int32_t RC2::set_EffectiveKeySize_724f57ed7427a770(int32_t value) {
        this->EffectiveKeySizeValue = value;
        return get_EffectiveKeySize_5d48beb267b8d37a();
    }
    
    int32_t RC2::get_KeySize_ec919ce7243c4a9() {
        return SymmetricAlgorithm::get_KeySize_ec919ce7243c4a9();
    }
    
    int32_t RC2::set_KeySize_f5b8ff3d506d2d5a(int32_t value) {
        SymmetricAlgorithm::set_KeySize_f5b8ff3d506d2d5a(value);
        this->EffectiveKeySizeValue = value;
        return get_KeySize_ec919ce7243c4a9();
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    
    void RC2CryptoServiceProvider::constructor() {
    }
    
    ICryptoTransform* RC2CryptoServiceProvider::CreateDecryptor_80e9c787d56cc5d1(cli::array<unsigned char>* rgbKey, cli::array<unsigned char>* rgbIV) {
        return cli::gcnew<RC2Transform>(this, false, rgbKey, rgbIV);
    }
    
    ICryptoTransform* RC2CryptoServiceProvider::CreateEncryptor_5ed1e69e3ba0a86a(cli::array<unsigned char>* rgbKey, cli::array<unsigned char>* rgbIV) {
        return cli::gcnew<RC2Transform>(this, true, rgbKey, rgbIV);
    }
    
    void RC2CryptoServiceProvider::GenerateIV_df3473e2513c2b00() {
        this->IVValue = Mono::Security::Cryptography::KeyBuilder::IV((this->BlockSizeValue >> 3));
    }
    
    void RC2CryptoServiceProvider::GenerateKey_a6a62018358dfc76() {
        this->KeyValue = Mono::Security::Cryptography::KeyBuilder::Key2((this->KeySizeValue >> 3));
    }
    
    int32_t RC2CryptoServiceProvider::get_EffectiveKeySize_5d48beb267b8d37a() {
        return RC2::get_EffectiveKeySize_5d48beb267b8d37a();
    }
    
    int32_t RC2CryptoServiceProvider::set_EffectiveKeySize_724f57ed7427a770(int32_t value) {
        if((value != this->KeySizeValue)) 
        {
            throw cli::gcnew<CryptographicUnexpectedOperationException>(Locale::GetText(_T("Effective key size must match key size for compatibility")));
        }
        RC2::set_EffectiveKeySize_724f57ed7427a770(value);
        return get_EffectiveKeySize_5d48beb267b8d37a();
    }
    
    bool RC2CryptoServiceProvider::get_UseSalt() {
        return this->_useSalt;
    }
    
    bool RC2CryptoServiceProvider::set_UseSalt(bool value) {
        this->_useSalt = value;
        return get_UseSalt();
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    cli::array<unsigned char>*  RC2Transform::pitable;
    
    RC2Transform::RC2Transform()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void RC2Transform::constructor(RC2* rc2Algo, bool encryption, cli::array<unsigned char>* key, cli::array<unsigned char>* iv) {
        int32_t t1 = rc2Algo->get_EffectiveKeySize_5d48beb267b8d37a();
        if((key ==  nullptr)) 
        {
            key = Mono::Security::Cryptography::KeyBuilder::Key2((rc2Algo->get_KeySize_ec919ce7243c4a9() >> 3));
        }
         else 
        {
            key = cli::cast<cli::array<unsigned char>*>(cli::import(key)->Clone());
            t1 = System::Math::Min5(t1, (key->get_Length() << 3));
        }
        int32_t t = key->get_Length();
        if(!(KeySizes::IsLegalKeySize(rc2Algo->get_LegalKeySizes_27644398fdbe9d8(), (t << 3)))) 
        {
            System::String *msg = Locale::GetText2(_T("Key is too small ({0} bytes), it should be between {1} and {2} bytes long."), (new cli::array<System::Object*>({cli::box(t), cli::box(5), cli::box(16)})));
            throw cli::gcnew<CryptographicException>(msg);
        }
        cli::array<unsigned char> *L = (new cli::array<unsigned char>(128));
        int32_t t8 = ((t1 + 7) >> 3);
        int32_t tm = (255 % (2 << ((((8 + t1) - (t8 << 3)) - 1) & 31)));
        for(int32_t i = 0; (i < t); i++) {
            L->at(i) = key->at(i);
        }
        for(int32_t i = t; (i < 128); i++) {
            L->at(i) = (unsigned char)(pitable->at((((int32_t)(L->at((i - 1))) + (int32_t)(L->at((i - t)))) & 255)));
        }
        L->at((128 - t8)) = pitable->at(((int32_t)(L->at((128 - t8))) & tm));
        for(int32_t i = (127 - t8); (i >= 0); i--) {
            L->at(i) = pitable->at(((int32_t)(L->at((i + 1))) ^ (int32_t)(L->at((i + t8)))));
        }
        this->K = (new cli::array<uint16_t>(64));
        int32_t pos = 0;
        for(int32_t i = 0; (i < 64); i++) {
            this->K->at(i) = (uint16_t)((int32_t)(L->at(pos++)) + ((int32_t)(L->at(pos++)) << 8));
        }
    }
    
    void RC2Transform::static_constructor() {
    }
    
    void RC2Transform::ECB_94d714c69347f447(cli::array<unsigned char>* input, cli::array<unsigned char>* output) {
        this->R0 = (uint16_t)((int32_t)(input->at(0)) | ((int32_t)(input->at(1)) << 8));
        this->R1 = (uint16_t)((int32_t)(input->at(2)) | ((int32_t)(input->at(3)) << 8));
        this->R2 = (uint16_t)((int32_t)(input->at(4)) | ((int32_t)(input->at(5)) << 8));
        this->R3 = (uint16_t)((int32_t)(input->at(6)) | ((int32_t)(input->at(7)) << 8));
        if(this->encrypt) 
        {
            this->j = 0;
            while((this->j <= 16)) {
                (this->R0 = (uint16_t)((int32_t)(this->R0) + (int32_t)((uint16_t)(((int32_t)(this->K->at(this->j++)) + ((int32_t)(this->R3) & (int32_t)(this->R2))) + (~((int32_t)(this->R3)) & (int32_t)(this->R1))))));
                this->R0 = (uint16_t)(((int32_t)(this->R0) << 1) | ((int32_t)(this->R0) >> 15));
                (this->R1 = (uint16_t)((int32_t)(this->R1) + (int32_t)((uint16_t)(((int32_t)(this->K->at(this->j++)) + ((int32_t)(this->R0) & (int32_t)(this->R3))) + (~((int32_t)(this->R0)) & (int32_t)(this->R2))))));
                this->R1 = (uint16_t)(((int32_t)(this->R1) << 2) | ((int32_t)(this->R1) >> 14));
                (this->R2 = (uint16_t)((int32_t)(this->R2) + (int32_t)((uint16_t)(((int32_t)(this->K->at(this->j++)) + ((int32_t)(this->R1) & (int32_t)(this->R0))) + (~((int32_t)(this->R1)) & (int32_t)(this->R3))))));
                this->R2 = (uint16_t)(((int32_t)(this->R2) << 3) | ((int32_t)(this->R2) >> 13));
                (this->R3 = (uint16_t)((int32_t)(this->R3) + (int32_t)((uint16_t)(((int32_t)(this->K->at(this->j++)) + ((int32_t)(this->R2) & (int32_t)(this->R1))) + (~((int32_t)(this->R2)) & (int32_t)(this->R0))))));
                this->R3 = (uint16_t)(((int32_t)(this->R3) << 5) | ((int32_t)(this->R3) >> 11));
            }
            (this->R0 = (uint16_t)((int32_t)(this->R0) + (int32_t)(this->K->at(((int32_t)(this->R3) & 63)))));
            (this->R1 = (uint16_t)((int32_t)(this->R1) + (int32_t)(this->K->at(((int32_t)(this->R0) & 63)))));
            (this->R2 = (uint16_t)((int32_t)(this->R2) + (int32_t)(this->K->at(((int32_t)(this->R1) & 63)))));
            (this->R3 = (uint16_t)((int32_t)(this->R3) + (int32_t)(this->K->at(((int32_t)(this->R2) & 63)))));
            while((this->j <= 40)) {
                (this->R0 = (uint16_t)((int32_t)(this->R0) + (int32_t)((uint16_t)(((int32_t)(this->K->at(this->j++)) + ((int32_t)(this->R3) & (int32_t)(this->R2))) + (~((int32_t)(this->R3)) & (int32_t)(this->R1))))));
                this->R0 = (uint16_t)(((int32_t)(this->R0) << 1) | ((int32_t)(this->R0) >> 15));
                (this->R1 = (uint16_t)((int32_t)(this->R1) + (int32_t)((uint16_t)(((int32_t)(this->K->at(this->j++)) + ((int32_t)(this->R0) & (int32_t)(this->R3))) + (~((int32_t)(this->R0)) & (int32_t)(this->R2))))));
                this->R1 = (uint16_t)(((int32_t)(this->R1) << 2) | ((int32_t)(this->R1) >> 14));
                (this->R2 = (uint16_t)((int32_t)(this->R2) + (int32_t)((uint16_t)(((int32_t)(this->K->at(this->j++)) + ((int32_t)(this->R1) & (int32_t)(this->R0))) + (~((int32_t)(this->R1)) & (int32_t)(this->R3))))));
                this->R2 = (uint16_t)(((int32_t)(this->R2) << 3) | ((int32_t)(this->R2) >> 13));
                (this->R3 = (uint16_t)((int32_t)(this->R3) + (int32_t)((uint16_t)(((int32_t)(this->K->at(this->j++)) + ((int32_t)(this->R2) & (int32_t)(this->R1))) + (~((int32_t)(this->R2)) & (int32_t)(this->R0))))));
                this->R3 = (uint16_t)(((int32_t)(this->R3) << 5) | ((int32_t)(this->R3) >> 11));
            }
            (this->R0 = (uint16_t)((int32_t)(this->R0) + (int32_t)(this->K->at(((int32_t)(this->R3) & 63)))));
            (this->R1 = (uint16_t)((int32_t)(this->R1) + (int32_t)(this->K->at(((int32_t)(this->R0) & 63)))));
            (this->R2 = (uint16_t)((int32_t)(this->R2) + (int32_t)(this->K->at(((int32_t)(this->R1) & 63)))));
            (this->R3 = (uint16_t)((int32_t)(this->R3) + (int32_t)(this->K->at(((int32_t)(this->R2) & 63)))));
            while((this->j < 64)) {
                (this->R0 = (uint16_t)((int32_t)(this->R0) + (int32_t)((uint16_t)(((int32_t)(this->K->at(this->j++)) + ((int32_t)(this->R3) & (int32_t)(this->R2))) + (~((int32_t)(this->R3)) & (int32_t)(this->R1))))));
                this->R0 = (uint16_t)(((int32_t)(this->R0) << 1) | ((int32_t)(this->R0) >> 15));
                (this->R1 = (uint16_t)((int32_t)(this->R1) + (int32_t)((uint16_t)(((int32_t)(this->K->at(this->j++)) + ((int32_t)(this->R0) & (int32_t)(this->R3))) + (~((int32_t)(this->R0)) & (int32_t)(this->R2))))));
                this->R1 = (uint16_t)(((int32_t)(this->R1) << 2) | ((int32_t)(this->R1) >> 14));
                (this->R2 = (uint16_t)((int32_t)(this->R2) + (int32_t)((uint16_t)(((int32_t)(this->K->at(this->j++)) + ((int32_t)(this->R1) & (int32_t)(this->R0))) + (~((int32_t)(this->R1)) & (int32_t)(this->R3))))));
                this->R2 = (uint16_t)(((int32_t)(this->R2) << 3) | ((int32_t)(this->R2) >> 13));
                (this->R3 = (uint16_t)((int32_t)(this->R3) + (int32_t)((uint16_t)(((int32_t)(this->K->at(this->j++)) + ((int32_t)(this->R2) & (int32_t)(this->R1))) + (~((int32_t)(this->R2)) & (int32_t)(this->R0))))));
                this->R3 = (uint16_t)(((int32_t)(this->R3) << 5) | ((int32_t)(this->R3) >> 11));
            }
        }
         else 
        {
            this->j = 63;
            while((this->j >= 44)) {
                this->R3 = (uint16_t)(((int32_t)(this->R3) >> 5) | ((int32_t)(this->R3) << 11));
                (this->R3 = (uint16_t)((int32_t)(this->R3) - (int32_t)((uint16_t)(((int32_t)(this->K->at(this->j--)) + ((int32_t)(this->R2) & (int32_t)(this->R1))) + (~((int32_t)(this->R2)) & (int32_t)(this->R0))))));
                this->R2 = (uint16_t)(((int32_t)(this->R2) >> 3) | ((int32_t)(this->R2) << 13));
                (this->R2 = (uint16_t)((int32_t)(this->R2) - (int32_t)((uint16_t)(((int32_t)(this->K->at(this->j--)) + ((int32_t)(this->R1) & (int32_t)(this->R0))) + (~((int32_t)(this->R1)) & (int32_t)(this->R3))))));
                this->R1 = (uint16_t)(((int32_t)(this->R1) >> 2) | ((int32_t)(this->R1) << 14));
                (this->R1 = (uint16_t)((int32_t)(this->R1) - (int32_t)((uint16_t)(((int32_t)(this->K->at(this->j--)) + ((int32_t)(this->R0) & (int32_t)(this->R3))) + (~((int32_t)(this->R0)) & (int32_t)(this->R2))))));
                this->R0 = (uint16_t)(((int32_t)(this->R0) >> 1) | ((int32_t)(this->R0) << 15));
                (this->R0 = (uint16_t)((int32_t)(this->R0) - (int32_t)((uint16_t)(((int32_t)(this->K->at(this->j--)) + ((int32_t)(this->R3) & (int32_t)(this->R2))) + (~((int32_t)(this->R3)) & (int32_t)(this->R1))))));
            }
            (this->R3 = (uint16_t)((int32_t)(this->R3) - (int32_t)(this->K->at(((int32_t)(this->R2) & 63)))));
            (this->R2 = (uint16_t)((int32_t)(this->R2) - (int32_t)(this->K->at(((int32_t)(this->R1) & 63)))));
            (this->R1 = (uint16_t)((int32_t)(this->R1) - (int32_t)(this->K->at(((int32_t)(this->R0) & 63)))));
            (this->R0 = (uint16_t)((int32_t)(this->R0) - (int32_t)(this->K->at(((int32_t)(this->R3) & 63)))));
            while((this->j >= 20)) {
                this->R3 = (uint16_t)(((int32_t)(this->R3) >> 5) | ((int32_t)(this->R3) << 11));
                (this->R3 = (uint16_t)((int32_t)(this->R3) - (int32_t)((uint16_t)(((int32_t)(this->K->at(this->j--)) + ((int32_t)(this->R2) & (int32_t)(this->R1))) + (~((int32_t)(this->R2)) & (int32_t)(this->R0))))));
                this->R2 = (uint16_t)(((int32_t)(this->R2) >> 3) | ((int32_t)(this->R2) << 13));
                (this->R2 = (uint16_t)((int32_t)(this->R2) - (int32_t)((uint16_t)(((int32_t)(this->K->at(this->j--)) + ((int32_t)(this->R1) & (int32_t)(this->R0))) + (~((int32_t)(this->R1)) & (int32_t)(this->R3))))));
                this->R1 = (uint16_t)(((int32_t)(this->R1) >> 2) | ((int32_t)(this->R1) << 14));
                (this->R1 = (uint16_t)((int32_t)(this->R1) - (int32_t)((uint16_t)(((int32_t)(this->K->at(this->j--)) + ((int32_t)(this->R0) & (int32_t)(this->R3))) + (~((int32_t)(this->R0)) & (int32_t)(this->R2))))));
                this->R0 = (uint16_t)(((int32_t)(this->R0) >> 1) | ((int32_t)(this->R0) << 15));
                (this->R0 = (uint16_t)((int32_t)(this->R0) - (int32_t)((uint16_t)(((int32_t)(this->K->at(this->j--)) + ((int32_t)(this->R3) & (int32_t)(this->R2))) + (~((int32_t)(this->R3)) & (int32_t)(this->R1))))));
            }
            (this->R3 = (uint16_t)((int32_t)(this->R3) - (int32_t)(this->K->at(((int32_t)(this->R2) & 63)))));
            (this->R2 = (uint16_t)((int32_t)(this->R2) - (int32_t)(this->K->at(((int32_t)(this->R1) & 63)))));
            (this->R1 = (uint16_t)((int32_t)(this->R1) - (int32_t)(this->K->at(((int32_t)(this->R0) & 63)))));
            (this->R0 = (uint16_t)((int32_t)(this->R0) - (int32_t)(this->K->at(((int32_t)(this->R3) & 63)))));
            while((this->j >= 0)) {
                this->R3 = (uint16_t)(((int32_t)(this->R3) >> 5) | ((int32_t)(this->R3) << 11));
                (this->R3 = (uint16_t)((int32_t)(this->R3) - (int32_t)((uint16_t)(((int32_t)(this->K->at(this->j--)) + ((int32_t)(this->R2) & (int32_t)(this->R1))) + (~((int32_t)(this->R2)) & (int32_t)(this->R0))))));
                this->R2 = (uint16_t)(((int32_t)(this->R2) >> 3) | ((int32_t)(this->R2) << 13));
                (this->R2 = (uint16_t)((int32_t)(this->R2) - (int32_t)((uint16_t)(((int32_t)(this->K->at(this->j--)) + ((int32_t)(this->R1) & (int32_t)(this->R0))) + (~((int32_t)(this->R1)) & (int32_t)(this->R3))))));
                this->R1 = (uint16_t)(((int32_t)(this->R1) >> 2) | ((int32_t)(this->R1) << 14));
                (this->R1 = (uint16_t)((int32_t)(this->R1) - (int32_t)((uint16_t)(((int32_t)(this->K->at(this->j--)) + ((int32_t)(this->R0) & (int32_t)(this->R3))) + (~((int32_t)(this->R0)) & (int32_t)(this->R2))))));
                this->R0 = (uint16_t)(((int32_t)(this->R0) >> 1) | ((int32_t)(this->R0) << 15));
                (this->R0 = (uint16_t)((int32_t)(this->R0) - (int32_t)((uint16_t)(((int32_t)(this->K->at(this->j--)) + ((int32_t)(this->R3) & (int32_t)(this->R2))) + (~((int32_t)(this->R3)) & (int32_t)(this->R1))))));
            }
        }
        output->at(0) = (unsigned char)this->R0;
        output->at(1) = (unsigned char)((int32_t)(this->R0) >> 8);
        output->at(2) = (unsigned char)this->R1;
        output->at(3) = (unsigned char)((int32_t)(this->R1) >> 8);
        output->at(4) = (unsigned char)this->R2;
        output->at(5) = (unsigned char)((int32_t)(this->R2) >> 8);
        output->at(6) = (unsigned char)this->R3;
        output->at(7) = (unsigned char)((int32_t)(this->R3) >> 8);
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    
    void Rfc2898DeriveBytes::constructor(System::String* password, cli::array<unsigned char>* salt) {
    }
    
    void Rfc2898DeriveBytes::constructor(System::String* password, cli::array<unsigned char>* salt, int32_t iterations) {
        if((password ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("password"));
        }
        this->set_Salt(salt);
        this->set_IterationCount(iterations);
        this->_hmac = cli::gcnew<HMACSHA1>(System::Text::Encoding::get_UTF8()->GetBytes_49806e8e98b1c1db(password));
    }
    
    void Rfc2898DeriveBytes::constructor(cli::array<unsigned char>* password, cli::array<unsigned char>* salt, int32_t iterations) {
        if((password ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("password"));
        }
        this->set_Salt(salt);
        this->set_IterationCount(iterations);
        this->_hmac = cli::gcnew<HMACSHA1>(password);
    }
    
    void Rfc2898DeriveBytes::constructor(System::String* password, int32_t saltSize) {
    }
    
    void Rfc2898DeriveBytes::constructor(System::String* password, int32_t saltSize, int32_t iterations) {
        if((password ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("password"));
        }
        if((saltSize < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("invalid salt length"));
        }
        this->set_Salt(Mono::Security::Cryptography::KeyBuilder::Key2(saltSize));
        this->set_IterationCount(iterations);
        this->_hmac = cli::gcnew<HMACSHA1>(System::Text::Encoding::get_UTF8()->GetBytes_49806e8e98b1c1db(password));
    }
    
    cli::array<unsigned char>* Rfc2898DeriveBytes::F(cli::array<unsigned char>* s, int32_t c, int32_t i) {
        s->at((s->get_Length() - 4)) = (unsigned char)(i >> 24);
        s->at((s->get_Length() - 3)) = (unsigned char)(i >> 16);
        s->at((s->get_Length() - 2)) = (unsigned char)(i >> 8);
        s->at((s->get_Length() - 1)) = (unsigned char)i;
        cli::array<unsigned char> *u1 = this->_hmac->ComputeHash(s);
        cli::array<unsigned char> *data = u1;
        for(int32_t j = 1; (j < c); j++){
            cli::array<unsigned char> *un = this->_hmac->ComputeHash(data);
            for(int32_t k = 0; (k < 20); k++) {
                u1->at(k) = (unsigned char)((int32_t)(u1->at(k)) ^ (int32_t)(un->at(k)));
            }
            data = un;
        }
        return u1;
    }
    
    cli::array<unsigned char>* Rfc2898DeriveBytes::GetBytes_ad106635b376b402(int32_t cb) {
        if((cb < 1)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("cb"));
        }
        int32_t l = (cb / 20);
        int32_t r = (cb % 20);
        if((r != 0)) 
        {
            l++;
        }
        cli::array<unsigned char> *result = (new cli::array<unsigned char>(cb));
        int32_t rpos = 0;
        if((this->_pos > 0)) 
        {
            int32_t count = System::Math::Min5((20 - this->_pos), cb);
            System::Buffer::BlockCopy(this->_buffer, this->_pos, result, 0, count);
            if((count >= cb)) 
            {
                return result;
            }
            if(((((l - 1) * 20) + count) > result->get_Length())) 
            {
                l--;
            }
            this->_pos = 0;
            rpos = count;
        }
        cli::array<unsigned char> *data = (new cli::array<unsigned char>((this->_salt->get_Length() + 4)));
        System::Buffer::BlockCopy(this->_salt, 0, data, 0, this->_salt->get_Length());
        for(int32_t i = 1; (i <= l); i++){
            this->_buffer = F(data, this->_iteration, ++this->_f);
            int32_t count = (i ==  l) ? (result->get_Length() - rpos) : 20;
            System::Buffer::BlockCopy(this->_buffer, this->_pos, result, rpos, count);
            (rpos = rpos + (this->_pos + count));
            this->_pos = (count ==  20) ? 0 : count;
        }
        return result;
    }
    
    void Rfc2898DeriveBytes::Reset_638e8b09d94d54e4() {
        this->_buffer = nullptr;
        this->_pos = 0;
        this->_f = 0;
    }
    
    void Rfc2898DeriveBytes::Dispose_803fca5f32415300(bool disposing) {
        System::Array::Clear2(this->_buffer, 0, this->_buffer->get_Length());
        System::Array::Clear2(this->_salt, 0, this->_salt->get_Length());
        this->_hmac->Clear();
        DeriveBytes2::Dispose_803fca5f32415300(disposing);
    }
    
    int32_t Rfc2898DeriveBytes::get_IterationCount() {
        return this->_iteration;
    }
    
    int32_t Rfc2898DeriveBytes::set_IterationCount(int32_t value) {
        if((value < 1)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("IterationCount < 1"));
        }
        this->_iteration = value;
        return get_IterationCount();
    }
    
    cli::array<unsigned char>* Rfc2898DeriveBytes::get_Salt() {
        return cli::cast<cli::array<unsigned char>*>(cli::import(this->_salt)->Clone());
    }
    
    cli::array<unsigned char>* Rfc2898DeriveBytes::set_Salt(cli::array<unsigned char>* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("Salt"));
        }
        if((value->get_Length() < 8)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Salt < 8 bytes"));
        }
        this->_salt = cli::cast<cli::array<unsigned char>*>(cli::import(value)->Clone());
        return get_Salt();
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    
    void Rijndael::constructor() {
        this->KeySizeValue = 256;
        this->BlockSizeValue = 128;
        this->FeedbackSizeValue = 128;
        this->LegalKeySizesValue = (new cli::array<KeySizes*>(1));
        this->LegalKeySizesValue->at(0) = cli::gcnew<KeySizes>(128, 256, 64);
        this->LegalBlockSizesValue = (new cli::array<KeySizes*>(1));
        this->LegalBlockSizesValue->at(0) = cli::gcnew<KeySizes>(128, 256, 64);
    }
    
    Rijndael* Rijndael::Create3() {
        return Create4(_T("System.Security.Cryptography.Rijndael"));
    }
    
    Rijndael* Rijndael::Create4(System::String* algName) {
        return cli::cast<Rijndael*>(CryptoConfig::CreateFromName(algName));
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    
    void RijndaelManaged::constructor() {
    }
    
    void RijndaelManaged::GenerateIV_df3473e2513c2b00() {
        this->IVValue = Mono::Security::Cryptography::KeyBuilder::IV((this->BlockSizeValue >> 3));
    }
    
    void RijndaelManaged::GenerateKey_a6a62018358dfc76() {
        this->KeyValue = Mono::Security::Cryptography::KeyBuilder::Key2((this->KeySizeValue >> 3));
    }
    
    ICryptoTransform* RijndaelManaged::CreateDecryptor_80e9c787d56cc5d1(cli::array<unsigned char>* rgbKey, cli::array<unsigned char>* rgbIV) {
        return cli::gcnew<RijndaelManagedTransform>(this, false, rgbKey, rgbIV);
    }
    
    ICryptoTransform* RijndaelManaged::CreateEncryptor_5ed1e69e3ba0a86a(cli::array<unsigned char>* rgbKey, cli::array<unsigned char>* rgbIV) {
        return cli::gcnew<RijndaelManagedTransform>(this, true, rgbKey, rgbIV);
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    cli::array<uint32_t>*  RijndaelTransform::Rcon;
    cli::array<unsigned char>*  RijndaelTransform::SBox;
    cli::array<unsigned char>*  RijndaelTransform::iSBox;
    cli::array<uint32_t>*  RijndaelTransform::T0;
    cli::array<uint32_t>*  RijndaelTransform::T1;
    cli::array<uint32_t>*  RijndaelTransform::T2;
    cli::array<uint32_t>*  RijndaelTransform::T3;
    cli::array<uint32_t>*  RijndaelTransform::iT0;
    cli::array<uint32_t>*  RijndaelTransform::iT1;
    cli::array<uint32_t>*  RijndaelTransform::iT2;
    cli::array<uint32_t>*  RijndaelTransform::iT3;
    
    RijndaelTransform::RijndaelTransform()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void RijndaelTransform::constructor(Rijndael* algo, bool encryption, cli::array<unsigned char>* key, cli::array<unsigned char>* iv) {
        if((key ==  nullptr)) 
        {
            throw cli::gcnew<CryptographicException>(_T("key is null"));
        }
        if(((iv != nullptr) && (iv->get_Length() != (algo->get_BlockSize_7a5a96e8187bef27() >> 3)))) 
        {
            System::String *msg = Locale::GetText2(_T("IV length is invalid ({0} bytes), it should be {1} bytes long."), (new cli::array<System::Object*>({cli::box(iv->get_Length()), cli::box((algo->get_BlockSize_7a5a96e8187bef27() >> 3))})));
            throw cli::gcnew<CryptographicException>(msg);
        }
        int32_t keySize = key->get_Length();
        if((((keySize != 16) && (keySize != 24)) && (keySize != 32))) 
        {
            System::String *msg = Locale::GetText2(_T("Key is too small ({0} bytes), it should be {1}, {2} or {3} bytes long."), (new cli::array<System::Object*>({cli::box(keySize), cli::box(16), cli::box(24), cli::box(32)})));
            throw cli::gcnew<CryptographicException>(msg);
        }
        (keySize = keySize << 3);
        int32_t blockSize = algo->get_BlockSize_7a5a96e8187bef27();
        this->Nb = (blockSize >> 5);
        this->Nk = (keySize >> 5);
        if(((this->Nb ==  8) || (this->Nk ==  8))) 
        {
            this->Nr = 14;
        }
         else 
        {
            if(((this->Nb ==  6) || (this->Nk ==  6))) 
            {
                this->Nr = 12;
            }
             else 
            {
                this->Nr = 10;
            }
        }
        int32_t exKeySize = (this->Nb * (this->Nr + 1));
        cli::array<uint32_t> *exKey = (new cli::array<uint32_t>(exKeySize));
        int32_t pos = 0;
        for(int32_t i = 0; (i < this->Nk); i++){
            uint32_t value = ((uint32_t)(key->at(pos++)) << 24);
            (value = value | ((uint32_t)(key->at(pos++)) << 16));
            (value = value | ((uint32_t)(key->at(pos++)) << 8));
            (value = value | (uint32_t)(key->at(pos++)));
            exKey->at(i) = value;
        }
        for(int32_t i = this->Nk; (i < exKeySize); i++){
            uint32_t temp = exKey->at((i - 1));
            if(((i % this->Nk) ==  0)) 
            {
                uint32_t rot = (uint32_t)(((temp << 8) | ((temp >> 24) & 255U)));
                temp = (SubByte(rot) ^ Rcon->at((i / this->Nk)));
            }
             else 
            {
                if(((this->Nk > 6) && ((i % this->Nk) ==  4))) 
                {
                    temp = SubByte(temp);
                }
            }
            exKey->at(i) = (exKey->at((i - this->Nk)) ^ temp);
        }
        if((!(encryption) && (((int32_t)(algo->get_Mode_248883f5619349b8()) ==  2) || ((int32_t)(algo->get_Mode_248883f5619349b8()) ==  1)))) 
        {
            for(int32_t i = 0, k = (exKeySize - this->Nb); (i < k); (i = i + this->Nb), (k = k - this->Nb)){
                for(int32_t j = 0; (j < this->Nb); j++){
                    uint32_t temp = exKey->at((i + j));
                    exKey->at((i + j)) = exKey->at((k + j));
                    exKey->at((k + j)) = temp;
                }
            }
            for(int32_t i = this->Nb; (i < (exKey->get_Length() - this->Nb)); i++){
                exKey->at(i) = (((iT0->at((int32_t)(SBox->at((int32_t)(exKey->at(i) >> 24)))) ^ iT1->at((int32_t)(SBox->at((int32_t)((unsigned char)(exKey->at(i) >> 16)))))) ^ iT2->at((int32_t)(SBox->at((int32_t)((unsigned char)(exKey->at(i) >> 8)))))) ^ iT3->at((int32_t)(SBox->at((int32_t)((unsigned char)exKey->at(i))))));
            }
        }
        this->expandedKey = exKey;
    }
    
    void RijndaelTransform::static_constructor() {
    }
    
    void RijndaelTransform::Clear() {
        Mono::Security::Cryptography::SymmetricTransform::Dispose_c0fd0d8ff386db0d(true);
    }
    
    void RijndaelTransform::ECB_94d714c69347f447(cli::array<unsigned char>* input, cli::array<unsigned char>* output) {
        if(this->encrypt) 
        {
            switch(this->Nb) {
                case 4: case_1663: {
                    Encrypt128(input, output, this->expandedKey);
                    return;
                }
                case 6: case_1664: {
                    Encrypt192(input, output, this->expandedKey);
                    return;
                }
                case 8: case_1665: {
                    Encrypt256(input, output, this->expandedKey);
                    return;
                }
            }
        }
         else 
        {
            switch(this->Nb) {
                case 4: case_1666: {
                    Decrypt128(input, output, this->expandedKey);
                    return;
                }
                case 6: case_1667: {
                    Decrypt192(input, output, this->expandedKey);
                    return;
                }
                case 8: case_1668: {
                    Decrypt256(input, output, this->expandedKey);
                    return;
                }
            }
        }
    }
    
    uint32_t RijndaelTransform::SubByte(uint32_t a) {
        uint32_t value = (255U & a);
        uint32_t result = (uint32_t)(SBox->at((int32_t)value));
        value = (255U & (a >> 8));
        (result = result | ((uint32_t)(SBox->at((int32_t)value)) << 8));
        value = (255U & (a >> 16));
        (result = result | ((uint32_t)(SBox->at((int32_t)value)) << 16));
        value = (255U & (a >> 24));
        return (result | (uint32_t)((int32_t)(SBox->at((int32_t)value)) << 24));
    }
    
    void RijndaelTransform::Encrypt128(cli::array<unsigned char>* indata, cli::array<unsigned char>* outdata, cli::array<uint32_t>* ekey) {
        uint32_t a0, a1, a2, a3, b0, b1, b2, b3;
        int32_t ei = 40;
        a0 = ((((((uint32_t)(indata->at(0)) << 24) | ((uint32_t)(indata->at(1)) << 16)) | ((uint32_t)(indata->at(2)) << 8)) | (uint32_t)(indata->at(3))) ^ ekey->at(0));
        a1 = ((((((uint32_t)(indata->at(4)) << 24) | ((uint32_t)(indata->at(5)) << 16)) | ((uint32_t)(indata->at(6)) << 8)) | (uint32_t)(indata->at(7))) ^ ekey->at(1));
        a2 = ((((((uint32_t)(indata->at(8)) << 24) | ((uint32_t)(indata->at(9)) << 16)) | ((uint32_t)(indata->at(10)) << 8)) | (uint32_t)(indata->at(11))) ^ ekey->at(2));
        a3 = ((((((uint32_t)(indata->at(12)) << 24) | ((uint32_t)(indata->at(13)) << 16)) | ((uint32_t)(indata->at(14)) << 8)) | (uint32_t)(indata->at(15))) ^ ekey->at(3));
        b0 = ((((T0->at((int32_t)(a0 >> 24)) ^ T1->at((int32_t)((unsigned char)(a1 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a2 >> 8)))) ^ T3->at((int32_t)((unsigned char)a3))) ^ ekey->at(4));
        b1 = ((((T0->at((int32_t)(a1 >> 24)) ^ T1->at((int32_t)((unsigned char)(a2 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a3 >> 8)))) ^ T3->at((int32_t)((unsigned char)a0))) ^ ekey->at(5));
        b2 = ((((T0->at((int32_t)(a2 >> 24)) ^ T1->at((int32_t)((unsigned char)(a3 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a0 >> 8)))) ^ T3->at((int32_t)((unsigned char)a1))) ^ ekey->at(6));
        b3 = ((((T0->at((int32_t)(a3 >> 24)) ^ T1->at((int32_t)((unsigned char)(a0 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a1 >> 8)))) ^ T3->at((int32_t)((unsigned char)a2))) ^ ekey->at(7));
        a0 = ((((T0->at((int32_t)(b0 >> 24)) ^ T1->at((int32_t)((unsigned char)(b1 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b2 >> 8)))) ^ T3->at((int32_t)((unsigned char)b3))) ^ ekey->at(8));
        a1 = ((((T0->at((int32_t)(b1 >> 24)) ^ T1->at((int32_t)((unsigned char)(b2 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b3 >> 8)))) ^ T3->at((int32_t)((unsigned char)b0))) ^ ekey->at(9));
        a2 = ((((T0->at((int32_t)(b2 >> 24)) ^ T1->at((int32_t)((unsigned char)(b3 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b0 >> 8)))) ^ T3->at((int32_t)((unsigned char)b1))) ^ ekey->at(10));
        a3 = ((((T0->at((int32_t)(b3 >> 24)) ^ T1->at((int32_t)((unsigned char)(b0 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b1 >> 8)))) ^ T3->at((int32_t)((unsigned char)b2))) ^ ekey->at(11));
        b0 = ((((T0->at((int32_t)(a0 >> 24)) ^ T1->at((int32_t)((unsigned char)(a1 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a2 >> 8)))) ^ T3->at((int32_t)((unsigned char)a3))) ^ ekey->at(12));
        b1 = ((((T0->at((int32_t)(a1 >> 24)) ^ T1->at((int32_t)((unsigned char)(a2 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a3 >> 8)))) ^ T3->at((int32_t)((unsigned char)a0))) ^ ekey->at(13));
        b2 = ((((T0->at((int32_t)(a2 >> 24)) ^ T1->at((int32_t)((unsigned char)(a3 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a0 >> 8)))) ^ T3->at((int32_t)((unsigned char)a1))) ^ ekey->at(14));
        b3 = ((((T0->at((int32_t)(a3 >> 24)) ^ T1->at((int32_t)((unsigned char)(a0 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a1 >> 8)))) ^ T3->at((int32_t)((unsigned char)a2))) ^ ekey->at(15));
        a0 = ((((T0->at((int32_t)(b0 >> 24)) ^ T1->at((int32_t)((unsigned char)(b1 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b2 >> 8)))) ^ T3->at((int32_t)((unsigned char)b3))) ^ ekey->at(16));
        a1 = ((((T0->at((int32_t)(b1 >> 24)) ^ T1->at((int32_t)((unsigned char)(b2 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b3 >> 8)))) ^ T3->at((int32_t)((unsigned char)b0))) ^ ekey->at(17));
        a2 = ((((T0->at((int32_t)(b2 >> 24)) ^ T1->at((int32_t)((unsigned char)(b3 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b0 >> 8)))) ^ T3->at((int32_t)((unsigned char)b1))) ^ ekey->at(18));
        a3 = ((((T0->at((int32_t)(b3 >> 24)) ^ T1->at((int32_t)((unsigned char)(b0 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b1 >> 8)))) ^ T3->at((int32_t)((unsigned char)b2))) ^ ekey->at(19));
        b0 = ((((T0->at((int32_t)(a0 >> 24)) ^ T1->at((int32_t)((unsigned char)(a1 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a2 >> 8)))) ^ T3->at((int32_t)((unsigned char)a3))) ^ ekey->at(20));
        b1 = ((((T0->at((int32_t)(a1 >> 24)) ^ T1->at((int32_t)((unsigned char)(a2 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a3 >> 8)))) ^ T3->at((int32_t)((unsigned char)a0))) ^ ekey->at(21));
        b2 = ((((T0->at((int32_t)(a2 >> 24)) ^ T1->at((int32_t)((unsigned char)(a3 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a0 >> 8)))) ^ T3->at((int32_t)((unsigned char)a1))) ^ ekey->at(22));
        b3 = ((((T0->at((int32_t)(a3 >> 24)) ^ T1->at((int32_t)((unsigned char)(a0 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a1 >> 8)))) ^ T3->at((int32_t)((unsigned char)a2))) ^ ekey->at(23));
        a0 = ((((T0->at((int32_t)(b0 >> 24)) ^ T1->at((int32_t)((unsigned char)(b1 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b2 >> 8)))) ^ T3->at((int32_t)((unsigned char)b3))) ^ ekey->at(24));
        a1 = ((((T0->at((int32_t)(b1 >> 24)) ^ T1->at((int32_t)((unsigned char)(b2 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b3 >> 8)))) ^ T3->at((int32_t)((unsigned char)b0))) ^ ekey->at(25));
        a2 = ((((T0->at((int32_t)(b2 >> 24)) ^ T1->at((int32_t)((unsigned char)(b3 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b0 >> 8)))) ^ T3->at((int32_t)((unsigned char)b1))) ^ ekey->at(26));
        a3 = ((((T0->at((int32_t)(b3 >> 24)) ^ T1->at((int32_t)((unsigned char)(b0 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b1 >> 8)))) ^ T3->at((int32_t)((unsigned char)b2))) ^ ekey->at(27));
        b0 = ((((T0->at((int32_t)(a0 >> 24)) ^ T1->at((int32_t)((unsigned char)(a1 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a2 >> 8)))) ^ T3->at((int32_t)((unsigned char)a3))) ^ ekey->at(28));
        b1 = ((((T0->at((int32_t)(a1 >> 24)) ^ T1->at((int32_t)((unsigned char)(a2 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a3 >> 8)))) ^ T3->at((int32_t)((unsigned char)a0))) ^ ekey->at(29));
        b2 = ((((T0->at((int32_t)(a2 >> 24)) ^ T1->at((int32_t)((unsigned char)(a3 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a0 >> 8)))) ^ T3->at((int32_t)((unsigned char)a1))) ^ ekey->at(30));
        b3 = ((((T0->at((int32_t)(a3 >> 24)) ^ T1->at((int32_t)((unsigned char)(a0 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a1 >> 8)))) ^ T3->at((int32_t)((unsigned char)a2))) ^ ekey->at(31));
        a0 = ((((T0->at((int32_t)(b0 >> 24)) ^ T1->at((int32_t)((unsigned char)(b1 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b2 >> 8)))) ^ T3->at((int32_t)((unsigned char)b3))) ^ ekey->at(32));
        a1 = ((((T0->at((int32_t)(b1 >> 24)) ^ T1->at((int32_t)((unsigned char)(b2 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b3 >> 8)))) ^ T3->at((int32_t)((unsigned char)b0))) ^ ekey->at(33));
        a2 = ((((T0->at((int32_t)(b2 >> 24)) ^ T1->at((int32_t)((unsigned char)(b3 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b0 >> 8)))) ^ T3->at((int32_t)((unsigned char)b1))) ^ ekey->at(34));
        a3 = ((((T0->at((int32_t)(b3 >> 24)) ^ T1->at((int32_t)((unsigned char)(b0 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b1 >> 8)))) ^ T3->at((int32_t)((unsigned char)b2))) ^ ekey->at(35));
        b0 = ((((T0->at((int32_t)(a0 >> 24)) ^ T1->at((int32_t)((unsigned char)(a1 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a2 >> 8)))) ^ T3->at((int32_t)((unsigned char)a3))) ^ ekey->at(36));
        b1 = ((((T0->at((int32_t)(a1 >> 24)) ^ T1->at((int32_t)((unsigned char)(a2 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a3 >> 8)))) ^ T3->at((int32_t)((unsigned char)a0))) ^ ekey->at(37));
        b2 = ((((T0->at((int32_t)(a2 >> 24)) ^ T1->at((int32_t)((unsigned char)(a3 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a0 >> 8)))) ^ T3->at((int32_t)((unsigned char)a1))) ^ ekey->at(38));
        b3 = ((((T0->at((int32_t)(a3 >> 24)) ^ T1->at((int32_t)((unsigned char)(a0 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a1 >> 8)))) ^ T3->at((int32_t)((unsigned char)a2))) ^ ekey->at(39));
        if((this->Nr > 10)) 
        {
            a0 = ((((T0->at((int32_t)(b0 >> 24)) ^ T1->at((int32_t)((unsigned char)(b1 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b2 >> 8)))) ^ T3->at((int32_t)((unsigned char)b3))) ^ ekey->at(40));
            a1 = ((((T0->at((int32_t)(b1 >> 24)) ^ T1->at((int32_t)((unsigned char)(b2 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b3 >> 8)))) ^ T3->at((int32_t)((unsigned char)b0))) ^ ekey->at(41));
            a2 = ((((T0->at((int32_t)(b2 >> 24)) ^ T1->at((int32_t)((unsigned char)(b3 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b0 >> 8)))) ^ T3->at((int32_t)((unsigned char)b1))) ^ ekey->at(42));
            a3 = ((((T0->at((int32_t)(b3 >> 24)) ^ T1->at((int32_t)((unsigned char)(b0 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b1 >> 8)))) ^ T3->at((int32_t)((unsigned char)b2))) ^ ekey->at(43));
            b0 = ((((T0->at((int32_t)(a0 >> 24)) ^ T1->at((int32_t)((unsigned char)(a1 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a2 >> 8)))) ^ T3->at((int32_t)((unsigned char)a3))) ^ ekey->at(44));
            b1 = ((((T0->at((int32_t)(a1 >> 24)) ^ T1->at((int32_t)((unsigned char)(a2 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a3 >> 8)))) ^ T3->at((int32_t)((unsigned char)a0))) ^ ekey->at(45));
            b2 = ((((T0->at((int32_t)(a2 >> 24)) ^ T1->at((int32_t)((unsigned char)(a3 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a0 >> 8)))) ^ T3->at((int32_t)((unsigned char)a1))) ^ ekey->at(46));
            b3 = ((((T0->at((int32_t)(a3 >> 24)) ^ T1->at((int32_t)((unsigned char)(a0 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a1 >> 8)))) ^ T3->at((int32_t)((unsigned char)a2))) ^ ekey->at(47));
            ei = 48;
            if((this->Nr > 12)) 
            {
                a0 = ((((T0->at((int32_t)(b0 >> 24)) ^ T1->at((int32_t)((unsigned char)(b1 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b2 >> 8)))) ^ T3->at((int32_t)((unsigned char)b3))) ^ ekey->at(48));
                a1 = ((((T0->at((int32_t)(b1 >> 24)) ^ T1->at((int32_t)((unsigned char)(b2 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b3 >> 8)))) ^ T3->at((int32_t)((unsigned char)b0))) ^ ekey->at(49));
                a2 = ((((T0->at((int32_t)(b2 >> 24)) ^ T1->at((int32_t)((unsigned char)(b3 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b0 >> 8)))) ^ T3->at((int32_t)((unsigned char)b1))) ^ ekey->at(50));
                a3 = ((((T0->at((int32_t)(b3 >> 24)) ^ T1->at((int32_t)((unsigned char)(b0 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b1 >> 8)))) ^ T3->at((int32_t)((unsigned char)b2))) ^ ekey->at(51));
                b0 = ((((T0->at((int32_t)(a0 >> 24)) ^ T1->at((int32_t)((unsigned char)(a1 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a2 >> 8)))) ^ T3->at((int32_t)((unsigned char)a3))) ^ ekey->at(52));
                b1 = ((((T0->at((int32_t)(a1 >> 24)) ^ T1->at((int32_t)((unsigned char)(a2 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a3 >> 8)))) ^ T3->at((int32_t)((unsigned char)a0))) ^ ekey->at(53));
                b2 = ((((T0->at((int32_t)(a2 >> 24)) ^ T1->at((int32_t)((unsigned char)(a3 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a0 >> 8)))) ^ T3->at((int32_t)((unsigned char)a1))) ^ ekey->at(54));
                b3 = ((((T0->at((int32_t)(a3 >> 24)) ^ T1->at((int32_t)((unsigned char)(a0 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a1 >> 8)))) ^ T3->at((int32_t)((unsigned char)a2))) ^ ekey->at(55));
                ei = 56;
            }
        }
        outdata->at(0) = (unsigned char)((int32_t)(SBox->at((int32_t)(b0 >> 24))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 24)));
        outdata->at(1) = (unsigned char)((int32_t)(SBox->at((int32_t)((unsigned char)(b1 >> 16)))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 16)));
        outdata->at(2) = (unsigned char)((int32_t)(SBox->at((int32_t)((unsigned char)(b2 >> 8)))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 8)));
        outdata->at(3) = (unsigned char)((int32_t)(SBox->at((int32_t)((unsigned char)b3))) ^ (int32_t)((unsigned char)ekey->at(ei++)));
        outdata->at(4) = (unsigned char)((int32_t)(SBox->at((int32_t)(b1 >> 24))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 24)));
        outdata->at(5) = (unsigned char)((int32_t)(SBox->at((int32_t)((unsigned char)(b2 >> 16)))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 16)));
        outdata->at(6) = (unsigned char)((int32_t)(SBox->at((int32_t)((unsigned char)(b3 >> 8)))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 8)));
        outdata->at(7) = (unsigned char)((int32_t)(SBox->at((int32_t)((unsigned char)b0))) ^ (int32_t)((unsigned char)ekey->at(ei++)));
        outdata->at(8) = (unsigned char)((int32_t)(SBox->at((int32_t)(b2 >> 24))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 24)));
        outdata->at(9) = (unsigned char)((int32_t)(SBox->at((int32_t)((unsigned char)(b3 >> 16)))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 16)));
        outdata->at(10) = (unsigned char)((int32_t)(SBox->at((int32_t)((unsigned char)(b0 >> 8)))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 8)));
        outdata->at(11) = (unsigned char)((int32_t)(SBox->at((int32_t)((unsigned char)b1))) ^ (int32_t)((unsigned char)ekey->at(ei++)));
        outdata->at(12) = (unsigned char)((int32_t)(SBox->at((int32_t)(b3 >> 24))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 24)));
        outdata->at(13) = (unsigned char)((int32_t)(SBox->at((int32_t)((unsigned char)(b0 >> 16)))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 16)));
        outdata->at(14) = (unsigned char)((int32_t)(SBox->at((int32_t)((unsigned char)(b1 >> 8)))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 8)));
        outdata->at(15) = (unsigned char)((int32_t)(SBox->at((int32_t)((unsigned char)b2))) ^ (int32_t)((unsigned char)ekey->at(ei++)));
    }
    
    void RijndaelTransform::Encrypt192(cli::array<unsigned char>* indata, cli::array<unsigned char>* outdata, cli::array<uint32_t>* ekey) {
        uint32_t a0, a1, a2, a3, a4, a5, b0, b1, b2, b3, b4, b5;
        int32_t ei = 72;
        a0 = ((((((uint32_t)(indata->at(0)) << 24) | ((uint32_t)(indata->at(1)) << 16)) | ((uint32_t)(indata->at(2)) << 8)) | (uint32_t)(indata->at(3))) ^ ekey->at(0));
        a1 = ((((((uint32_t)(indata->at(4)) << 24) | ((uint32_t)(indata->at(5)) << 16)) | ((uint32_t)(indata->at(6)) << 8)) | (uint32_t)(indata->at(7))) ^ ekey->at(1));
        a2 = ((((((uint32_t)(indata->at(8)) << 24) | ((uint32_t)(indata->at(9)) << 16)) | ((uint32_t)(indata->at(10)) << 8)) | (uint32_t)(indata->at(11))) ^ ekey->at(2));
        a3 = ((((((uint32_t)(indata->at(12)) << 24) | ((uint32_t)(indata->at(13)) << 16)) | ((uint32_t)(indata->at(14)) << 8)) | (uint32_t)(indata->at(15))) ^ ekey->at(3));
        a4 = ((((((uint32_t)(indata->at(16)) << 24) | ((uint32_t)(indata->at(17)) << 16)) | ((uint32_t)(indata->at(18)) << 8)) | (uint32_t)(indata->at(19))) ^ ekey->at(4));
        a5 = ((((((uint32_t)(indata->at(20)) << 24) | ((uint32_t)(indata->at(21)) << 16)) | ((uint32_t)(indata->at(22)) << 8)) | (uint32_t)(indata->at(23))) ^ ekey->at(5));
        b0 = ((((T0->at((int32_t)(a0 >> 24)) ^ T1->at((int32_t)((unsigned char)(a1 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a2 >> 8)))) ^ T3->at((int32_t)((unsigned char)a3))) ^ ekey->at(6));
        b1 = ((((T0->at((int32_t)(a1 >> 24)) ^ T1->at((int32_t)((unsigned char)(a2 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a3 >> 8)))) ^ T3->at((int32_t)((unsigned char)a4))) ^ ekey->at(7));
        b2 = ((((T0->at((int32_t)(a2 >> 24)) ^ T1->at((int32_t)((unsigned char)(a3 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a4 >> 8)))) ^ T3->at((int32_t)((unsigned char)a5))) ^ ekey->at(8));
        b3 = ((((T0->at((int32_t)(a3 >> 24)) ^ T1->at((int32_t)((unsigned char)(a4 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a5 >> 8)))) ^ T3->at((int32_t)((unsigned char)a0))) ^ ekey->at(9));
        b4 = ((((T0->at((int32_t)(a4 >> 24)) ^ T1->at((int32_t)((unsigned char)(a5 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a0 >> 8)))) ^ T3->at((int32_t)((unsigned char)a1))) ^ ekey->at(10));
        b5 = ((((T0->at((int32_t)(a5 >> 24)) ^ T1->at((int32_t)((unsigned char)(a0 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a1 >> 8)))) ^ T3->at((int32_t)((unsigned char)a2))) ^ ekey->at(11));
        a0 = ((((T0->at((int32_t)(b0 >> 24)) ^ T1->at((int32_t)((unsigned char)(b1 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b2 >> 8)))) ^ T3->at((int32_t)((unsigned char)b3))) ^ ekey->at(12));
        a1 = ((((T0->at((int32_t)(b1 >> 24)) ^ T1->at((int32_t)((unsigned char)(b2 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b3 >> 8)))) ^ T3->at((int32_t)((unsigned char)b4))) ^ ekey->at(13));
        a2 = ((((T0->at((int32_t)(b2 >> 24)) ^ T1->at((int32_t)((unsigned char)(b3 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b4 >> 8)))) ^ T3->at((int32_t)((unsigned char)b5))) ^ ekey->at(14));
        a3 = ((((T0->at((int32_t)(b3 >> 24)) ^ T1->at((int32_t)((unsigned char)(b4 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b5 >> 8)))) ^ T3->at((int32_t)((unsigned char)b0))) ^ ekey->at(15));
        a4 = ((((T0->at((int32_t)(b4 >> 24)) ^ T1->at((int32_t)((unsigned char)(b5 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b0 >> 8)))) ^ T3->at((int32_t)((unsigned char)b1))) ^ ekey->at(16));
        a5 = ((((T0->at((int32_t)(b5 >> 24)) ^ T1->at((int32_t)((unsigned char)(b0 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b1 >> 8)))) ^ T3->at((int32_t)((unsigned char)b2))) ^ ekey->at(17));
        b0 = ((((T0->at((int32_t)(a0 >> 24)) ^ T1->at((int32_t)((unsigned char)(a1 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a2 >> 8)))) ^ T3->at((int32_t)((unsigned char)a3))) ^ ekey->at(18));
        b1 = ((((T0->at((int32_t)(a1 >> 24)) ^ T1->at((int32_t)((unsigned char)(a2 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a3 >> 8)))) ^ T3->at((int32_t)((unsigned char)a4))) ^ ekey->at(19));
        b2 = ((((T0->at((int32_t)(a2 >> 24)) ^ T1->at((int32_t)((unsigned char)(a3 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a4 >> 8)))) ^ T3->at((int32_t)((unsigned char)a5))) ^ ekey->at(20));
        b3 = ((((T0->at((int32_t)(a3 >> 24)) ^ T1->at((int32_t)((unsigned char)(a4 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a5 >> 8)))) ^ T3->at((int32_t)((unsigned char)a0))) ^ ekey->at(21));
        b4 = ((((T0->at((int32_t)(a4 >> 24)) ^ T1->at((int32_t)((unsigned char)(a5 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a0 >> 8)))) ^ T3->at((int32_t)((unsigned char)a1))) ^ ekey->at(22));
        b5 = ((((T0->at((int32_t)(a5 >> 24)) ^ T1->at((int32_t)((unsigned char)(a0 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a1 >> 8)))) ^ T3->at((int32_t)((unsigned char)a2))) ^ ekey->at(23));
        a0 = ((((T0->at((int32_t)(b0 >> 24)) ^ T1->at((int32_t)((unsigned char)(b1 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b2 >> 8)))) ^ T3->at((int32_t)((unsigned char)b3))) ^ ekey->at(24));
        a1 = ((((T0->at((int32_t)(b1 >> 24)) ^ T1->at((int32_t)((unsigned char)(b2 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b3 >> 8)))) ^ T3->at((int32_t)((unsigned char)b4))) ^ ekey->at(25));
        a2 = ((((T0->at((int32_t)(b2 >> 24)) ^ T1->at((int32_t)((unsigned char)(b3 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b4 >> 8)))) ^ T3->at((int32_t)((unsigned char)b5))) ^ ekey->at(26));
        a3 = ((((T0->at((int32_t)(b3 >> 24)) ^ T1->at((int32_t)((unsigned char)(b4 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b5 >> 8)))) ^ T3->at((int32_t)((unsigned char)b0))) ^ ekey->at(27));
        a4 = ((((T0->at((int32_t)(b4 >> 24)) ^ T1->at((int32_t)((unsigned char)(b5 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b0 >> 8)))) ^ T3->at((int32_t)((unsigned char)b1))) ^ ekey->at(28));
        a5 = ((((T0->at((int32_t)(b5 >> 24)) ^ T1->at((int32_t)((unsigned char)(b0 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b1 >> 8)))) ^ T3->at((int32_t)((unsigned char)b2))) ^ ekey->at(29));
        b0 = ((((T0->at((int32_t)(a0 >> 24)) ^ T1->at((int32_t)((unsigned char)(a1 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a2 >> 8)))) ^ T3->at((int32_t)((unsigned char)a3))) ^ ekey->at(30));
        b1 = ((((T0->at((int32_t)(a1 >> 24)) ^ T1->at((int32_t)((unsigned char)(a2 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a3 >> 8)))) ^ T3->at((int32_t)((unsigned char)a4))) ^ ekey->at(31));
        b2 = ((((T0->at((int32_t)(a2 >> 24)) ^ T1->at((int32_t)((unsigned char)(a3 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a4 >> 8)))) ^ T3->at((int32_t)((unsigned char)a5))) ^ ekey->at(32));
        b3 = ((((T0->at((int32_t)(a3 >> 24)) ^ T1->at((int32_t)((unsigned char)(a4 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a5 >> 8)))) ^ T3->at((int32_t)((unsigned char)a0))) ^ ekey->at(33));
        b4 = ((((T0->at((int32_t)(a4 >> 24)) ^ T1->at((int32_t)((unsigned char)(a5 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a0 >> 8)))) ^ T3->at((int32_t)((unsigned char)a1))) ^ ekey->at(34));
        b5 = ((((T0->at((int32_t)(a5 >> 24)) ^ T1->at((int32_t)((unsigned char)(a0 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a1 >> 8)))) ^ T3->at((int32_t)((unsigned char)a2))) ^ ekey->at(35));
        a0 = ((((T0->at((int32_t)(b0 >> 24)) ^ T1->at((int32_t)((unsigned char)(b1 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b2 >> 8)))) ^ T3->at((int32_t)((unsigned char)b3))) ^ ekey->at(36));
        a1 = ((((T0->at((int32_t)(b1 >> 24)) ^ T1->at((int32_t)((unsigned char)(b2 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b3 >> 8)))) ^ T3->at((int32_t)((unsigned char)b4))) ^ ekey->at(37));
        a2 = ((((T0->at((int32_t)(b2 >> 24)) ^ T1->at((int32_t)((unsigned char)(b3 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b4 >> 8)))) ^ T3->at((int32_t)((unsigned char)b5))) ^ ekey->at(38));
        a3 = ((((T0->at((int32_t)(b3 >> 24)) ^ T1->at((int32_t)((unsigned char)(b4 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b5 >> 8)))) ^ T3->at((int32_t)((unsigned char)b0))) ^ ekey->at(39));
        a4 = ((((T0->at((int32_t)(b4 >> 24)) ^ T1->at((int32_t)((unsigned char)(b5 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b0 >> 8)))) ^ T3->at((int32_t)((unsigned char)b1))) ^ ekey->at(40));
        a5 = ((((T0->at((int32_t)(b5 >> 24)) ^ T1->at((int32_t)((unsigned char)(b0 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b1 >> 8)))) ^ T3->at((int32_t)((unsigned char)b2))) ^ ekey->at(41));
        b0 = ((((T0->at((int32_t)(a0 >> 24)) ^ T1->at((int32_t)((unsigned char)(a1 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a2 >> 8)))) ^ T3->at((int32_t)((unsigned char)a3))) ^ ekey->at(42));
        b1 = ((((T0->at((int32_t)(a1 >> 24)) ^ T1->at((int32_t)((unsigned char)(a2 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a3 >> 8)))) ^ T3->at((int32_t)((unsigned char)a4))) ^ ekey->at(43));
        b2 = ((((T0->at((int32_t)(a2 >> 24)) ^ T1->at((int32_t)((unsigned char)(a3 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a4 >> 8)))) ^ T3->at((int32_t)((unsigned char)a5))) ^ ekey->at(44));
        b3 = ((((T0->at((int32_t)(a3 >> 24)) ^ T1->at((int32_t)((unsigned char)(a4 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a5 >> 8)))) ^ T3->at((int32_t)((unsigned char)a0))) ^ ekey->at(45));
        b4 = ((((T0->at((int32_t)(a4 >> 24)) ^ T1->at((int32_t)((unsigned char)(a5 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a0 >> 8)))) ^ T3->at((int32_t)((unsigned char)a1))) ^ ekey->at(46));
        b5 = ((((T0->at((int32_t)(a5 >> 24)) ^ T1->at((int32_t)((unsigned char)(a0 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a1 >> 8)))) ^ T3->at((int32_t)((unsigned char)a2))) ^ ekey->at(47));
        a0 = ((((T0->at((int32_t)(b0 >> 24)) ^ T1->at((int32_t)((unsigned char)(b1 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b2 >> 8)))) ^ T3->at((int32_t)((unsigned char)b3))) ^ ekey->at(48));
        a1 = ((((T0->at((int32_t)(b1 >> 24)) ^ T1->at((int32_t)((unsigned char)(b2 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b3 >> 8)))) ^ T3->at((int32_t)((unsigned char)b4))) ^ ekey->at(49));
        a2 = ((((T0->at((int32_t)(b2 >> 24)) ^ T1->at((int32_t)((unsigned char)(b3 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b4 >> 8)))) ^ T3->at((int32_t)((unsigned char)b5))) ^ ekey->at(50));
        a3 = ((((T0->at((int32_t)(b3 >> 24)) ^ T1->at((int32_t)((unsigned char)(b4 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b5 >> 8)))) ^ T3->at((int32_t)((unsigned char)b0))) ^ ekey->at(51));
        a4 = ((((T0->at((int32_t)(b4 >> 24)) ^ T1->at((int32_t)((unsigned char)(b5 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b0 >> 8)))) ^ T3->at((int32_t)((unsigned char)b1))) ^ ekey->at(52));
        a5 = ((((T0->at((int32_t)(b5 >> 24)) ^ T1->at((int32_t)((unsigned char)(b0 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b1 >> 8)))) ^ T3->at((int32_t)((unsigned char)b2))) ^ ekey->at(53));
        b0 = ((((T0->at((int32_t)(a0 >> 24)) ^ T1->at((int32_t)((unsigned char)(a1 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a2 >> 8)))) ^ T3->at((int32_t)((unsigned char)a3))) ^ ekey->at(54));
        b1 = ((((T0->at((int32_t)(a1 >> 24)) ^ T1->at((int32_t)((unsigned char)(a2 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a3 >> 8)))) ^ T3->at((int32_t)((unsigned char)a4))) ^ ekey->at(55));
        b2 = ((((T0->at((int32_t)(a2 >> 24)) ^ T1->at((int32_t)((unsigned char)(a3 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a4 >> 8)))) ^ T3->at((int32_t)((unsigned char)a5))) ^ ekey->at(56));
        b3 = ((((T0->at((int32_t)(a3 >> 24)) ^ T1->at((int32_t)((unsigned char)(a4 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a5 >> 8)))) ^ T3->at((int32_t)((unsigned char)a0))) ^ ekey->at(57));
        b4 = ((((T0->at((int32_t)(a4 >> 24)) ^ T1->at((int32_t)((unsigned char)(a5 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a0 >> 8)))) ^ T3->at((int32_t)((unsigned char)a1))) ^ ekey->at(58));
        b5 = ((((T0->at((int32_t)(a5 >> 24)) ^ T1->at((int32_t)((unsigned char)(a0 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a1 >> 8)))) ^ T3->at((int32_t)((unsigned char)a2))) ^ ekey->at(59));
        a0 = ((((T0->at((int32_t)(b0 >> 24)) ^ T1->at((int32_t)((unsigned char)(b1 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b2 >> 8)))) ^ T3->at((int32_t)((unsigned char)b3))) ^ ekey->at(60));
        a1 = ((((T0->at((int32_t)(b1 >> 24)) ^ T1->at((int32_t)((unsigned char)(b2 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b3 >> 8)))) ^ T3->at((int32_t)((unsigned char)b4))) ^ ekey->at(61));
        a2 = ((((T0->at((int32_t)(b2 >> 24)) ^ T1->at((int32_t)((unsigned char)(b3 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b4 >> 8)))) ^ T3->at((int32_t)((unsigned char)b5))) ^ ekey->at(62));
        a3 = ((((T0->at((int32_t)(b3 >> 24)) ^ T1->at((int32_t)((unsigned char)(b4 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b5 >> 8)))) ^ T3->at((int32_t)((unsigned char)b0))) ^ ekey->at(63));
        a4 = ((((T0->at((int32_t)(b4 >> 24)) ^ T1->at((int32_t)((unsigned char)(b5 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b0 >> 8)))) ^ T3->at((int32_t)((unsigned char)b1))) ^ ekey->at(64));
        a5 = ((((T0->at((int32_t)(b5 >> 24)) ^ T1->at((int32_t)((unsigned char)(b0 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b1 >> 8)))) ^ T3->at((int32_t)((unsigned char)b2))) ^ ekey->at(65));
        b0 = ((((T0->at((int32_t)(a0 >> 24)) ^ T1->at((int32_t)((unsigned char)(a1 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a2 >> 8)))) ^ T3->at((int32_t)((unsigned char)a3))) ^ ekey->at(66));
        b1 = ((((T0->at((int32_t)(a1 >> 24)) ^ T1->at((int32_t)((unsigned char)(a2 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a3 >> 8)))) ^ T3->at((int32_t)((unsigned char)a4))) ^ ekey->at(67));
        b2 = ((((T0->at((int32_t)(a2 >> 24)) ^ T1->at((int32_t)((unsigned char)(a3 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a4 >> 8)))) ^ T3->at((int32_t)((unsigned char)a5))) ^ ekey->at(68));
        b3 = ((((T0->at((int32_t)(a3 >> 24)) ^ T1->at((int32_t)((unsigned char)(a4 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a5 >> 8)))) ^ T3->at((int32_t)((unsigned char)a0))) ^ ekey->at(69));
        b4 = ((((T0->at((int32_t)(a4 >> 24)) ^ T1->at((int32_t)((unsigned char)(a5 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a0 >> 8)))) ^ T3->at((int32_t)((unsigned char)a1))) ^ ekey->at(70));
        b5 = ((((T0->at((int32_t)(a5 >> 24)) ^ T1->at((int32_t)((unsigned char)(a0 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a1 >> 8)))) ^ T3->at((int32_t)((unsigned char)a2))) ^ ekey->at(71));
        if((this->Nr > 12)) 
        {
            a0 = ((((T0->at((int32_t)(b0 >> 24)) ^ T1->at((int32_t)((unsigned char)(b1 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b2 >> 8)))) ^ T3->at((int32_t)((unsigned char)b3))) ^ ekey->at(72));
            a1 = ((((T0->at((int32_t)(b1 >> 24)) ^ T1->at((int32_t)((unsigned char)(b2 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b3 >> 8)))) ^ T3->at((int32_t)((unsigned char)b4))) ^ ekey->at(73));
            a2 = ((((T0->at((int32_t)(b2 >> 24)) ^ T1->at((int32_t)((unsigned char)(b3 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b4 >> 8)))) ^ T3->at((int32_t)((unsigned char)b5))) ^ ekey->at(74));
            a3 = ((((T0->at((int32_t)(b3 >> 24)) ^ T1->at((int32_t)((unsigned char)(b4 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b5 >> 8)))) ^ T3->at((int32_t)((unsigned char)b0))) ^ ekey->at(75));
            a4 = ((((T0->at((int32_t)(b4 >> 24)) ^ T1->at((int32_t)((unsigned char)(b5 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b0 >> 8)))) ^ T3->at((int32_t)((unsigned char)b1))) ^ ekey->at(76));
            a5 = ((((T0->at((int32_t)(b5 >> 24)) ^ T1->at((int32_t)((unsigned char)(b0 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b1 >> 8)))) ^ T3->at((int32_t)((unsigned char)b2))) ^ ekey->at(77));
            b0 = ((((T0->at((int32_t)(a0 >> 24)) ^ T1->at((int32_t)((unsigned char)(a1 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a2 >> 8)))) ^ T3->at((int32_t)((unsigned char)a3))) ^ ekey->at(78));
            b1 = ((((T0->at((int32_t)(a1 >> 24)) ^ T1->at((int32_t)((unsigned char)(a2 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a3 >> 8)))) ^ T3->at((int32_t)((unsigned char)a4))) ^ ekey->at(79));
            b2 = ((((T0->at((int32_t)(a2 >> 24)) ^ T1->at((int32_t)((unsigned char)(a3 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a4 >> 8)))) ^ T3->at((int32_t)((unsigned char)a5))) ^ ekey->at(80));
            b3 = ((((T0->at((int32_t)(a3 >> 24)) ^ T1->at((int32_t)((unsigned char)(a4 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a5 >> 8)))) ^ T3->at((int32_t)((unsigned char)a0))) ^ ekey->at(81));
            b4 = ((((T0->at((int32_t)(a4 >> 24)) ^ T1->at((int32_t)((unsigned char)(a5 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a0 >> 8)))) ^ T3->at((int32_t)((unsigned char)a1))) ^ ekey->at(82));
            b5 = ((((T0->at((int32_t)(a5 >> 24)) ^ T1->at((int32_t)((unsigned char)(a0 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a1 >> 8)))) ^ T3->at((int32_t)((unsigned char)a2))) ^ ekey->at(83));
            ei = 84;
        }
        outdata->at(0) = (unsigned char)((int32_t)(SBox->at((int32_t)(b0 >> 24))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 24)));
        outdata->at(1) = (unsigned char)((int32_t)(SBox->at((int32_t)((unsigned char)(b1 >> 16)))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 16)));
        outdata->at(2) = (unsigned char)((int32_t)(SBox->at((int32_t)((unsigned char)(b2 >> 8)))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 8)));
        outdata->at(3) = (unsigned char)((int32_t)(SBox->at((int32_t)((unsigned char)b3))) ^ (int32_t)((unsigned char)ekey->at(ei++)));
        outdata->at(4) = (unsigned char)((int32_t)(SBox->at((int32_t)(b1 >> 24))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 24)));
        outdata->at(5) = (unsigned char)((int32_t)(SBox->at((int32_t)((unsigned char)(b2 >> 16)))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 16)));
        outdata->at(6) = (unsigned char)((int32_t)(SBox->at((int32_t)((unsigned char)(b3 >> 8)))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 8)));
        outdata->at(7) = (unsigned char)((int32_t)(SBox->at((int32_t)((unsigned char)b4))) ^ (int32_t)((unsigned char)ekey->at(ei++)));
        outdata->at(8) = (unsigned char)((int32_t)(SBox->at((int32_t)(b2 >> 24))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 24)));
        outdata->at(9) = (unsigned char)((int32_t)(SBox->at((int32_t)((unsigned char)(b3 >> 16)))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 16)));
        outdata->at(10) = (unsigned char)((int32_t)(SBox->at((int32_t)((unsigned char)(b4 >> 8)))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 8)));
        outdata->at(11) = (unsigned char)((int32_t)(SBox->at((int32_t)((unsigned char)b5))) ^ (int32_t)((unsigned char)ekey->at(ei++)));
        outdata->at(12) = (unsigned char)((int32_t)(SBox->at((int32_t)(b3 >> 24))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 24)));
        outdata->at(13) = (unsigned char)((int32_t)(SBox->at((int32_t)((unsigned char)(b4 >> 16)))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 16)));
        outdata->at(14) = (unsigned char)((int32_t)(SBox->at((int32_t)((unsigned char)(b5 >> 8)))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 8)));
        outdata->at(15) = (unsigned char)((int32_t)(SBox->at((int32_t)((unsigned char)b0))) ^ (int32_t)((unsigned char)ekey->at(ei++)));
        outdata->at(16) = (unsigned char)((int32_t)(SBox->at((int32_t)(b4 >> 24))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 24)));
        outdata->at(17) = (unsigned char)((int32_t)(SBox->at((int32_t)((unsigned char)(b5 >> 16)))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 16)));
        outdata->at(18) = (unsigned char)((int32_t)(SBox->at((int32_t)((unsigned char)(b0 >> 8)))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 8)));
        outdata->at(19) = (unsigned char)((int32_t)(SBox->at((int32_t)((unsigned char)b1))) ^ (int32_t)((unsigned char)ekey->at(ei++)));
        outdata->at(20) = (unsigned char)((int32_t)(SBox->at((int32_t)(b5 >> 24))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 24)));
        outdata->at(21) = (unsigned char)((int32_t)(SBox->at((int32_t)((unsigned char)(b0 >> 16)))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 16)));
        outdata->at(22) = (unsigned char)((int32_t)(SBox->at((int32_t)((unsigned char)(b1 >> 8)))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 8)));
        outdata->at(23) = (unsigned char)((int32_t)(SBox->at((int32_t)((unsigned char)b2))) ^ (int32_t)((unsigned char)ekey->at(ei++)));
    }
    
    void RijndaelTransform::Encrypt256(cli::array<unsigned char>* indata, cli::array<unsigned char>* outdata, cli::array<uint32_t>* ekey) {
        uint32_t a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7;
        a0 = ((((((uint32_t)(indata->at(0)) << 24) | ((uint32_t)(indata->at(1)) << 16)) | ((uint32_t)(indata->at(2)) << 8)) | (uint32_t)(indata->at(3))) ^ ekey->at(0));
        a1 = ((((((uint32_t)(indata->at(4)) << 24) | ((uint32_t)(indata->at(5)) << 16)) | ((uint32_t)(indata->at(6)) << 8)) | (uint32_t)(indata->at(7))) ^ ekey->at(1));
        a2 = ((((((uint32_t)(indata->at(8)) << 24) | ((uint32_t)(indata->at(9)) << 16)) | ((uint32_t)(indata->at(10)) << 8)) | (uint32_t)(indata->at(11))) ^ ekey->at(2));
        a3 = ((((((uint32_t)(indata->at(12)) << 24) | ((uint32_t)(indata->at(13)) << 16)) | ((uint32_t)(indata->at(14)) << 8)) | (uint32_t)(indata->at(15))) ^ ekey->at(3));
        a4 = ((((((uint32_t)(indata->at(16)) << 24) | ((uint32_t)(indata->at(17)) << 16)) | ((uint32_t)(indata->at(18)) << 8)) | (uint32_t)(indata->at(19))) ^ ekey->at(4));
        a5 = ((((((uint32_t)(indata->at(20)) << 24) | ((uint32_t)(indata->at(21)) << 16)) | ((uint32_t)(indata->at(22)) << 8)) | (uint32_t)(indata->at(23))) ^ ekey->at(5));
        a6 = ((((((uint32_t)(indata->at(24)) << 24) | ((uint32_t)(indata->at(25)) << 16)) | ((uint32_t)(indata->at(26)) << 8)) | (uint32_t)(indata->at(27))) ^ ekey->at(6));
        a7 = ((((((uint32_t)(indata->at(28)) << 24) | ((uint32_t)(indata->at(29)) << 16)) | ((uint32_t)(indata->at(30)) << 8)) | (uint32_t)(indata->at(31))) ^ ekey->at(7));
        b0 = ((((T0->at((int32_t)(a0 >> 24)) ^ T1->at((int32_t)((unsigned char)(a1 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a3 >> 8)))) ^ T3->at((int32_t)((unsigned char)a4))) ^ ekey->at(8));
        b1 = ((((T0->at((int32_t)(a1 >> 24)) ^ T1->at((int32_t)((unsigned char)(a2 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a4 >> 8)))) ^ T3->at((int32_t)((unsigned char)a5))) ^ ekey->at(9));
        b2 = ((((T0->at((int32_t)(a2 >> 24)) ^ T1->at((int32_t)((unsigned char)(a3 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a5 >> 8)))) ^ T3->at((int32_t)((unsigned char)a6))) ^ ekey->at(10));
        b3 = ((((T0->at((int32_t)(a3 >> 24)) ^ T1->at((int32_t)((unsigned char)(a4 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a6 >> 8)))) ^ T3->at((int32_t)((unsigned char)a7))) ^ ekey->at(11));
        b4 = ((((T0->at((int32_t)(a4 >> 24)) ^ T1->at((int32_t)((unsigned char)(a5 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a7 >> 8)))) ^ T3->at((int32_t)((unsigned char)a0))) ^ ekey->at(12));
        b5 = ((((T0->at((int32_t)(a5 >> 24)) ^ T1->at((int32_t)((unsigned char)(a6 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a0 >> 8)))) ^ T3->at((int32_t)((unsigned char)a1))) ^ ekey->at(13));
        b6 = ((((T0->at((int32_t)(a6 >> 24)) ^ T1->at((int32_t)((unsigned char)(a7 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a1 >> 8)))) ^ T3->at((int32_t)((unsigned char)a2))) ^ ekey->at(14));
        b7 = ((((T0->at((int32_t)(a7 >> 24)) ^ T1->at((int32_t)((unsigned char)(a0 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a2 >> 8)))) ^ T3->at((int32_t)((unsigned char)a3))) ^ ekey->at(15));
        a0 = ((((T0->at((int32_t)(b0 >> 24)) ^ T1->at((int32_t)((unsigned char)(b1 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b3 >> 8)))) ^ T3->at((int32_t)((unsigned char)b4))) ^ ekey->at(16));
        a1 = ((((T0->at((int32_t)(b1 >> 24)) ^ T1->at((int32_t)((unsigned char)(b2 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b4 >> 8)))) ^ T3->at((int32_t)((unsigned char)b5))) ^ ekey->at(17));
        a2 = ((((T0->at((int32_t)(b2 >> 24)) ^ T1->at((int32_t)((unsigned char)(b3 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b5 >> 8)))) ^ T3->at((int32_t)((unsigned char)b6))) ^ ekey->at(18));
        a3 = ((((T0->at((int32_t)(b3 >> 24)) ^ T1->at((int32_t)((unsigned char)(b4 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b6 >> 8)))) ^ T3->at((int32_t)((unsigned char)b7))) ^ ekey->at(19));
        a4 = ((((T0->at((int32_t)(b4 >> 24)) ^ T1->at((int32_t)((unsigned char)(b5 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b7 >> 8)))) ^ T3->at((int32_t)((unsigned char)b0))) ^ ekey->at(20));
        a5 = ((((T0->at((int32_t)(b5 >> 24)) ^ T1->at((int32_t)((unsigned char)(b6 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b0 >> 8)))) ^ T3->at((int32_t)((unsigned char)b1))) ^ ekey->at(21));
        a6 = ((((T0->at((int32_t)(b6 >> 24)) ^ T1->at((int32_t)((unsigned char)(b7 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b1 >> 8)))) ^ T3->at((int32_t)((unsigned char)b2))) ^ ekey->at(22));
        a7 = ((((T0->at((int32_t)(b7 >> 24)) ^ T1->at((int32_t)((unsigned char)(b0 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b2 >> 8)))) ^ T3->at((int32_t)((unsigned char)b3))) ^ ekey->at(23));
        b0 = ((((T0->at((int32_t)(a0 >> 24)) ^ T1->at((int32_t)((unsigned char)(a1 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a3 >> 8)))) ^ T3->at((int32_t)((unsigned char)a4))) ^ ekey->at(24));
        b1 = ((((T0->at((int32_t)(a1 >> 24)) ^ T1->at((int32_t)((unsigned char)(a2 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a4 >> 8)))) ^ T3->at((int32_t)((unsigned char)a5))) ^ ekey->at(25));
        b2 = ((((T0->at((int32_t)(a2 >> 24)) ^ T1->at((int32_t)((unsigned char)(a3 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a5 >> 8)))) ^ T3->at((int32_t)((unsigned char)a6))) ^ ekey->at(26));
        b3 = ((((T0->at((int32_t)(a3 >> 24)) ^ T1->at((int32_t)((unsigned char)(a4 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a6 >> 8)))) ^ T3->at((int32_t)((unsigned char)a7))) ^ ekey->at(27));
        b4 = ((((T0->at((int32_t)(a4 >> 24)) ^ T1->at((int32_t)((unsigned char)(a5 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a7 >> 8)))) ^ T3->at((int32_t)((unsigned char)a0))) ^ ekey->at(28));
        b5 = ((((T0->at((int32_t)(a5 >> 24)) ^ T1->at((int32_t)((unsigned char)(a6 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a0 >> 8)))) ^ T3->at((int32_t)((unsigned char)a1))) ^ ekey->at(29));
        b6 = ((((T0->at((int32_t)(a6 >> 24)) ^ T1->at((int32_t)((unsigned char)(a7 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a1 >> 8)))) ^ T3->at((int32_t)((unsigned char)a2))) ^ ekey->at(30));
        b7 = ((((T0->at((int32_t)(a7 >> 24)) ^ T1->at((int32_t)((unsigned char)(a0 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a2 >> 8)))) ^ T3->at((int32_t)((unsigned char)a3))) ^ ekey->at(31));
        a0 = ((((T0->at((int32_t)(b0 >> 24)) ^ T1->at((int32_t)((unsigned char)(b1 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b3 >> 8)))) ^ T3->at((int32_t)((unsigned char)b4))) ^ ekey->at(32));
        a1 = ((((T0->at((int32_t)(b1 >> 24)) ^ T1->at((int32_t)((unsigned char)(b2 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b4 >> 8)))) ^ T3->at((int32_t)((unsigned char)b5))) ^ ekey->at(33));
        a2 = ((((T0->at((int32_t)(b2 >> 24)) ^ T1->at((int32_t)((unsigned char)(b3 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b5 >> 8)))) ^ T3->at((int32_t)((unsigned char)b6))) ^ ekey->at(34));
        a3 = ((((T0->at((int32_t)(b3 >> 24)) ^ T1->at((int32_t)((unsigned char)(b4 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b6 >> 8)))) ^ T3->at((int32_t)((unsigned char)b7))) ^ ekey->at(35));
        a4 = ((((T0->at((int32_t)(b4 >> 24)) ^ T1->at((int32_t)((unsigned char)(b5 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b7 >> 8)))) ^ T3->at((int32_t)((unsigned char)b0))) ^ ekey->at(36));
        a5 = ((((T0->at((int32_t)(b5 >> 24)) ^ T1->at((int32_t)((unsigned char)(b6 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b0 >> 8)))) ^ T3->at((int32_t)((unsigned char)b1))) ^ ekey->at(37));
        a6 = ((((T0->at((int32_t)(b6 >> 24)) ^ T1->at((int32_t)((unsigned char)(b7 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b1 >> 8)))) ^ T3->at((int32_t)((unsigned char)b2))) ^ ekey->at(38));
        a7 = ((((T0->at((int32_t)(b7 >> 24)) ^ T1->at((int32_t)((unsigned char)(b0 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b2 >> 8)))) ^ T3->at((int32_t)((unsigned char)b3))) ^ ekey->at(39));
        b0 = ((((T0->at((int32_t)(a0 >> 24)) ^ T1->at((int32_t)((unsigned char)(a1 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a3 >> 8)))) ^ T3->at((int32_t)((unsigned char)a4))) ^ ekey->at(40));
        b1 = ((((T0->at((int32_t)(a1 >> 24)) ^ T1->at((int32_t)((unsigned char)(a2 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a4 >> 8)))) ^ T3->at((int32_t)((unsigned char)a5))) ^ ekey->at(41));
        b2 = ((((T0->at((int32_t)(a2 >> 24)) ^ T1->at((int32_t)((unsigned char)(a3 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a5 >> 8)))) ^ T3->at((int32_t)((unsigned char)a6))) ^ ekey->at(42));
        b3 = ((((T0->at((int32_t)(a3 >> 24)) ^ T1->at((int32_t)((unsigned char)(a4 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a6 >> 8)))) ^ T3->at((int32_t)((unsigned char)a7))) ^ ekey->at(43));
        b4 = ((((T0->at((int32_t)(a4 >> 24)) ^ T1->at((int32_t)((unsigned char)(a5 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a7 >> 8)))) ^ T3->at((int32_t)((unsigned char)a0))) ^ ekey->at(44));
        b5 = ((((T0->at((int32_t)(a5 >> 24)) ^ T1->at((int32_t)((unsigned char)(a6 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a0 >> 8)))) ^ T3->at((int32_t)((unsigned char)a1))) ^ ekey->at(45));
        b6 = ((((T0->at((int32_t)(a6 >> 24)) ^ T1->at((int32_t)((unsigned char)(a7 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a1 >> 8)))) ^ T3->at((int32_t)((unsigned char)a2))) ^ ekey->at(46));
        b7 = ((((T0->at((int32_t)(a7 >> 24)) ^ T1->at((int32_t)((unsigned char)(a0 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a2 >> 8)))) ^ T3->at((int32_t)((unsigned char)a3))) ^ ekey->at(47));
        a0 = ((((T0->at((int32_t)(b0 >> 24)) ^ T1->at((int32_t)((unsigned char)(b1 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b3 >> 8)))) ^ T3->at((int32_t)((unsigned char)b4))) ^ ekey->at(48));
        a1 = ((((T0->at((int32_t)(b1 >> 24)) ^ T1->at((int32_t)((unsigned char)(b2 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b4 >> 8)))) ^ T3->at((int32_t)((unsigned char)b5))) ^ ekey->at(49));
        a2 = ((((T0->at((int32_t)(b2 >> 24)) ^ T1->at((int32_t)((unsigned char)(b3 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b5 >> 8)))) ^ T3->at((int32_t)((unsigned char)b6))) ^ ekey->at(50));
        a3 = ((((T0->at((int32_t)(b3 >> 24)) ^ T1->at((int32_t)((unsigned char)(b4 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b6 >> 8)))) ^ T3->at((int32_t)((unsigned char)b7))) ^ ekey->at(51));
        a4 = ((((T0->at((int32_t)(b4 >> 24)) ^ T1->at((int32_t)((unsigned char)(b5 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b7 >> 8)))) ^ T3->at((int32_t)((unsigned char)b0))) ^ ekey->at(52));
        a5 = ((((T0->at((int32_t)(b5 >> 24)) ^ T1->at((int32_t)((unsigned char)(b6 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b0 >> 8)))) ^ T3->at((int32_t)((unsigned char)b1))) ^ ekey->at(53));
        a6 = ((((T0->at((int32_t)(b6 >> 24)) ^ T1->at((int32_t)((unsigned char)(b7 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b1 >> 8)))) ^ T3->at((int32_t)((unsigned char)b2))) ^ ekey->at(54));
        a7 = ((((T0->at((int32_t)(b7 >> 24)) ^ T1->at((int32_t)((unsigned char)(b0 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b2 >> 8)))) ^ T3->at((int32_t)((unsigned char)b3))) ^ ekey->at(55));
        b0 = ((((T0->at((int32_t)(a0 >> 24)) ^ T1->at((int32_t)((unsigned char)(a1 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a3 >> 8)))) ^ T3->at((int32_t)((unsigned char)a4))) ^ ekey->at(56));
        b1 = ((((T0->at((int32_t)(a1 >> 24)) ^ T1->at((int32_t)((unsigned char)(a2 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a4 >> 8)))) ^ T3->at((int32_t)((unsigned char)a5))) ^ ekey->at(57));
        b2 = ((((T0->at((int32_t)(a2 >> 24)) ^ T1->at((int32_t)((unsigned char)(a3 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a5 >> 8)))) ^ T3->at((int32_t)((unsigned char)a6))) ^ ekey->at(58));
        b3 = ((((T0->at((int32_t)(a3 >> 24)) ^ T1->at((int32_t)((unsigned char)(a4 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a6 >> 8)))) ^ T3->at((int32_t)((unsigned char)a7))) ^ ekey->at(59));
        b4 = ((((T0->at((int32_t)(a4 >> 24)) ^ T1->at((int32_t)((unsigned char)(a5 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a7 >> 8)))) ^ T3->at((int32_t)((unsigned char)a0))) ^ ekey->at(60));
        b5 = ((((T0->at((int32_t)(a5 >> 24)) ^ T1->at((int32_t)((unsigned char)(a6 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a0 >> 8)))) ^ T3->at((int32_t)((unsigned char)a1))) ^ ekey->at(61));
        b6 = ((((T0->at((int32_t)(a6 >> 24)) ^ T1->at((int32_t)((unsigned char)(a7 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a1 >> 8)))) ^ T3->at((int32_t)((unsigned char)a2))) ^ ekey->at(62));
        b7 = ((((T0->at((int32_t)(a7 >> 24)) ^ T1->at((int32_t)((unsigned char)(a0 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a2 >> 8)))) ^ T3->at((int32_t)((unsigned char)a3))) ^ ekey->at(63));
        a0 = ((((T0->at((int32_t)(b0 >> 24)) ^ T1->at((int32_t)((unsigned char)(b1 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b3 >> 8)))) ^ T3->at((int32_t)((unsigned char)b4))) ^ ekey->at(64));
        a1 = ((((T0->at((int32_t)(b1 >> 24)) ^ T1->at((int32_t)((unsigned char)(b2 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b4 >> 8)))) ^ T3->at((int32_t)((unsigned char)b5))) ^ ekey->at(65));
        a2 = ((((T0->at((int32_t)(b2 >> 24)) ^ T1->at((int32_t)((unsigned char)(b3 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b5 >> 8)))) ^ T3->at((int32_t)((unsigned char)b6))) ^ ekey->at(66));
        a3 = ((((T0->at((int32_t)(b3 >> 24)) ^ T1->at((int32_t)((unsigned char)(b4 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b6 >> 8)))) ^ T3->at((int32_t)((unsigned char)b7))) ^ ekey->at(67));
        a4 = ((((T0->at((int32_t)(b4 >> 24)) ^ T1->at((int32_t)((unsigned char)(b5 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b7 >> 8)))) ^ T3->at((int32_t)((unsigned char)b0))) ^ ekey->at(68));
        a5 = ((((T0->at((int32_t)(b5 >> 24)) ^ T1->at((int32_t)((unsigned char)(b6 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b0 >> 8)))) ^ T3->at((int32_t)((unsigned char)b1))) ^ ekey->at(69));
        a6 = ((((T0->at((int32_t)(b6 >> 24)) ^ T1->at((int32_t)((unsigned char)(b7 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b1 >> 8)))) ^ T3->at((int32_t)((unsigned char)b2))) ^ ekey->at(70));
        a7 = ((((T0->at((int32_t)(b7 >> 24)) ^ T1->at((int32_t)((unsigned char)(b0 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b2 >> 8)))) ^ T3->at((int32_t)((unsigned char)b3))) ^ ekey->at(71));
        b0 = ((((T0->at((int32_t)(a0 >> 24)) ^ T1->at((int32_t)((unsigned char)(a1 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a3 >> 8)))) ^ T3->at((int32_t)((unsigned char)a4))) ^ ekey->at(72));
        b1 = ((((T0->at((int32_t)(a1 >> 24)) ^ T1->at((int32_t)((unsigned char)(a2 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a4 >> 8)))) ^ T3->at((int32_t)((unsigned char)a5))) ^ ekey->at(73));
        b2 = ((((T0->at((int32_t)(a2 >> 24)) ^ T1->at((int32_t)((unsigned char)(a3 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a5 >> 8)))) ^ T3->at((int32_t)((unsigned char)a6))) ^ ekey->at(74));
        b3 = ((((T0->at((int32_t)(a3 >> 24)) ^ T1->at((int32_t)((unsigned char)(a4 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a6 >> 8)))) ^ T3->at((int32_t)((unsigned char)a7))) ^ ekey->at(75));
        b4 = ((((T0->at((int32_t)(a4 >> 24)) ^ T1->at((int32_t)((unsigned char)(a5 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a7 >> 8)))) ^ T3->at((int32_t)((unsigned char)a0))) ^ ekey->at(76));
        b5 = ((((T0->at((int32_t)(a5 >> 24)) ^ T1->at((int32_t)((unsigned char)(a6 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a0 >> 8)))) ^ T3->at((int32_t)((unsigned char)a1))) ^ ekey->at(77));
        b6 = ((((T0->at((int32_t)(a6 >> 24)) ^ T1->at((int32_t)((unsigned char)(a7 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a1 >> 8)))) ^ T3->at((int32_t)((unsigned char)a2))) ^ ekey->at(78));
        b7 = ((((T0->at((int32_t)(a7 >> 24)) ^ T1->at((int32_t)((unsigned char)(a0 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a2 >> 8)))) ^ T3->at((int32_t)((unsigned char)a3))) ^ ekey->at(79));
        a0 = ((((T0->at((int32_t)(b0 >> 24)) ^ T1->at((int32_t)((unsigned char)(b1 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b3 >> 8)))) ^ T3->at((int32_t)((unsigned char)b4))) ^ ekey->at(80));
        a1 = ((((T0->at((int32_t)(b1 >> 24)) ^ T1->at((int32_t)((unsigned char)(b2 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b4 >> 8)))) ^ T3->at((int32_t)((unsigned char)b5))) ^ ekey->at(81));
        a2 = ((((T0->at((int32_t)(b2 >> 24)) ^ T1->at((int32_t)((unsigned char)(b3 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b5 >> 8)))) ^ T3->at((int32_t)((unsigned char)b6))) ^ ekey->at(82));
        a3 = ((((T0->at((int32_t)(b3 >> 24)) ^ T1->at((int32_t)((unsigned char)(b4 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b6 >> 8)))) ^ T3->at((int32_t)((unsigned char)b7))) ^ ekey->at(83));
        a4 = ((((T0->at((int32_t)(b4 >> 24)) ^ T1->at((int32_t)((unsigned char)(b5 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b7 >> 8)))) ^ T3->at((int32_t)((unsigned char)b0))) ^ ekey->at(84));
        a5 = ((((T0->at((int32_t)(b5 >> 24)) ^ T1->at((int32_t)((unsigned char)(b6 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b0 >> 8)))) ^ T3->at((int32_t)((unsigned char)b1))) ^ ekey->at(85));
        a6 = ((((T0->at((int32_t)(b6 >> 24)) ^ T1->at((int32_t)((unsigned char)(b7 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b1 >> 8)))) ^ T3->at((int32_t)((unsigned char)b2))) ^ ekey->at(86));
        a7 = ((((T0->at((int32_t)(b7 >> 24)) ^ T1->at((int32_t)((unsigned char)(b0 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b2 >> 8)))) ^ T3->at((int32_t)((unsigned char)b3))) ^ ekey->at(87));
        b0 = ((((T0->at((int32_t)(a0 >> 24)) ^ T1->at((int32_t)((unsigned char)(a1 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a3 >> 8)))) ^ T3->at((int32_t)((unsigned char)a4))) ^ ekey->at(88));
        b1 = ((((T0->at((int32_t)(a1 >> 24)) ^ T1->at((int32_t)((unsigned char)(a2 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a4 >> 8)))) ^ T3->at((int32_t)((unsigned char)a5))) ^ ekey->at(89));
        b2 = ((((T0->at((int32_t)(a2 >> 24)) ^ T1->at((int32_t)((unsigned char)(a3 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a5 >> 8)))) ^ T3->at((int32_t)((unsigned char)a6))) ^ ekey->at(90));
        b3 = ((((T0->at((int32_t)(a3 >> 24)) ^ T1->at((int32_t)((unsigned char)(a4 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a6 >> 8)))) ^ T3->at((int32_t)((unsigned char)a7))) ^ ekey->at(91));
        b4 = ((((T0->at((int32_t)(a4 >> 24)) ^ T1->at((int32_t)((unsigned char)(a5 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a7 >> 8)))) ^ T3->at((int32_t)((unsigned char)a0))) ^ ekey->at(92));
        b5 = ((((T0->at((int32_t)(a5 >> 24)) ^ T1->at((int32_t)((unsigned char)(a6 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a0 >> 8)))) ^ T3->at((int32_t)((unsigned char)a1))) ^ ekey->at(93));
        b6 = ((((T0->at((int32_t)(a6 >> 24)) ^ T1->at((int32_t)((unsigned char)(a7 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a1 >> 8)))) ^ T3->at((int32_t)((unsigned char)a2))) ^ ekey->at(94));
        b7 = ((((T0->at((int32_t)(a7 >> 24)) ^ T1->at((int32_t)((unsigned char)(a0 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a2 >> 8)))) ^ T3->at((int32_t)((unsigned char)a3))) ^ ekey->at(95));
        a0 = ((((T0->at((int32_t)(b0 >> 24)) ^ T1->at((int32_t)((unsigned char)(b1 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b3 >> 8)))) ^ T3->at((int32_t)((unsigned char)b4))) ^ ekey->at(96));
        a1 = ((((T0->at((int32_t)(b1 >> 24)) ^ T1->at((int32_t)((unsigned char)(b2 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b4 >> 8)))) ^ T3->at((int32_t)((unsigned char)b5))) ^ ekey->at(97));
        a2 = ((((T0->at((int32_t)(b2 >> 24)) ^ T1->at((int32_t)((unsigned char)(b3 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b5 >> 8)))) ^ T3->at((int32_t)((unsigned char)b6))) ^ ekey->at(98));
        a3 = ((((T0->at((int32_t)(b3 >> 24)) ^ T1->at((int32_t)((unsigned char)(b4 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b6 >> 8)))) ^ T3->at((int32_t)((unsigned char)b7))) ^ ekey->at(99));
        a4 = ((((T0->at((int32_t)(b4 >> 24)) ^ T1->at((int32_t)((unsigned char)(b5 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b7 >> 8)))) ^ T3->at((int32_t)((unsigned char)b0))) ^ ekey->at(100));
        a5 = ((((T0->at((int32_t)(b5 >> 24)) ^ T1->at((int32_t)((unsigned char)(b6 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b0 >> 8)))) ^ T3->at((int32_t)((unsigned char)b1))) ^ ekey->at(101));
        a6 = ((((T0->at((int32_t)(b6 >> 24)) ^ T1->at((int32_t)((unsigned char)(b7 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b1 >> 8)))) ^ T3->at((int32_t)((unsigned char)b2))) ^ ekey->at(102));
        a7 = ((((T0->at((int32_t)(b7 >> 24)) ^ T1->at((int32_t)((unsigned char)(b0 >> 16)))) ^ T2->at((int32_t)((unsigned char)(b2 >> 8)))) ^ T3->at((int32_t)((unsigned char)b3))) ^ ekey->at(103));
        b0 = ((((T0->at((int32_t)(a0 >> 24)) ^ T1->at((int32_t)((unsigned char)(a1 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a3 >> 8)))) ^ T3->at((int32_t)((unsigned char)a4))) ^ ekey->at(104));
        b1 = ((((T0->at((int32_t)(a1 >> 24)) ^ T1->at((int32_t)((unsigned char)(a2 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a4 >> 8)))) ^ T3->at((int32_t)((unsigned char)a5))) ^ ekey->at(105));
        b2 = ((((T0->at((int32_t)(a2 >> 24)) ^ T1->at((int32_t)((unsigned char)(a3 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a5 >> 8)))) ^ T3->at((int32_t)((unsigned char)a6))) ^ ekey->at(106));
        b3 = ((((T0->at((int32_t)(a3 >> 24)) ^ T1->at((int32_t)((unsigned char)(a4 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a6 >> 8)))) ^ T3->at((int32_t)((unsigned char)a7))) ^ ekey->at(107));
        b4 = ((((T0->at((int32_t)(a4 >> 24)) ^ T1->at((int32_t)((unsigned char)(a5 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a7 >> 8)))) ^ T3->at((int32_t)((unsigned char)a0))) ^ ekey->at(108));
        b5 = ((((T0->at((int32_t)(a5 >> 24)) ^ T1->at((int32_t)((unsigned char)(a6 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a0 >> 8)))) ^ T3->at((int32_t)((unsigned char)a1))) ^ ekey->at(109));
        b6 = ((((T0->at((int32_t)(a6 >> 24)) ^ T1->at((int32_t)((unsigned char)(a7 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a1 >> 8)))) ^ T3->at((int32_t)((unsigned char)a2))) ^ ekey->at(110));
        b7 = ((((T0->at((int32_t)(a7 >> 24)) ^ T1->at((int32_t)((unsigned char)(a0 >> 16)))) ^ T2->at((int32_t)((unsigned char)(a2 >> 8)))) ^ T3->at((int32_t)((unsigned char)a3))) ^ ekey->at(111));
        outdata->at(0) = (unsigned char)((int32_t)(SBox->at((int32_t)(b0 >> 24))) ^ (int32_t)((unsigned char)(ekey->at(112) >> 24)));
        outdata->at(1) = (unsigned char)((int32_t)(SBox->at((int32_t)((unsigned char)(b1 >> 16)))) ^ (int32_t)((unsigned char)(ekey->at(112) >> 16)));
        outdata->at(2) = (unsigned char)((int32_t)(SBox->at((int32_t)((unsigned char)(b3 >> 8)))) ^ (int32_t)((unsigned char)(ekey->at(112) >> 8)));
        outdata->at(3) = (unsigned char)((int32_t)(SBox->at((int32_t)((unsigned char)b4))) ^ (int32_t)((unsigned char)ekey->at(112)));
        outdata->at(4) = (unsigned char)((int32_t)(SBox->at((int32_t)(b1 >> 24))) ^ (int32_t)((unsigned char)(ekey->at(113) >> 24)));
        outdata->at(5) = (unsigned char)((int32_t)(SBox->at((int32_t)((unsigned char)(b2 >> 16)))) ^ (int32_t)((unsigned char)(ekey->at(113) >> 16)));
        outdata->at(6) = (unsigned char)((int32_t)(SBox->at((int32_t)((unsigned char)(b4 >> 8)))) ^ (int32_t)((unsigned char)(ekey->at(113) >> 8)));
        outdata->at(7) = (unsigned char)((int32_t)(SBox->at((int32_t)((unsigned char)b5))) ^ (int32_t)((unsigned char)ekey->at(113)));
        outdata->at(8) = (unsigned char)((int32_t)(SBox->at((int32_t)(b2 >> 24))) ^ (int32_t)((unsigned char)(ekey->at(114) >> 24)));
        outdata->at(9) = (unsigned char)((int32_t)(SBox->at((int32_t)((unsigned char)(b3 >> 16)))) ^ (int32_t)((unsigned char)(ekey->at(114) >> 16)));
        outdata->at(10) = (unsigned char)((int32_t)(SBox->at((int32_t)((unsigned char)(b5 >> 8)))) ^ (int32_t)((unsigned char)(ekey->at(114) >> 8)));
        outdata->at(11) = (unsigned char)((int32_t)(SBox->at((int32_t)((unsigned char)b6))) ^ (int32_t)((unsigned char)ekey->at(114)));
        outdata->at(12) = (unsigned char)((int32_t)(SBox->at((int32_t)(b3 >> 24))) ^ (int32_t)((unsigned char)(ekey->at(115) >> 24)));
        outdata->at(13) = (unsigned char)((int32_t)(SBox->at((int32_t)((unsigned char)(b4 >> 16)))) ^ (int32_t)((unsigned char)(ekey->at(115) >> 16)));
        outdata->at(14) = (unsigned char)((int32_t)(SBox->at((int32_t)((unsigned char)(b6 >> 8)))) ^ (int32_t)((unsigned char)(ekey->at(115) >> 8)));
        outdata->at(15) = (unsigned char)((int32_t)(SBox->at((int32_t)((unsigned char)b7))) ^ (int32_t)((unsigned char)ekey->at(115)));
        outdata->at(16) = (unsigned char)((int32_t)(SBox->at((int32_t)(b4 >> 24))) ^ (int32_t)((unsigned char)(ekey->at(116) >> 24)));
        outdata->at(17) = (unsigned char)((int32_t)(SBox->at((int32_t)((unsigned char)(b5 >> 16)))) ^ (int32_t)((unsigned char)(ekey->at(116) >> 16)));
        outdata->at(18) = (unsigned char)((int32_t)(SBox->at((int32_t)((unsigned char)(b7 >> 8)))) ^ (int32_t)((unsigned char)(ekey->at(116) >> 8)));
        outdata->at(19) = (unsigned char)((int32_t)(SBox->at((int32_t)((unsigned char)b0))) ^ (int32_t)((unsigned char)ekey->at(116)));
        outdata->at(20) = (unsigned char)((int32_t)(SBox->at((int32_t)(b5 >> 24))) ^ (int32_t)((unsigned char)(ekey->at(117) >> 24)));
        outdata->at(21) = (unsigned char)((int32_t)(SBox->at((int32_t)((unsigned char)(b6 >> 16)))) ^ (int32_t)((unsigned char)(ekey->at(117) >> 16)));
        outdata->at(22) = (unsigned char)((int32_t)(SBox->at((int32_t)((unsigned char)(b0 >> 8)))) ^ (int32_t)((unsigned char)(ekey->at(117) >> 8)));
        outdata->at(23) = (unsigned char)((int32_t)(SBox->at((int32_t)((unsigned char)b1))) ^ (int32_t)((unsigned char)ekey->at(117)));
        outdata->at(24) = (unsigned char)((int32_t)(SBox->at((int32_t)(b6 >> 24))) ^ (int32_t)((unsigned char)(ekey->at(118) >> 24)));
        outdata->at(25) = (unsigned char)((int32_t)(SBox->at((int32_t)((unsigned char)(b7 >> 16)))) ^ (int32_t)((unsigned char)(ekey->at(118) >> 16)));
        outdata->at(26) = (unsigned char)((int32_t)(SBox->at((int32_t)((unsigned char)(b1 >> 8)))) ^ (int32_t)((unsigned char)(ekey->at(118) >> 8)));
        outdata->at(27) = (unsigned char)((int32_t)(SBox->at((int32_t)((unsigned char)b2))) ^ (int32_t)((unsigned char)ekey->at(118)));
        outdata->at(28) = (unsigned char)((int32_t)(SBox->at((int32_t)(b7 >> 24))) ^ (int32_t)((unsigned char)(ekey->at(119) >> 24)));
        outdata->at(29) = (unsigned char)((int32_t)(SBox->at((int32_t)((unsigned char)(b0 >> 16)))) ^ (int32_t)((unsigned char)(ekey->at(119) >> 16)));
        outdata->at(30) = (unsigned char)((int32_t)(SBox->at((int32_t)((unsigned char)(b2 >> 8)))) ^ (int32_t)((unsigned char)(ekey->at(119) >> 8)));
        outdata->at(31) = (unsigned char)((int32_t)(SBox->at((int32_t)((unsigned char)b3))) ^ (int32_t)((unsigned char)ekey->at(119)));
    }
    
    void RijndaelTransform::Decrypt128(cli::array<unsigned char>* indata, cli::array<unsigned char>* outdata, cli::array<uint32_t>* ekey) {
        uint32_t a0, a1, a2, a3, b0, b1, b2, b3;
        int32_t ei = 40;
        a0 = ((((((uint32_t)(indata->at(0)) << 24) | ((uint32_t)(indata->at(1)) << 16)) | ((uint32_t)(indata->at(2)) << 8)) | (uint32_t)(indata->at(3))) ^ ekey->at(0));
        a1 = ((((((uint32_t)(indata->at(4)) << 24) | ((uint32_t)(indata->at(5)) << 16)) | ((uint32_t)(indata->at(6)) << 8)) | (uint32_t)(indata->at(7))) ^ ekey->at(1));
        a2 = ((((((uint32_t)(indata->at(8)) << 24) | ((uint32_t)(indata->at(9)) << 16)) | ((uint32_t)(indata->at(10)) << 8)) | (uint32_t)(indata->at(11))) ^ ekey->at(2));
        a3 = ((((((uint32_t)(indata->at(12)) << 24) | ((uint32_t)(indata->at(13)) << 16)) | ((uint32_t)(indata->at(14)) << 8)) | (uint32_t)(indata->at(15))) ^ ekey->at(3));
        b0 = ((((iT0->at((int32_t)(a0 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a3 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a2 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a1))) ^ ekey->at(4));
        b1 = ((((iT0->at((int32_t)(a1 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a0 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a3 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a2))) ^ ekey->at(5));
        b2 = ((((iT0->at((int32_t)(a2 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a1 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a0 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a3))) ^ ekey->at(6));
        b3 = ((((iT0->at((int32_t)(a3 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a2 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a1 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a0))) ^ ekey->at(7));
        a0 = ((((iT0->at((int32_t)(b0 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b3 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b2 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b1))) ^ ekey->at(8));
        a1 = ((((iT0->at((int32_t)(b1 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b0 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b3 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b2))) ^ ekey->at(9));
        a2 = ((((iT0->at((int32_t)(b2 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b1 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b0 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b3))) ^ ekey->at(10));
        a3 = ((((iT0->at((int32_t)(b3 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b2 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b1 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b0))) ^ ekey->at(11));
        b0 = ((((iT0->at((int32_t)(a0 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a3 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a2 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a1))) ^ ekey->at(12));
        b1 = ((((iT0->at((int32_t)(a1 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a0 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a3 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a2))) ^ ekey->at(13));
        b2 = ((((iT0->at((int32_t)(a2 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a1 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a0 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a3))) ^ ekey->at(14));
        b3 = ((((iT0->at((int32_t)(a3 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a2 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a1 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a0))) ^ ekey->at(15));
        a0 = ((((iT0->at((int32_t)(b0 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b3 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b2 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b1))) ^ ekey->at(16));
        a1 = ((((iT0->at((int32_t)(b1 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b0 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b3 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b2))) ^ ekey->at(17));
        a2 = ((((iT0->at((int32_t)(b2 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b1 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b0 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b3))) ^ ekey->at(18));
        a3 = ((((iT0->at((int32_t)(b3 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b2 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b1 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b0))) ^ ekey->at(19));
        b0 = ((((iT0->at((int32_t)(a0 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a3 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a2 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a1))) ^ ekey->at(20));
        b1 = ((((iT0->at((int32_t)(a1 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a0 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a3 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a2))) ^ ekey->at(21));
        b2 = ((((iT0->at((int32_t)(a2 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a1 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a0 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a3))) ^ ekey->at(22));
        b3 = ((((iT0->at((int32_t)(a3 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a2 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a1 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a0))) ^ ekey->at(23));
        a0 = ((((iT0->at((int32_t)(b0 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b3 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b2 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b1))) ^ ekey->at(24));
        a1 = ((((iT0->at((int32_t)(b1 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b0 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b3 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b2))) ^ ekey->at(25));
        a2 = ((((iT0->at((int32_t)(b2 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b1 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b0 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b3))) ^ ekey->at(26));
        a3 = ((((iT0->at((int32_t)(b3 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b2 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b1 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b0))) ^ ekey->at(27));
        b0 = ((((iT0->at((int32_t)(a0 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a3 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a2 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a1))) ^ ekey->at(28));
        b1 = ((((iT0->at((int32_t)(a1 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a0 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a3 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a2))) ^ ekey->at(29));
        b2 = ((((iT0->at((int32_t)(a2 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a1 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a0 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a3))) ^ ekey->at(30));
        b3 = ((((iT0->at((int32_t)(a3 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a2 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a1 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a0))) ^ ekey->at(31));
        a0 = ((((iT0->at((int32_t)(b0 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b3 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b2 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b1))) ^ ekey->at(32));
        a1 = ((((iT0->at((int32_t)(b1 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b0 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b3 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b2))) ^ ekey->at(33));
        a2 = ((((iT0->at((int32_t)(b2 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b1 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b0 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b3))) ^ ekey->at(34));
        a3 = ((((iT0->at((int32_t)(b3 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b2 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b1 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b0))) ^ ekey->at(35));
        b0 = ((((iT0->at((int32_t)(a0 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a3 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a2 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a1))) ^ ekey->at(36));
        b1 = ((((iT0->at((int32_t)(a1 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a0 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a3 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a2))) ^ ekey->at(37));
        b2 = ((((iT0->at((int32_t)(a2 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a1 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a0 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a3))) ^ ekey->at(38));
        b3 = ((((iT0->at((int32_t)(a3 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a2 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a1 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a0))) ^ ekey->at(39));
        if((this->Nr > 10)) 
        {
            a0 = ((((iT0->at((int32_t)(b0 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b3 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b2 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b1))) ^ ekey->at(40));
            a1 = ((((iT0->at((int32_t)(b1 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b0 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b3 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b2))) ^ ekey->at(41));
            a2 = ((((iT0->at((int32_t)(b2 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b1 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b0 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b3))) ^ ekey->at(42));
            a3 = ((((iT0->at((int32_t)(b3 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b2 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b1 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b0))) ^ ekey->at(43));
            b0 = ((((iT0->at((int32_t)(a0 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a3 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a2 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a1))) ^ ekey->at(44));
            b1 = ((((iT0->at((int32_t)(a1 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a0 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a3 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a2))) ^ ekey->at(45));
            b2 = ((((iT0->at((int32_t)(a2 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a1 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a0 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a3))) ^ ekey->at(46));
            b3 = ((((iT0->at((int32_t)(a3 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a2 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a1 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a0))) ^ ekey->at(47));
            ei = 48;
            if((this->Nr > 12)) 
            {
                a0 = ((((iT0->at((int32_t)(b0 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b3 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b2 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b1))) ^ ekey->at(48));
                a1 = ((((iT0->at((int32_t)(b1 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b0 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b3 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b2))) ^ ekey->at(49));
                a2 = ((((iT0->at((int32_t)(b2 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b1 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b0 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b3))) ^ ekey->at(50));
                a3 = ((((iT0->at((int32_t)(b3 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b2 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b1 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b0))) ^ ekey->at(51));
                b0 = ((((iT0->at((int32_t)(a0 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a3 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a2 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a1))) ^ ekey->at(52));
                b1 = ((((iT0->at((int32_t)(a1 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a0 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a3 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a2))) ^ ekey->at(53));
                b2 = ((((iT0->at((int32_t)(a2 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a1 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a0 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a3))) ^ ekey->at(54));
                b3 = ((((iT0->at((int32_t)(a3 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a2 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a1 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a0))) ^ ekey->at(55));
                ei = 56;
            }
        }
        outdata->at(0) = (unsigned char)((int32_t)(iSBox->at((int32_t)(b0 >> 24))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 24)));
        outdata->at(1) = (unsigned char)((int32_t)(iSBox->at((int32_t)((unsigned char)(b3 >> 16)))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 16)));
        outdata->at(2) = (unsigned char)((int32_t)(iSBox->at((int32_t)((unsigned char)(b2 >> 8)))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 8)));
        outdata->at(3) = (unsigned char)((int32_t)(iSBox->at((int32_t)((unsigned char)b1))) ^ (int32_t)((unsigned char)ekey->at(ei++)));
        outdata->at(4) = (unsigned char)((int32_t)(iSBox->at((int32_t)(b1 >> 24))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 24)));
        outdata->at(5) = (unsigned char)((int32_t)(iSBox->at((int32_t)((unsigned char)(b0 >> 16)))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 16)));
        outdata->at(6) = (unsigned char)((int32_t)(iSBox->at((int32_t)((unsigned char)(b3 >> 8)))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 8)));
        outdata->at(7) = (unsigned char)((int32_t)(iSBox->at((int32_t)((unsigned char)b2))) ^ (int32_t)((unsigned char)ekey->at(ei++)));
        outdata->at(8) = (unsigned char)((int32_t)(iSBox->at((int32_t)(b2 >> 24))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 24)));
        outdata->at(9) = (unsigned char)((int32_t)(iSBox->at((int32_t)((unsigned char)(b1 >> 16)))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 16)));
        outdata->at(10) = (unsigned char)((int32_t)(iSBox->at((int32_t)((unsigned char)(b0 >> 8)))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 8)));
        outdata->at(11) = (unsigned char)((int32_t)(iSBox->at((int32_t)((unsigned char)b3))) ^ (int32_t)((unsigned char)ekey->at(ei++)));
        outdata->at(12) = (unsigned char)((int32_t)(iSBox->at((int32_t)(b3 >> 24))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 24)));
        outdata->at(13) = (unsigned char)((int32_t)(iSBox->at((int32_t)((unsigned char)(b2 >> 16)))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 16)));
        outdata->at(14) = (unsigned char)((int32_t)(iSBox->at((int32_t)((unsigned char)(b1 >> 8)))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 8)));
        outdata->at(15) = (unsigned char)((int32_t)(iSBox->at((int32_t)((unsigned char)b0))) ^ (int32_t)((unsigned char)ekey->at(ei++)));
    }
    
    void RijndaelTransform::Decrypt192(cli::array<unsigned char>* indata, cli::array<unsigned char>* outdata, cli::array<uint32_t>* ekey) {
        uint32_t a0, a1, a2, a3, a4, a5, b0, b1, b2, b3, b4, b5;
        int32_t ei = 72;
        a0 = ((((((uint32_t)(indata->at(0)) << 24) | ((uint32_t)(indata->at(1)) << 16)) | ((uint32_t)(indata->at(2)) << 8)) | (uint32_t)(indata->at(3))) ^ ekey->at(0));
        a1 = ((((((uint32_t)(indata->at(4)) << 24) | ((uint32_t)(indata->at(5)) << 16)) | ((uint32_t)(indata->at(6)) << 8)) | (uint32_t)(indata->at(7))) ^ ekey->at(1));
        a2 = ((((((uint32_t)(indata->at(8)) << 24) | ((uint32_t)(indata->at(9)) << 16)) | ((uint32_t)(indata->at(10)) << 8)) | (uint32_t)(indata->at(11))) ^ ekey->at(2));
        a3 = ((((((uint32_t)(indata->at(12)) << 24) | ((uint32_t)(indata->at(13)) << 16)) | ((uint32_t)(indata->at(14)) << 8)) | (uint32_t)(indata->at(15))) ^ ekey->at(3));
        a4 = ((((((uint32_t)(indata->at(16)) << 24) | ((uint32_t)(indata->at(17)) << 16)) | ((uint32_t)(indata->at(18)) << 8)) | (uint32_t)(indata->at(19))) ^ ekey->at(4));
        a5 = ((((((uint32_t)(indata->at(20)) << 24) | ((uint32_t)(indata->at(21)) << 16)) | ((uint32_t)(indata->at(22)) << 8)) | (uint32_t)(indata->at(23))) ^ ekey->at(5));
        b0 = ((((iT0->at((int32_t)(a0 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a5 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a4 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a3))) ^ ekey->at(6));
        b1 = ((((iT0->at((int32_t)(a1 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a0 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a5 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a4))) ^ ekey->at(7));
        b2 = ((((iT0->at((int32_t)(a2 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a1 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a0 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a5))) ^ ekey->at(8));
        b3 = ((((iT0->at((int32_t)(a3 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a2 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a1 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a0))) ^ ekey->at(9));
        b4 = ((((iT0->at((int32_t)(a4 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a3 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a2 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a1))) ^ ekey->at(10));
        b5 = ((((iT0->at((int32_t)(a5 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a4 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a3 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a2))) ^ ekey->at(11));
        a0 = ((((iT0->at((int32_t)(b0 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b5 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b4 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b3))) ^ ekey->at(12));
        a1 = ((((iT0->at((int32_t)(b1 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b0 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b5 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b4))) ^ ekey->at(13));
        a2 = ((((iT0->at((int32_t)(b2 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b1 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b0 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b5))) ^ ekey->at(14));
        a3 = ((((iT0->at((int32_t)(b3 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b2 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b1 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b0))) ^ ekey->at(15));
        a4 = ((((iT0->at((int32_t)(b4 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b3 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b2 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b1))) ^ ekey->at(16));
        a5 = ((((iT0->at((int32_t)(b5 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b4 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b3 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b2))) ^ ekey->at(17));
        b0 = ((((iT0->at((int32_t)(a0 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a5 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a4 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a3))) ^ ekey->at(18));
        b1 = ((((iT0->at((int32_t)(a1 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a0 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a5 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a4))) ^ ekey->at(19));
        b2 = ((((iT0->at((int32_t)(a2 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a1 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a0 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a5))) ^ ekey->at(20));
        b3 = ((((iT0->at((int32_t)(a3 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a2 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a1 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a0))) ^ ekey->at(21));
        b4 = ((((iT0->at((int32_t)(a4 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a3 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a2 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a1))) ^ ekey->at(22));
        b5 = ((((iT0->at((int32_t)(a5 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a4 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a3 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a2))) ^ ekey->at(23));
        a0 = ((((iT0->at((int32_t)(b0 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b5 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b4 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b3))) ^ ekey->at(24));
        a1 = ((((iT0->at((int32_t)(b1 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b0 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b5 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b4))) ^ ekey->at(25));
        a2 = ((((iT0->at((int32_t)(b2 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b1 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b0 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b5))) ^ ekey->at(26));
        a3 = ((((iT0->at((int32_t)(b3 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b2 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b1 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b0))) ^ ekey->at(27));
        a4 = ((((iT0->at((int32_t)(b4 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b3 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b2 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b1))) ^ ekey->at(28));
        a5 = ((((iT0->at((int32_t)(b5 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b4 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b3 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b2))) ^ ekey->at(29));
        b0 = ((((iT0->at((int32_t)(a0 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a5 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a4 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a3))) ^ ekey->at(30));
        b1 = ((((iT0->at((int32_t)(a1 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a0 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a5 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a4))) ^ ekey->at(31));
        b2 = ((((iT0->at((int32_t)(a2 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a1 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a0 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a5))) ^ ekey->at(32));
        b3 = ((((iT0->at((int32_t)(a3 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a2 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a1 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a0))) ^ ekey->at(33));
        b4 = ((((iT0->at((int32_t)(a4 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a3 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a2 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a1))) ^ ekey->at(34));
        b5 = ((((iT0->at((int32_t)(a5 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a4 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a3 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a2))) ^ ekey->at(35));
        a0 = ((((iT0->at((int32_t)(b0 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b5 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b4 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b3))) ^ ekey->at(36));
        a1 = ((((iT0->at((int32_t)(b1 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b0 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b5 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b4))) ^ ekey->at(37));
        a2 = ((((iT0->at((int32_t)(b2 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b1 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b0 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b5))) ^ ekey->at(38));
        a3 = ((((iT0->at((int32_t)(b3 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b2 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b1 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b0))) ^ ekey->at(39));
        a4 = ((((iT0->at((int32_t)(b4 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b3 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b2 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b1))) ^ ekey->at(40));
        a5 = ((((iT0->at((int32_t)(b5 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b4 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b3 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b2))) ^ ekey->at(41));
        b0 = ((((iT0->at((int32_t)(a0 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a5 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a4 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a3))) ^ ekey->at(42));
        b1 = ((((iT0->at((int32_t)(a1 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a0 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a5 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a4))) ^ ekey->at(43));
        b2 = ((((iT0->at((int32_t)(a2 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a1 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a0 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a5))) ^ ekey->at(44));
        b3 = ((((iT0->at((int32_t)(a3 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a2 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a1 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a0))) ^ ekey->at(45));
        b4 = ((((iT0->at((int32_t)(a4 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a3 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a2 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a1))) ^ ekey->at(46));
        b5 = ((((iT0->at((int32_t)(a5 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a4 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a3 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a2))) ^ ekey->at(47));
        a0 = ((((iT0->at((int32_t)(b0 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b5 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b4 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b3))) ^ ekey->at(48));
        a1 = ((((iT0->at((int32_t)(b1 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b0 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b5 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b4))) ^ ekey->at(49));
        a2 = ((((iT0->at((int32_t)(b2 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b1 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b0 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b5))) ^ ekey->at(50));
        a3 = ((((iT0->at((int32_t)(b3 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b2 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b1 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b0))) ^ ekey->at(51));
        a4 = ((((iT0->at((int32_t)(b4 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b3 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b2 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b1))) ^ ekey->at(52));
        a5 = ((((iT0->at((int32_t)(b5 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b4 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b3 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b2))) ^ ekey->at(53));
        b0 = ((((iT0->at((int32_t)(a0 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a5 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a4 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a3))) ^ ekey->at(54));
        b1 = ((((iT0->at((int32_t)(a1 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a0 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a5 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a4))) ^ ekey->at(55));
        b2 = ((((iT0->at((int32_t)(a2 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a1 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a0 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a5))) ^ ekey->at(56));
        b3 = ((((iT0->at((int32_t)(a3 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a2 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a1 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a0))) ^ ekey->at(57));
        b4 = ((((iT0->at((int32_t)(a4 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a3 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a2 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a1))) ^ ekey->at(58));
        b5 = ((((iT0->at((int32_t)(a5 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a4 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a3 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a2))) ^ ekey->at(59));
        a0 = ((((iT0->at((int32_t)(b0 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b5 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b4 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b3))) ^ ekey->at(60));
        a1 = ((((iT0->at((int32_t)(b1 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b0 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b5 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b4))) ^ ekey->at(61));
        a2 = ((((iT0->at((int32_t)(b2 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b1 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b0 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b5))) ^ ekey->at(62));
        a3 = ((((iT0->at((int32_t)(b3 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b2 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b1 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b0))) ^ ekey->at(63));
        a4 = ((((iT0->at((int32_t)(b4 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b3 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b2 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b1))) ^ ekey->at(64));
        a5 = ((((iT0->at((int32_t)(b5 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b4 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b3 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b2))) ^ ekey->at(65));
        b0 = ((((iT0->at((int32_t)(a0 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a5 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a4 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a3))) ^ ekey->at(66));
        b1 = ((((iT0->at((int32_t)(a1 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a0 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a5 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a4))) ^ ekey->at(67));
        b2 = ((((iT0->at((int32_t)(a2 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a1 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a0 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a5))) ^ ekey->at(68));
        b3 = ((((iT0->at((int32_t)(a3 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a2 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a1 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a0))) ^ ekey->at(69));
        b4 = ((((iT0->at((int32_t)(a4 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a3 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a2 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a1))) ^ ekey->at(70));
        b5 = ((((iT0->at((int32_t)(a5 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a4 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a3 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a2))) ^ ekey->at(71));
        if((this->Nr > 12)) 
        {
            a0 = ((((iT0->at((int32_t)(b0 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b5 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b4 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b3))) ^ ekey->at(72));
            a1 = ((((iT0->at((int32_t)(b1 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b0 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b5 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b4))) ^ ekey->at(73));
            a2 = ((((iT0->at((int32_t)(b2 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b1 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b0 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b5))) ^ ekey->at(74));
            a3 = ((((iT0->at((int32_t)(b3 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b2 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b1 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b0))) ^ ekey->at(75));
            a4 = ((((iT0->at((int32_t)(b4 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b3 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b2 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b1))) ^ ekey->at(76));
            a5 = ((((iT0->at((int32_t)(b5 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b4 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b3 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b2))) ^ ekey->at(77));
            b0 = ((((iT0->at((int32_t)(a0 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a5 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a4 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a3))) ^ ekey->at(78));
            b1 = ((((iT0->at((int32_t)(a1 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a0 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a5 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a4))) ^ ekey->at(79));
            b2 = ((((iT0->at((int32_t)(a2 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a1 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a0 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a5))) ^ ekey->at(80));
            b3 = ((((iT0->at((int32_t)(a3 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a2 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a1 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a0))) ^ ekey->at(81));
            b4 = ((((iT0->at((int32_t)(a4 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a3 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a2 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a1))) ^ ekey->at(82));
            b5 = ((((iT0->at((int32_t)(a5 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a4 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a3 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a2))) ^ ekey->at(83));
            ei = 84;
        }
        outdata->at(0) = (unsigned char)((int32_t)(iSBox->at((int32_t)(b0 >> 24))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 24)));
        outdata->at(1) = (unsigned char)((int32_t)(iSBox->at((int32_t)((unsigned char)(b5 >> 16)))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 16)));
        outdata->at(2) = (unsigned char)((int32_t)(iSBox->at((int32_t)((unsigned char)(b4 >> 8)))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 8)));
        outdata->at(3) = (unsigned char)((int32_t)(iSBox->at((int32_t)((unsigned char)b3))) ^ (int32_t)((unsigned char)ekey->at(ei++)));
        outdata->at(4) = (unsigned char)((int32_t)(iSBox->at((int32_t)(b1 >> 24))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 24)));
        outdata->at(5) = (unsigned char)((int32_t)(iSBox->at((int32_t)((unsigned char)(b0 >> 16)))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 16)));
        outdata->at(6) = (unsigned char)((int32_t)(iSBox->at((int32_t)((unsigned char)(b5 >> 8)))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 8)));
        outdata->at(7) = (unsigned char)((int32_t)(iSBox->at((int32_t)((unsigned char)b4))) ^ (int32_t)((unsigned char)ekey->at(ei++)));
        outdata->at(8) = (unsigned char)((int32_t)(iSBox->at((int32_t)(b2 >> 24))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 24)));
        outdata->at(9) = (unsigned char)((int32_t)(iSBox->at((int32_t)((unsigned char)(b1 >> 16)))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 16)));
        outdata->at(10) = (unsigned char)((int32_t)(iSBox->at((int32_t)((unsigned char)(b0 >> 8)))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 8)));
        outdata->at(11) = (unsigned char)((int32_t)(iSBox->at((int32_t)((unsigned char)b5))) ^ (int32_t)((unsigned char)ekey->at(ei++)));
        outdata->at(12) = (unsigned char)((int32_t)(iSBox->at((int32_t)(b3 >> 24))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 24)));
        outdata->at(13) = (unsigned char)((int32_t)(iSBox->at((int32_t)((unsigned char)(b2 >> 16)))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 16)));
        outdata->at(14) = (unsigned char)((int32_t)(iSBox->at((int32_t)((unsigned char)(b1 >> 8)))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 8)));
        outdata->at(15) = (unsigned char)((int32_t)(iSBox->at((int32_t)((unsigned char)b0))) ^ (int32_t)((unsigned char)ekey->at(ei++)));
        outdata->at(16) = (unsigned char)((int32_t)(iSBox->at((int32_t)(b4 >> 24))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 24)));
        outdata->at(17) = (unsigned char)((int32_t)(iSBox->at((int32_t)((unsigned char)(b3 >> 16)))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 16)));
        outdata->at(18) = (unsigned char)((int32_t)(iSBox->at((int32_t)((unsigned char)(b2 >> 8)))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 8)));
        outdata->at(19) = (unsigned char)((int32_t)(iSBox->at((int32_t)((unsigned char)b1))) ^ (int32_t)((unsigned char)ekey->at(ei++)));
        outdata->at(20) = (unsigned char)((int32_t)(iSBox->at((int32_t)(b5 >> 24))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 24)));
        outdata->at(21) = (unsigned char)((int32_t)(iSBox->at((int32_t)((unsigned char)(b4 >> 16)))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 16)));
        outdata->at(22) = (unsigned char)((int32_t)(iSBox->at((int32_t)((unsigned char)(b3 >> 8)))) ^ (int32_t)((unsigned char)(ekey->at(ei) >> 8)));
        outdata->at(23) = (unsigned char)((int32_t)(iSBox->at((int32_t)((unsigned char)b2))) ^ (int32_t)((unsigned char)ekey->at(ei++)));
    }
    
    void RijndaelTransform::Decrypt256(cli::array<unsigned char>* indata, cli::array<unsigned char>* outdata, cli::array<uint32_t>* ekey) {
        uint32_t a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7;
        a0 = ((((((uint32_t)(indata->at(0)) << 24) | ((uint32_t)(indata->at(1)) << 16)) | ((uint32_t)(indata->at(2)) << 8)) | (uint32_t)(indata->at(3))) ^ ekey->at(0));
        a1 = ((((((uint32_t)(indata->at(4)) << 24) | ((uint32_t)(indata->at(5)) << 16)) | ((uint32_t)(indata->at(6)) << 8)) | (uint32_t)(indata->at(7))) ^ ekey->at(1));
        a2 = ((((((uint32_t)(indata->at(8)) << 24) | ((uint32_t)(indata->at(9)) << 16)) | ((uint32_t)(indata->at(10)) << 8)) | (uint32_t)(indata->at(11))) ^ ekey->at(2));
        a3 = ((((((uint32_t)(indata->at(12)) << 24) | ((uint32_t)(indata->at(13)) << 16)) | ((uint32_t)(indata->at(14)) << 8)) | (uint32_t)(indata->at(15))) ^ ekey->at(3));
        a4 = ((((((uint32_t)(indata->at(16)) << 24) | ((uint32_t)(indata->at(17)) << 16)) | ((uint32_t)(indata->at(18)) << 8)) | (uint32_t)(indata->at(19))) ^ ekey->at(4));
        a5 = ((((((uint32_t)(indata->at(20)) << 24) | ((uint32_t)(indata->at(21)) << 16)) | ((uint32_t)(indata->at(22)) << 8)) | (uint32_t)(indata->at(23))) ^ ekey->at(5));
        a6 = ((((((uint32_t)(indata->at(24)) << 24) | ((uint32_t)(indata->at(25)) << 16)) | ((uint32_t)(indata->at(26)) << 8)) | (uint32_t)(indata->at(27))) ^ ekey->at(6));
        a7 = ((((((uint32_t)(indata->at(28)) << 24) | ((uint32_t)(indata->at(29)) << 16)) | ((uint32_t)(indata->at(30)) << 8)) | (uint32_t)(indata->at(31))) ^ ekey->at(7));
        b0 = ((((iT0->at((int32_t)(a0 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a7 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a5 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a4))) ^ ekey->at(8));
        b1 = ((((iT0->at((int32_t)(a1 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a0 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a6 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a5))) ^ ekey->at(9));
        b2 = ((((iT0->at((int32_t)(a2 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a1 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a7 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a6))) ^ ekey->at(10));
        b3 = ((((iT0->at((int32_t)(a3 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a2 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a0 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a7))) ^ ekey->at(11));
        b4 = ((((iT0->at((int32_t)(a4 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a3 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a1 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a0))) ^ ekey->at(12));
        b5 = ((((iT0->at((int32_t)(a5 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a4 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a2 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a1))) ^ ekey->at(13));
        b6 = ((((iT0->at((int32_t)(a6 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a5 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a3 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a2))) ^ ekey->at(14));
        b7 = ((((iT0->at((int32_t)(a7 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a6 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a4 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a3))) ^ ekey->at(15));
        a0 = ((((iT0->at((int32_t)(b0 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b7 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b5 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b4))) ^ ekey->at(16));
        a1 = ((((iT0->at((int32_t)(b1 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b0 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b6 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b5))) ^ ekey->at(17));
        a2 = ((((iT0->at((int32_t)(b2 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b1 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b7 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b6))) ^ ekey->at(18));
        a3 = ((((iT0->at((int32_t)(b3 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b2 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b0 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b7))) ^ ekey->at(19));
        a4 = ((((iT0->at((int32_t)(b4 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b3 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b1 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b0))) ^ ekey->at(20));
        a5 = ((((iT0->at((int32_t)(b5 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b4 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b2 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b1))) ^ ekey->at(21));
        a6 = ((((iT0->at((int32_t)(b6 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b5 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b3 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b2))) ^ ekey->at(22));
        a7 = ((((iT0->at((int32_t)(b7 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b6 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b4 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b3))) ^ ekey->at(23));
        b0 = ((((iT0->at((int32_t)(a0 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a7 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a5 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a4))) ^ ekey->at(24));
        b1 = ((((iT0->at((int32_t)(a1 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a0 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a6 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a5))) ^ ekey->at(25));
        b2 = ((((iT0->at((int32_t)(a2 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a1 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a7 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a6))) ^ ekey->at(26));
        b3 = ((((iT0->at((int32_t)(a3 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a2 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a0 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a7))) ^ ekey->at(27));
        b4 = ((((iT0->at((int32_t)(a4 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a3 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a1 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a0))) ^ ekey->at(28));
        b5 = ((((iT0->at((int32_t)(a5 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a4 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a2 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a1))) ^ ekey->at(29));
        b6 = ((((iT0->at((int32_t)(a6 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a5 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a3 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a2))) ^ ekey->at(30));
        b7 = ((((iT0->at((int32_t)(a7 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a6 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a4 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a3))) ^ ekey->at(31));
        a0 = ((((iT0->at((int32_t)(b0 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b7 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b5 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b4))) ^ ekey->at(32));
        a1 = ((((iT0->at((int32_t)(b1 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b0 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b6 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b5))) ^ ekey->at(33));
        a2 = ((((iT0->at((int32_t)(b2 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b1 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b7 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b6))) ^ ekey->at(34));
        a3 = ((((iT0->at((int32_t)(b3 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b2 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b0 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b7))) ^ ekey->at(35));
        a4 = ((((iT0->at((int32_t)(b4 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b3 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b1 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b0))) ^ ekey->at(36));
        a5 = ((((iT0->at((int32_t)(b5 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b4 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b2 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b1))) ^ ekey->at(37));
        a6 = ((((iT0->at((int32_t)(b6 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b5 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b3 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b2))) ^ ekey->at(38));
        a7 = ((((iT0->at((int32_t)(b7 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b6 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b4 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b3))) ^ ekey->at(39));
        b0 = ((((iT0->at((int32_t)(a0 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a7 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a5 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a4))) ^ ekey->at(40));
        b1 = ((((iT0->at((int32_t)(a1 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a0 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a6 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a5))) ^ ekey->at(41));
        b2 = ((((iT0->at((int32_t)(a2 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a1 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a7 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a6))) ^ ekey->at(42));
        b3 = ((((iT0->at((int32_t)(a3 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a2 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a0 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a7))) ^ ekey->at(43));
        b4 = ((((iT0->at((int32_t)(a4 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a3 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a1 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a0))) ^ ekey->at(44));
        b5 = ((((iT0->at((int32_t)(a5 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a4 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a2 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a1))) ^ ekey->at(45));
        b6 = ((((iT0->at((int32_t)(a6 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a5 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a3 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a2))) ^ ekey->at(46));
        b7 = ((((iT0->at((int32_t)(a7 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a6 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a4 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a3))) ^ ekey->at(47));
        a0 = ((((iT0->at((int32_t)(b0 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b7 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b5 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b4))) ^ ekey->at(48));
        a1 = ((((iT0->at((int32_t)(b1 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b0 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b6 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b5))) ^ ekey->at(49));
        a2 = ((((iT0->at((int32_t)(b2 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b1 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b7 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b6))) ^ ekey->at(50));
        a3 = ((((iT0->at((int32_t)(b3 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b2 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b0 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b7))) ^ ekey->at(51));
        a4 = ((((iT0->at((int32_t)(b4 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b3 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b1 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b0))) ^ ekey->at(52));
        a5 = ((((iT0->at((int32_t)(b5 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b4 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b2 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b1))) ^ ekey->at(53));
        a6 = ((((iT0->at((int32_t)(b6 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b5 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b3 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b2))) ^ ekey->at(54));
        a7 = ((((iT0->at((int32_t)(b7 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b6 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b4 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b3))) ^ ekey->at(55));
        b0 = ((((iT0->at((int32_t)(a0 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a7 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a5 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a4))) ^ ekey->at(56));
        b1 = ((((iT0->at((int32_t)(a1 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a0 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a6 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a5))) ^ ekey->at(57));
        b2 = ((((iT0->at((int32_t)(a2 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a1 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a7 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a6))) ^ ekey->at(58));
        b3 = ((((iT0->at((int32_t)(a3 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a2 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a0 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a7))) ^ ekey->at(59));
        b4 = ((((iT0->at((int32_t)(a4 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a3 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a1 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a0))) ^ ekey->at(60));
        b5 = ((((iT0->at((int32_t)(a5 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a4 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a2 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a1))) ^ ekey->at(61));
        b6 = ((((iT0->at((int32_t)(a6 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a5 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a3 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a2))) ^ ekey->at(62));
        b7 = ((((iT0->at((int32_t)(a7 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a6 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a4 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a3))) ^ ekey->at(63));
        a0 = ((((iT0->at((int32_t)(b0 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b7 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b5 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b4))) ^ ekey->at(64));
        a1 = ((((iT0->at((int32_t)(b1 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b0 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b6 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b5))) ^ ekey->at(65));
        a2 = ((((iT0->at((int32_t)(b2 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b1 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b7 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b6))) ^ ekey->at(66));
        a3 = ((((iT0->at((int32_t)(b3 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b2 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b0 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b7))) ^ ekey->at(67));
        a4 = ((((iT0->at((int32_t)(b4 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b3 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b1 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b0))) ^ ekey->at(68));
        a5 = ((((iT0->at((int32_t)(b5 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b4 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b2 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b1))) ^ ekey->at(69));
        a6 = ((((iT0->at((int32_t)(b6 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b5 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b3 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b2))) ^ ekey->at(70));
        a7 = ((((iT0->at((int32_t)(b7 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b6 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b4 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b3))) ^ ekey->at(71));
        b0 = ((((iT0->at((int32_t)(a0 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a7 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a5 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a4))) ^ ekey->at(72));
        b1 = ((((iT0->at((int32_t)(a1 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a0 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a6 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a5))) ^ ekey->at(73));
        b2 = ((((iT0->at((int32_t)(a2 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a1 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a7 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a6))) ^ ekey->at(74));
        b3 = ((((iT0->at((int32_t)(a3 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a2 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a0 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a7))) ^ ekey->at(75));
        b4 = ((((iT0->at((int32_t)(a4 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a3 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a1 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a0))) ^ ekey->at(76));
        b5 = ((((iT0->at((int32_t)(a5 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a4 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a2 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a1))) ^ ekey->at(77));
        b6 = ((((iT0->at((int32_t)(a6 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a5 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a3 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a2))) ^ ekey->at(78));
        b7 = ((((iT0->at((int32_t)(a7 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a6 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a4 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a3))) ^ ekey->at(79));
        a0 = ((((iT0->at((int32_t)(b0 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b7 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b5 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b4))) ^ ekey->at(80));
        a1 = ((((iT0->at((int32_t)(b1 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b0 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b6 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b5))) ^ ekey->at(81));
        a2 = ((((iT0->at((int32_t)(b2 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b1 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b7 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b6))) ^ ekey->at(82));
        a3 = ((((iT0->at((int32_t)(b3 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b2 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b0 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b7))) ^ ekey->at(83));
        a4 = ((((iT0->at((int32_t)(b4 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b3 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b1 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b0))) ^ ekey->at(84));
        a5 = ((((iT0->at((int32_t)(b5 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b4 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b2 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b1))) ^ ekey->at(85));
        a6 = ((((iT0->at((int32_t)(b6 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b5 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b3 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b2))) ^ ekey->at(86));
        a7 = ((((iT0->at((int32_t)(b7 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b6 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b4 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b3))) ^ ekey->at(87));
        b0 = ((((iT0->at((int32_t)(a0 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a7 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a5 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a4))) ^ ekey->at(88));
        b1 = ((((iT0->at((int32_t)(a1 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a0 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a6 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a5))) ^ ekey->at(89));
        b2 = ((((iT0->at((int32_t)(a2 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a1 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a7 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a6))) ^ ekey->at(90));
        b3 = ((((iT0->at((int32_t)(a3 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a2 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a0 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a7))) ^ ekey->at(91));
        b4 = ((((iT0->at((int32_t)(a4 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a3 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a1 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a0))) ^ ekey->at(92));
        b5 = ((((iT0->at((int32_t)(a5 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a4 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a2 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a1))) ^ ekey->at(93));
        b6 = ((((iT0->at((int32_t)(a6 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a5 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a3 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a2))) ^ ekey->at(94));
        b7 = ((((iT0->at((int32_t)(a7 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a6 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a4 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a3))) ^ ekey->at(95));
        a0 = ((((iT0->at((int32_t)(b0 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b7 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b5 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b4))) ^ ekey->at(96));
        a1 = ((((iT0->at((int32_t)(b1 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b0 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b6 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b5))) ^ ekey->at(97));
        a2 = ((((iT0->at((int32_t)(b2 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b1 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b7 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b6))) ^ ekey->at(98));
        a3 = ((((iT0->at((int32_t)(b3 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b2 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b0 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b7))) ^ ekey->at(99));
        a4 = ((((iT0->at((int32_t)(b4 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b3 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b1 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b0))) ^ ekey->at(100));
        a5 = ((((iT0->at((int32_t)(b5 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b4 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b2 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b1))) ^ ekey->at(101));
        a6 = ((((iT0->at((int32_t)(b6 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b5 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b3 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b2))) ^ ekey->at(102));
        a7 = ((((iT0->at((int32_t)(b7 >> 24)) ^ iT1->at((int32_t)((unsigned char)(b6 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(b4 >> 8)))) ^ iT3->at((int32_t)((unsigned char)b3))) ^ ekey->at(103));
        b0 = ((((iT0->at((int32_t)(a0 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a7 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a5 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a4))) ^ ekey->at(104));
        b1 = ((((iT0->at((int32_t)(a1 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a0 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a6 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a5))) ^ ekey->at(105));
        b2 = ((((iT0->at((int32_t)(a2 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a1 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a7 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a6))) ^ ekey->at(106));
        b3 = ((((iT0->at((int32_t)(a3 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a2 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a0 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a7))) ^ ekey->at(107));
        b4 = ((((iT0->at((int32_t)(a4 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a3 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a1 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a0))) ^ ekey->at(108));
        b5 = ((((iT0->at((int32_t)(a5 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a4 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a2 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a1))) ^ ekey->at(109));
        b6 = ((((iT0->at((int32_t)(a6 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a5 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a3 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a2))) ^ ekey->at(110));
        b7 = ((((iT0->at((int32_t)(a7 >> 24)) ^ iT1->at((int32_t)((unsigned char)(a6 >> 16)))) ^ iT2->at((int32_t)((unsigned char)(a4 >> 8)))) ^ iT3->at((int32_t)((unsigned char)a3))) ^ ekey->at(111));
        outdata->at(0) = (unsigned char)((int32_t)(iSBox->at((int32_t)(b0 >> 24))) ^ (int32_t)((unsigned char)(ekey->at(112) >> 24)));
        outdata->at(1) = (unsigned char)((int32_t)(iSBox->at((int32_t)((unsigned char)(b7 >> 16)))) ^ (int32_t)((unsigned char)(ekey->at(112) >> 16)));
        outdata->at(2) = (unsigned char)((int32_t)(iSBox->at((int32_t)((unsigned char)(b5 >> 8)))) ^ (int32_t)((unsigned char)(ekey->at(112) >> 8)));
        outdata->at(3) = (unsigned char)((int32_t)(iSBox->at((int32_t)((unsigned char)b4))) ^ (int32_t)((unsigned char)ekey->at(112)));
        outdata->at(4) = (unsigned char)((int32_t)(iSBox->at((int32_t)(b1 >> 24))) ^ (int32_t)((unsigned char)(ekey->at(113) >> 24)));
        outdata->at(5) = (unsigned char)((int32_t)(iSBox->at((int32_t)((unsigned char)(b0 >> 16)))) ^ (int32_t)((unsigned char)(ekey->at(113) >> 16)));
        outdata->at(6) = (unsigned char)((int32_t)(iSBox->at((int32_t)((unsigned char)(b6 >> 8)))) ^ (int32_t)((unsigned char)(ekey->at(113) >> 8)));
        outdata->at(7) = (unsigned char)((int32_t)(iSBox->at((int32_t)((unsigned char)b5))) ^ (int32_t)((unsigned char)ekey->at(113)));
        outdata->at(8) = (unsigned char)((int32_t)(iSBox->at((int32_t)(b2 >> 24))) ^ (int32_t)((unsigned char)(ekey->at(114) >> 24)));
        outdata->at(9) = (unsigned char)((int32_t)(iSBox->at((int32_t)((unsigned char)(b1 >> 16)))) ^ (int32_t)((unsigned char)(ekey->at(114) >> 16)));
        outdata->at(10) = (unsigned char)((int32_t)(iSBox->at((int32_t)((unsigned char)(b7 >> 8)))) ^ (int32_t)((unsigned char)(ekey->at(114) >> 8)));
        outdata->at(11) = (unsigned char)((int32_t)(iSBox->at((int32_t)((unsigned char)b6))) ^ (int32_t)((unsigned char)ekey->at(114)));
        outdata->at(12) = (unsigned char)((int32_t)(iSBox->at((int32_t)(b3 >> 24))) ^ (int32_t)((unsigned char)(ekey->at(115) >> 24)));
        outdata->at(13) = (unsigned char)((int32_t)(iSBox->at((int32_t)((unsigned char)(b2 >> 16)))) ^ (int32_t)((unsigned char)(ekey->at(115) >> 16)));
        outdata->at(14) = (unsigned char)((int32_t)(iSBox->at((int32_t)((unsigned char)(b0 >> 8)))) ^ (int32_t)((unsigned char)(ekey->at(115) >> 8)));
        outdata->at(15) = (unsigned char)((int32_t)(iSBox->at((int32_t)((unsigned char)b7))) ^ (int32_t)((unsigned char)ekey->at(115)));
        outdata->at(16) = (unsigned char)((int32_t)(iSBox->at((int32_t)(b4 >> 24))) ^ (int32_t)((unsigned char)(ekey->at(116) >> 24)));
        outdata->at(17) = (unsigned char)((int32_t)(iSBox->at((int32_t)((unsigned char)(b3 >> 16)))) ^ (int32_t)((unsigned char)(ekey->at(116) >> 16)));
        outdata->at(18) = (unsigned char)((int32_t)(iSBox->at((int32_t)((unsigned char)(b1 >> 8)))) ^ (int32_t)((unsigned char)(ekey->at(116) >> 8)));
        outdata->at(19) = (unsigned char)((int32_t)(iSBox->at((int32_t)((unsigned char)b0))) ^ (int32_t)((unsigned char)ekey->at(116)));
        outdata->at(20) = (unsigned char)((int32_t)(iSBox->at((int32_t)(b5 >> 24))) ^ (int32_t)((unsigned char)(ekey->at(117) >> 24)));
        outdata->at(21) = (unsigned char)((int32_t)(iSBox->at((int32_t)((unsigned char)(b4 >> 16)))) ^ (int32_t)((unsigned char)(ekey->at(117) >> 16)));
        outdata->at(22) = (unsigned char)((int32_t)(iSBox->at((int32_t)((unsigned char)(b2 >> 8)))) ^ (int32_t)((unsigned char)(ekey->at(117) >> 8)));
        outdata->at(23) = (unsigned char)((int32_t)(iSBox->at((int32_t)((unsigned char)b1))) ^ (int32_t)((unsigned char)ekey->at(117)));
        outdata->at(24) = (unsigned char)((int32_t)(iSBox->at((int32_t)(b6 >> 24))) ^ (int32_t)((unsigned char)(ekey->at(118) >> 24)));
        outdata->at(25) = (unsigned char)((int32_t)(iSBox->at((int32_t)((unsigned char)(b5 >> 16)))) ^ (int32_t)((unsigned char)(ekey->at(118) >> 16)));
        outdata->at(26) = (unsigned char)((int32_t)(iSBox->at((int32_t)((unsigned char)(b3 >> 8)))) ^ (int32_t)((unsigned char)(ekey->at(118) >> 8)));
        outdata->at(27) = (unsigned char)((int32_t)(iSBox->at((int32_t)((unsigned char)b2))) ^ (int32_t)((unsigned char)ekey->at(118)));
        outdata->at(28) = (unsigned char)((int32_t)(iSBox->at((int32_t)(b7 >> 24))) ^ (int32_t)((unsigned char)(ekey->at(119) >> 24)));
        outdata->at(29) = (unsigned char)((int32_t)(iSBox->at((int32_t)((unsigned char)(b6 >> 16)))) ^ (int32_t)((unsigned char)(ekey->at(119) >> 16)));
        outdata->at(30) = (unsigned char)((int32_t)(iSBox->at((int32_t)((unsigned char)(b4 >> 8)))) ^ (int32_t)((unsigned char)(ekey->at(119) >> 8)));
        outdata->at(31) = (unsigned char)((int32_t)(iSBox->at((int32_t)((unsigned char)b3))) ^ (int32_t)((unsigned char)ekey->at(119)));
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    
    void RijndaelManagedTransform::constructor(Rijndael* algo, bool encryption, cli::array<unsigned char>* key, cli::array<unsigned char>* iv) {
        this->_st = cli::gcnew<RijndaelTransform>(algo, encryption, key, iv);
        this->_bs = algo->get_BlockSize_7a5a96e8187bef27();
    }
    
    void RijndaelManagedTransform::Clear() {
        this->_st->Clear();
    }
    
    void RijndaelManagedTransform::Reset() {
    }
    
    void RijndaelManagedTransform::Dispose() {
        this->_st->Clear();
    }
    
    int32_t RijndaelManagedTransform::TransformBlock(cli::array<unsigned char>* inputBuffer, int32_t inputOffset, int32_t inputCount, cli::array<unsigned char>* outputBuffer, int32_t outputOffset) {
        return this->_st->TransformBlock_ae7940e12ac19b2d(inputBuffer, inputOffset, inputCount, outputBuffer, outputOffset);
    }
    
    cli::array<unsigned char>* RijndaelManagedTransform::TransformFinalBlock(cli::array<unsigned char>* inputBuffer, int32_t inputOffset, int32_t inputCount) {
        return this->_st->TransformFinalBlock_b50acf58c03aba0a(inputBuffer, inputOffset, inputCount);
    }
    
    int32_t RijndaelManagedTransform::get_BlockSizeValue() {
        return this->_bs;
    }
    
    bool RijndaelManagedTransform::get_CanTransformMultipleBlocks() {
        return this->_st->get_CanTransformMultipleBlocks_6ab5f7b44ce018f3();
    }
    
    bool RijndaelManagedTransform::get_CanReuseTransform() {
        return this->_st->get_CanReuseTransform_dc6193f5d984ad67();
    }
    
    int32_t RijndaelManagedTransform::get_InputBlockSize() {
        return this->_st->get_InputBlockSize_ffe7482408103da5();
    }
    
    int32_t RijndaelManagedTransform::get_OutputBlockSize() {
        return this->_st->get_OutputBlockSize_97555d7a856ef43b();
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    
    void RIPEMD160::constructor() {
        this->HashSizeValue = 160;
    }
    
    RIPEMD160* RIPEMD160::Create3() {
        return Create4(_T("System.Security.Cryptography.RIPEMD160"));
    }
    
    RIPEMD160* RIPEMD160::Create4(System::String* hashName) {
        return cli::cast<RIPEMD160*>(CryptoConfig::CreateFromName(hashName));
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    
    void RIPEMD160Managed::constructor() {
        this->_X = (new cli::array<uint32_t>(16));
        this->_HashValue = (new cli::array<uint32_t>(5));
        this->_ProcessingBuffer = (new cli::array<unsigned char>(64));
        RIPEMD160Managed::Initialize_4bdfe3e821ea432();
    }
    
    void RIPEMD160Managed::Finalize_57f0d4252ca69bc() {
        {
            cli::finally_guard([&]() {
                Finalize_b946fbc32e26afd6();
            });
            HashAlgorithm::Dispose_66239c1dbe6eca10(false);
        }
    }
    
    void RIPEMD160Managed::Initialize_4bdfe3e821ea432() {
        this->_HashValue->at(0) = 1732584193U;
        this->_HashValue->at(1) = 4023233417U;
        this->_HashValue->at(2) = 2562383102U;
        this->_HashValue->at(3) = 271733878U;
        this->_HashValue->at(4) = 3285377520U;
        this->_Length = 0UL;
        this->_ProcessingBufferCount = 0;
        System::Array::Clear2(this->_X, 0, this->_X->get_Length());
        System::Array::Clear2(this->_ProcessingBuffer, 0, this->_ProcessingBuffer->get_Length());
    }
    
    void RIPEMD160Managed::HashCore_8c4be9c0eca56be6(cli::array<unsigned char>* rgb, int32_t ibStart, int32_t cbSize) {
        int32_t i;
        this->State = 1;
        (this->_Length = this->_Length + (uint64_t)((uint32_t)cbSize));
        if((this->_ProcessingBufferCount != 0)) 
        {
            if((cbSize < (64 - this->_ProcessingBufferCount))) 
            {
                System::Buffer::BlockCopy(rgb, ibStart, this->_ProcessingBuffer, this->_ProcessingBufferCount, cbSize);
                (this->_ProcessingBufferCount = this->_ProcessingBufferCount + cbSize);
                return;
            }
             else 
            {
                i = (64 - this->_ProcessingBufferCount);
                System::Buffer::BlockCopy(rgb, ibStart, this->_ProcessingBuffer, this->_ProcessingBufferCount, i);
                ProcessBlock(this->_ProcessingBuffer, 0);
                this->_ProcessingBufferCount = 0;
                (ibStart = ibStart + i);
                (cbSize = cbSize - i);
            }
        }
        for(i = 0; (i < (cbSize - (cbSize % 64))); (i = i + 64)){
            ProcessBlock(rgb, (ibStart + i));
        }
        if(((cbSize % 64) != 0)) 
        {
            System::Buffer::BlockCopy(rgb, ((cbSize - (cbSize % 64)) + ibStart), this->_ProcessingBuffer, 0, (cbSize % 64));
            this->_ProcessingBufferCount = (cbSize % 64);
        }
    }
    
    cli::array<unsigned char>* RIPEMD160Managed::HashFinal_58940e7c7f2519b1() {
        CompressFinal(this->_Length);
        cli::array<unsigned char> *hash = (new cli::array<unsigned char>(20));
        if(!(System::BitConverter::IsLittleEndian)) 
        {
            for(int32_t i = 0; (i < 5); i++){
                for(int32_t j = 0; (j < 4); j++){
                    hash->at(((i * 4) + j)) = (unsigned char)(this->_HashValue->at(i) >> ((j * 8) & 31));
                }
            }
        }
         else 
        {
            System::Buffer::BlockCopy(this->_HashValue, 0, hash, 0, 20);
        }
        return hash;
    }
    
    void RIPEMD160Managed::ProcessBlock(cli::array<unsigned char>* buffer, int32_t offset) {
        if(!(System::BitConverter::IsLittleEndian)) 
        {
            for(int32_t i = 0; (i < this->_X->get_Length()); i++){
                this->_X->at(i) = ((((uint32_t)(buffer->at(offset)) | ((uint32_t)(buffer->at((offset + 1))) << 8)) | ((uint32_t)(buffer->at((offset + 2))) << 16)) | ((uint32_t)(buffer->at((offset + 3))) << 24));
                (offset = offset + 4);
            }
        }
         else 
        {
            System::Buffer::BlockCopy(buffer, offset, this->_X, 0, 64);
        }
        Compress();
    }
    
    void RIPEMD160Managed::Compress() {
        uint32_t aa = this->_HashValue->at(0), bb = this->_HashValue->at(1), cc = this->_HashValue->at(2), dd = this->_HashValue->at(3), ee = this->_HashValue->at(4);
        uint32_t aaa = this->_HashValue->at(0), bbb = this->_HashValue->at(1), ccc = this->_HashValue->at(2), ddd = this->_HashValue->at(3), eee = this->_HashValue->at(4);
        FF(aa, bb, cc, dd, ee, this->_X->at(0), 11);
        FF(ee, aa, bb, cc, dd, this->_X->at(1), 14);
        FF(dd, ee, aa, bb, cc, this->_X->at(2), 15);
        FF(cc, dd, ee, aa, bb, this->_X->at(3), 12);
        FF(bb, cc, dd, ee, aa, this->_X->at(4), 5);
        FF(aa, bb, cc, dd, ee, this->_X->at(5), 8);
        FF(ee, aa, bb, cc, dd, this->_X->at(6), 7);
        FF(dd, ee, aa, bb, cc, this->_X->at(7), 9);
        FF(cc, dd, ee, aa, bb, this->_X->at(8), 11);
        FF(bb, cc, dd, ee, aa, this->_X->at(9), 13);
        FF(aa, bb, cc, dd, ee, this->_X->at(10), 14);
        FF(ee, aa, bb, cc, dd, this->_X->at(11), 15);
        FF(dd, ee, aa, bb, cc, this->_X->at(12), 6);
        FF(cc, dd, ee, aa, bb, this->_X->at(13), 7);
        FF(bb, cc, dd, ee, aa, this->_X->at(14), 9);
        FF(aa, bb, cc, dd, ee, this->_X->at(15), 8);
        GG(ee, aa, bb, cc, dd, this->_X->at(7), 7);
        GG(dd, ee, aa, bb, cc, this->_X->at(4), 6);
        GG(cc, dd, ee, aa, bb, this->_X->at(13), 8);
        GG(bb, cc, dd, ee, aa, this->_X->at(1), 13);
        GG(aa, bb, cc, dd, ee, this->_X->at(10), 11);
        GG(ee, aa, bb, cc, dd, this->_X->at(6), 9);
        GG(dd, ee, aa, bb, cc, this->_X->at(15), 7);
        GG(cc, dd, ee, aa, bb, this->_X->at(3), 15);
        GG(bb, cc, dd, ee, aa, this->_X->at(12), 7);
        GG(aa, bb, cc, dd, ee, this->_X->at(0), 12);
        GG(ee, aa, bb, cc, dd, this->_X->at(9), 15);
        GG(dd, ee, aa, bb, cc, this->_X->at(5), 9);
        GG(cc, dd, ee, aa, bb, this->_X->at(2), 11);
        GG(bb, cc, dd, ee, aa, this->_X->at(14), 7);
        GG(aa, bb, cc, dd, ee, this->_X->at(11), 13);
        GG(ee, aa, bb, cc, dd, this->_X->at(8), 12);
        HH(dd, ee, aa, bb, cc, this->_X->at(3), 11);
        HH(cc, dd, ee, aa, bb, this->_X->at(10), 13);
        HH(bb, cc, dd, ee, aa, this->_X->at(14), 6);
        HH(aa, bb, cc, dd, ee, this->_X->at(4), 7);
        HH(ee, aa, bb, cc, dd, this->_X->at(9), 14);
        HH(dd, ee, aa, bb, cc, this->_X->at(15), 9);
        HH(cc, dd, ee, aa, bb, this->_X->at(8), 13);
        HH(bb, cc, dd, ee, aa, this->_X->at(1), 15);
        HH(aa, bb, cc, dd, ee, this->_X->at(2), 14);
        HH(ee, aa, bb, cc, dd, this->_X->at(7), 8);
        HH(dd, ee, aa, bb, cc, this->_X->at(0), 13);
        HH(cc, dd, ee, aa, bb, this->_X->at(6), 6);
        HH(bb, cc, dd, ee, aa, this->_X->at(13), 5);
        HH(aa, bb, cc, dd, ee, this->_X->at(11), 12);
        HH(ee, aa, bb, cc, dd, this->_X->at(5), 7);
        HH(dd, ee, aa, bb, cc, this->_X->at(12), 5);
        II(cc, dd, ee, aa, bb, this->_X->at(1), 11);
        II(bb, cc, dd, ee, aa, this->_X->at(9), 12);
        II(aa, bb, cc, dd, ee, this->_X->at(11), 14);
        II(ee, aa, bb, cc, dd, this->_X->at(10), 15);
        II(dd, ee, aa, bb, cc, this->_X->at(0), 14);
        II(cc, dd, ee, aa, bb, this->_X->at(8), 15);
        II(bb, cc, dd, ee, aa, this->_X->at(12), 9);
        II(aa, bb, cc, dd, ee, this->_X->at(4), 8);
        II(ee, aa, bb, cc, dd, this->_X->at(13), 9);
        II(dd, ee, aa, bb, cc, this->_X->at(3), 14);
        II(cc, dd, ee, aa, bb, this->_X->at(7), 5);
        II(bb, cc, dd, ee, aa, this->_X->at(15), 6);
        II(aa, bb, cc, dd, ee, this->_X->at(14), 8);
        II(ee, aa, bb, cc, dd, this->_X->at(5), 6);
        II(dd, ee, aa, bb, cc, this->_X->at(6), 5);
        II(cc, dd, ee, aa, bb, this->_X->at(2), 12);
        JJ(bb, cc, dd, ee, aa, this->_X->at(4), 9);
        JJ(aa, bb, cc, dd, ee, this->_X->at(0), 15);
        JJ(ee, aa, bb, cc, dd, this->_X->at(5), 5);
        JJ(dd, ee, aa, bb, cc, this->_X->at(9), 11);
        JJ(cc, dd, ee, aa, bb, this->_X->at(7), 6);
        JJ(bb, cc, dd, ee, aa, this->_X->at(12), 8);
        JJ(aa, bb, cc, dd, ee, this->_X->at(2), 13);
        JJ(ee, aa, bb, cc, dd, this->_X->at(10), 12);
        JJ(dd, ee, aa, bb, cc, this->_X->at(14), 5);
        JJ(cc, dd, ee, aa, bb, this->_X->at(1), 12);
        JJ(bb, cc, dd, ee, aa, this->_X->at(3), 13);
        JJ(aa, bb, cc, dd, ee, this->_X->at(8), 14);
        JJ(ee, aa, bb, cc, dd, this->_X->at(11), 11);
        JJ(dd, ee, aa, bb, cc, this->_X->at(6), 8);
        JJ(cc, dd, ee, aa, bb, this->_X->at(15), 5);
        JJ(bb, cc, dd, ee, aa, this->_X->at(13), 6);
        JJJ(aaa, bbb, ccc, ddd, eee, this->_X->at(5), 8);
        JJJ(eee, aaa, bbb, ccc, ddd, this->_X->at(14), 9);
        JJJ(ddd, eee, aaa, bbb, ccc, this->_X->at(7), 9);
        JJJ(ccc, ddd, eee, aaa, bbb, this->_X->at(0), 11);
        JJJ(bbb, ccc, ddd, eee, aaa, this->_X->at(9), 13);
        JJJ(aaa, bbb, ccc, ddd, eee, this->_X->at(2), 15);
        JJJ(eee, aaa, bbb, ccc, ddd, this->_X->at(11), 15);
        JJJ(ddd, eee, aaa, bbb, ccc, this->_X->at(4), 5);
        JJJ(ccc, ddd, eee, aaa, bbb, this->_X->at(13), 7);
        JJJ(bbb, ccc, ddd, eee, aaa, this->_X->at(6), 7);
        JJJ(aaa, bbb, ccc, ddd, eee, this->_X->at(15), 8);
        JJJ(eee, aaa, bbb, ccc, ddd, this->_X->at(8), 11);
        JJJ(ddd, eee, aaa, bbb, ccc, this->_X->at(1), 14);
        JJJ(ccc, ddd, eee, aaa, bbb, this->_X->at(10), 14);
        JJJ(bbb, ccc, ddd, eee, aaa, this->_X->at(3), 12);
        JJJ(aaa, bbb, ccc, ddd, eee, this->_X->at(12), 6);
        III(eee, aaa, bbb, ccc, ddd, this->_X->at(6), 9);
        III(ddd, eee, aaa, bbb, ccc, this->_X->at(11), 13);
        III(ccc, ddd, eee, aaa, bbb, this->_X->at(3), 15);
        III(bbb, ccc, ddd, eee, aaa, this->_X->at(7), 7);
        III(aaa, bbb, ccc, ddd, eee, this->_X->at(0), 12);
        III(eee, aaa, bbb, ccc, ddd, this->_X->at(13), 8);
        III(ddd, eee, aaa, bbb, ccc, this->_X->at(5), 9);
        III(ccc, ddd, eee, aaa, bbb, this->_X->at(10), 11);
        III(bbb, ccc, ddd, eee, aaa, this->_X->at(14), 7);
        III(aaa, bbb, ccc, ddd, eee, this->_X->at(15), 7);
        III(eee, aaa, bbb, ccc, ddd, this->_X->at(8), 12);
        III(ddd, eee, aaa, bbb, ccc, this->_X->at(12), 7);
        III(ccc, ddd, eee, aaa, bbb, this->_X->at(4), 6);
        III(bbb, ccc, ddd, eee, aaa, this->_X->at(9), 15);
        III(aaa, bbb, ccc, ddd, eee, this->_X->at(1), 13);
        III(eee, aaa, bbb, ccc, ddd, this->_X->at(2), 11);
        HHH(ddd, eee, aaa, bbb, ccc, this->_X->at(15), 9);
        HHH(ccc, ddd, eee, aaa, bbb, this->_X->at(5), 7);
        HHH(bbb, ccc, ddd, eee, aaa, this->_X->at(1), 15);
        HHH(aaa, bbb, ccc, ddd, eee, this->_X->at(3), 11);
        HHH(eee, aaa, bbb, ccc, ddd, this->_X->at(7), 8);
        HHH(ddd, eee, aaa, bbb, ccc, this->_X->at(14), 6);
        HHH(ccc, ddd, eee, aaa, bbb, this->_X->at(6), 6);
        HHH(bbb, ccc, ddd, eee, aaa, this->_X->at(9), 14);
        HHH(aaa, bbb, ccc, ddd, eee, this->_X->at(11), 12);
        HHH(eee, aaa, bbb, ccc, ddd, this->_X->at(8), 13);
        HHH(ddd, eee, aaa, bbb, ccc, this->_X->at(12), 5);
        HHH(ccc, ddd, eee, aaa, bbb, this->_X->at(2), 14);
        HHH(bbb, ccc, ddd, eee, aaa, this->_X->at(10), 13);
        HHH(aaa, bbb, ccc, ddd, eee, this->_X->at(0), 13);
        HHH(eee, aaa, bbb, ccc, ddd, this->_X->at(4), 7);
        HHH(ddd, eee, aaa, bbb, ccc, this->_X->at(13), 5);
        GGG(ccc, ddd, eee, aaa, bbb, this->_X->at(8), 15);
        GGG(bbb, ccc, ddd, eee, aaa, this->_X->at(6), 5);
        GGG(aaa, bbb, ccc, ddd, eee, this->_X->at(4), 8);
        GGG(eee, aaa, bbb, ccc, ddd, this->_X->at(1), 11);
        GGG(ddd, eee, aaa, bbb, ccc, this->_X->at(3), 14);
        GGG(ccc, ddd, eee, aaa, bbb, this->_X->at(11), 14);
        GGG(bbb, ccc, ddd, eee, aaa, this->_X->at(15), 6);
        GGG(aaa, bbb, ccc, ddd, eee, this->_X->at(0), 14);
        GGG(eee, aaa, bbb, ccc, ddd, this->_X->at(5), 6);
        GGG(ddd, eee, aaa, bbb, ccc, this->_X->at(12), 9);
        GGG(ccc, ddd, eee, aaa, bbb, this->_X->at(2), 12);
        GGG(bbb, ccc, ddd, eee, aaa, this->_X->at(13), 9);
        GGG(aaa, bbb, ccc, ddd, eee, this->_X->at(9), 12);
        GGG(eee, aaa, bbb, ccc, ddd, this->_X->at(7), 5);
        GGG(ddd, eee, aaa, bbb, ccc, this->_X->at(10), 15);
        GGG(ccc, ddd, eee, aaa, bbb, this->_X->at(14), 8);
        FFF(bbb, ccc, ddd, eee, aaa, this->_X->at(12), 8);
        FFF(aaa, bbb, ccc, ddd, eee, this->_X->at(15), 5);
        FFF(eee, aaa, bbb, ccc, ddd, this->_X->at(10), 12);
        FFF(ddd, eee, aaa, bbb, ccc, this->_X->at(4), 9);
        FFF(ccc, ddd, eee, aaa, bbb, this->_X->at(1), 12);
        FFF(bbb, ccc, ddd, eee, aaa, this->_X->at(5), 5);
        FFF(aaa, bbb, ccc, ddd, eee, this->_X->at(8), 14);
        FFF(eee, aaa, bbb, ccc, ddd, this->_X->at(7), 6);
        FFF(ddd, eee, aaa, bbb, ccc, this->_X->at(6), 8);
        FFF(ccc, ddd, eee, aaa, bbb, this->_X->at(2), 13);
        FFF(bbb, ccc, ddd, eee, aaa, this->_X->at(13), 6);
        FFF(aaa, bbb, ccc, ddd, eee, this->_X->at(14), 5);
        FFF(eee, aaa, bbb, ccc, ddd, this->_X->at(0), 15);
        FFF(ddd, eee, aaa, bbb, ccc, this->_X->at(3), 13);
        FFF(ccc, ddd, eee, aaa, bbb, this->_X->at(9), 11);
        FFF(bbb, ccc, ddd, eee, aaa, this->_X->at(11), 11);
        (ddd = ddd + (cc + this->_HashValue->at(1)));
        this->_HashValue->at(1) = ((this->_HashValue->at(2) + dd) + eee);
        this->_HashValue->at(2) = ((this->_HashValue->at(3) + ee) + aaa);
        this->_HashValue->at(3) = ((this->_HashValue->at(4) + aa) + bbb);
        this->_HashValue->at(4) = ((this->_HashValue->at(0) + bb) + ccc);
        this->_HashValue->at(0) = ddd;
    }
    
    void RIPEMD160Managed::CompressFinal(uint64_t length) {
        uint32_t lswlen = (uint32_t)(length & 4294967295UL);
        uint32_t mswlen = (uint32_t)(length >> 32);
        System::Array::Clear2(this->_X, 0, this->_X->get_Length());
        int32_t ptr = 0;
        for(uint32_t i = 0U; (i < (lswlen & 63U)); i++){
            (this->_X->at((int32_t)(i >> 2)) = this->_X->at((int32_t)(i >> 2)) ^ ((uint32_t)(this->_ProcessingBuffer->at(ptr++)) << ((int32_t)(8U * (i & 3U)) & 31)));
        }
        (this->_X->at((int32_t)((lswlen >> 2) & 15U)) = this->_X->at((int32_t)((lswlen >> 2) & 15U)) ^ (1U << ((int32_t)((8U * (lswlen & 3U)) + 7U) & 31)));
        if(((lswlen & 63U) > 55U)) 
        {
            Compress();
            System::Array::Clear2(this->_X, 0, this->_X->get_Length());
        }
        this->_X->at(14) = (lswlen << 3);
        this->_X->at(15) = ((lswlen >> 29) | (mswlen << 3));
        Compress();
    }
    
    uint32_t RIPEMD160Managed::ROL(uint32_t x, int32_t n) {
        return ((x << (n & 31)) | (x >> ((32 - n) & 31)));
    }
    
    uint32_t RIPEMD160Managed::F(uint32_t x, uint32_t y, uint32_t z) {
        return ((x ^ y) ^ z);
    }
    
    uint32_t RIPEMD160Managed::G(uint32_t x, uint32_t y, uint32_t z) {
        return ((x & y) | (~(x) & z));
    }
    
    uint32_t RIPEMD160Managed::H(uint32_t x, uint32_t y, uint32_t z) {
        return ((x | ~(y)) ^ z);
    }
    
    uint32_t RIPEMD160Managed::I(uint32_t x, uint32_t y, uint32_t z) {
        return ((x & z) | (y & ~(z)));
    }
    
    uint32_t RIPEMD160Managed::J(uint32_t x, uint32_t y, uint32_t z) {
        return (x ^ (y | ~(z)));
    }
    
    void RIPEMD160Managed::FF(uint32_t a, uint32_t b, uint32_t c, uint32_t d, uint32_t e, uint32_t x, int32_t s) {
        (a = a + (F(b, c, d) + x));
        a = (ROL(a, s) + e);
        c = ROL(c, 10);
    }
    
    void RIPEMD160Managed::GG(uint32_t a, uint32_t b, uint32_t c, uint32_t d, uint32_t e, uint32_t x, int32_t s) {
        (a = a + ((G(b, c, d) + x) + 1518500249U));
        a = (ROL(a, s) + e);
        c = ROL(c, 10);
    }
    
    void RIPEMD160Managed::HH(uint32_t a, uint32_t b, uint32_t c, uint32_t d, uint32_t e, uint32_t x, int32_t s) {
        (a = a + ((H(b, c, d) + x) + 1859775393U));
        a = (ROL(a, s) + e);
        c = ROL(c, 10);
    }
    
    void RIPEMD160Managed::II(uint32_t a, uint32_t b, uint32_t c, uint32_t d, uint32_t e, uint32_t x, int32_t s) {
        (a = a + ((I(b, c, d) + x) + 2400959708U));
        a = (ROL(a, s) + e);
        c = ROL(c, 10);
    }
    
    void RIPEMD160Managed::JJ(uint32_t a, uint32_t b, uint32_t c, uint32_t d, uint32_t e, uint32_t x, int32_t s) {
        (a = a + ((J(b, c, d) + x) + 2840853838U));
        a = (ROL(a, s) + e);
        c = ROL(c, 10);
    }
    
    void RIPEMD160Managed::FFF(uint32_t a, uint32_t b, uint32_t c, uint32_t d, uint32_t e, uint32_t x, int32_t s) {
        (a = a + (F(b, c, d) + x));
        a = (ROL(a, s) + e);
        c = ROL(c, 10);
    }
    
    void RIPEMD160Managed::GGG(uint32_t a, uint32_t b, uint32_t c, uint32_t d, uint32_t e, uint32_t x, int32_t s) {
        (a = a + ((G(b, c, d) + x) + 2053994217U));
        a = (ROL(a, s) + e);
        c = ROL(c, 10);
    }
    
    void RIPEMD160Managed::HHH(uint32_t a, uint32_t b, uint32_t c, uint32_t d, uint32_t e, uint32_t x, int32_t s) {
        (a = a + ((H(b, c, d) + x) + 1836072691U));
        a = (ROL(a, s) + e);
        c = ROL(c, 10);
    }
    
    void RIPEMD160Managed::III(uint32_t a, uint32_t b, uint32_t c, uint32_t d, uint32_t e, uint32_t x, int32_t s) {
        (a = a + ((I(b, c, d) + x) + 1548603684U));
        a = (ROL(a, s) + e);
        c = ROL(c, 10);
    }
    
    void RIPEMD160Managed::JJJ(uint32_t a, uint32_t b, uint32_t c, uint32_t d, uint32_t e, uint32_t x, int32_t s) {
        (a = a + ((J(b, c, d) + x) + 1352829926U));
        a = (ROL(a, s) + e);
        c = ROL(c, 10);
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    System::Object*  RNGCryptoServiceProvider::_lock;
    
    RNGCryptoServiceProvider::RNGCryptoServiceProvider()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void RNGCryptoServiceProvider::static_constructor() {
        if(RngOpen()) 
        {
            _lock = cli::gcnew<System::Object>();
        }
    }
    
    void RNGCryptoServiceProvider::constructor() {
        this->_handle = RngInitialize(nullptr);
        Check();
    }
    
    void RNGCryptoServiceProvider::constructor(cli::array<unsigned char>* rgb) {
        this->_handle = RngInitialize(rgb);
        Check();
    }
    
    void RNGCryptoServiceProvider::constructor(CspParameters* cspParams) {
        this->_handle = RngInitialize(nullptr);
        Check();
    }
    
    void RNGCryptoServiceProvider::constructor(System::String* str) {
        if((str ==  nullptr)) 
        {
            this->_handle = RngInitialize(nullptr);
        }
         else 
        {
            this->_handle = RngInitialize(System::Text::Encoding::get_UTF8()->GetBytes_49806e8e98b1c1db(str));
        }
        Check();
    }
    
    void RNGCryptoServiceProvider::Finalize_99656142092ef5a3() {
        {
            cli::finally_guard([&]() {
                Finalize_b946fbc32e26afd6();
            });
            if(::System::IntPtr::op_Inequality(this->_handle, (*::System::IntPtr::Zero))) 
            {
                RngClose(this->_handle);
                this->_handle = (*::System::IntPtr::Zero);
            }
        }
    }
    
    void RNGCryptoServiceProvider::Check() {
        if(::System::IntPtr::op_Equality(this->_handle, (*::System::IntPtr::Zero))) 
        {
            throw cli::gcnew<CryptographicException>(Locale::GetText(_T("Couldn\'t access random source.")));
        }
    }
    
    bool RNGCryptoServiceProvider::RngOpen() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void* RNGCryptoServiceProvider::RngInitialize(cli::array<unsigned char>* seed) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void* RNGCryptoServiceProvider::RngGetBytes(void* handle, cli::array<unsigned char>* data) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void RNGCryptoServiceProvider::RngClose(void* handle) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void RNGCryptoServiceProvider::GetBytes_bf6c3bc1baf70dfd(cli::array<unsigned char>* data) {
        if((data ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("data"));
        }
        if((_lock ==  nullptr)) 
        {
            this->_handle = RngGetBytes(this->_handle, data);
        }
         else 
        {
            {
                cli::lock_guard{_lock};
                this->_handle = RngGetBytes(this->_handle, data);
            }
        }
        Check();
    }
    
    void RNGCryptoServiceProvider::GetNonZeroBytes_eb33fce7e843c67b(cli::array<unsigned char>* data) {
        if((data ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("data"));
        }
        cli::array<unsigned char> *random = (new cli::array<unsigned char>((data->get_Length() * 2)));
        int32_t i = 0;
        while((i < data->get_Length())) {
            this->_handle = RngGetBytes(this->_handle, random);
            Check();
            for(int32_t j = 0; (j < random->get_Length()); j++){
                if((i ==  data->get_Length())) 
                {
                    break;
                }
                if(((int32_t)(random->at(j)) != 0)) 
                {
                    data->at(i++) = random->at(j);
                }
            }
        }
    }
    
    void RNGCryptoServiceProvider::Dispose_322058ebc1ad4f39(bool disposing) {
        RandomNumberGenerator::Dispose_322058ebc1ad4f39(disposing);
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    
    void RSA::constructor() {
    }
    
    RSA* RSA::Create3() {
        return Create4(_T("System.Security.Cryptography.RSA"));
    }
    
    RSA* RSA::Create4(System::String* algName) {
        return cli::cast<RSA*>(CryptoConfig::CreateFromName(algName));
    }
    
    void RSA::ZeroizePrivateKey(RSAParameters parameters) {
        if((parameters->P != nullptr)) 
        {
            System::Array::Clear2(parameters->P, 0, parameters->P->get_Length());
        }
        if((parameters->Q != nullptr)) 
        {
            System::Array::Clear2(parameters->Q, 0, parameters->Q->get_Length());
        }
        if((parameters->DP != nullptr)) 
        {
            System::Array::Clear2(parameters->DP, 0, parameters->DP->get_Length());
        }
        if((parameters->DQ != nullptr)) 
        {
            System::Array::Clear2(parameters->DQ, 0, parameters->DQ->get_Length());
        }
        if((parameters->InverseQ != nullptr)) 
        {
            System::Array::Clear2(parameters->InverseQ, 0, parameters->InverseQ->get_Length());
        }
        if((parameters->D != nullptr)) 
        {
            System::Array::Clear2(parameters->D, 0, parameters->D->get_Length());
        }
    }
    
    void RSA::FromXmlString_ec36cca6166e6990(System::String* xmlString) {
        if((xmlString ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("xmlString"));
        }
        RSAParameters rsaParams = cli::ctor<RSAParameters>();
        try
        {
            cli::finally_guard([&]() {
                ZeroizePrivateKey(rsaParams);
            });
            rsaParams->P = AsymmetricAlgorithm::GetNamedParam(xmlString, _T("P"));
            rsaParams->Q = AsymmetricAlgorithm::GetNamedParam(xmlString, _T("Q"));
            rsaParams->D = AsymmetricAlgorithm::GetNamedParam(xmlString, _T("D"));
            rsaParams->DP = AsymmetricAlgorithm::GetNamedParam(xmlString, _T("DP"));
            rsaParams->DQ = AsymmetricAlgorithm::GetNamedParam(xmlString, _T("DQ"));
            rsaParams->InverseQ = AsymmetricAlgorithm::GetNamedParam(xmlString, _T("InverseQ"));
            rsaParams->Exponent = AsymmetricAlgorithm::GetNamedParam(xmlString, _T("Exponent"));
            rsaParams->Modulus = AsymmetricAlgorithm::GetNamedParam(xmlString, _T("Modulus"));
            ImportParameters_43620ad65e380dd(rsaParams);
        }
        catch(System::Exception* e) {
            ZeroizePrivateKey(rsaParams);
            throw cli::gcnew<CryptographicException>(Locale::GetText(_T("Couldn\'t decode XML")), e);
        }
    }
    
    System::String* RSA::ToXmlString_681b6b8ae145c576(bool includePrivateParameters) {
        System::Text::StringBuilder *sb = cli::gcnew<System::Text::StringBuilder>();
        RSAParameters rsaParams = ExportParameters_f406cf113d936197(includePrivateParameters);
        try {
            sb->Append2(_T("<RSAKeyValue>"));
            sb->Append2(_T("<Modulus>"));
            sb->Append2(System::Convert::ToBase64String(rsaParams->Modulus));
            sb->Append2(_T("</Modulus>"));
            sb->Append2(_T("<Exponent>"));
            sb->Append2(System::Convert::ToBase64String(rsaParams->Exponent));
            sb->Append2(_T("</Exponent>"));
            if(includePrivateParameters) 
            {
                if((rsaParams->D ==  nullptr)) 
                {
                    System::String *msg = Locale::GetText(_T("Missing D parameter for the private key."));
                    throw cli::gcnew<System::ArgumentNullException>(msg);
                }
                 else 
                {
                    if((((((rsaParams->P ==  nullptr) || (rsaParams->Q ==  nullptr)) || (rsaParams->DP ==  nullptr)) || (rsaParams->DQ ==  nullptr)) || (rsaParams->InverseQ ==  nullptr))) 
                    {
                        System::String *msg = Locale::GetText(_T("Missing some CRT parameters for the private key."));
                        throw cli::gcnew<CryptographicException>(msg);
                    }
                }
                sb->Append2(_T("<P>"));
                sb->Append2(System::Convert::ToBase64String(rsaParams->P));
                sb->Append2(_T("</P>"));
                sb->Append2(_T("<Q>"));
                sb->Append2(System::Convert::ToBase64String(rsaParams->Q));
                sb->Append2(_T("</Q>"));
                sb->Append2(_T("<DP>"));
                sb->Append2(System::Convert::ToBase64String(rsaParams->DP));
                sb->Append2(_T("</DP>"));
                sb->Append2(_T("<DQ>"));
                sb->Append2(System::Convert::ToBase64String(rsaParams->DQ));
                sb->Append2(_T("</DQ>"));
                sb->Append2(_T("<InverseQ>"));
                sb->Append2(System::Convert::ToBase64String(rsaParams->InverseQ));
                sb->Append2(_T("</InverseQ>"));
                sb->Append2(_T("<D>"));
                sb->Append2(System::Convert::ToBase64String(rsaParams->D));
                sb->Append2(_T("</D>"));
            }
            sb->Append2(_T("</RSAKeyValue>"));
        }
        catch(...) {
            ZeroizePrivateKey(rsaParams);
            throw ;
        }
        return sb->ToString_1636a0751cb9ac11();
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    bool  RSACryptoServiceProvider::useMachineKeyStore;
    
    RSACryptoServiceProvider::RSACryptoServiceProvider()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void RSACryptoServiceProvider::constructor() {
        Common(1024, nullptr);
    }
    
    void RSACryptoServiceProvider::constructor(CspParameters* parameters) {
        Common(1024, parameters);
    }
    
    void RSACryptoServiceProvider::constructor(int32_t dwKeySize) {
        Common(dwKeySize, nullptr);
    }
    
    void RSACryptoServiceProvider::constructor(int32_t dwKeySize, CspParameters* parameters) {
        Common(dwKeySize, parameters);
    }
    
    void RSACryptoServiceProvider::static_constructor() {
    }
    
    void RSACryptoServiceProvider::Finalize_5e9ea80be174b9c6() {
        {
            cli::finally_guard([&]() {
                Finalize_b946fbc32e26afd6();
            });
            AsymmetricAlgorithm::Dispose_2369c0ba816a26e4(false);
        }
    }
    
    void RSACryptoServiceProvider::Common(int32_t dwKeySize, CspParameters* p) {
        this->LegalKeySizesValue = (new cli::array<KeySizes*>(1));
        this->LegalKeySizesValue->at(0) = cli::gcnew<KeySizes>(384, 16384, 8);
        RSA::set_KeySize_16a33b99cbf5525b(dwKeySize);
        this->rsa = cli::gcnew<Mono::Security::Cryptography::RSAManaged>(this->get_KeySize_6bd474632c551ac());
        this->rsa->add_KeyGenerated(cli::bind(this, &RSACryptoServiceProvider::OnKeyGenerated));
        this->persistKey = (p != nullptr);
        if((p ==  nullptr)) 
        {
            p = cli::gcnew<CspParameters>(1);
            if(useMachineKeyStore) 
            {
                (p->set_Flags((CspProviderFlags)(((int32_t)(p->get_Flags()) | 1))));
            }
            this->store = cli::gcnew<Mono::Security::Cryptography::KeyPairPersistence>(p);
        }
         else 
        {
            this->store = cli::gcnew<Mono::Security::Cryptography::KeyPairPersistence>(p);
            bool exists = this->store->Load();
            bool required = ((int32_t)(((int32_t)(p->get_Flags()) & 8)) != 0);
            if((required && !(exists))) 
            {
                throw cli::gcnew<CryptographicException>(_T("Keyset does not exist"));
            }
            if((this->store->get_KeyValue() != nullptr)) 
            {
                this->persisted = true;
                this->FromXmlString_ec36cca6166e6990(this->store->get_KeyValue());
            }
        }
    }
    
    cli::array<unsigned char>* RSACryptoServiceProvider::Decrypt(cli::array<unsigned char>* rgb, bool fOAEP) {
        if(this->m_disposed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("rsa"));
        }
        AsymmetricKeyExchangeDeformatter *def = nullptr;
        if(fOAEP) 
        {
            def = cli::gcnew<RSAOAEPKeyExchangeDeformatter>(this->rsa);
        }
         else 
        {
            def = cli::gcnew<RSAPKCS1KeyExchangeDeformatter>(this->rsa);
        }
        return def->DecryptKeyExchange_a085cba75fa7b7e8(rgb);
    }
    
    cli::array<unsigned char>* RSACryptoServiceProvider::DecryptValue_e0f03fff133976bf(cli::array<unsigned char>* rgb) {
        if(!(this->rsa->get_IsCrtPossible())) 
        {
            throw cli::gcnew<CryptographicException>(_T("Incomplete private key - missing CRT."));
        }
        return this->rsa->DecryptValue_e0f03fff133976bf(rgb);
    }
    
    cli::array<unsigned char>* RSACryptoServiceProvider::Encrypt(cli::array<unsigned char>* rgb, bool fOAEP) {
        AsymmetricKeyExchangeFormatter *fmt = nullptr;
        if(fOAEP) 
        {
            fmt = cli::gcnew<RSAOAEPKeyExchangeFormatter>(this->rsa);
        }
         else 
        {
            fmt = cli::gcnew<RSAPKCS1KeyExchangeFormatter>(this->rsa);
        }
        return fmt->CreateKeyExchange_57ddeacaf3382dd4(rgb);
    }
    
    cli::array<unsigned char>* RSACryptoServiceProvider::EncryptValue_16a44acec74209ed(cli::array<unsigned char>* rgb) {
        return this->rsa->EncryptValue_16a44acec74209ed(rgb);
    }
    
    RSAParameters RSACryptoServiceProvider::ExportParameters_f406cf113d936197(bool includePrivateParameters) {
        if((includePrivateParameters && !(this->privateKeyExportable))) 
        {
            throw cli::gcnew<CryptographicException>(_T("cannot export private key"));
        }
        return this->rsa->ExportParameters_f406cf113d936197(includePrivateParameters);
    }
    
    void RSACryptoServiceProvider::ImportParameters_43620ad65e380dd(RSAParameters parameters) {
        this->rsa->ImportParameters_43620ad65e380dd(parameters);
    }
    
    HashAlgorithm* RSACryptoServiceProvider::GetHash(System::Object* halg) {
        if((halg ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("halg"));
        }
        HashAlgorithm *hash = nullptr;
        if(cli::is<System::String>(halg)) 
        {
            hash = HashAlgorithm::Create2(cli::cast<System::String*>(halg));
        }
         else 
        {
            if(cli::is<HashAlgorithm>(halg)) 
            {
                hash = cli::cast<HashAlgorithm*>(halg);
            }
             else 
            {
                if(cli::is<System::Type>(halg)) 
                {
                    hash = cli::cast<HashAlgorithm*>(System::Activator::CreateInstance8(cli::cast<System::Type*>(halg)));
                }
                 else 
                {
                    throw cli::gcnew<System::ArgumentException>(_T("halg"));
                }
            }
        }
        return hash;
    }
    
    cli::array<unsigned char>* RSACryptoServiceProvider::SignData(cli::array<unsigned char>* buffer, System::Object* halg) {
        if((buffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("buffer"));
        }
        return SignData3(buffer, 0, buffer->get_Length(), halg);
    }
    
    cli::array<unsigned char>* RSACryptoServiceProvider::SignData2(System::IO::Stream* inputStream, System::Object* halg) {
        HashAlgorithm *hash = GetHash(halg);
        cli::array<unsigned char> *toBeSigned = hash->ComputeHash3(inputStream);
        return Mono::Security::Cryptography::PKCS1::Sign_v15(this, hash, toBeSigned);
    }
    
    cli::array<unsigned char>* RSACryptoServiceProvider::SignData3(cli::array<unsigned char>* buffer, int32_t offset, int32_t count, System::Object* halg) {
        HashAlgorithm *hash = GetHash(halg);
        cli::array<unsigned char> *toBeSigned = hash->ComputeHash2(buffer, offset, count);
        return Mono::Security::Cryptography::PKCS1::Sign_v15(this, hash, toBeSigned);
    }
    
    System::String* RSACryptoServiceProvider::GetHashNameFromOID(System::String* oid) {
        System::String* tmp_521 = oid;
        ::System::Int32 tmp_522 = -1;
        if(::System::String::Equals3(tmp_521, _T("1.3.14.3.2.26"))) tmp_522 = 0;
        if(::System::String::Equals3(tmp_521, _T("1.2.840.113549.2.5"))) tmp_522 = 1;
        if(::System::String::Equals3(tmp_521, _T("2.16.840.1.101.3.4.2.1"))) tmp_522 = 2;
        if(::System::String::Equals3(tmp_521, _T("2.16.840.1.101.3.4.2.2"))) tmp_522 = 3;
        if(::System::String::Equals3(tmp_521, _T("2.16.840.1.101.3.4.2.3"))) tmp_522 = 4;
        switch(tmp_522)
        {
            case 0: case_1669: 
            {
                return _T("SHA1");
            }
            case 1: case_1670: 
            {
                return _T("MD5");
            }
            case 2: case_1671: 
            {
                return _T("SHA256");
            }
            case 3: case_1672: 
            {
                return _T("SHA384");
            }
            case 4: case_1673: 
            {
                return _T("SHA512");
            }
            default: case_1674: 
            {
                throw cli::gcnew<CryptographicException>(cli::concat(oid, _T(" is an unsupported hash algorithm for RSA signing")));
            }
        }
    }
    
    cli::array<unsigned char>* RSACryptoServiceProvider::SignHash(cli::array<unsigned char>* rgbHash, System::String* str) {
        if((rgbHash ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("rgbHash"));
        }
        System::String *hashName = (str ==  nullptr) ? _T("SHA1") : GetHashNameFromOID(str);
        HashAlgorithm *hash = HashAlgorithm::Create2(hashName);
        return Mono::Security::Cryptography::PKCS1::Sign_v15(this, hash, rgbHash);
    }
    
    bool RSACryptoServiceProvider::VerifyData(cli::array<unsigned char>* buffer, System::Object* halg, cli::array<unsigned char>* signature) {
        if((buffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("buffer"));
        }
        if((signature ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("signature"));
        }
        HashAlgorithm *hash = GetHash(halg);
        cli::array<unsigned char> *toBeVerified = hash->ComputeHash(buffer);
        return Mono::Security::Cryptography::PKCS1::Verify_v15(this, hash, toBeVerified, signature);
    }
    
    bool RSACryptoServiceProvider::VerifyHash(cli::array<unsigned char>* rgbHash, System::String* str, cli::array<unsigned char>* rgbSignature) {
        if((rgbHash ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("rgbHash"));
        }
        if((rgbSignature ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("rgbSignature"));
        }
        System::String *hashName = (str ==  nullptr) ? _T("SHA1") : GetHashNameFromOID(str);
        HashAlgorithm *hash = HashAlgorithm::Create2(hashName);
        return Mono::Security::Cryptography::PKCS1::Verify_v15(this, hash, rgbHash, rgbSignature);
    }
    
    void RSACryptoServiceProvider::Dispose_2369c0ba816a26e4(bool disposing) {
        if(!(this->m_disposed)) 
        {
            if((this->persisted && !(this->persistKey))) 
            {
                this->store->Remove();
            }
            if((this->rsa != nullptr)) 
            {
                this->rsa->Clear();
            }
            this->m_disposed = true;
        }
    }
    
    void RSACryptoServiceProvider::OnKeyGenerated(System::Object* sender, System::EventArgs* e) {
        if((this->persistKey && !(this->persisted))) 
        {
            this->store->set_KeyValue(this->ToXmlString_681b6b8ae145c576(!(this->rsa->get_PublicOnly())));
            this->store->Save();
            this->persisted = true;
        }
    }
    
    cli::array<unsigned char>* RSACryptoServiceProvider::ExportCspBlob(bool includePrivateParameters) {
        cli::array<unsigned char> *blob = nullptr;
        if(includePrivateParameters) 
        {
            blob = Mono::Security::Cryptography::CryptoConvert::ToCapiPrivateKeyBlob(this);
        }
         else 
        {
            blob = Mono::Security::Cryptography::CryptoConvert::ToCapiPublicKeyBlob(this);
        }
        blob->at(5) = 164;
        return blob;
    }
    
    void RSACryptoServiceProvider::ImportCspBlob(cli::array<unsigned char>* keyBlob) {
        if((keyBlob ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("keyBlob"));
        }
        RSA *rsa = Mono::Security::Cryptography::CryptoConvert::FromCapiKeyBlob(keyBlob);
        if(cli::is<RSACryptoServiceProvider>(rsa)) 
        {
            RSAParameters rsap = rsa->ExportParameters_f406cf113d936197(!(cli::as<RSACryptoServiceProvider*>(rsa)->get_PublicOnly()));
            RSACryptoServiceProvider::ImportParameters_43620ad65e380dd(rsap);
        }
         else 
        {
            try {
                RSAParameters rsap = rsa->ExportParameters_f406cf113d936197(true);
                RSACryptoServiceProvider::ImportParameters_43620ad65e380dd(rsap);
            }
            catch(...) {
                RSAParameters rsap = rsa->ExportParameters_f406cf113d936197(false);
                RSACryptoServiceProvider::ImportParameters_43620ad65e380dd(rsap);
            }
        }
    }
    
    bool RSACryptoServiceProvider::get_UseMachineKeyStore() {
        return useMachineKeyStore;
    }
    
    bool RSACryptoServiceProvider::set_UseMachineKeyStore(bool value) {
        useMachineKeyStore = value;
        return get_UseMachineKeyStore();
    }
    
    System::String* RSACryptoServiceProvider::get_KeyExchangeAlgorithm_e4956689b1767b62() {
        return _T("RSA-PKCS1-KeyEx");
    }
    
    int32_t RSACryptoServiceProvider::get_KeySize_6bd474632c551ac() {
        if((this->rsa ==  nullptr)) 
        {
            return this->KeySizeValue;
        }
         else 
        {
            return this->rsa->get_KeySize_6bd474632c551ac();
        }
    }
    
    bool RSACryptoServiceProvider::get_PersistKeyInCsp() {
        return this->persistKey;
    }
    
    bool RSACryptoServiceProvider::set_PersistKeyInCsp(bool value) {
        this->persistKey = value;
        if(this->persistKey) 
        {
            OnKeyGenerated(this->rsa, nullptr);
        }
        return get_PersistKeyInCsp();
    }
    
    bool RSACryptoServiceProvider::get_PublicOnly() {
        return this->rsa->get_PublicOnly();
    }
    
    System::String* RSACryptoServiceProvider::get_SignatureAlgorithm_94f2ebe82aebde31() {
        return _T("http://www.w3.org/2000/09/xmldsig#rsa-sha1");
    }
    
    CspKeyContainerInfo* RSACryptoServiceProvider::get_CspKeyContainerInfo() {
        return cli::gcnew<CspKeyContainerInfo>(this->store->get_Parameters());
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    
    void RSAOAEPKeyExchangeDeformatter::constructor() {
    }
    
    void RSAOAEPKeyExchangeDeformatter::constructor(AsymmetricAlgorithm* key) {
        RSAOAEPKeyExchangeDeformatter::SetKey_bd4b3e1db375026(key);
    }
    
    cli::array<unsigned char>* RSAOAEPKeyExchangeDeformatter::DecryptKeyExchange_a085cba75fa7b7e8(cli::array<unsigned char>* rgbData) {
        if((this->rsa ==  nullptr)) 
        {
            System::String *msg = Locale::GetText(_T("No RSA key specified"));
            throw cli::gcnew<CryptographicUnexpectedOperationException>(msg);
        }
        SHA1 *sha1 = SHA1::Create3();
        cli::array<unsigned char> *result = Mono::Security::Cryptography::PKCS1::Decrypt_OAEP(this->rsa, sha1, rgbData);
        if((result != nullptr)) 
        {
            return result;
        }
        throw cli::gcnew<CryptographicException>(Locale::GetText(_T("OAEP decoding error.")));
    }
    
    void RSAOAEPKeyExchangeDeformatter::SetKey_bd4b3e1db375026(AsymmetricAlgorithm* key) {
        this->rsa = cli::cast<RSA*>(key);
    }
    
    System::String* RSAOAEPKeyExchangeDeformatter::get_Parameters_24dbb412163f248d() {
        return nullptr;
    }
    
    System::String* RSAOAEPKeyExchangeDeformatter::set_Parameters_f734d1cc05a7e81b(System::String* value) {;
        return get_Parameters_24dbb412163f248d();
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    
    void RSAOAEPKeyExchangeFormatter::constructor() {
        this->rsa = nullptr;
    }
    
    void RSAOAEPKeyExchangeFormatter::constructor(AsymmetricAlgorithm* key) {
        RSAOAEPKeyExchangeFormatter::SetKey_4186746ff8b83ffd(key);
    }
    
    cli::array<unsigned char>* RSAOAEPKeyExchangeFormatter::CreateKeyExchange_57ddeacaf3382dd4(cli::array<unsigned char>* rgbData) {
        if((this->random ==  nullptr)) 
        {
            this->random = RandomNumberGenerator::Create();
        }
        if((this->rsa ==  nullptr)) 
        {
            System::String *msg = Locale::GetText(_T("No RSA key specified"));
            throw cli::gcnew<CryptographicUnexpectedOperationException>(msg);
        }
        SHA1 *sha1 = SHA1::Create3();
        return Mono::Security::Cryptography::PKCS1::Encrypt_OAEP(this->rsa, sha1, this->random, rgbData);
    }
    
    cli::array<unsigned char>* RSAOAEPKeyExchangeFormatter::CreateKeyExchange_d7106f3b8416be39(cli::array<unsigned char>* rgbData, System::Type* symAlgType) {
        return RSAOAEPKeyExchangeFormatter::CreateKeyExchange_57ddeacaf3382dd4(rgbData);
    }
    
    void RSAOAEPKeyExchangeFormatter::SetKey_4186746ff8b83ffd(AsymmetricAlgorithm* key) {
        this->rsa = cli::cast<RSA*>(key);
    }
    
    cli::array<unsigned char>* RSAOAEPKeyExchangeFormatter::get_Parameter() {
        return this->param;
    }
    
    cli::array<unsigned char>* RSAOAEPKeyExchangeFormatter::set_Parameter(cli::array<unsigned char>* value) {
        this->param = value;
        return get_Parameter();
    }
    
    System::String* RSAOAEPKeyExchangeFormatter::get_Parameters_c99e16816ae9e82d() {
        return nullptr;
    }
    
    RandomNumberGenerator* RSAOAEPKeyExchangeFormatter::get_Rng() {
        return this->random;
    }
    
    RandomNumberGenerator* RSAOAEPKeyExchangeFormatter::set_Rng(RandomNumberGenerator* value) {
        this->random = value;
        return get_Rng();
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    
    void RSAPKCS1KeyExchangeDeformatter::constructor() {
    }
    
    void RSAPKCS1KeyExchangeDeformatter::constructor(AsymmetricAlgorithm* key) {
        RSAPKCS1KeyExchangeDeformatter::SetKey_bd4b3e1db375026(key);
    }
    
    cli::array<unsigned char>* RSAPKCS1KeyExchangeDeformatter::DecryptKeyExchange_a085cba75fa7b7e8(cli::array<unsigned char>* rgbIn) {
        if((this->rsa ==  nullptr)) 
        {
            throw cli::gcnew<CryptographicUnexpectedOperationException>(Locale::GetText(_T("No key pair available.")));
        }
        cli::array<unsigned char> *result = Mono::Security::Cryptography::PKCS1::Decrypt_v15(this->rsa, rgbIn);
        if((result != nullptr)) 
        {
            return result;
        }
        throw cli::gcnew<CryptographicException>(Locale::GetText(_T("PKCS1 decoding error.")));
    }
    
    void RSAPKCS1KeyExchangeDeformatter::SetKey_bd4b3e1db375026(AsymmetricAlgorithm* key) {
        this->rsa = cli::cast<RSA*>(key);
    }
    
    System::String* RSAPKCS1KeyExchangeDeformatter::get_Parameters_24dbb412163f248d() {
        return nullptr;
    }
    
    System::String* RSAPKCS1KeyExchangeDeformatter::set_Parameters_f734d1cc05a7e81b(System::String* value) {;
        return get_Parameters_24dbb412163f248d();
    }
    
    RandomNumberGenerator* RSAPKCS1KeyExchangeDeformatter::get_RNG() {
        return this->random;
    }
    
    RandomNumberGenerator* RSAPKCS1KeyExchangeDeformatter::set_RNG(RandomNumberGenerator* value) {
        this->random = value;
        return get_RNG();
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    
    void RSAPKCS1KeyExchangeFormatter::constructor() {
    }
    
    void RSAPKCS1KeyExchangeFormatter::constructor(AsymmetricAlgorithm* key) {
        SetRSAKey(key);
    }
    
    cli::array<unsigned char>* RSAPKCS1KeyExchangeFormatter::CreateKeyExchange_57ddeacaf3382dd4(cli::array<unsigned char>* rgbData) {
        if((rgbData ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("rgbData"));
        }
        if((this->rsa ==  nullptr)) 
        {
            System::String *msg = Locale::GetText(_T("No RSA key specified"));
            throw cli::gcnew<CryptographicUnexpectedOperationException>(msg);
        }
        if((this->random ==  nullptr)) 
        {
            this->random = RandomNumberGenerator::Create();
        }
        return Mono::Security::Cryptography::PKCS1::Encrypt_v15(this->rsa, this->random, rgbData);
    }
    
    cli::array<unsigned char>* RSAPKCS1KeyExchangeFormatter::CreateKeyExchange_d7106f3b8416be39(cli::array<unsigned char>* rgbData, System::Type* symAlgType) {
        return RSAPKCS1KeyExchangeFormatter::CreateKeyExchange_57ddeacaf3382dd4(rgbData);
    }
    
    void RSAPKCS1KeyExchangeFormatter::SetRSAKey(AsymmetricAlgorithm* key) {
        if((key ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("key"));
        }
        this->rsa = cli::cast<RSA*>(key);
    }
    
    void RSAPKCS1KeyExchangeFormatter::SetKey_4186746ff8b83ffd(AsymmetricAlgorithm* key) {
        SetRSAKey(key);
    }
    
    RandomNumberGenerator* RSAPKCS1KeyExchangeFormatter::get_Rng() {
        return this->random;
    }
    
    RandomNumberGenerator* RSAPKCS1KeyExchangeFormatter::set_Rng(RandomNumberGenerator* value) {
        this->random = value;
        return get_Rng();
    }
    
    System::String* RSAPKCS1KeyExchangeFormatter::get_Parameters_c99e16816ae9e82d() {
        return _T("<enc:KeyEncryptionMethod enc:Algorithm=\"http://www.microsoft.com/xml/security/algorithm/PKCS1-v1.5-KeyEx\" xmlns:enc=\"http://www.microsoft.com/xml/security/encryption/v1.0\" />");
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    
    void RSAPKCS1SignatureDeformatter::constructor() {
    }
    
    void RSAPKCS1SignatureDeformatter::constructor(AsymmetricAlgorithm* key) {
        RSAPKCS1SignatureDeformatter::SetKey_d453955f9571ca18(key);
    }
    
    void RSAPKCS1SignatureDeformatter::SetHashAlgorithm_5a7fb9c08aaf7ac9(System::String* strName) {
        if((strName ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("strName"));
        }
        this->hashName = strName;
    }
    
    void RSAPKCS1SignatureDeformatter::SetKey_d453955f9571ca18(AsymmetricAlgorithm* key) {
        if((key ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("key"));
        }
        this->rsa = cli::cast<RSA*>(key);
    }
    
    bool RSAPKCS1SignatureDeformatter::VerifySignature_ecf649797288645c(cli::array<unsigned char>* rgbHash, cli::array<unsigned char>* rgbSignature) {
        if((this->rsa ==  nullptr)) 
        {
            throw cli::gcnew<CryptographicUnexpectedOperationException>(Locale::GetText(_T("No public key available.")));
        }
        if((this->hashName ==  nullptr)) 
        {
            throw cli::gcnew<CryptographicUnexpectedOperationException>(Locale::GetText(_T("Missing hash algorithm.")));
        }
        if((rgbHash ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("rgbHash"));
        }
        if((rgbSignature ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("rgbSignature"));
        }
        return Mono::Security::Cryptography::PKCS1::Verify_v15(this->rsa, HashAlgorithm::Create2(this->hashName), rgbHash, rgbSignature);
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    
    void RSAPKCS1SignatureFormatter::constructor() {
    }
    
    void RSAPKCS1SignatureFormatter::constructor(AsymmetricAlgorithm* key) {
        RSAPKCS1SignatureFormatter::SetKey_1b1967336b333b5c(key);
    }
    
    cli::array<unsigned char>* RSAPKCS1SignatureFormatter::CreateSignature_119f8aceb75b0d2(cli::array<unsigned char>* rgbHash) {
        if((this->rsa ==  nullptr)) 
        {
            throw cli::gcnew<CryptographicUnexpectedOperationException>(Locale::GetText(_T("No key pair available.")));
        }
        if((this->hash ==  nullptr)) 
        {
            throw cli::gcnew<CryptographicUnexpectedOperationException>(Locale::GetText(_T("Missing hash algorithm.")));
        }
        if((rgbHash ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("rgbHash"));
        }
        return Mono::Security::Cryptography::PKCS1::Sign_v15(this->rsa, this->hash, rgbHash);
    }
    
    void RSAPKCS1SignatureFormatter::SetHashAlgorithm_9029a89c4cb706ce(System::String* strName) {
        this->hash = HashAlgorithm::Create2(strName);
    }
    
    void RSAPKCS1SignatureFormatter::SetKey_1b1967336b333b5c(AsymmetricAlgorithm* key) {
        if((key ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("key"));
        }
        this->rsa = cli::cast<RSA*>(key);
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    
    void SHA1::constructor() {
        this->HashSizeValue = 160;
    }
    
    SHA1* SHA1::Create3() {
        return Create4(_T("System.Security.Cryptography.SHA1"));
    }
    
    SHA1* SHA1::Create4(System::String* hashName) {
        return cli::cast<SHA1*>(CryptoConfig::CreateFromName(hashName));
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    
    void SHA1Internal::constructor() {
        this->_H = (new cli::array<uint32_t>(5));
        this->_ProcessingBuffer = (new cli::array<unsigned char>(64));
        this->buff = (new cli::array<uint32_t>(80));
        Initialize();
    }
    
    void SHA1Internal::HashCore(cli::array<unsigned char>* rgb, int32_t ibStart, int32_t cbSize) {
        int32_t i;
        if((this->_ProcessingBufferCount != 0)) 
        {
            if((cbSize < (64 - this->_ProcessingBufferCount))) 
            {
                System::Buffer::BlockCopy(rgb, ibStart, this->_ProcessingBuffer, this->_ProcessingBufferCount, cbSize);
                (this->_ProcessingBufferCount = this->_ProcessingBufferCount + cbSize);
                return;
            }
             else 
            {
                i = (64 - this->_ProcessingBufferCount);
                System::Buffer::BlockCopy(rgb, ibStart, this->_ProcessingBuffer, this->_ProcessingBufferCount, i);
                ProcessBlock(this->_ProcessingBuffer, 0U);
                this->_ProcessingBufferCount = 0;
                (ibStart = ibStart + i);
                (cbSize = cbSize - i);
            }
        }
        for(i = 0; (i < (cbSize - (cbSize % 64))); (i = i + 64)){
            ProcessBlock(rgb, (uint32_t)(ibStart + i));
        }
        if(((cbSize % 64) != 0)) 
        {
            System::Buffer::BlockCopy(rgb, ((cbSize - (cbSize % 64)) + ibStart), this->_ProcessingBuffer, 0, (cbSize % 64));
            this->_ProcessingBufferCount = (cbSize % 64);
        }
    }
    
    cli::array<unsigned char>* SHA1Internal::HashFinal() {
        cli::array<unsigned char> *hash = (new cli::array<unsigned char>(20));
        ProcessFinalBlock(this->_ProcessingBuffer, 0, this->_ProcessingBufferCount);
        for(int32_t i = 0; (i < 5); i++){
            for(int32_t j = 0; (j < 4); j++){
                hash->at(((i * 4) + j)) = (unsigned char)(this->_H->at(i) >> ((8 * (3 - j)) & 31));
            }
        }
        return hash;
    }
    
    void SHA1Internal::Initialize() {
        this->count = 0UL;
        this->_ProcessingBufferCount = 0;
        this->_H->at(0) = 1732584193U;
        this->_H->at(1) = 4023233417U;
        this->_H->at(2) = 2562383102U;
        this->_H->at(3) = 271733878U;
        this->_H->at(4) = 3285377520U;
    }
    
    void SHA1Internal::ProcessBlock(cli::array<unsigned char>* inputBuffer, uint32_t inputOffset) {
        uint32_t a, b, c, d, e;
        (this->count = this->count + 64UL);
        cli::array<uint32_t> *_H = this->_H;
        cli::array<uint32_t> *buff = this->buff;
        InitialiseBuff(buff, inputBuffer, inputOffset);
        FillBuff(buff);
        a = _H->at(0);
        b = _H->at(1);
        c = _H->at(2);
        d = _H->at(3);
        e = _H->at(4);
        int32_t i = 0;
        while((i < 20)) {
            (e = e + (((((a << 5) | (a >> 27)) + (((c ^ d) & b) ^ d)) + 1518500249U) + buff->at(i)));
            b = ((b << 30) | (b >> 2));
            (d = d + (((((e << 5) | (e >> 27)) + (((b ^ c) & a) ^ c)) + 1518500249U) + buff->at((i + 1))));
            a = ((a << 30) | (a >> 2));
            (c = c + (((((d << 5) | (d >> 27)) + (((a ^ b) & e) ^ b)) + 1518500249U) + buff->at((i + 2))));
            e = ((e << 30) | (e >> 2));
            (b = b + (((((c << 5) | (c >> 27)) + (((e ^ a) & d) ^ a)) + 1518500249U) + buff->at((i + 3))));
            d = ((d << 30) | (d >> 2));
            (a = a + (((((b << 5) | (b >> 27)) + (((d ^ e) & c) ^ e)) + 1518500249U) + buff->at((i + 4))));
            c = ((c << 30) | (c >> 2));
            (i = i + 5);
        }
        while((i < 40)) {
            (e = e + (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 1859775393U) + buff->at(i)));
            b = ((b << 30) | (b >> 2));
            (d = d + (((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 1859775393U) + buff->at((i + 1))));
            a = ((a << 30) | (a >> 2));
            (c = c + (((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 1859775393U) + buff->at((i + 2))));
            e = ((e << 30) | (e >> 2));
            (b = b + (((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 1859775393U) + buff->at((i + 3))));
            d = ((d << 30) | (d >> 2));
            (a = a + (((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 1859775393U) + buff->at((i + 4))));
            c = ((c << 30) | (c >> 2));
            (i = i + 5);
        }
        while((i < 60)) {
            (e = e + (((((a << 5) | (a >> 27)) + (((b & c) | (b & d)) | (c & d))) + 2400959708U) + buff->at(i)));
            b = ((b << 30) | (b >> 2));
            (d = d + (((((e << 5) | (e >> 27)) + (((a & b) | (a & c)) | (b & c))) + 2400959708U) + buff->at((i + 1))));
            a = ((a << 30) | (a >> 2));
            (c = c + (((((d << 5) | (d >> 27)) + (((e & a) | (e & b)) | (a & b))) + 2400959708U) + buff->at((i + 2))));
            e = ((e << 30) | (e >> 2));
            (b = b + (((((c << 5) | (c >> 27)) + (((d & e) | (d & a)) | (e & a))) + 2400959708U) + buff->at((i + 3))));
            d = ((d << 30) | (d >> 2));
            (a = a + (((((b << 5) | (b >> 27)) + (((c & d) | (c & e)) | (d & e))) + 2400959708U) + buff->at((i + 4))));
            c = ((c << 30) | (c >> 2));
            (i = i + 5);
        }
        while((i < 80)) {
            (e = e + (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 3395469782U) + buff->at(i)));
            b = ((b << 30) | (b >> 2));
            (d = d + (((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 3395469782U) + buff->at((i + 1))));
            a = ((a << 30) | (a >> 2));
            (c = c + (((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 3395469782U) + buff->at((i + 2))));
            e = ((e << 30) | (e >> 2));
            (b = b + (((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 3395469782U) + buff->at((i + 3))));
            d = ((d << 30) | (d >> 2));
            (a = a + (((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 3395469782U) + buff->at((i + 4))));
            c = ((c << 30) | (c >> 2));
            (i = i + 5);
        }
        (_H->at(0) = _H->at(0) + a);
        (_H->at(1) = _H->at(1) + b);
        (_H->at(2) = _H->at(2) + c);
        (_H->at(3) = _H->at(3) + d);
        (_H->at(4) = _H->at(4) + e);
    }
    
    void SHA1Internal::InitialiseBuff(cli::array<uint32_t>* buff, cli::array<unsigned char>* input, uint32_t inputOffset) {
        buff->at(0) = (uint32_t)(((((int32_t)(input->at((int32_t)inputOffset)) << 24) | ((int32_t)(input->at((int32_t)(inputOffset + 1U))) << 16)) | ((int32_t)(input->at((int32_t)(inputOffset + 2U))) << 8)) | (int32_t)(input->at((int32_t)(inputOffset + 3U))));
        buff->at(1) = (uint32_t)(((((int32_t)(input->at((int32_t)(inputOffset + 4U))) << 24) | ((int32_t)(input->at((int32_t)(inputOffset + 5U))) << 16)) | ((int32_t)(input->at((int32_t)(inputOffset + 6U))) << 8)) | (int32_t)(input->at((int32_t)(inputOffset + 7U))));
        buff->at(2) = (uint32_t)(((((int32_t)(input->at((int32_t)(inputOffset + 8U))) << 24) | ((int32_t)(input->at((int32_t)(inputOffset + 9U))) << 16)) | ((int32_t)(input->at((int32_t)(inputOffset + 10U))) << 8)) | (int32_t)(input->at((int32_t)(inputOffset + 11U))));
        buff->at(3) = (uint32_t)(((((int32_t)(input->at((int32_t)(inputOffset + 12U))) << 24) | ((int32_t)(input->at((int32_t)(inputOffset + 13U))) << 16)) | ((int32_t)(input->at((int32_t)(inputOffset + 14U))) << 8)) | (int32_t)(input->at((int32_t)(inputOffset + 15U))));
        buff->at(4) = (uint32_t)(((((int32_t)(input->at((int32_t)(inputOffset + 16U))) << 24) | ((int32_t)(input->at((int32_t)(inputOffset + 17U))) << 16)) | ((int32_t)(input->at((int32_t)(inputOffset + 18U))) << 8)) | (int32_t)(input->at((int32_t)(inputOffset + 19U))));
        buff->at(5) = (uint32_t)(((((int32_t)(input->at((int32_t)(inputOffset + 20U))) << 24) | ((int32_t)(input->at((int32_t)(inputOffset + 21U))) << 16)) | ((int32_t)(input->at((int32_t)(inputOffset + 22U))) << 8)) | (int32_t)(input->at((int32_t)(inputOffset + 23U))));
        buff->at(6) = (uint32_t)(((((int32_t)(input->at((int32_t)(inputOffset + 24U))) << 24) | ((int32_t)(input->at((int32_t)(inputOffset + 25U))) << 16)) | ((int32_t)(input->at((int32_t)(inputOffset + 26U))) << 8)) | (int32_t)(input->at((int32_t)(inputOffset + 27U))));
        buff->at(7) = (uint32_t)(((((int32_t)(input->at((int32_t)(inputOffset + 28U))) << 24) | ((int32_t)(input->at((int32_t)(inputOffset + 29U))) << 16)) | ((int32_t)(input->at((int32_t)(inputOffset + 30U))) << 8)) | (int32_t)(input->at((int32_t)(inputOffset + 31U))));
        buff->at(8) = (uint32_t)(((((int32_t)(input->at((int32_t)(inputOffset + 32U))) << 24) | ((int32_t)(input->at((int32_t)(inputOffset + 33U))) << 16)) | ((int32_t)(input->at((int32_t)(inputOffset + 34U))) << 8)) | (int32_t)(input->at((int32_t)(inputOffset + 35U))));
        buff->at(9) = (uint32_t)(((((int32_t)(input->at((int32_t)(inputOffset + 36U))) << 24) | ((int32_t)(input->at((int32_t)(inputOffset + 37U))) << 16)) | ((int32_t)(input->at((int32_t)(inputOffset + 38U))) << 8)) | (int32_t)(input->at((int32_t)(inputOffset + 39U))));
        buff->at(10) = (uint32_t)(((((int32_t)(input->at((int32_t)(inputOffset + 40U))) << 24) | ((int32_t)(input->at((int32_t)(inputOffset + 41U))) << 16)) | ((int32_t)(input->at((int32_t)(inputOffset + 42U))) << 8)) | (int32_t)(input->at((int32_t)(inputOffset + 43U))));
        buff->at(11) = (uint32_t)(((((int32_t)(input->at((int32_t)(inputOffset + 44U))) << 24) | ((int32_t)(input->at((int32_t)(inputOffset + 45U))) << 16)) | ((int32_t)(input->at((int32_t)(inputOffset + 46U))) << 8)) | (int32_t)(input->at((int32_t)(inputOffset + 47U))));
        buff->at(12) = (uint32_t)(((((int32_t)(input->at((int32_t)(inputOffset + 48U))) << 24) | ((int32_t)(input->at((int32_t)(inputOffset + 49U))) << 16)) | ((int32_t)(input->at((int32_t)(inputOffset + 50U))) << 8)) | (int32_t)(input->at((int32_t)(inputOffset + 51U))));
        buff->at(13) = (uint32_t)(((((int32_t)(input->at((int32_t)(inputOffset + 52U))) << 24) | ((int32_t)(input->at((int32_t)(inputOffset + 53U))) << 16)) | ((int32_t)(input->at((int32_t)(inputOffset + 54U))) << 8)) | (int32_t)(input->at((int32_t)(inputOffset + 55U))));
        buff->at(14) = (uint32_t)(((((int32_t)(input->at((int32_t)(inputOffset + 56U))) << 24) | ((int32_t)(input->at((int32_t)(inputOffset + 57U))) << 16)) | ((int32_t)(input->at((int32_t)(inputOffset + 58U))) << 8)) | (int32_t)(input->at((int32_t)(inputOffset + 59U))));
        buff->at(15) = (uint32_t)(((((int32_t)(input->at((int32_t)(inputOffset + 60U))) << 24) | ((int32_t)(input->at((int32_t)(inputOffset + 61U))) << 16)) | ((int32_t)(input->at((int32_t)(inputOffset + 62U))) << 8)) | (int32_t)(input->at((int32_t)(inputOffset + 63U))));
    }
    
    void SHA1Internal::FillBuff(cli::array<uint32_t>* buff) {
        uint32_t val;
        for(int32_t i = 16; (i < 80); (i = i + 8)){
            val = (((buff->at((i - 3)) ^ buff->at((i - 8))) ^ buff->at((i - 14))) ^ buff->at((i - 16)));
            buff->at(i) = ((val << 1) | (val >> 31));
            val = (((buff->at((i - 2)) ^ buff->at((i - 7))) ^ buff->at((i - 13))) ^ buff->at((i - 15)));
            buff->at((i + 1)) = ((val << 1) | (val >> 31));
            val = (((buff->at((i - 1)) ^ buff->at((i - 6))) ^ buff->at((i - 12))) ^ buff->at((i - 14)));
            buff->at((i + 2)) = ((val << 1) | (val >> 31));
            val = (((buff->at(i) ^ buff->at((i - 5))) ^ buff->at((i - 11))) ^ buff->at((i - 13)));
            buff->at((i + 3)) = ((val << 1) | (val >> 31));
            val = (((buff->at((i + 1)) ^ buff->at((i - 4))) ^ buff->at((i - 10))) ^ buff->at((i - 12)));
            buff->at((i + 4)) = ((val << 1) | (val >> 31));
            val = (((buff->at((i + 2)) ^ buff->at((i - 3))) ^ buff->at((i - 9))) ^ buff->at((i - 11)));
            buff->at((i + 5)) = ((val << 1) | (val >> 31));
            val = (((buff->at((i + 3)) ^ buff->at((i - 2))) ^ buff->at((i - 8))) ^ buff->at((i - 10)));
            buff->at((i + 6)) = ((val << 1) | (val >> 31));
            val = (((buff->at((i + 4)) ^ buff->at((i - 1))) ^ buff->at((i - 7))) ^ buff->at((i - 9)));
            buff->at((i + 7)) = ((val << 1) | (val >> 31));
        }
    }
    
    void SHA1Internal::ProcessFinalBlock(cli::array<unsigned char>* inputBuffer, int32_t inputOffset, int32_t inputCount) {
        uint64_t total = (this->count + (uint64_t)inputCount);
        int32_t paddingSize = (56 - (int32_t)(total % 64UL));
        if((paddingSize < 1)) 
        {
            (paddingSize = paddingSize + 64);
        }
        int32_t length = ((inputCount + paddingSize) + 8);
        cli::array<unsigned char> *fooBuffer = (length ==  64) ? this->_ProcessingBuffer : (new cli::array<unsigned char>(length));
        for(int32_t i = 0; (i < inputCount); i++){
            fooBuffer->at(i) = inputBuffer->at((i + inputOffset));
        }
        fooBuffer->at(inputCount) = 128;
        for(int32_t i = (inputCount + 1); (i < (inputCount + paddingSize)); i++){
            fooBuffer->at(i) = 0;
        }
        uint64_t size = (total << 3);
        AddLength(size, fooBuffer, (inputCount + paddingSize));
        ProcessBlock(fooBuffer, 0U);
        if((length ==  128)) 
        {
            ProcessBlock(fooBuffer, 64U);
        }
    }
    
    void SHA1Internal::AddLength(uint64_t length, cli::array<unsigned char>* buffer, int32_t position) {
        buffer->at(position++) = (unsigned char)(length >> 56);
        buffer->at(position++) = (unsigned char)(length >> 48);
        buffer->at(position++) = (unsigned char)(length >> 40);
        buffer->at(position++) = (unsigned char)(length >> 32);
        buffer->at(position++) = (unsigned char)(length >> 24);
        buffer->at(position++) = (unsigned char)(length >> 16);
        buffer->at(position++) = (unsigned char)(length >> 8);
        buffer->at(position) = (unsigned char)length;
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    
    void SHA1CryptoServiceProvider::constructor() {
        this->sha = cli::gcnew<SHA1Internal>();
    }
    
    void SHA1CryptoServiceProvider::Finalize_62c720bdfe815947() {
        {
            cli::finally_guard([&]() {
                Finalize_b946fbc32e26afd6();
            });
            HashAlgorithm::Dispose_66239c1dbe6eca10(false);
        }
    }
    
    void SHA1CryptoServiceProvider::Dispose_66239c1dbe6eca10(bool disposing) {
        SHA1::Dispose_66239c1dbe6eca10(disposing);
    }
    
    void SHA1CryptoServiceProvider::HashCore_8c4be9c0eca56be6(cli::array<unsigned char>* rgb, int32_t ibStart, int32_t cbSize) {
        this->State = 1;
        this->sha->HashCore(rgb, ibStart, cbSize);
    }
    
    cli::array<unsigned char>* SHA1CryptoServiceProvider::HashFinal_58940e7c7f2519b1() {
        this->State = 0;
        return this->sha->HashFinal();
    }
    
    void SHA1CryptoServiceProvider::Initialize_4bdfe3e821ea432() {
        this->sha->Initialize();
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    
    void SHA1Managed::constructor() {
        this->sha = cli::gcnew<SHA1Internal>();
    }
    
    void SHA1Managed::HashCore_8c4be9c0eca56be6(cli::array<unsigned char>* rgb, int32_t ibStart, int32_t cbSize) {
        this->State = 1;
        this->sha->HashCore(rgb, ibStart, cbSize);
    }
    
    cli::array<unsigned char>* SHA1Managed::HashFinal_58940e7c7f2519b1() {
        this->State = 0;
        return this->sha->HashFinal();
    }
    
    void SHA1Managed::Initialize_4bdfe3e821ea432() {
        this->sha->Initialize();
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    
    void SHA256::constructor() {
        this->HashSizeValue = 256;
    }
    
    SHA256* SHA256::Create3() {
        return Create4(_T("System.Security.Cryptography.SHA256"));
    }
    
    SHA256* SHA256::Create4(System::String* hashName) {
        return cli::cast<SHA256*>(CryptoConfig::CreateFromName(hashName));
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    
    void SHA256Managed::constructor() {
        this->_H = (new cli::array<uint32_t>(8));
        this->_ProcessingBuffer = (new cli::array<unsigned char>(64));
        this->buff = (new cli::array<uint32_t>(64));
        SHA256Managed::Initialize_4bdfe3e821ea432();
    }
    
    void SHA256Managed::HashCore_8c4be9c0eca56be6(cli::array<unsigned char>* rgb, int32_t ibStart, int32_t cbSize) {
        int32_t i;
        this->State = 1;
        if((this->_ProcessingBufferCount != 0)) 
        {
            if((cbSize < (64 - this->_ProcessingBufferCount))) 
            {
                System::Buffer::BlockCopy(rgb, ibStart, this->_ProcessingBuffer, this->_ProcessingBufferCount, cbSize);
                (this->_ProcessingBufferCount = this->_ProcessingBufferCount + cbSize);
                return;
            }
             else 
            {
                i = (64 - this->_ProcessingBufferCount);
                System::Buffer::BlockCopy(rgb, ibStart, this->_ProcessingBuffer, this->_ProcessingBufferCount, i);
                ProcessBlock(this->_ProcessingBuffer, 0);
                this->_ProcessingBufferCount = 0;
                (ibStart = ibStart + i);
                (cbSize = cbSize - i);
            }
        }
        for(i = 0; (i < (cbSize - (cbSize % 64))); (i = i + 64)){
            ProcessBlock(rgb, (ibStart + i));
        }
        if(((cbSize % 64) != 0)) 
        {
            System::Buffer::BlockCopy(rgb, ((cbSize - (cbSize % 64)) + ibStart), this->_ProcessingBuffer, 0, (cbSize % 64));
            this->_ProcessingBufferCount = (cbSize % 64);
        }
    }
    
    cli::array<unsigned char>* SHA256Managed::HashFinal_58940e7c7f2519b1() {
        cli::array<unsigned char> *hash = (new cli::array<unsigned char>(32));
        int32_t i, j;
        ProcessFinalBlock(this->_ProcessingBuffer, 0, this->_ProcessingBufferCount);
        for(i = 0; (i < 8); i++){
            for(j = 0; (j < 4); j++){
                hash->at(((i * 4) + j)) = (unsigned char)(this->_H->at(i) >> ((24 - (j * 8)) & 31));
            }
        }
        this->State = 0;
        return hash;
    }
    
    void SHA256Managed::Initialize_4bdfe3e821ea432() {
        this->count = 0UL;
        this->_ProcessingBufferCount = 0;
        this->_H->at(0) = 1779033703U;
        this->_H->at(1) = 3144134277U;
        this->_H->at(2) = 1013904242U;
        this->_H->at(3) = 2773480762U;
        this->_H->at(4) = 1359893119U;
        this->_H->at(5) = 2600822924U;
        this->_H->at(6) = 528734635U;
        this->_H->at(7) = 1541459225U;
    }
    
    void SHA256Managed::ProcessBlock(cli::array<unsigned char>* inputBuffer, int32_t inputOffset) {
        uint32_t a, b, c, d, e, f, g, h;
        uint32_t t1, t2;
        int32_t i;
        cli::array<uint32_t> *K1 = SHAConstants::K1;
        cli::array<uint32_t> *buff = this->buff;
        (this->count = this->count + 64UL);
        for(i = 0; (i < 16); i++){
            buff->at(i) = (uint32_t)(((((int32_t)(inputBuffer->at((inputOffset + (4 * i)))) << 24) | ((int32_t)(inputBuffer->at(((inputOffset + (4 * i)) + 1))) << 16)) | ((int32_t)(inputBuffer->at(((inputOffset + (4 * i)) + 2))) << 8)) | (int32_t)(inputBuffer->at(((inputOffset + (4 * i)) + 3))));
        }
        for(i = 16; (i < 64); i++){
            t1 = buff->at((i - 15));
            t1 = ((((t1 >> 7) | (t1 << 25)) ^ ((t1 >> 18) | (t1 << 14))) ^ (t1 >> 3));
            t2 = buff->at((i - 2));
            t2 = ((((t2 >> 17) | (t2 << 15)) ^ ((t2 >> 19) | (t2 << 13))) ^ (t2 >> 10));
            buff->at(i) = (((t2 + buff->at((i - 7))) + t1) + buff->at((i - 16)));
        }
        a = this->_H->at(0);
        b = this->_H->at(1);
        c = this->_H->at(2);
        d = this->_H->at(3);
        e = this->_H->at(4);
        f = this->_H->at(5);
        g = this->_H->at(6);
        h = this->_H->at(7);
        for(i = 0; (i < 64); i++){
            t1 = ((((h + ((((e >> 6) | (e << 26)) ^ ((e >> 11) | (e << 21))) ^ ((e >> 25) | (e << 7)))) + ((e & f) ^ (~(e) & g))) + K1->at(i)) + buff->at(i));
            t2 = ((((a >> 2) | (a << 30)) ^ ((a >> 13) | (a << 19))) ^ ((a >> 22) | (a << 10)));
            t2 = (t2 + (((a & b) ^ (a & c)) ^ (b & c)));
            h = g;
            g = f;
            f = e;
            e = (d + t1);
            d = c;
            c = b;
            b = a;
            a = (t1 + t2);
        }
        (this->_H->at(0) = this->_H->at(0) + a);
        (this->_H->at(1) = this->_H->at(1) + b);
        (this->_H->at(2) = this->_H->at(2) + c);
        (this->_H->at(3) = this->_H->at(3) + d);
        (this->_H->at(4) = this->_H->at(4) + e);
        (this->_H->at(5) = this->_H->at(5) + f);
        (this->_H->at(6) = this->_H->at(6) + g);
        (this->_H->at(7) = this->_H->at(7) + h);
    }
    
    void SHA256Managed::ProcessFinalBlock(cli::array<unsigned char>* inputBuffer, int32_t inputOffset, int32_t inputCount) {
        uint64_t total = (this->count + (uint64_t)inputCount);
        int32_t paddingSize = (56 - (int32_t)(total % 64UL));
        if((paddingSize < 1)) 
        {
            (paddingSize = paddingSize + 64);
        }
        cli::array<unsigned char> *fooBuffer = (new cli::array<unsigned char>(((inputCount + paddingSize) + 8)));
        for(int32_t i = 0; (i < inputCount); i++){
            fooBuffer->at(i) = inputBuffer->at((i + inputOffset));
        }
        fooBuffer->at(inputCount) = 128;
        for(int32_t i = (inputCount + 1); (i < (inputCount + paddingSize)); i++){
            fooBuffer->at(i) = 0;
        }
        uint64_t size = (total << 3);
        AddLength(size, fooBuffer, (inputCount + paddingSize));
        ProcessBlock(fooBuffer, 0);
        if((((inputCount + paddingSize) + 8) ==  128)) 
        {
            ProcessBlock(fooBuffer, 64);
        }
    }
    
    void SHA256Managed::AddLength(uint64_t length, cli::array<unsigned char>* buffer, int32_t position) {
        buffer->at(position++) = (unsigned char)(length >> 56);
        buffer->at(position++) = (unsigned char)(length >> 48);
        buffer->at(position++) = (unsigned char)(length >> 40);
        buffer->at(position++) = (unsigned char)(length >> 32);
        buffer->at(position++) = (unsigned char)(length >> 24);
        buffer->at(position++) = (unsigned char)(length >> 16);
        buffer->at(position++) = (unsigned char)(length >> 8);
        buffer->at(position) = (unsigned char)length;
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    
    void SHA384::constructor() {
        this->HashSizeValue = 384;
    }
    
    SHA384* SHA384::Create3() {
        return Create4(_T("System.Security.Cryptography.SHA384"));
    }
    
    SHA384* SHA384::Create4(System::String* hashName) {
        return cli::cast<SHA384*>(CryptoConfig::CreateFromName(hashName));
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    
    void SHA384Managed::constructor() {
        this->xBuf = (new cli::array<unsigned char>(8));
        this->W = (new cli::array<uint64_t>(80));
        Initialize(false);
    }
    
    void SHA384Managed::Initialize(bool reuse) {
        this->H1 = 14680500436340154072UL;
        this->H2 = 7105036623409894663UL;
        this->H3 = 10473403895298186519UL;
        this->H4 = 1526699215303891257UL;
        this->H5 = 7436329637833083697UL;
        this->H6 = 10282925794625328401UL;
        this->H7 = 15784041429090275239UL;
        this->H8 = 5167115440072839076UL;
        if(reuse) 
        {
            this->byteCount1 = 0UL;
            this->byteCount2 = 0UL;
            this->xBufOff = 0;
            for(int32_t i = 0; (i < this->xBuf->get_Length()); i++) {
                this->xBuf->at(i) = 0;
            }
            this->wOff = 0;
            for(int32_t i = 0; (i != this->W->get_Length()); i++) {
                this->W->at(i) = 0UL;
            }
        }
    }
    
    void SHA384Managed::Initialize_4bdfe3e821ea432() {
        Initialize(true);
    }
    
    void SHA384Managed::HashCore_8c4be9c0eca56be6(cli::array<unsigned char>* rgb, int32_t ibStart, int32_t cbSize) {
        while(((this->xBufOff != 0) && (cbSize > 0))) {
            update(rgb->at(ibStart));
            ibStart++;
            cbSize--;
        }
        while((cbSize > this->xBuf->get_Length())) {
            processWord(rgb, ibStart);
            (ibStart = ibStart + this->xBuf->get_Length());
            (cbSize = cbSize - this->xBuf->get_Length());
            (this->byteCount1 = this->byteCount1 + (uint64_t)this->xBuf->get_Length());
        }
        while((cbSize > 0)) {
            update(rgb->at(ibStart));
            ibStart++;
            cbSize--;
        }
    }
    
    cli::array<unsigned char>* SHA384Managed::HashFinal_58940e7c7f2519b1() {
        adjustByteCounts();
        uint64_t lowBitLength = (this->byteCount1 << 3);
        uint64_t hiBitLength = this->byteCount2;
        update(128);
        while((this->xBufOff != 0)) update(0);
        processLength(lowBitLength, hiBitLength);
        processBlock();
        cli::array<unsigned char> *output = (new cli::array<unsigned char>(48));
        unpackWord(this->H1, output, 0);
        unpackWord(this->H2, output, 8);
        unpackWord(this->H3, output, 16);
        unpackWord(this->H4, output, 24);
        unpackWord(this->H5, output, 32);
        unpackWord(this->H6, output, 40);
        SHA384Managed::Initialize_4bdfe3e821ea432();
        return output;
    }
    
    void SHA384Managed::update(unsigned char input) {
        this->xBuf->at(this->xBufOff++) = input;
        if((this->xBufOff ==  this->xBuf->get_Length())) 
        {
            processWord(this->xBuf, 0);
            this->xBufOff = 0;
        }
        this->byteCount1++;
    }
    
    void SHA384Managed::processWord(cli::array<unsigned char>* input, int32_t inOff) {
        this->W->at(this->wOff++) = (((((((((uint64_t)(input->at(inOff)) << 56) | ((uint64_t)(input->at((inOff + 1))) << 48)) | ((uint64_t)(input->at((inOff + 2))) << 40)) | ((uint64_t)(input->at((inOff + 3))) << 32)) | ((uint64_t)(input->at((inOff + 4))) << 24)) | ((uint64_t)(input->at((inOff + 5))) << 16)) | ((uint64_t)(input->at((inOff + 6))) << 8)) | (uint64_t)(input->at((inOff + 7))));
        if((this->wOff ==  16)) 
        {
            processBlock();
        }
    }
    
    void SHA384Managed::unpackWord(uint64_t word, cli::array<unsigned char>* output, int32_t outOff) {
        output->at(outOff) = (unsigned char)(word >> 56);
        output->at((outOff + 1)) = (unsigned char)(word >> 48);
        output->at((outOff + 2)) = (unsigned char)(word >> 40);
        output->at((outOff + 3)) = (unsigned char)(word >> 32);
        output->at((outOff + 4)) = (unsigned char)(word >> 24);
        output->at((outOff + 5)) = (unsigned char)(word >> 16);
        output->at((outOff + 6)) = (unsigned char)(word >> 8);
        output->at((outOff + 7)) = (unsigned char)word;
    }
    
    void SHA384Managed::adjustByteCounts() {
        if((this->byteCount1 > 2305843009213693951UL)) 
        {
            (this->byteCount2 = this->byteCount2 + (this->byteCount1 >> 61));
            (this->byteCount1 = this->byteCount1 & 2305843009213693951UL);
        }
    }
    
    void SHA384Managed::processLength(uint64_t lowW, uint64_t hiW) {
        if((this->wOff > 14)) 
        {
            processBlock();
        }
        this->W->at(14) = hiW;
        this->W->at(15) = lowW;
    }
    
    void SHA384Managed::processBlock() {
        uint64_t a, b, c, d, e, f, g, h;
        cli::array<uint64_t> *W = this->W;
        cli::array<uint64_t> *K2 = SHAConstants::K2;
        adjustByteCounts();
        for(int32_t t = 16; (t <= 79); t++){
            a = W->at((t - 15));
            a = ((((a >> 1) | (a << 63)) ^ ((a >> 8) | (a << 56))) ^ (a >> 7));
            b = W->at((t - 2));
            b = ((((b >> 19) | (b << 45)) ^ ((b >> 61) | (b << 3))) ^ (b >> 6));
            W->at(t) = (((b + W->at((t - 7))) + a) + W->at((t - 16)));
        }
        a = this->H1;
        b = this->H2;
        c = this->H3;
        d = this->H4;
        e = this->H5;
        f = this->H6;
        g = this->H7;
        h = this->H8;
        for(int32_t t = 0; (t <= 79); t++){
            uint64_t T1 = ((((e >> 14) | (e << 50)) ^ ((e >> 18) | (e << 46))) ^ ((e >> 41) | (e << 23)));
            (T1 = T1 + (((h + ((e & f) ^ (~(e) & g))) + K2->at(t)) + W->at(t)));
            uint64_t T2 = ((((a >> 28) | (a << 36)) ^ ((a >> 34) | (a << 30))) ^ ((a >> 39) | (a << 25)));
            (T2 = T2 + (((a & b) ^ (a & c)) ^ (b & c)));
            h = g;
            g = f;
            f = e;
            e = (d + T1);
            d = c;
            c = b;
            b = a;
            a = (T1 + T2);
        }
        (this->H1 = this->H1 + a);
        (this->H2 = this->H2 + b);
        (this->H3 = this->H3 + c);
        (this->H4 = this->H4 + d);
        (this->H5 = this->H5 + e);
        (this->H6 = this->H6 + f);
        (this->H7 = this->H7 + g);
        (this->H8 = this->H8 + h);
        this->wOff = 0;
        for(int32_t i = 0; (i != W->get_Length()); i++) {
            W->at(i) = 0UL;
        }
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    
    void SHA512::constructor() {
        this->HashSizeValue = 512;
    }
    
    SHA512* SHA512::Create3() {
        return Create4(_T("System.Security.Cryptography.SHA512"));
    }
    
    SHA512* SHA512::Create4(System::String* hashName) {
        return cli::cast<SHA512*>(CryptoConfig::CreateFromName(hashName));
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    
    void SHA512Managed::constructor() {
        this->xBuf = (new cli::array<unsigned char>(8));
        this->W = (new cli::array<uint64_t>(80));
        Initialize(false);
    }
    
    void SHA512Managed::Initialize(bool reuse) {
        this->H1 = 7640891576956012808UL;
        this->H2 = 13503953896175478587UL;
        this->H3 = 4354685564936845355UL;
        this->H4 = 11912009170470909681UL;
        this->H5 = 5840696475078001361UL;
        this->H6 = 11170449401992604703UL;
        this->H7 = 2270897969802886507UL;
        this->H8 = 6620516959819538809UL;
        if(reuse) 
        {
            this->byteCount1 = 0UL;
            this->byteCount2 = 0UL;
            this->xBufOff = 0;
            for(int32_t i = 0; (i < this->xBuf->get_Length()); i++) {
                this->xBuf->at(i) = 0;
            }
            this->wOff = 0;
            for(int32_t i = 0; (i != this->W->get_Length()); i++) {
                this->W->at(i) = 0UL;
            }
        }
    }
    
    void SHA512Managed::Initialize_4bdfe3e821ea432() {
        Initialize(true);
    }
    
    void SHA512Managed::HashCore_8c4be9c0eca56be6(cli::array<unsigned char>* rgb, int32_t ibStart, int32_t cbSize) {
        while(((this->xBufOff != 0) && (cbSize > 0))) {
            update(rgb->at(ibStart));
            ibStart++;
            cbSize--;
        }
        while((cbSize > this->xBuf->get_Length())) {
            processWord(rgb, ibStart);
            (ibStart = ibStart + this->xBuf->get_Length());
            (cbSize = cbSize - this->xBuf->get_Length());
            (this->byteCount1 = this->byteCount1 + (uint64_t)this->xBuf->get_Length());
        }
        while((cbSize > 0)) {
            update(rgb->at(ibStart));
            ibStart++;
            cbSize--;
        }
    }
    
    cli::array<unsigned char>* SHA512Managed::HashFinal_58940e7c7f2519b1() {
        adjustByteCounts();
        uint64_t lowBitLength = (this->byteCount1 << 3);
        uint64_t hiBitLength = this->byteCount2;
        update(128);
        while((this->xBufOff != 0)) update(0);
        processLength(lowBitLength, hiBitLength);
        processBlock();
        cli::array<unsigned char> *output = (new cli::array<unsigned char>(64));
        unpackWord(this->H1, output, 0);
        unpackWord(this->H2, output, 8);
        unpackWord(this->H3, output, 16);
        unpackWord(this->H4, output, 24);
        unpackWord(this->H5, output, 32);
        unpackWord(this->H6, output, 40);
        unpackWord(this->H7, output, 48);
        unpackWord(this->H8, output, 56);
        SHA512Managed::Initialize_4bdfe3e821ea432();
        return output;
    }
    
    void SHA512Managed::update(unsigned char input) {
        this->xBuf->at(this->xBufOff++) = input;
        if((this->xBufOff ==  this->xBuf->get_Length())) 
        {
            processWord(this->xBuf, 0);
            this->xBufOff = 0;
        }
        this->byteCount1++;
    }
    
    void SHA512Managed::processWord(cli::array<unsigned char>* input, int32_t inOff) {
        this->W->at(this->wOff++) = (((((((((uint64_t)(input->at(inOff)) << 56) | ((uint64_t)(input->at((inOff + 1))) << 48)) | ((uint64_t)(input->at((inOff + 2))) << 40)) | ((uint64_t)(input->at((inOff + 3))) << 32)) | ((uint64_t)(input->at((inOff + 4))) << 24)) | ((uint64_t)(input->at((inOff + 5))) << 16)) | ((uint64_t)(input->at((inOff + 6))) << 8)) | (uint64_t)(input->at((inOff + 7))));
        if((this->wOff ==  16)) 
        {
            processBlock();
        }
    }
    
    void SHA512Managed::unpackWord(uint64_t word, cli::array<unsigned char>* output, int32_t outOff) {
        output->at(outOff) = (unsigned char)(word >> 56);
        output->at((outOff + 1)) = (unsigned char)(word >> 48);
        output->at((outOff + 2)) = (unsigned char)(word >> 40);
        output->at((outOff + 3)) = (unsigned char)(word >> 32);
        output->at((outOff + 4)) = (unsigned char)(word >> 24);
        output->at((outOff + 5)) = (unsigned char)(word >> 16);
        output->at((outOff + 6)) = (unsigned char)(word >> 8);
        output->at((outOff + 7)) = (unsigned char)word;
    }
    
    void SHA512Managed::adjustByteCounts() {
        if((this->byteCount1 > 2305843009213693951UL)) 
        {
            (this->byteCount2 = this->byteCount2 + (this->byteCount1 >> 61));
            (this->byteCount1 = this->byteCount1 & 2305843009213693951UL);
        }
    }
    
    void SHA512Managed::processLength(uint64_t lowW, uint64_t hiW) {
        if((this->wOff > 14)) 
        {
            processBlock();
        }
        this->W->at(14) = hiW;
        this->W->at(15) = lowW;
    }
    
    void SHA512Managed::processBlock() {
        adjustByteCounts();
        for(int32_t t = 16; (t <= 79); t++) {
            this->W->at(t) = (((Sigma1(this->W->at((t - 2))) + this->W->at((t - 7))) + Sigma0(this->W->at((t - 15)))) + this->W->at((t - 16)));
        }
        uint64_t a = this->H1;
        uint64_t b = this->H2;
        uint64_t c = this->H3;
        uint64_t d = this->H4;
        uint64_t e = this->H5;
        uint64_t f = this->H6;
        uint64_t g = this->H7;
        uint64_t h = this->H8;
        for(int32_t t = 0; (t <= 79); t++){
            uint64_t T1 = ((((h + Sum1(e)) + Ch(e, f, g)) + SHAConstants::K2->at(t)) + this->W->at(t));
            uint64_t T2 = (Sum0(a) + Maj(a, b, c));
            h = g;
            g = f;
            f = e;
            e = (d + T1);
            d = c;
            c = b;
            b = a;
            a = (T1 + T2);
        }
        (this->H1 = this->H1 + a);
        (this->H2 = this->H2 + b);
        (this->H3 = this->H3 + c);
        (this->H4 = this->H4 + d);
        (this->H5 = this->H5 + e);
        (this->H6 = this->H6 + f);
        (this->H7 = this->H7 + g);
        (this->H8 = this->H8 + h);
        this->wOff = 0;
        for(int32_t i = 0; (i != this->W->get_Length()); i++) {
            this->W->at(i) = 0UL;
        }
    }
    
    uint64_t SHA512Managed::rotateRight(uint64_t x, int32_t n) {
        return ((x >> (n & 63)) | (x << ((64 - n) & 63)));
    }
    
    uint64_t SHA512Managed::Ch(uint64_t x, uint64_t y, uint64_t z) {
        return ((x & y) ^ (~(x) & z));
    }
    
    uint64_t SHA512Managed::Maj(uint64_t x, uint64_t y, uint64_t z) {
        return (((x & y) ^ (x & z)) ^ (y & z));
    }
    
    uint64_t SHA512Managed::Sum0(uint64_t x) {
        return ((rotateRight(x, 28) ^ rotateRight(x, 34)) ^ rotateRight(x, 39));
    }
    
    uint64_t SHA512Managed::Sum1(uint64_t x) {
        return ((rotateRight(x, 14) ^ rotateRight(x, 18)) ^ rotateRight(x, 41));
    }
    
    uint64_t SHA512Managed::Sigma0(uint64_t x) {
        return ((rotateRight(x, 1) ^ rotateRight(x, 8)) ^ (x >> 7));
    }
    
    uint64_t SHA512Managed::Sigma1(uint64_t x) {
        return ((rotateRight(x, 19) ^ rotateRight(x, 61)) ^ (x >> 6));
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    cli::array<uint32_t>*  SHAConstants::K1;
    cli::array<uint64_t>*  SHAConstants::K2;
    
    SHAConstants::SHAConstants()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void SHAConstants::static_constructor() {
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    
    void SignatureDescription::constructor() {
    }
    
    void SignatureDescription::constructor(System::Security::SecurityElement* el) {
        if((el ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("el"));
        }
        System::Security::SecurityElement *child = el->SearchForChildByTag(_T("Deformatter"));
        this->_DeformatterAlgorithm = (child ==  nullptr) ? nullptr : child->get_Text();
        child = el->SearchForChildByTag(_T("Digest"));
        this->_DigestAlgorithm = (child ==  nullptr) ? nullptr : child->get_Text();
        child = el->SearchForChildByTag(_T("Formatter"));
        this->_FormatterAlgorithm = (child ==  nullptr) ? nullptr : child->get_Text();
        child = el->SearchForChildByTag(_T("Key"));
        this->_KeyAlgorithm = (child ==  nullptr) ? nullptr : child->get_Text();
    }
    
    AsymmetricSignatureDeformatter* SignatureDescription::CreateDeformatter_8eb8daaf249d6ff0(AsymmetricAlgorithm* key) {
        if((this->_DeformatterAlgorithm ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("DeformatterAlgorithm"));
        }
        AsymmetricSignatureDeformatter *def = cli::cast<AsymmetricSignatureDeformatter*>(CryptoConfig::CreateFromName(this->_DeformatterAlgorithm));
        if((this->_KeyAlgorithm ==  nullptr)) 
        {
            throw cli::gcnew<System::NullReferenceException>(_T("KeyAlgorithm"));
        }
        def->SetKey_d453955f9571ca18(key);
        return def;
    }
    
    HashAlgorithm* SignatureDescription::CreateDigest_35cf85d843e5c3d2() {
        if((this->_DigestAlgorithm ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("DigestAlgorithm"));
        }
        return cli::cast<HashAlgorithm*>(CryptoConfig::CreateFromName(this->_DigestAlgorithm));
    }
    
    AsymmetricSignatureFormatter* SignatureDescription::CreateFormatter_f3b600e181bd68be(AsymmetricAlgorithm* key) {
        if((this->_FormatterAlgorithm ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("FormatterAlgorithm"));
        }
        AsymmetricSignatureFormatter *fmt = cli::cast<AsymmetricSignatureFormatter*>(CryptoConfig::CreateFromName(this->_FormatterAlgorithm));
        if((this->_KeyAlgorithm ==  nullptr)) 
        {
            throw cli::gcnew<System::NullReferenceException>(_T("KeyAlgorithm"));
        }
        fmt->SetKey_1b1967336b333b5c(key);
        return fmt;
    }
    
    System::String* SignatureDescription::get_DeformatterAlgorithm() {
        return this->_DeformatterAlgorithm;
    }
    
    System::String* SignatureDescription::set_DeformatterAlgorithm(System::String* value) {
        this->_DeformatterAlgorithm = value;
        return get_DeformatterAlgorithm();
    }
    
    System::String* SignatureDescription::get_DigestAlgorithm() {
        return this->_DigestAlgorithm;
    }
    
    System::String* SignatureDescription::set_DigestAlgorithm(System::String* value) {
        this->_DigestAlgorithm = value;
        return get_DigestAlgorithm();
    }
    
    System::String* SignatureDescription::get_FormatterAlgorithm() {
        return this->_FormatterAlgorithm;
    }
    
    System::String* SignatureDescription::set_FormatterAlgorithm(System::String* value) {
        this->_FormatterAlgorithm = value;
        return get_FormatterAlgorithm();
    }
    
    System::String* SignatureDescription::get_KeyAlgorithm() {
        return this->_KeyAlgorithm;
    }
    
    System::String* SignatureDescription::set_KeyAlgorithm(System::String* value) {
        this->_KeyAlgorithm = value;
        return get_KeyAlgorithm();
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    
    void DSASignatureDescription::constructor() {
        this->set_DeformatterAlgorithm(_T("System.Security.Cryptography.DSASignatureDeformatter"));
        this->set_DigestAlgorithm(_T("System.Security.Cryptography.SHA1CryptoServiceProvider"));
        this->set_FormatterAlgorithm(_T("System.Security.Cryptography.DSASignatureFormatter"));
        this->set_KeyAlgorithm(_T("System.Security.Cryptography.DSACryptoServiceProvider"));
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    
    void RSAPKCS1SHA1SignatureDescription::constructor() {
        this->set_DeformatterAlgorithm(_T("System.Security.Cryptography.RSAPKCS1SignatureDeformatter"));
        this->set_DigestAlgorithm(_T("System.Security.Cryptography.SHA1CryptoServiceProvider"));
        this->set_FormatterAlgorithm(_T("System.Security.Cryptography.RSAPKCS1SignatureFormatter"));
        this->set_KeyAlgorithm(_T("System.Security.Cryptography.RSACryptoServiceProvider"));
    }
    
    AsymmetricSignatureDeformatter* RSAPKCS1SHA1SignatureDescription::CreateDeformatter_8eb8daaf249d6ff0(AsymmetricAlgorithm* key) {
        return SignatureDescription::CreateDeformatter_8eb8daaf249d6ff0(key);
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    
    void SymmetricAlgorithm::constructor() {
        this->ModeValue = CipherMode::CBC;
        this->PaddingValue = PaddingMode::PKCS72;
        this->m_disposed = false;
    }
    
    void SymmetricAlgorithm::Finalize_d235b32c6d7e8b6d() {
        {
            cli::finally_guard([&]() {
                Finalize_b946fbc32e26afd6();
            });
            Dispose_e50bc684cac77d05(false);
        }
    }
    
    void SymmetricAlgorithm::Dispose() {
        Dispose_e50bc684cac77d05(true);
        System::GC::SuppressFinalize(this);
    }
    
    void SymmetricAlgorithm::Clear() {
        Dispose_e50bc684cac77d05(true);
    }
    
    void SymmetricAlgorithm::Dispose_e50bc684cac77d05(bool disposing) {
        if(!(this->m_disposed)) 
        {
            if((this->KeyValue != nullptr)) 
            {
                System::Array::Clear2(this->KeyValue, 0, this->KeyValue->get_Length());
                this->KeyValue = nullptr;
            }
            if(disposing) 
            {
            }
            this->m_disposed = true;
        }
    }
    
    ICryptoTransform* SymmetricAlgorithm::CreateDecryptor_2ed655dc8e27df59() {
        return CreateDecryptor_80e9c787d56cc5d1(this->get_Key_79a2c753d4f0f561(), this->get_IV_983478ffab99927());
    }
    
    ICryptoTransform* SymmetricAlgorithm::CreateEncryptor_f7057afd90cae836() {
        return CreateEncryptor_5ed1e69e3ba0a86a(this->get_Key_79a2c753d4f0f561(), this->get_IV_983478ffab99927());
    }
    
    bool SymmetricAlgorithm::ValidKeySize(int32_t bitLength) {
        return KeySizes::IsLegalKeySize(this->LegalKeySizesValue, bitLength);
    }
    
    SymmetricAlgorithm* SymmetricAlgorithm::Create() {
        return Create2(_T("System.Security.Cryptography.SymmetricAlgorithm"));
    }
    
    SymmetricAlgorithm* SymmetricAlgorithm::Create2(System::String* algName) {
        return cli::cast<SymmetricAlgorithm*>(CryptoConfig::CreateFromName(algName));
    }
    
    int32_t SymmetricAlgorithm::get_BlockSize_7a5a96e8187bef27() {
        return this->BlockSizeValue;
    }
    
    int32_t SymmetricAlgorithm::set_BlockSize_170b4e38aff87e6b(int32_t value) {
        if(!(KeySizes::IsLegalKeySize(this->LegalBlockSizesValue, value))) 
        {
            throw cli::gcnew<CryptographicException>(Locale::GetText(_T("block size not supported by algorithm")));
        }
        if((this->BlockSizeValue != value)) 
        {
            this->BlockSizeValue = value;
            this->IVValue = nullptr;
        }
        return get_BlockSize_7a5a96e8187bef27();
    }
    
    int32_t SymmetricAlgorithm::get_FeedbackSize_fac329115f28c49a() {
        return this->FeedbackSizeValue;
    }
    
    int32_t SymmetricAlgorithm::set_FeedbackSize_ab32be6ebcbf9640(int32_t value) {
        if(((value <= 0) || (value > this->BlockSizeValue))) 
        {
            throw cli::gcnew<CryptographicException>(Locale::GetText(_T("feedback size larger than block size")));
        }
        this->FeedbackSizeValue = value;
        return get_FeedbackSize_fac329115f28c49a();
    }
    
    cli::array<unsigned char>* SymmetricAlgorithm::get_IV_983478ffab99927() {
        if((this->IVValue ==  nullptr)) 
        {
            GenerateIV_df3473e2513c2b00();
        }
        return cli::cast<cli::array<unsigned char>*>(cli::import(this->IVValue)->Clone());
    }
    
    cli::array<unsigned char>* SymmetricAlgorithm::set_IV_5f86e84678ef1565(cli::array<unsigned char>* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("IV"));
        }
        if(((value->get_Length() << 3) != this->BlockSizeValue)) 
        {
            throw cli::gcnew<CryptographicException>(Locale::GetText(_T("IV length is different than block size")));
        }
        this->IVValue = cli::cast<cli::array<unsigned char>*>(cli::import(value)->Clone());
        return get_IV_983478ffab99927();
    }
    
    cli::array<unsigned char>* SymmetricAlgorithm::get_Key_79a2c753d4f0f561() {
        if((this->KeyValue ==  nullptr)) 
        {
            GenerateKey_a6a62018358dfc76();
        }
        return cli::cast<cli::array<unsigned char>*>(cli::import(this->KeyValue)->Clone());
    }
    
    cli::array<unsigned char>* SymmetricAlgorithm::set_Key_9b56e7a05d7e4c8f(cli::array<unsigned char>* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("Key"));
        }
        int32_t length = (value->get_Length() << 3);
        if(!(KeySizes::IsLegalKeySize(this->LegalKeySizesValue, length))) 
        {
            throw cli::gcnew<CryptographicException>(Locale::GetText(_T("Key size not supported by algorithm")));
        }
        this->KeySizeValue = length;
        this->KeyValue = cli::cast<cli::array<unsigned char>*>(cli::import(value)->Clone());
        return get_Key_79a2c753d4f0f561();
    }
    
    int32_t SymmetricAlgorithm::get_KeySize_ec919ce7243c4a9() {
        return this->KeySizeValue;
    }
    
    int32_t SymmetricAlgorithm::set_KeySize_f5b8ff3d506d2d5a(int32_t value) {
        if(!(KeySizes::IsLegalKeySize(this->LegalKeySizesValue, value))) 
        {
            throw cli::gcnew<CryptographicException>(Locale::GetText(_T("Key size not supported by algorithm")));
        }
        this->KeySizeValue = value;
        this->KeyValue = nullptr;
        return get_KeySize_ec919ce7243c4a9();
    }
    
    cli::array<KeySizes*>* SymmetricAlgorithm::get_LegalBlockSizes_988a517b67f5a151() {
        return this->LegalBlockSizesValue;
    }
    
    cli::array<KeySizes*>* SymmetricAlgorithm::get_LegalKeySizes_27644398fdbe9d8() {
        return this->LegalKeySizesValue;
    }
    
    CipherMode SymmetricAlgorithm::get_Mode_248883f5619349b8() {
        return this->ModeValue;
    }
    
    CipherMode SymmetricAlgorithm::set_Mode_b4ebd08a4556d807(CipherMode value) {
        if(!(System::Enum::IsDefined(cli::import(this->ModeValue)->GetType(), cli::box(value)))) 
        {
            throw cli::gcnew<CryptographicException>(Locale::GetText(_T("Cipher mode not available")));
        }
        this->ModeValue = value;
        return get_Mode_248883f5619349b8();
    }
    
    PaddingMode SymmetricAlgorithm::get_Padding_4e1745ee57afb026() {
        return this->PaddingValue;
    }
    
    PaddingMode SymmetricAlgorithm::set_Padding_2e9637021e7fe5c6(PaddingMode value) {
        if(!(System::Enum::IsDefined(cli::import(this->PaddingValue)->GetType(), cli::box(value)))) 
        {
            throw cli::gcnew<CryptographicException>(Locale::GetText(_T("Padding mode not available")));
        }
        this->PaddingValue = value;
        return get_Padding_4e1745ee57afb026();
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    
    void ToBase64Transform::constructor() {
    }
    
    void ToBase64Transform::Finalize_ab7e804173f971c() {
        {
            cli::finally_guard([&]() {
                Finalize_b946fbc32e26afd6();
            });
            Dispose_1cc14386475cd361(false);
        }
    }
    
    void ToBase64Transform::Clear() {
        Dispose_1cc14386475cd361(true);
    }
    
    void ToBase64Transform::Dispose() {
        Dispose_1cc14386475cd361(true);
        System::GC::SuppressFinalize(this);
    }
    
    void ToBase64Transform::Dispose_1cc14386475cd361(bool disposing) {
        if(!(this->m_disposed)) 
        {
            if(disposing) 
            {
            }
            this->m_disposed = true;
        }
    }
    
    int32_t ToBase64Transform::TransformBlock(cli::array<unsigned char>* inputBuffer, int32_t inputOffset, int32_t inputCount, cli::array<unsigned char>* outputBuffer, int32_t outputOffset) {
        if(this->m_disposed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("TransformBlock"));
        }
        if((inputBuffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("inputBuffer"));
        }
        if((outputBuffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("outputBuffer"));
        }
        if((inputCount < 0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("inputCount"), _T("< 0"));
        }
        if((inputCount > inputBuffer->get_Length())) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("inputCount"), Locale::GetText(_T("Overflow")));
        }
        if((inputOffset < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("inputOffset"), _T("< 0"));
        }
        if((inputOffset > (inputBuffer->get_Length() - inputCount))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("inputOffset"), Locale::GetText(_T("Overflow")));
        }
        if((outputOffset < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("outputOffset"), _T("< 0"));
        }
        if((outputOffset > (outputBuffer->get_Length() - inputCount))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("outputOffset"), Locale::GetText(_T("Overflow")));
        }
        InternalTransformBlock(inputBuffer, inputOffset, inputCount, outputBuffer, outputOffset);
        return this->get_OutputBlockSize();
    }
    
    void ToBase64Transform::InternalTransformBlock(cli::array<unsigned char>* inputBuffer, int32_t inputOffset, int32_t inputCount, cli::array<unsigned char>* outputBuffer, int32_t outputOffset) {
        cli::array<unsigned char> *lookup = Base64Constants::EncodeTable;
        int32_t b1 = (int32_t)(inputBuffer->at(inputOffset));
        int32_t b2 = (int32_t)(inputBuffer->at((inputOffset + 1)));
        int32_t b3 = (int32_t)(inputBuffer->at((inputOffset + 2)));
        outputBuffer->at(outputOffset) = lookup->at((b1 >> 2));
        outputBuffer->at((outputOffset + 1)) = lookup->at((((b1 << 4) & 48) | (b2 >> 4)));
        outputBuffer->at((outputOffset + 2)) = lookup->at((((b2 << 2) & 60) | (b3 >> 6)));
        outputBuffer->at((outputOffset + 3)) = lookup->at((b3 & 63));
    }
    
    cli::array<unsigned char>* ToBase64Transform::TransformFinalBlock(cli::array<unsigned char>* inputBuffer, int32_t inputOffset, int32_t inputCount) {
        if(this->m_disposed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("TransformFinalBlock"));
        }
        if((inputBuffer ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("inputBuffer"));
        }
        if((inputCount < 0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("inputCount"), _T("< 0"));
        }
        if((inputOffset > (inputBuffer->get_Length() - inputCount))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("inputCount"), Locale::GetText(_T("Overflow")));
        }
        if((inputCount > this->get_InputBlockSize())) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(Locale::GetText(_T("Invalid input length")));
        }
        return InternalTransformFinalBlock(inputBuffer, inputOffset, inputCount);
    }
    
    cli::array<unsigned char>* ToBase64Transform::InternalTransformFinalBlock(cli::array<unsigned char>* inputBuffer, int32_t inputOffset, int32_t inputCount) {
        int32_t blockLen = 3;
        int32_t outLen = 4;
        int32_t fullBlocks = (inputCount / blockLen);
        int32_t tail = (inputCount % blockLen);
        cli::array<unsigned char> *res = (new cli::array<unsigned char>((inputCount != 0) ? (((inputCount + 2) / blockLen) * outLen) : 0));
        int32_t outputOffset = 0;
        for(int32_t i = 0; (i < fullBlocks); i++){
            InternalTransformBlock(inputBuffer, inputOffset, blockLen, res, outputOffset);
            (inputOffset = inputOffset + blockLen);
            (outputOffset = outputOffset + outLen);
        }
        cli::array<unsigned char> *lookup = Base64Constants::EncodeTable;
        int32_t b1, b2;
        switch(tail) {
            case 0: case_1675: {
                break;
            }
            case 1: case_1676: {
                b1 = (int32_t)(inputBuffer->at(inputOffset));
                res->at(outputOffset) = lookup->at((b1 >> 2));
                res->at((outputOffset + 1)) = lookup->at(((b1 << 4) & 48));
                res->at((outputOffset + 2)) = 61;
                res->at((outputOffset + 3)) = 61;
                break;
            }
            case 2: case_1677: {
                b1 = (int32_t)(inputBuffer->at(inputOffset));
                b2 = (int32_t)(inputBuffer->at((inputOffset + 1)));
                res->at(outputOffset) = lookup->at((b1 >> 2));
                res->at((outputOffset + 1)) = lookup->at((((b1 << 4) & 48) | (b2 >> 4)));
                res->at((outputOffset + 2)) = lookup->at(((b2 << 2) & 60));
                res->at((outputOffset + 3)) = 61;
                break;
            }
        }
        return res;
    }
    
    bool ToBase64Transform::get_CanTransformMultipleBlocks() {
        return false;
    }
    
    bool ToBase64Transform::get_CanReuseTransform_ab8331e898b19c7c() {
        return true;
    }
    
    int32_t ToBase64Transform::get_InputBlockSize() {
        return 3;
    }
    
    int32_t ToBase64Transform::get_OutputBlockSize() {
        return 4;
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    
    void TripleDES::constructor() {
        this->KeySizeValue = 192;
        this->BlockSizeValue = 64;
        this->FeedbackSizeValue = 8;
        this->LegalKeySizesValue = (new cli::array<KeySizes*>(1));
        this->LegalKeySizesValue->at(0) = cli::gcnew<KeySizes>(128, 192, 64);
        this->LegalBlockSizesValue = (new cli::array<KeySizes*>(1));
        this->LegalBlockSizesValue->at(0) = cli::gcnew<KeySizes>(64, 64, 0);
    }
    
    bool TripleDES::IsWeakKey(cli::array<unsigned char>* rgbKey) {
        if((rgbKey ==  nullptr)) 
        {
            throw cli::gcnew<CryptographicException>(Locale::GetText(_T("Null Key")));
        }
        if((rgbKey->get_Length() ==  16)) 
        {
            for(int32_t i = 0; (i < 8); i++) {
                if(((int32_t)(rgbKey->at(i)) != (int32_t)(rgbKey->at((i + 8))))) 
                {
                    return false;
                }
            }
        }
         else 
        {
            if((rgbKey->get_Length() ==  24)) 
            {
                bool bFirstCase = true;
                for(int32_t i = 0; (i < 8); i++){
                    if(((int32_t)(rgbKey->at(i)) != (int32_t)(rgbKey->at((i + 8))))) 
                    {
                        bFirstCase = false;
                        break;
                    }
                }
                if(!(bFirstCase)) 
                {
                    for(int32_t i = 8; (i < 16); i++) {
                        if(((int32_t)(rgbKey->at(i)) != (int32_t)(rgbKey->at((i + 8))))) 
                        {
                            return false;
                        }
                    }
                }
            }
             else 
            {
                throw cli::gcnew<CryptographicException>(Locale::GetText(_T("Wrong Key Length")));
            }
        }
        return true;
    }
    
    TripleDES* TripleDES::Create3() {
        return Create4(_T("System.Security.Cryptography.TripleDES"));
    }
    
    TripleDES* TripleDES::Create4(System::String* str) {
        return cli::cast<TripleDES*>(CryptoConfig::CreateFromName(str));
    }
    
    cli::array<unsigned char>* TripleDES::get_Key_79a2c753d4f0f561() {
        if((this->KeyValue ==  nullptr)) 
        {
            GenerateKey_a6a62018358dfc76();
            while(IsWeakKey(this->KeyValue)) GenerateKey_a6a62018358dfc76();
        }
        return cli::cast<cli::array<unsigned char>*>(cli::import(this->KeyValue)->Clone());
    }
    
    cli::array<unsigned char>* TripleDES::set_Key_9b56e7a05d7e4c8f(cli::array<unsigned char>* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("Key"));
        }
        if(IsWeakKey(value)) 
        {
            throw cli::gcnew<CryptographicException>(Locale::GetText(_T("Weak Key")));
        }
        this->KeyValue = cli::cast<cli::array<unsigned char>*>(cli::import(value)->Clone());
        return get_Key_79a2c753d4f0f561();
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    
    void TripleDESCryptoServiceProvider::constructor() {
    }
    
    void TripleDESCryptoServiceProvider::GenerateIV_df3473e2513c2b00() {
        this->IVValue = Mono::Security::Cryptography::KeyBuilder::IV((this->BlockSizeValue >> 3));
    }
    
    void TripleDESCryptoServiceProvider::GenerateKey_a6a62018358dfc76() {
        this->KeyValue = TripleDESTransform::GetStrongKey();
    }
    
    ICryptoTransform* TripleDESCryptoServiceProvider::CreateDecryptor_80e9c787d56cc5d1(cli::array<unsigned char>* rgbKey, cli::array<unsigned char>* rgbIV) {
        return cli::gcnew<TripleDESTransform>(this, false, rgbKey, rgbIV);
    }
    
    ICryptoTransform* TripleDESCryptoServiceProvider::CreateEncryptor_5ed1e69e3ba0a86a(cli::array<unsigned char>* rgbKey, cli::array<unsigned char>* rgbIV) {
        return cli::gcnew<TripleDESTransform>(this, true, rgbKey, rgbIV);
    }
    
}}}
namespace System { namespace Security { namespace Cryptography {
    
    
    void TripleDESTransform::constructor(TripleDES* algo, bool encryption, cli::array<unsigned char>* key, cli::array<unsigned char>* iv) {
        if((key ==  nullptr)) 
        {
            key = GetStrongKey();
        }
        if(TripleDES::IsWeakKey(key)) 
        {
            System::String *msg = Locale::GetText(_T("This is a known weak key."));
            throw cli::gcnew<CryptographicException>(msg);
        }
        cli::array<unsigned char> *key1 = (new cli::array<unsigned char>(8));
        cli::array<unsigned char> *key2 = (new cli::array<unsigned char>(8));
        cli::array<unsigned char> *key3 = (new cli::array<unsigned char>(8));
        DES *des = DES::Create3();
        System::Buffer::BlockCopy(key, 0, key1, 0, 8);
        System::Buffer::BlockCopy(key, 8, key2, 0, 8);
        if((key->get_Length() ==  16)) 
        {
            System::Buffer::BlockCopy(key, 0, key3, 0, 8);
        }
         else 
        {
            System::Buffer::BlockCopy(key, 16, key3, 0, 8);
        }
        if((encryption || ((int32_t)(algo->get_Mode_248883f5619349b8()) ==  4))) 
        {
            this->E1 = cli::gcnew<DESTransform>(des, true, key1, iv);
            this->D2 = cli::gcnew<DESTransform>(des, false, key2, iv);
            this->E3 = cli::gcnew<DESTransform>(des, true, key3, iv);
        }
         else 
        {
            this->D1 = cli::gcnew<DESTransform>(des, false, key3, iv);
            this->E2 = cli::gcnew<DESTransform>(des, true, key2, iv);
            this->D3 = cli::gcnew<DESTransform>(des, false, key1, iv);
        }
    }
    
    void TripleDESTransform::ECB_94d714c69347f447(cli::array<unsigned char>* input, cli::array<unsigned char>* output) {
        DESTransform::Permutation(input, output, DESTransform::ipTab, false);
        if(this->encrypt) 
        {
            this->E1->ProcessBlock(output, output);
            this->D2->ProcessBlock(output, output);
            this->E3->ProcessBlock(output, output);
        }
         else 
        {
            this->D1->ProcessBlock(output, output);
            this->E2->ProcessBlock(output, output);
            this->D3->ProcessBlock(output, output);
        }
        DESTransform::Permutation(output, output, DESTransform::fpTab, true);
    }
    
    cli::array<unsigned char>* TripleDESTransform::GetStrongKey() {
        int32_t size = (DESTransform::BLOCK_BYTE_SIZE * 3);
        cli::array<unsigned char> *key = Mono::Security::Cryptography::KeyBuilder::Key2(size);
        while(TripleDES::IsWeakKey(key)) key = Mono::Security::Cryptography::KeyBuilder::Key2(size);
        return key;
    }
    
}}}
namespace System { namespace Security { namespace Cryptography { namespace X509Certificates {
    
    
    void X509Certificate2::constructor(cli::array<unsigned char>* data, bool dates) {
        if((data != nullptr)) 
        {
            Import_8704c488ef852461(data, nullptr, X509KeyStorageFlags::DefaultKeySet);
            this->hideDates = !(dates);
        }
    }
    
    void X509Certificate2::constructor(cli::array<unsigned char>* data) {
    }
    
    void X509Certificate2::constructor(void* handle) {
        if(::System::IntPtr::op_Equality(handle, (*::System::IntPtr::Zero))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Invalid handle."));
        }
        InitFromHandle(handle);
    }
    
    void X509Certificate2::constructor(X509Certificate2* cert) {
        if((cert ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("cert"));
        }
        if((cert != nullptr)) 
        {
            cli::array<unsigned char> *data = cert->GetRawCertData_ac3e339ae8bdb569();
            if((data != nullptr)) 
            {
                this->x509 = cli::gcnew<Mono::Security::X509::X509Certificate>(data);
            }
            this->hideDates = false;
        }
    }
    
    void X509Certificate2::constructor() {
    }
    
    void X509Certificate2::constructor(cli::array<unsigned char>* rawData, System::String* password) {
        Import_8704c488ef852461(rawData, password, X509KeyStorageFlags::DefaultKeySet);
    }
    
    void X509Certificate2::constructor(cli::array<unsigned char>* rawData, System::Security::SecureString* password) {
        Import_49d225ed0ddfc5ed(rawData, password, X509KeyStorageFlags::DefaultKeySet);
    }
    
    void X509Certificate2::constructor(cli::array<unsigned char>* rawData, System::String* password, X509KeyStorageFlags keyStorageFlags) {
        Import_8704c488ef852461(rawData, password, keyStorageFlags);
    }
    
    void X509Certificate2::constructor(cli::array<unsigned char>* rawData, System::Security::SecureString* password, X509KeyStorageFlags keyStorageFlags) {
        Import_49d225ed0ddfc5ed(rawData, password, keyStorageFlags);
    }
    
    void X509Certificate2::constructor(System::String* fileName) {
        Import_f6c9177991fa38c4(fileName, nullptr, X509KeyStorageFlags::DefaultKeySet);
    }
    
    void X509Certificate2::constructor(System::String* fileName, System::String* password) {
        Import_f6c9177991fa38c4(fileName, password, X509KeyStorageFlags::DefaultKeySet);
    }
    
    void X509Certificate2::constructor(System::String* fileName, System::Security::SecureString* password) {
        Import_32240950aa38999e(fileName, password, X509KeyStorageFlags::DefaultKeySet);
    }
    
    void X509Certificate2::constructor(System::String* fileName, System::String* password, X509KeyStorageFlags keyStorageFlags) {
        Import_f6c9177991fa38c4(fileName, password, keyStorageFlags);
    }
    
    void X509Certificate2::constructor(System::String* fileName, System::Security::SecureString* password, X509KeyStorageFlags keyStorageFlags) {
        Import_32240950aa38999e(fileName, password, keyStorageFlags);
    }
    
    void X509Certificate2::constructor(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        cli::array<unsigned char> *raw = cli::cast<cli::array<unsigned char>*>(info->GetValue(_T("RawData"), cli::typeof<System::Type>::info));
        Import_8704c488ef852461(raw, nullptr, X509KeyStorageFlags::DefaultKeySet);
    }
    
    System::String* X509Certificate2::tostr(cli::array<unsigned char>* data) {
        if((data != nullptr)) 
        {
            System::Text::StringBuilder *sb = cli::gcnew<System::Text::StringBuilder>();
            for(int32_t i = 0; (i < data->get_Length()); i++) {
                sb->Append2(cli::import(data->at(i))->ToString3(_T("X2")));
            }
            return sb->ToString_1636a0751cb9ac11();
        }
         else 
        {
            return nullptr;
        }
    }
    
    X509Certificate2* X509Certificate2::CreateFromCertFile(System::String* filename) {
        cli::array<unsigned char> *data = Load(filename);
        return cli::gcnew<X509Certificate2>(data);
    }
    
    X509Certificate2* X509Certificate2::CreateFromSignedFile(System::String* filename) {
        try {
            Mono::Security::Authenticode::AuthenticodeDeformatter *a = cli::gcnew<Mono::Security::Authenticode::AuthenticodeDeformatter>(filename);
            if((a->get_SigningCertificate() != nullptr)) 
            {
                return cli::gcnew<X509Certificate2>(a->get_SigningCertificate()->get_RawData_c0a18e988d76611c());
            }
        }
        catch(System::Security::SecurityException*) {
            throw ;
        }
        catch(System::Exception* e) {
            System::String *msg = Locale::GetText2(_T("Couldn\'t extract digital signature from {0}."), (new cli::array<System::Object*>({filename})));
            throw cli::gcnew<System::Runtime::InteropServices::COMException>(msg, e);
        }
        throw cli::gcnew<System::Security::Cryptography::CryptographicException>(Locale::GetText2(_T("{0} isn\'t signed."), (new cli::array<System::Object*>({filename}))));
    }
    
    void X509Certificate2::InitFromHandle(void* handle) {
        if(::System::IntPtr::op_Inequality(handle, (*::System::IntPtr::Zero))) 
        {
            CertificateContext cc = cli::unbox<CertificateContext>(System::Runtime::InteropServices::Marshal::PtrToStructure2(handle, cli::typeof<System::Type>::info));
            cli::array<unsigned char> *data = (new cli::array<unsigned char>((int32_t)cc->cbCertEncoded));
            System::Runtime::InteropServices::Marshal::Copy9(cc->pbCertEncoded, data, 0, (int32_t)cc->cbCertEncoded);
            this->x509 = cli::gcnew<Mono::Security::X509::X509Certificate>(data);
        }
    }
    
    bool X509Certificate2::Equals_4ee033c835248c9d(X509Certificate2* other) {
        if((other ==  nullptr)) 
        {
            return false;
        }
         else 
        {
            if((other->x509 ==  nullptr)) 
            {
                if((this->x509 ==  nullptr)) 
                {
                    return true;
                }
                throw cli::gcnew<System::Security::Cryptography::CryptographicException>(Locale::GetText(_T("Certificate instance is empty.")));
            }
            cli::array<unsigned char> *raw = other->x509->get_RawData_c0a18e988d76611c();
            if((raw != nullptr)) 
            {
                if((this->x509 ==  nullptr)) 
                {
                    return false;
                }
                if((this->x509->get_RawData_c0a18e988d76611c() ==  nullptr)) 
                {
                    return false;
                }
                if((raw->get_Length() ==  this->x509->get_RawData_c0a18e988d76611c()->get_Length())) 
                {
                    for(int32_t i = 0; (i < raw->get_Length()); i++){
                        if(((int32_t)(raw->at(i)) != (int32_t)(this->x509->get_RawData_c0a18e988d76611c()->at(i)))) 
                        {
                            return false;
                        }
                    }
                    return true;
                }
                 else 
                {
                    return false;
                }
            }
        }
        return ((this->x509 ==  nullptr) || (this->x509->get_RawData_c0a18e988d76611c() ==  nullptr));
    }
    
    cli::array<unsigned char>* X509Certificate2::GetCertHash_6e5c891031851f85() {
        if((this->x509 ==  nullptr)) 
        {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(Locale::GetText(_T("Certificate instance is empty.")));
        }
        if(((this->cachedCertificateHash ==  nullptr) && (this->x509 != nullptr))) 
        {
            System::Security::Cryptography::SHA1 *sha = System::Security::Cryptography::SHA1::Create3();
            this->cachedCertificateHash = sha->ComputeHash(this->x509->get_RawData_c0a18e988d76611c());
        }
        return this->cachedCertificateHash;
    }
    
    System::String* X509Certificate2::GetCertHashString_6f21abd347a44d33() {
        return tostr(GetCertHash_6e5c891031851f85());
    }
    
    System::String* X509Certificate2::GetEffectiveDateString_a7d11e3256f7e438() {
        if(this->hideDates) 
        {
            return nullptr;
        }
        if((this->x509 ==  nullptr)) 
        {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(Locale::GetText(_T("Certificate instance is empty.")));
        }
        return this->x509->get_ValidFrom_b9a836b86f941230()->ToLocalTime()->ToString_1636a0751cb9ac11();
    }
    
    System::String* X509Certificate2::GetExpirationDateString_bfe4aedffdbc9727() {
        if(this->hideDates) 
        {
            return nullptr;
        }
        if((this->x509 ==  nullptr)) 
        {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(Locale::GetText(_T("Certificate instance is empty.")));
        }
        return this->x509->get_ValidUntil_63987634a232abc0()->ToLocalTime()->ToString_1636a0751cb9ac11();
    }
    
    System::String* X509Certificate2::GetFormat_9d02941013991518() {
        return _T("X509");
    }
    
    int32_t X509Certificate2::GetHashCode_6648aef0f235ee6c() {
        if((this->x509 ==  nullptr)) 
        {
            return 0;
        }
        if((this->cachedCertificateHash ==  nullptr)) 
        {
            GetCertHash_6e5c891031851f85();
        }
        if(((this->cachedCertificateHash != nullptr) && (this->cachedCertificateHash->get_Length() >= 4))) 
        {
            return (((((int32_t)(this->cachedCertificateHash->at(0)) << 24) | ((int32_t)(this->cachedCertificateHash->at(1)) << 16)) | ((int32_t)(this->cachedCertificateHash->at(2)) << 8)) | (int32_t)(this->cachedCertificateHash->at(3)));
        }
         else 
        {
            return 0;
        }
    }
    
    System::String* X509Certificate2::GetIssuerName_b07b655a589baba() {
        if((this->x509 ==  nullptr)) 
        {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(Locale::GetText(_T("Certificate instance is empty.")));
        }
        return this->x509->get_IssuerName_25458e2c269ceeaa();
    }
    
    System::String* X509Certificate2::GetKeyAlgorithm_bc8b5dfe7d8b4e74() {
        if((this->x509 ==  nullptr)) 
        {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(Locale::GetText(_T("Certificate instance is empty.")));
        }
        return this->x509->get_KeyAlgorithm_26169b6c5ae631ca();
    }
    
    cli::array<unsigned char>* X509Certificate2::GetKeyAlgorithmParameters_e877a3b6d57d563e() {
        if((this->x509 ==  nullptr)) 
        {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(Locale::GetText(_T("Certificate instance is empty.")));
        }
        cli::array<unsigned char> *kap = this->x509->get_KeyAlgorithmParameters_7dd2925ed6c97721();
        if((kap ==  nullptr)) 
        {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(Locale::GetText(_T("Parameters not part of the certificate")));
        }
        return kap;
    }
    
    System::String* X509Certificate2::GetKeyAlgorithmParametersString_8c98fdf4c4c5b8c9() {
        return tostr(GetKeyAlgorithmParameters_e877a3b6d57d563e());
    }
    
    System::String* X509Certificate2::GetName_27e249535074211f() {
        if((this->x509 ==  nullptr)) 
        {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(Locale::GetText(_T("Certificate instance is empty.")));
        }
        return this->x509->get_SubjectName_8e1ad5a09a5c9697();
    }
    
    cli::array<unsigned char>* X509Certificate2::GetPublicKey_dfa105cbfdc38326() {
        if((this->x509 ==  nullptr)) 
        {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(Locale::GetText(_T("Certificate instance is empty.")));
        }
        return this->x509->get_PublicKey_bbce0ec4cf2d16e();
    }
    
    System::String* X509Certificate2::GetPublicKeyString_883dde0135cf6f31() {
        return tostr(GetPublicKey_dfa105cbfdc38326());
    }
    
    cli::array<unsigned char>* X509Certificate2::GetRawCertData_ac3e339ae8bdb569() {
        if((this->x509 ==  nullptr)) 
        {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(Locale::GetText(_T("Certificate instance is empty.")));
        }
        return this->x509->get_RawData_c0a18e988d76611c();
    }
    
    System::String* X509Certificate2::GetRawCertDataString_9b5d755fdca2c386() {
        if((this->x509 ==  nullptr)) 
        {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(Locale::GetText(_T("Certificate instance is empty.")));
        }
        return tostr(this->x509->get_RawData_c0a18e988d76611c());
    }
    
    cli::array<unsigned char>* X509Certificate2::GetSerialNumber_30200c16d792461f() {
        if((this->x509 ==  nullptr)) 
        {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(Locale::GetText(_T("Certificate instance is empty.")));
        }
        return this->x509->get_SerialNumber_ac6911419cae47b0();
    }
    
    System::String* X509Certificate2::GetSerialNumberString_e8d5e8bf0d47fe1c() {
        cli::array<unsigned char> *sn = GetSerialNumber_30200c16d792461f();
        System::Array::Reverse(sn);
        return tostr(sn);
    }
    
    System::String* X509Certificate2::ToString_1636a0751cb9ac11() {
        return System::Object::ToString_1636a0751cb9ac11();
    }
    
    System::String* X509Certificate2::ToString_15fae504dac2a2c0(bool fVerbose) {
        if((!(fVerbose) || (this->x509 ==  nullptr))) 
        {
            return System::Object::ToString_1636a0751cb9ac11();
        }
        System::String *nl = System::Environment::get_NewLine();
        System::Text::StringBuilder *sb = cli::gcnew<System::Text::StringBuilder>();
        sb->AppendFormat4(_T("[Subject]{0}  {1}{0}{0}"), nl, this->get_Subject());
        sb->AppendFormat4(_T("[Issuer]{0}  {1}{0}{0}"), nl, this->get_Issuer());
        sb->AppendFormat4(_T("[Not Before]{0}  {1}{0}{0}"), nl, GetEffectiveDateString_a7d11e3256f7e438());
        sb->AppendFormat4(_T("[Not After]{0}  {1}{0}{0}"), nl, GetExpirationDateString_bfe4aedffdbc9727());
        sb->AppendFormat4(_T("[Thumbprint]{0}  {1}{0}"), nl, GetCertHashString_6f21abd347a44d33());
        sb->Append2(nl);
        return sb->ToString_1636a0751cb9ac11();
    }
    
    cli::array<unsigned char>* X509Certificate2::Load(System::String* fileName) {
        cli::array<unsigned char> *data = nullptr;
        {
            /* USING - BLOCK */
            auto fs = System::IO::File::OpenRead(fileName);
            cli::using_guard{fs};
            data = (new cli::array<unsigned char>((int32_t)fs->get_Length_ddb8b0d061db5350()));
            fs->Read_c0d6dde3943b413e(data, 0, data->get_Length());
            fs->Close_59c62ed53ef2a481();
        }
        return data;
    }
    
    System::String* X509Certificate2::FormatDate(System::DateTime date) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool X509Certificate2::Equals_ed975d2f4a7d193e(System::Object* obj) {
        X509Certificate2 *x = cli::as<X509Certificate2*>(obj);
        if((x != nullptr)) 
        {
            return this->Equals_4ee033c835248c9d(x);
        }
        return false;
    }
    
    cli::array<unsigned char>* X509Certificate2::Export_abe12b767ba3c001(X509ContentType contentType) {
        return Export4(contentType, nullptr);
    }
    
    cli::array<unsigned char>* X509Certificate2::Export_5306d1a57883d7c1(X509ContentType contentType, System::String* password) {
        cli::array<unsigned char> *pwd = (password ==  nullptr) ? nullptr : System::Text::Encoding::get_UTF8()->GetBytes_49806e8e98b1c1db(password);
        return Export4(contentType, pwd);
    }
    
    cli::array<unsigned char>* X509Certificate2::Export_feb9d7cd54387416(X509ContentType contentType, System::Security::SecureString* password) {
        cli::array<unsigned char> *pwd = (password ==  nullptr) ? nullptr : password->GetBuffer();
        return Export4(contentType, pwd);
    }
    
    cli::array<unsigned char>* X509Certificate2::Export4(X509ContentType contentType, cli::array<unsigned char>* password) {
        if((this->x509 ==  nullptr)) 
        {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(Locale::GetText(_T("Certificate instance is empty.")));
        }
        {
            cli::finally_guard([&]() {
                if((password != nullptr)) 
                {
                    System::Array::Clear2(password, 0, password->get_Length());
                }
            });
            switch(contentType) {
                case X509ContentType::Cert: case_1678: {
                    return this->x509->get_RawData_c0a18e988d76611c();
                }
                case X509ContentType::Pfx: case_1679: {
                    throw cli::gcnew<System::NotSupportedException>();
                }
                case X509ContentType::SerializedCert: case_1680: {
                    throw cli::gcnew<System::NotSupportedException>();
                }
                default: case_1681: {
                    System::String *msg = Locale::GetText2(_T("This certificate format \'{0}\' cannot be exported."), (new cli::array<System::Object*>({cli::box(contentType)})));
                    throw cli::gcnew<System::Security::Cryptography::CryptographicException>(msg);
                }
            }
        }
    }
    
    void X509Certificate2::Import_77a5439bc691b240(cli::array<unsigned char>* rawData) {
        Import_8704c488ef852461(rawData, nullptr, X509KeyStorageFlags::DefaultKeySet);
    }
    
    void X509Certificate2::Import_8704c488ef852461(cli::array<unsigned char>* rawData, System::String* password, X509KeyStorageFlags keyStorageFlags) {
        Reset_82cf81433177234a();
        if((password ==  nullptr)) 
        {
            try {
                this->x509 = cli::gcnew<Mono::Security::X509::X509Certificate>(rawData);
            }
            catch(System::Exception* e) {
                try {
                    Mono::Security::X509::PKCS12 *pfx = cli::gcnew<Mono::Security::X509::PKCS12>(rawData);
                    if((pfx->get_Certificates()->get_Count() > 0)) 
                    {
                        this->x509 = pfx->get_Certificates()->get_Item2(0);
                    }
                     else 
                    {
                        this->x509 = nullptr;
                    }
                }
                catch(...) {
                    System::String *msg = Locale::GetText(_T("Unable to decode certificate."));
                    throw cli::gcnew<System::Security::Cryptography::CryptographicException>(msg, e);
                }
            }
        }
         else 
        {
            try {
                Mono::Security::X509::PKCS12 *pfx = cli::gcnew<Mono::Security::X509::PKCS12>(rawData, password);
                if((pfx->get_Certificates()->get_Count() > 0)) 
                {
                    this->x509 = pfx->get_Certificates()->get_Item2(0);
                }
                 else 
                {
                    this->x509 = nullptr;
                }
            }
            catch(...) {
                this->x509 = cli::gcnew<Mono::Security::X509::X509Certificate>(rawData);
            }
        }
    }
    
    void X509Certificate2::Import_49d225ed0ddfc5ed(cli::array<unsigned char>* rawData, System::Security::SecureString* password, X509KeyStorageFlags keyStorageFlags) {
        Import_8704c488ef852461(rawData, nullptr, keyStorageFlags);
    }
    
    void X509Certificate2::Import_b500b50331e43dd3(System::String* fileName) {
        cli::array<unsigned char> *rawData = Load(fileName);
        Import_8704c488ef852461(rawData, nullptr, X509KeyStorageFlags::DefaultKeySet);
    }
    
    void X509Certificate2::Import_f6c9177991fa38c4(System::String* fileName, System::String* password, X509KeyStorageFlags keyStorageFlags) {
        cli::array<unsigned char> *rawData = Load(fileName);
        Import_8704c488ef852461(rawData, password, keyStorageFlags);
    }
    
    void X509Certificate2::Import_32240950aa38999e(System::String* fileName, System::Security::SecureString* password, X509KeyStorageFlags keyStorageFlags) {
        cli::array<unsigned char> *rawData = Load(fileName);
        Import_8704c488ef852461(rawData, nullptr, keyStorageFlags);
    }
    
    void X509Certificate2::OnDeserialization(System::Object* sender) {
    }
    
    void X509Certificate2::GetObjectData(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        info->AddValue16(_T("RawData"), this->x509->get_RawData_c0a18e988d76611c());
    }
    
    void X509Certificate2::Reset_82cf81433177234a() {
        this->x509 = nullptr;
        this->issuer_name = nullptr;
        this->subject_name = nullptr;
        this->hideDates = false;
        this->cachedCertificateHash = nullptr;
    }
    
    System::String* X509Certificate2::get_Issuer() {
        if((this->x509 ==  nullptr)) 
        {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(Locale::GetText(_T("Certificate instance is empty.")));
        }
        if((this->issuer_name ==  nullptr)) 
        {
            this->issuer_name = Mono::Security::X509::X501::ToString3(this->x509->GetIssuerName(), true, _T(", "), true);
        }
        return this->issuer_name;
    }
    
    System::String* X509Certificate2::get_Subject() {
        if((this->x509 ==  nullptr)) 
        {
            throw cli::gcnew<System::Security::Cryptography::CryptographicException>(Locale::GetText(_T("Certificate instance is empty.")));
        }
        if((this->subject_name ==  nullptr)) 
        {
            this->subject_name = Mono::Security::X509::X501::ToString3(this->x509->GetSubjectName(), true, _T(", "), true);
        }
        return this->subject_name;
    }
    
    void* X509Certificate2::get_Handle() {
        return (*::System::IntPtr::Zero);
    }
    
}}}}
namespace System { namespace Security { namespace Permissions {
    
    
    void CodeAccessSecurityAttribute::constructor(SecurityAction action) {
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    
    
    void EnvironmentPermission::constructor(PermissionState state) {
        this->_state = System::Security::CodeAccessPermission::CheckPermissionState(state, true);
        this->readList = cli::gcnew<System::Collections::ArrayList>();
        this->writeList = cli::gcnew<System::Collections::ArrayList>();
    }
    
    void EnvironmentPermission::constructor(EnvironmentPermissionAccess flag, System::String* pathList) {
        this->readList = cli::gcnew<System::Collections::ArrayList>();
        this->writeList = cli::gcnew<System::Collections::ArrayList>();
        SetPathList(flag, pathList);
    }
    
    void EnvironmentPermission::AddPathList(EnvironmentPermissionAccess flag, System::String* pathList) {
        if((pathList ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("pathList"));
        }
        cli::array<System::String*> *paths;
        switch(flag) {
            case EnvironmentPermissionAccess::AllAccess: case_1682: {
                paths = pathList->Split((new cli::array<char16_t>({u';'})));
                for(auto tmp_523 : paths) {
                    auto path = cli::cast<System::String*>(tmp_523);
                    {
                        if(!(this->readList->Contains_f1c198d01147f1ee(path))) 
                        {
                            this->readList->Add_e6a92085999ce388(path);
                        }
                        if(!(this->writeList->Contains_f1c198d01147f1ee(path))) 
                        {
                            this->writeList->Add_e6a92085999ce388(path);
                        }
                    }
                }
                break;
            }
            case EnvironmentPermissionAccess::NoAccess: case_1683: {
                break;
            }
            case EnvironmentPermissionAccess::Read: case_1684: {
                paths = pathList->Split((new cli::array<char16_t>({u';'})));
                for(auto tmp_524 : paths) {
                    auto path = cli::cast<System::String*>(tmp_524);
                    {
                        if(!(this->readList->Contains_f1c198d01147f1ee(path))) 
                        {
                            this->readList->Add_e6a92085999ce388(path);
                        }
                    }
                }
                break;
            }
            case EnvironmentPermissionAccess::Write: case_1685: {
                paths = pathList->Split((new cli::array<char16_t>({u';'})));
                for(auto tmp_525 : paths) {
                    auto path = cli::cast<System::String*>(tmp_525);
                    {
                        if(!(this->writeList->Contains_f1c198d01147f1ee(path))) 
                        {
                            this->writeList->Add_e6a92085999ce388(path);
                        }
                    }
                }
                break;
            }
            default: case_1686: {
                ThrowInvalidFlag(flag, false);
                break;
            }
        }
    }
    
    System::Security::IPermission* EnvironmentPermission::Copy_d1e925db301dc53f() {
        EnvironmentPermission *ep = cli::gcnew<EnvironmentPermission>(this->_state);
        System::String *path = GetPathList(EnvironmentPermissionAccess::Read);
        if((path != nullptr)) 
        {
            ep->SetPathList(EnvironmentPermissionAccess::Read, path);
        }
        path = GetPathList(EnvironmentPermissionAccess::Write);
        if((path != nullptr)) 
        {
            ep->SetPathList(EnvironmentPermissionAccess::Write, path);
        }
        return ep;
    }
    
    void EnvironmentPermission::FromXml_ec3b425a66b43072(System::Security::SecurityElement* esd) {
        System::Security::CodeAccessPermission::CheckSecurityElement(esd, _T("esd"), 1, 1);
        if(System::Security::CodeAccessPermission::IsUnrestricted(esd)) 
        {
            this->_state = PermissionState::Unrestricted;
        }
        System::String *read = esd->Attribute2(_T("Read"));
        if(((read != nullptr) && (read->get_Length() > 0))) 
        {
            SetPathList(EnvironmentPermissionAccess::Read, read);
        }
        System::String *write = esd->Attribute2(_T("Write"));
        if(((write != nullptr) && (write->get_Length() > 0))) 
        {
            SetPathList(EnvironmentPermissionAccess::Write, write);
        }
    }
    
    System::String* EnvironmentPermission::GetPathList(EnvironmentPermissionAccess flag) {
        switch(flag) {
            case EnvironmentPermissionAccess::AllAccess: case EnvironmentPermissionAccess::NoAccess: case_1687: {
                ThrowInvalidFlag(flag, true);
                break;
            }
            case EnvironmentPermissionAccess::Read: case_1688: {
                return GetPathList2(this->readList);
            }
            case EnvironmentPermissionAccess::Write: case_1689: {
                return GetPathList2(this->writeList);
            }
            default: case_1690: {
                ThrowInvalidFlag(flag, false);
                break;
            }
        }
        return nullptr;
    }
    
    System::Security::IPermission* EnvironmentPermission::Intersect_7dbf5aef702b16af(System::Security::IPermission* target) {
        EnvironmentPermission *ep = Cast(target);
        if((ep ==  nullptr)) 
        {
            return nullptr;
        }
        if(IsUnrestricted2()) 
        {
            return ep->Copy_d1e925db301dc53f();
        }
        if(ep->IsUnrestricted2()) 
        {
            return Copy_e6fdf74d8dfaca72();
        }
        int32_t n = 0;
        EnvironmentPermission *result = cli::gcnew<EnvironmentPermission>(PermissionState::None);
        System::String *readTarget = ep->GetPathList(EnvironmentPermissionAccess::Read);
        if((readTarget != nullptr)) 
        {
            cli::array<System::String*> *targets = readTarget->Split((new cli::array<char16_t>({u';'})));
            for(auto tmp_526 : targets) {
                auto t = cli::cast<System::String*>(tmp_526);
                {
                    if(this->readList->Contains_f1c198d01147f1ee(t)) 
                    {
                        result->AddPathList(EnvironmentPermissionAccess::Read, t);
                        n++;
                    }
                }
            }
        }
        System::String *writeTarget = ep->GetPathList(EnvironmentPermissionAccess::Write);
        if((writeTarget != nullptr)) 
        {
            cli::array<System::String*> *targets = writeTarget->Split((new cli::array<char16_t>({u';'})));
            for(auto tmp_527 : targets) {
                auto t = cli::cast<System::String*>(tmp_527);
                {
                    if(this->writeList->Contains_f1c198d01147f1ee(t)) 
                    {
                        result->AddPathList(EnvironmentPermissionAccess::Write, t);
                        n++;
                    }
                }
            }
        }
        return (n > 0) ? result : nullptr;
    }
    
    bool EnvironmentPermission::IsSubsetOf_76947f8575c4d81(System::Security::IPermission* target) {
        EnvironmentPermission *ep = Cast(target);
        if((ep ==  nullptr)) 
        {
            return false;
        }
        if(IsUnrestricted2()) 
        {
            return ep->IsUnrestricted2();
        }
         else 
        {
            if(ep->IsUnrestricted2()) 
            {
                return true;
            }
        }
        for(auto tmp_528 : this->readList) {
            auto s = cli::cast<System::String*>(tmp_528);
            {
                if(!(ep->readList->Contains_f1c198d01147f1ee(s))) 
                {
                    return false;
                }
            }
        }
        for(auto tmp_529 : this->writeList) {
            auto s = cli::cast<System::String*>(tmp_529);
            {
                if(!(ep->writeList->Contains_f1c198d01147f1ee(s))) 
                {
                    return false;
                }
            }
        }
        return true;
    }
    
    bool EnvironmentPermission::IsUnrestricted2() {
        return ((int32_t)(this->_state) ==  1);
    }
    
    void EnvironmentPermission::SetPathList(EnvironmentPermissionAccess flag, System::String* pathList) {
        if((pathList ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("pathList"));
        }
        cli::array<System::String*> *paths;
        switch(flag) {
            case EnvironmentPermissionAccess::AllAccess: case_1691: {
                this->readList->Clear_cd6654e5a40f5056();
                this->writeList->Clear_cd6654e5a40f5056();
                paths = pathList->Split((new cli::array<char16_t>({u';'})));
                for(auto tmp_530 : paths) {
                    auto path = cli::cast<System::String*>(tmp_530);
                    {
                        this->readList->Add_e6a92085999ce388(path);
                        this->writeList->Add_e6a92085999ce388(path);
                    }
                }
                break;
            }
            case EnvironmentPermissionAccess::NoAccess: case_1692: {
                break;
            }
            case EnvironmentPermissionAccess::Read: case_1693: {
                this->readList->Clear_cd6654e5a40f5056();
                paths = pathList->Split((new cli::array<char16_t>({u';'})));
                for(auto tmp_531 : paths) {
                    auto path = cli::cast<System::String*>(tmp_531);
                    {
                        this->readList->Add_e6a92085999ce388(path);
                    }
                }
                break;
            }
            case EnvironmentPermissionAccess::Write: case_1694: {
                this->writeList->Clear_cd6654e5a40f5056();
                paths = pathList->Split((new cli::array<char16_t>({u';'})));
                for(auto tmp_532 : paths) {
                    auto path = cli::cast<System::String*>(tmp_532);
                    {
                        this->writeList->Add_e6a92085999ce388(path);
                    }
                }
                break;
            }
            default: case_1695: {
                ThrowInvalidFlag(flag, false);
                break;
            }
        }
    }
    
    System::Security::SecurityElement* EnvironmentPermission::ToXml_9ee4cd8af8e8f747() {
        System::Security::SecurityElement *se = System::Security::CodeAccessPermission::Element2(1);
        if(((int32_t)(this->_state) ==  1)) 
        {
            se->AddAttribute(_T("Unrestricted"), _T("true"));
        }
         else 
        {
            System::String *path = GetPathList(EnvironmentPermissionAccess::Read);
            if((path != nullptr)) 
            {
                se->AddAttribute(_T("Read"), path);
            }
            path = GetPathList(EnvironmentPermissionAccess::Write);
            if((path != nullptr)) 
            {
                se->AddAttribute(_T("Write"), path);
            }
        }
        return se;
    }
    
    System::Security::IPermission* EnvironmentPermission::Union_b0ddcab6cb9c8441(System::Security::IPermission* other) {
        EnvironmentPermission *ep = Cast(other);
        if((ep ==  nullptr)) 
        {
            return Copy_e6fdf74d8dfaca72();
        }
        if((IsUnrestricted2() || ep->IsUnrestricted2())) 
        {
            return cli::gcnew<EnvironmentPermission>(PermissionState::Unrestricted);
        }
        if((IsEmpty() && ep->IsEmpty())) 
        {
            return nullptr;
        }
        EnvironmentPermission *result = cli::cast<EnvironmentPermission*>(Copy_e6fdf74d8dfaca72());
        System::String *path = ep->GetPathList(EnvironmentPermissionAccess::Read);
        if((path != nullptr)) 
        {
            result->AddPathList(EnvironmentPermissionAccess::Read, path);
        }
        path = ep->GetPathList(EnvironmentPermissionAccess::Write);
        if((path != nullptr)) 
        {
            result->AddPathList(EnvironmentPermissionAccess::Write, path);
        }
        return result;
    }
    
    int32_t EnvironmentPermission::GetTokenIndex() {
        return 0;
    }
    
    bool EnvironmentPermission::IsEmpty() {
        return ((((int32_t)(this->_state) ==  0) && (this->readList->get_Count_2354963792616712() ==  0)) && (this->writeList->get_Count_2354963792616712() ==  0));
    }
    
    EnvironmentPermission* EnvironmentPermission::Cast(System::Security::IPermission* target) {
        if((target ==  nullptr)) 
        {
            return nullptr;
        }
        EnvironmentPermission *ep = cli::as<EnvironmentPermission*>(target);
        if((ep ==  nullptr)) 
        {
            System::Security::CodeAccessPermission::ThrowInvalidPermission(target, cli::typeof<System::Type>::info);
        }
        return ep;
    }
    
    void EnvironmentPermission::ThrowInvalidFlag(EnvironmentPermissionAccess flag, bool context) {
        System::String *msg = nullptr;
        if(context) 
        {
            msg = Locale::GetText(_T("Unknown flag \'{0}\'."));
        }
         else 
        {
            msg = Locale::GetText(_T("Invalid flag \'{0}\' in this context."));
        }
        throw cli::gcnew<System::ArgumentException>(System::String::Format2(msg, cli::box(flag)), _T("flag"));
    }
    
    System::String* EnvironmentPermission::GetPathList2(System::Collections::ArrayList* list) {
        if(IsUnrestricted2()) 
        {
            return System::String::Empty;
        }
        if((list->get_Count_2354963792616712() ==  0)) 
        {
            return System::String::Empty;
        }
        System::Text::StringBuilder *sb = cli::gcnew<System::Text::StringBuilder>();
        for(auto tmp_533 : list) {
            auto path = cli::cast<System::String*>(tmp_533);
            {
                sb->Append2(path);
                sb->Append2(_T(";"));
            }
        }
        System::String *result = sb->ToString_1636a0751cb9ac11();
        int32_t n = result->get_Length();
        if((n > 0)) 
        {
            return result->Substring2(0, (n - 1));
        }
        return System::String::Empty;
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    
    
    void EnvironmentPermissionAttribute::constructor(SecurityAction action) {
    }
    
    System::Security::IPermission* EnvironmentPermissionAttribute::CreatePermission_cae8413caba48c05() {
        EnvironmentPermission *perm = nullptr;
        if(this->get_Unrestricted()) 
        {
            perm = cli::gcnew<EnvironmentPermission>(PermissionState::Unrestricted);
        }
         else 
        {
            perm = cli::gcnew<EnvironmentPermission>(PermissionState::None);
            if((this->read != nullptr)) 
            {
                perm->AddPathList(EnvironmentPermissionAccess::Read, this->read);
            }
            if((this->write != nullptr)) 
            {
                perm->AddPathList(EnvironmentPermissionAccess::Write, this->write);
            }
        }
        return perm;
    }
    
    System::String* EnvironmentPermissionAttribute::get_All() {
        throw cli::gcnew<System::NotSupportedException>(_T("All"));
    }
    
    System::String* EnvironmentPermissionAttribute::set_All(System::String* value) {
        this->read = value;
        this->write = value;
        return get_All();
    }
    
    System::String* EnvironmentPermissionAttribute::get_Read() {
        return this->read;
    }
    
    System::String* EnvironmentPermissionAttribute::set_Read(System::String* value) {
        this->read = value;
        return get_Read();
    }
    
    System::String* EnvironmentPermissionAttribute::get_Write() {
        return this->write;
    }
    
    System::String* EnvironmentPermissionAttribute::set_Write(System::String* value) {
        this->write = value;
        return get_Write();
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    
    
    void FileDialogPermission::constructor(PermissionState state) {
        if(((int32_t)(System::Security::CodeAccessPermission::CheckPermissionState(state, true)) ==  1)) 
        {
            this->_access = FileDialogPermissionAccess::OpenSave;
        }
         else 
        {
            this->_access = FileDialogPermissionAccess::None;
        }
    }
    
    void FileDialogPermission::constructor(FileDialogPermissionAccess access) {
        this->set_Access(access);
    }
    
    System::Security::IPermission* FileDialogPermission::Copy_d1e925db301dc53f() {
        return cli::gcnew<FileDialogPermission>(this->_access);
    }
    
    void FileDialogPermission::FromXml_ec3b425a66b43072(System::Security::SecurityElement* esd) {
        System::Security::CodeAccessPermission::CheckSecurityElement(esd, _T("esd"), 1, 1);
        if(System::Security::CodeAccessPermission::IsUnrestricted(esd)) 
        {
            this->_access = FileDialogPermissionAccess::OpenSave;
        }
         else 
        {
            System::String *a = esd->Attribute2(_T("Access"));
            if((a ==  nullptr)) 
            {
                this->_access = FileDialogPermissionAccess::None;
            }
             else 
            {
                this->_access = cli::unbox<FileDialogPermissionAccess>(System::Enum::Parse(cli::typeof<System::Type>::info, a));
            }
        }
    }
    
    System::Security::IPermission* FileDialogPermission::Intersect_7dbf5aef702b16af(System::Security::IPermission* target) {
        FileDialogPermission *fdp = Cast(target);
        if((fdp ==  nullptr)) 
        {
            return nullptr;
        }
        FileDialogPermissionAccess a = (FileDialogPermissionAccess)(((int32_t)(this->_access) & (int32_t)(fdp->_access)));
        return ((int32_t)(a) ==  0) ? nullptr : cli::gcnew<FileDialogPermission>(a);
    }
    
    bool FileDialogPermission::IsSubsetOf_76947f8575c4d81(System::Security::IPermission* target) {
        FileDialogPermission *fdp = Cast(target);
        if((fdp ==  nullptr)) 
        {
            return false;
        }
        return ((int32_t)(((int32_t)(this->_access) & (int32_t)(fdp->_access))) ==  (int32_t)(this->_access));
    }
    
    bool FileDialogPermission::IsUnrestricted2() {
        return ((int32_t)(this->_access) ==  3);
    }
    
    System::Security::SecurityElement* FileDialogPermission::ToXml_9ee4cd8af8e8f747() {
        System::Security::SecurityElement *se = System::Security::CodeAccessPermission::Element2(1);
        switch(this->_access) {
            case FileDialogPermissionAccess::Open: case_1696: {
                se->AddAttribute(_T("Access"), _T("Open"));
                break;
            }
            case FileDialogPermissionAccess::Save: case_1697: {
                se->AddAttribute(_T("Access"), _T("Save"));
                break;
            }
            case FileDialogPermissionAccess::OpenSave: case_1698: {
                se->AddAttribute(_T("Unrestricted"), _T("true"));
                break;
            }
        }
        return se;
    }
    
    System::Security::IPermission* FileDialogPermission::Union_b0ddcab6cb9c8441(System::Security::IPermission* target) {
        FileDialogPermission *fdp = Cast(target);
        if((fdp ==  nullptr)) 
        {
            return Copy_e6fdf74d8dfaca72();
        }
        if((IsUnrestricted2() || fdp->IsUnrestricted2())) 
        {
            return cli::gcnew<FileDialogPermission>(PermissionState::Unrestricted);
        }
        return cli::gcnew<FileDialogPermission>((FileDialogPermissionAccess)(((int32_t)(this->_access) | (int32_t)(fdp->_access))));
    }
    
    int32_t FileDialogPermission::GetTokenIndex() {
        return 1;
    }
    
    FileDialogPermission* FileDialogPermission::Cast(System::Security::IPermission* target) {
        if((target ==  nullptr)) 
        {
            return nullptr;
        }
        FileDialogPermission *fdp = cli::as<FileDialogPermission*>(target);
        if((fdp ==  nullptr)) 
        {
            System::Security::CodeAccessPermission::ThrowInvalidPermission(target, cli::typeof<System::Type>::info);
        }
        return fdp;
    }
    
    FileDialogPermissionAccess FileDialogPermission::get_Access() {
        return this->_access;
    }
    
    FileDialogPermissionAccess FileDialogPermission::set_Access(FileDialogPermissionAccess value) {
        if(!(System::Enum::IsDefined(cli::typeof<System::Type>::info, cli::box(value)))) 
        {
            System::String *msg = System::String::Format2(Locale::GetText(_T("Invalid enum {0}")), cli::box(value));
            throw cli::gcnew<System::ArgumentException>(msg, _T("FileDialogPermissionAccess"));
        }
        this->_access = value;
        return get_Access();
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    
    
    void FileDialogPermissionAttribute::constructor(SecurityAction action) {
    }
    
    System::Security::IPermission* FileDialogPermissionAttribute::CreatePermission_cae8413caba48c05() {
        FileDialogPermission *perm = nullptr;
        if(this->get_Unrestricted()) 
        {
            perm = cli::gcnew<FileDialogPermission>(PermissionState::Unrestricted);
        }
         else 
        {
            FileDialogPermissionAccess access = FileDialogPermissionAccess::None;
            if(this->canOpen) 
            {
                (access = (FileDialogPermissionAccess)(((int32_t)(access) | 1)));
            }
            if(this->canSave) 
            {
                (access = (FileDialogPermissionAccess)(((int32_t)(access) | 2)));
            }
            perm = cli::gcnew<FileDialogPermission>(access);
        }
        return perm;
    }
    
    bool FileDialogPermissionAttribute::get_Open() {
        return this->canOpen;
    }
    
    bool FileDialogPermissionAttribute::set_Open(bool value) {
        this->canOpen = value;
        return get_Open();
    }
    
    bool FileDialogPermissionAttribute::get_Save() {
        return this->canSave;
    }
    
    bool FileDialogPermissionAttribute::set_Save(bool value) {
        this->canSave = value;
        return get_Save();
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    
    cli::array<char16_t>*  FileIOPermission::BadPathNameCharacters;
    cli::array<char16_t>*  FileIOPermission::BadFileNameCharacters;
    
    FileIOPermission::FileIOPermission()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void FileIOPermission::static_constructor() {
        BadPathNameCharacters = System::IO::Path::GetInvalidPathChars();
        BadFileNameCharacters = System::IO::Path::GetInvalidFileNameChars();
    }
    
    void FileIOPermission::constructor(PermissionState state) {
        if(((int32_t)(System::Security::CodeAccessPermission::CheckPermissionState(state, true)) ==  1)) 
        {
            this->m_Unrestricted = true;
            this->m_AllFilesAccess = FileIOPermissionAccess::AllAccess;
            this->m_AllLocalFilesAccess = FileIOPermissionAccess::AllAccess;
        }
        CreateLists();
    }
    
    void FileIOPermission::constructor(FileIOPermissionAccess access, System::String* path) {
        if((path ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("path"));
        }
        CreateLists();
        AddPathList(access, path);
    }
    
    void FileIOPermission::constructor(FileIOPermissionAccess access, cli::array<System::String*>* pathList) {
        if((pathList ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("pathList"));
        }
        CreateLists();
        AddPathList2(access, pathList);
    }
    
    void FileIOPermission::constructor(FileIOPermissionAccess access, System::Security::AccessControl::AccessControlActions control, System::String* path) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    void FileIOPermission::constructor(FileIOPermissionAccess access, System::Security::AccessControl::AccessControlActions control, cli::array<System::String*>* pathList) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    void FileIOPermission::CreateLists() {
        this->readList = cli::gcnew<System::Collections::ArrayList>();
        this->writeList = cli::gcnew<System::Collections::ArrayList>();
        this->appendList = cli::gcnew<System::Collections::ArrayList>();
        this->pathList = cli::gcnew<System::Collections::ArrayList>();
    }
    
    void FileIOPermission::AddPathList(FileIOPermissionAccess access, System::String* path) {
        if(((int32_t)((15 & (int32_t)(access))) != (int32_t)(access))) 
        {
            ThrowInvalidFlag(access, true);
        }
        ThrowIfInvalidPath(path);
        AddPathInternal(access, path);
    }
    
    void FileIOPermission::AddPathList2(FileIOPermissionAccess access, cli::array<System::String*>* pathList) {
        if(((int32_t)((15 & (int32_t)(access))) != (int32_t)(access))) 
        {
            ThrowInvalidFlag(access, true);
        }
        ThrowIfInvalidPath2(pathList);
        for(auto tmp_534 : pathList) {
            auto path = cli::cast<System::String*>(tmp_534);
            {
                AddPathInternal(access, path);
            }
        }
    }
    
    void FileIOPermission::AddPathInternal(FileIOPermissionAccess access, System::String* path) {
        path = System::IO::Path::InsecureGetFullPath(path);
        if(((int32_t)(((int32_t)(access) & 1)) ==  1)) 
        {
            this->readList->Add_e6a92085999ce388(path);
        }
        if(((int32_t)(((int32_t)(access) & 2)) ==  2)) 
        {
            this->writeList->Add_e6a92085999ce388(path);
        }
        if(((int32_t)(((int32_t)(access) & 4)) ==  4)) 
        {
            this->appendList->Add_e6a92085999ce388(path);
        }
        if(((int32_t)(((int32_t)(access) & 8)) ==  8)) 
        {
            this->pathList->Add_e6a92085999ce388(path);
        }
    }
    
    System::Security::IPermission* FileIOPermission::Copy_d1e925db301dc53f() {
        if(this->m_Unrestricted) 
        {
            return cli::gcnew<FileIOPermission>(PermissionState::Unrestricted);
        }
        FileIOPermission *copy = cli::gcnew<FileIOPermission>(PermissionState::None);
        copy->readList = cli::cast<System::Collections::ArrayList*>(this->readList->Clone_5d610374e21ea7b0());
        copy->writeList = cli::cast<System::Collections::ArrayList*>(this->writeList->Clone_5d610374e21ea7b0());
        copy->appendList = cli::cast<System::Collections::ArrayList*>(this->appendList->Clone_5d610374e21ea7b0());
        copy->pathList = cli::cast<System::Collections::ArrayList*>(this->pathList->Clone_5d610374e21ea7b0());
        copy->m_AllFilesAccess = this->m_AllFilesAccess;
        copy->m_AllLocalFilesAccess = this->m_AllLocalFilesAccess;
        return copy;
    }
    
    void FileIOPermission::FromXml_ec3b425a66b43072(System::Security::SecurityElement* esd) {
        System::Security::CodeAccessPermission::CheckSecurityElement(esd, _T("esd"), 1, 1);
        if(System::Security::CodeAccessPermission::IsUnrestricted(esd)) 
        {
            this->m_Unrestricted = true;
        }
         else 
        {
            this->m_Unrestricted = false;
            System::String *fileList = esd->Attribute2(_T("Read"));
            cli::array<System::String*> *files;
            if((fileList != nullptr)) 
            {
                files = fileList->Split((new cli::array<char16_t>({u';'})));
                AddPathList2(FileIOPermissionAccess::Read, files);
            }
            fileList = esd->Attribute2(_T("Write"));
            if((fileList != nullptr)) 
            {
                files = fileList->Split((new cli::array<char16_t>({u';'})));
                AddPathList2(FileIOPermissionAccess::Write, files);
            }
            fileList = esd->Attribute2(_T("Append"));
            if((fileList != nullptr)) 
            {
                files = fileList->Split((new cli::array<char16_t>({u';'})));
                AddPathList2(FileIOPermissionAccess::Append, files);
            }
            fileList = esd->Attribute2(_T("PathDiscovery"));
            if((fileList != nullptr)) 
            {
                files = fileList->Split((new cli::array<char16_t>({u';'})));
                AddPathList2(FileIOPermissionAccess::PathDiscovery, files);
            }
        }
    }
    
    cli::array<System::String*>* FileIOPermission::GetPathList(FileIOPermissionAccess access) {
        if(((int32_t)((15 & (int32_t)(access))) != (int32_t)(access))) 
        {
            ThrowInvalidFlag(access, true);
        }
        System::Collections::ArrayList *result = cli::gcnew<System::Collections::ArrayList>();
        switch(access) {
            case FileIOPermissionAccess::NoAccess: case_1699: {
                break;
            }
            case FileIOPermissionAccess::Read: case_1700: {
                result->AddRange_a8bb4db32a72ffe(this->readList);
                break;
            }
            case FileIOPermissionAccess::Write: case_1701: {
                result->AddRange_a8bb4db32a72ffe(this->writeList);
                break;
            }
            case FileIOPermissionAccess::Append: case_1702: {
                result->AddRange_a8bb4db32a72ffe(this->appendList);
                break;
            }
            case FileIOPermissionAccess::PathDiscovery: case_1703: {
                result->AddRange_a8bb4db32a72ffe(this->pathList);
                break;
            }
            default: case_1704: {
                ThrowInvalidFlag(access, false);
                break;
            }
        }
        return (result->get_Count_2354963792616712() > 0) ? cli::cast<cli::array<System::String*>*>(result->ToArray_7b80f35a5dbfbc47(cli::typeof<System::Type>::info)) : nullptr;
    }
    
    System::Security::IPermission* FileIOPermission::Intersect_7dbf5aef702b16af(System::Security::IPermission* target) {
        FileIOPermission *fiop = Cast(target);
        if((fiop ==  nullptr)) 
        {
            return nullptr;
        }
        if(IsUnrestricted2()) 
        {
            return fiop->Copy_d1e925db301dc53f();
        }
        if(fiop->IsUnrestricted2()) 
        {
            return Copy_e6fdf74d8dfaca72();
        }
        FileIOPermission *result = cli::gcnew<FileIOPermission>(PermissionState::None);
        result->set_AllFiles((FileIOPermissionAccess)(((int32_t)(this->m_AllFilesAccess) & (int32_t)(fiop->get_AllFiles()))));
        result->set_AllLocalFiles((FileIOPermissionAccess)(((int32_t)(this->m_AllLocalFilesAccess) & (int32_t)(fiop->get_AllLocalFiles()))));
        IntersectKeys(this->readList, fiop->readList, result->readList);
        IntersectKeys(this->writeList, fiop->writeList, result->writeList);
        IntersectKeys(this->appendList, fiop->appendList, result->appendList);
        IntersectKeys(this->pathList, fiop->pathList, result->pathList);
        return result->IsEmpty() ? nullptr : result;
    }
    
    bool FileIOPermission::IsSubsetOf_76947f8575c4d81(System::Security::IPermission* target) {
        FileIOPermission *fiop = Cast(target);
        if((fiop ==  nullptr)) 
        {
            return false;
        }
        if(fiop->IsEmpty()) 
        {
            return IsEmpty();
        }
        if(IsUnrestricted2()) 
        {
            return fiop->IsUnrestricted2();
        }
         else 
        {
            if(fiop->IsUnrestricted2()) 
            {
                return true;
            }
        }
        if(((int32_t)(((int32_t)(this->m_AllFilesAccess) & (int32_t)(fiop->get_AllFiles()))) != (int32_t)(this->m_AllFilesAccess))) 
        {
            return false;
        }
        if(((int32_t)(((int32_t)(this->m_AllLocalFilesAccess) & (int32_t)(fiop->get_AllLocalFiles()))) != (int32_t)(this->m_AllLocalFilesAccess))) 
        {
            return false;
        }
        if(!(KeyIsSubsetOf(this->appendList, fiop->appendList))) 
        {
            return false;
        }
        if(!(KeyIsSubsetOf(this->readList, fiop->readList))) 
        {
            return false;
        }
        if(!(KeyIsSubsetOf(this->writeList, fiop->writeList))) 
        {
            return false;
        }
        if(!(KeyIsSubsetOf(this->pathList, fiop->pathList))) 
        {
            return false;
        }
        return true;
    }
    
    bool FileIOPermission::IsUnrestricted2() {
        return this->m_Unrestricted;
    }
    
    void FileIOPermission::SetPathList(FileIOPermissionAccess access, System::String* path) {
        if(((int32_t)((15 & (int32_t)(access))) != (int32_t)(access))) 
        {
            ThrowInvalidFlag(access, true);
        }
        ThrowIfInvalidPath(path);
        Clear(access);
        AddPathInternal(access, path);
    }
    
    void FileIOPermission::SetPathList2(FileIOPermissionAccess access, cli::array<System::String*>* pathList) {
        if(((int32_t)((15 & (int32_t)(access))) != (int32_t)(access))) 
        {
            ThrowInvalidFlag(access, true);
        }
        ThrowIfInvalidPath2(pathList);
        Clear(access);
        for(auto tmp_535 : pathList) {
            auto path = cli::cast<System::String*>(tmp_535);
            AddPathInternal(access, path);
        }
    }
    
    System::Security::SecurityElement* FileIOPermission::ToXml_9ee4cd8af8e8f747() {
        System::Security::SecurityElement *se = System::Security::CodeAccessPermission::Element2(1);
        if(this->m_Unrestricted) 
        {
            se->AddAttribute(_T("Unrestricted"), _T("true"));
        }
         else 
        {
            cli::array<System::String*> *paths = GetPathList(FileIOPermissionAccess::Append);
            if(((paths != nullptr) && (paths->get_Length() > 0))) 
            {
                se->AddAttribute(_T("Append"), System::String::Join(_T(";"), paths));
            }
            paths = GetPathList(FileIOPermissionAccess::Read);
            if(((paths != nullptr) && (paths->get_Length() > 0))) 
            {
                se->AddAttribute(_T("Read"), System::String::Join(_T(";"), paths));
            }
            paths = GetPathList(FileIOPermissionAccess::Write);
            if(((paths != nullptr) && (paths->get_Length() > 0))) 
            {
                se->AddAttribute(_T("Write"), System::String::Join(_T(";"), paths));
            }
            paths = GetPathList(FileIOPermissionAccess::PathDiscovery);
            if(((paths != nullptr) && (paths->get_Length() > 0))) 
            {
                se->AddAttribute(_T("PathDiscovery"), System::String::Join(_T(";"), paths));
            }
        }
        return se;
    }
    
    System::Security::IPermission* FileIOPermission::Union_b0ddcab6cb9c8441(System::Security::IPermission* other) {
        FileIOPermission *fiop = Cast(other);
        if((fiop ==  nullptr)) 
        {
            return Copy_e6fdf74d8dfaca72();
        }
        if((IsUnrestricted2() || fiop->IsUnrestricted2())) 
        {
            return cli::gcnew<FileIOPermission>(PermissionState::Unrestricted);
        }
        if((IsEmpty() && fiop->IsEmpty())) 
        {
            return nullptr;
        }
        FileIOPermission *result = cli::cast<FileIOPermission*>(Copy_e6fdf74d8dfaca72());
        (result->set_AllFiles((FileIOPermissionAccess)(((int32_t)(result->get_AllFiles()) | (int32_t)(fiop->get_AllFiles())))));
        (result->set_AllLocalFiles((FileIOPermissionAccess)(((int32_t)(result->get_AllLocalFiles()) | (int32_t)(fiop->get_AllLocalFiles())))));
        cli::array<System::String*> *paths = fiop->GetPathList(FileIOPermissionAccess::Read);
        if((paths != nullptr)) 
        {
            UnionKeys(result->readList, paths);
        }
        paths = fiop->GetPathList(FileIOPermissionAccess::Write);
        if((paths != nullptr)) 
        {
            UnionKeys(result->writeList, paths);
        }
        paths = fiop->GetPathList(FileIOPermissionAccess::Append);
        if((paths != nullptr)) 
        {
            UnionKeys(result->appendList, paths);
        }
        paths = fiop->GetPathList(FileIOPermissionAccess::PathDiscovery);
        if((paths != nullptr)) 
        {
            UnionKeys(result->pathList, paths);
        }
        return result;
    }
    
    bool FileIOPermission::Equals_ed975d2f4a7d193e(System::Object* obj) {
        return false;
    }
    
    int32_t FileIOPermission::GetHashCode_6648aef0f235ee6c() {
        return System::Security::CodeAccessPermission::GetHashCode_6648aef0f235ee6c();
    }
    
    int32_t FileIOPermission::GetTokenIndex() {
        return 2;
    }
    
    bool FileIOPermission::IsEmpty() {
        return ((((!(this->m_Unrestricted) && (this->appendList->get_Count_2354963792616712() ==  0)) && (this->readList->get_Count_2354963792616712() ==  0)) && (this->writeList->get_Count_2354963792616712() ==  0)) && (this->pathList->get_Count_2354963792616712() ==  0));
    }
    
    FileIOPermission* FileIOPermission::Cast(System::Security::IPermission* target) {
        if((target ==  nullptr)) 
        {
            return nullptr;
        }
        FileIOPermission *fiop = cli::as<FileIOPermission*>(target);
        if((fiop ==  nullptr)) 
        {
            System::Security::CodeAccessPermission::ThrowInvalidPermission(target, cli::typeof<System::Type>::info);
        }
        return fiop;
    }
    
    void FileIOPermission::ThrowInvalidFlag(FileIOPermissionAccess access, bool context) {
        System::String *msg = nullptr;
        if(context) 
        {
            msg = Locale::GetText(_T("Unknown flag \'{0}\'."));
        }
         else 
        {
            msg = Locale::GetText(_T("Invalid flag \'{0}\' in this context."));
        }
        throw cli::gcnew<System::ArgumentException>(System::String::Format2(msg, cli::box(access)), _T("access"));
    }
    
    void FileIOPermission::ThrowIfInvalidPath(System::String* path) {
        System::String *dir = System::IO::Path::GetDirectoryName(path);
        if(((dir != nullptr) && (dir->LastIndexOfAny(BadPathNameCharacters) >= 0))) 
        {
            System::String *msg = System::String::Format2(Locale::GetText(_T("Invalid path characters in path: \'{0}\'")), path);
            throw cli::gcnew<System::ArgumentException>(msg, _T("path"));
        }
        System::String *fname = System::IO::Path::GetFileName(path);
        if(((fname != nullptr) && (fname->LastIndexOfAny(BadFileNameCharacters) >= 0))) 
        {
            System::String *msg = System::String::Format2(Locale::GetText(_T("Invalid filename characters in path: \'{0}\'")), path);
            throw cli::gcnew<System::ArgumentException>(msg, _T("path"));
        }
        if(!(System::IO::Path::IsPathRooted(path))) 
        {
            System::String *msg = Locale::GetText(_T("Absolute path information is required."));
            throw cli::gcnew<System::ArgumentException>(msg, _T("path"));
        }
    }
    
    void FileIOPermission::ThrowIfInvalidPath2(cli::array<System::String*>* paths) {
        for(auto tmp_536 : paths) {
            auto path = cli::cast<System::String*>(tmp_536);
            ThrowIfInvalidPath(path);
        }
    }
    
    void FileIOPermission::Clear(FileIOPermissionAccess access) {
        if(((int32_t)(((int32_t)(access) & 1)) ==  1)) 
        {
            this->readList->Clear_cd6654e5a40f5056();
        }
        if(((int32_t)(((int32_t)(access) & 2)) ==  2)) 
        {
            this->writeList->Clear_cd6654e5a40f5056();
        }
        if(((int32_t)(((int32_t)(access) & 4)) ==  4)) 
        {
            this->appendList->Clear_cd6654e5a40f5056();
        }
        if(((int32_t)(((int32_t)(access) & 8)) ==  8)) 
        {
            this->pathList->Clear_cd6654e5a40f5056();
        }
    }
    
    bool FileIOPermission::KeyIsSubsetOf(System::Collections::IList* local, System::Collections::IList* target) {
        bool result = false;
        for(auto tmp_537 : local) {
            auto l = cli::cast<System::String*>(tmp_537);
            {
                for(auto tmp_538 : target) {
                    auto t = cli::cast<System::String*>(tmp_538);
                    {
                        if(System::IO::Path::IsPathSubsetOf(t, l)) 
                        {
                            result = true;
                            break;
                        }
                    }
                }
                if(!(result)) 
                {
                    return false;
                }
            }
        }
        return true;
    }
    
    void FileIOPermission::UnionKeys(System::Collections::IList* list, cli::array<System::String*>* paths) {
        for(auto tmp_539 : paths) {
            auto path = cli::cast<System::String*>(tmp_539);
            {
                int32_t len = list->get_Count_8f254f3dd8e2403();
                if((len ==  0)) 
                {
                    list->Add_985508e3bf9b7a73(path);
                }
                 else 
                {
                    int32_t i;
                    for(i = 0; (i < len); i++){
                        System::String *s = cli::cast<System::String*>(list->get_Item_8550d21996ef9dc5(i));
                        if(System::IO::Path::IsPathSubsetOf(path, s)) 
                        {
                            list->set_Item_d57705373e0668e7(i, path);
                            break;
                        }
                         else 
                        {
                            if(System::IO::Path::IsPathSubsetOf(s, path)) 
                            {
                                break;
                            }
                        }
                    }
                    if((i ==  len)) 
                    {
                        list->Add_985508e3bf9b7a73(path);
                    }
                }
            }
        }
    }
    
    void FileIOPermission::IntersectKeys(System::Collections::IList* local, System::Collections::IList* target, System::Collections::IList* result) {
        for(auto tmp_540 : local) {
            auto l = cli::cast<System::String*>(tmp_540);
            {
                for(auto tmp_541 : target) {
                    auto t = cli::cast<System::String*>(tmp_541);
                    {
                        if((t->get_Length() > l->get_Length())) 
                        {
                            if(System::IO::Path::IsPathSubsetOf(l, t)) 
                            {
                                result->Add_985508e3bf9b7a73(t);
                            }
                        }
                         else 
                        {
                            if(System::IO::Path::IsPathSubsetOf(t, l)) 
                            {
                                result->Add_985508e3bf9b7a73(l);
                            }
                        }
                    }
                }
            }
        }
    }
    
    FileIOPermissionAccess FileIOPermission::get_AllFiles() {
        return this->m_AllFilesAccess;
    }
    
    FileIOPermissionAccess FileIOPermission::set_AllFiles(FileIOPermissionAccess value) {
        if(!(this->m_Unrestricted)) 
        {
            this->m_AllFilesAccess = value;
        }
        return get_AllFiles();
    }
    
    FileIOPermissionAccess FileIOPermission::get_AllLocalFiles() {
        return this->m_AllLocalFilesAccess;
    }
    
    FileIOPermissionAccess FileIOPermission::set_AllLocalFiles(FileIOPermissionAccess value) {
        if(!(this->m_Unrestricted)) 
        {
            this->m_AllLocalFilesAccess = value;
        }
        return get_AllLocalFiles();
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    
    
    void FileIOPermissionAttribute::constructor(SecurityAction action) {
    }
    
    System::Security::IPermission* FileIOPermissionAttribute::CreatePermission_cae8413caba48c05() {
        FileIOPermission *perm = nullptr;
        if(this->get_Unrestricted()) 
        {
            perm = cli::gcnew<FileIOPermission>(PermissionState::Unrestricted);
        }
         else 
        {
            perm = cli::gcnew<FileIOPermission>(PermissionState::None);
            if((this->append != nullptr)) 
            {
                perm->AddPathList(FileIOPermissionAccess::Append, this->append);
            }
            if((this->path != nullptr)) 
            {
                perm->AddPathList(FileIOPermissionAccess::PathDiscovery, this->path);
            }
            if((this->read != nullptr)) 
            {
                perm->AddPathList(FileIOPermissionAccess::Read, this->read);
            }
            if((this->write != nullptr)) 
            {
                perm->AddPathList(FileIOPermissionAccess::Write, this->write);
            }
        }
        return perm;
    }
    
    System::String* FileIOPermissionAttribute::get_All() {
        throw cli::gcnew<System::NotSupportedException>(_T("All"));
    }
    
    System::String* FileIOPermissionAttribute::set_All(System::String* value) {
        this->append = value;
        this->path = value;
        this->read = value;
        this->write = value;
        return get_All();
    }
    
    System::String* FileIOPermissionAttribute::get_Append() {
        return this->append;
    }
    
    System::String* FileIOPermissionAttribute::set_Append(System::String* value) {
        this->append = value;
        return get_Append();
    }
    
    System::String* FileIOPermissionAttribute::get_PathDiscovery() {
        return this->path;
    }
    
    System::String* FileIOPermissionAttribute::set_PathDiscovery(System::String* value) {
        this->path = value;
        return get_PathDiscovery();
    }
    
    System::String* FileIOPermissionAttribute::get_Read() {
        return this->read;
    }
    
    System::String* FileIOPermissionAttribute::set_Read(System::String* value) {
        this->read = value;
        return get_Read();
    }
    
    System::String* FileIOPermissionAttribute::get_Write() {
        return this->write;
    }
    
    System::String* FileIOPermissionAttribute::set_Write(System::String* value) {
        this->write = value;
        return get_Write();
    }
    
    FileIOPermissionAccess FileIOPermissionAttribute::get_AllFiles() {
        return this->allFiles;
    }
    
    FileIOPermissionAccess FileIOPermissionAttribute::set_AllFiles(FileIOPermissionAccess value) {
        this->allFiles = value;
        return get_AllFiles();
    }
    
    FileIOPermissionAccess FileIOPermissionAttribute::get_AllLocalFiles() {
        return this->allLocalFiles;
    }
    
    FileIOPermissionAccess FileIOPermissionAttribute::set_AllLocalFiles(FileIOPermissionAccess value) {
        this->allLocalFiles = value;
        return get_AllLocalFiles();
    }
    
    System::String* FileIOPermissionAttribute::get_ChangeAccessControl() {
        return this->changeAccessControl;
    }
    
    System::String* FileIOPermissionAttribute::set_ChangeAccessControl(System::String* value) {
        this->changeAccessControl = value;
        return get_ChangeAccessControl();
    }
    
    System::String* FileIOPermissionAttribute::get_ViewAccessControl() {
        return this->viewAccessControl;
    }
    
    System::String* FileIOPermissionAttribute::set_ViewAccessControl(System::String* value) {
        this->viewAccessControl = value;
        return get_ViewAccessControl();
    }
    
    System::String* FileIOPermissionAttribute::get_ViewAndModify() {
        throw cli::gcnew<System::NotSupportedException>();
    }
    
    System::String* FileIOPermissionAttribute::set_ViewAndModify(System::String* value) {
        this->append = value;
        this->path = value;
        this->read = value;
        this->write = value;
        return get_ViewAndModify();
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    
    
    void GacIdentityPermission::constructor() {
    }
    
    void GacIdentityPermission::constructor(PermissionState state) {
        System::Security::CodeAccessPermission::CheckPermissionState(state, false);
    }
    
    System::Security::IPermission* GacIdentityPermission::Copy_d1e925db301dc53f() {
        return cli::cast<System::Security::IPermission*>(cli::gcnew<GacIdentityPermission>());
    }
    
    System::Security::IPermission* GacIdentityPermission::Intersect_7dbf5aef702b16af(System::Security::IPermission* target) {
        GacIdentityPermission *gip = Cast(target);
        if((gip ==  nullptr)) 
        {
            return nullptr;
        }
        return Copy_e6fdf74d8dfaca72();
    }
    
    bool GacIdentityPermission::IsSubsetOf_76947f8575c4d81(System::Security::IPermission* target) {
        GacIdentityPermission *gip = Cast(target);
        return (gip != nullptr);
    }
    
    System::Security::IPermission* GacIdentityPermission::Union_b0ddcab6cb9c8441(System::Security::IPermission* target) {
        Cast(target);
        return Copy_e6fdf74d8dfaca72();
    }
    
    void GacIdentityPermission::FromXml_ec3b425a66b43072(System::Security::SecurityElement* securityElement) {
        System::Security::CodeAccessPermission::CheckSecurityElement(securityElement, _T("securityElement"), 1, 1);
    }
    
    System::Security::SecurityElement* GacIdentityPermission::ToXml_9ee4cd8af8e8f747() {
        System::Security::SecurityElement *se = System::Security::CodeAccessPermission::Element2(1);
        return se;
    }
    
    int32_t GacIdentityPermission::GetTokenIndex() {
        return 15;
    }
    
    GacIdentityPermission* GacIdentityPermission::Cast(System::Security::IPermission* target) {
        if((target ==  nullptr)) 
        {
            return nullptr;
        }
        GacIdentityPermission *uip = cli::as<GacIdentityPermission*>(target);
        if((uip ==  nullptr)) 
        {
            System::Security::CodeAccessPermission::ThrowInvalidPermission(target, cli::typeof<System::Type>::info);
        }
        return uip;
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    
    
    void GacIdentityPermissionAttribute::constructor(SecurityAction action) {
    }
    
    System::Security::IPermission* GacIdentityPermissionAttribute::CreatePermission_cae8413caba48c05() {
        return cli::cast<System::Security::IPermission*>(cli::gcnew<GacIdentityPermission>());
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    
    
    void HostProtectionAttribute::constructor() {
    }
    
    void HostProtectionAttribute::constructor(SecurityAction action) {
        if(((int32_t)(action) != 6)) 
        {
            System::String *msg = System::String::Format2(Locale::GetText(_T("Only {0} is accepted.")), cli::box(SecurityAction::LinkDemand));
            throw cli::gcnew<System::ArgumentException>(msg, _T("action"));
        }
    }
    
    System::Security::IPermission* HostProtectionAttribute::CreatePermission_cae8413caba48c05() {
        return cli::gcnew<HostProtectionPermission>(this->_resources);
    }
    
    bool HostProtectionAttribute::get_ExternalProcessMgmt() {
        return ((int32_t)(((int32_t)(this->_resources) & 4)) != 0);
    }
    
    bool HostProtectionAttribute::set_ExternalProcessMgmt(bool value) {
        if(value) 
        {
            (this->_resources = (HostProtectionResource)(((int32_t)(this->_resources) | 4)));
        }
         else 
        {
            (this->_resources = (HostProtectionResource)(((int32_t)(this->_resources) & -5)));
        }
        return get_ExternalProcessMgmt();
    }
    
    bool HostProtectionAttribute::get_ExternalThreading() {
        return ((int32_t)(((int32_t)(this->_resources) & 16)) != 0);
    }
    
    bool HostProtectionAttribute::set_ExternalThreading(bool value) {
        if(value) 
        {
            (this->_resources = (HostProtectionResource)(((int32_t)(this->_resources) | 16)));
        }
         else 
        {
            (this->_resources = (HostProtectionResource)(((int32_t)(this->_resources) & -17)));
        }
        return get_ExternalThreading();
    }
    
    bool HostProtectionAttribute::get_MayLeakOnAbort() {
        return ((int32_t)(((int32_t)(this->_resources) & 256)) != 0);
    }
    
    bool HostProtectionAttribute::set_MayLeakOnAbort(bool value) {
        if(value) 
        {
            (this->_resources = (HostProtectionResource)(((int32_t)(this->_resources) | 256)));
        }
         else 
        {
            (this->_resources = (HostProtectionResource)(((int32_t)(this->_resources) & -257)));
        }
        return get_MayLeakOnAbort();
    }
    
    bool HostProtectionAttribute::get_SecurityInfrastructure() {
        return ((int32_t)(((int32_t)(this->_resources) & 64)) != 0);
    }
    
    bool HostProtectionAttribute::set_SecurityInfrastructure(bool value) {
        if(value) 
        {
            (this->_resources = (HostProtectionResource)(((int32_t)(this->_resources) | 64)));
        }
         else 
        {
            (this->_resources = (HostProtectionResource)(((int32_t)(this->_resources) & -65)));
        }
        return get_SecurityInfrastructure();
    }
    
    bool HostProtectionAttribute::get_SelfAffectingProcessMgmt() {
        return ((int32_t)(((int32_t)(this->_resources) & 8)) != 0);
    }
    
    bool HostProtectionAttribute::set_SelfAffectingProcessMgmt(bool value) {
        if(value) 
        {
            (this->_resources = (HostProtectionResource)(((int32_t)(this->_resources) | 8)));
        }
         else 
        {
            (this->_resources = (HostProtectionResource)(((int32_t)(this->_resources) & -9)));
        }
        return get_SelfAffectingProcessMgmt();
    }
    
    bool HostProtectionAttribute::get_SelfAffectingThreading() {
        return ((int32_t)(((int32_t)(this->_resources) & 32)) != 0);
    }
    
    bool HostProtectionAttribute::set_SelfAffectingThreading(bool value) {
        if(value) 
        {
            (this->_resources = (HostProtectionResource)(((int32_t)(this->_resources) | 32)));
        }
         else 
        {
            (this->_resources = (HostProtectionResource)(((int32_t)(this->_resources) & -33)));
        }
        return get_SelfAffectingThreading();
    }
    
    bool HostProtectionAttribute::get_SharedState() {
        return ((int32_t)(((int32_t)(this->_resources) & 2)) != 0);
    }
    
    bool HostProtectionAttribute::set_SharedState(bool value) {
        if(value) 
        {
            (this->_resources = (HostProtectionResource)(((int32_t)(this->_resources) | 2)));
        }
         else 
        {
            (this->_resources = (HostProtectionResource)(((int32_t)(this->_resources) & -3)));
        }
        return get_SharedState();
    }
    
    bool HostProtectionAttribute::get_Synchronization() {
        return ((int32_t)(((int32_t)(this->_resources) & 1)) != 0);
    }
    
    bool HostProtectionAttribute::set_Synchronization(bool value) {
        if(value) 
        {
            (this->_resources = (HostProtectionResource)(((int32_t)(this->_resources) | 1)));
        }
         else 
        {
            (this->_resources = (HostProtectionResource)(((int32_t)(this->_resources) & -2)));
        }
        return get_Synchronization();
    }
    
    bool HostProtectionAttribute::get_UI() {
        return ((int32_t)(((int32_t)(this->_resources) & 128)) != 0);
    }
    
    bool HostProtectionAttribute::set_UI(bool value) {
        if(value) 
        {
            (this->_resources = (HostProtectionResource)(((int32_t)(this->_resources) | 128)));
        }
         else 
        {
            (this->_resources = (HostProtectionResource)(((int32_t)(this->_resources) & -129)));
        }
        return get_UI();
    }
    
    HostProtectionResource HostProtectionAttribute::get_Resources() {
        return this->_resources;
    }
    
    HostProtectionResource HostProtectionAttribute::set_Resources(HostProtectionResource value) {
        this->_resources = value;
        return get_Resources();
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    
    
    void HostProtectionPermission::constructor(PermissionState state) {
        if(((int32_t)(System::Security::CodeAccessPermission::CheckPermissionState(state, true)) ==  1)) 
        {
            this->_resources = HostProtectionResource::All;
        }
         else 
        {
            this->_resources = HostProtectionResource::None;
        }
    }
    
    void HostProtectionPermission::constructor(HostProtectionResource resources) {
        this->set_Resources(this->_resources);
    }
    
    System::Security::IPermission* HostProtectionPermission::Copy_d1e925db301dc53f() {
        return cli::gcnew<HostProtectionPermission>(this->_resources);
    }
    
    System::Security::IPermission* HostProtectionPermission::Intersect_7dbf5aef702b16af(System::Security::IPermission* target) {
        HostProtectionPermission *hpp = Cast(target);
        if((hpp ==  nullptr)) 
        {
            return nullptr;
        }
        if((this->IsUnrestricted2() && hpp->IsUnrestricted2())) 
        {
            return cli::gcnew<HostProtectionPermission>(PermissionState::Unrestricted);
        }
        if(this->IsUnrestricted2()) 
        {
            return hpp->Copy_d1e925db301dc53f();
        }
        if(hpp->IsUnrestricted2()) 
        {
            return this->Copy_d1e925db301dc53f();
        }
        return cli::gcnew<HostProtectionPermission>((HostProtectionResource)(((int32_t)(this->_resources) & (int32_t)(hpp->_resources))));
    }
    
    System::Security::IPermission* HostProtectionPermission::Union_b0ddcab6cb9c8441(System::Security::IPermission* target) {
        HostProtectionPermission *hpp = Cast(target);
        if((hpp ==  nullptr)) 
        {
            return this->Copy_d1e925db301dc53f();
        }
        if((this->IsUnrestricted2() || hpp->IsUnrestricted2())) 
        {
            return cli::gcnew<HostProtectionPermission>(PermissionState::Unrestricted);
        }
        return cli::gcnew<HostProtectionPermission>((HostProtectionResource)(((int32_t)(this->_resources) | (int32_t)(hpp->_resources))));
    }
    
    bool HostProtectionPermission::IsSubsetOf_76947f8575c4d81(System::Security::IPermission* target) {
        HostProtectionPermission *hpp = Cast(target);
        if((hpp ==  nullptr)) 
        {
            return ((int32_t)(this->_resources) ==  0);
        }
        if(hpp->IsUnrestricted2()) 
        {
            return true;
        }
        if(this->IsUnrestricted2()) 
        {
            return false;
        }
        return ((int32_t)(((int32_t)(this->_resources) & (int32_t)(~((int32_t)(hpp->_resources))))) ==  0);
    }
    
    void HostProtectionPermission::FromXml_ec3b425a66b43072(System::Security::SecurityElement* e) {
        System::Security::CodeAccessPermission::CheckSecurityElement(e, _T("e"), 1, 1);
        this->_resources = cli::unbox<HostProtectionResource>(System::Enum::Parse(cli::typeof<System::Type>::info, e->Attribute2(_T("Resources"))));
    }
    
    System::Security::SecurityElement* HostProtectionPermission::ToXml_9ee4cd8af8e8f747() {
        System::Security::SecurityElement *e = System::Security::CodeAccessPermission::Element2(1);
        e->AddAttribute(_T("Resources"), cli::import(this->_resources)->ToString_1636a0751cb9ac11());
        return e;
    }
    
    bool HostProtectionPermission::IsUnrestricted2() {
        return ((int32_t)(this->_resources) ==  511);
    }
    
    int32_t HostProtectionPermission::GetTokenIndex() {
        return 9;
    }
    
    HostProtectionPermission* HostProtectionPermission::Cast(System::Security::IPermission* target) {
        if((target ==  nullptr)) 
        {
            return nullptr;
        }
        HostProtectionPermission *hpp = cli::as<HostProtectionPermission*>(target);
        if((hpp ==  nullptr)) 
        {
            System::Security::CodeAccessPermission::ThrowInvalidPermission(target, cli::typeof<System::Type>::info);
        }
        return hpp;
    }
    
    HostProtectionResource HostProtectionPermission::get_Resources() {
        return this->_resources;
    }
    
    HostProtectionResource HostProtectionPermission::set_Resources(HostProtectionResource value) {
        if(!(System::Enum::IsDefined(cli::typeof<System::Type>::info, cli::box(value)))) 
        {
            System::String *msg = System::String::Format2(Locale::GetText(_T("Invalid enum {0}")), cli::box(value));
            throw cli::gcnew<System::ArgumentException>(msg, _T("HostProtectionResource"));
        }
        this->_resources = value;
        return get_Resources();
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    
    
    void IsolatedStorageFilePermission::constructor(PermissionState state) {
    }
    
    System::Security::IPermission* IsolatedStorageFilePermission::Copy_d1e925db301dc53f() {
        IsolatedStorageFilePermission *p = cli::gcnew<IsolatedStorageFilePermission>(PermissionState::None);
        p->m_userQuota = this->m_userQuota;
        p->m_machineQuota = this->m_machineQuota;
        p->m_expirationDays = this->m_expirationDays;
        p->m_permanentData = this->m_permanentData;
        p->m_allowed = this->m_allowed;
        return p;
    }
    
    System::Security::IPermission* IsolatedStorageFilePermission::Intersect_7dbf5aef702b16af(System::Security::IPermission* target) {
        IsolatedStorageFilePermission *isfp = Cast(target);
        if((isfp ==  nullptr)) 
        {
            return nullptr;
        }
        if((IsolatedStoragePermission::IsEmpty() && isfp->IsEmpty())) 
        {
            return nullptr;
        }
        IsolatedStorageFilePermission *p = cli::gcnew<IsolatedStorageFilePermission>(PermissionState::None);
        p->m_userQuota = (this->m_userQuota < isfp->m_userQuota) ? this->m_userQuota : isfp->m_userQuota;
        p->m_machineQuota = (this->m_machineQuota < isfp->m_machineQuota) ? this->m_machineQuota : isfp->m_machineQuota;
        p->m_expirationDays = (this->m_expirationDays < isfp->m_expirationDays) ? this->m_expirationDays : isfp->m_expirationDays;
        p->m_permanentData = (this->m_permanentData && isfp->m_permanentData);
        p->set_UsageAllowed(((int32_t)(this->m_allowed) < (int32_t)(isfp->m_allowed)) ? this->m_allowed : isfp->m_allowed);
        return p;
    }
    
    bool IsolatedStorageFilePermission::IsSubsetOf_76947f8575c4d81(System::Security::IPermission* target) {
        IsolatedStorageFilePermission *isfp = Cast(target);
        if((isfp ==  nullptr)) 
        {
            return IsolatedStoragePermission::IsEmpty();
        }
        if(isfp->IsUnrestricted2()) 
        {
            return true;
        }
        if((this->m_userQuota > isfp->m_userQuota)) 
        {
            return false;
        }
        if((this->m_machineQuota > isfp->m_machineQuota)) 
        {
            return false;
        }
        if((this->m_expirationDays > isfp->m_expirationDays)) 
        {
            return false;
        }
        if((this->m_permanentData != isfp->m_permanentData)) 
        {
            return false;
        }
        if(((int32_t)(this->m_allowed) > (int32_t)(isfp->m_allowed))) 
        {
            return false;
        }
        return true;
    }
    
    System::Security::IPermission* IsolatedStorageFilePermission::Union_b0ddcab6cb9c8441(System::Security::IPermission* target) {
        IsolatedStorageFilePermission *isfp = Cast(target);
        if((isfp ==  nullptr)) 
        {
            return Copy_e6fdf74d8dfaca72();
        }
        IsolatedStorageFilePermission *p = cli::gcnew<IsolatedStorageFilePermission>(PermissionState::None);
        p->m_userQuota = (this->m_userQuota > isfp->m_userQuota) ? this->m_userQuota : isfp->m_userQuota;
        p->m_machineQuota = (this->m_machineQuota > isfp->m_machineQuota) ? this->m_machineQuota : isfp->m_machineQuota;
        p->m_expirationDays = (this->m_expirationDays > isfp->m_expirationDays) ? this->m_expirationDays : isfp->m_expirationDays;
        p->m_permanentData = (this->m_permanentData || isfp->m_permanentData);
        p->set_UsageAllowed(((int32_t)(this->m_allowed) > (int32_t)(isfp->m_allowed)) ? this->m_allowed : isfp->m_allowed);
        return p;
    }
    
    System::Security::SecurityElement* IsolatedStorageFilePermission::ToXml_9ee4cd8af8e8f747() {
        return IsolatedStoragePermission::ToXml_9ee4cd8af8e8f747();
    }
    
    int32_t IsolatedStorageFilePermission::GetTokenIndex() {
        return 3;
    }
    
    IsolatedStorageFilePermission* IsolatedStorageFilePermission::Cast(System::Security::IPermission* target) {
        if((target ==  nullptr)) 
        {
            return nullptr;
        }
        IsolatedStorageFilePermission *isfp = cli::as<IsolatedStorageFilePermission*>(target);
        if((isfp ==  nullptr)) 
        {
            System::Security::CodeAccessPermission::ThrowInvalidPermission(target, cli::typeof<System::Type>::info);
        }
        return isfp;
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    
    
    void IsolatedStorageFilePermissionAttribute::constructor(SecurityAction action) {
    }
    
    System::Security::IPermission* IsolatedStorageFilePermissionAttribute::CreatePermission_cae8413caba48c05() {
        IsolatedStorageFilePermission *perm = nullptr;
        if(this->get_Unrestricted()) 
        {
            perm = cli::gcnew<IsolatedStorageFilePermission>(PermissionState::Unrestricted);
        }
         else 
        {
            perm = cli::gcnew<IsolatedStorageFilePermission>(PermissionState::None);
            perm->set_UsageAllowed(this->get_UsageAllowed());
            perm->set_UserQuota(this->get_UserQuota());
        }
        return perm;
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    
    
    void IsolatedStoragePermission::constructor(PermissionState state) {
        if(((int32_t)(System::Security::CodeAccessPermission::CheckPermissionState(state, true)) ==  1)) 
        {
            this->set_UsageAllowed(IsolatedStorageContainment::UnrestrictedIsolatedStorage);
        }
    }
    
    bool IsolatedStoragePermission::IsUnrestricted2() {
        return (240 ==  (int32_t)(this->m_allowed));
    }
    
    System::Security::SecurityElement* IsolatedStoragePermission::ToXml_9ee4cd8af8e8f747() {
        System::Security::SecurityElement *se = System::Security::CodeAccessPermission::Element2(1);
        if(((int32_t)(this->m_allowed) ==  240)) 
        {
            se->AddAttribute(_T("Unrestricted"), _T("true"));
        }
         else 
        {
            se->AddAttribute(_T("Allowed"), cli::import(this->m_allowed)->ToString_1636a0751cb9ac11());
            if((this->m_userQuota > 0L)) 
            {
                se->AddAttribute(_T("UserQuota"), cli::import(this->m_userQuota)->ToString_1636a0751cb9ac11());
            }
        }
        return se;
    }
    
    void IsolatedStoragePermission::FromXml_ec3b425a66b43072(System::Security::SecurityElement* esd) {
        System::Security::CodeAccessPermission::CheckSecurityElement(esd, _T("esd"), 1, 1);
        this->m_userQuota = 0L;
        this->m_machineQuota = 0L;
        this->m_expirationDays = 0L;
        this->m_permanentData = false;
        this->m_allowed = IsolatedStorageContainment::None;
        if(System::Security::CodeAccessPermission::IsUnrestricted(esd)) 
        {
            this->set_UsageAllowed(IsolatedStorageContainment::UnrestrictedIsolatedStorage);
        }
         else 
        {
            System::String *a = esd->Attribute2(_T("Allowed"));
            if((a != nullptr)) 
            {
                this->set_UsageAllowed(cli::unbox<IsolatedStorageContainment>(System::Enum::Parse(cli::typeof<System::Type>::info, a)));
            }
            a = esd->Attribute2(_T("UserQuota"));
            if((a != nullptr)) 
            {
                System::Exception *exc;
                System::Int64::Parse(a, true, this->m_userQuota, exc);
            }
        }
    }
    
    bool IsolatedStoragePermission::IsEmpty() {
        return ((this->m_userQuota ==  0L) && ((int32_t)(this->m_allowed) ==  0));
    }
    
    int64_t IsolatedStoragePermission::get_UserQuota() {
        return this->m_userQuota;
    }
    
    int64_t IsolatedStoragePermission::set_UserQuota(int64_t value) {
        this->m_userQuota = value;
        return get_UserQuota();
    }
    
    IsolatedStorageContainment IsolatedStoragePermission::get_UsageAllowed() {
        return this->m_allowed;
    }
    
    IsolatedStorageContainment IsolatedStoragePermission::set_UsageAllowed(IsolatedStorageContainment value) {
        if(!(System::Enum::IsDefined(cli::typeof<System::Type>::info, cli::box(value)))) 
        {
            System::String *msg = System::String::Format2(Locale::GetText(_T("Invalid enum {0}")), cli::box(value));
            throw cli::gcnew<System::ArgumentException>(msg, _T("IsolatedStorageContainment"));
        }
        this->m_allowed = value;
        if(((int32_t)(this->m_allowed) ==  240)) 
        {
            this->m_userQuota = 9223372036854775807L;
            this->m_machineQuota = 9223372036854775807L;
            this->m_expirationDays = 9223372036854775807L;
            this->m_permanentData = true;
        }
        return get_UsageAllowed();
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    
    
    void IsolatedStoragePermissionAttribute::constructor(SecurityAction action) {
    }
    
    IsolatedStorageContainment IsolatedStoragePermissionAttribute::get_UsageAllowed() {
        return this->usage_allowed;
    }
    
    IsolatedStorageContainment IsolatedStoragePermissionAttribute::set_UsageAllowed(IsolatedStorageContainment value) {
        this->usage_allowed = value;
        return get_UsageAllowed();
    }
    
    int64_t IsolatedStoragePermissionAttribute::get_UserQuota() {
        return this->user_quota;
    }
    
    int64_t IsolatedStoragePermissionAttribute::set_UserQuota(int64_t value) {
        this->user_quota = value;
        return get_UserQuota();
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    
    
    void KeyContainerPermission::constructor(PermissionState state) {
        if(((int32_t)(System::Security::CodeAccessPermission::CheckPermissionState(state, true)) ==  1)) 
        {
            this->_flags = KeyContainerPermissionFlags::AllFlags;
        }
    }
    
    void KeyContainerPermission::constructor(KeyContainerPermissionFlags flags) {
        SetFlags(flags);
    }
    
    void KeyContainerPermission::constructor(KeyContainerPermissionFlags flags, cli::array<KeyContainerPermissionAccessEntry*>* accessList) {
        SetFlags(flags);
        if((accessList != nullptr)) 
        {
            this->_accessEntries = cli::gcnew<KeyContainerPermissionAccessEntryCollection>();
            for(auto tmp_542 : accessList) {
                auto kcpae = cli::cast<KeyContainerPermissionAccessEntry*>(tmp_542);
                {
                    this->_accessEntries->Add(kcpae);
                }
            }
        }
    }
    
    System::Security::IPermission* KeyContainerPermission::Copy_d1e925db301dc53f() {
        if((this->_accessEntries->get_Count() ==  0)) 
        {
            return cli::gcnew<KeyContainerPermission>(this->_flags);
        }
        cli::array<KeyContainerPermissionAccessEntry*> *list = (new cli::array<KeyContainerPermissionAccessEntry*>(this->_accessEntries->get_Count()));
        this->_accessEntries->CopyTo(list, 0);
        return cli::gcnew<KeyContainerPermission>(this->_flags, list);
    }
    
    void KeyContainerPermission::FromXml_ec3b425a66b43072(System::Security::SecurityElement* securityElement) {
        System::Security::CodeAccessPermission::CheckSecurityElement(securityElement, _T("securityElement"), 1, 1);
        if(System::Security::CodeAccessPermission::IsUnrestricted(securityElement)) 
        {
            this->_flags = KeyContainerPermissionFlags::AllFlags;
        }
         else 
        {
            this->_flags = cli::unbox<KeyContainerPermissionFlags>(System::Enum::Parse(cli::typeof<System::Type>::info, securityElement->Attribute2(_T("Flags"))));
        }
    }
    
    System::Security::IPermission* KeyContainerPermission::Intersect_7dbf5aef702b16af(System::Security::IPermission* target) {
        return nullptr;
    }
    
    bool KeyContainerPermission::IsSubsetOf_76947f8575c4d81(System::Security::IPermission* target) {
        return false;
    }
    
    bool KeyContainerPermission::IsUnrestricted2() {
        return ((int32_t)(this->_flags) ==  13111);
    }
    
    System::Security::SecurityElement* KeyContainerPermission::ToXml_9ee4cd8af8e8f747() {
        System::Security::SecurityElement *e = System::Security::CodeAccessPermission::Element2(1);
        if(IsUnrestricted2()) 
        {
            e->AddAttribute(_T("Unrestricted"), _T("true"));
        }
         else 
        {
        }
        return e;
    }
    
    System::Security::IPermission* KeyContainerPermission::Union_b0ddcab6cb9c8441(System::Security::IPermission* target) {
        KeyContainerPermission *kcp = Cast(target);
        if((kcp ==  nullptr)) 
        {
            return Copy_e6fdf74d8dfaca72();
        }
        KeyContainerPermissionAccessEntryCollection *kcpaec = cli::gcnew<KeyContainerPermissionAccessEntryCollection>();
        for(auto tmp_543 : this->_accessEntries) {
            auto kcpae = cli::cast<KeyContainerPermissionAccessEntry*>(tmp_543);
            {
                kcpaec->Add(kcpae);
            }
        }
        for(auto tmp_544 : kcp->_accessEntries) {
            auto kcpae = cli::cast<KeyContainerPermissionAccessEntry*>(tmp_544);
            {
                if((this->_accessEntries->IndexOf(kcpae) ==  -1)) 
                {
                    kcpaec->Add(kcpae);
                }
            }
        }
        if((kcpaec->get_Count() ==  0)) 
        {
            return cli::gcnew<KeyContainerPermission>((KeyContainerPermissionFlags)(((int32_t)(this->_flags) | (int32_t)(kcp->_flags))));
        }
        cli::array<KeyContainerPermissionAccessEntry*> *list = (new cli::array<KeyContainerPermissionAccessEntry*>(kcpaec->get_Count()));
        kcpaec->CopyTo(list, 0);
        return cli::gcnew<KeyContainerPermission>((KeyContainerPermissionFlags)(((int32_t)(this->_flags) | (int32_t)(kcp->_flags))), list);
    }
    
    int32_t KeyContainerPermission::GetTokenIndex() {
        return 16;
    }
    
    void KeyContainerPermission::SetFlags(KeyContainerPermissionFlags flags) {
        if(((int32_t)(((int32_t)(flags) & 13111)) != 0)) 
        {
            System::String *msg = System::String::Format2(Locale::GetText(_T("Invalid enum {0}")), cli::box(flags));
            throw cli::gcnew<System::ArgumentException>(msg, _T("KeyContainerPermissionFlags"));
        }
        this->_flags = flags;
    }
    
    KeyContainerPermission* KeyContainerPermission::Cast(System::Security::IPermission* target) {
        if((target ==  nullptr)) 
        {
            return nullptr;
        }
        KeyContainerPermission *kcp = cli::as<KeyContainerPermission*>(target);
        if((kcp ==  nullptr)) 
        {
            System::Security::CodeAccessPermission::ThrowInvalidPermission(target, cli::typeof<System::Type>::info);
        }
        return kcp;
    }
    
    KeyContainerPermissionAccessEntryCollection* KeyContainerPermission::get_AccessEntries() {
        return this->_accessEntries;
    }
    
    KeyContainerPermissionFlags KeyContainerPermission::get_Flags() {
        return this->_flags;
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    
    
    void KeyContainerPermissionAccessEntry::constructor(System::Security::Cryptography::CspParameters* parameters, KeyContainerPermissionFlags flags) {
        if((parameters ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("parameters"));
        }
        this->set_ProviderName(parameters->ProviderName);
        this->set_ProviderType(parameters->ProviderType);
        this->set_KeyContainerName(parameters->KeyContainerName);
        this->set_KeySpec(parameters->KeyNumber2);
        this->set_Flags(flags);
    }
    
    void KeyContainerPermissionAccessEntry::constructor(System::String* keyContainerName, KeyContainerPermissionFlags flags) {
        this->set_KeyContainerName(keyContainerName);
        this->set_Flags(flags);
    }
    
    void KeyContainerPermissionAccessEntry::constructor(System::String* keyStore, System::String* providerName, int32_t providerType, System::String* keyContainerName, int32_t keySpec, KeyContainerPermissionFlags flags) {
        this->set_KeyStore(keyStore);
        this->set_ProviderName(providerName);
        this->set_ProviderType(providerType);
        this->set_KeyContainerName(keyContainerName);
        this->set_KeySpec(keySpec);
        this->set_Flags(flags);
    }
    
    bool KeyContainerPermissionAccessEntry::Equals_ed975d2f4a7d193e(System::Object* o) {
        if((o ==  nullptr)) 
        {
            return false;
        }
        KeyContainerPermissionAccessEntry *kcpae = cli::as<KeyContainerPermissionAccessEntry*>(o);
        if((kcpae ==  nullptr)) 
        {
            return false;
        }
        if(((int32_t)(this->_flags) != (int32_t)(kcpae->_flags))) 
        {
            return false;
        }
        if(System::String::op_Inequality(this->_containerName, kcpae->_containerName)) 
        {
            return false;
        }
        if(System::String::op_Inequality(this->_store, kcpae->_store)) 
        {
            return false;
        }
        if(System::String::op_Inequality(this->_providerName, kcpae->_providerName)) 
        {
            return false;
        }
        if((this->_type != kcpae->_type)) 
        {
            return false;
        }
        return true;
    }
    
    int32_t KeyContainerPermissionAccessEntry::GetHashCode_6648aef0f235ee6c() {
        int32_t result = ((this->_type ^ this->_spec) ^ (int32_t)(this->_flags));
        if((this->_containerName != nullptr)) 
        {
            (result = result ^ this->_containerName->GetHashCode_6648aef0f235ee6c());
        }
        if((this->_store != nullptr)) 
        {
            (result = result ^ this->_store->GetHashCode_6648aef0f235ee6c());
        }
        if((this->_providerName != nullptr)) 
        {
            (result = result ^ this->_providerName->GetHashCode_6648aef0f235ee6c());
        }
        return result;
    }
    
    KeyContainerPermissionFlags KeyContainerPermissionAccessEntry::get_Flags() {
        return this->_flags;
    }
    
    KeyContainerPermissionFlags KeyContainerPermissionAccessEntry::set_Flags(KeyContainerPermissionFlags value) {
        if(((int32_t)(((int32_t)(value) & 13111)) != 0)) 
        {
            System::String *msg = System::String::Format2(Locale::GetText(_T("Invalid enum {0}")), cli::box(value));
            throw cli::gcnew<System::ArgumentException>(msg, _T("KeyContainerPermissionFlags"));
        }
        this->_flags = value;
        return get_Flags();
    }
    
    System::String* KeyContainerPermissionAccessEntry::get_KeyContainerName() {
        return this->_containerName;
    }
    
    System::String* KeyContainerPermissionAccessEntry::set_KeyContainerName(System::String* value) {
        this->_containerName = value;
        return get_KeyContainerName();
    }
    
    int32_t KeyContainerPermissionAccessEntry::get_KeySpec() {
        return this->_spec;
    }
    
    int32_t KeyContainerPermissionAccessEntry::set_KeySpec(int32_t value) {
        this->_spec = value;
        return get_KeySpec();
    }
    
    System::String* KeyContainerPermissionAccessEntry::get_KeyStore() {
        return this->_store;
    }
    
    System::String* KeyContainerPermissionAccessEntry::set_KeyStore(System::String* value) {
        this->_store = value;
        return get_KeyStore();
    }
    
    System::String* KeyContainerPermissionAccessEntry::get_ProviderName() {
        return this->_providerName;
    }
    
    System::String* KeyContainerPermissionAccessEntry::set_ProviderName(System::String* value) {
        this->_providerName = value;
        return get_ProviderName();
    }
    
    int32_t KeyContainerPermissionAccessEntry::get_ProviderType() {
        return this->_type;
    }
    
    int32_t KeyContainerPermissionAccessEntry::set_ProviderType(int32_t value) {
        this->_type = value;
        return get_ProviderType();
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    
    
    void KeyContainerPermissionAccessEntryCollection::constructor() {
        this->_list = cli::gcnew<System::Collections::ArrayList>();
    }
    
    void KeyContainerPermissionAccessEntryCollection::constructor(cli::array<KeyContainerPermissionAccessEntry*>* entries) {
        if((entries != nullptr)) 
        {
            for(auto tmp_545 : entries) {
                auto kcpae = cli::cast<KeyContainerPermissionAccessEntry*>(tmp_545);
                {
                    Add(kcpae);
                }
            }
        }
    }
    
    int32_t KeyContainerPermissionAccessEntryCollection::Add(KeyContainerPermissionAccessEntry* accessEntry) {
        return this->_list->Add_e6a92085999ce388(accessEntry);
    }
    
    void KeyContainerPermissionAccessEntryCollection::Clear() {
        this->_list->Clear_cd6654e5a40f5056();
    }
    
    void KeyContainerPermissionAccessEntryCollection::CopyTo(cli::array<KeyContainerPermissionAccessEntry*>* array, int32_t index) {
        this->_list->CopyTo_2bc540dad3c25b9e(array, index);
    }
    
    void KeyContainerPermissionAccessEntryCollection::CopyTo2(System::Array* array, int32_t index) {
        this->_list->CopyTo_2bc540dad3c25b9e(array, index);
    }
    
    KeyContainerPermissionAccessEntryEnumerator* KeyContainerPermissionAccessEntryCollection::GetEnumerator() {
        return cli::gcnew<KeyContainerPermissionAccessEntryEnumerator>(this->_list);
    }
    
    System::Collections::IEnumerator* KeyContainerPermissionAccessEntryCollection::GetEnumerator2() {
        return cli::gcnew<KeyContainerPermissionAccessEntryEnumerator>(this->_list);
    }
    
    int32_t KeyContainerPermissionAccessEntryCollection::IndexOf(KeyContainerPermissionAccessEntry* accessEntry) {
        if((accessEntry ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("accessEntry"));
        }
        for(int32_t i = 0; (i < this->_list->get_Count_2354963792616712()); i++){
            if(accessEntry->Equals_ed975d2f4a7d193e(this->_list->get_Item_fd0155f142ae570(i))) 
            {
                return i;
            }
        }
        return -1;
    }
    
    void KeyContainerPermissionAccessEntryCollection::Remove(KeyContainerPermissionAccessEntry* accessEntry) {
        if((accessEntry ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("accessEntry"));
        }
        for(int32_t i = 0; (i < this->_list->get_Count_2354963792616712()); i++){
            if(accessEntry->Equals_ed975d2f4a7d193e(this->_list->get_Item_fd0155f142ae570(i))) 
            {
                this->_list->RemoveAt_2abea768d3273318(i);
            }
        }
    }
    
    int32_t KeyContainerPermissionAccessEntryCollection::get_Count() {
        return this->_list->get_Count_2354963792616712();
    }
    
    bool KeyContainerPermissionAccessEntryCollection::get_IsSynchronized() {
        return false;
    }
    
    KeyContainerPermissionAccessEntry* KeyContainerPermissionAccessEntryCollection::get_Item(int32_t index) {
        return cli::cast<KeyContainerPermissionAccessEntry*>(this->_list->get_Item_fd0155f142ae570(index));
    }
    
    System::Object* KeyContainerPermissionAccessEntryCollection::get_SyncRoot() {
        return this;
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    
    
    void KeyContainerPermissionAccessEntryEnumerator::constructor(System::Collections::ArrayList* list) {
        this->e = list->GetEnumerator_84e3ba8f2fdefd62();
    }
    
    bool KeyContainerPermissionAccessEntryEnumerator::MoveNext() {
        return this->e->MoveNext_4e78e145935f5417();
    }
    
    void KeyContainerPermissionAccessEntryEnumerator::Reset() {
        this->e->Reset_bcd82381eed41868();
    }
    
    KeyContainerPermissionAccessEntry* KeyContainerPermissionAccessEntryEnumerator::get_Current() {
        return cli::cast<KeyContainerPermissionAccessEntry*>(this->e->get_Current_8eca9b3da02b123a());
    }
    
    System::Object* KeyContainerPermissionAccessEntryEnumerator::get_Current2() {
        return this->e->get_Current_8eca9b3da02b123a();
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    
    
    void KeyContainerPermissionAttribute::constructor(SecurityAction action) {
        this->_spec = -1;
        this->_type = -1;
    }
    
    System::Security::IPermission* KeyContainerPermissionAttribute::CreatePermission_cae8413caba48c05() {
        if(this->get_Unrestricted()) 
        {
            return cli::gcnew<KeyContainerPermission>(PermissionState::Unrestricted);
        }
         else 
        {
            if(EmptyEntry()) 
            {
                return cli::gcnew<KeyContainerPermission>(this->_flags);
            }
             else 
            {
                cli::array<KeyContainerPermissionAccessEntry*> *list = (new cli::array<KeyContainerPermissionAccessEntry*>(1));
                list->at(0) = cli::gcnew<KeyContainerPermissionAccessEntry>(this->_store, this->_providerName, this->_type, this->_containerName, this->_spec, this->_flags);
                return cli::gcnew<KeyContainerPermission>(this->_flags, list);
            }
        }
    }
    
    bool KeyContainerPermissionAttribute::EmptyEntry() {
        if((this->_containerName != nullptr)) 
        {
            return false;
        }
        if((this->_spec != 0)) 
        {
            return false;
        }
        if((this->_store != nullptr)) 
        {
            return false;
        }
        if((this->_providerName != nullptr)) 
        {
            return false;
        }
        if((this->_type != 0)) 
        {
            return false;
        }
        return true;
    }
    
    KeyContainerPermissionFlags KeyContainerPermissionAttribute::get_Flags() {
        return this->_flags;
    }
    
    KeyContainerPermissionFlags KeyContainerPermissionAttribute::set_Flags(KeyContainerPermissionFlags value) {
        this->_flags = value;
        return get_Flags();
    }
    
    System::String* KeyContainerPermissionAttribute::get_KeyContainerName() {
        return this->_containerName;
    }
    
    System::String* KeyContainerPermissionAttribute::set_KeyContainerName(System::String* value) {
        this->_containerName = value;
        return get_KeyContainerName();
    }
    
    int32_t KeyContainerPermissionAttribute::get_KeySpec() {
        return this->_spec;
    }
    
    int32_t KeyContainerPermissionAttribute::set_KeySpec(int32_t value) {
        this->_spec = value;
        return get_KeySpec();
    }
    
    System::String* KeyContainerPermissionAttribute::get_KeyStore() {
        return this->_store;
    }
    
    System::String* KeyContainerPermissionAttribute::set_KeyStore(System::String* value) {
        this->_store = value;
        return get_KeyStore();
    }
    
    System::String* KeyContainerPermissionAttribute::get_ProviderName() {
        return this->_providerName;
    }
    
    System::String* KeyContainerPermissionAttribute::set_ProviderName(System::String* value) {
        this->_providerName = value;
        return get_ProviderName();
    }
    
    int32_t KeyContainerPermissionAttribute::get_ProviderType() {
        return this->_type;
    }
    
    int32_t KeyContainerPermissionAttribute::set_ProviderType(int32_t value) {
        this->_type = value;
        return get_ProviderType();
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    
    
    void PermissionSetAttribute::constructor(SecurityAction action) {
    }
    
    System::Security::IPermission* PermissionSetAttribute::CreatePermission_cae8413caba48c05() {
        return nullptr;
    }
    
    System::Security::PermissionSet* PermissionSetAttribute::CreateFromXml(System::String* xml) {
        Mono::Xml::SecurityParser *sp = cli::gcnew<Mono::Xml::SecurityParser>();
        try {
            sp->LoadXml(xml);
        }
        catch(Mono::Xml::SmallXmlParserException* xe) {
            throw cli::gcnew<System::Security::XmlSyntaxException>(xe->get_Line(), xe->ToString_1636a0751cb9ac11());
        }
        System::Security::SecurityElement *se = sp->ToXml();
        System::String *className = se->Attribute2(_T("class"));
        if((className ==  nullptr)) 
        {
            return nullptr;
        }
        PermissionState state = PermissionState::None;
        if(System::Security::CodeAccessPermission::IsUnrestricted(se)) 
        {
            state = PermissionState::Unrestricted;
        }
        if(className->EndsWith(_T("NamedPermissionSet"))) 
        {
            System::Security::NamedPermissionSet *nps = cli::gcnew<System::Security::NamedPermissionSet>(se->Attribute2(_T("Name")), state);
            nps->FromXml_2ac858dba9ca352b(se);
            return cli::cast<System::Security::PermissionSet*>(nps);
        }
         else 
        {
            if(className->EndsWith(_T("PermissionSet"))) 
            {
                System::Security::PermissionSet *ps = cli::gcnew<System::Security::PermissionSet>(state);
                ps->FromXml_2ac858dba9ca352b(se);
                return ps;
            }
        }
        return nullptr;
    }
    
    System::Security::PermissionSet* PermissionSetAttribute::CreatePermissionSet() {
        System::Security::PermissionSet *pset = nullptr;
        if(this->get_Unrestricted()) 
        {
            pset = cli::gcnew<System::Security::PermissionSet>(PermissionState::Unrestricted);
        }
         else 
        {
            pset = cli::gcnew<System::Security::PermissionSet>(PermissionState::None);
            if((this->name != nullptr)) 
            {
                return System::Security::Policy::PolicyLevel::CreateAppDomainLevel()->GetNamedPermissionSet(this->name);
            }
             else 
            {
                if((this->file != nullptr)) 
                {
                    System::Text::Encoding *e = this->isUnicodeEncoded ? System::Text::Encoding::get_Unicode() : System::Text::Encoding::get_ASCII();
                    {
                        /* USING - BLOCK */
                        auto sr = cli::gcnew<System::IO::StreamReader>(this->file, e);
                        cli::using_guard{sr};
                        pset = CreateFromXml(sr->ReadToEnd_f683943dd5002e1e());
                    }
                }
                 else 
                {
                    if((this->xml != nullptr)) 
                    {
                        pset = CreateFromXml(this->xml);
                    }
                     else 
                    {
                        if((this->hex != nullptr)) 
                        {
                            System::Text::Encoding *e = System::Text::Encoding::get_ASCII();
                            cli::array<unsigned char> *bin = Mono::Security::Cryptography::CryptoConvert::FromHex(this->hex);
                            pset = CreateFromXml(e->GetString_39f4843197ddbe92(bin, 0, bin->get_Length()));
                        }
                    }
                }
            }
        }
        return pset;
    }
    
    System::String* PermissionSetAttribute::get_File() {
        return this->file;
    }
    
    System::String* PermissionSetAttribute::set_File(System::String* value) {
        this->file = value;
        return get_File();
    }
    
    System::String* PermissionSetAttribute::get_Hex() {
        return this->hex;
    }
    
    System::String* PermissionSetAttribute::set_Hex(System::String* value) {
        this->hex = value;
        return get_Hex();
    }
    
    System::String* PermissionSetAttribute::get_Name() {
        return this->name;
    }
    
    System::String* PermissionSetAttribute::set_Name(System::String* value) {
        this->name = value;
        return get_Name();
    }
    
    bool PermissionSetAttribute::get_UnicodeEncoded() {
        return this->isUnicodeEncoded;
    }
    
    bool PermissionSetAttribute::set_UnicodeEncoded(bool value) {
        this->isUnicodeEncoded = value;
        return get_UnicodeEncoded();
    }
    
    System::String* PermissionSetAttribute::get_XML() {
        return this->xml;
    }
    
    System::String* PermissionSetAttribute::set_XML(System::String* value) {
        this->xml = value;
        return get_XML();
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    
    
    void PrincipalInfo::constructor(System::String* name, System::String* role, bool isAuthenticated) {
        this->_name = name;
        this->_role = role;
        this->_isAuthenticated = isAuthenticated;
    }
    
    System::String* PrincipalInfo::get_Name() {
        return this->_name;
    }
    
    System::String* PrincipalInfo::get_Role() {
        return this->_role;
    }
    
    bool PrincipalInfo::get_IsAuthenticated() {
        return this->_isAuthenticated;
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    
    
    void PrincipalPermission::constructor(PermissionState state) {
        this->principals = cli::gcnew<System::Collections::ArrayList>();
        if(((int32_t)(System::Security::CodeAccessPermission::CheckPermissionState(state, true)) ==  1)) 
        {
            PrincipalInfo *pi = cli::gcnew<PrincipalInfo>(nullptr, nullptr, true);
            this->principals->Add_e6a92085999ce388(pi);
        }
    }
    
    void PrincipalPermission::constructor(System::String* name, System::String* role) {
    }
    
    void PrincipalPermission::constructor(System::String* name, System::String* role, bool isAuthenticated) {
        this->principals = cli::gcnew<System::Collections::ArrayList>();
        PrincipalInfo *pi = cli::gcnew<PrincipalInfo>(name, role, isAuthenticated);
        this->principals->Add_e6a92085999ce388(pi);
    }
    
    void PrincipalPermission::constructor(System::Collections::ArrayList* principals) {
        this->principals = cli::cast<System::Collections::ArrayList*>(principals->Clone_5d610374e21ea7b0());
    }
    
    System::Security::IPermission* PrincipalPermission::Copy() {
        return cli::gcnew<PrincipalPermission>(this->principals);
    }
    
    void PrincipalPermission::Demand() {
        System::Security::Principal::IPrincipal *p = System::Threading::Thread::get_CurrentPrincipal();
        if((p ==  nullptr)) 
        {
            throw cli::gcnew<System::Security::SecurityException>(_T("no Principal"));
        }
        if((this->principals->get_Count_2354963792616712() > 0)) 
        {
            bool demand = false;
            for(auto tmp_546 : this->principals) {
                auto pi = cli::cast<PrincipalInfo*>(tmp_546);
                {
                    if(((((pi->get_Name() ==  nullptr) || System::String::op_Equality(pi->get_Name(), p->get_Identity_8451efd6a7a604b6()->get_Name_b724867acffa5fcd())) && ((pi->get_Role() ==  nullptr) || p->IsInRole_3999c98ebfe5d242(pi->get_Role()))) && ((pi->get_IsAuthenticated() && p->get_Identity_8451efd6a7a604b6()->get_IsAuthenticated_3494858dba7d3668()) || !(pi->get_IsAuthenticated())))) 
                    {
                        demand = true;
                        break;
                    }
                }
            }
            if(!(demand)) 
            {
                throw cli::gcnew<System::Security::SecurityException>(_T("Demand for principal refused."));
            }
        }
    }
    
    void PrincipalPermission::FromXml(System::Security::SecurityElement* elem) {
        CheckSecurityElement(elem, _T("elem"), 1, 1);
        this->principals->Clear_cd6654e5a40f5056();
        if((elem->get_Children() != nullptr)) 
        {
            for(auto tmp_547 : elem->get_Children()) {
                auto se = cli::cast<System::Security::SecurityElement*>(tmp_547);
                {
                    if(System::String::op_Inequality(se->get_Tag(), _T("Identity"))) 
                    {
                        throw cli::gcnew<System::ArgumentException>(_T("not IPermission/Identity"));
                    }
                    System::String *name = se->Attribute2(_T("ID"));
                    System::String *role = se->Attribute2(_T("Role"));
                    System::String *auth = se->Attribute2(_T("Authenticated"));
                    bool isAuthenticated = false;
                    if((auth != nullptr)) 
                    {
                        try {
                            isAuthenticated = System::Boolean::Parse(auth);
                        }
                        catch(...) {
                        }
                    }
                    PrincipalInfo *pi = cli::gcnew<PrincipalInfo>(name, role, isAuthenticated);
                    this->principals->Add_e6a92085999ce388(pi);
                }
            }
        }
    }
    
    System::Security::IPermission* PrincipalPermission::Intersect(System::Security::IPermission* target) {
        PrincipalPermission *pp = Cast(target);
        if((pp ==  nullptr)) 
        {
            return nullptr;
        }
        if(IsUnrestricted()) 
        {
            return pp->Copy();
        }
        if(pp->IsUnrestricted()) 
        {
            return Copy();
        }
        PrincipalPermission *intersect = cli::gcnew<PrincipalPermission>(PermissionState::None);
        for(auto tmp_548 : this->principals) {
            auto pi = cli::cast<PrincipalInfo*>(tmp_548);
            {
                for(auto tmp_549 : pp->principals) {
                    auto opi = cli::cast<PrincipalInfo*>(tmp_549);
                    {
                        if((pi->get_IsAuthenticated() ==  opi->get_IsAuthenticated())) 
                        {
                            System::String *name = nullptr;
                            if((System::String::op_Equality(pi->get_Name(), opi->get_Name()) || (opi->get_Name() ==  nullptr))) 
                            {
                                name = pi->get_Name();
                            }
                             else 
                            {
                                if((pi->get_Name() ==  nullptr)) 
                                {
                                    name = opi->get_Name();
                                }
                            }
                            System::String *role = nullptr;
                            if((System::String::op_Equality(pi->get_Role(), opi->get_Role()) || (opi->get_Role() ==  nullptr))) 
                            {
                                role = pi->get_Role();
                            }
                             else 
                            {
                                if((pi->get_Role() ==  nullptr)) 
                                {
                                    role = opi->get_Role();
                                }
                            }
                            if(((name != nullptr) || (role != nullptr))) 
                            {
                                PrincipalInfo *ipi = cli::gcnew<PrincipalInfo>(name, role, pi->get_IsAuthenticated());
                                intersect->principals->Add_e6a92085999ce388(ipi);
                            }
                        }
                    }
                }
            }
        }
        return (intersect->principals->get_Count_2354963792616712() > 0) ? intersect : nullptr;
    }
    
    bool PrincipalPermission::IsSubsetOf(System::Security::IPermission* target) {
        PrincipalPermission *pp = Cast(target);
        if((pp ==  nullptr)) 
        {
            return IsEmpty();
        }
        if(IsUnrestricted()) 
        {
            return pp->IsUnrestricted();
        }
         else 
        {
            if(pp->IsUnrestricted()) 
            {
                return true;
            }
        }
        for(auto tmp_550 : this->principals) {
            auto pi = cli::cast<PrincipalInfo*>(tmp_550);
            {
                bool thisItem = false;
                for(auto tmp_551 : pp->principals) {
                    auto opi = cli::cast<PrincipalInfo*>(tmp_551);
                    {
                        if((((System::String::op_Equality(pi->get_Name(), opi->get_Name()) || (opi->get_Name() ==  nullptr)) && (System::String::op_Equality(pi->get_Role(), opi->get_Role()) || (opi->get_Role() ==  nullptr))) && (pi->get_IsAuthenticated() ==  opi->get_IsAuthenticated()))) 
                        {
                            thisItem = true;
                        }
                    }
                }
                if(!(thisItem)) 
                {
                    return false;
                }
            }
        }
        return true;
    }
    
    bool PrincipalPermission::IsUnrestricted() {
        for(auto tmp_552 : this->principals) {
            auto pi = cli::cast<PrincipalInfo*>(tmp_552);
            {
                if((((pi->get_Name() ==  nullptr) && (pi->get_Role() ==  nullptr)) && pi->get_IsAuthenticated())) 
                {
                    return true;
                }
            }
        }
        return false;
    }
    
    System::String* PrincipalPermission::ToString_1636a0751cb9ac11() {
        return ToXml()->ToString_1636a0751cb9ac11();
    }
    
    System::Security::SecurityElement* PrincipalPermission::ToXml() {
        System::Security::SecurityElement *se = cli::gcnew<System::Security::SecurityElement>(_T("Permission"));
        System::Type *type = this->GetType();
        se->AddAttribute(_T("class"), cli::concat(type->get_FullName_7e8fa72ba225e1a4(), _T(", ")));
        se->AddAttribute(_T("version"), cli::import(1)->ToString_1636a0751cb9ac11());
        for(auto tmp_553 : this->principals) {
            auto pi = cli::cast<PrincipalInfo*>(tmp_553);
            {
                System::Security::SecurityElement *sec = cli::gcnew<System::Security::SecurityElement>(_T("Identity"));
                if((pi->get_Name() != nullptr)) 
                {
                    sec->AddAttribute(_T("ID"), pi->get_Name());
                }
                if((pi->get_Role() != nullptr)) 
                {
                    sec->AddAttribute(_T("Role"), pi->get_Role());
                }
                if(pi->get_IsAuthenticated()) 
                {
                    sec->AddAttribute(_T("Authenticated"), _T("true"));
                }
                se->AddChild(sec);
            }
        }
        return se;
    }
    
    System::Security::IPermission* PrincipalPermission::Union(System::Security::IPermission* other) {
        PrincipalPermission *pp = Cast(other);
        if((pp ==  nullptr)) 
        {
            return Copy();
        }
        if((IsUnrestricted() || pp->IsUnrestricted())) 
        {
            return cli::gcnew<PrincipalPermission>(PermissionState::Unrestricted);
        }
        PrincipalPermission *union_ = cli::gcnew<PrincipalPermission>(this->principals);
        for(auto tmp_554 : pp->principals) {
            auto pi = cli::cast<PrincipalInfo*>(tmp_554);
            union_->principals->Add_e6a92085999ce388(pi);
        }
        return union_;
    }
    
    bool PrincipalPermission::Equals_ed975d2f4a7d193e(System::Object* obj) {
        if((obj ==  nullptr)) 
        {
            return false;
        }
        PrincipalPermission *pp = cli::as<PrincipalPermission*>(obj);
        if((pp ==  nullptr)) 
        {
            return false;
        }
        if((this->principals->get_Count_2354963792616712() != pp->principals->get_Count_2354963792616712())) 
        {
            return false;
        }
        for(auto tmp_555 : this->principals) {
            auto pi = cli::cast<PrincipalInfo*>(tmp_555);
            {
                bool thisItem = false;
                for(auto tmp_556 : pp->principals) {
                    auto opi = cli::cast<PrincipalInfo*>(tmp_556);
                    {
                        if((((System::String::op_Equality(pi->get_Name(), opi->get_Name()) || (opi->get_Name() ==  nullptr)) && (System::String::op_Equality(pi->get_Role(), opi->get_Role()) || (opi->get_Role() ==  nullptr))) && (pi->get_IsAuthenticated() ==  opi->get_IsAuthenticated()))) 
                        {
                            thisItem = true;
                            break;
                        }
                    }
                }
                if(!(thisItem)) 
                {
                    return false;
                }
            }
        }
        return true;
    }
    
    int32_t PrincipalPermission::GetHashCode_6648aef0f235ee6c() {
        return System::Object::GetHashCode_6648aef0f235ee6c();
    }
    
    int32_t PrincipalPermission::GetTokenIndex() {
        return 8;
    }
    
    PrincipalPermission* PrincipalPermission::Cast(System::Security::IPermission* target) {
        if((target ==  nullptr)) 
        {
            return nullptr;
        }
        PrincipalPermission *pp = cli::as<PrincipalPermission*>(target);
        if((pp ==  nullptr)) 
        {
            System::Security::CodeAccessPermission::ThrowInvalidPermission(target, cli::typeof<System::Type>::info);
        }
        return pp;
    }
    
    bool PrincipalPermission::IsEmpty() {
        return (this->principals->get_Count_2354963792616712() ==  0);
    }
    
    int32_t PrincipalPermission::CheckSecurityElement(System::Security::SecurityElement* se, System::String* parameterName, int32_t minimumVersion, int32_t maximumVersion) {
        if((se ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(parameterName);
        }
        if(System::String::op_Inequality(se->get_Tag(), _T("Permission"))) 
        {
            System::String *msg = System::String::Format2(Locale::GetText(_T("Invalid tag {0}")), se->get_Tag());
            throw cli::gcnew<System::ArgumentException>(msg, parameterName);
        }
        int32_t version = minimumVersion;
        System::String *v = se->Attribute2(_T("version"));
        if((v != nullptr)) 
        {
            try {
                version = System::Int32::Parse5(v);
            }
            catch(System::Exception* e) {
                System::String *msg = Locale::GetText(_T("Couldn\'t parse version from \'{0}\'."));
                msg = System::String::Format2(msg, v);
                throw cli::gcnew<System::ArgumentException>(msg, parameterName, e);
            }
        }
        if(((version < minimumVersion) || (version > maximumVersion))) 
        {
            System::String *msg = Locale::GetText(_T("Unknown version \'{0}\', expected versions between [\'{1}\',\'{2}\']."));
            msg = System::String::Format4(msg, cli::box(version), cli::box(minimumVersion), cli::box(maximumVersion));
            throw cli::gcnew<System::ArgumentException>(msg, parameterName);
        }
        return version;
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    
    
    void PrincipalPermissionAttribute::constructor(SecurityAction action) {
        this->authenticated = true;
    }
    
    System::Security::IPermission* PrincipalPermissionAttribute::CreatePermission_cae8413caba48c05() {
        PrincipalPermission *perm = nullptr;
        if(this->get_Unrestricted()) 
        {
            perm = cli::gcnew<PrincipalPermission>(PermissionState::Unrestricted);
        }
         else 
        {
            perm = cli::gcnew<PrincipalPermission>(this->name, this->role, this->authenticated);
        }
        return perm;
    }
    
    bool PrincipalPermissionAttribute::get_Authenticated() {
        return this->authenticated;
    }
    
    bool PrincipalPermissionAttribute::set_Authenticated(bool value) {
        this->authenticated = value;
        return get_Authenticated();
    }
    
    System::String* PrincipalPermissionAttribute::get_Name() {
        return this->name;
    }
    
    System::String* PrincipalPermissionAttribute::set_Name(System::String* value) {
        this->name = value;
        return get_Name();
    }
    
    System::String* PrincipalPermissionAttribute::get_Role() {
        return this->role;
    }
    
    System::String* PrincipalPermissionAttribute::set_Role(System::String* value) {
        this->role = value;
        return get_Role();
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    
    
    void PublisherIdentityPermission::constructor(PermissionState state) {
        System::Security::CodeAccessPermission::CheckPermissionState(state, false);
    }
    
    void PublisherIdentityPermission::constructor(System::Security::Cryptography::X509Certificates::X509Certificate2* certificate) {
        this->set_Certificate(certificate);
    }
    
    System::Security::IPermission* PublisherIdentityPermission::Copy_d1e925db301dc53f() {
        PublisherIdentityPermission *p = cli::gcnew<PublisherIdentityPermission>(PermissionState::None);
        if((this->x509 != nullptr)) 
        {
            p->set_Certificate(this->x509);
        }
        return p;
    }
    
    void PublisherIdentityPermission::FromXml_ec3b425a66b43072(System::Security::SecurityElement* esd) {
        System::Security::CodeAccessPermission::CheckSecurityElement(esd, _T("esd"), 1, 1);
        System::String *cert = cli::as<System::String*>(esd->get_Attributes()->get_Item_d75c6e706b965758(_T("X509v3Certificate")));
        if((cert != nullptr)) 
        {
            cli::array<unsigned char> *rawcert = Mono::Security::Cryptography::CryptoConvert::FromHex(cert);
            this->x509 = cli::gcnew<System::Security::Cryptography::X509Certificates::X509Certificate2>(rawcert);
        }
    }
    
    System::Security::IPermission* PublisherIdentityPermission::Intersect_7dbf5aef702b16af(System::Security::IPermission* target) {
        PublisherIdentityPermission *pip = Cast(target);
        if((pip ==  nullptr)) 
        {
            return nullptr;
        }
        if(((this->x509 != nullptr) && (pip->x509 != nullptr))) 
        {
            if(System::String::op_Equality(this->x509->GetRawCertDataString_9b5d755fdca2c386(), pip->x509->GetRawCertDataString_9b5d755fdca2c386())) 
            {
                return cli::gcnew<PublisherIdentityPermission>(pip->x509);
            }
        }
        return nullptr;
    }
    
    bool PublisherIdentityPermission::IsSubsetOf_76947f8575c4d81(System::Security::IPermission* target) {
        PublisherIdentityPermission *pip = Cast(target);
        if((pip ==  nullptr)) 
        {
            return false;
        }
        if((this->x509 ==  nullptr)) 
        {
            return true;
        }
        if((pip->x509 ==  nullptr)) 
        {
            return false;
        }
        return System::String::op_Equality(this->x509->GetRawCertDataString_9b5d755fdca2c386(), pip->x509->GetRawCertDataString_9b5d755fdca2c386());
    }
    
    System::Security::SecurityElement* PublisherIdentityPermission::ToXml_9ee4cd8af8e8f747() {
        System::Security::SecurityElement *se = System::Security::CodeAccessPermission::Element2(1);
        if((this->x509 != nullptr)) 
        {
            se->AddAttribute(_T("X509v3Certificate"), this->x509->GetRawCertDataString_9b5d755fdca2c386());
        }
        return se;
    }
    
    System::Security::IPermission* PublisherIdentityPermission::Union_b0ddcab6cb9c8441(System::Security::IPermission* target) {
        PublisherIdentityPermission *pip = Cast(target);
        if((pip ==  nullptr)) 
        {
            return Copy_e6fdf74d8dfaca72();
        }
        if(((this->x509 != nullptr) && (pip->x509 != nullptr))) 
        {
            if(System::String::op_Equality(this->x509->GetRawCertDataString_9b5d755fdca2c386(), pip->x509->GetRawCertDataString_9b5d755fdca2c386())) 
            {
                return cli::gcnew<PublisherIdentityPermission>(this->x509);
            }
        }
         else 
        {
            if(((this->x509 ==  nullptr) && (pip->x509 != nullptr))) 
            {
                return cli::gcnew<PublisherIdentityPermission>(pip->x509);
            }
             else 
            {
                if(((this->x509 != nullptr) && (pip->x509 ==  nullptr))) 
                {
                    return cli::gcnew<PublisherIdentityPermission>(this->x509);
                }
            }
        }
        return nullptr;
    }
    
    int32_t PublisherIdentityPermission::GetTokenIndex() {
        return 10;
    }
    
    PublisherIdentityPermission* PublisherIdentityPermission::Cast(System::Security::IPermission* target) {
        if((target ==  nullptr)) 
        {
            return nullptr;
        }
        PublisherIdentityPermission *pip = cli::as<PublisherIdentityPermission*>(target);
        if((pip ==  nullptr)) 
        {
            System::Security::CodeAccessPermission::ThrowInvalidPermission(target, cli::typeof<System::Type>::info);
        }
        return pip;
    }
    
    System::Security::Cryptography::X509Certificates::X509Certificate2* PublisherIdentityPermission::get_Certificate() {
        return this->x509;
    }
    
    System::Security::Cryptography::X509Certificates::X509Certificate2* PublisherIdentityPermission::set_Certificate(System::Security::Cryptography::X509Certificates::X509Certificate2* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("X509Certificate"));
        }
        this->x509 = value;
        return get_Certificate();
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    
    
    void PublisherIdentityPermissionAttribute::constructor(SecurityAction action) {
    }
    
    System::Security::IPermission* PublisherIdentityPermissionAttribute::CreatePermission_cae8413caba48c05() {
        if(this->get_Unrestricted()) 
        {
            return cli::gcnew<PublisherIdentityPermission>(PermissionState::Unrestricted);
        }
        System::Security::Cryptography::X509Certificates::X509Certificate2 *x509 = nullptr;
        if((this->x509data != nullptr)) 
        {
            cli::array<unsigned char> *rawcert = Mono::Security::Cryptography::CryptoConvert::FromHex(this->x509data);
            x509 = cli::gcnew<System::Security::Cryptography::X509Certificates::X509Certificate2>(rawcert);
            return cli::gcnew<PublisherIdentityPermission>(x509);
        }
        if((this->certFile != nullptr)) 
        {
            x509 = System::Security::Cryptography::X509Certificates::X509Certificate2::CreateFromCertFile(this->certFile);
            return cli::gcnew<PublisherIdentityPermission>(x509);
        }
        if((this->signedFile != nullptr)) 
        {
            x509 = System::Security::Cryptography::X509Certificates::X509Certificate2::CreateFromSignedFile(this->signedFile);
            return cli::gcnew<PublisherIdentityPermission>(x509);
        }
        return cli::gcnew<PublisherIdentityPermission>(PermissionState::None);
    }
    
    System::String* PublisherIdentityPermissionAttribute::get_CertFile() {
        return this->certFile;
    }
    
    System::String* PublisherIdentityPermissionAttribute::set_CertFile(System::String* value) {
        this->certFile = value;
        return get_CertFile();
    }
    
    System::String* PublisherIdentityPermissionAttribute::get_SignedFile() {
        return this->signedFile;
    }
    
    System::String* PublisherIdentityPermissionAttribute::set_SignedFile(System::String* value) {
        this->signedFile = value;
        return get_SignedFile();
    }
    
    System::String* PublisherIdentityPermissionAttribute::get_X509Certificate() {
        return this->x509data;
    }
    
    System::String* PublisherIdentityPermissionAttribute::set_X509Certificate(System::String* value) {
        this->x509data = value;
        return get_X509Certificate();
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    
    
    void ReflectionPermission::constructor(PermissionState state) {
        if(((int32_t)(System::Security::CodeAccessPermission::CheckPermissionState(state, true)) ==  1)) 
        {
            this->flags = ReflectionPermissionFlag::AllFlags;
        }
         else 
        {
            this->flags = ReflectionPermissionFlag::NoFlags;
        }
    }
    
    void ReflectionPermission::constructor(ReflectionPermissionFlag flag) {
        this->set_Flags(flag);
    }
    
    System::Security::IPermission* ReflectionPermission::Copy_d1e925db301dc53f() {
        return cli::gcnew<ReflectionPermission>(this->flags);
    }
    
    void ReflectionPermission::FromXml_ec3b425a66b43072(System::Security::SecurityElement* esd) {
        System::Security::CodeAccessPermission::CheckSecurityElement(esd, _T("esd"), 1, 1);
        if(System::Security::CodeAccessPermission::IsUnrestricted(esd)) 
        {
            this->flags = ReflectionPermissionFlag::AllFlags;
        }
         else 
        {
            this->flags = ReflectionPermissionFlag::NoFlags;
            System::String *xmlFlags = cli::as<System::String*>(esd->get_Attributes()->get_Item_d75c6e706b965758(_T("Flags")));
            if((xmlFlags->IndexOf7(_T("MemberAccess")) >= 0)) 
            {
                (this->flags = (ReflectionPermissionFlag)(((int32_t)(this->flags) | 2)));
            }
            if((xmlFlags->IndexOf7(_T("ReflectionEmit")) >= 0)) 
            {
                (this->flags = (ReflectionPermissionFlag)(((int32_t)(this->flags) | 4)));
            }
            if((xmlFlags->IndexOf7(_T("TypeInformation")) >= 0)) 
            {
                (this->flags = (ReflectionPermissionFlag)(((int32_t)(this->flags) | 1)));
            }
        }
    }
    
    System::Security::IPermission* ReflectionPermission::Intersect_7dbf5aef702b16af(System::Security::IPermission* target) {
        ReflectionPermission *rp = Cast(target);
        if((rp ==  nullptr)) 
        {
            return nullptr;
        }
        if(IsUnrestricted2()) 
        {
            if(((int32_t)(rp->get_Flags()) ==  0)) 
            {
                return nullptr;
            }
             else 
            {
                return rp->Copy_d1e925db301dc53f();
            }
        }
        if(rp->IsUnrestricted2()) 
        {
            if(((int32_t)(this->flags) ==  0)) 
            {
                return nullptr;
            }
             else 
            {
                return Copy_e6fdf74d8dfaca72();
            }
        }
        ReflectionPermission *p = cli::cast<ReflectionPermission*>(rp->Copy_d1e925db301dc53f());
        (p->set_Flags((ReflectionPermissionFlag)(((int32_t)(p->get_Flags()) & (int32_t)(this->flags)))));
        return ((int32_t)(p->get_Flags()) ==  0) ? nullptr : p;
    }
    
    bool ReflectionPermission::IsSubsetOf_76947f8575c4d81(System::Security::IPermission* target) {
        ReflectionPermission *rp = Cast(target);
        if((rp ==  nullptr)) 
        {
            return ((int32_t)(this->flags) ==  0);
        }
        if(IsUnrestricted2()) 
        {
            return rp->IsUnrestricted2();
        }
         else 
        {
            if(rp->IsUnrestricted2()) 
            {
                return true;
            }
        }
        return ((int32_t)(((int32_t)(this->flags) & (int32_t)(rp->get_Flags()))) ==  (int32_t)(this->flags));
    }
    
    bool ReflectionPermission::IsUnrestricted2() {
        return ((int32_t)(this->flags) ==  7);
    }
    
    System::Security::SecurityElement* ReflectionPermission::ToXml_9ee4cd8af8e8f747() {
        System::Security::SecurityElement *se = System::Security::CodeAccessPermission::Element2(1);
        if(IsUnrestricted2()) 
        {
            se->AddAttribute(_T("Unrestricted"), _T("true"));
        }
         else 
        {
            if(((int32_t)(this->flags) ==  0)) 
            {
                se->AddAttribute(_T("Flags"), _T("NoFlags"));
            }
             else 
            {
                if(((int32_t)(((int32_t)(this->flags) & 7)) ==  7)) 
                {
                    se->AddAttribute(_T("Flags"), _T("AllFlags"));
                }
                 else 
                {
                    System::String *xmlFlags = _T("");
                    if(((int32_t)(((int32_t)(this->flags) & 2)) ==  2)) 
                    {
                        xmlFlags = _T("MemberAccess");
                    }
                    if(((int32_t)(((int32_t)(this->flags) & 4)) ==  4)) 
                    {
                        if((xmlFlags->get_Length() > 0)) 
                        {
                            (xmlFlags = cli::concat(xmlFlags, _T(", ")));
                        }
                        (xmlFlags = cli::concat(xmlFlags, _T("ReflectionEmit")));
                    }
                    if(((int32_t)(((int32_t)(this->flags) & 1)) ==  1)) 
                    {
                        if((xmlFlags->get_Length() > 0)) 
                        {
                            (xmlFlags = cli::concat(xmlFlags, _T(", ")));
                        }
                        (xmlFlags = cli::concat(xmlFlags, _T("TypeInformation")));
                    }
                    se->AddAttribute(_T("Flags"), xmlFlags);
                }
            }
        }
        return se;
    }
    
    System::Security::IPermission* ReflectionPermission::Union_b0ddcab6cb9c8441(System::Security::IPermission* other) {
        ReflectionPermission *rp = Cast(other);
        if((other ==  nullptr)) 
        {
            return Copy_e6fdf74d8dfaca72();
        }
        if((IsUnrestricted2() || rp->IsUnrestricted2())) 
        {
            return cli::gcnew<ReflectionPermission>(PermissionState::Unrestricted);
        }
        ReflectionPermission *p = cli::cast<ReflectionPermission*>(rp->Copy_d1e925db301dc53f());
        (p->set_Flags((ReflectionPermissionFlag)(((int32_t)(p->get_Flags()) | (int32_t)(this->flags)))));
        return p;
    }
    
    int32_t ReflectionPermission::GetTokenIndex() {
        return 4;
    }
    
    ReflectionPermission* ReflectionPermission::Cast(System::Security::IPermission* target) {
        if((target ==  nullptr)) 
        {
            return nullptr;
        }
        ReflectionPermission *rp = cli::as<ReflectionPermission*>(target);
        if((rp ==  nullptr)) 
        {
            System::Security::CodeAccessPermission::ThrowInvalidPermission(target, cli::typeof<System::Type>::info);
        }
        return rp;
    }
    
    ReflectionPermissionFlag ReflectionPermission::get_Flags() {
        return this->flags;
    }
    
    ReflectionPermissionFlag ReflectionPermission::set_Flags(ReflectionPermissionFlag value) {
        const ReflectionPermissionFlag all_flags = (ReflectionPermissionFlag)15L;
        if(((int32_t)(((int32_t)(value) & 15)) != (int32_t)(value))) 
        {
            System::String *msg = System::String::Format2(Locale::GetText(_T("Invalid flags {0}")), cli::box(value));
            throw cli::gcnew<System::ArgumentException>(msg, _T("ReflectionPermissionFlag"));
        }
        this->flags = value;
        return get_Flags();
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    
    
    void ReflectionPermissionAttribute::constructor(SecurityAction action) {
    }
    
    System::Security::IPermission* ReflectionPermissionAttribute::CreatePermission_cae8413caba48c05() {
        ReflectionPermission *perm = nullptr;
        if(this->get_Unrestricted()) 
        {
            perm = cli::gcnew<ReflectionPermission>(PermissionState::Unrestricted);
        }
         else 
        {
            perm = cli::gcnew<ReflectionPermission>(this->flags);
        }
        return perm;
    }
    
    ReflectionPermissionFlag ReflectionPermissionAttribute::get_Flags() {
        return this->flags;
    }
    
    ReflectionPermissionFlag ReflectionPermissionAttribute::set_Flags(ReflectionPermissionFlag value) {
        this->flags = value;
        this->memberAccess = ((int32_t)(((int32_t)(this->flags) & 2)) ==  2);
        this->reflectionEmit = ((int32_t)(((int32_t)(this->flags) & 4)) ==  4);
        this->typeInfo = ((int32_t)(((int32_t)(this->flags) & 1)) ==  1);
        return get_Flags();
    }
    
    bool ReflectionPermissionAttribute::get_MemberAccess() {
        return this->memberAccess;
    }
    
    bool ReflectionPermissionAttribute::set_MemberAccess(bool value) {
        if(value) 
        {
            (this->flags = (ReflectionPermissionFlag)(((int32_t)(this->flags) | 2)));
        }
         else 
        {
            (this->flags = (ReflectionPermissionFlag)(((int32_t)(this->flags) - 2)));
        }
        this->memberAccess = value;
        return get_MemberAccess();
    }
    
    bool ReflectionPermissionAttribute::get_ReflectionEmit() {
        return this->reflectionEmit;
    }
    
    bool ReflectionPermissionAttribute::set_ReflectionEmit(bool value) {
        if(value) 
        {
            (this->flags = (ReflectionPermissionFlag)(((int32_t)(this->flags) | 4)));
        }
         else 
        {
            (this->flags = (ReflectionPermissionFlag)(((int32_t)(this->flags) - 4)));
        }
        this->reflectionEmit = value;
        return get_ReflectionEmit();
    }
    
    bool ReflectionPermissionAttribute::get_RestrictedMemberAccess() {
        return ((int32_t)(((int32_t)(this->flags) & 8)) ==  8);
    }
    
    bool ReflectionPermissionAttribute::set_RestrictedMemberAccess(bool value) {
        if(value) 
        {
            (this->flags = (ReflectionPermissionFlag)(((int32_t)(this->flags) | 8)));
        }
         else 
        {
            (this->flags = (ReflectionPermissionFlag)(((int32_t)(this->flags) - 8)));
        }
        return get_RestrictedMemberAccess();
    }
    
    bool ReflectionPermissionAttribute::get_TypeInformation() {
        return this->typeInfo;
    }
    
    bool ReflectionPermissionAttribute::set_TypeInformation(bool value) {
        if(value) 
        {
            (this->flags = (ReflectionPermissionFlag)(((int32_t)(this->flags) | 1)));
        }
         else 
        {
            (this->flags = (ReflectionPermissionFlag)(((int32_t)(this->flags) - 1)));
        }
        this->typeInfo = value;
        return get_TypeInformation();
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    
    
    void RegistryPermission::constructor(PermissionState state) {
        this->_state = System::Security::CodeAccessPermission::CheckPermissionState(state, true);
        this->createList = cli::gcnew<System::Collections::ArrayList>();
        this->readList = cli::gcnew<System::Collections::ArrayList>();
        this->writeList = cli::gcnew<System::Collections::ArrayList>();
    }
    
    void RegistryPermission::constructor(RegistryPermissionAccess access, System::String* pathList) {
        this->_state = PermissionState::None;
        this->createList = cli::gcnew<System::Collections::ArrayList>();
        this->readList = cli::gcnew<System::Collections::ArrayList>();
        this->writeList = cli::gcnew<System::Collections::ArrayList>();
        AddPathList(access, pathList);
    }
    
    void RegistryPermission::constructor(RegistryPermissionAccess access, System::Security::AccessControl::AccessControlActions control, System::String* pathList) {
        if(!(System::Enum::IsDefined(cli::typeof<System::Type>::info, cli::box(control)))) 
        {
            System::String *msg = System::String::Format2(Locale::GetText(_T("Invalid enum {0}")), cli::box(control));
            throw cli::gcnew<System::ArgumentException>(msg, _T("AccessControlActions"));
        }
        this->_state = PermissionState::None;
        AddPathList2(access, control, pathList);
    }
    
    void RegistryPermission::AddPathList(RegistryPermissionAccess access, System::String* pathList) {
        if((pathList ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("pathList"));
        }
        switch(access) {
            case RegistryPermissionAccess::AllAccess: case_1705: {
                AddWithUnionKey(this->createList, pathList);
                AddWithUnionKey(this->readList, pathList);
                AddWithUnionKey(this->writeList, pathList);
                break;
            }
            case RegistryPermissionAccess::NoAccess: case_1706: {
                break;
            }
            case RegistryPermissionAccess::Create: case_1707: {
                AddWithUnionKey(this->createList, pathList);
                break;
            }
            case RegistryPermissionAccess::Read: case_1708: {
                AddWithUnionKey(this->readList, pathList);
                break;
            }
            case RegistryPermissionAccess::Write: case_1709: {
                AddWithUnionKey(this->writeList, pathList);
                break;
            }
            default: case_1710: {
                ThrowInvalidFlag(access, false);
                break;
            }
        }
    }
    
    void RegistryPermission::AddPathList2(RegistryPermissionAccess access, System::Security::AccessControl::AccessControlActions control, System::String* pathList) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    System::String* RegistryPermission::GetPathList(RegistryPermissionAccess access) {
        switch(access) {
            case RegistryPermissionAccess::AllAccess: case RegistryPermissionAccess::NoAccess: case_1711: {
                ThrowInvalidFlag(access, true);
                break;
            }
            case RegistryPermissionAccess::Create: case_1712: {
                return GetPathList2(this->createList);
            }
            case RegistryPermissionAccess::Read: case_1713: {
                return GetPathList2(this->readList);
            }
            case RegistryPermissionAccess::Write: case_1714: {
                return GetPathList2(this->writeList);
            }
            default: case_1715: {
                ThrowInvalidFlag(access, false);
                break;
            }
        }
        return nullptr;
    }
    
    void RegistryPermission::SetPathList(RegistryPermissionAccess access, System::String* pathList) {
        if((pathList ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("pathList"));
        }
        cli::array<System::String*> *paths;
        switch(access) {
            case RegistryPermissionAccess::AllAccess: case_1716: {
                this->createList->Clear_cd6654e5a40f5056();
                this->readList->Clear_cd6654e5a40f5056();
                this->writeList->Clear_cd6654e5a40f5056();
                paths = pathList->Split((new cli::array<char16_t>({u';'})));
                for(auto tmp_557 : paths) {
                    auto path = cli::cast<System::String*>(tmp_557);
                    {
                        this->createList->Add_e6a92085999ce388(path);
                        this->readList->Add_e6a92085999ce388(path);
                        this->writeList->Add_e6a92085999ce388(path);
                    }
                }
                break;
            }
            case RegistryPermissionAccess::NoAccess: case_1717: {
                break;
            }
            case RegistryPermissionAccess::Create: case_1718: {
                this->createList->Clear_cd6654e5a40f5056();
                paths = pathList->Split((new cli::array<char16_t>({u';'})));
                for(auto tmp_558 : paths) {
                    auto path = cli::cast<System::String*>(tmp_558);
                    {
                        this->createList->Add_e6a92085999ce388(path);
                    }
                }
                break;
            }
            case RegistryPermissionAccess::Read: case_1719: {
                this->readList->Clear_cd6654e5a40f5056();
                paths = pathList->Split((new cli::array<char16_t>({u';'})));
                for(auto tmp_559 : paths) {
                    auto path = cli::cast<System::String*>(tmp_559);
                    {
                        this->readList->Add_e6a92085999ce388(path);
                    }
                }
                break;
            }
            case RegistryPermissionAccess::Write: case_1720: {
                this->writeList->Clear_cd6654e5a40f5056();
                paths = pathList->Split((new cli::array<char16_t>({u';'})));
                for(auto tmp_560 : paths) {
                    auto path = cli::cast<System::String*>(tmp_560);
                    {
                        this->writeList->Add_e6a92085999ce388(path);
                    }
                }
                break;
            }
            default: case_1721: {
                ThrowInvalidFlag(access, false);
                break;
            }
        }
    }
    
    System::Security::IPermission* RegistryPermission::Copy_d1e925db301dc53f() {
        RegistryPermission *rp = cli::gcnew<RegistryPermission>(this->_state);
        System::String *path = GetPathList(RegistryPermissionAccess::Create);
        if((path != nullptr)) 
        {
            rp->SetPathList(RegistryPermissionAccess::Create, path);
        }
        path = GetPathList(RegistryPermissionAccess::Read);
        if((path != nullptr)) 
        {
            rp->SetPathList(RegistryPermissionAccess::Read, path);
        }
        path = GetPathList(RegistryPermissionAccess::Write);
        if((path != nullptr)) 
        {
            rp->SetPathList(RegistryPermissionAccess::Write, path);
        }
        return rp;
    }
    
    void RegistryPermission::FromXml_ec3b425a66b43072(System::Security::SecurityElement* esd) {
        System::Security::CodeAccessPermission::CheckSecurityElement(esd, _T("esd"), 1, 1);
        System::Security::CodeAccessPermission::CheckSecurityElement(esd, _T("esd"), 1, 1);
        if(System::Security::CodeAccessPermission::IsUnrestricted(esd)) 
        {
            this->_state = PermissionState::Unrestricted;
        }
        System::String *create = esd->Attribute2(_T("Create"));
        if(((create != nullptr) && (create->get_Length() > 0))) 
        {
            SetPathList(RegistryPermissionAccess::Create, create);
        }
        System::String *read = esd->Attribute2(_T("Read"));
        if(((read != nullptr) && (read->get_Length() > 0))) 
        {
            SetPathList(RegistryPermissionAccess::Read, read);
        }
        System::String *write = esd->Attribute2(_T("Write"));
        if(((write != nullptr) && (write->get_Length() > 0))) 
        {
            SetPathList(RegistryPermissionAccess::Write, write);
        }
    }
    
    System::Security::IPermission* RegistryPermission::Intersect_7dbf5aef702b16af(System::Security::IPermission* target) {
        RegistryPermission *rp = Cast(target);
        if((rp ==  nullptr)) 
        {
            return nullptr;
        }
        if(IsUnrestricted2()) 
        {
            return rp->Copy_d1e925db301dc53f();
        }
        if(rp->IsUnrestricted2()) 
        {
            return Copy_e6fdf74d8dfaca72();
        }
        RegistryPermission *result = cli::gcnew<RegistryPermission>(PermissionState::None);
        IntersectKeys(this->createList, rp->createList, result->createList);
        IntersectKeys(this->readList, rp->readList, result->readList);
        IntersectKeys(this->writeList, rp->writeList, result->writeList);
        return result->IsEmpty() ? nullptr : result;
    }
    
    bool RegistryPermission::IsSubsetOf_76947f8575c4d81(System::Security::IPermission* target) {
        RegistryPermission *rp = Cast(target);
        if((rp ==  nullptr)) 
        {
            return false;
        }
        if(rp->IsEmpty()) 
        {
            return IsEmpty();
        }
        if(IsUnrestricted2()) 
        {
            return rp->IsUnrestricted2();
        }
         else 
        {
            if(rp->IsUnrestricted2()) 
            {
                return true;
            }
        }
        if(!(KeyIsSubsetOf(this->createList, rp->createList))) 
        {
            return false;
        }
        if(!(KeyIsSubsetOf(this->readList, rp->readList))) 
        {
            return false;
        }
        if(!(KeyIsSubsetOf(this->writeList, rp->writeList))) 
        {
            return false;
        }
        return true;
    }
    
    bool RegistryPermission::IsUnrestricted2() {
        return ((int32_t)(this->_state) ==  1);
    }
    
    System::Security::SecurityElement* RegistryPermission::ToXml_9ee4cd8af8e8f747() {
        System::Security::SecurityElement *se = System::Security::CodeAccessPermission::Element2(1);
        if(((int32_t)(this->_state) ==  1)) 
        {
            se->AddAttribute(_T("Unrestricted"), _T("true"));
        }
         else 
        {
            System::String *path = GetPathList(RegistryPermissionAccess::Create);
            if((path != nullptr)) 
            {
                se->AddAttribute(_T("Create"), path);
            }
            path = GetPathList(RegistryPermissionAccess::Read);
            if((path != nullptr)) 
            {
                se->AddAttribute(_T("Read"), path);
            }
            path = GetPathList(RegistryPermissionAccess::Write);
            if((path != nullptr)) 
            {
                se->AddAttribute(_T("Write"), path);
            }
        }
        return se;
    }
    
    System::Security::IPermission* RegistryPermission::Union_b0ddcab6cb9c8441(System::Security::IPermission* other) {
        RegistryPermission *rp = Cast(other);
        if((rp ==  nullptr)) 
        {
            return Copy_e6fdf74d8dfaca72();
        }
        if((IsUnrestricted2() || rp->IsUnrestricted2())) 
        {
            return cli::gcnew<RegistryPermission>(PermissionState::Unrestricted);
        }
        if((IsEmpty() && rp->IsEmpty())) 
        {
            return nullptr;
        }
        RegistryPermission *result = cli::cast<RegistryPermission*>(Copy_e6fdf74d8dfaca72());
        System::String *path = rp->GetPathList(RegistryPermissionAccess::Create);
        if((path != nullptr)) 
        {
            result->AddPathList(RegistryPermissionAccess::Create, path);
        }
        path = rp->GetPathList(RegistryPermissionAccess::Read);
        if((path != nullptr)) 
        {
            result->AddPathList(RegistryPermissionAccess::Read, path);
        }
        path = rp->GetPathList(RegistryPermissionAccess::Write);
        if((path != nullptr)) 
        {
            result->AddPathList(RegistryPermissionAccess::Write, path);
        }
        return result;
    }
    
    int32_t RegistryPermission::GetTokenIndex() {
        return 5;
    }
    
    bool RegistryPermission::IsEmpty() {
        return (((((int32_t)(this->_state) ==  0) && (this->createList->get_Count_2354963792616712() ==  0)) && (this->readList->get_Count_2354963792616712() ==  0)) && (this->writeList->get_Count_2354963792616712() ==  0));
    }
    
    RegistryPermission* RegistryPermission::Cast(System::Security::IPermission* target) {
        if((target ==  nullptr)) 
        {
            return nullptr;
        }
        RegistryPermission *rp = cli::as<RegistryPermission*>(target);
        if((rp ==  nullptr)) 
        {
            System::Security::CodeAccessPermission::ThrowInvalidPermission(target, cli::typeof<System::Type>::info);
        }
        return rp;
    }
    
    void RegistryPermission::ThrowInvalidFlag(RegistryPermissionAccess flag, bool context) {
        System::String *msg = nullptr;
        if(context) 
        {
            msg = Locale::GetText(_T("Unknown flag \'{0}\'."));
        }
         else 
        {
            msg = Locale::GetText(_T("Invalid flag \'{0}\' in this context."));
        }
        throw cli::gcnew<System::ArgumentException>(System::String::Format2(msg, cli::box(flag)), _T("flag"));
    }
    
    System::String* RegistryPermission::GetPathList2(System::Collections::ArrayList* list) {
        if(IsUnrestricted2()) 
        {
            return System::String::Empty;
        }
        if((list->get_Count_2354963792616712() ==  0)) 
        {
            return System::String::Empty;
        }
        System::Text::StringBuilder *sb = cli::gcnew<System::Text::StringBuilder>();
        for(auto tmp_561 : list) {
            auto path = cli::cast<System::String*>(tmp_561);
            {
                sb->Append2(path);
                sb->Append2(_T(";"));
            }
        }
        System::String *result = sb->ToString_1636a0751cb9ac11();
        int32_t n = result->get_Length();
        if((n > 0)) 
        {
            return result->Substring2(0, (n - 1));
        }
        return System::String::Empty;
    }
    
    bool RegistryPermission::KeyIsSubsetOf(System::Collections::IList* local, System::Collections::IList* target) {
        bool result = false;
        for(auto tmp_562 : local) {
            auto l = cli::cast<System::String*>(tmp_562);
            {
                for(auto tmp_563 : target) {
                    auto t = cli::cast<System::String*>(tmp_563);
                    {
                        if(l->StartsWith(t)) 
                        {
                            result = true;
                            break;
                        }
                    }
                }
                if(!(result)) 
                {
                    return false;
                }
            }
        }
        return true;
    }
    
    void RegistryPermission::AddWithUnionKey(System::Collections::IList* list, System::String* pathList) {
        cli::array<System::String*> *paths = pathList->Split((new cli::array<char16_t>({u';'})));
        for(auto tmp_564 : paths) {
            auto path = cli::cast<System::String*>(tmp_564);
            {
                int32_t len = list->get_Count_8f254f3dd8e2403();
                if((len ==  0)) 
                {
                    list->Add_985508e3bf9b7a73(path);
                }
                 else 
                {
                    for(int32_t i = 0; (i < len); i++){
                        System::String *s = cli::cast<System::String*>(list->get_Item_8550d21996ef9dc5(i));
                        if(s->StartsWith(path)) 
                        {
                            list->set_Item_d57705373e0668e7(i, path);
                        }
                         else 
                        {
                            if(path->StartsWith(s)) 
                            {
                            }
                             else 
                            {
                                list->Add_985508e3bf9b7a73(path);
                            }
                        }
                    }
                }
            }
        }
    }
    
    void RegistryPermission::IntersectKeys(System::Collections::IList* local, System::Collections::IList* target, System::Collections::IList* result) {
        for(auto tmp_565 : local) {
            auto l = cli::cast<System::String*>(tmp_565);
            {
                for(auto tmp_566 : target) {
                    auto t = cli::cast<System::String*>(tmp_566);
                    {
                        if((t->get_Length() > l->get_Length())) 
                        {
                            if(t->StartsWith(l)) 
                            {
                                result->Add_985508e3bf9b7a73(t);
                            }
                        }
                         else 
                        {
                            if(l->StartsWith(t)) 
                            {
                                result->Add_985508e3bf9b7a73(l);
                            }
                        }
                    }
                }
            }
        }
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    
    
    void RegistryPermissionAttribute::constructor(SecurityAction action) {
    }
    
    System::Security::IPermission* RegistryPermissionAttribute::CreatePermission_cae8413caba48c05() {
        RegistryPermission *perm = nullptr;
        if(this->get_Unrestricted()) 
        {
            perm = cli::gcnew<RegistryPermission>(PermissionState::Unrestricted);
        }
         else 
        {
            perm = cli::gcnew<RegistryPermission>(PermissionState::None);
            if((this->create != nullptr)) 
            {
                perm->AddPathList(RegistryPermissionAccess::Create, this->create);
            }
            if((this->read != nullptr)) 
            {
                perm->AddPathList(RegistryPermissionAccess::Read, this->read);
            }
            if((this->write != nullptr)) 
            {
                perm->AddPathList(RegistryPermissionAccess::Write, this->write);
            }
        }
        return perm;
    }
    
    System::String* RegistryPermissionAttribute::get_All() {
        throw cli::gcnew<System::NotSupportedException>(_T("All"));
    }
    
    System::String* RegistryPermissionAttribute::set_All(System::String* value) {
        this->create = value;
        this->read = value;
        this->write = value;
        return get_All();
    }
    
    System::String* RegistryPermissionAttribute::get_Create() {
        return this->create;
    }
    
    System::String* RegistryPermissionAttribute::set_Create(System::String* value) {
        this->create = value;
        return get_Create();
    }
    
    System::String* RegistryPermissionAttribute::get_Read() {
        return this->read;
    }
    
    System::String* RegistryPermissionAttribute::set_Read(System::String* value) {
        this->read = value;
        return get_Read();
    }
    
    System::String* RegistryPermissionAttribute::get_Write() {
        return this->write;
    }
    
    System::String* RegistryPermissionAttribute::set_Write(System::String* value) {
        this->write = value;
        return get_Write();
    }
    
    System::String* RegistryPermissionAttribute::get_ChangeAccessControl() {
        return this->changeAccessControl;
    }
    
    System::String* RegistryPermissionAttribute::set_ChangeAccessControl(System::String* value) {
        this->changeAccessControl = value;
        return get_ChangeAccessControl();
    }
    
    System::String* RegistryPermissionAttribute::get_ViewAccessControl() {
        return this->viewAccessControl;
    }
    
    System::String* RegistryPermissionAttribute::set_ViewAccessControl(System::String* value) {
        this->viewAccessControl = value;
        return get_ViewAccessControl();
    }
    
    System::String* RegistryPermissionAttribute::get_ViewAndModify() {
        throw cli::gcnew<System::NotSupportedException>();
    }
    
    System::String* RegistryPermissionAttribute::set_ViewAndModify(System::String* value) {
        this->create = value;
        this->read = value;
        this->write = value;
        return get_ViewAndModify();
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    
    
    void SecurityAttribute2::constructor(SecurityAction action) {
        this->set_Action(action);
    }
    
    bool SecurityAttribute2::get_Unrestricted() {
        return this->m_Unrestricted;
    }
    
    bool SecurityAttribute2::set_Unrestricted(bool value) {
        this->m_Unrestricted = value;
        return get_Unrestricted();
    }
    
    SecurityAction SecurityAttribute2::get_Action() {
        return this->m_Action;
    }
    
    SecurityAction SecurityAttribute2::set_Action(SecurityAction value) {
        this->m_Action = value;
        return get_Action();
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    
    
    void SecurityPermission::constructor(PermissionState state) {
        if(((int32_t)(System::Security::CodeAccessPermission::CheckPermissionState(state, true)) ==  1)) 
        {
            this->flags = SecurityPermissionFlag::AllFlags;
        }
         else 
        {
            this->flags = SecurityPermissionFlag::NoFlags;
        }
    }
    
    void SecurityPermission::constructor(SecurityPermissionFlag flag) {
        this->set_Flags(flag);
    }
    
    bool SecurityPermission::IsUnrestricted2() {
        return ((int32_t)(this->flags) ==  16383);
    }
    
    System::Security::IPermission* SecurityPermission::Copy_d1e925db301dc53f() {
        return cli::gcnew<SecurityPermission>(this->flags);
    }
    
    System::Security::IPermission* SecurityPermission::Intersect_7dbf5aef702b16af(System::Security::IPermission* target) {
        SecurityPermission *sp = Cast(target);
        if((sp ==  nullptr)) 
        {
            return nullptr;
        }
        if((IsEmpty() || sp->IsEmpty())) 
        {
            return nullptr;
        }
        if((this->IsUnrestricted2() && sp->IsUnrestricted2())) 
        {
            return cli::gcnew<SecurityPermission>(PermissionState::Unrestricted);
        }
        if(this->IsUnrestricted2()) 
        {
            return sp->Copy_d1e925db301dc53f();
        }
        if(sp->IsUnrestricted2()) 
        {
            return this->Copy_d1e925db301dc53f();
        }
        SecurityPermissionFlag f = (SecurityPermissionFlag)(((int32_t)(this->flags) & (int32_t)(sp->flags)));
        if(((int32_t)(f) ==  0)) 
        {
            return nullptr;
        }
         else 
        {
            return cli::gcnew<SecurityPermission>(f);
        }
    }
    
    System::Security::IPermission* SecurityPermission::Union_b0ddcab6cb9c8441(System::Security::IPermission* target) {
        SecurityPermission *sp = Cast(target);
        if((sp ==  nullptr)) 
        {
            return this->Copy_d1e925db301dc53f();
        }
        if((this->IsUnrestricted2() || sp->IsUnrestricted2())) 
        {
            return cli::gcnew<SecurityPermission>(PermissionState::Unrestricted);
        }
        return cli::gcnew<SecurityPermission>((SecurityPermissionFlag)(((int32_t)(this->flags) | (int32_t)(sp->flags))));
    }
    
    bool SecurityPermission::IsSubsetOf_76947f8575c4d81(System::Security::IPermission* target) {
        SecurityPermission *sp = Cast(target);
        if((sp ==  nullptr)) 
        {
            return IsEmpty();
        }
        if(sp->IsUnrestricted2()) 
        {
            return true;
        }
        if(this->IsUnrestricted2()) 
        {
            return false;
        }
        return ((int32_t)(((int32_t)(this->flags) & (int32_t)(~((int32_t)(sp->flags))))) ==  0);
    }
    
    void SecurityPermission::FromXml_ec3b425a66b43072(System::Security::SecurityElement* esd) {
        System::Security::CodeAccessPermission::CheckSecurityElement(esd, _T("esd"), 1, 1);
        if(System::Security::CodeAccessPermission::IsUnrestricted(esd)) 
        {
            this->flags = SecurityPermissionFlag::AllFlags;
        }
         else 
        {
            System::String *f = esd->Attribute2(_T("Flags"));
            if((f ==  nullptr)) 
            {
                this->flags = SecurityPermissionFlag::NoFlags;
            }
             else 
            {
                this->flags = cli::unbox<SecurityPermissionFlag>(System::Enum::Parse(cli::typeof<System::Type>::info, f));
            }
        }
    }
    
    System::Security::SecurityElement* SecurityPermission::ToXml_9ee4cd8af8e8f747() {
        System::Security::SecurityElement *e = System::Security::CodeAccessPermission::Element2(1);
        if(IsUnrestricted2()) 
        {
            e->AddAttribute(_T("Unrestricted"), _T("true"));
        }
         else 
        {
            e->AddAttribute(_T("Flags"), cli::import(this->flags)->ToString_1636a0751cb9ac11());
        }
        return e;
    }
    
    int32_t SecurityPermission::GetTokenIndex() {
        return 6;
    }
    
    bool SecurityPermission::IsEmpty() {
        return ((int32_t)(this->flags) ==  0);
    }
    
    SecurityPermission* SecurityPermission::Cast(System::Security::IPermission* target) {
        if((target ==  nullptr)) 
        {
            return nullptr;
        }
        SecurityPermission *sp = cli::as<SecurityPermission*>(target);
        if((sp ==  nullptr)) 
        {
            System::Security::CodeAccessPermission::ThrowInvalidPermission(target, cli::typeof<System::Type>::info);
        }
        return sp;
    }
    
    SecurityPermissionFlag SecurityPermission::get_Flags() {
        return this->flags;
    }
    
    SecurityPermissionFlag SecurityPermission::set_Flags(SecurityPermissionFlag value) {
        if(((int32_t)(((int32_t)(value) & 16383)) != (int32_t)(value))) 
        {
            System::String *msg = System::String::Format2(Locale::GetText(_T("Invalid flags {0}")), cli::box(value));
            throw cli::gcnew<System::ArgumentException>(msg, _T("SecurityPermissionFlag"));
        }
        this->flags = value;
        return get_Flags();
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    
    
    void SecurityPermissionAttribute::constructor(SecurityAction action) {
        this->m_Flags = SecurityPermissionFlag::NoFlags;
    }
    
    System::Security::IPermission* SecurityPermissionAttribute::CreatePermission_cae8413caba48c05() {
        SecurityPermission *perm = nullptr;
        if(this->get_Unrestricted()) 
        {
            perm = cli::gcnew<SecurityPermission>(PermissionState::Unrestricted);
        }
         else 
        {
            perm = cli::gcnew<SecurityPermission>(this->m_Flags);
        }
        return perm;
    }
    
    bool SecurityPermissionAttribute::get_Assertion() {
        return ((int32_t)(((int32_t)(this->m_Flags) & 1)) != 0);
    }
    
    bool SecurityPermissionAttribute::set_Assertion(bool value) {
        if(value) 
        {
            (this->m_Flags = (SecurityPermissionFlag)(((int32_t)(this->m_Flags) | 1)));
        }
         else 
        {
            (this->m_Flags = (SecurityPermissionFlag)(((int32_t)(this->m_Flags) & -2)));
        }
        return get_Assertion();
    }
    
    bool SecurityPermissionAttribute::get_BindingRedirects() {
        return ((int32_t)(((int32_t)(this->m_Flags) & 8192)) != 0);
    }
    
    bool SecurityPermissionAttribute::set_BindingRedirects(bool value) {
        if(value) 
        {
            (this->m_Flags = (SecurityPermissionFlag)(((int32_t)(this->m_Flags) | 8192)));
        }
         else 
        {
            (this->m_Flags = (SecurityPermissionFlag)(((int32_t)(this->m_Flags) & -8193)));
        }
        return get_BindingRedirects();
    }
    
    bool SecurityPermissionAttribute::get_ControlAppDomain() {
        return ((int32_t)(((int32_t)(this->m_Flags) & 1024)) != 0);
    }
    
    bool SecurityPermissionAttribute::set_ControlAppDomain(bool value) {
        if(value) 
        {
            (this->m_Flags = (SecurityPermissionFlag)(((int32_t)(this->m_Flags) | 1024)));
        }
         else 
        {
            (this->m_Flags = (SecurityPermissionFlag)(((int32_t)(this->m_Flags) & -1025)));
        }
        return get_ControlAppDomain();
    }
    
    bool SecurityPermissionAttribute::get_ControlDomainPolicy() {
        return ((int32_t)(((int32_t)(this->m_Flags) & 256)) != 0);
    }
    
    bool SecurityPermissionAttribute::set_ControlDomainPolicy(bool value) {
        if(value) 
        {
            (this->m_Flags = (SecurityPermissionFlag)(((int32_t)(this->m_Flags) | 256)));
        }
         else 
        {
            (this->m_Flags = (SecurityPermissionFlag)(((int32_t)(this->m_Flags) & -257)));
        }
        return get_ControlDomainPolicy();
    }
    
    bool SecurityPermissionAttribute::get_ControlEvidence() {
        return ((int32_t)(((int32_t)(this->m_Flags) & 32)) != 0);
    }
    
    bool SecurityPermissionAttribute::set_ControlEvidence(bool value) {
        if(value) 
        {
            (this->m_Flags = (SecurityPermissionFlag)(((int32_t)(this->m_Flags) | 32)));
        }
         else 
        {
            (this->m_Flags = (SecurityPermissionFlag)(((int32_t)(this->m_Flags) & -33)));
        }
        return get_ControlEvidence();
    }
    
    bool SecurityPermissionAttribute::get_ControlPolicy() {
        return ((int32_t)(((int32_t)(this->m_Flags) & 64)) != 0);
    }
    
    bool SecurityPermissionAttribute::set_ControlPolicy(bool value) {
        if(value) 
        {
            (this->m_Flags = (SecurityPermissionFlag)(((int32_t)(this->m_Flags) | 64)));
        }
         else 
        {
            (this->m_Flags = (SecurityPermissionFlag)(((int32_t)(this->m_Flags) & -65)));
        }
        return get_ControlPolicy();
    }
    
    bool SecurityPermissionAttribute::get_ControlPrincipal() {
        return ((int32_t)(((int32_t)(this->m_Flags) & 512)) != 0);
    }
    
    bool SecurityPermissionAttribute::set_ControlPrincipal(bool value) {
        if(value) 
        {
            (this->m_Flags = (SecurityPermissionFlag)(((int32_t)(this->m_Flags) | 512)));
        }
         else 
        {
            (this->m_Flags = (SecurityPermissionFlag)(((int32_t)(this->m_Flags) & -513)));
        }
        return get_ControlPrincipal();
    }
    
    bool SecurityPermissionAttribute::get_ControlThread() {
        return ((int32_t)(((int32_t)(this->m_Flags) & 16)) != 0);
    }
    
    bool SecurityPermissionAttribute::set_ControlThread(bool value) {
        if(value) 
        {
            (this->m_Flags = (SecurityPermissionFlag)(((int32_t)(this->m_Flags) | 16)));
        }
         else 
        {
            (this->m_Flags = (SecurityPermissionFlag)(((int32_t)(this->m_Flags) & -17)));
        }
        return get_ControlThread();
    }
    
    bool SecurityPermissionAttribute::get_Execution() {
        return ((int32_t)(((int32_t)(this->m_Flags) & 8)) != 0);
    }
    
    bool SecurityPermissionAttribute::set_Execution(bool value) {
        if(value) 
        {
            (this->m_Flags = (SecurityPermissionFlag)(((int32_t)(this->m_Flags) | 8)));
        }
         else 
        {
            (this->m_Flags = (SecurityPermissionFlag)(((int32_t)(this->m_Flags) & -9)));
        }
        return get_Execution();
    }
    
    bool SecurityPermissionAttribute::get_Infrastructure() {
        return ((int32_t)(((int32_t)(this->m_Flags) & 4096)) != 0);
    }
    
    bool SecurityPermissionAttribute::set_Infrastructure(bool value) {
        if(value) 
        {
            (this->m_Flags = (SecurityPermissionFlag)(((int32_t)(this->m_Flags) | 4096)));
        }
         else 
        {
            (this->m_Flags = (SecurityPermissionFlag)(((int32_t)(this->m_Flags) & -4097)));
        }
        return get_Infrastructure();
    }
    
    bool SecurityPermissionAttribute::get_RemotingConfiguration() {
        return ((int32_t)(((int32_t)(this->m_Flags) & 2048)) != 0);
    }
    
    bool SecurityPermissionAttribute::set_RemotingConfiguration(bool value) {
        if(value) 
        {
            (this->m_Flags = (SecurityPermissionFlag)(((int32_t)(this->m_Flags) | 2048)));
        }
         else 
        {
            (this->m_Flags = (SecurityPermissionFlag)(((int32_t)(this->m_Flags) & -2049)));
        }
        return get_RemotingConfiguration();
    }
    
    bool SecurityPermissionAttribute::get_SerializationFormatter() {
        return ((int32_t)(((int32_t)(this->m_Flags) & 128)) != 0);
    }
    
    bool SecurityPermissionAttribute::set_SerializationFormatter(bool value) {
        if(value) 
        {
            (this->m_Flags = (SecurityPermissionFlag)(((int32_t)(this->m_Flags) | 128)));
        }
         else 
        {
            (this->m_Flags = (SecurityPermissionFlag)(((int32_t)(this->m_Flags) & -129)));
        }
        return get_SerializationFormatter();
    }
    
    bool SecurityPermissionAttribute::get_SkipVerification() {
        return ((int32_t)(((int32_t)(this->m_Flags) & 4)) != 0);
    }
    
    bool SecurityPermissionAttribute::set_SkipVerification(bool value) {
        if(value) 
        {
            (this->m_Flags = (SecurityPermissionFlag)(((int32_t)(this->m_Flags) | 4)));
        }
         else 
        {
            (this->m_Flags = (SecurityPermissionFlag)(((int32_t)(this->m_Flags) & -5)));
        }
        return get_SkipVerification();
    }
    
    bool SecurityPermissionAttribute::get_UnmanagedCode() {
        return ((int32_t)(((int32_t)(this->m_Flags) & 2)) != 0);
    }
    
    bool SecurityPermissionAttribute::set_UnmanagedCode(bool value) {
        if(value) 
        {
            (this->m_Flags = (SecurityPermissionFlag)(((int32_t)(this->m_Flags) | 2)));
        }
         else 
        {
            (this->m_Flags = (SecurityPermissionFlag)(((int32_t)(this->m_Flags) & -3)));
        }
        return get_UnmanagedCode();
    }
    
    SecurityPermissionFlag SecurityPermissionAttribute::get_Flags() {
        return this->m_Flags;
    }
    
    SecurityPermissionFlag SecurityPermissionAttribute::set_Flags(SecurityPermissionFlag value) {
        this->m_Flags = value;
        return get_Flags();
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    
    cli::array<bool>*  SiteIdentityPermission::valid;
    
    SiteIdentityPermission::SiteIdentityPermission()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void SiteIdentityPermission::constructor(PermissionState state) {
        System::Security::CodeAccessPermission::CheckPermissionState(state, false);
    }
    
    void SiteIdentityPermission::constructor(System::String* site) {
        this->set_Site(site);
    }
    
    void SiteIdentityPermission::static_constructor() {
    }
    
    System::Security::IPermission* SiteIdentityPermission::Copy_d1e925db301dc53f() {
        if(IsEmpty()) 
        {
            return cli::gcnew<SiteIdentityPermission>(PermissionState::None);
        }
         else 
        {
            return cli::gcnew<SiteIdentityPermission>(this->_site);
        }
    }
    
    void SiteIdentityPermission::FromXml_ec3b425a66b43072(System::Security::SecurityElement* esd) {
        System::Security::CodeAccessPermission::CheckSecurityElement(esd, _T("esd"), 1, 1);
        System::String *s = esd->Attribute2(_T("Site"));
        if((s != nullptr)) 
        {
            this->set_Site(s);
        }
    }
    
    System::Security::IPermission* SiteIdentityPermission::Intersect_7dbf5aef702b16af(System::Security::IPermission* target) {
        SiteIdentityPermission *sip = Cast(target);
        if(((sip ==  nullptr) || IsEmpty())) 
        {
            return nullptr;
        }
        if(Match(sip->_site)) 
        {
            System::String *s = (this->_site->get_Length() > sip->_site->get_Length()) ? this->_site : sip->_site;
            return cli::gcnew<SiteIdentityPermission>(s);
        }
        return nullptr;
    }
    
    bool SiteIdentityPermission::IsSubsetOf_76947f8575c4d81(System::Security::IPermission* target) {
        SiteIdentityPermission *sip = Cast(target);
        if((sip ==  nullptr)) 
        {
            return IsEmpty();
        }
        if(((this->_site ==  nullptr) && (sip->_site ==  nullptr))) 
        {
            return true;
        }
        if(((this->_site ==  nullptr) || (sip->_site ==  nullptr))) 
        {
            return false;
        }
        int32_t wildcard = sip->_site->IndexOf4(u'*');
        if((wildcard ==  -1)) 
        {
            return System::String::op_Equality(this->_site, sip->_site);
        }
        return this->_site->EndsWith(sip->_site->Substring((wildcard + 1)));
    }
    
    System::Security::SecurityElement* SiteIdentityPermission::ToXml_9ee4cd8af8e8f747() {
        System::Security::SecurityElement *e = System::Security::CodeAccessPermission::Element2(1);
        if((this->_site != nullptr)) 
        {
            e->AddAttribute(_T("Site"), this->_site);
        }
        return e;
    }
    
    System::Security::IPermission* SiteIdentityPermission::Union_b0ddcab6cb9c8441(System::Security::IPermission* target) {
        SiteIdentityPermission *sip = Cast(target);
        if(((sip ==  nullptr) || sip->IsEmpty())) 
        {
            return Copy_e6fdf74d8dfaca72();
        }
        if(IsEmpty()) 
        {
            return sip->Copy_d1e925db301dc53f();
        }
        if(Match(sip->_site)) 
        {
            System::String *s = (this->_site->get_Length() < sip->_site->get_Length()) ? this->_site : sip->_site;
            return cli::gcnew<SiteIdentityPermission>(s);
        }
        throw cli::gcnew<System::ArgumentException>(Locale::GetText(_T("Cannot union two different sites.")), _T("target"));
    }
    
    int32_t SiteIdentityPermission::GetTokenIndex() {
        return 11;
    }
    
    bool SiteIdentityPermission::IsEmpty() {
        return (this->_site ==  nullptr);
    }
    
    SiteIdentityPermission* SiteIdentityPermission::Cast(System::Security::IPermission* target) {
        if((target ==  nullptr)) 
        {
            return nullptr;
        }
        SiteIdentityPermission *sip = cli::as<SiteIdentityPermission*>(target);
        if((sip ==  nullptr)) 
        {
            System::Security::CodeAccessPermission::ThrowInvalidPermission(target, cli::typeof<System::Type>::info);
        }
        return sip;
    }
    
    bool SiteIdentityPermission::IsValid(System::String* s) {
        if(((s ==  nullptr) || (s->get_Length() ==  0))) 
        {
            return false;
        }
        for(int32_t i = 0; (i < s->get_Length()); i++){
            uint16_t x = (uint16_t)(s->get_Chars(i));
            if((((int32_t)(x) < 33) || ((int32_t)(x) > 126))) 
            {
                return false;
            }
            if(((int32_t)(x) ==  42)) 
            {
                if(((s->get_Length() > 1) && (((int32_t)(s->get_Chars((i + 1))) != 46) || (i > 0)))) 
                {
                    return false;
                }
            }
            if(!(valid->at(((int32_t)(x) - 33)))) 
            {
                return false;
            }
        }
        if((s->get_Length() ==  1)) 
        {
            return ((int32_t)(s->get_Chars(0)) != 46);
        }
        return true;
    }
    
    bool SiteIdentityPermission::Match(System::String* target) {
        if(((this->_site ==  nullptr) || (target ==  nullptr))) 
        {
            return false;
        }
        int32_t wcs = this->_site->IndexOf4(u'*');
        int32_t wct = target->IndexOf4(u'*');
        if(((wcs ==  -1) && (wct ==  -1))) 
        {
            return System::String::op_Equality(this->_site, target);
        }
         else 
        {
            if((wcs ==  -1)) 
            {
                return this->_site->EndsWith(target->Substring((wct + 1)));
            }
             else 
            {
                if((wct ==  -1)) 
                {
                    return target->EndsWith(this->_site->Substring((wcs + 1)));
                }
                 else 
                {
                    System::String *s = this->_site->Substring((wcs + 1));
                    target = target->Substring((wct + 1));
                    if((s->get_Length() > target->get_Length())) 
                    {
                        return s->EndsWith(target);
                    }
                     else 
                    {
                        return target->EndsWith(s);
                    }
                }
            }
        }
    }
    
    System::String* SiteIdentityPermission::get_Site() {
        if(IsEmpty()) 
        {
            throw cli::gcnew<System::NullReferenceException>(_T("No site."));
        }
        return this->_site;
    }
    
    System::String* SiteIdentityPermission::set_Site(System::String* value) {
        if(!(IsValid(value))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Invalid site."));
        }
        this->_site = value;
        return get_Site();
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    
    
    void SiteIdentityPermissionAttribute::constructor(SecurityAction action) {
    }
    
    System::Security::IPermission* SiteIdentityPermissionAttribute::CreatePermission_cae8413caba48c05() {
        SiteIdentityPermission *perm = nullptr;
        if(this->get_Unrestricted()) 
        {
            perm = cli::gcnew<SiteIdentityPermission>(PermissionState::Unrestricted);
        }
         else 
        {
            if((this->site ==  nullptr)) 
            {
                perm = cli::gcnew<SiteIdentityPermission>(PermissionState::None);
            }
             else 
            {
                perm = cli::gcnew<SiteIdentityPermission>(this->site);
            }
        }
        return perm;
    }
    
    System::String* SiteIdentityPermissionAttribute::get_Site() {
        return this->site;
    }
    
    System::String* SiteIdentityPermissionAttribute::set_Site(System::String* value) {
        this->site = value;
        return get_Site();
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    
    System::Version*  StrongNameIdentityPermission::defaultVersion;
    
    StrongNameIdentityPermission::StrongNameIdentityPermission()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void StrongNameIdentityPermission::constructor(PermissionState state) {
        this->_state = System::Security::CodeAccessPermission::CheckPermissionState(state, true);
        this->_list = cli::gcnew<System::Collections::ArrayList>();
        this->_list->Add_e6a92085999ce388(cli::box(SNIP::CreateDefault()));
    }
    
    void StrongNameIdentityPermission::constructor(StrongNamePublicKeyBlob* blob, System::String* name, System::Version* version) {
        if((blob ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("blob"));
        }
        if(((name != nullptr) && (name->get_Length() ==  0))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("name"));
        }
        this->_state = PermissionState::None;
        this->_list = cli::gcnew<System::Collections::ArrayList>();
        this->_list->Add_e6a92085999ce388(cli::box(cli::ctor<SNIP>(blob, name, version)));
    }
    
    void StrongNameIdentityPermission::constructor(StrongNameIdentityPermission* snip) {
        this->_state = snip->_state;
        this->_list = cli::gcnew<System::Collections::ArrayList>(snip->_list->get_Count_2354963792616712());
        for(auto tmp_567 : snip->_list) {
            auto e = cli::cast<SNIP>(tmp_567);
            {
                this->_list->Add_e6a92085999ce388(cli::box(cli::ctor<SNIP>(e->PublicKey, e->Name2, e->AssemblyVersion)));
            }
        }
    }
    
    void StrongNameIdentityPermission::static_constructor() {
    }
    
    void StrongNameIdentityPermission::ResetToDefault() {
        this->_list->Clear_cd6654e5a40f5056();
        this->_list->Add_e6a92085999ce388(cli::box(SNIP::CreateDefault()));
    }
    
    System::Security::IPermission* StrongNameIdentityPermission::Copy_d1e925db301dc53f() {
        if(IsEmpty2()) 
        {
            return cli::gcnew<StrongNameIdentityPermission>(PermissionState::None);
        }
         else 
        {
            return cli::gcnew<StrongNameIdentityPermission>(this);
        }
    }
    
    void StrongNameIdentityPermission::FromXml_ec3b425a66b43072(System::Security::SecurityElement* e) {
        System::Security::CodeAccessPermission::CheckSecurityElement(e, _T("e"), 1, 1);
        this->_list->Clear_cd6654e5a40f5056();
        if(((e->get_Children() != nullptr) && (e->get_Children()->get_Count_2354963792616712() > 0))) 
        {
            for(auto tmp_568 : e->get_Children()) {
                auto se = cli::cast<System::Security::SecurityElement*>(tmp_568);
                {
                    this->_list->Add_e6a92085999ce388(cli::box(FromSecurityElement(se)));
                }
            }
        }
         else 
        {
            this->_list->Add_e6a92085999ce388(cli::box(FromSecurityElement(e)));
        }
    }
    
    SNIP StrongNameIdentityPermission::FromSecurityElement(System::Security::SecurityElement* se) {
        System::String *name = se->Attribute2(_T("Name"));
        StrongNamePublicKeyBlob *publickey = StrongNamePublicKeyBlob::FromString(se->Attribute2(_T("PublicKeyBlob")));
        System::String *v = se->Attribute2(_T("AssemblyVersion"));
        System::Version *assemblyVersion = (v ==  nullptr) ? nullptr : cli::gcnew<System::Version>(v);
        return cli::ctor<SNIP>(publickey, name, assemblyVersion);
    }
    
    System::Security::IPermission* StrongNameIdentityPermission::Intersect_7dbf5aef702b16af(System::Security::IPermission* target) {
        if((target ==  nullptr)) 
        {
            return nullptr;
        }
        StrongNameIdentityPermission *snip = cli::as<StrongNameIdentityPermission*>(target);
        if((snip ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentException>(Locale::GetText(_T("Wrong permission type.")));
        }
        if((IsEmpty2() || snip->IsEmpty2())) 
        {
            return nullptr;
        }
        if(!(Match(snip->get_Name()))) 
        {
            return nullptr;
        }
        System::String *n = (this->get_Name()->get_Length() < snip->get_Name()->get_Length()) ? this->get_Name() : snip->get_Name();
        if(!(this->get_Version()->Equals4(snip->get_Version()))) 
        {
            return nullptr;
        }
        if(!(this->get_PublicKey()->Equals_ed975d2f4a7d193e(snip->get_PublicKey()))) 
        {
            return nullptr;
        }
        return cli::gcnew<StrongNameIdentityPermission>(this->get_PublicKey(), n, this->get_Version());
    }
    
    bool StrongNameIdentityPermission::IsSubsetOf_76947f8575c4d81(System::Security::IPermission* target) {
        StrongNameIdentityPermission *snip = Cast(target);
        if((snip ==  nullptr)) 
        {
            return IsEmpty2();
        }
        if(IsEmpty2()) 
        {
            return true;
        }
        if(IsUnrestricted2()) 
        {
            return snip->IsUnrestricted2();
        }
         else 
        {
            if(snip->IsUnrestricted2()) 
            {
                return true;
            }
        }
        for(auto tmp_569 : this->_list) {
            auto e = cli::cast<SNIP>(tmp_569);
            {
                for(auto tmp_570 : snip->_list) {
                    auto t = cli::cast<SNIP>(tmp_570);
                    {
                        if(!(e->IsSubsetOf(t))) 
                        {
                            return false;
                        }
                    }
                }
            }
        }
        return true;
    }
    
    System::Security::SecurityElement* StrongNameIdentityPermission::ToXml_9ee4cd8af8e8f747() {
        System::Security::SecurityElement *se = System::Security::CodeAccessPermission::Element2(1);
        if((this->_list->get_Count_2354963792616712() > 1)) 
        {
            for(auto tmp_571 : this->_list) {
                auto snip = cli::cast<SNIP>(tmp_571);
                {
                    System::Security::SecurityElement *child = cli::gcnew<System::Security::SecurityElement>(_T("StrongName"));
                    ToSecurityElement(child, snip);
                    se->AddChild(child);
                }
            }
        }
         else 
        {
            if((this->_list->get_Count_2354963792616712() ==  1)) 
            {
                SNIP snip = cli::unbox<SNIP>(this->_list->get_Item_fd0155f142ae570(0));
                if(!(IsEmpty(snip))) 
                {
                    ToSecurityElement(se, snip);
                }
            }
        }
        return se;
    }
    
    void StrongNameIdentityPermission::ToSecurityElement(System::Security::SecurityElement* se, SNIP snip) {
        if((snip->PublicKey != nullptr)) 
        {
            se->AddAttribute(_T("PublicKeyBlob"), snip->PublicKey->ToString_1636a0751cb9ac11());
        }
        if((snip->Name2 != nullptr)) 
        {
            se->AddAttribute(_T("Name"), snip->Name2);
        }
        if(System::Version::op_Inequality(snip->AssemblyVersion, nullptr)) 
        {
            se->AddAttribute(_T("AssemblyVersion"), snip->AssemblyVersion->ToString_1636a0751cb9ac11());
        }
    }
    
    System::Security::IPermission* StrongNameIdentityPermission::Union_b0ddcab6cb9c8441(System::Security::IPermission* target) {
        StrongNameIdentityPermission *snip = Cast(target);
        if(((snip ==  nullptr) || snip->IsEmpty2())) 
        {
            return Copy_e6fdf74d8dfaca72();
        }
        if(IsEmpty2()) 
        {
            return snip->Copy_d1e925db301dc53f();
        }
        StrongNameIdentityPermission *union_ = cli::cast<StrongNameIdentityPermission*>(Copy_e6fdf74d8dfaca72());
        for(auto tmp_572 : snip->_list) {
            auto e = cli::cast<SNIP>(tmp_572);
            {
                if((!(IsEmpty(e)) && !(Contains(e)))) 
                {
                    union_->_list->Add_e6a92085999ce388(cli::box(e));
                }
            }
        }
        return union_;
    }
    
    int32_t StrongNameIdentityPermission::GetTokenIndex() {
        return 12;
    }
    
    bool StrongNameIdentityPermission::IsUnrestricted2() {
        return ((int32_t)(this->_state) ==  1);
    }
    
    bool StrongNameIdentityPermission::Contains(SNIP snip) {
        for(auto tmp_573 : this->_list) {
            auto e = cli::cast<SNIP>(tmp_573);
            {
                bool pk = (((e->PublicKey ==  nullptr) && (snip->PublicKey ==  nullptr)) || ((e->PublicKey != nullptr) && e->PublicKey->Equals_ed975d2f4a7d193e(snip->PublicKey)));
                bool name = e->IsNameSubsetOf(snip->Name2);
                bool version = ((System::Version::op_Equality(e->AssemblyVersion, nullptr) && System::Version::op_Equality(snip->AssemblyVersion, nullptr)) || (System::Version::op_Inequality(e->AssemblyVersion, nullptr) && e->AssemblyVersion->Equals4(snip->AssemblyVersion)));
                if(((pk && name) && version)) 
                {
                    return true;
                }
            }
        }
        return false;
    }
    
    bool StrongNameIdentityPermission::IsEmpty(SNIP snip) {
        if((this->get_PublicKey() != nullptr)) 
        {
            return false;
        }
        if(((this->get_Name() != nullptr) && (this->get_Name()->get_Length() > 0))) 
        {
            return false;
        }
        return (System::Version::op_Equality(this->get_Version(), nullptr) || defaultVersion->Equals4(this->get_Version()));
    }
    
    bool StrongNameIdentityPermission::IsEmpty2() {
        if((IsUnrestricted2() || (this->_list->get_Count_2354963792616712() > 1))) 
        {
            return false;
        }
        if((this->get_PublicKey() != nullptr)) 
        {
            return false;
        }
        if(((this->get_Name() != nullptr) && (this->get_Name()->get_Length() > 0))) 
        {
            return false;
        }
        return (System::Version::op_Equality(this->get_Version(), nullptr) || defaultVersion->Equals4(this->get_Version()));
    }
    
    StrongNameIdentityPermission* StrongNameIdentityPermission::Cast(System::Security::IPermission* target) {
        if((target ==  nullptr)) 
        {
            return nullptr;
        }
        StrongNameIdentityPermission *snip = cli::as<StrongNameIdentityPermission*>(target);
        if((snip ==  nullptr)) 
        {
            System::Security::CodeAccessPermission::ThrowInvalidPermission(target, cli::typeof<System::Type>::info);
        }
        return snip;
    }
    
    bool StrongNameIdentityPermission::Match(System::String* target) {
        if(((this->get_Name() ==  nullptr) || (target ==  nullptr))) 
        {
            return false;
        }
        int32_t wcu = this->get_Name()->LastIndexOf4(u'*');
        int32_t wct = target->LastIndexOf4(u'*');
        int32_t length = 2147483647;
        if(((wcu ==  -1) && (wct ==  -1))) 
        {
            length = System::Math::Max5(this->get_Name()->get_Length(), target->get_Length());
        }
         else 
        {
            if((wcu ==  -1)) 
            {
                length = wct;
            }
             else 
            {
                if((wct ==  -1)) 
                {
                    length = wcu;
                }
                 else 
                {
                    length = System::Math::Min5(wcu, wct);
                }
            }
        }
        return (System::String::Compare6(this->get_Name(), 0, target, 0, length, true, System::Globalization::CultureInfo::get_InvariantCulture()) ==  0);
    }
    
    System::String* StrongNameIdentityPermission::get_Name() {
        if((this->_list->get_Count_2354963792616712() > 1)) 
        {
            throw cli::gcnew<System::NotSupportedException>();
        }
        return cli::unbox<SNIP>(this->_list->get_Item_fd0155f142ae570(0))->Name2;
    }
    
    System::String* StrongNameIdentityPermission::set_Name(System::String* value) {
        if(((value != nullptr) && (value->get_Length() ==  0))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("name"));
        }
        if((this->_list->get_Count_2354963792616712() > 1)) 
        {
            ResetToDefault();
        }
        SNIP snip = cli::unbox<SNIP>(this->_list->get_Item_fd0155f142ae570(0));
        snip->Name2 = value;
        this->_list->set_Item_9f12782653a34813(0, cli::box(snip));
        return get_Name();
    }
    
    StrongNamePublicKeyBlob* StrongNameIdentityPermission::get_PublicKey() {
        if((this->_list->get_Count_2354963792616712() > 1)) 
        {
            throw cli::gcnew<System::NotSupportedException>();
        }
        return cli::unbox<SNIP>(this->_list->get_Item_fd0155f142ae570(0))->PublicKey;
    }
    
    StrongNamePublicKeyBlob* StrongNameIdentityPermission::set_PublicKey(StrongNamePublicKeyBlob* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("value"));
        }
        if((this->_list->get_Count_2354963792616712() > 1)) 
        {
            ResetToDefault();
        }
        SNIP snip = cli::unbox<SNIP>(this->_list->get_Item_fd0155f142ae570(0));
        snip->PublicKey = value;
        this->_list->set_Item_9f12782653a34813(0, cli::box(snip));
        return get_PublicKey();
    }
    
    System::Version* StrongNameIdentityPermission::get_Version() {
        if((this->_list->get_Count_2354963792616712() > 1)) 
        {
            throw cli::gcnew<System::NotSupportedException>();
        }
        return cli::unbox<SNIP>(this->_list->get_Item_fd0155f142ae570(0))->AssemblyVersion;
    }
    
    System::Version* StrongNameIdentityPermission::set_Version(System::Version* value) {
        if((this->_list->get_Count_2354963792616712() > 1)) 
        {
            ResetToDefault();
        }
        SNIP snip = cli::unbox<SNIP>(this->_list->get_Item_fd0155f142ae570(0));
        snip->AssemblyVersion = value;
        this->_list->set_Item_9f12782653a34813(0, cli::box(snip));
        return get_Version();
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    
    
    void StrongNameIdentityPermissionAttribute::constructor(SecurityAction action) {
    }
    
    System::Security::IPermission* StrongNameIdentityPermissionAttribute::CreatePermission_cae8413caba48c05() {
        if(this->get_Unrestricted()) 
        {
            return cli::gcnew<StrongNameIdentityPermission>(PermissionState::Unrestricted);
        }
        if((((this->name ==  nullptr) && (this->key ==  nullptr)) && (this->version ==  nullptr))) 
        {
            return cli::gcnew<StrongNameIdentityPermission>(PermissionState::None);
        }
        if((this->key ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentException>(Locale::GetText(_T("PublicKey is required")));
        }
        StrongNamePublicKeyBlob *blob = StrongNamePublicKeyBlob::FromString(this->key);
        System::Version *v = nullptr;
        if((this->version != nullptr)) 
        {
            v = cli::gcnew<System::Version>(this->version);
        }
        return cli::gcnew<StrongNameIdentityPermission>(blob, this->name, v);
    }
    
    System::String* StrongNameIdentityPermissionAttribute::get_Name() {
        return this->name;
    }
    
    System::String* StrongNameIdentityPermissionAttribute::set_Name(System::String* value) {
        this->name = value;
        return get_Name();
    }
    
    System::String* StrongNameIdentityPermissionAttribute::get_PublicKey() {
        return this->key;
    }
    
    System::String* StrongNameIdentityPermissionAttribute::set_PublicKey(System::String* value) {
        this->key = value;
        return get_PublicKey();
    }
    
    System::String* StrongNameIdentityPermissionAttribute::get_Version() {
        return this->version;
    }
    
    System::String* StrongNameIdentityPermissionAttribute::set_Version(System::String* value) {
        this->version = value;
        return get_Version();
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    
    
    void StrongNamePublicKeyBlob::constructor(cli::array<unsigned char>* publicKey) {
        if((publicKey ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("publicKey"));
        }
        this->pubkey = publicKey;
    }
    
    StrongNamePublicKeyBlob* StrongNamePublicKeyBlob::FromString(System::String* s) {
        if(((s ==  nullptr) || (s->get_Length() ==  0))) 
        {
            return nullptr;
        }
        int32_t length = (s->get_Length() / 2);
        cli::array<unsigned char> *array = (new cli::array<unsigned char>(length));
        for(int32_t i = 0, j = 0; (i < s->get_Length()); (i = i + 2), j++){
            unsigned char left = CharToByte(s->get_Chars(i));
            unsigned char right = CharToByte(s->get_Chars((i + 1)));
            array->at(j) = System::Convert::ToByte8((((int32_t)(left) * 16) + (int32_t)(right)));
        }
        return cli::gcnew<StrongNamePublicKeyBlob>(array);
    }
    
    unsigned char StrongNamePublicKeyBlob::CharToByte(char16_t c) {
        char16_t ch = System::Char::ToLowerInvariant(c);
        if(System::Char::IsDigit(ch)) 
        {
            return (unsigned char)((int32_t)(ch) - 48);
        }
         else 
        {
            return (unsigned char)(((int32_t)(ch) - 97) + 10);
        }
    }
    
    bool StrongNamePublicKeyBlob::Equals_ed975d2f4a7d193e(System::Object* obj) {
        StrongNamePublicKeyBlob *snpkb = cli::as<StrongNamePublicKeyBlob*>(obj);
        if((snpkb ==  nullptr)) 
        {
            return false;
        }
        bool result = (this->pubkey->get_Length() ==  snpkb->pubkey->get_Length());
        if(result) 
        {
            for(int32_t i = 0; (i < this->pubkey->get_Length()); i++){
                if(((int32_t)(this->pubkey->at(i)) != (int32_t)(snpkb->pubkey->at(i)))) 
                {
                    return false;
                }
            }
        }
        return result;
    }
    
    int32_t StrongNamePublicKeyBlob::GetHashCode_6648aef0f235ee6c() {
        int32_t hash = 0;
        int32_t i = 0;
        int32_t n = System::Math::Min5(this->pubkey->get_Length(), 4);
        while((i < n)) hash = ((hash << 8) + (int32_t)(this->pubkey->at(i++)));
        return hash;
    }
    
    System::String* StrongNamePublicKeyBlob::ToString_1636a0751cb9ac11() {
        System::Text::StringBuilder *sb = cli::gcnew<System::Text::StringBuilder>();
        for(int32_t i = 0; (i < this->pubkey->get_Length()); i++) {
            sb->Append2(cli::import(this->pubkey->at(i))->ToString3(_T("X2")));
        }
        return sb->ToString_1636a0751cb9ac11();
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    
    
    void UIPermission::constructor(PermissionState state) {
        if(((int32_t)(System::Security::CodeAccessPermission::CheckPermissionState(state, true)) ==  1)) 
        {
            this->_clipboard = UIPermissionClipboard::AllClipboard;
            this->_window = UIPermissionWindow::AllWindows;
        }
    }
    
    void UIPermission::constructor(UIPermissionClipboard clipboardFlag) {
        this->set_Clipboard(clipboardFlag);
    }
    
    void UIPermission::constructor(UIPermissionWindow windowFlag) {
        this->set_Window(windowFlag);
    }
    
    void UIPermission::constructor(UIPermissionWindow windowFlag, UIPermissionClipboard clipboardFlag) {
        this->set_Clipboard(clipboardFlag);
        this->set_Window(windowFlag);
    }
    
    System::Security::IPermission* UIPermission::Copy_d1e925db301dc53f() {
        return cli::gcnew<UIPermission>(this->_window, this->_clipboard);
    }
    
    void UIPermission::FromXml_ec3b425a66b43072(System::Security::SecurityElement* esd) {
        System::Security::CodeAccessPermission::CheckSecurityElement(esd, _T("esd"), 1, 1);
        if(System::Security::CodeAccessPermission::IsUnrestricted(esd)) 
        {
            this->_window = UIPermissionWindow::AllWindows;
            this->_clipboard = UIPermissionClipboard::AllClipboard;
        }
         else 
        {
            System::String *w = esd->Attribute2(_T("Window"));
            if((w ==  nullptr)) 
            {
                this->_window = UIPermissionWindow::NoWindows;
            }
             else 
            {
                this->_window = cli::unbox<UIPermissionWindow>(System::Enum::Parse(cli::typeof<System::Type>::info, w));
            }
            System::String *c = esd->Attribute2(_T("Clipboard"));
            if((c ==  nullptr)) 
            {
                this->_clipboard = UIPermissionClipboard::NoClipboard;
            }
             else 
            {
                this->_clipboard = cli::unbox<UIPermissionClipboard>(System::Enum::Parse(cli::typeof<System::Type>::info, c));
            }
        }
    }
    
    System::Security::IPermission* UIPermission::Intersect_7dbf5aef702b16af(System::Security::IPermission* target) {
        UIPermission *uip = Cast(target);
        if((uip ==  nullptr)) 
        {
            return nullptr;
        }
        UIPermissionWindow w = ((int32_t)(this->_window) < (int32_t)(uip->_window)) ? this->_window : uip->_window;
        UIPermissionClipboard c = ((int32_t)(this->_clipboard) < (int32_t)(uip->_clipboard)) ? this->_clipboard : uip->_clipboard;
        if(IsEmpty(w, c)) 
        {
            return nullptr;
        }
        return cli::gcnew<UIPermission>(w, c);
    }
    
    bool UIPermission::IsSubsetOf_76947f8575c4d81(System::Security::IPermission* target) {
        UIPermission *uip = Cast(target);
        if((uip ==  nullptr)) 
        {
            return IsEmpty(this->_window, this->_clipboard);
        }
        if(uip->IsUnrestricted2()) 
        {
            return true;
        }
        return (((int32_t)(this->_window) <= (int32_t)(uip->_window)) && ((int32_t)(this->_clipboard) <= (int32_t)(uip->_clipboard)));
    }
    
    bool UIPermission::IsUnrestricted2() {
        return (((int32_t)(this->_window) ==  3) && ((int32_t)(this->_clipboard) ==  2));
    }
    
    System::Security::SecurityElement* UIPermission::ToXml_9ee4cd8af8e8f747() {
        System::Security::SecurityElement *e = System::Security::CodeAccessPermission::Element2(1);
        if((((int32_t)(this->_window) ==  3) && ((int32_t)(this->_clipboard) ==  2))) 
        {
            e->AddAttribute(_T("Unrestricted"), _T("true"));
        }
         else 
        {
            if(((int32_t)(this->_window) != 0)) 
            {
                e->AddAttribute(_T("Window"), cli::import(this->_window)->ToString_1636a0751cb9ac11());
            }
            if(((int32_t)(this->_clipboard) != 0)) 
            {
                e->AddAttribute(_T("Clipboard"), cli::import(this->_clipboard)->ToString_1636a0751cb9ac11());
            }
        }
        return e;
    }
    
    System::Security::IPermission* UIPermission::Union_b0ddcab6cb9c8441(System::Security::IPermission* target) {
        UIPermission *uip = Cast(target);
        if((uip ==  nullptr)) 
        {
            return Copy_e6fdf74d8dfaca72();
        }
        UIPermissionWindow w = ((int32_t)(this->_window) > (int32_t)(uip->_window)) ? this->_window : uip->_window;
        UIPermissionClipboard c = ((int32_t)(this->_clipboard) > (int32_t)(uip->_clipboard)) ? this->_clipboard : uip->_clipboard;
        if(IsEmpty(w, c)) 
        {
            return nullptr;
        }
        return cli::gcnew<UIPermission>(w, c);
    }
    
    int32_t UIPermission::GetTokenIndex() {
        return 7;
    }
    
    bool UIPermission::IsEmpty(UIPermissionWindow w, UIPermissionClipboard c) {
        return (((int32_t)(w) ==  0) && ((int32_t)(c) ==  0));
    }
    
    UIPermission* UIPermission::Cast(System::Security::IPermission* target) {
        if((target ==  nullptr)) 
        {
            return nullptr;
        }
        UIPermission *uip = cli::as<UIPermission*>(target);
        if((uip ==  nullptr)) 
        {
            System::Security::CodeAccessPermission::ThrowInvalidPermission(target, cli::typeof<System::Type>::info);
        }
        return uip;
    }
    
    UIPermissionClipboard UIPermission::get_Clipboard() {
        return this->_clipboard;
    }
    
    UIPermissionClipboard UIPermission::set_Clipboard(UIPermissionClipboard value) {
        if(!(System::Enum::IsDefined(cli::typeof<System::Type>::info, cli::box(value)))) 
        {
            System::String *msg = System::String::Format2(Locale::GetText(_T("Invalid enum {0}")), cli::box(value));
            throw cli::gcnew<System::ArgumentException>(msg, _T("UIPermissionClipboard"));
        }
        this->_clipboard = value;
        return get_Clipboard();
    }
    
    UIPermissionWindow UIPermission::get_Window() {
        return this->_window;
    }
    
    UIPermissionWindow UIPermission::set_Window(UIPermissionWindow value) {
        if(!(System::Enum::IsDefined(cli::typeof<System::Type>::info, cli::box(value)))) 
        {
            System::String *msg = System::String::Format2(Locale::GetText(_T("Invalid enum {0}")), cli::box(value));
            throw cli::gcnew<System::ArgumentException>(msg, _T("UIPermissionWindow"));
        }
        this->_window = value;
        return get_Window();
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    
    
    void UIPermissionAttribute::constructor(SecurityAction action) {
    }
    
    System::Security::IPermission* UIPermissionAttribute::CreatePermission_cae8413caba48c05() {
        UIPermission *perm = nullptr;
        if(this->get_Unrestricted()) 
        {
            perm = cli::gcnew<UIPermission>(PermissionState::Unrestricted);
        }
         else 
        {
            perm = cli::gcnew<UIPermission>(this->window, this->clipboard);
        }
        return perm;
    }
    
    UIPermissionClipboard UIPermissionAttribute::get_Clipboard() {
        return this->clipboard;
    }
    
    UIPermissionClipboard UIPermissionAttribute::set_Clipboard(UIPermissionClipboard value) {
        this->clipboard = value;
        return get_Clipboard();
    }
    
    UIPermissionWindow UIPermissionAttribute::get_Window() {
        return this->window;
    }
    
    UIPermissionWindow UIPermissionAttribute::set_Window(UIPermissionWindow value) {
        this->window = value;
        return get_Window();
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    
    
    void UrlIdentityPermission::constructor(PermissionState state) {
        System::Security::CodeAccessPermission::CheckPermissionState(state, false);
        this->url = System::String::Empty;
    }
    
    void UrlIdentityPermission::constructor(System::String* site) {
        if((site ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("site"));
        }
        this->url = site;
    }
    
    System::Security::IPermission* UrlIdentityPermission::Copy_d1e925db301dc53f() {
        if((this->url ==  nullptr)) 
        {
            return cli::gcnew<UrlIdentityPermission>(PermissionState::None);
        }
         else 
        {
            return cli::gcnew<UrlIdentityPermission>(this->url);
        }
    }
    
    void UrlIdentityPermission::FromXml_ec3b425a66b43072(System::Security::SecurityElement* esd) {
        System::Security::CodeAccessPermission::CheckSecurityElement(esd, _T("esd"), 1, 1);
        System::String *u = esd->Attribute2(_T("Url"));
        if((u ==  nullptr)) 
        {
            this->url = System::String::Empty;
        }
         else 
        {
            this->set_Url(u);
        }
    }
    
    System::Security::IPermission* UrlIdentityPermission::Intersect_7dbf5aef702b16af(System::Security::IPermission* target) {
        UrlIdentityPermission *uip = Cast(target);
        if(((uip ==  nullptr) || IsEmpty())) 
        {
            return nullptr;
        }
        if(Match(uip->url)) 
        {
            if((this->url->get_Length() > uip->url->get_Length())) 
            {
                return Copy_e6fdf74d8dfaca72();
            }
             else 
            {
                return uip->Copy_d1e925db301dc53f();
            }
        }
        return nullptr;
    }
    
    bool UrlIdentityPermission::IsSubsetOf_76947f8575c4d81(System::Security::IPermission* target) {
        UrlIdentityPermission *uip = Cast(target);
        if((uip ==  nullptr)) 
        {
            return IsEmpty();
        }
        if(IsEmpty()) 
        {
            return true;
        }
        if((uip->url ==  nullptr)) 
        {
            return false;
        }
        int32_t wildcard = uip->url->LastIndexOf4(u'*');
        if((wildcard ==  -1)) 
        {
            wildcard = uip->url->get_Length();
        }
        return (System::String::Compare6(this->url, 0, uip->url, 0, wildcard, true, System::Globalization::CultureInfo::get_InvariantCulture()) ==  0);
    }
    
    System::Security::SecurityElement* UrlIdentityPermission::ToXml_9ee4cd8af8e8f747() {
        System::Security::SecurityElement *se = System::Security::CodeAccessPermission::Element2(1);
        if(!(IsEmpty())) 
        {
            se->AddAttribute(_T("Url"), this->url);
        }
        return se;
    }
    
    System::Security::IPermission* UrlIdentityPermission::Union_b0ddcab6cb9c8441(System::Security::IPermission* target) {
        UrlIdentityPermission *uip = Cast(target);
        if((uip ==  nullptr)) 
        {
            return Copy_e6fdf74d8dfaca72();
        }
        if((IsEmpty() && uip->IsEmpty())) 
        {
            return nullptr;
        }
        if(uip->IsEmpty()) 
        {
            return Copy_e6fdf74d8dfaca72();
        }
        if(IsEmpty()) 
        {
            return uip->Copy_d1e925db301dc53f();
        }
        if(Match(uip->url)) 
        {
            if((this->url->get_Length() < uip->url->get_Length())) 
            {
                return Copy_e6fdf74d8dfaca72();
            }
             else 
            {
                return uip->Copy_d1e925db301dc53f();
            }
        }
        throw cli::gcnew<System::ArgumentException>(Locale::GetText(_T("Cannot union two different urls.")), _T("target"));
    }
    
    int32_t UrlIdentityPermission::GetTokenIndex() {
        return 13;
    }
    
    bool UrlIdentityPermission::IsEmpty() {
        return ((this->url ==  nullptr) || (this->url->get_Length() ==  0));
    }
    
    UrlIdentityPermission* UrlIdentityPermission::Cast(System::Security::IPermission* target) {
        if((target ==  nullptr)) 
        {
            return nullptr;
        }
        UrlIdentityPermission *uip = cli::as<UrlIdentityPermission*>(target);
        if((uip ==  nullptr)) 
        {
            System::Security::CodeAccessPermission::ThrowInvalidPermission(target, cli::typeof<System::Type>::info);
        }
        return uip;
    }
    
    bool UrlIdentityPermission::Match(System::String* target) {
        if(((this->url ==  nullptr) || (target ==  nullptr))) 
        {
            return false;
        }
        int32_t wcu = this->url->LastIndexOf4(u'*');
        int32_t wct = target->LastIndexOf4(u'*');
        int32_t length = 2147483647;
        if(((wcu ==  -1) && (wct ==  -1))) 
        {
            length = System::Math::Max5(this->url->get_Length(), target->get_Length());
        }
         else 
        {
            if((wcu ==  -1)) 
            {
                length = wct;
            }
             else 
            {
                if((wct ==  -1)) 
                {
                    length = wcu;
                }
                 else 
                {
                    length = System::Math::Min5(wcu, wct);
                }
            }
        }
        return (System::String::Compare6(this->url, 0, target, 0, length, true, System::Globalization::CultureInfo::get_InvariantCulture()) ==  0);
    }
    
    System::String* UrlIdentityPermission::get_Url() {
        return this->url;
    }
    
    System::String* UrlIdentityPermission::set_Url(System::String* value) {
        this->url = (value ==  nullptr) ? System::String::Empty : value;
        return get_Url();
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    
    
    void UrlIdentityPermissionAttribute::constructor(SecurityAction action) {
    }
    
    System::Security::IPermission* UrlIdentityPermissionAttribute::CreatePermission_cae8413caba48c05() {
        if(this->get_Unrestricted()) 
        {
            return cli::gcnew<UrlIdentityPermission>(PermissionState::Unrestricted);
        }
         else 
        {
            if((this->url ==  nullptr)) 
            {
                return cli::gcnew<UrlIdentityPermission>(PermissionState::None);
            }
             else 
            {
                return cli::gcnew<UrlIdentityPermission>(this->url);
            }
        }
    }
    
    System::String* UrlIdentityPermissionAttribute::get_Url() {
        return this->url;
    }
    
    System::String* UrlIdentityPermissionAttribute::set_Url(System::String* value) {
        this->url = value;
        return get_Url();
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    
    
    void ZoneIdentityPermission::constructor(PermissionState state) {
        System::Security::CodeAccessPermission::CheckPermissionState(state, false);
        this->zone = System::Security::SecurityZone::NoZone;
    }
    
    void ZoneIdentityPermission::constructor(System::Security::SecurityZone zone) {
        this->set_SecurityZone(zone);
    }
    
    System::Security::IPermission* ZoneIdentityPermission::Copy_d1e925db301dc53f() {
        return cli::gcnew<ZoneIdentityPermission>(this->zone);
    }
    
    bool ZoneIdentityPermission::IsSubsetOf_76947f8575c4d81(System::Security::IPermission* target) {
        ZoneIdentityPermission *zip = Cast(target);
        if((zip ==  nullptr)) 
        {
            return ((int32_t)(this->zone) ==  -1);
        }
        return (((int32_t)(this->zone) ==  -1) || ((int32_t)(this->zone) ==  (int32_t)(zip->zone)));
    }
    
    System::Security::IPermission* ZoneIdentityPermission::Union_b0ddcab6cb9c8441(System::Security::IPermission* target) {
        ZoneIdentityPermission *zip = Cast(target);
        if((zip ==  nullptr)) 
        {
            return ((int32_t)(this->zone) ==  -1) ? nullptr : Copy_e6fdf74d8dfaca72();
        }
        if((((int32_t)(this->zone) ==  (int32_t)(zip->zone)) || ((int32_t)(zip->zone) ==  -1))) 
        {
            return Copy_e6fdf74d8dfaca72();
        }
        if(((int32_t)(this->zone) ==  -1)) 
        {
            return zip->Copy_d1e925db301dc53f();
        }
        throw cli::gcnew<System::ArgumentException>(Locale::GetText(_T("Union impossible")));
    }
    
    System::Security::IPermission* ZoneIdentityPermission::Intersect_7dbf5aef702b16af(System::Security::IPermission* target) {
        ZoneIdentityPermission *zip = Cast(target);
        if(((zip ==  nullptr) || ((int32_t)(this->zone) ==  -1))) 
        {
            return nullptr;
        }
        if(((int32_t)(this->zone) ==  (int32_t)(zip->zone))) 
        {
            return Copy_e6fdf74d8dfaca72();
        }
        return nullptr;
    }
    
    void ZoneIdentityPermission::FromXml_ec3b425a66b43072(System::Security::SecurityElement* esd) {
        System::Security::CodeAccessPermission::CheckSecurityElement(esd, _T("esd"), 1, 1);
        System::String *zoneName = esd->Attribute2(_T("Zone"));
        if((zoneName ==  nullptr)) 
        {
            this->zone = System::Security::SecurityZone::NoZone;
        }
         else 
        {
            this->zone = cli::unbox<System::Security::SecurityZone>(System::Enum::Parse(cli::typeof<System::Type>::info, zoneName));
        }
    }
    
    System::Security::SecurityElement* ZoneIdentityPermission::ToXml_9ee4cd8af8e8f747() {
        System::Security::SecurityElement *se = System::Security::CodeAccessPermission::Element2(1);
        if(((int32_t)(this->zone) != -1)) 
        {
            se->AddAttribute(_T("Zone"), cli::import(this->zone)->ToString_1636a0751cb9ac11());
        }
        return se;
    }
    
    int32_t ZoneIdentityPermission::GetTokenIndex() {
        return 14;
    }
    
    ZoneIdentityPermission* ZoneIdentityPermission::Cast(System::Security::IPermission* target) {
        if((target ==  nullptr)) 
        {
            return nullptr;
        }
        ZoneIdentityPermission *zip = cli::as<ZoneIdentityPermission*>(target);
        if((zip ==  nullptr)) 
        {
            System::Security::CodeAccessPermission::ThrowInvalidPermission(target, cli::typeof<System::Type>::info);
        }
        return zip;
    }
    
    System::Security::SecurityZone ZoneIdentityPermission::get_SecurityZone() {
        return this->zone;
    }
    
    System::Security::SecurityZone ZoneIdentityPermission::set_SecurityZone(System::Security::SecurityZone value) {
        if(!(System::Enum::IsDefined(cli::typeof<System::Type>::info, cli::box(value)))) 
        {
            System::String *msg = System::String::Format2(Locale::GetText(_T("Invalid enum {0}")), cli::box(value));
            throw cli::gcnew<System::ArgumentException>(msg, _T("SecurityZone"));
        }
        this->zone = value;
        return get_SecurityZone();
    }
    
}}}
namespace System { namespace Security { namespace Permissions {
    
    
    void ZoneIdentityPermissionAttribute::constructor(SecurityAction action) {
        this->zone = System::Security::SecurityZone::NoZone;
    }
    
    System::Security::IPermission* ZoneIdentityPermissionAttribute::CreatePermission_cae8413caba48c05() {
        if(this->get_Unrestricted()) 
        {
            return cli::gcnew<ZoneIdentityPermission>(PermissionState::Unrestricted);
        }
         else 
        {
            return cli::gcnew<ZoneIdentityPermission>(this->zone);
        }
    }
    
    System::Security::SecurityZone ZoneIdentityPermissionAttribute::get_Zone() {
        return this->zone;
    }
    
    System::Security::SecurityZone ZoneIdentityPermissionAttribute::set_Zone(System::Security::SecurityZone value) {
        this->zone = value;
        return get_Zone();
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    
    
    void AllMembershipCondition::constructor() {
    }
    
    bool AllMembershipCondition::Check(Evidence* evidence) {
        return true;
    }
    
    IMembershipCondition* AllMembershipCondition::Copy() {
        return cli::gcnew<AllMembershipCondition>();
    }
    
    bool AllMembershipCondition::Equals_ed975d2f4a7d193e(System::Object* o) {
        return cli::is<AllMembershipCondition>(o);
    }
    
    void AllMembershipCondition::FromXml(System::Security::SecurityElement* e) {
        FromXml2(e, nullptr);
    }
    
    void AllMembershipCondition::FromXml2(System::Security::SecurityElement* e, PolicyLevel* level) {
        MembershipConditionHelper::CheckSecurityElement(e, _T("e"), this->version, this->version);
    }
    
    int32_t AllMembershipCondition::GetHashCode_6648aef0f235ee6c() {
        return cli::typeof<System::Type>::info->GetHashCode_6648aef0f235ee6c();
    }
    
    System::String* AllMembershipCondition::ToString_1636a0751cb9ac11() {
        return _T("All code");
    }
    
    System::Security::SecurityElement* AllMembershipCondition::ToXml() {
        return ToXml2(nullptr);
    }
    
    System::Security::SecurityElement* AllMembershipCondition::ToXml2(PolicyLevel* level) {
        System::Security::SecurityElement *se = MembershipConditionHelper::Element2(cli::typeof<System::Type>::info, this->version);
        return se;
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    
    
    void ApplicationDefaultCodeGroup::constructor(IMembershipCondition* membershipCondition) {
    }
    
    CodeGroup* ApplicationDefaultCodeGroup::Copy_7fdc78f7390869fe() {
        ApplicationDefaultCodeGroup *copy = cli::gcnew<ApplicationDefaultCodeGroup>(this->get_MembershipCondition());
        for(auto tmp_574 : this->get_Children()) {
            auto child = cli::cast<CodeGroup*>(tmp_574);
            {
                copy->AddChild(child->Copy_7fdc78f7390869fe());
            }
        }
        return copy;
    }
    
    PolicyStatement* ApplicationDefaultCodeGroup::Resolve_e0385e713d5ae5af(Evidence* evidence) {
        if((evidence ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("evidence"));
        }
        return nullptr;
    }
    
    CodeGroup* ApplicationDefaultCodeGroup::ResolveMatchingCodeGroups_908cc5caa682e9f4(Evidence* evidence) {
        return nullptr;
    }
    
    System::String* ApplicationDefaultCodeGroup::get_MergeLogic_cd001da1f3850530() {
        return _T("MergeLogic_Union");
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    
    
    void ApplicationDirectory::constructor(System::String* name) {
        if((name ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("name"));
        }
        if((name->get_Length() < 1)) 
        {
            throw cli::gcnew<System::FormatException>(Locale::GetText(_T("Empty")));
        }
        this->directory = name;
    }
    
    System::Object* ApplicationDirectory::Copy() {
        return cli::gcnew<ApplicationDirectory>(this->get_Directory());
    }
    
    bool ApplicationDirectory::Equals_ed975d2f4a7d193e(System::Object* o) {
        ApplicationDirectory *compare = cli::as<ApplicationDirectory*>(o);
        if((compare != nullptr)) 
        {
            ThrowOnInvalid(compare->directory);
            return System::String::op_Equality(this->directory, compare->directory);
        }
        return false;
    }
    
    int32_t ApplicationDirectory::GetHashCode_6648aef0f235ee6c() {
        return this->get_Directory()->GetHashCode_6648aef0f235ee6c();
    }
    
    System::String* ApplicationDirectory::ToString_1636a0751cb9ac11() {
        ThrowOnInvalid(this->get_Directory());
        System::Security::SecurityElement *element = cli::gcnew<System::Security::SecurityElement>(_T("System.Security.Policy.ApplicationDirectory"));
        element->AddAttribute(_T("version"), _T("1"));
        element->AddChild(cli::gcnew<System::Security::SecurityElement>(_T("Directory"), this->directory));
        return element->ToString_1636a0751cb9ac11();
    }
    
    int32_t ApplicationDirectory::GetRequiredSize(bool verbose) {
        return (verbose ? 3 : 1 + this->directory->get_Length());
    }
    
    int32_t ApplicationDirectory::InitFromBuffer(cli::array<char16_t>* buffer, int32_t position) {
        return 0;
    }
    
    int32_t ApplicationDirectory::OutputToBuffer(cli::array<char16_t>* buffer, int32_t position, bool verbose) {
        return 0;
    }
    
    void ApplicationDirectory::ThrowOnInvalid(System::String* appdir) {
        if((appdir->IndexOfAny(System::IO::Path::InvalidPathChars) != -1)) 
        {
            System::String *msg = Locale::GetText(_T("Invalid character(s) in directory {0}"));
            throw cli::gcnew<System::ArgumentException>(System::String::Format2(msg, appdir), _T("other"));
        }
    }
    
    System::String* ApplicationDirectory::get_Directory() {
        return this->directory;
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    
    
    void ApplicationDirectoryMembershipCondition::constructor() {
    }
    
    bool ApplicationDirectoryMembershipCondition::Check(Evidence* evidence) {
        if((evidence ==  nullptr)) 
        {
            return false;
        }
        System::String *codebase = System::Reflection::Assembly::GetCallingAssembly()->get_CodeBase_5e12949b795c9d90();
        Mono::Security::Uri *local = cli::gcnew<Mono::Security::Uri>(codebase);
        Url *ucode = cli::gcnew<Url>(codebase);
        bool adir = false;
        bool url = false;
        System::Collections::IEnumerator *e = evidence->GetHostEnumerator();
        while(e->MoveNext_4e78e145935f5417()) {
            System::Object *o = e->get_Current_8eca9b3da02b123a();
            if((!(adir) && cli::is<ApplicationDirectory>(o))) 
            {
                ApplicationDirectory *ad = cli::as<ApplicationDirectory*>(o);
                System::String *s = ad->get_Directory();
                adir = (System::String::Compare6(s, 0, local->ToString_1636a0751cb9ac11(), 0, s->get_Length(), true, System::Globalization::CultureInfo::get_InvariantCulture()) ==  0);
            }
             else 
            {
                if((!(url) && cli::is<Url>(o))) 
                {
                    url = ucode->Equals_ed975d2f4a7d193e(o);
                }
            }
            if((adir && url)) 
            {
                return true;
            }
        }
        return false;
    }
    
    IMembershipCondition* ApplicationDirectoryMembershipCondition::Copy() {
        return cli::gcnew<ApplicationDirectoryMembershipCondition>();
    }
    
    bool ApplicationDirectoryMembershipCondition::Equals_ed975d2f4a7d193e(System::Object* o) {
        return cli::is<ApplicationDirectoryMembershipCondition>(o);
    }
    
    void ApplicationDirectoryMembershipCondition::FromXml(System::Security::SecurityElement* e) {
        FromXml2(e, nullptr);
    }
    
    void ApplicationDirectoryMembershipCondition::FromXml2(System::Security::SecurityElement* e, PolicyLevel* level) {
        MembershipConditionHelper::CheckSecurityElement(e, _T("e"), this->version, this->version);
    }
    
    int32_t ApplicationDirectoryMembershipCondition::GetHashCode_6648aef0f235ee6c() {
        return cli::typeof<System::Type>::info->GetHashCode_6648aef0f235ee6c();
    }
    
    System::String* ApplicationDirectoryMembershipCondition::ToString_1636a0751cb9ac11() {
        return _T("ApplicationDirectory");
    }
    
    System::Security::SecurityElement* ApplicationDirectoryMembershipCondition::ToXml() {
        return ToXml2(nullptr);
    }
    
    System::Security::SecurityElement* ApplicationDirectoryMembershipCondition::ToXml2(PolicyLevel* level) {
        System::Security::SecurityElement *se = MembershipConditionHelper::Element2(cli::typeof<System::Type>::info, this->version);
        return se;
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    
    
    void ApplicationMembershipCondition::constructor() {
        this->_lookAtDir = true;
    }
    
    bool ApplicationMembershipCondition::Check(Evidence* evidence) {
        if((evidence ==  nullptr)) 
        {
            return false;
        }
        System::Collections::IEnumerator *e = evidence->GetHostEnumerator();
        while(e->MoveNext_4e78e145935f5417()) {
        }
        return false;
    }
    
    IMembershipCondition* ApplicationMembershipCondition::Copy() {
        return cli::gcnew<ApplicationMembershipCondition>();
    }
    
    bool ApplicationMembershipCondition::Equals_ed975d2f4a7d193e(System::Object* o) {
        return cli::is<ApplicationMembershipCondition>(o);
    }
    
    void ApplicationMembershipCondition::FromXml(System::Security::SecurityElement* e) {
        FromXml2(e, nullptr);
    }
    
    void ApplicationMembershipCondition::FromXml2(System::Security::SecurityElement* e, PolicyLevel* level) {
        MembershipConditionHelper::CheckSecurityElement(e, _T("e"), this->version, this->version);
        if(!(System::Boolean::TryParse(e->Attribute2(_T("LookAtDir")), this->_lookAtDir))) 
        {
            this->_lookAtDir = false;
        }
    }
    
    int32_t ApplicationMembershipCondition::GetHashCode_6648aef0f235ee6c() {
        return -1;
    }
    
    System::String* ApplicationMembershipCondition::ToString_1636a0751cb9ac11() {
        System::ActivationContext *ac = System::AppDomain::get_CurrentDomain()->get_ActivationContext();
        if((ac ==  nullptr)) 
        {
            return _T("Application");
        }
         else 
        {
            return cli::concat(_T("Application - "), ac->get_Identity()->get_FullName());
        }
    }
    
    System::Security::SecurityElement* ApplicationMembershipCondition::ToXml() {
        return ToXml2(nullptr);
    }
    
    System::Security::SecurityElement* ApplicationMembershipCondition::ToXml2(PolicyLevel* level) {
        System::Security::SecurityElement *se = MembershipConditionHelper::Element2(cli::typeof<System::Type>::info, this->version);
        if(this->_lookAtDir) 
        {
            se->AddAttribute(_T("LookAtDir"), _T("true"));
        }
        return se;
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    
    
    void ApplicationSecurityInfo::constructor(System::ActivationContext* activationContext) {
        if((activationContext ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("activationContext"));
        }
    }
    
    Evidence* ApplicationSecurityInfo::get_ApplicationEvidence() {
        return this->_evidence;
    }
    
    Evidence* ApplicationSecurityInfo::set_ApplicationEvidence(Evidence* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("ApplicationEvidence"));
        }
        this->_evidence = value;
        return get_ApplicationEvidence();
    }
    
    System::ApplicationId* ApplicationSecurityInfo::get_ApplicationId() {
        return this->_appid;
    }
    
    System::ApplicationId* ApplicationSecurityInfo::set_ApplicationId(System::ApplicationId* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("ApplicationId"));
        }
        this->_appid = value;
        return get_ApplicationId();
    }
    
    System::Security::PermissionSet* ApplicationSecurityInfo::get_DefaultRequestSet() {
        if((this->_defaultSet ==  nullptr)) 
        {
            return cli::gcnew<System::Security::PermissionSet>(System::Security::Permissions::PermissionState::None);
        }
        return this->_defaultSet;
    }
    
    System::Security::PermissionSet* ApplicationSecurityInfo::set_DefaultRequestSet(System::Security::PermissionSet* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("DefaultRequestSet"));
        }
        this->_defaultSet = value;
        return get_DefaultRequestSet();
    }
    
    System::ApplicationId* ApplicationSecurityInfo::get_DeploymentId() {
        return this->_deployid;
    }
    
    System::ApplicationId* ApplicationSecurityInfo::set_DeploymentId(System::ApplicationId* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("DeploymentId"));
        }
        this->_deployid = value;
        return get_DeploymentId();
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    
    IApplicationTrustManager*  ApplicationSecurityManager::_appTrustManager;
    ApplicationTrustCollection*  ApplicationSecurityManager::_userAppTrusts;
    
    bool ApplicationSecurityManager::DetermineApplicationTrust(System::ActivationContext* activationContext, TrustManagerContext* context) {
        if((activationContext ==  nullptr)) 
        {
            throw cli::gcnew<System::NullReferenceException>(_T("activationContext"));
        }
        ApplicationTrust *at = ApplicationSecurityManager::get_ApplicationTrustManager()->DetermineApplicationTrust_29a1102f04ee3483(activationContext, context);
        return at->get_IsApplicationTrustedToRun();
    }
    
    IApplicationTrustManager* ApplicationSecurityManager::get_ApplicationTrustManager() {
        if((_appTrustManager ==  nullptr)) 
        {
            _appTrustManager = cli::gcnew<MonoTrustManager>();
        }
        return _appTrustManager;
    }
    
    ApplicationTrustCollection* ApplicationSecurityManager::get_UserApplicationTrusts() {
        if((_userAppTrusts ==  nullptr)) 
        {
            _userAppTrusts = cli::gcnew<ApplicationTrustCollection>();
        }
        return _userAppTrusts;
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    
    
    void ApplicationSecurityManagerCodeGroup::constructor(IMembershipCondition* membershipCondition) {
    }
    
    CodeGroup* ApplicationSecurityManagerCodeGroup::Copy_7fdc78f7390869fe() {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    PolicyStatement* ApplicationSecurityManagerCodeGroup::Resolve_e0385e713d5ae5af(Evidence* evidence) {
        if((evidence ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("evidence"));
        }
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    CodeGroup* ApplicationSecurityManagerCodeGroup::ResolveMatchingCodeGroups_908cc5caa682e9f4(Evidence* evidence) {
        if((evidence ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("evidence"));
        }
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    System::String* ApplicationSecurityManagerCodeGroup::get_MergeLogic_cd001da1f3850530() {
        return _T("Union");
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    
    
    void ApplicationTrust::constructor() {
        this->fullTrustAssemblies = cli::gcnew<System::Collections::Generic::List<StrongName2*>>(0);
    }
    
    void ApplicationTrust::constructor(System::ApplicationIdentity* applicationIdentity) {
        if((applicationIdentity ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("applicationIdentity"));
        }
        this->_appid = applicationIdentity;
    }
    
    void ApplicationTrust::constructor(System::Security::PermissionSet* defaultGrantSet, System::Collections::Generic::IEnumerable2<StrongName2*>* fullTrustAssemblies) {
        if((defaultGrantSet ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("defaultGrantSet"));
        }
        this->_defaultPolicy = cli::gcnew<PolicyStatement>(defaultGrantSet);
        if((fullTrustAssemblies ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("fullTrustAssemblies"));
        }
        this->fullTrustAssemblies = cli::gcnew<System::Collections::Generic::List<StrongName2*>>();
        for(auto tmp_575 : fullTrustAssemblies) {
            auto a = cli::cast<StrongName2*>(tmp_575);
            {
                if((a ==  nullptr)) 
                {
                    throw cli::gcnew<System::ArgumentException>(_T("fullTrustAssemblies contains an assembly that does not have a StrongName"));
                }
                this->fullTrustAssemblies->Add_a6fc54bc2aa3c029(cli::cast<StrongName2*>(a->Copy()));
            }
        }
    }
    
    void ApplicationTrust::FromXml(System::Security::SecurityElement* element) {
        if((element ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("element"));
        }
        if(System::String::op_Inequality(element->get_Tag(), _T("ApplicationTrust"))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("element"));
        }
        System::String *s = element->Attribute2(_T("FullName"));
        if((s != nullptr)) 
        {
            this->_appid = cli::gcnew<System::ApplicationIdentity>(s);
        }
         else 
        {
            this->_appid = nullptr;
        }
        this->_defaultPolicy = nullptr;
        System::Security::SecurityElement *defaultGrant = element->SearchForChildByTag(_T("DefaultGrant"));
        if((defaultGrant != nullptr)) 
        {
            for(int32_t i = 0; (i < defaultGrant->get_Children()->get_Count_2354963792616712()); i++){
                System::Security::SecurityElement *se = cli::as<System::Security::SecurityElement*>(defaultGrant->get_Children()->get_Item_fd0155f142ae570(i));
                if(System::String::op_Equality(se->get_Tag(), _T("PolicyStatement"))) 
                {
                    this->get_DefaultGrantSet()->FromXml2(se, nullptr);
                    break;
                }
            }
        }
        if(!(System::Boolean::TryParse(element->Attribute2(_T("TrustedToRun")), this->_trustrun))) 
        {
            this->_trustrun = false;
        }
        if(!(System::Boolean::TryParse(element->Attribute2(_T("Persist")), this->_persist))) 
        {
            this->_persist = false;
        }
        this->_xtranfo = nullptr;
        System::Security::SecurityElement *xtra = element->SearchForChildByTag(_T("ExtraInfo"));
        if((xtra != nullptr)) 
        {
            s = xtra->Attribute2(_T("Data"));
            if((s != nullptr)) 
            {
                cli::array<unsigned char> *data = Mono::Security::Cryptography::CryptoConvert::FromHex(s);
                {
                    /* USING - BLOCK */
                    auto ms = cli::gcnew<System::IO::MemoryStream>(data);
                    cli::using_guard{ms};
                    System::Runtime::Serialization::Formatters::Binary::BinaryFormatter *bf = cli::gcnew<System::Runtime::Serialization::Formatters::Binary::BinaryFormatter>();
                    this->_xtranfo = bf->Deserialize(ms);
                }
            }
        }
    }
    
    System::Security::SecurityElement* ApplicationTrust::ToXml() {
        System::Security::SecurityElement *se = cli::gcnew<System::Security::SecurityElement>(_T("ApplicationTrust"));
        se->AddAttribute(_T("version"), _T("1"));
        if((this->_appid != nullptr)) 
        {
            se->AddAttribute(_T("FullName"), this->_appid->get_FullName());
        }
        if(this->_trustrun) 
        {
            se->AddAttribute(_T("TrustedToRun"), _T("true"));
        }
        if(this->_persist) 
        {
            se->AddAttribute(_T("Persist"), _T("true"));
        }
        System::Security::SecurityElement *defaultGrant = cli::gcnew<System::Security::SecurityElement>(_T("DefaultGrant"));
        defaultGrant->AddChild(this->get_DefaultGrantSet()->ToXml());
        se->AddChild(defaultGrant);
        if((this->_xtranfo != nullptr)) 
        {
            cli::array<unsigned char> *data = nullptr;
            {
                /* USING - BLOCK */
                auto ms = cli::gcnew<System::IO::MemoryStream>();
                cli::using_guard{ms};
                System::Runtime::Serialization::Formatters::Binary::BinaryFormatter *bf = cli::gcnew<System::Runtime::Serialization::Formatters::Binary::BinaryFormatter>();
                bf->Serialize(ms, this->_xtranfo);
                data = ms->ToArray_ebf8bde16e9d2ad6();
            }
            System::Security::SecurityElement *xtra = cli::gcnew<System::Security::SecurityElement>(_T("ExtraInfo"));
            xtra->AddAttribute(_T("Data"), Mono::Security::Cryptography::CryptoConvert::ToHex(data));
            se->AddChild(xtra);
        }
        return se;
    }
    
    PolicyStatement* ApplicationTrust::GetDefaultGrantSet() {
        System::Security::PermissionSet *ps = cli::gcnew<System::Security::PermissionSet>(System::Security::Permissions::PermissionState::None);
        return cli::gcnew<PolicyStatement>(ps);
    }
    
    System::ApplicationIdentity* ApplicationTrust::get_ApplicationIdentity() {
        return this->_appid;
    }
    
    System::ApplicationIdentity* ApplicationTrust::set_ApplicationIdentity(System::ApplicationIdentity* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("ApplicationIdentity"));
        }
        this->_appid = value;
        return get_ApplicationIdentity();
    }
    
    PolicyStatement* ApplicationTrust::get_DefaultGrantSet() {
        if((this->_defaultPolicy ==  nullptr)) 
        {
            this->_defaultPolicy = GetDefaultGrantSet();
        }
        return this->_defaultPolicy;
    }
    
    PolicyStatement* ApplicationTrust::set_DefaultGrantSet(PolicyStatement* value) {
        this->_defaultPolicy = value;
        return get_DefaultGrantSet();
    }
    
    System::Object* ApplicationTrust::get_ExtraInfo() {
        return this->_xtranfo;
    }
    
    System::Object* ApplicationTrust::set_ExtraInfo(System::Object* value) {
        this->_xtranfo = value;
        return get_ExtraInfo();
    }
    
    bool ApplicationTrust::get_IsApplicationTrustedToRun() {
        return this->_trustrun;
    }
    
    bool ApplicationTrust::set_IsApplicationTrustedToRun(bool value) {
        this->_trustrun = value;
        return get_IsApplicationTrustedToRun();
    }
    
    bool ApplicationTrust::get_Persist() {
        return this->_persist;
    }
    
    bool ApplicationTrust::set_Persist(bool value) {
        this->_persist = value;
        return get_Persist();
    }
    
    System::Collections::Generic::IList2<StrongName2*>* ApplicationTrust::get_FullTrustAssemblies() {
        return this->fullTrustAssemblies;
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    
    
    void ApplicationTrustCollection::constructor() {
        this->_list = cli::gcnew<System::Collections::ArrayList>();
    }
    
    int32_t ApplicationTrustCollection::Add(ApplicationTrust* trust) {
        if((trust ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("trust"));
        }
        if((trust->get_ApplicationIdentity() ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentException>(Locale::GetText(_T("ApplicationTrust.ApplicationIdentity can\'t be null.")), _T("trust"));
        }
        return this->_list->Add_e6a92085999ce388(trust);
    }
    
    void ApplicationTrustCollection::AddRange(cli::array<ApplicationTrust*>* trusts) {
        if((trusts ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("trusts"));
        }
        for(auto tmp_576 : trusts) {
            auto t = cli::cast<ApplicationTrust*>(tmp_576);
            {
                if((t->get_ApplicationIdentity() ==  nullptr)) 
                {
                    throw cli::gcnew<System::ArgumentException>(Locale::GetText(_T("ApplicationTrust.ApplicationIdentity can\'t be null.")), _T("trust"));
                }
                this->_list->Add_e6a92085999ce388(t);
            }
        }
    }
    
    void ApplicationTrustCollection::AddRange2(ApplicationTrustCollection* trusts) {
        if((trusts ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("trusts"));
        }
        for(auto tmp_577 : trusts) {
            auto t = cli::cast<ApplicationTrust*>(tmp_577);
            {
                if((t->get_ApplicationIdentity() ==  nullptr)) 
                {
                    throw cli::gcnew<System::ArgumentException>(Locale::GetText(_T("ApplicationTrust.ApplicationIdentity can\'t be null.")), _T("trust"));
                }
                this->_list->Add_e6a92085999ce388(t);
            }
        }
    }
    
    void ApplicationTrustCollection::Clear() {
        this->_list->Clear_cd6654e5a40f5056();
    }
    
    void ApplicationTrustCollection::CopyTo(cli::array<ApplicationTrust*>* array, int32_t index) {
        this->_list->CopyTo_2bc540dad3c25b9e(array, index);
    }
    
    void ApplicationTrustCollection::CopyTo2(System::Array* array, int32_t index) {
        this->_list->CopyTo_2bc540dad3c25b9e(array, index);
    }
    
    ApplicationTrustCollection* ApplicationTrustCollection::Find(System::ApplicationIdentity* applicationIdentity, ApplicationVersionMatch versionMatch) {
        if((applicationIdentity ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("applicationIdentity"));
        }
        System::String *fullname = applicationIdentity->get_FullName();
        switch(versionMatch) {
            case ApplicationVersionMatch::MatchAllVersions: case_1722: {
                int32_t pos = fullname->IndexOf7(_T(", Version="));
                if((pos >= 0)) 
                {
                    fullname = fullname->Substring2(0, pos);
                }
                break;
            }
            case ApplicationVersionMatch::MatchExactVersion: case_1723: {
                break;
            }
            default: case_1724: {
                throw cli::gcnew<System::ArgumentException>(_T("versionMatch"));
            }
        }
        ApplicationTrustCollection *coll = cli::gcnew<ApplicationTrustCollection>();
        for(auto tmp_578 : this->_list) {
            auto t = cli::cast<ApplicationTrust*>(tmp_578);
            {
                if(t->get_ApplicationIdentity()->get_FullName()->StartsWith(fullname)) 
                {
                    coll->Add(t);
                }
            }
        }
        return coll;
    }
    
    ApplicationTrustEnumerator* ApplicationTrustCollection::GetEnumerator() {
        return cli::gcnew<ApplicationTrustEnumerator>(this);
    }
    
    System::Collections::IEnumerator* ApplicationTrustCollection::GetEnumerator2() {
        return cli::cast<System::Collections::IEnumerator*>(cli::gcnew<ApplicationTrustEnumerator>(this));
    }
    
    void ApplicationTrustCollection::Remove(ApplicationTrust* trust) {
        if((trust ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("trust"));
        }
        if((trust->get_ApplicationIdentity() ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentException>(Locale::GetText(_T("ApplicationTrust.ApplicationIdentity can\'t be null.")), _T("trust"));
        }
        RemoveAllInstances(trust);
    }
    
    void ApplicationTrustCollection::Remove2(System::ApplicationIdentity* applicationIdentity, ApplicationVersionMatch versionMatch) {
        ApplicationTrustCollection *coll = Find(applicationIdentity, versionMatch);
        for(auto tmp_579 : coll) {
            auto t = cli::cast<ApplicationTrust*>(tmp_579);
            {
                RemoveAllInstances(t);
            }
        }
    }
    
    void ApplicationTrustCollection::RemoveRange(cli::array<ApplicationTrust*>* trusts) {
        if((trusts ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("trusts"));
        }
        for(auto tmp_580 : trusts) {
            auto t = cli::cast<ApplicationTrust*>(tmp_580);
            {
                RemoveAllInstances(t);
            }
        }
    }
    
    void ApplicationTrustCollection::RemoveRange2(ApplicationTrustCollection* trusts) {
        if((trusts ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("trusts"));
        }
        for(auto tmp_581 : trusts) {
            auto t = cli::cast<ApplicationTrust*>(tmp_581);
            {
                RemoveAllInstances(t);
            }
        }
    }
    
    void ApplicationTrustCollection::RemoveAllInstances(ApplicationTrust* trust) {
        for(int32_t i = (this->_list->get_Count_2354963792616712() - 1); (i >= 0); i--){
            if(trust->Equals_ed975d2f4a7d193e(this->_list->get_Item_fd0155f142ae570(i))) 
            {
                this->_list->RemoveAt_2abea768d3273318(i);
            }
        }
    }
    
    int32_t ApplicationTrustCollection::get_Count() {
        return this->_list->get_Count_2354963792616712();
    }
    
    bool ApplicationTrustCollection::get_IsSynchronized() {
        return false;
    }
    
    System::Object* ApplicationTrustCollection::get_SyncRoot() {
        return this;
    }
    
    ApplicationTrust* ApplicationTrustCollection::get_Item(int32_t index) {
        return cli::cast<ApplicationTrust*>(this->_list->get_Item_fd0155f142ae570(index));
    }
    
    ApplicationTrust* ApplicationTrustCollection::get_Item2(System::String* appFullName) {
        for(int32_t i = 0; (i < this->_list->get_Count_2354963792616712()); i++){
            ApplicationTrust *at = cli::as<ApplicationTrust*>(this->_list->get_Item_fd0155f142ae570(i));
            if(System::String::op_Equality(at->get_ApplicationIdentity()->get_FullName(), appFullName)) 
            {
                return at;
            }
        }
        return nullptr;
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    
    
    void ApplicationTrustEnumerator::constructor(ApplicationTrustCollection* collection) {
        this->e = collection->GetEnumerator();
    }
    
    bool ApplicationTrustEnumerator::MoveNext() {
        return this->e->MoveNext_4e78e145935f5417();
    }
    
    void ApplicationTrustEnumerator::Reset() {
        this->e->Reset_bcd82381eed41868();
    }
    
    ApplicationTrust* ApplicationTrustEnumerator::get_Current() {
        return cli::cast<ApplicationTrust*>(this->e->get_Current_8eca9b3da02b123a());
    }
    
    System::Object* ApplicationTrustEnumerator::get_Current2() {
        return this->e->get_Current_8eca9b3da02b123a();
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    
    System::String*  CodeConnectAccess::AnyScheme;
    int32_t  CodeConnectAccess::DefaultPort;
    int32_t  CodeConnectAccess::OriginPort;
    System::String*  CodeConnectAccess::OriginScheme;
    
    CodeConnectAccess::CodeConnectAccess()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void CodeConnectAccess::constructor(System::String* allowScheme, int32_t allowPort) {
        if(((allowScheme ==  nullptr) || (allowScheme->get_Length() ==  0))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("allowScheme"));
        }
        if(((allowPort < 0) || (allowPort > 65535))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("allowPort"));
        }
        this->_scheme = allowScheme;
        this->_port = allowPort;
    }
    
    void CodeConnectAccess::static_constructor() {
    }
    
    bool CodeConnectAccess::Equals_ed975d2f4a7d193e(System::Object* o) {
        CodeConnectAccess *cca = cli::as<CodeConnectAccess*>(o);
        if((cca ==  nullptr)) 
        {
            return false;
        }
        return (System::String::op_Equality(this->_scheme, cca->_scheme) && (this->_port ==  cca->_port));
    }
    
    int32_t CodeConnectAccess::GetHashCode_6648aef0f235ee6c() {
        return (this->_scheme->GetHashCode_6648aef0f235ee6c() ^ this->_port);
    }
    
    CodeConnectAccess* CodeConnectAccess::CreateAnySchemeAccess(int32_t allowPort) {
        return cli::gcnew<CodeConnectAccess>(AnyScheme, allowPort);
    }
    
    CodeConnectAccess* CodeConnectAccess::CreateOriginSchemeAccess(int32_t allowPort) {
        return cli::gcnew<CodeConnectAccess>(OriginScheme, allowPort);
    }
    
    int32_t CodeConnectAccess::get_Port() {
        return this->_port;
    }
    
    System::String* CodeConnectAccess::get_Scheme() {
        return this->_scheme;
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    
    
    void CodeGroup::constructor(IMembershipCondition* membershipCondition, PolicyStatement* policy) {
        if((membershipCondition ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("membershipCondition"));
        }
        if((policy != nullptr)) 
        {
            this->m_policy = policy->Copy();
        }
        this->m_membershipCondition = membershipCondition->Copy_44d120d5c8a6f573();
    }
    
    void CodeGroup::constructor(System::Security::SecurityElement* e, PolicyLevel* level) {
        FromXml2(e, level);
    }
    
    void CodeGroup::AddChild(CodeGroup* group) {
        if((group ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("group"));
        }
        this->m_children->Add_e6a92085999ce388(group->Copy_7fdc78f7390869fe());
    }
    
    bool CodeGroup::Equals_ed975d2f4a7d193e(System::Object* o) {
        CodeGroup *cg = cli::as<CodeGroup*>(o);
        if((cg ==  nullptr)) 
        {
            return false;
        }
        return Equals4(cg, false);
    }
    
    bool CodeGroup::Equals4(CodeGroup* cg, bool compareChildren) {
        if(System::String::op_Inequality(cg->get_Name(), this->get_Name())) 
        {
            return false;
        }
        if(System::String::op_Inequality(cg->get_Description(), this->get_Description())) 
        {
            return false;
        }
        if(!(cg->get_MembershipCondition()->Equals_4b738171fe6c9984(this->m_membershipCondition))) 
        {
            return false;
        }
        if(compareChildren) 
        {
            int32_t childCount = cg->get_Children()->get_Count_8f254f3dd8e2403();
            if((this->get_Children()->get_Count_8f254f3dd8e2403() != childCount)) 
            {
                return false;
            }
            for(int32_t index = 0; (index < childCount); index++){
                if(!(cli::cast<CodeGroup*>(this->get_Children()->get_Item_8550d21996ef9dc5(index))->Equals4(cli::cast<CodeGroup*>(cg->get_Children()->get_Item_8550d21996ef9dc5(index)), false))) 
                {
                    return false;
                }
            }
        }
        return true;
    }
    
    void CodeGroup::RemoveChild(CodeGroup* group) {
        if((group != nullptr)) 
        {
            this->m_children->Remove_2225381aaf812c6d(group);
        }
    }
    
    int32_t CodeGroup::GetHashCode_6648aef0f235ee6c() {
        int32_t hashCode = this->m_membershipCondition->GetHashCode_6648aef0f235ee6c();
        if((this->m_policy != nullptr)) 
        {
            (hashCode = hashCode + this->m_policy->GetHashCode_6648aef0f235ee6c());
        }
        return hashCode;
    }
    
    void CodeGroup::FromXml(System::Security::SecurityElement* e) {
        FromXml2(e, nullptr);
    }
    
    void CodeGroup::FromXml2(System::Security::SecurityElement* e, PolicyLevel* level) {
        if((e ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("e"));
        }
        System::Security::PermissionSet *ps = nullptr;
        System::String *psetname = e->Attribute2(_T("PermissionSetName"));
        if(((psetname != nullptr) && (level != nullptr))) 
        {
            ps = level->GetNamedPermissionSet(psetname);
        }
         else 
        {
            System::Security::SecurityElement *pset = e->SearchForChildByTag(_T("PermissionSet"));
            if((pset != nullptr)) 
            {
                System::Type *classType = System::Type::GetType4(pset->Attribute2(_T("class")));
                ps = cli::cast<System::Security::PermissionSet*>(System::Activator::CreateInstance13(classType, true));
                ps->FromXml_2ac858dba9ca352b(pset);
            }
             else 
            {
                ps = cli::gcnew<System::Security::PermissionSet>(cli::gcnew<System::Security::PermissionSet>(System::Security::Permissions::PermissionState::None));
            }
        }
        this->m_policy = cli::gcnew<PolicyStatement>(ps);
        this->m_children->Clear_cd6654e5a40f5056();
        if(((e->get_Children() != nullptr) && (e->get_Children()->get_Count_2354963792616712() > 0))) 
        {
            for(auto tmp_582 : e->get_Children()) {
                auto se = cli::cast<System::Security::SecurityElement*>(tmp_582);
                {
                    if(System::String::op_Equality(se->get_Tag(), _T("CodeGroup"))) 
                    {
                        this->AddChild(CodeGroup::CreateFromXml(se, level));
                    }
                }
            }
        }
        this->m_membershipCondition = nullptr;
        System::Security::SecurityElement *mc = e->SearchForChildByTag(_T("IMembershipCondition"));
        if((mc != nullptr)) 
        {
            System::String *className = mc->Attribute2(_T("class"));
            System::Type *classType = System::Type::GetType4(className);
            if(System::Type::op_Equality2(classType, nullptr)) 
            {
                classType = System::Type::GetType4(cli::concat(_T("System.Security.Policy."), className));
            }
            this->m_membershipCondition = cli::cast<IMembershipCondition*>(System::Activator::CreateInstance13(classType, true));
            this->m_membershipCondition->FromXml_d33f37a1ca3b24b6(mc, level);
        }
        this->m_name = e->Attribute2(_T("Name"));
        this->m_description = e->Attribute2(_T("Description"));
        ParseXml_ecb12c827959aa39(e, level);
    }
    
    void CodeGroup::ParseXml_ecb12c827959aa39(System::Security::SecurityElement* e, PolicyLevel* level) {
    }
    
    System::Security::SecurityElement* CodeGroup::ToXml() {
        return ToXml2(nullptr);
    }
    
    System::Security::SecurityElement* CodeGroup::ToXml2(PolicyLevel* level) {
        System::Security::SecurityElement *e = cli::gcnew<System::Security::SecurityElement>(_T("CodeGroup"));
        e->AddAttribute(_T("class"), this->GetType()->get_AssemblyQualifiedName_cea373c2171bd483());
        e->AddAttribute(_T("version"), _T("1"));
        if((this->get_Name() != nullptr)) 
        {
            e->AddAttribute(_T("Name"), this->get_Name());
        }
        if((this->get_Description() != nullptr)) 
        {
            e->AddAttribute(_T("Description"), this->get_Description());
        }
        if((this->get_MembershipCondition() != nullptr)) 
        {
            e->AddChild(this->get_MembershipCondition()->ToXml_4868e697107d327());
        }
        if(((this->get_PolicyStatement() != nullptr) && (this->get_PolicyStatement()->get_PermissionSet() != nullptr))) 
        {
            e->AddChild(this->get_PolicyStatement()->get_PermissionSet()->ToXml_c2a66662101c88c3());
        }
        for(auto tmp_583 : this->get_Children()) {
            auto child = cli::cast<CodeGroup*>(tmp_583);
            e->AddChild(child->ToXml());
        }
        CreateXml_14eb36ca74574a81(e, level);
        return e;
    }
    
    void CodeGroup::CreateXml_14eb36ca74574a81(System::Security::SecurityElement* element, PolicyLevel* level) {
    }
    
    CodeGroup* CodeGroup::CreateFromXml(System::Security::SecurityElement* se, PolicyLevel* level) {
        System::String *fullClassName = se->Attribute2(_T("class"));
        System::String *className = fullClassName;
        int32_t n = className->IndexOf7(_T(","));
        if((n > 0)) 
        {
            className = className->Substring2(0, n);
        }
        n = className->LastIndexOf7(_T("."));
        if((n > 0)) 
        {
            className = className->Substring((n + 1));
        }
        System::String* tmp_584 = className;
        ::System::Int32 tmp_585 = -1;
        if(::System::String::Equals3(tmp_584, _T("FileCodeGroup"))) tmp_585 = 0;
        if(::System::String::Equals3(tmp_584, _T("FirstMatchCodeGroup"))) tmp_585 = 1;
        if(::System::String::Equals3(tmp_584, _T("NetCodeGroup"))) tmp_585 = 2;
        if(::System::String::Equals3(tmp_584, _T("UnionCodeGroup"))) tmp_585 = 3;
        switch(tmp_585)
        {
            case 0: case_1725: 
            {
                return cli::gcnew<FileCodeGroup>(se, level);
            }
            case 1: case_1726: 
            {
                return cli::gcnew<FirstMatchCodeGroup>(se, level);
            }
            case 2: case_1727: 
            {
                return cli::gcnew<NetCodeGroup>(se, level);
            }
            case 3: case_1728: 
            {
                return cli::gcnew<UnionCodeGroup>(se, level);
            }
            default: case_1729: 
            {
                System::Type *classType = System::Type::GetType4(fullClassName);
                CodeGroup *cg = cli::cast<CodeGroup*>(System::Activator::CreateInstance13(classType, true));
                cg->FromXml2(se, level);
                return cg;
            }
        }
    }
    
    PolicyStatement* CodeGroup::get_PolicyStatement() {
        return this->m_policy;
    }
    
    PolicyStatement* CodeGroup::set_PolicyStatement(PolicyStatement* value) {
        this->m_policy = value;
        return get_PolicyStatement();
    }
    
    System::String* CodeGroup::get_Description() {
        return this->m_description;
    }
    
    System::String* CodeGroup::set_Description(System::String* value) {
        this->m_description = value;
        return get_Description();
    }
    
    IMembershipCondition* CodeGroup::get_MembershipCondition() {
        return this->m_membershipCondition;
    }
    
    IMembershipCondition* CodeGroup::set_MembershipCondition(IMembershipCondition* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("value"));
        }
        this->m_membershipCondition = value;
        return get_MembershipCondition();
    }
    
    System::String* CodeGroup::get_Name() {
        return this->m_name;
    }
    
    System::String* CodeGroup::set_Name(System::String* value) {
        this->m_name = value;
        return get_Name();
    }
    
    System::Collections::IList* CodeGroup::get_Children() {
        return this->m_children;
    }
    
    System::Collections::IList* CodeGroup::set_Children(System::Collections::IList* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("value"));
        }
        this->m_children = cli::gcnew<System::Collections::ArrayList>(value);
        return get_Children();
    }
    
    System::String* CodeGroup::get_AttributeString_f768971bd5bbaf63() {
        if((this->m_policy != nullptr)) 
        {
            return this->m_policy->get_AttributeString();
        }
        return nullptr;
    }
    
    System::String* CodeGroup::get_PermissionSetName_4d6dd01cf3ccc2f3() {
        if((this->m_policy ==  nullptr)) 
        {
            return nullptr;
        }
        if(cli::is<System::Security::NamedPermissionSet>(this->m_policy->get_PermissionSet())) 
        {
            return cli::cast<System::Security::NamedPermissionSet*>(this->m_policy->get_PermissionSet())->get_Name();
        }
        return nullptr;
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    
    System::Collections::Generic::Dictionary<System::String*, int32_t>*  ReservedNames::__f__switch_mapF;
    
    bool ReservedNames::IsReserved(System::String* name) {
        System::String* tmp_586 = name;
        ::System::Int32 tmp_587 = -1;
        if(::System::String::Equals3(tmp_586, _T("0")) ||
        ::System::String::Equals3(tmp_586, _T("0")) ||
        ::System::String::Equals3(tmp_586, _T("0")) ||
        ::System::String::Equals3(tmp_586, _T("0")) ||
        ::System::String::Equals3(tmp_586, _T("0")) ||
        ::System::String::Equals3(tmp_586, _T("0")) ||
        ::System::String::Equals3(tmp_586, _T("0"))) tmp_587 = 0;
        switch(tmp_587)
        {
            case 0: case_1730: 
            {
                return true;
            }
            default: case_1731: 
            {
                return false;
            }
        }
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    
    System::Version*  DefaultPolicies::_fxVersion;
    cli::array<unsigned char>*  DefaultPolicies::_ecmaKey;
    System::Security::Permissions::StrongNamePublicKeyBlob*  DefaultPolicies::_ecma;
    cli::array<unsigned char>*  DefaultPolicies::_msFinalKey;
    System::Security::Permissions::StrongNamePublicKeyBlob*  DefaultPolicies::_msFinal;
    System::Security::NamedPermissionSet*  DefaultPolicies::_fullTrust;
    System::Security::NamedPermissionSet*  DefaultPolicies::_localIntranet;
    System::Security::NamedPermissionSet*  DefaultPolicies::_internet;
    System::Security::NamedPermissionSet*  DefaultPolicies::_skipVerification;
    System::Security::NamedPermissionSet*  DefaultPolicies::_execution;
    System::Security::NamedPermissionSet*  DefaultPolicies::_nothing;
    System::Security::NamedPermissionSet*  DefaultPolicies::_everything;
    System::Collections::Generic::Dictionary<System::String*, int32_t>*  DefaultPolicies::__f__switch_map10;
    
    DefaultPolicies::DefaultPolicies()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void DefaultPolicies::static_constructor() {
    }
    
    System::Security::PermissionSet* DefaultPolicies::GetSpecialPermissionSet(System::String* name) {
        if((name ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("name"));
        }
        System::String* tmp_588 = name;
        ::System::Int32 tmp_589 = -1;
        if(::System::String::Equals3(tmp_588, _T("0"))) tmp_589 = 0;
        if(::System::String::Equals3(tmp_588, _T("1"))) tmp_589 = 1;
        if(::System::String::Equals3(tmp_588, _T("2"))) tmp_589 = 2;
        if(::System::String::Equals3(tmp_588, _T("3"))) tmp_589 = 3;
        if(::System::String::Equals3(tmp_588, _T("4"))) tmp_589 = 4;
        if(::System::String::Equals3(tmp_588, _T("5"))) tmp_589 = 5;
        if(::System::String::Equals3(tmp_588, _T("6"))) tmp_589 = 6;
        switch(tmp_589)
        {
            case 0: case_1732: 
            {
                return DefaultPolicies::get_FullTrust();
            }
            case 1: case_1733: 
            {
                return DefaultPolicies::get_LocalIntranet();
            }
            case 2: case_1734: 
            {
                return DefaultPolicies::get_Internet();
            }
            case 3: case_1735: 
            {
                return DefaultPolicies::get_SkipVerification();
            }
            case 4: case_1736: 
            {
                return DefaultPolicies::get_Execution();
            }
            case 5: case_1737: 
            {
                return DefaultPolicies::get_Nothing();
            }
            case 6: case_1738: 
            {
                return DefaultPolicies::get_Everything();
            }
            default: case_1739: 
            {
                return nullptr;
            }
        }
    }
    
    StrongNameMembershipCondition* DefaultPolicies::FullTrustMembership(System::String* name, Key key) {
        System::Security::Permissions::StrongNamePublicKeyBlob *snkb = nullptr;
        switch(key) {
            case Key::Ecma: case_1740: {
                if((_ecma ==  nullptr)) 
                {
                    _ecma = cli::gcnew<System::Security::Permissions::StrongNamePublicKeyBlob>(_ecmaKey);
                }
                snkb = _ecma;
                break;
            }
            case Key::MsFinal: case_1741: {
                if((_msFinal ==  nullptr)) 
                {
                    _msFinal = cli::gcnew<System::Security::Permissions::StrongNamePublicKeyBlob>(_msFinalKey);
                }
                snkb = _msFinal;
                break;
            }
        }
        if(System::Version::op_Equality(_fxVersion, nullptr)) 
        {
            _fxVersion = cli::gcnew<System::Version>(_T("4.0.0.0"));
        }
        return cli::gcnew<StrongNameMembershipCondition>(snkb, name, _fxVersion);
    }
    
    System::Security::NamedPermissionSet* DefaultPolicies::BuildFullTrust() {
        return cli::gcnew<System::Security::NamedPermissionSet>(_T("FullTrust"), System::Security::Permissions::PermissionState::Unrestricted);
    }
    
    System::Security::NamedPermissionSet* DefaultPolicies::BuildLocalIntranet() {
        System::Security::NamedPermissionSet *nps = cli::gcnew<System::Security::NamedPermissionSet>(_T("LocalIntranet"), System::Security::Permissions::PermissionState::None);
        nps->AddPermission(cli::gcnew<System::Security::Permissions::EnvironmentPermission>(System::Security::Permissions::EnvironmentPermissionAccess::Read, _T("USERNAME;USER")));
        nps->AddPermission(cli::gcnew<System::Security::Permissions::FileDialogPermission>(System::Security::Permissions::PermissionState::Unrestricted));
        System::Security::Permissions::IsolatedStorageFilePermission *isfp = cli::gcnew<System::Security::Permissions::IsolatedStorageFilePermission>(System::Security::Permissions::PermissionState::None);
        isfp->set_UsageAllowed(System::Security::Permissions::IsolatedStorageContainment::AssemblyIsolationByUser);
        isfp->set_UserQuota(9223372036854775807L);
        nps->AddPermission(isfp);
        nps->AddPermission(cli::gcnew<System::Security::Permissions::ReflectionPermission>(System::Security::Permissions::ReflectionPermissionFlag::ReflectionEmit));
        System::Security::Permissions::SecurityPermissionFlag spf = (System::Security::Permissions::SecurityPermissionFlag)9L;
        nps->AddPermission(cli::gcnew<System::Security::Permissions::SecurityPermission>(spf));
        nps->AddPermission(cli::gcnew<System::Security::Permissions::UIPermission>(System::Security::Permissions::PermissionState::Unrestricted));
        nps->AddPermission(System::Security::PermissionBuilder::Create(_T("System.Net.DnsPermission, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"), System::Security::Permissions::PermissionState::Unrestricted));
        nps->AddPermission(System::Security::PermissionBuilder::Create2(PrintingPermission(_T("SafePrinting"))));
        return nps;
    }
    
    System::Security::NamedPermissionSet* DefaultPolicies::BuildInternet() {
        System::Security::NamedPermissionSet *nps = cli::gcnew<System::Security::NamedPermissionSet>(_T("Internet"), System::Security::Permissions::PermissionState::None);
        nps->AddPermission(cli::gcnew<System::Security::Permissions::FileDialogPermission>(System::Security::Permissions::FileDialogPermissionAccess::Open));
        System::Security::Permissions::IsolatedStorageFilePermission *isfp = cli::gcnew<System::Security::Permissions::IsolatedStorageFilePermission>(System::Security::Permissions::PermissionState::None);
        isfp->set_UsageAllowed(System::Security::Permissions::IsolatedStorageContainment::DomainIsolationByUser);
        isfp->set_UserQuota(512000L);
        nps->AddPermission(isfp);
        nps->AddPermission(cli::gcnew<System::Security::Permissions::SecurityPermission>(System::Security::Permissions::SecurityPermissionFlag::Execution));
        nps->AddPermission(cli::gcnew<System::Security::Permissions::UIPermission>(System::Security::Permissions::UIPermissionWindow::SafeTopLevelWindows, System::Security::Permissions::UIPermissionClipboard::OwnClipboard));
        nps->AddPermission(System::Security::PermissionBuilder::Create2(PrintingPermission(_T("SafePrinting"))));
        return nps;
    }
    
    System::Security::NamedPermissionSet* DefaultPolicies::BuildSkipVerification() {
        System::Security::NamedPermissionSet *nps = cli::gcnew<System::Security::NamedPermissionSet>(_T("SkipVerification"), System::Security::Permissions::PermissionState::None);
        nps->AddPermission(cli::gcnew<System::Security::Permissions::SecurityPermission>(System::Security::Permissions::SecurityPermissionFlag::SkipVerification));
        return nps;
    }
    
    System::Security::NamedPermissionSet* DefaultPolicies::BuildExecution() {
        System::Security::NamedPermissionSet *nps = cli::gcnew<System::Security::NamedPermissionSet>(_T("Execution"), System::Security::Permissions::PermissionState::None);
        nps->AddPermission(cli::gcnew<System::Security::Permissions::SecurityPermission>(System::Security::Permissions::SecurityPermissionFlag::Execution));
        return nps;
    }
    
    System::Security::NamedPermissionSet* DefaultPolicies::BuildNothing() {
        return cli::gcnew<System::Security::NamedPermissionSet>(_T("Nothing"), System::Security::Permissions::PermissionState::None);
    }
    
    System::Security::NamedPermissionSet* DefaultPolicies::BuildEverything() {
        System::Security::NamedPermissionSet *nps = cli::gcnew<System::Security::NamedPermissionSet>(_T("Everything"), System::Security::Permissions::PermissionState::None);
        nps->AddPermission(cli::gcnew<System::Security::Permissions::EnvironmentPermission>(System::Security::Permissions::PermissionState::Unrestricted));
        nps->AddPermission(cli::gcnew<System::Security::Permissions::FileDialogPermission>(System::Security::Permissions::PermissionState::Unrestricted));
        nps->AddPermission(cli::gcnew<System::Security::Permissions::FileIOPermission>(System::Security::Permissions::PermissionState::Unrestricted));
        nps->AddPermission(cli::gcnew<System::Security::Permissions::IsolatedStorageFilePermission>(System::Security::Permissions::PermissionState::Unrestricted));
        nps->AddPermission(cli::gcnew<System::Security::Permissions::ReflectionPermission>(System::Security::Permissions::PermissionState::Unrestricted));
        nps->AddPermission(cli::gcnew<System::Security::Permissions::RegistryPermission>(System::Security::Permissions::PermissionState::Unrestricted));
        nps->AddPermission(cli::gcnew<System::Security::Permissions::KeyContainerPermission>(System::Security::Permissions::PermissionState::Unrestricted));
        System::Security::Permissions::SecurityPermissionFlag spf = System::Security::Permissions::SecurityPermissionFlag::AllFlags;
        (spf = (System::Security::Permissions::SecurityPermissionFlag)(((int32_t)(spf) & -5)));
        nps->AddPermission(cli::gcnew<System::Security::Permissions::SecurityPermission>(spf));
        nps->AddPermission(cli::gcnew<System::Security::Permissions::UIPermission>(System::Security::Permissions::PermissionState::Unrestricted));
        nps->AddPermission(System::Security::PermissionBuilder::Create(_T("System.Net.DnsPermission, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"), System::Security::Permissions::PermissionState::Unrestricted));
        nps->AddPermission(System::Security::PermissionBuilder::Create(_T("System.Drawing.Printing.PrintingPermission, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"), System::Security::Permissions::PermissionState::Unrestricted));
        nps->AddPermission(System::Security::PermissionBuilder::Create(_T("System.Diagnostics.EventLogPermission, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"), System::Security::Permissions::PermissionState::Unrestricted));
        nps->AddPermission(System::Security::PermissionBuilder::Create(_T("System.Net.SocketPermission, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"), System::Security::Permissions::PermissionState::Unrestricted));
        nps->AddPermission(System::Security::PermissionBuilder::Create(_T("System.Net.WebPermission, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"), System::Security::Permissions::PermissionState::Unrestricted));
        nps->AddPermission(System::Security::PermissionBuilder::Create(_T("System.Diagnostics.PerformanceCounterPermission, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"), System::Security::Permissions::PermissionState::Unrestricted));
        nps->AddPermission(System::Security::PermissionBuilder::Create(_T("System.DirectoryServices.DirectoryServicesPermission, System.DirectoryServices, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"), System::Security::Permissions::PermissionState::Unrestricted));
        nps->AddPermission(System::Security::PermissionBuilder::Create(_T("System.Messaging.MessageQueuePermission, System.Messaging, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"), System::Security::Permissions::PermissionState::Unrestricted));
        nps->AddPermission(System::Security::PermissionBuilder::Create(_T("System.ServiceProcess.ServiceControllerPermission, System.ServiceProcess, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"), System::Security::Permissions::PermissionState::Unrestricted));
        nps->AddPermission(System::Security::PermissionBuilder::Create(_T("System.Data.OleDb.OleDbPermission, System.Data, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"), System::Security::Permissions::PermissionState::Unrestricted));
        nps->AddPermission(System::Security::PermissionBuilder::Create(_T("System.Data.SqlClient.SqlClientPermission, System.Data, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"), System::Security::Permissions::PermissionState::Unrestricted));
        return nps;
    }
    
    System::Security::SecurityElement* DefaultPolicies::PrintingPermission(System::String* level) {
        System::Security::SecurityElement *se = cli::gcnew<System::Security::SecurityElement>(_T("IPermission"));
        se->AddAttribute(_T("class"), _T("System.Drawing.Printing.PrintingPermission, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"));
        se->AddAttribute(_T("version"), _T("1"));
        se->AddAttribute(_T("Level"), level);
        return se;
    }
    
    System::Security::PermissionSet* DefaultPolicies::get_FullTrust() {
        if((_fullTrust ==  nullptr)) 
        {
            _fullTrust = BuildFullTrust();
        }
        return _fullTrust;
    }
    
    System::Security::PermissionSet* DefaultPolicies::get_LocalIntranet() {
        if((_localIntranet ==  nullptr)) 
        {
            _localIntranet = BuildLocalIntranet();
        }
        return _localIntranet;
    }
    
    System::Security::PermissionSet* DefaultPolicies::get_Internet() {
        if((_internet ==  nullptr)) 
        {
            _internet = BuildInternet();
        }
        return _internet;
    }
    
    System::Security::PermissionSet* DefaultPolicies::get_SkipVerification() {
        if((_skipVerification ==  nullptr)) 
        {
            _skipVerification = BuildSkipVerification();
        }
        return _skipVerification;
    }
    
    System::Security::PermissionSet* DefaultPolicies::get_Execution() {
        if((_execution ==  nullptr)) 
        {
            _execution = BuildExecution();
        }
        return _execution;
    }
    
    System::Security::PermissionSet* DefaultPolicies::get_Nothing() {
        if((_nothing ==  nullptr)) 
        {
            _nothing = BuildNothing();
        }
        return _nothing;
    }
    
    System::Security::PermissionSet* DefaultPolicies::get_Everything() {
        if((_everything ==  nullptr)) 
        {
            _everything = BuildEverything();
        }
        return _everything;
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    
    
    void DomainApplicationMembershipCondition::constructor() {
    }
    
    bool DomainApplicationMembershipCondition::Check(Evidence* evidence) {
        return false;
    }
    
    IMembershipCondition* DomainApplicationMembershipCondition::Copy() {
        return cli::gcnew<DomainApplicationMembershipCondition>();
    }
    
    bool DomainApplicationMembershipCondition::Equals_ed975d2f4a7d193e(System::Object* o) {
        return cli::is<DomainApplicationMembershipCondition>(o);
    }
    
    void DomainApplicationMembershipCondition::FromXml(System::Security::SecurityElement* e) {
        FromXml2(e, nullptr);
    }
    
    void DomainApplicationMembershipCondition::FromXml2(System::Security::SecurityElement* e, PolicyLevel* level) {
        MembershipConditionHelper::CheckSecurityElement(e, _T("e"), this->version, this->version);
    }
    
    int32_t DomainApplicationMembershipCondition::GetHashCode_6648aef0f235ee6c() {
        return -1;
    }
    
    System::String* DomainApplicationMembershipCondition::ToString_1636a0751cb9ac11() {
        System::ActivationContext *ac = System::AppDomain::get_CurrentDomain()->get_ActivationContext();
        if((ac ==  nullptr)) 
        {
            return _T("Domain");
        }
         else 
        {
            return cli::concat(_T("Domain - "), ac->get_Identity()->get_FullName());
        }
    }
    
    System::Security::SecurityElement* DomainApplicationMembershipCondition::ToXml() {
        return ToXml2(nullptr);
    }
    
    System::Security::SecurityElement* DomainApplicationMembershipCondition::ToXml2(PolicyLevel* level) {
        System::Security::SecurityElement *se = MembershipConditionHelper::Element2(cli::typeof<System::Type>::info, this->version);
        return se;
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    
    
    void EvidenceEnumerator::constructor(System::Collections::IEnumerator* hostenum, System::Collections::IEnumerator* assemblyenum) {
        this->hostEnum = hostenum;
        this->assemblyEnum = assemblyenum;
        this->currentEnum = this->hostEnum;
    }
    
    bool EvidenceEnumerator::MoveNext() {
        if((this->currentEnum ==  nullptr)) 
        {
            return false;
        }
        bool ret = this->currentEnum->MoveNext_4e78e145935f5417();
        if(((!(ret) && (this->hostEnum ==  this->currentEnum)) && (this->assemblyEnum != nullptr))) 
        {
            this->currentEnum = this->assemblyEnum;
            ret = this->assemblyEnum->MoveNext_4e78e145935f5417();
        }
        return ret;
    }
    
    void EvidenceEnumerator::Reset() {
        if((this->hostEnum != nullptr)) 
        {
            this->hostEnum->Reset_bcd82381eed41868();
            this->currentEnum = this->hostEnum;
        }
         else 
        {
            this->currentEnum = this->assemblyEnum;
        }
        if((this->assemblyEnum != nullptr)) 
        {
            this->assemblyEnum->Reset_bcd82381eed41868();
        }
    }
    
    System::Object* EvidenceEnumerator::get_Current() {
        return this->currentEnum->get_Current_8eca9b3da02b123a();
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    
    
    void Evidence::constructor() {
    }
    
    void Evidence::constructor(Evidence* evidence) {
        if((evidence != nullptr)) 
        {
            Merge(evidence);
        }
    }
    
    void Evidence::constructor(cli::array<System::Object*>* hostEvidence, cli::array<System::Object*>* assemblyEvidence) {
        if((hostEvidence != nullptr)) 
        {
            this->get_HostEvidenceList()->AddRange_a8bb4db32a72ffe(hostEvidence);
        }
        if((assemblyEvidence != nullptr)) 
        {
            this->get_AssemblyEvidenceList()->AddRange_a8bb4db32a72ffe(assemblyEvidence);
        }
    }
    
    void Evidence::AddAssembly(System::Object* id) {
        this->get_AssemblyEvidenceList()->Add_e6a92085999ce388(id);
        this->_hashCode = 0;
    }
    
    void Evidence::AddHost(System::Object* id) {
        if((this->_locked && System::Security::SecurityManager::get_SecurityEnabled())) 
        {
            cli::gcnew<System::Security::Permissions::SecurityPermission>(System::Security::Permissions::SecurityPermissionFlag::ControlEvidence)->Demand();
        }
        this->get_HostEvidenceList()->Add_e6a92085999ce388(id);
        this->_hashCode = 0;
    }
    
    void Evidence::Clear() {
        if((this->hostEvidenceList != nullptr)) 
        {
            this->hostEvidenceList->Clear_cd6654e5a40f5056();
        }
        if((this->assemblyEvidenceList != nullptr)) 
        {
            this->assemblyEvidenceList->Clear_cd6654e5a40f5056();
        }
        this->_hashCode = 0;
    }
    
    void Evidence::CopyTo(System::Array* array, int32_t index) {
        int32_t hc = 0;
        if((this->hostEvidenceList != nullptr)) 
        {
            hc = this->hostEvidenceList->get_Count_2354963792616712();
            if((hc > 0)) 
            {
                this->hostEvidenceList->CopyTo_2bc540dad3c25b9e(array, index);
            }
        }
        if(((this->assemblyEvidenceList != nullptr) && (this->assemblyEvidenceList->get_Count_2354963792616712() > 0))) 
        {
            this->assemblyEvidenceList->CopyTo_2bc540dad3c25b9e(array, (index + hc));
        }
    }
    
    bool Evidence::Equals_ed975d2f4a7d193e(System::Object* obj) {
        if((obj ==  nullptr)) 
        {
            return false;
        }
        Evidence *e = cli::as<Evidence*>(obj);
        if((e ==  nullptr)) 
        {
            return false;
        }
        if((this->get_HostEvidenceList()->get_Count_2354963792616712() != e->get_HostEvidenceList()->get_Count_2354963792616712())) 
        {
            return false;
        }
        if((this->get_AssemblyEvidenceList()->get_Count_2354963792616712() != e->get_AssemblyEvidenceList()->get_Count_2354963792616712())) 
        {
            return false;
        }
        for(int32_t i = 0; (i < this->hostEvidenceList->get_Count_2354963792616712()); i++){
            bool found = false;
            for(int32_t j = 0; (j < e->hostEvidenceList->get_Count_2354963792616712()); i++){
                if(this->hostEvidenceList->get_Item_fd0155f142ae570(i)->Equals_ed975d2f4a7d193e(e->hostEvidenceList->get_Item_fd0155f142ae570(j))) 
                {
                    found = true;
                    break;
                }
            }
            if(!(found)) 
            {
                return false;
            }
        }
        for(int32_t i = 0; (i < this->assemblyEvidenceList->get_Count_2354963792616712()); i++){
            bool found = false;
            for(int32_t j = 0; (j < e->assemblyEvidenceList->get_Count_2354963792616712()); i++){
                if(this->assemblyEvidenceList->get_Item_fd0155f142ae570(i)->Equals_ed975d2f4a7d193e(e->assemblyEvidenceList->get_Item_fd0155f142ae570(j))) 
                {
                    found = true;
                    break;
                }
            }
            if(!(found)) 
            {
                return false;
            }
        }
        return true;
    }
    
    System::Collections::IEnumerator* Evidence::GetEnumerator() {
        System::Collections::IEnumerator *he = nullptr;
        if((this->hostEvidenceList != nullptr)) 
        {
            he = this->hostEvidenceList->GetEnumerator_84e3ba8f2fdefd62();
        }
        System::Collections::IEnumerator *ae = nullptr;
        if((this->assemblyEvidenceList != nullptr)) 
        {
            ae = this->assemblyEvidenceList->GetEnumerator_84e3ba8f2fdefd62();
        }
        return cli::gcnew<EvidenceEnumerator>(he, ae);
    }
    
    System::Collections::IEnumerator* Evidence::GetAssemblyEnumerator() {
        return this->get_AssemblyEvidenceList()->GetEnumerator_84e3ba8f2fdefd62();
    }
    
    int32_t Evidence::GetHashCode_6648aef0f235ee6c() {
        if((this->_hashCode ==  0)) 
        {
            if((this->hostEvidenceList != nullptr)) 
            {
                for(int32_t i = 0; (i < this->hostEvidenceList->get_Count_2354963792616712()); i++) {
                    (this->_hashCode = this->_hashCode ^ this->hostEvidenceList->get_Item_fd0155f142ae570(i)->GetHashCode_6648aef0f235ee6c());
                }
            }
            if((this->assemblyEvidenceList != nullptr)) 
            {
                for(int32_t i = 0; (i < this->assemblyEvidenceList->get_Count_2354963792616712()); i++) {
                    (this->_hashCode = this->_hashCode ^ this->assemblyEvidenceList->get_Item_fd0155f142ae570(i)->GetHashCode_6648aef0f235ee6c());
                }
            }
        }
        return this->_hashCode;
    }
    
    System::Collections::IEnumerator* Evidence::GetHostEnumerator() {
        return this->get_HostEvidenceList()->GetEnumerator_84e3ba8f2fdefd62();
    }
    
    void Evidence::Merge(Evidence* evidence) {
        if(((evidence != nullptr) && (evidence->get_Count() > 0))) 
        {
            if((evidence->hostEvidenceList != nullptr)) 
            {
                for(auto tmp_590 : evidence->hostEvidenceList) {
                    auto o = cli::cast<System::Object*>(tmp_590);
                    AddHost(o);
                }
            }
            if((evidence->assemblyEvidenceList != nullptr)) 
            {
                for(auto tmp_591 : evidence->assemblyEvidenceList) {
                    auto o = cli::cast<System::Object*>(tmp_591);
                    AddAssembly(o);
                }
            }
            this->_hashCode = 0;
        }
    }
    
    void Evidence::RemoveType(System::Type* t) {
        for(int32_t i = this->hostEvidenceList->get_Count_2354963792616712(); (i >= 0); i--){
            if(System::Type::op_Equality2(this->hostEvidenceList->GetType(), t)) 
            {
                this->hostEvidenceList->RemoveAt_2abea768d3273318(i);
                this->_hashCode = 0;
            }
        }
        for(int32_t i = this->assemblyEvidenceList->get_Count_2354963792616712(); (i >= 0); i--){
            if(System::Type::op_Equality2(this->assemblyEvidenceList->GetType(), t)) 
            {
                this->assemblyEvidenceList->RemoveAt_2abea768d3273318(i);
                this->_hashCode = 0;
            }
        }
    }
    
    bool Evidence::IsAuthenticodePresent(System::Reflection::Assembly* a) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    Evidence* Evidence::GetDefaultHostEvidence(System::Reflection::Assembly* a) {
        Evidence *e = cli::gcnew<Evidence>();
        System::String *aname = a->get_EscapedCodeBase_2cc20f2402d62395();
        e->AddHost(Zone::CreateFromUrl(aname));
        e->AddHost(cli::gcnew<Url>(aname));
        e->AddHost(cli::gcnew<Hash>(a));
        if((System::String::Compare6(_T("FILE://"), 0, aname, 0, 7, true, System::Globalization::CultureInfo::get_InvariantCulture()) != 0)) 
        {
            e->AddHost(Site::CreateFromUrl(aname));
        }
        System::Reflection::AssemblyName *an = a->UnprotectedGetName_b11b135b2412c023();
        cli::array<unsigned char> *pk = an->GetPublicKey();
        if(((pk != nullptr) && (pk->get_Length() > 0))) 
        {
            System::Security::Permissions::StrongNamePublicKeyBlob *blob = cli::gcnew<System::Security::Permissions::StrongNamePublicKeyBlob>(pk);
            e->AddHost(cli::gcnew<StrongName2>(blob, an->get_Name(), an->get_Version()));
        }
        if(IsAuthenticodePresent(a)) 
        {
            Mono::Security::Authenticode::AuthenticodeDeformatter *ad = cli::gcnew<Mono::Security::Authenticode::AuthenticodeDeformatter>(a->get_Location_3a7779d7eb72fa50());
            if((ad->get_SigningCertificate() != nullptr)) 
            {
                System::Security::Cryptography::X509Certificates::X509Certificate2 *x509 = cli::gcnew<System::Security::Cryptography::X509Certificates::X509Certificate2>(ad->get_SigningCertificate()->get_RawData_c0a18e988d76611c());
                if((x509->GetHashCode_6648aef0f235ee6c() != 0)) 
                {
                    e->AddHost(cli::gcnew<Publisher>(x509));
                }
            }
        }
        if(a->get_GlobalAssemblyCache_db80d4f5ee2824e7()) 
        {
            e->AddHost(cli::gcnew<GacInstalled>());
        }
        System::AppDomainManager *dommgr = System::AppDomain::get_CurrentDomain()->get_DomainManager();
        if((dommgr != nullptr)) 
        {
            if(((int32_t)(((int32_t)(dommgr->get_HostSecurityManager_78a0d9527aa5ded3()->get_Flags_b631cff0eaaa13d7()) & 4)) ==  4)) 
            {
                e = dommgr->get_HostSecurityManager_78a0d9527aa5ded3()->ProvideAssemblyEvidence_152b6b2161b9f01c(a, e);
            }
        }
        return e;
    }
    
    int32_t Evidence::get_Count() {
        int32_t count = 0;
        if((this->hostEvidenceList != nullptr)) 
        {
            (count = count + this->hostEvidenceList->get_Count_2354963792616712());
        }
        if((this->assemblyEvidenceList != nullptr)) 
        {
            (count = count + this->assemblyEvidenceList->get_Count_2354963792616712());
        }
        return count;
    }
    
    bool Evidence::get_IsReadOnly() {
        return false;
    }
    
    bool Evidence::get_IsSynchronized() {
        return false;
    }
    
    bool Evidence::get_Locked() {
        return this->_locked;
    }
    
    bool Evidence::set_Locked(bool value) {
        this->_locked = value;
        return get_Locked();
    }
    
    System::Object* Evidence::get_SyncRoot() {
        return this;
    }
    
    System::Collections::ArrayList* Evidence::get_HostEvidenceList() {
        if((this->hostEvidenceList ==  nullptr)) 
        {
            this->hostEvidenceList = System::Collections::ArrayList::Synchronized(cli::gcnew<System::Collections::ArrayList>());
        }
        return this->hostEvidenceList;
    }
    
    System::Collections::ArrayList* Evidence::get_AssemblyEvidenceList() {
        if((this->assemblyEvidenceList ==  nullptr)) 
        {
            this->assemblyEvidenceList = System::Collections::ArrayList::Synchronized(cli::gcnew<System::Collections::ArrayList>());
        }
        return this->assemblyEvidenceList;
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    
    
    void FileCodeGroup::constructor(IMembershipCondition* membershipCondition, System::Security::Permissions::FileIOPermissionAccess access) {
        this->m_access = access;
    }
    
    void FileCodeGroup::constructor(System::Security::SecurityElement* e, PolicyLevel* level) {
    }
    
    CodeGroup* FileCodeGroup::Copy_7fdc78f7390869fe() {
        FileCodeGroup *copy = cli::gcnew<FileCodeGroup>(this->get_MembershipCondition(), this->m_access);
        copy->set_Name(this->get_Name());
        copy->set_Description(this->get_Description());
        for(auto tmp_592 : this->get_Children()) {
            auto child = cli::cast<CodeGroup*>(tmp_592);
            {
                copy->AddChild(child->Copy_7fdc78f7390869fe());
            }
        }
        return copy;
    }
    
    PolicyStatement* FileCodeGroup::Resolve_e0385e713d5ae5af(Evidence* evidence) {
        if((evidence ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("evidence"));
        }
        if(!(this->get_MembershipCondition()->Check_40359438a47300d0(evidence))) 
        {
            return nullptr;
        }
        System::Security::PermissionSet *ps = nullptr;
        if((this->get_PolicyStatement() ==  nullptr)) 
        {
            ps = cli::gcnew<System::Security::PermissionSet>(System::Security::Permissions::PermissionState::None);
        }
         else 
        {
            ps = this->get_PolicyStatement()->get_PermissionSet()->Copy_cfeae72b3c523c4e();
        }
        if((this->get_Children()->get_Count_8f254f3dd8e2403() > 0)) 
        {
            for(auto tmp_593 : this->get_Children()) {
                auto child_cg = cli::cast<CodeGroup*>(tmp_593);
                {
                    PolicyStatement *child_pst = child_cg->Resolve_e0385e713d5ae5af(evidence);
                    if((child_pst != nullptr)) 
                    {
                        ps = ps->Union(child_pst->get_PermissionSet());
                    }
                }
            }
        }
        PolicyStatement *pst = nullptr;
        if((this->get_PolicyStatement() != nullptr)) 
        {
            pst = this->get_PolicyStatement()->Copy();
        }
         else 
        {
            pst = PolicyStatement::Empty();
        }
        pst->set_PermissionSet(ps);
        return pst;
    }
    
    CodeGroup* FileCodeGroup::ResolveMatchingCodeGroups_908cc5caa682e9f4(Evidence* evidence) {
        if((evidence ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("evidence"));
        }
        if(!(this->get_MembershipCondition()->Check_40359438a47300d0(evidence))) 
        {
            return nullptr;
        }
        FileCodeGroup *matchRoot = cli::gcnew<FileCodeGroup>(this->get_MembershipCondition(), this->m_access);
        for(auto tmp_594 : this->get_Children()) {
            auto child = cli::cast<CodeGroup*>(tmp_594);
            {
                CodeGroup *childMatchingCodeGroup = child->ResolveMatchingCodeGroups_908cc5caa682e9f4(evidence);
                if((childMatchingCodeGroup != nullptr)) 
                {
                    matchRoot->AddChild(childMatchingCodeGroup);
                }
            }
        }
        return matchRoot;
    }
    
    bool FileCodeGroup::Equals_ed975d2f4a7d193e(System::Object* o) {
        if(!(cli::is<FileCodeGroup>(o))) 
        {
            return false;
        }
        if(((int32_t)(this->m_access) != (int32_t)(cli::cast<FileCodeGroup*>(o)->m_access))) 
        {
            return false;
        }
        return CodeGroup::Equals4(cli::cast<CodeGroup*>(o), false);
    }
    
    int32_t FileCodeGroup::GetHashCode_6648aef0f235ee6c() {
        return cli::import(this->m_access)->GetHashCode_6648aef0f235ee6c();
    }
    
    void FileCodeGroup::ParseXml_ecb12c827959aa39(System::Security::SecurityElement* e, PolicyLevel* level) {
        System::String *a = e->Attribute2(_T("Access"));
        if((a != nullptr)) 
        {
            this->m_access = cli::unbox<System::Security::Permissions::FileIOPermissionAccess>(System::Enum::Parse2(cli::typeof<System::Type>::info, a, true));
        }
         else 
        {
            this->m_access = System::Security::Permissions::FileIOPermissionAccess::NoAccess;
        }
    }
    
    void FileCodeGroup::CreateXml_14eb36ca74574a81(System::Security::SecurityElement* element, PolicyLevel* level) {
        element->AddAttribute(_T("Access"), cli::import(this->m_access)->ToString_1636a0751cb9ac11());
    }
    
    System::String* FileCodeGroup::get_MergeLogic_cd001da1f3850530() {
        return _T("Union");
    }
    
    System::String* FileCodeGroup::get_AttributeString_f768971bd5bbaf63() {
        return nullptr;
    }
    
    System::String* FileCodeGroup::get_PermissionSetName_4d6dd01cf3ccc2f3() {
        return cli::concat(_T("Same directory FileIO - "), cli::import(this->m_access)->ToString_1636a0751cb9ac11());
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    
    
    void FirstMatchCodeGroup::constructor(IMembershipCondition* membershipCondition, PolicyStatement* policy) {
    }
    
    void FirstMatchCodeGroup::constructor(System::Security::SecurityElement* e, PolicyLevel* level) {
    }
    
    CodeGroup* FirstMatchCodeGroup::Copy_7fdc78f7390869fe() {
        FirstMatchCodeGroup *copy = CopyNoChildren();
        for(auto tmp_595 : this->get_Children()) {
            auto child = cli::cast<CodeGroup*>(tmp_595);
            {
                copy->AddChild(child->Copy_7fdc78f7390869fe());
            }
        }
        return copy;
    }
    
    PolicyStatement* FirstMatchCodeGroup::Resolve_e0385e713d5ae5af(Evidence* evidence) {
        if((evidence ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("evidence"));
        }
        if(!(this->get_MembershipCondition()->Check_40359438a47300d0(evidence))) 
        {
            return nullptr;
        }
        for(auto tmp_596 : this->get_Children()) {
            auto child = cli::cast<CodeGroup*>(tmp_596);
            {
                PolicyStatement *policy = child->Resolve_e0385e713d5ae5af(evidence);
                if((policy != nullptr)) 
                {
                    return policy;
                }
            }
        }
        return this->get_PolicyStatement();
    }
    
    CodeGroup* FirstMatchCodeGroup::ResolveMatchingCodeGroups_908cc5caa682e9f4(Evidence* evidence) {
        if((evidence ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("evidence"));
        }
        if(!(this->get_MembershipCondition()->Check_40359438a47300d0(evidence))) 
        {
            return nullptr;
        }
        for(auto tmp_597 : this->get_Children()) {
            auto child = cli::cast<CodeGroup*>(tmp_597);
            {
                if((child->Resolve_e0385e713d5ae5af(evidence) != nullptr)) 
                {
                    return child->Copy_7fdc78f7390869fe();
                }
            }
        }
        return this->CopyNoChildren();
    }
    
    FirstMatchCodeGroup* FirstMatchCodeGroup::CopyNoChildren() {
        FirstMatchCodeGroup *copy = cli::gcnew<FirstMatchCodeGroup>(this->get_MembershipCondition(), this->get_PolicyStatement());
        copy->set_Name(this->get_Name());
        copy->set_Description(this->get_Description());
        return copy;
    }
    
    System::String* FirstMatchCodeGroup::get_MergeLogic_cd001da1f3850530() {
        return _T("First Match");
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    
    
    void GacInstalled::constructor() {
    }
    
    System::Object* GacInstalled::Copy() {
        return cli::cast<System::Object*>(cli::gcnew<GacInstalled>());
    }
    
    System::Security::IPermission* GacInstalled::CreateIdentityPermission(Evidence* evidence) {
        return cli::gcnew<System::Security::Permissions::GacIdentityPermission>();
    }
    
    bool GacInstalled::Equals_ed975d2f4a7d193e(System::Object* o) {
        if((o ==  nullptr)) 
        {
            return false;
        }
        return cli::is<GacInstalled>(o);
    }
    
    int32_t GacInstalled::GetHashCode_6648aef0f235ee6c() {
        return 0;
    }
    
    System::String* GacInstalled::ToString_1636a0751cb9ac11() {
        System::Security::SecurityElement *se = cli::gcnew<System::Security::SecurityElement>(System::Object::GetType()->get_FullName_7e8fa72ba225e1a4());
        se->AddAttribute(_T("version"), _T("1"));
        return se->ToString_1636a0751cb9ac11();
    }
    
    int32_t GacInstalled::GetRequiredSize(bool verbose) {
        return 1;
    }
    
    int32_t GacInstalled::InitFromBuffer(cli::array<char16_t>* buffer, int32_t position) {
        return position;
    }
    
    int32_t GacInstalled::OutputToBuffer(cli::array<char16_t>* buffer, int32_t position, bool verbose) {
        buffer->at(position) = u'\x9';
        return (position + 1);
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    
    
    void GacMembershipCondition::constructor() {
    }
    
    bool GacMembershipCondition::Check(Evidence* evidence) {
        if((evidence ==  nullptr)) 
        {
            return false;
        }
        System::Collections::IEnumerator *e = evidence->GetHostEnumerator();
        while(e->MoveNext_4e78e145935f5417()) {
            if(cli::is<GacInstalled>(e->get_Current_8eca9b3da02b123a())) 
            {
                return true;
            }
        }
        return false;
    }
    
    IMembershipCondition* GacMembershipCondition::Copy() {
        return cli::gcnew<GacMembershipCondition>();
    }
    
    bool GacMembershipCondition::Equals_ed975d2f4a7d193e(System::Object* o) {
        if((o ==  nullptr)) 
        {
            return false;
        }
        return cli::is<GacMembershipCondition>(o);
    }
    
    void GacMembershipCondition::FromXml(System::Security::SecurityElement* e) {
        FromXml2(e, nullptr);
    }
    
    void GacMembershipCondition::FromXml2(System::Security::SecurityElement* e, PolicyLevel* level) {
        MembershipConditionHelper::CheckSecurityElement(e, _T("e"), this->version, this->version);
    }
    
    int32_t GacMembershipCondition::GetHashCode_6648aef0f235ee6c() {
        return 0;
    }
    
    System::String* GacMembershipCondition::ToString_1636a0751cb9ac11() {
        return _T("GAC");
    }
    
    System::Security::SecurityElement* GacMembershipCondition::ToXml() {
        return ToXml2(nullptr);
    }
    
    System::Security::SecurityElement* GacMembershipCondition::ToXml2(PolicyLevel* level) {
        System::Security::SecurityElement *se = MembershipConditionHelper::Element2(cli::typeof<System::Type>::info, this->version);
        return se;
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    
    
    void Hash::constructor(System::Reflection::Assembly* assembly) {
        if(System::Reflection::Assembly::op_Equality(assembly, nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("assembly"));
        }
        this->assembly = assembly;
    }
    
    void Hash::constructor() {
    }
    
    void Hash::constructor(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        this->data = cli::cast<cli::array<unsigned char>*>(info->GetValue(_T("RawData"), cli::typeof<System::Type>::info));
    }
    
    cli::array<unsigned char>* Hash::GenerateHash(System::Security::Cryptography::HashAlgorithm* hashAlg) {
        if((hashAlg ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("hashAlg"));
        }
        return hashAlg->ComputeHash(GetData());
    }
    
    void Hash::GetObjectData(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        if((info ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("info"));
        }
        info->AddValue16(_T("RawData"), GetData());
    }
    
    System::String* Hash::ToString_1636a0751cb9ac11() {
        System::Security::SecurityElement *se = cli::gcnew<System::Security::SecurityElement>(System::Object::GetType()->get_FullName_7e8fa72ba225e1a4());
        se->AddAttribute(_T("version"), _T("1"));
        System::Text::StringBuilder *sb = cli::gcnew<System::Text::StringBuilder>();
        cli::array<unsigned char> *raw = GetData();
        for(int32_t i = 0; (i < raw->get_Length()); i++) {
            sb->Append2(cli::import(raw->at(i))->ToString3(_T("X2")));
        }
        se->AddChild(cli::gcnew<System::Security::SecurityElement>(_T("RawData"), sb->ToString_1636a0751cb9ac11()));
        return se->ToString_1636a0751cb9ac11();
    }
    
    cli::array<unsigned char>* Hash::GetData() {
        if((System::Reflection::Assembly::op_Equality(this->assembly, nullptr) && (this->data ==  nullptr))) 
        {
            System::String *msg = Locale::GetText(_T("No assembly data."));
            throw cli::gcnew<System::Security::SecurityException>(msg);
        }
        if((this->data ==  nullptr)) 
        {
            System::IO::FileStream *stream = cli::gcnew<System::IO::FileStream>(this->assembly->get_Location_3a7779d7eb72fa50(), System::IO::FileMode::Open, System::IO::FileAccess::Read);
            this->data = (new cli::array<unsigned char>((int32_t)stream->get_Length_ddb8b0d061db5350()));
            stream->Read_c0d6dde3943b413e(this->data, 0, (int32_t)stream->get_Length_ddb8b0d061db5350());
        }
        return this->data;
    }
    
    int32_t Hash::GetRequiredSize(bool verbose) {
        return verbose ? 5 : 0;
    }
    
    int32_t Hash::InitFromBuffer(cli::array<char16_t>* buffer, int32_t position) {
        return 0;
    }
    
    int32_t Hash::OutputToBuffer(cli::array<char16_t>* buffer, int32_t position, bool verbose) {
        return 0;
    }
    
    Hash* Hash::CreateMD5(cli::array<unsigned char>* md5) {
        if((md5 ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("md5"));
        }
        Hash *h = cli::gcnew<Hash>();
        h->_md5 = md5;
        return h;
    }
    
    Hash* Hash::CreateSHA1(cli::array<unsigned char>* sha1) {
        if((sha1 ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("sha1"));
        }
        Hash *h = cli::gcnew<Hash>();
        h->_sha1 = sha1;
        return h;
    }
    
    cli::array<unsigned char>* Hash::get_MD5() {
        if((this->_md5 != nullptr)) 
        {
            return this->_md5;
        }
        if((System::Reflection::Assembly::op_Equality(this->assembly, nullptr) && (this->_sha1 != nullptr))) 
        {
            System::String *msg = Locale::GetText(_T("No assembly data. This instance was initialized with an MSHA1 digest value."));
            throw cli::gcnew<System::Security::SecurityException>(msg);
        }
        System::Security::Cryptography::HashAlgorithm *hash = System::Security::Cryptography::MD5::Create3();
        this->_md5 = GenerateHash(hash);
        return this->_md5;
    }
    
    cli::array<unsigned char>* Hash::get_SHA1() {
        if((this->_sha1 != nullptr)) 
        {
            return this->_sha1;
        }
        if((System::Reflection::Assembly::op_Equality(this->assembly, nullptr) && (this->_md5 != nullptr))) 
        {
            System::String *msg = Locale::GetText(_T("No assembly data. This instance was initialized with an MD5 digest value."));
            throw cli::gcnew<System::Security::SecurityException>(msg);
        }
        System::Security::Cryptography::HashAlgorithm *hash = System::Security::Cryptography::SHA1::Create3();
        this->_sha1 = GenerateHash(hash);
        return this->_sha1;
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    
    
    void HashMembershipCondition::constructor() {
    }
    
    void HashMembershipCondition::constructor(System::Security::Cryptography::HashAlgorithm* hashAlg, cli::array<unsigned char>* value) {
        if((hashAlg ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("hashAlg"));
        }
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("value"));
        }
        this->hash_algorithm = hashAlg;
        this->hash_value = cli::cast<cli::array<unsigned char>*>(cli::import(value)->Clone());
    }
    
    bool HashMembershipCondition::Check(Evidence* evidence) {
        if((evidence ==  nullptr)) 
        {
            return false;
        }
        System::Collections::IEnumerator *e = evidence->GetHostEnumerator();
        while(e->MoveNext_4e78e145935f5417()) {
            Hash *hash = cli::as<Hash*>(e->get_Current_8eca9b3da02b123a());
            if((hash ==  nullptr)) 
            {
                continue;
            }
            if(Compare(this->hash_value, hash->GenerateHash(this->hash_algorithm))) 
            {
                return true;
            }
            break;
        }
        return false;
    }
    
    IMembershipCondition* HashMembershipCondition::Copy() {
        return cli::gcnew<HashMembershipCondition>(this->hash_algorithm, this->hash_value);
    }
    
    bool HashMembershipCondition::Equals_ed975d2f4a7d193e(System::Object* o) {
        HashMembershipCondition *other = cli::as<HashMembershipCondition*>(o);
        if((other ==  nullptr)) 
        {
            return false;
        }
        return ((other->get_HashAlgorithm() ==  this->hash_algorithm) && Compare(this->hash_value, other->hash_value));
    }
    
    System::Security::SecurityElement* HashMembershipCondition::ToXml() {
        return ToXml2(nullptr);
    }
    
    System::Security::SecurityElement* HashMembershipCondition::ToXml2(PolicyLevel* level) {
        System::Security::SecurityElement *se = MembershipConditionHelper::Element2(cli::typeof<System::Type>::info, this->version);
        se->AddAttribute(_T("HashValue"), Mono::Security::Cryptography::CryptoConvert::ToHex(this->get_HashValue()));
        se->AddAttribute(_T("HashAlgorithm"), this->hash_algorithm->GetType()->get_FullName_7e8fa72ba225e1a4());
        return se;
    }
    
    void HashMembershipCondition::FromXml(System::Security::SecurityElement* e) {
        FromXml2(e, nullptr);
    }
    
    void HashMembershipCondition::FromXml2(System::Security::SecurityElement* e, PolicyLevel* level) {
        MembershipConditionHelper::CheckSecurityElement(e, _T("e"), this->version, this->version);
        this->hash_value = Mono::Security::Cryptography::CryptoConvert::FromHex(e->Attribute2(_T("HashValue")));
        System::String *algorithm = e->Attribute2(_T("HashAlgorithm"));
        this->hash_algorithm = (algorithm ==  nullptr) ? nullptr : System::Security::Cryptography::HashAlgorithm::Create2(algorithm);
    }
    
    int32_t HashMembershipCondition::GetHashCode_6648aef0f235ee6c() {
        int32_t code = this->hash_algorithm->GetType()->GetHashCode_6648aef0f235ee6c();
        if((this->hash_value != nullptr)) 
        {
            for(auto tmp_598 : this->hash_value) {
                auto b = cli::cast<unsigned char>(tmp_598);
                {
                    (code = code ^ (int32_t)(b));
                }
            }
        }
        return code;
    }
    
    System::String* HashMembershipCondition::ToString_1636a0751cb9ac11() {
        System::Type *alg_type = this->get_HashAlgorithm()->GetType();
        return System::String::Format4(_T("Hash - {0} {1} = {2}"), alg_type->get_FullName_7e8fa72ba225e1a4(), alg_type->get_Assembly_3aae0acbf2a6d696(), Mono::Security::Cryptography::CryptoConvert::ToHex(this->get_HashValue()));
    }
    
    bool HashMembershipCondition::Compare(cli::array<unsigned char>* expected, cli::array<unsigned char>* actual) {
        if((expected->get_Length() != actual->get_Length())) 
        {
            return false;
        }
        int32_t len = expected->get_Length();
        for(int32_t i = 0; (i < len); i++){
            if(((int32_t)(expected->at(i)) != (int32_t)(actual->at(i)))) 
            {
                return false;
            }
        }
        return true;
    }
    
    void HashMembershipCondition::OnDeserialization(System::Object* sender) {
    }
    
    void HashMembershipCondition::GetObjectData(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
    }
    
    System::Security::Cryptography::HashAlgorithm* HashMembershipCondition::get_HashAlgorithm() {
        if((this->hash_algorithm ==  nullptr)) 
        {
            this->hash_algorithm = cli::gcnew<System::Security::Cryptography::SHA1Managed>();
        }
        return this->hash_algorithm;
    }
    
    System::Security::Cryptography::HashAlgorithm* HashMembershipCondition::set_HashAlgorithm(System::Security::Cryptography::HashAlgorithm* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("HashAlgorithm"));
        }
        this->hash_algorithm = value;
        return get_HashAlgorithm();
    }
    
    cli::array<unsigned char>* HashMembershipCondition::get_HashValue() {
        if((this->hash_value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentException>(Locale::GetText(_T("No HashValue available.")));
        }
        return cli::cast<cli::array<unsigned char>*>(cli::import(this->hash_value)->Clone());
    }
    
    cli::array<unsigned char>* HashMembershipCondition::set_HashValue(cli::array<unsigned char>* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("HashValue"));
        }
        this->hash_value = cli::cast<cli::array<unsigned char>*>(cli::import(value)->Clone());
        return get_HashValue();
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    
    System::String*  MembershipConditionHelper::XmlTag;
    
    MembershipConditionHelper::MembershipConditionHelper()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void MembershipConditionHelper::constructor() {
    }
    
    void MembershipConditionHelper::static_constructor() {
    }
    
    int32_t MembershipConditionHelper::CheckSecurityElement(System::Security::SecurityElement* se, System::String* parameterName, int32_t minimumVersion, int32_t maximumVersion) {
        if((se ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(parameterName);
        }
        if(System::String::op_Inequality(se->get_Tag(), XmlTag)) 
        {
            System::String *msg = System::String::Format3(Locale::GetText(_T("Invalid tag {0}, expected {1}.")), se->get_Tag(), XmlTag);
            throw cli::gcnew<System::ArgumentException>(msg, parameterName);
        }
        int32_t version = minimumVersion;
        System::String *v = se->Attribute2(_T("version"));
        if((v != nullptr)) 
        {
            try {
                version = System::Int32::Parse5(v);
            }
            catch(System::Exception* e) {
                System::String *msg = Locale::GetText(_T("Couldn\'t parse version from \'{0}\'."));
                msg = System::String::Format2(msg, v);
                throw cli::gcnew<System::ArgumentException>(msg, parameterName, e);
            }
        }
        return version;
    }
    
    System::Security::SecurityElement* MembershipConditionHelper::Element2(System::Type* type, int32_t version) {
        System::Security::SecurityElement *se = cli::gcnew<System::Security::SecurityElement>(XmlTag);
        se->AddAttribute(_T("class"), cli::concat(type->get_FullName_7e8fa72ba225e1a4(), _T(", ")));
        se->AddAttribute(_T("version"), cli::import(version)->ToString_1636a0751cb9ac11());
        return se;
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    
    
    void MonoTrustManager::constructor() {
    }
    
    ApplicationTrust* MonoTrustManager::DetermineApplicationTrust(System::ActivationContext* activationContext, TrustManagerContext* context) {
        if((activationContext ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("activationContext"));
        }
        return nullptr;
    }
    
    void MonoTrustManager::FromXml(System::Security::SecurityElement* e) {
        if((e ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("e"));
        }
        if(System::String::op_Inequality(e->get_Tag(), _T("IApplicationTrustManager"))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("e"), Locale::GetText(_T("Invalid XML tag.")));
        }
    }
    
    System::Security::SecurityElement* MonoTrustManager::ToXml() {
        System::Security::SecurityElement *se = cli::gcnew<System::Security::SecurityElement>(_T("IApplicationTrustManager"));
        se->AddAttribute(_T("class"), cli::typeof<System::Type>::info->get_AssemblyQualifiedName_cea373c2171bd483());
        se->AddAttribute(_T("version"), _T("1"));
        return se;
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    
    System::String*  NetCodeGroup::AbsentOriginScheme;
    System::String*  NetCodeGroup::AnyOtherOriginScheme;
    
    NetCodeGroup::NetCodeGroup()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void NetCodeGroup::constructor(IMembershipCondition* membershipCondition) {
    }
    
    void NetCodeGroup::constructor(System::Security::SecurityElement* e, PolicyLevel* level) {
    }
    
    void NetCodeGroup::static_constructor() {
    }
    
    void NetCodeGroup::AddConnectAccess(System::String* originScheme, CodeConnectAccess* connectAccess) {
        if((originScheme ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("originScheme"));
        }
        if((System::String::op_Equality(originScheme, AbsentOriginScheme) && System::String::op_Equality(connectAccess->get_Scheme(), CodeConnectAccess::OriginScheme))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("connectAccess"), Locale::GetText(_T("Schema == CodeConnectAccess.OriginScheme")));
        }
        if(this->_rules->ContainsKey_5de2e202a0290d76(originScheme)) 
        {
            if((connectAccess != nullptr)) 
            {
                cli::array<CodeConnectAccess*> *existing = cli::cast<cli::array<CodeConnectAccess*>*>(this->_rules->get_Item_d75c6e706b965758(originScheme));
                cli::array<CodeConnectAccess*> *array = (new cli::array<CodeConnectAccess*>((existing->get_Length() + 1)));
                System::Array::Copy2(existing, 0, array, 0, existing->get_Length());
                array->at(existing->get_Length()) = connectAccess;
                this->_rules->set_Item_84c7e24d9caa09(originScheme, array);
            }
        }
         else 
        {
            cli::array<CodeConnectAccess*> *array = (new cli::array<CodeConnectAccess*>(1));
            array->at(0) = connectAccess;
            this->_rules->Add_3f7ab157bcb41156(originScheme, array);
        }
    }
    
    CodeGroup* NetCodeGroup::Copy_7fdc78f7390869fe() {
        NetCodeGroup *copy = cli::gcnew<NetCodeGroup>(this->get_MembershipCondition());
        copy->set_Name(this->get_Name());
        copy->set_Description(this->get_Description());
        copy->set_PolicyStatement(this->get_PolicyStatement());
        for(auto tmp_599 : this->get_Children()) {
            auto child = cli::cast<CodeGroup*>(tmp_599);
            {
                copy->AddChild(child->Copy_7fdc78f7390869fe());
            }
        }
        return copy;
    }
    
    bool NetCodeGroup::Equals(cli::array<CodeConnectAccess*>* rules1, cli::array<CodeConnectAccess*>* rules2) {
        for(int32_t i = 0; (i < rules1->get_Length()); i++){
            bool found = false;
            for(int32_t j = 0; (j < rules2->get_Length()); j++){
                if(rules1->at(i)->Equals_ed975d2f4a7d193e(rules2->at(j))) 
                {
                    found = true;
                    break;
                }
            }
            if(!(found)) 
            {
                return false;
            }
        }
        return true;
    }
    
    bool NetCodeGroup::Equals_ed975d2f4a7d193e(System::Object* o) {
        if(!(CodeGroup::Equals_ed975d2f4a7d193e(o))) 
        {
            return false;
        }
        NetCodeGroup *ncg = cli::as<NetCodeGroup*>(o);
        if((ncg ==  nullptr)) 
        {
            return false;
        }
        for(auto tmp_600 : this->_rules) {
            auto de = cli::cast<System::Collections::DictionaryEntry>(tmp_600);
            {
                bool found = false;
                cli::array<CodeConnectAccess*> *ccas = cli::cast<cli::array<CodeConnectAccess*>*>(ncg->_rules->get_Item_d75c6e706b965758(de->get_Key()));
                if((ccas != nullptr)) 
                {
                    found = Equals(cli::cast<cli::array<CodeConnectAccess*>*>(de->get_Value()), ccas);
                }
                 else 
                {
                    found = (de->get_Value() ==  nullptr);
                }
                if(!(found)) 
                {
                    return false;
                }
            }
        }
        return true;
    }
    
    cli::array<System::Collections::DictionaryEntry>* NetCodeGroup::GetConnectAccessRules() {
        cli::array<System::Collections::DictionaryEntry> *result = (new cli::array<System::Collections::DictionaryEntry>(this->_rules->get_Count_40aff81471a60b4c()));
        this->_rules->CopyTo_2ceaf225ee09f8a(result, 0);
        return result;
    }
    
    int32_t NetCodeGroup::GetHashCode_6648aef0f235ee6c() {
        if((this->_hashcode ==  0)) 
        {
            this->_hashcode = CodeGroup::GetHashCode_6648aef0f235ee6c();
            for(auto tmp_601 : this->_rules) {
                auto de = cli::cast<System::Collections::DictionaryEntry>(tmp_601);
                {
                    cli::array<CodeConnectAccess*> *ccas = cli::cast<cli::array<CodeConnectAccess*>*>(de->get_Value());
                    if((ccas != nullptr)) 
                    {
                        for(auto tmp_602 : ccas) {
                            auto cca = cli::cast<CodeConnectAccess*>(tmp_602);
                            {
                                (this->_hashcode = this->_hashcode ^ cca->GetHashCode_6648aef0f235ee6c());
                            }
                        }
                    }
                }
            }
        }
        return this->_hashcode;
    }
    
    PolicyStatement* NetCodeGroup::Resolve_e0385e713d5ae5af(Evidence* evidence) {
        if((evidence ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("evidence"));
        }
        if(!(this->get_MembershipCondition()->Check_40359438a47300d0(evidence))) 
        {
            return nullptr;
        }
        System::Security::PermissionSet *ps = nullptr;
        if((this->get_PolicyStatement() ==  nullptr)) 
        {
            ps = cli::gcnew<System::Security::PermissionSet>(System::Security::Permissions::PermissionState::None);
        }
         else 
        {
            ps = this->get_PolicyStatement()->get_PermissionSet()->Copy_cfeae72b3c523c4e();
        }
        if((this->get_Children()->get_Count_8f254f3dd8e2403() > 0)) 
        {
            for(auto tmp_603 : this->get_Children()) {
                auto child_cg = cli::cast<CodeGroup*>(tmp_603);
                {
                    PolicyStatement *child_pst = child_cg->Resolve_e0385e713d5ae5af(evidence);
                    if((child_pst != nullptr)) 
                    {
                        ps = ps->Union(child_pst->get_PermissionSet());
                    }
                }
            }
        }
        PolicyStatement *pst = this->get_PolicyStatement()->Copy();
        pst->set_PermissionSet(ps);
        return pst;
    }
    
    void NetCodeGroup::ResetConnectAccess() {
        this->_rules->Clear_f1f405c8fa63a059();
    }
    
    CodeGroup* NetCodeGroup::ResolveMatchingCodeGroups_908cc5caa682e9f4(Evidence* evidence) {
        if((evidence ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("evidence"));
        }
        CodeGroup *return_group = nullptr;
        if(this->get_MembershipCondition()->Check_40359438a47300d0(evidence)) 
        {
            return_group = NetCodeGroup::Copy_7fdc78f7390869fe();
            for(auto tmp_604 : this->get_Children()) {
                auto child_group = cli::cast<CodeGroup*>(tmp_604);
                {
                    CodeGroup *matching = child_group->ResolveMatchingCodeGroups_908cc5caa682e9f4(evidence);
                    if((matching ==  nullptr)) 
                    {
                        continue;
                    }
                    return_group->AddChild(matching);
                }
            }
        }
        return return_group;
    }
    
    void NetCodeGroup::CreateXml_14eb36ca74574a81(System::Security::SecurityElement* element, PolicyLevel* level) {
        CodeGroup::CreateXml_14eb36ca74574a81(element, level);
    }
    
    void NetCodeGroup::ParseXml_ecb12c827959aa39(System::Security::SecurityElement* e, PolicyLevel* level) {
        CodeGroup::ParseXml_ecb12c827959aa39(e, level);
    }
    
    System::String* NetCodeGroup::get_AttributeString_f768971bd5bbaf63() {
        return nullptr;
    }
    
    System::String* NetCodeGroup::get_MergeLogic_cd001da1f3850530() {
        return _T("Union");
    }
    
    System::String* NetCodeGroup::get_PermissionSetName_4d6dd01cf3ccc2f3() {
        return _T("Same site Web");
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    
    
    void PermissionRequestEvidence::constructor(System::Security::PermissionSet* request, System::Security::PermissionSet* optional, System::Security::PermissionSet* denied) {
        if((request != nullptr)) 
        {
            this->requested = cli::gcnew<System::Security::PermissionSet>(request);
        }
        if((optional != nullptr)) 
        {
            this->optional = cli::gcnew<System::Security::PermissionSet>(optional);
        }
        if((denied != nullptr)) 
        {
            this->denied = cli::gcnew<System::Security::PermissionSet>(denied);
        }
    }
    
    PermissionRequestEvidence* PermissionRequestEvidence::Copy() {
        return cli::gcnew<PermissionRequestEvidence>(this->requested, this->optional, this->denied);
    }
    
    System::String* PermissionRequestEvidence::ToString_1636a0751cb9ac11() {
        System::Security::SecurityElement *se = cli::gcnew<System::Security::SecurityElement>(_T("System.Security.Policy.PermissionRequestEvidence"));
        se->AddAttribute(_T("version"), _T("1"));
        if((this->requested != nullptr)) 
        {
            System::Security::SecurityElement *requestElement = cli::gcnew<System::Security::SecurityElement>(_T("Request"));
            requestElement->AddChild(this->requested->ToXml_c2a66662101c88c3());
            se->AddChild(requestElement);
        }
        if((this->optional != nullptr)) 
        {
            System::Security::SecurityElement *optionalElement = cli::gcnew<System::Security::SecurityElement>(_T("Optional"));
            optionalElement->AddChild(this->optional->ToXml_c2a66662101c88c3());
            se->AddChild(optionalElement);
        }
        if((this->denied != nullptr)) 
        {
            System::Security::SecurityElement *deniedElement = cli::gcnew<System::Security::SecurityElement>(_T("Denied"));
            deniedElement->AddChild(this->denied->ToXml_c2a66662101c88c3());
            se->AddChild(deniedElement);
        }
        return se->ToString_1636a0751cb9ac11();
    }
    
    int32_t PermissionRequestEvidence::GetRequiredSize(bool verbose) {
        int32_t size = verbose ? 3 : 1;
        if((this->requested != nullptr)) 
        {
            int32_t r = (this->requested->ToXml_c2a66662101c88c3()->ToString_1636a0751cb9ac11()->get_Length() + verbose ? 5 : 0);
            (size = size + r);
        }
        if((this->optional != nullptr)) 
        {
            int32_t o = (this->optional->ToXml_c2a66662101c88c3()->ToString_1636a0751cb9ac11()->get_Length() + verbose ? 5 : 0);
            (size = size + o);
        }
        if((this->denied != nullptr)) 
        {
            int32_t d = (this->denied->ToXml_c2a66662101c88c3()->ToString_1636a0751cb9ac11()->get_Length() + verbose ? 5 : 0);
            (size = size + d);
        }
        return size;
    }
    
    int32_t PermissionRequestEvidence::InitFromBuffer(cli::array<char16_t>* buffer, int32_t position) {
        return 0;
    }
    
    int32_t PermissionRequestEvidence::OutputToBuffer(cli::array<char16_t>* buffer, int32_t position, bool verbose) {
        return 0;
    }
    
    System::Security::PermissionSet* PermissionRequestEvidence::get_DeniedPermissions() {
        return this->denied;
    }
    
    System::Security::PermissionSet* PermissionRequestEvidence::get_OptionalPermissions() {
        return this->optional;
    }
    
    System::Security::PermissionSet* PermissionRequestEvidence::get_RequestedPermissions() {
        return this->requested;
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    
    
    void PolicyException::constructor() {
    }
    
    void PolicyException::constructor(System::String* message) {
    }
    
    void PolicyException::constructor(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
    }
    
    void PolicyException::constructor(System::String* message, System::Exception* exception) {
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    
    
    void PolicyLevel::constructor(System::String* label, System::Security::PolicyLevelType type) {
        this->label = label;
        this->_type = type;
        this->full_trust_assemblies = cli::gcnew<System::Collections::ArrayList>();
        this->named_permission_sets = cli::gcnew<System::Collections::ArrayList>();
    }
    
    void PolicyLevel::LoadFromFile(System::String* filename) {
        try
        {
            cli::finally_guard([&]() {
                this->_location = filename;
            });
            if(!(System::IO::File::Exists(filename))) 
            {
                System::String *defcfg = cli::concat(filename, _T(".default"));
                if(System::IO::File::Exists(defcfg)) 
                {
                    System::IO::File::Copy(defcfg, filename);
                }
            }
            if(System::IO::File::Exists(filename)) 
            {
                {
                    /* USING - BLOCK */
                    auto sr = System::IO::File::OpenText(filename);
                    cli::using_guard{sr};
                    this->xml = FromString(sr->ReadToEnd_f683943dd5002e1e());
                }
                {
                    cli::finally_guard([&]() {
                        System::Security::SecurityManager::set_ResolvingPolicyLevel(this);
                    });
                    System::Security::SecurityManager::set_ResolvingPolicyLevel(this);
                    FromXml(this->xml);
                }
            }
             else 
            {
                CreateDefaultFullTrustAssemblies();
                CreateDefaultNamedPermissionSets();
                CreateDefaultLevel(this->_type);
                Save();
            }
        }
        catch(...) {
        }
    }
    
    void PolicyLevel::LoadFromString(System::String* xml) {
        FromXml(FromString(xml));
    }
    
    System::Security::SecurityElement* PolicyLevel::FromString(System::String* xml) {
        Mono::Xml::SecurityParser *parser = cli::gcnew<Mono::Xml::SecurityParser>();
        parser->LoadXml(xml);
        System::Security::SecurityElement *configuration = parser->ToXml();
        if(System::String::op_Inequality(configuration->get_Tag(), _T("configuration"))) 
        {
            throw cli::gcnew<System::ArgumentException>(Locale::GetText(_T("missing <configuration> root element")));
        }
        System::Security::SecurityElement *mscorlib = cli::cast<System::Security::SecurityElement*>(configuration->get_Children()->get_Item_fd0155f142ae570(0));
        if(System::String::op_Inequality(mscorlib->get_Tag(), _T("mscorlib"))) 
        {
            throw cli::gcnew<System::ArgumentException>(Locale::GetText(_T("missing <mscorlib> tag")));
        }
        System::Security::SecurityElement *security = cli::cast<System::Security::SecurityElement*>(mscorlib->get_Children()->get_Item_fd0155f142ae570(0));
        if(System::String::op_Inequality(security->get_Tag(), _T("security"))) 
        {
            throw cli::gcnew<System::ArgumentException>(Locale::GetText(_T("missing <security> tag")));
        }
        System::Security::SecurityElement *policy = cli::cast<System::Security::SecurityElement*>(security->get_Children()->get_Item_fd0155f142ae570(0));
        if(System::String::op_Inequality(policy->get_Tag(), _T("policy"))) 
        {
            throw cli::gcnew<System::ArgumentException>(Locale::GetText(_T("missing <policy> tag")));
        }
        System::Security::SecurityElement *policyLevel = cli::cast<System::Security::SecurityElement*>(policy->get_Children()->get_Item_fd0155f142ae570(0));
        return policyLevel;
    }
    
    void PolicyLevel::AddFullTrustAssembly(StrongName2* sn) {
        if((sn ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("sn"));
        }
        StrongNameMembershipCondition *snMC = cli::gcnew<StrongNameMembershipCondition>(sn->get_PublicKey(), sn->get_Name(), sn->get_Version());
        AddFullTrustAssembly2(snMC);
    }
    
    void PolicyLevel::AddFullTrustAssembly2(StrongNameMembershipCondition* snMC) {
        if((snMC ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("snMC"));
        }
        for(auto tmp_605 : this->full_trust_assemblies) {
            auto sn = cli::cast<StrongNameMembershipCondition*>(tmp_605);
            {
                if(sn->Equals_ed975d2f4a7d193e(snMC)) 
                {
                    throw cli::gcnew<System::ArgumentException>(Locale::GetText(_T("sn already has full trust.")));
                }
            }
        }
        this->full_trust_assemblies->Add_e6a92085999ce388(snMC);
    }
    
    void PolicyLevel::AddNamedPermissionSet(System::Security::NamedPermissionSet* permSet) {
        if((permSet ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("permSet"));
        }
        for(auto tmp_606 : this->named_permission_sets) {
            auto n = cli::cast<System::Security::NamedPermissionSet*>(tmp_606);
            {
                if(System::String::op_Equality(permSet->get_Name(), n->get_Name())) 
                {
                    throw cli::gcnew<System::ArgumentException>(Locale::GetText(_T("This NamedPermissionSet is the same an existing NamedPermissionSet.")));
                }
            }
        }
        this->named_permission_sets->Add_e6a92085999ce388(permSet->Copy_cfeae72b3c523c4e());
    }
    
    System::Security::NamedPermissionSet* PolicyLevel::ChangeNamedPermissionSet(System::String* name, System::Security::PermissionSet* pSet) {
        if((name ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("name"));
        }
        if((pSet ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("pSet"));
        }
        if(ReservedNames::IsReserved(name)) 
        {
            throw cli::gcnew<System::ArgumentException>(Locale::GetText(_T("Reserved name")));
        }
        for(auto tmp_607 : this->named_permission_sets) {
            auto n = cli::cast<System::Security::NamedPermissionSet*>(tmp_607);
            {
                if(System::String::op_Equality(name, n->get_Name())) 
                {
                    this->named_permission_sets->Remove_2225381aaf812c6d(n);
                    AddNamedPermissionSet(cli::gcnew<System::Security::NamedPermissionSet>(name, pSet));
                    return n;
                }
            }
        }
        throw cli::gcnew<System::ArgumentException>(Locale::GetText(_T("PermissionSet not found")));
    }
    
    PolicyLevel* PolicyLevel::CreateAppDomainLevel() {
        UnionCodeGroup *cg = cli::gcnew<UnionCodeGroup>(cli::gcnew<AllMembershipCondition>(), cli::gcnew<PolicyStatement>(DefaultPolicies::get_FullTrust()));
        cg->set_Name(_T("All_Code"));
        PolicyLevel *pl = cli::gcnew<PolicyLevel>(_T("AppDomain"), System::Security::PolicyLevelType::AppDomain2);
        pl->set_RootCodeGroup(cg);
        pl->Reset();
        return pl;
    }
    
    void PolicyLevel::FromXml(System::Security::SecurityElement* e) {
        if((e ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("e"));
        }
        System::Security::SecurityElement *sc = e->SearchForChildByTag(_T("SecurityClasses"));
        if((((sc != nullptr) && (sc->get_Children() != nullptr)) && (sc->get_Children()->get_Count_2354963792616712() > 0))) 
        {
            this->fullNames = cli::gcnew<System::Collections::Hashtable>(sc->get_Children()->get_Count_2354963792616712());
            for(auto tmp_608 : sc->get_Children()) {
                auto se = cli::cast<System::Security::SecurityElement*>(tmp_608);
                {
                    this->fullNames->Add_3f7ab157bcb41156(se->get_Attributes()->get_Item_d75c6e706b965758(_T("Name")), se->get_Attributes()->get_Item_d75c6e706b965758(_T("Description")));
                }
            }
        }
        System::Security::SecurityElement *fta = e->SearchForChildByTag(_T("FullTrustAssemblies"));
        if((((fta != nullptr) && (fta->get_Children() != nullptr)) && (fta->get_Children()->get_Count_2354963792616712() > 0))) 
        {
            this->full_trust_assemblies->Clear_cd6654e5a40f5056();
            for(auto tmp_609 : fta->get_Children()) {
                auto se = cli::cast<System::Security::SecurityElement*>(tmp_609);
                {
                    if(System::String::op_Inequality(se->get_Tag(), _T("IMembershipCondition"))) 
                    {
                        throw cli::gcnew<System::ArgumentException>(Locale::GetText(_T("Invalid XML")));
                    }
                    System::String *className = se->Attribute2(_T("class"));
                    if((className->IndexOf7(_T("StrongNameMembershipCondition")) < 0)) 
                    {
                        throw cli::gcnew<System::ArgumentException>(Locale::GetText(_T("Invalid XML - must be StrongNameMembershipCondition")));
                    }
                    this->full_trust_assemblies->Add_e6a92085999ce388(cli::gcnew<StrongNameMembershipCondition>(se));
                }
            }
        }
        System::Security::SecurityElement *cg = e->SearchForChildByTag(_T("CodeGroup"));
        if((((cg != nullptr) && (cg->get_Children() != nullptr)) && (cg->get_Children()->get_Count_2354963792616712() > 0))) 
        {
            this->root_code_group = CodeGroup::CreateFromXml(cg, this);
        }
         else 
        {
            throw cli::gcnew<System::ArgumentException>(Locale::GetText(_T("Missing Root CodeGroup")));
        }
        System::Security::SecurityElement *nps = e->SearchForChildByTag(_T("NamedPermissionSets"));
        if((((nps != nullptr) && (nps->get_Children() != nullptr)) && (nps->get_Children()->get_Count_2354963792616712() > 0))) 
        {
            this->named_permission_sets->Clear_cd6654e5a40f5056();
            for(auto tmp_610 : nps->get_Children()) {
                auto se = cli::cast<System::Security::SecurityElement*>(tmp_610);
                {
                    System::Security::NamedPermissionSet *n = cli::gcnew<System::Security::NamedPermissionSet>();
                    n->set_Resolver(this);
                    n->FromXml_2ac858dba9ca352b(se);
                    this->named_permission_sets->Add_e6a92085999ce388(n);
                }
            }
        }
    }
    
    System::Security::NamedPermissionSet* PolicyLevel::GetNamedPermissionSet(System::String* name) {
        if((name ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("name"));
        }
        for(auto tmp_611 : this->named_permission_sets) {
            auto n = cli::cast<System::Security::NamedPermissionSet*>(tmp_611);
            {
                if(System::String::op_Equality(n->get_Name(), name)) 
                {
                    return cli::cast<System::Security::NamedPermissionSet*>(n->Copy_cfeae72b3c523c4e());
                }
            }
        }
        return nullptr;
    }
    
    void PolicyLevel::Recover() {
        if((this->_location ==  nullptr)) 
        {
            System::String *msg = Locale::GetText(_T("Only file based policies may be recovered."));
            throw cli::gcnew<PolicyException>(msg);
        }
        System::String *backup = cli::concat(this->_location, _T(".backup"));
        if(!(System::IO::File::Exists(backup))) 
        {
            System::String *msg = Locale::GetText(_T("No policy backup exists."));
            throw cli::gcnew<PolicyException>(msg);
        }
        try {
            System::IO::File::Copy2(backup, this->_location, true);
        }
        catch(System::Exception* e) {
            System::String *msg = Locale::GetText(_T("Couldn\'t replace the policy file with it\'s backup."));
            throw cli::gcnew<PolicyException>(msg, e);
        }
    }
    
    void PolicyLevel::RemoveFullTrustAssembly(StrongName2* sn) {
        if((sn ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("sn"));
        }
        StrongNameMembershipCondition *s = cli::gcnew<StrongNameMembershipCondition>(sn->get_PublicKey(), sn->get_Name(), sn->get_Version());
        RemoveFullTrustAssembly2(s);
    }
    
    void PolicyLevel::RemoveFullTrustAssembly2(StrongNameMembershipCondition* snMC) {
        if((snMC ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("snMC"));
        }
        if(cli::cast<System::Collections::IList*>(this->full_trust_assemblies)->Contains_2a2192a595869f4e(snMC)) 
        {
            cli::cast<System::Collections::IList*>(this->full_trust_assemblies)->Remove_69f1b1e57bb34112(snMC);
        }
         else 
        {
            throw cli::gcnew<System::ArgumentException>(Locale::GetText(_T("sn does not have full trust.")));
        }
    }
    
    System::Security::NamedPermissionSet* PolicyLevel::RemoveNamedPermissionSet(System::Security::NamedPermissionSet* permSet) {
        if((permSet ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("permSet"));
        }
        return RemoveNamedPermissionSet2(permSet->get_Name());
    }
    
    System::Security::NamedPermissionSet* PolicyLevel::RemoveNamedPermissionSet2(System::String* name) {
        if((name ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("name"));
        }
        if(ReservedNames::IsReserved(name)) 
        {
            throw cli::gcnew<System::ArgumentException>(Locale::GetText(_T("Reserved name")));
        }
        for(auto tmp_612 : this->named_permission_sets) {
            auto nps = cli::cast<System::Security::NamedPermissionSet*>(tmp_612);
            {
                if(System::String::op_Equality(name, nps->get_Name())) 
                {
                    this->named_permission_sets->Remove_2225381aaf812c6d(nps);
                    return nps;
                }
            }
        }
        System::String *msg = System::String::Format2(Locale::GetText(_T("Name \'{0}\' cannot be found.")), name);
        throw cli::gcnew<System::ArgumentException>(msg, _T("name"));
    }
    
    void PolicyLevel::Reset() {
        if((this->fullNames != nullptr)) 
        {
            this->fullNames->Clear_f1f405c8fa63a059();
        }
        if(((int32_t)(this->_type) != 3)) 
        {
            this->full_trust_assemblies->Clear_cd6654e5a40f5056();
            this->named_permission_sets->Clear_cd6654e5a40f5056();
            if(((this->_location != nullptr) && System::IO::File::Exists(this->_location))) 
            {
                try {
                    System::IO::File::Delete(this->_location);
                }
                catch(...) {
                }
            }
            LoadFromFile(this->_location);
        }
         else 
        {
            CreateDefaultFullTrustAssemblies();
            CreateDefaultNamedPermissionSets();
        }
    }
    
    PolicyStatement* PolicyLevel::Resolve(Evidence* evidence) {
        if((evidence ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("evidence"));
        }
        PolicyStatement *ps = this->root_code_group->Resolve_e0385e713d5ae5af(evidence);
        return (ps != nullptr) ? ps : PolicyStatement::Empty();
    }
    
    CodeGroup* PolicyLevel::ResolveMatchingCodeGroups(Evidence* evidence) {
        if((evidence ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("evidence"));
        }
        CodeGroup *cg = this->root_code_group->ResolveMatchingCodeGroups_908cc5caa682e9f4(evidence);
        return (cg != nullptr) ? cg : nullptr;
    }
    
    System::Security::SecurityElement* PolicyLevel::ToXml() {
        System::Collections::Hashtable *fullNames = cli::gcnew<System::Collections::Hashtable>();
        if((this->full_trust_assemblies->get_Count_2354963792616712() > 0)) 
        {
            if(!(fullNames->Contains_be7d0f2741618cb4(_T("StrongNameMembershipCondition")))) 
            {
                fullNames->Add_3f7ab157bcb41156(_T("StrongNameMembershipCondition"), cli::typeof<System::Type>::info->get_FullName_7e8fa72ba225e1a4());
            }
        }
        System::Security::SecurityElement *namedPSs = cli::gcnew<System::Security::SecurityElement>(_T("NamedPermissionSets"));
        for(auto tmp_613 : this->named_permission_sets) {
            auto nps = cli::cast<System::Security::NamedPermissionSet*>(tmp_613);
            {
                System::Security::SecurityElement *se = nps->ToXml_c2a66662101c88c3();
                System::Object *objectClass = se->get_Attributes()->get_Item_d75c6e706b965758(_T("class"));
                if(!(fullNames->Contains_be7d0f2741618cb4(objectClass))) 
                {
                    fullNames->Add_3f7ab157bcb41156(objectClass, nps->GetType()->get_FullName_7e8fa72ba225e1a4());
                }
                namedPSs->AddChild(se);
            }
        }
        System::Security::SecurityElement *fta = cli::gcnew<System::Security::SecurityElement>(_T("FullTrustAssemblies"));
        for(auto tmp_614 : this->full_trust_assemblies) {
            auto snmc = cli::cast<StrongNameMembershipCondition*>(tmp_614);
            {
                fta->AddChild(snmc->ToXml2(this));
            }
        }
        System::Security::SecurityElement *security_classes = cli::gcnew<System::Security::SecurityElement>(_T("SecurityClasses"));
        if((fullNames->get_Count_40aff81471a60b4c() > 0)) 
        {
            for(auto tmp_615 : fullNames) {
                auto de = cli::cast<System::Collections::DictionaryEntry>(tmp_615);
                {
                    System::Security::SecurityElement *sc = cli::gcnew<System::Security::SecurityElement>(_T("SecurityClass"));
                    sc->AddAttribute(_T("Name"), cli::cast<System::String*>(de->get_Key()));
                    sc->AddAttribute(_T("Description"), cli::cast<System::String*>(de->get_Value()));
                    security_classes->AddChild(sc);
                }
            }
        }
        System::Security::SecurityElement *element = cli::gcnew<System::Security::SecurityElement>(cli::typeof<System::Type>::info->get_Name_50fad5fa936c3ae2());
        element->AddAttribute(_T("version"), _T("1"));
        element->AddChild(security_classes);
        element->AddChild(namedPSs);
        if((this->root_code_group != nullptr)) 
        {
            element->AddChild(this->root_code_group->ToXml2(this));
        }
        element->AddChild(fta);
        return element;
    }
    
    void PolicyLevel::Save() {
        if(((int32_t)(this->_type) ==  3)) 
        {
            throw cli::gcnew<PolicyException>(Locale::GetText(_T("Can\'t save AppDomain PolicyLevel")));
        }
        if((this->_location != nullptr)) 
        {
            try
            {
                cli::finally_guard([&]() {
                    {
                        /* USING - BLOCK */
                        auto sw = cli::gcnew<System::IO::StreamWriter>(this->_location);
                        cli::using_guard{sw};
                        sw->Write_dcf5e45abd9e11c4(ToXml()->ToString_1636a0751cb9ac11());
                        sw->Close_745be624b802d9f6();
                    }
                });
                if(System::IO::File::Exists(this->_location)) 
                {
                    System::IO::File::Copy2(this->_location, cli::concat(this->_location, _T(".backup")), true);
                }
            }
            catch(System::Exception*) {
            }
        }
    }
    
    void PolicyLevel::CreateDefaultLevel(System::Security::PolicyLevelType type) {
        PolicyStatement *psu = cli::gcnew<PolicyStatement>(DefaultPolicies::get_FullTrust());
        switch(type) {
            case System::Security::PolicyLevelType::Machine: case_1742: {
                PolicyStatement *psn = cli::gcnew<PolicyStatement>(DefaultPolicies::get_Nothing());
                this->root_code_group = cli::gcnew<UnionCodeGroup>(cli::gcnew<AllMembershipCondition>(), psn);
                this->root_code_group->set_Name(_T("All_Code"));
                UnionCodeGroup *myComputerZone = cli::gcnew<UnionCodeGroup>(cli::gcnew<ZoneMembershipCondition>(System::Security::SecurityZone::MyComputer), psu);
                myComputerZone->set_Name(_T("My_Computer_Zone"));
                this->root_code_group->AddChild(myComputerZone);
                UnionCodeGroup *localIntranetZone = cli::gcnew<UnionCodeGroup>(cli::gcnew<ZoneMembershipCondition>(System::Security::SecurityZone::Intranet), cli::gcnew<PolicyStatement>(DefaultPolicies::get_LocalIntranet()));
                localIntranetZone->set_Name(_T("LocalIntranet_Zone"));
                this->root_code_group->AddChild(localIntranetZone);
                PolicyStatement *psi = cli::gcnew<PolicyStatement>(DefaultPolicies::get_Internet());
                UnionCodeGroup *internetZone = cli::gcnew<UnionCodeGroup>(cli::gcnew<ZoneMembershipCondition>(System::Security::SecurityZone::Internet), psi);
                internetZone->set_Name(_T("Internet_Zone"));
                this->root_code_group->AddChild(internetZone);
                UnionCodeGroup *restrictedZone = cli::gcnew<UnionCodeGroup>(cli::gcnew<ZoneMembershipCondition>(System::Security::SecurityZone::Untrusted), psn);
                restrictedZone->set_Name(_T("Restricted_Zone"));
                this->root_code_group->AddChild(restrictedZone);
                UnionCodeGroup *trustedZone = cli::gcnew<UnionCodeGroup>(cli::gcnew<ZoneMembershipCondition>(System::Security::SecurityZone::Trusted), psi);
                trustedZone->set_Name(_T("Trusted_Zone"));
                this->root_code_group->AddChild(trustedZone);
                break;
            }
            case System::Security::PolicyLevelType::User: case System::Security::PolicyLevelType::Enterprise: case System::Security::PolicyLevelType::AppDomain2: case_1743: {
                this->root_code_group = cli::gcnew<UnionCodeGroup>(cli::gcnew<AllMembershipCondition>(), psu);
                this->root_code_group->set_Name(_T("All_Code"));
                break;
            }
        }
    }
    
    void PolicyLevel::CreateDefaultFullTrustAssemblies() {
        this->full_trust_assemblies->Clear_cd6654e5a40f5056();
        this->full_trust_assemblies->Add_e6a92085999ce388(DefaultPolicies::FullTrustMembership(_T("mscorlib"), Key::Ecma));
        this->full_trust_assemblies->Add_e6a92085999ce388(DefaultPolicies::FullTrustMembership(_T("System"), Key::Ecma));
        this->full_trust_assemblies->Add_e6a92085999ce388(DefaultPolicies::FullTrustMembership(_T("System.Data"), Key::Ecma));
        this->full_trust_assemblies->Add_e6a92085999ce388(DefaultPolicies::FullTrustMembership(_T("System.DirectoryServices"), Key::MsFinal));
        this->full_trust_assemblies->Add_e6a92085999ce388(DefaultPolicies::FullTrustMembership(_T("System.Drawing"), Key::MsFinal));
        this->full_trust_assemblies->Add_e6a92085999ce388(DefaultPolicies::FullTrustMembership(_T("System.Messaging"), Key::MsFinal));
        this->full_trust_assemblies->Add_e6a92085999ce388(DefaultPolicies::FullTrustMembership(_T("System.ServiceProcess"), Key::MsFinal));
    }
    
    void PolicyLevel::CreateDefaultNamedPermissionSets() {
        this->named_permission_sets->Clear_cd6654e5a40f5056();
        {
            cli::finally_guard([&]() {
                System::Security::SecurityManager::set_ResolvingPolicyLevel(nullptr);
            });
            System::Security::SecurityManager::set_ResolvingPolicyLevel(this);
            this->named_permission_sets->Add_e6a92085999ce388(DefaultPolicies::get_LocalIntranet());
            this->named_permission_sets->Add_e6a92085999ce388(DefaultPolicies::get_Internet());
            this->named_permission_sets->Add_e6a92085999ce388(DefaultPolicies::get_SkipVerification());
            this->named_permission_sets->Add_e6a92085999ce388(DefaultPolicies::get_Execution());
            this->named_permission_sets->Add_e6a92085999ce388(DefaultPolicies::get_Nothing());
            this->named_permission_sets->Add_e6a92085999ce388(DefaultPolicies::get_Everything());
            this->named_permission_sets->Add_e6a92085999ce388(DefaultPolicies::get_FullTrust());
        }
    }
    
    System::String* PolicyLevel::ResolveClassName(System::String* className) {
        if((this->fullNames != nullptr)) 
        {
            System::Object *name = this->fullNames->get_Item_d75c6e706b965758(className);
            if((name != nullptr)) 
            {
                return cli::cast<System::String*>(name);
            }
        }
        return className;
    }
    
    bool PolicyLevel::IsFullTrustAssembly(System::Reflection::Assembly* a) {
        System::Reflection::AssemblyName *an = a->UnprotectedGetName_b11b135b2412c023();
        System::Security::Permissions::StrongNamePublicKeyBlob *snpkb = cli::gcnew<System::Security::Permissions::StrongNamePublicKeyBlob>(an->GetPublicKey());
        StrongNameMembershipCondition *snMC = cli::gcnew<StrongNameMembershipCondition>(snpkb, an->get_Name(), an->get_Version());
        for(auto tmp_616 : this->full_trust_assemblies) {
            auto sn = cli::cast<StrongNameMembershipCondition*>(tmp_616);
            {
                if(sn->Equals_ed975d2f4a7d193e(snMC)) 
                {
                    return true;
                }
            }
        }
        return false;
    }
    
    System::Collections::IList* PolicyLevel::get_FullTrustAssemblies() {
        return this->full_trust_assemblies;
    }
    
    System::String* PolicyLevel::get_Label() {
        return this->label;
    }
    
    System::Collections::IList* PolicyLevel::get_NamedPermissionSets() {
        return this->named_permission_sets;
    }
    
    CodeGroup* PolicyLevel::get_RootCodeGroup() {
        return this->root_code_group;
    }
    
    CodeGroup* PolicyLevel::set_RootCodeGroup(CodeGroup* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("value"));
        }
        this->root_code_group = value;
        return get_RootCodeGroup();
    }
    
    System::String* PolicyLevel::get_StoreLocation() {
        return this->_location;
    }
    
    System::Security::PolicyLevelType PolicyLevel::get_Type() {
        return this->_type;
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    
    
    void PolicyStatement::constructor(System::Security::PermissionSet* permSet) {
    }
    
    void PolicyStatement::constructor(System::Security::PermissionSet* permSet, PolicyStatementAttribute attributes) {
        if((permSet != nullptr)) 
        {
            this->perms = permSet->Copy_cfeae72b3c523c4e();
            this->perms->SetReadOnly(true);
        }
        this->attrs = attributes;
    }
    
    PolicyStatement* PolicyStatement::Copy() {
        return cli::gcnew<PolicyStatement>(this->perms, this->attrs);
    }
    
    void PolicyStatement::FromXml(System::Security::SecurityElement* et) {
        FromXml2(et, nullptr);
    }
    
    void PolicyStatement::FromXml2(System::Security::SecurityElement* et, PolicyLevel* level) {
        if((et ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("et"));
        }
        if(System::String::op_Inequality(et->get_Tag(), _T("PolicyStatement"))) 
        {
            throw cli::gcnew<System::ArgumentException>(Locale::GetText(_T("Invalid tag.")));
        }
        System::String *attributes = et->Attribute2(_T("Attributes"));
        if((attributes != nullptr)) 
        {
            this->attrs = cli::unbox<PolicyStatementAttribute>(System::Enum::Parse(cli::typeof<System::Type>::info, attributes));
        }
        System::Security::SecurityElement *permissions = et->SearchForChildByTag(_T("PermissionSet"));
        this->get_PermissionSet()->FromXml_2ac858dba9ca352b(permissions);
    }
    
    System::Security::SecurityElement* PolicyStatement::ToXml() {
        return ToXml2(nullptr);
    }
    
    System::Security::SecurityElement* PolicyStatement::ToXml2(PolicyLevel* level) {
        System::Security::SecurityElement *element = cli::gcnew<System::Security::SecurityElement>(_T("PolicyStatement"));
        element->AddAttribute(_T("version"), _T("1"));
        if(((int32_t)(this->attrs) != 0)) 
        {
            element->AddAttribute(_T("Attributes"), cli::import(this->attrs)->ToString_1636a0751cb9ac11());
        }
        element->AddChild(this->get_PermissionSet()->ToXml_c2a66662101c88c3());
        return element;
    }
    
    bool PolicyStatement::Equals_ed975d2f4a7d193e(System::Object* obj) {
        if((obj ==  nullptr)) 
        {
            return false;
        }
        PolicyStatement *ps = cli::as<PolicyStatement*>(obj);
        if((ps ==  nullptr)) 
        {
            return false;
        }
        return (this->get_PermissionSet()->Equals_ed975d2f4a7d193e(obj) && ((int32_t)(this->attrs) ==  (int32_t)(ps->attrs)));
    }
    
    int32_t PolicyStatement::GetHashCode_6648aef0f235ee6c() {
        return (this->get_PermissionSet()->GetHashCode_6648aef0f235ee6c() ^ (int32_t)(this->attrs));
    }
    
    PolicyStatement* PolicyStatement::Empty() {
        return cli::gcnew<PolicyStatement>(cli::gcnew<System::Security::PermissionSet>(System::Security::Permissions::PermissionState::None));
    }
    
    System::Security::PermissionSet* PolicyStatement::get_PermissionSet() {
        if((this->perms ==  nullptr)) 
        {
            this->perms = cli::gcnew<System::Security::PermissionSet>(System::Security::Permissions::PermissionState::None);
            this->perms->SetReadOnly(true);
        }
        return this->perms;
    }
    
    System::Security::PermissionSet* PolicyStatement::set_PermissionSet(System::Security::PermissionSet* value) {
        this->perms = value;
        return get_PermissionSet();
    }
    
    PolicyStatementAttribute PolicyStatement::get_Attributes() {
        return this->attrs;
    }
    
    PolicyStatementAttribute PolicyStatement::set_Attributes(PolicyStatementAttribute value) {
        switch(value) {
            case PolicyStatementAttribute::Nothing: case PolicyStatementAttribute::Exclusive: case PolicyStatementAttribute::LevelFinal: case PolicyStatementAttribute::All: case_1744: {
                this->attrs = value;
                break;
            }
            default: case_1745: {
                System::String *msg = Locale::GetText(_T("Invalid value for {0}."));
                throw cli::gcnew<System::ArgumentException>(System::String::Format2(msg, _T("PolicyStatementAttribute")));
            }
        }
        return get_Attributes();
    }
    
    System::String* PolicyStatement::get_AttributeString() {
        switch(this->attrs) {
            case PolicyStatementAttribute::Exclusive: case_1746: {
                return _T("Exclusive");
            }
            case PolicyStatementAttribute::LevelFinal: case_1747: {
                return _T("LevelFinal");
            }
            case PolicyStatementAttribute::All: case_1748: {
                return _T("Exclusive LevelFinal");
            }
            default: case_1749: {
                return System::String::Empty;
            }
        }
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    
    
    void ProvideAssemblyEvidenceEventArgs::constructor(System::Reflection::Assembly* a, Evidence* e) {
        this->_assembly = a;
        this->_evidence = e;
    }
    
    System::Reflection::Assembly* ProvideAssemblyEvidenceEventArgs::get_Assembly() {
        return this->_assembly;
    }
    
    Evidence* ProvideAssemblyEvidenceEventArgs::get_Evidence() {
        return this->_evidence;
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    
    
    void Publisher::constructor(System::Security::Cryptography::X509Certificates::X509Certificate2* cert) {
        if((cert ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("cert"));
        }
        if((cert->GetHashCode_6648aef0f235ee6c() ==  0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("cert"));
        }
        this->m_cert = cert;
    }
    
    System::Object* Publisher::Copy() {
        return cli::gcnew<Publisher>(this->m_cert);
    }
    
    System::Security::IPermission* Publisher::CreateIdentityPermission(Evidence* evidence) {
        return cli::gcnew<System::Security::Permissions::PublisherIdentityPermission>(this->m_cert);
    }
    
    bool Publisher::Equals_ed975d2f4a7d193e(System::Object* o) {
        Publisher *p = cli::as<Publisher*>(o);
        if((p ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("o"), Locale::GetText(_T("not a Publisher instance.")));
        }
        return this->m_cert->Equals_4ee033c835248c9d(p->get_Certificate());
    }
    
    int32_t Publisher::GetHashCode_6648aef0f235ee6c() {
        return this->m_cert->GetHashCode_6648aef0f235ee6c();
    }
    
    System::String* Publisher::ToString_1636a0751cb9ac11() {
        System::Security::SecurityElement *se = cli::gcnew<System::Security::SecurityElement>(_T("System.Security.Policy.Publisher"));
        se->AddAttribute(_T("version"), _T("1"));
        System::Security::SecurityElement *cert = cli::gcnew<System::Security::SecurityElement>(_T("X509v3Certificate"));
        System::String *data = this->m_cert->GetRawCertDataString_9b5d755fdca2c386();
        if((data != nullptr)) 
        {
            cert->set_Text(data);
        }
        se->AddChild(cert);
        return se->ToString_1636a0751cb9ac11();
    }
    
    int32_t Publisher::GetRequiredSize(bool verbose) {
        return (verbose ? 3 : 1 + this->m_cert->GetRawCertData_ac3e339ae8bdb569()->get_Length());
    }
    
    int32_t Publisher::InitFromBuffer(cli::array<char16_t>* buffer, int32_t position) {
        return 0;
    }
    
    int32_t Publisher::OutputToBuffer(cli::array<char16_t>* buffer, int32_t position, bool verbose) {
        return 0;
    }
    
    System::Security::Cryptography::X509Certificates::X509Certificate2* Publisher::get_Certificate() {
        if((this->m_cert->GetHashCode_6648aef0f235ee6c() ==  0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("m_cert"));
        }
        return this->m_cert;
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    
    
    void PublisherMembershipCondition::constructor() {
    }
    
    void PublisherMembershipCondition::constructor(System::Security::Cryptography::X509Certificates::X509Certificate2* certificate) {
        if((certificate ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("certificate"));
        }
        if((certificate->GetHashCode_6648aef0f235ee6c() ==  0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("certificate"));
        }
        this->x509 = certificate;
    }
    
    bool PublisherMembershipCondition::Check(Evidence* evidence) {
        if((evidence ==  nullptr)) 
        {
            return false;
        }
        System::Collections::IEnumerator *e = evidence->GetHostEnumerator();
        while(e->MoveNext_4e78e145935f5417()) {
            if(cli::is<Publisher>(e->get_Current_8eca9b3da02b123a())) 
            {
                if(this->x509->Equals_4ee033c835248c9d(cli::as<Publisher*>(e->get_Current_8eca9b3da02b123a())->get_Certificate())) 
                {
                    return true;
                }
            }
        }
        return false;
    }
    
    IMembershipCondition* PublisherMembershipCondition::Copy() {
        return cli::gcnew<PublisherMembershipCondition>(this->x509);
    }
    
    bool PublisherMembershipCondition::Equals_ed975d2f4a7d193e(System::Object* o) {
        PublisherMembershipCondition *pmc = cli::as<PublisherMembershipCondition*>(o);
        if((pmc ==  nullptr)) 
        {
            return false;
        }
        return this->x509->Equals_4ee033c835248c9d(pmc->get_Certificate());
    }
    
    void PublisherMembershipCondition::FromXml(System::Security::SecurityElement* e) {
        FromXml2(e, nullptr);
    }
    
    void PublisherMembershipCondition::FromXml2(System::Security::SecurityElement* e, PolicyLevel* level) {
        MembershipConditionHelper::CheckSecurityElement(e, _T("e"), this->version, this->version);
        System::String *cert = e->Attribute2(_T("X509Certificate"));
        if((cert != nullptr)) 
        {
            cli::array<unsigned char> *rawcert = Mono::Security::Cryptography::CryptoConvert::FromHex(cert);
            this->x509 = cli::gcnew<System::Security::Cryptography::X509Certificates::X509Certificate2>(rawcert);
        }
    }
    
    int32_t PublisherMembershipCondition::GetHashCode_6648aef0f235ee6c() {
        return this->x509->GetHashCode_6648aef0f235ee6c();
    }
    
    System::String* PublisherMembershipCondition::ToString_1636a0751cb9ac11() {
        return cli::concat(_T("Publisher - "), this->x509->GetPublicKeyString_883dde0135cf6f31());
    }
    
    System::Security::SecurityElement* PublisherMembershipCondition::ToXml() {
        return ToXml2(nullptr);
    }
    
    System::Security::SecurityElement* PublisherMembershipCondition::ToXml2(PolicyLevel* level) {
        System::Security::SecurityElement *se = MembershipConditionHelper::Element2(cli::typeof<System::Type>::info, this->version);
        se->AddAttribute(_T("X509Certificate"), this->x509->GetRawCertDataString_9b5d755fdca2c386());
        return se;
    }
    
    System::Security::Cryptography::X509Certificates::X509Certificate2* PublisherMembershipCondition::get_Certificate() {
        return this->x509;
    }
    
    System::Security::Cryptography::X509Certificates::X509Certificate2* PublisherMembershipCondition::set_Certificate(System::Security::Cryptography::X509Certificates::X509Certificate2* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("value"));
        }
        this->x509 = value;
        return get_Certificate();
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    
    
    void Site::constructor(System::String* name) {
        if((name ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("url"));
        }
        if(!(IsValid(name))) 
        {
            throw cli::gcnew<System::ArgumentException>(Locale::GetText(_T("name is not valid")));
        }
        this->origin_site = name;
    }
    
    Site* Site::CreateFromUrl(System::String* url) {
        if((url ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("url"));
        }
        if((url->get_Length() ==  0)) 
        {
            throw cli::gcnew<System::FormatException>(Locale::GetText(_T("Empty URL.")));
        }
        System::String *site = UrlToSite(url);
        if((site ==  nullptr)) 
        {
            System::String *msg = System::String::Format2(Locale::GetText(_T("Invalid URL \'{0}\'.")), url);
            throw cli::gcnew<System::ArgumentException>(msg, _T("url"));
        }
        return cli::gcnew<Site>(site);
    }
    
    System::Object* Site::Copy() {
        return cli::gcnew<Site>(this->origin_site);
    }
    
    System::Security::IPermission* Site::CreateIdentityPermission(Evidence* evidence) {
        return cli::gcnew<System::Security::Permissions::SiteIdentityPermission>(this->origin_site);
    }
    
    bool Site::Equals_ed975d2f4a7d193e(System::Object* o) {
        Site *s = cli::as<Site*>(o);
        if((s ==  nullptr)) 
        {
            return false;
        }
        return (System::String::Compare3(s->get_Name(), this->origin_site, true, System::Globalization::CultureInfo::get_InvariantCulture()) ==  0);
    }
    
    int32_t Site::GetHashCode_6648aef0f235ee6c() {
        return this->origin_site->GetHashCode_6648aef0f235ee6c();
    }
    
    System::String* Site::ToString_1636a0751cb9ac11() {
        System::Security::SecurityElement *element = cli::gcnew<System::Security::SecurityElement>(_T("System.Security.Policy.Site"));
        element->AddAttribute(_T("version"), _T("1"));
        element->AddChild(cli::gcnew<System::Security::SecurityElement>(_T("Name"), this->origin_site));
        return element->ToString_1636a0751cb9ac11();
    }
    
    int32_t Site::GetRequiredSize(bool verbose) {
        return (verbose ? 3 : 1 + this->origin_site->get_Length());
    }
    
    int32_t Site::InitFromBuffer(cli::array<char16_t>* buffer, int32_t position) {
        return 0;
    }
    
    int32_t Site::OutputToBuffer(cli::array<char16_t>* buffer, int32_t position, bool verbose) {
        return 0;
    }
    
    bool Site::IsValid(System::String* name) {
        if(System::String::op_Equality(name, System::String::Empty)) 
        {
            return false;
        }
        if(((name->get_Length() ==  1) && System::String::op_Equality(name, _T(".")))) 
        {
            return false;
        }
        cli::array<System::String*> *parts = name->Split((new cli::array<char16_t>({u'.'})));
        for(int32_t i = 0; (i < parts->get_Length()); i++){
            System::String *part = parts->at(i);
            if(((i ==  0) && System::String::op_Equality(part, _T("*")))) 
            {
                continue;
            }
            for(auto tmp_617 : part) {
                auto c = cli::cast<char16_t>(tmp_617);
                {
                    int32_t x = System::Convert::ToInt323(c);
                    bool result = ((((((((x ==  33) || (x ==  45)) || ((x >= 35) && (x <= 41))) || ((x >= 48) && (x <= 57))) || ((x >= 64) && (x <= 90))) || ((x >= 94) && (x <= 95))) || ((x >= 97) && (x <= 123))) || ((x >= 125) && (x <= 126)));
                    if(!(result)) 
                    {
                        return false;
                    }
                }
            }
        }
        return true;
    }
    
    System::String* Site::UrlToSite(System::String* url) {
        if((url ==  nullptr)) 
        {
            return nullptr;
        }
        Mono::Security::Uri *uri = cli::gcnew<Mono::Security::Uri>(url);
        if(System::String::op_Equality(uri->get_Scheme(), Mono::Security::Uri::UriSchemeFile)) 
        {
            return nullptr;
        }
        System::String *site = uri->get_Host();
        return IsValid(site) ? site : nullptr;
    }
    
    System::String* Site::get_Name() {
        return this->origin_site;
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    
    
    void SiteMembershipCondition::constructor() {
    }
    
    void SiteMembershipCondition::constructor(System::String* site) {
        this->set_Site(site);
    }
    
    bool SiteMembershipCondition::Check(Evidence* evidence) {
        if((evidence ==  nullptr)) 
        {
            return false;
        }
        System::Collections::IEnumerator *e = evidence->GetHostEnumerator();
        while(e->MoveNext_4e78e145935f5417()) {
            if(cli::is<Site>(e->get_Current_8eca9b3da02b123a())) 
            {
                cli::array<System::String*> *s1 = this->_site->Split((new cli::array<char16_t>({u'.'})));
                cli::array<System::String*> *s2 = cli::as<Site*>(e->get_Current_8eca9b3da02b123a())->origin_site->Split((new cli::array<char16_t>({u'.'})));
                for(int32_t i = (s1->get_Length() - 1), j = (s2->get_Length() - 1); (i >= 0); i--, j--){
                    if((i ==  0)) 
                    {
                        return (System::String::Compare3(s1->at(0), _T("*"), true, System::Globalization::CultureInfo::get_InvariantCulture()) ==  0);
                    }
                    if((System::String::Compare3(s1->at(i), s2->at(j), true, System::Globalization::CultureInfo::get_InvariantCulture()) != 0)) 
                    {
                        return false;
                    }
                }
                return true;
            }
        }
        return false;
    }
    
    IMembershipCondition* SiteMembershipCondition::Copy() {
        return cli::gcnew<SiteMembershipCondition>(this->_site);
    }
    
    bool SiteMembershipCondition::Equals_ed975d2f4a7d193e(System::Object* o) {
        if((o ==  nullptr)) 
        {
            return false;
        }
        if(cli::is<SiteMembershipCondition>(o)) 
        {
            Site *s = cli::gcnew<Site>(cli::as<SiteMembershipCondition*>(o)->_site);
            return s->Equals_ed975d2f4a7d193e(cli::gcnew<Site>(this->_site));
        }
        return false;
    }
    
    void SiteMembershipCondition::FromXml(System::Security::SecurityElement* e) {
        FromXml2(e, nullptr);
    }
    
    void SiteMembershipCondition::FromXml2(System::Security::SecurityElement* e, PolicyLevel* level) {
        MembershipConditionHelper::CheckSecurityElement(e, _T("e"), this->version, this->version);
        this->_site = e->Attribute2(_T("Site"));
    }
    
    int32_t SiteMembershipCondition::GetHashCode_6648aef0f235ee6c() {
        return this->_site->GetHashCode_6648aef0f235ee6c();
    }
    
    System::String* SiteMembershipCondition::ToString_1636a0751cb9ac11() {
        return cli::concat(_T("Site - "), this->_site);
    }
    
    System::Security::SecurityElement* SiteMembershipCondition::ToXml() {
        return ToXml2(nullptr);
    }
    
    System::Security::SecurityElement* SiteMembershipCondition::ToXml2(PolicyLevel* level) {
        System::Security::SecurityElement *se = MembershipConditionHelper::Element2(cli::typeof<System::Type>::info, this->version);
        se->AddAttribute(_T("Site"), this->_site);
        return se;
    }
    
    System::String* SiteMembershipCondition::get_Site() {
        return this->_site;
    }
    
    System::String* SiteMembershipCondition::set_Site(System::String* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("site"));
        }
        if(!(Site::IsValid(value))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("invalid site"));
        }
        this->_site = value;
        return get_Site();
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    
    
    void StrongName2::constructor(System::Security::Permissions::StrongNamePublicKeyBlob* blob, System::String* name, System::Version* version) {
        if((blob ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("blob"));
        }
        if((name ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("name"));
        }
        if(System::Version::op_Equality(version, nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("version"));
        }
        if((name->get_Length() ==  0)) 
        {
            throw cli::gcnew<System::ArgumentException>(Locale::GetText(_T("Empty")), _T("name"));
        }
        this->publickey = blob;
        this->name = name;
        this->version = version;
    }
    
    System::Object* StrongName2::Copy() {
        return cli::cast<System::Object*>(cli::gcnew<StrongName2>(this->publickey, this->name, this->version));
    }
    
    System::Security::IPermission* StrongName2::CreateIdentityPermission(Evidence* evidence) {
        return cli::gcnew<System::Security::Permissions::StrongNameIdentityPermission>(this->publickey, this->name, this->version);
    }
    
    bool StrongName2::Equals_ed975d2f4a7d193e(System::Object* o) {
        StrongName2 *sn = cli::as<StrongName2*>(o);
        if((sn ==  nullptr)) 
        {
            return false;
        }
        if(System::String::op_Inequality(this->name, sn->get_Name())) 
        {
            return false;
        }
        if(!(this->get_Version()->Equals4(sn->get_Version()))) 
        {
            return false;
        }
        return this->get_PublicKey()->Equals_ed975d2f4a7d193e(sn->get_PublicKey());
    }
    
    int32_t StrongName2::GetHashCode_6648aef0f235ee6c() {
        return this->publickey->GetHashCode_6648aef0f235ee6c();
    }
    
    System::String* StrongName2::ToString_1636a0751cb9ac11() {
        System::Security::SecurityElement *element = cli::gcnew<System::Security::SecurityElement>(cli::typeof<System::Type>::info->get_Name_50fad5fa936c3ae2());
        element->AddAttribute(_T("version"), _T("1"));
        element->AddAttribute(_T("Key"), this->publickey->ToString_1636a0751cb9ac11());
        element->AddAttribute(_T("Name"), this->name);
        element->AddAttribute(_T("Version"), this->version->ToString_1636a0751cb9ac11());
        return element->ToString_1636a0751cb9ac11();
    }
    
    int32_t StrongName2::GetRequiredSize(bool verbose) {
        return (verbose ? 5 : 1 + this->name->get_Length());
    }
    
    int32_t StrongName2::InitFromBuffer(cli::array<char16_t>* buffer, int32_t position) {
        return 0;
    }
    
    int32_t StrongName2::OutputToBuffer(cli::array<char16_t>* buffer, int32_t position, bool verbose) {
        return 0;
    }
    
    System::String* StrongName2::get_Name() {
        return this->name;
    }
    
    System::Security::Permissions::StrongNamePublicKeyBlob* StrongName2::get_PublicKey() {
        return this->publickey;
    }
    
    System::Version* StrongName2::get_Version() {
        return this->version;
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    
    
    void StrongNameMembershipCondition::constructor(System::Security::Permissions::StrongNamePublicKeyBlob* blob, System::String* name, System::Version* version) {
        if((blob ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("blob"));
        }
        this->blob = blob;
        this->name = name;
        if(System::Version::op_Inequality(version, nullptr)) 
        {
            this->assemblyVersion = cli::cast<System::Version*>(version->Clone());
        }
    }
    
    void StrongNameMembershipCondition::constructor(System::Security::SecurityElement* e) {
        FromXml(e);
    }
    
    void StrongNameMembershipCondition::constructor() {
    }
    
    bool StrongNameMembershipCondition::Check(Evidence* evidence) {
        if((evidence ==  nullptr)) 
        {
            return false;
        }
        System::Collections::IEnumerator *e = evidence->GetHostEnumerator();
        while(e->MoveNext_4e78e145935f5417()) {
            StrongName2 *sn = cli::as<StrongName2*>(e->get_Current_8eca9b3da02b123a());
            if((sn != nullptr)) 
            {
                if(!(sn->get_PublicKey()->Equals_ed975d2f4a7d193e(this->blob))) 
                {
                    return false;
                }
                if(((this->name != nullptr) && System::String::op_Inequality(this->name, sn->get_Name()))) 
                {
                    return false;
                }
                if((System::Version::op_Inequality(this->assemblyVersion, nullptr) && !(this->assemblyVersion->Equals4(sn->get_Version())))) 
                {
                    return false;
                }
                return true;
            }
        }
        return false;
    }
    
    IMembershipCondition* StrongNameMembershipCondition::Copy() {
        return cli::gcnew<StrongNameMembershipCondition>(this->blob, this->name, this->assemblyVersion);
    }
    
    bool StrongNameMembershipCondition::Equals_ed975d2f4a7d193e(System::Object* o) {
        StrongNameMembershipCondition *snmc = cli::as<StrongNameMembershipCondition*>(o);
        if((snmc ==  nullptr)) 
        {
            return false;
        }
        if(!(snmc->get_PublicKey()->Equals_ed975d2f4a7d193e(this->get_PublicKey()))) 
        {
            return false;
        }
        if(System::String::op_Inequality(this->name, snmc->get_Name())) 
        {
            return false;
        }
        if(System::Version::op_Inequality(this->assemblyVersion, nullptr)) 
        {
            return this->assemblyVersion->Equals4(snmc->get_Version());
        }
        return System::Version::op_Equality(snmc->get_Version(), nullptr);
    }
    
    int32_t StrongNameMembershipCondition::GetHashCode_6648aef0f235ee6c() {
        return this->blob->GetHashCode_6648aef0f235ee6c();
    }
    
    void StrongNameMembershipCondition::FromXml(System::Security::SecurityElement* e) {
        FromXml2(e, nullptr);
    }
    
    void StrongNameMembershipCondition::FromXml2(System::Security::SecurityElement* e, PolicyLevel* level) {
        MembershipConditionHelper::CheckSecurityElement(e, _T("e"), this->version, this->version);
        this->blob = System::Security::Permissions::StrongNamePublicKeyBlob::FromString(e->Attribute2(_T("PublicKeyBlob")));
        this->name = e->Attribute2(_T("Name"));
        System::String *v = cli::cast<System::String*>(e->Attribute2(_T("AssemblyVersion")));
        if((v ==  nullptr)) 
        {
            this->assemblyVersion = nullptr;
        }
         else 
        {
            this->assemblyVersion = cli::gcnew<System::Version>(v);
        }
    }
    
    System::String* StrongNameMembershipCondition::ToString_1636a0751cb9ac11() {
        System::Text::StringBuilder *sb = cli::gcnew<System::Text::StringBuilder>(_T("StrongName - "));
        sb->Append10(this->blob);
        if((this->name != nullptr)) 
        {
            sb->AppendFormat3(_T(" name = {0}"), this->name);
        }
        if(System::Version::op_Inequality(this->assemblyVersion, nullptr)) 
        {
            sb->AppendFormat3(_T(" version = {0}"), this->assemblyVersion);
        }
        return sb->ToString_1636a0751cb9ac11();
    }
    
    System::Security::SecurityElement* StrongNameMembershipCondition::ToXml() {
        return ToXml2(nullptr);
    }
    
    System::Security::SecurityElement* StrongNameMembershipCondition::ToXml2(PolicyLevel* level) {
        System::Security::SecurityElement *se = MembershipConditionHelper::Element2(cli::typeof<System::Type>::info, this->version);
        if((this->blob != nullptr)) 
        {
            se->AddAttribute(_T("PublicKeyBlob"), this->blob->ToString_1636a0751cb9ac11());
        }
        if((this->name != nullptr)) 
        {
            se->AddAttribute(_T("Name"), this->name);
        }
        if(System::Version::op_Inequality(this->assemblyVersion, nullptr)) 
        {
            System::String *v = this->assemblyVersion->ToString_1636a0751cb9ac11();
            if(System::String::op_Inequality(v, _T("0.0"))) 
            {
                se->AddAttribute(_T("AssemblyVersion"), v);
            }
        }
        return se;
    }
    
    System::String* StrongNameMembershipCondition::get_Name() {
        return this->name;
    }
    
    System::String* StrongNameMembershipCondition::set_Name(System::String* value) {
        this->name = value;
        return get_Name();
    }
    
    System::Version* StrongNameMembershipCondition::get_Version() {
        return this->assemblyVersion;
    }
    
    System::Version* StrongNameMembershipCondition::set_Version(System::Version* value) {
        this->assemblyVersion = value;
        return get_Version();
    }
    
    System::Security::Permissions::StrongNamePublicKeyBlob* StrongNameMembershipCondition::get_PublicKey() {
        return this->blob;
    }
    
    System::Security::Permissions::StrongNamePublicKeyBlob* StrongNameMembershipCondition::set_PublicKey(System::Security::Permissions::StrongNamePublicKeyBlob* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("PublicKey"));
        }
        this->blob = value;
        return get_PublicKey();
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    
    
    void TrustLicenseIssuer::constructor() {
    }
    
    void TrustLicenseIssuer::constructor(System::Security::Cryptography::RSA* publicKey, System::String* title) {
        this->_publicKey = publicKey;
        this->_title = title;
    }
    
    System::Security::Cryptography::RSA* TrustLicenseIssuer::get_PublicKey() {
        return this->_publicKey;
    }
    
    System::Security::Cryptography::RSA* TrustLicenseIssuer::set_PublicKey(System::Security::Cryptography::RSA* value) {
        this->_publicKey = value;
        return get_PublicKey();
    }
    
    System::String* TrustLicenseIssuer::get_Title() {
        return this->_title;
    }
    
    System::String* TrustLicenseIssuer::set_Title(System::String* value) {
        this->_title = value;
        return get_Title();
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    
    
    void TrustManagerContext::constructor() {
    }
    
    void TrustManagerContext::constructor(TrustManagerUIContext uiContext) {
        this->_ignorePersistedDecision = false;
        this->_noPrompt = false;
        this->_keepAlive = false;
        this->_persist = false;
        this->_ui = uiContext;
    }
    
    bool TrustManagerContext::get_IgnorePersistedDecision_ac287477dbd7b15c() {
        return this->_ignorePersistedDecision;
    }
    
    bool TrustManagerContext::set_IgnorePersistedDecision_6774da57ae62d885(bool value) {
        this->_ignorePersistedDecision = value;
        return get_IgnorePersistedDecision_ac287477dbd7b15c();
    }
    
    bool TrustManagerContext::get_KeepAlive_8b80a28a931faee3() {
        return this->_keepAlive;
    }
    
    bool TrustManagerContext::set_KeepAlive_998c74dfe70b61b(bool value) {
        this->_keepAlive = value;
        return get_KeepAlive_8b80a28a931faee3();
    }
    
    bool TrustManagerContext::get_NoPrompt_201c71f0fbe15709() {
        return this->_noPrompt;
    }
    
    bool TrustManagerContext::set_NoPrompt_a4bf8c1182f6743d(bool value) {
        this->_noPrompt = value;
        return get_NoPrompt_201c71f0fbe15709();
    }
    
    bool TrustManagerContext::get_Persist_e503d8537a698c() {
        return this->_persist;
    }
    
    bool TrustManagerContext::set_Persist_34aecb54a156d805(bool value) {
        this->_persist = value;
        return get_Persist_e503d8537a698c();
    }
    
    System::ApplicationIdentity* TrustManagerContext::get_PreviousApplicationIdentity_659da1b437ccd279() {
        return this->_previousId;
    }
    
    System::ApplicationIdentity* TrustManagerContext::set_PreviousApplicationIdentity_a573268ad8ac0348(System::ApplicationIdentity* value) {
        this->_previousId = value;
        return get_PreviousApplicationIdentity_659da1b437ccd279();
    }
    
    TrustManagerUIContext TrustManagerContext::get_UIContext_fec8450af2ad7333() {
        return this->_ui;
    }
    
    TrustManagerUIContext TrustManagerContext::set_UIContext_1e686c213cbee48f(TrustManagerUIContext value) {
        this->_ui = value;
        return get_UIContext_fec8450af2ad7333();
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    
    
    void TrustManagerZoneConfig::constructor() {
        this->_prompt = PromptingLevel::Prompt;
    }
    
    void TrustManagerZoneConfig::constructor(System::String* defaultPermissionSetName, PromptingLevel promptingLevel) {
        this->_prompt = promptingLevel;
    }
    
    System::String* TrustManagerZoneConfig::get_DefaultPermissionSetName() {
        return this->_defaultName;
    }
    
    System::String* TrustManagerZoneConfig::set_DefaultPermissionSetName(System::String* value) {
        this->_defaultName = value;
        return get_DefaultPermissionSetName();
    }
    
    PromptingLevel TrustManagerZoneConfig::get_Prompt() {
        return this->_prompt;
    }
    
    PromptingLevel TrustManagerZoneConfig::set_Prompt(PromptingLevel value) {
        this->_prompt = value;
        return get_Prompt();
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    
    
    void UnionCodeGroup::constructor(IMembershipCondition* membershipCondition, PolicyStatement* policy) {
    }
    
    void UnionCodeGroup::constructor(System::Security::SecurityElement* e, PolicyLevel* level) {
    }
    
    CodeGroup* UnionCodeGroup::Copy_7fdc78f7390869fe() {
        return Copy3(true);
    }
    
    CodeGroup* UnionCodeGroup::Copy3(bool childs) {
        UnionCodeGroup *copy = cli::gcnew<UnionCodeGroup>(this->get_MembershipCondition(), this->get_PolicyStatement());
        copy->set_Name(this->get_Name());
        copy->set_Description(this->get_Description());
        if(childs) 
        {
            for(auto tmp_618 : this->get_Children()) {
                auto child = cli::cast<CodeGroup*>(tmp_618);
                {
                    copy->AddChild(child->Copy_7fdc78f7390869fe());
                }
            }
        }
        return copy;
    }
    
    PolicyStatement* UnionCodeGroup::Resolve_e0385e713d5ae5af(Evidence* evidence) {
        if((evidence ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("evidence"));
        }
        if(!(this->get_MembershipCondition()->Check_40359438a47300d0(evidence))) 
        {
            return nullptr;
        }
        System::Security::PermissionSet *ps = this->get_PolicyStatement()->get_PermissionSet()->Copy_cfeae72b3c523c4e();
        if((this->get_Children()->get_Count_8f254f3dd8e2403() > 0)) 
        {
            for(auto tmp_619 : this->get_Children()) {
                auto child_cg = cli::cast<CodeGroup*>(tmp_619);
                {
                    PolicyStatement *child_pst = child_cg->Resolve_e0385e713d5ae5af(evidence);
                    if((child_pst != nullptr)) 
                    {
                        ps = ps->Union(child_pst->get_PermissionSet());
                    }
                }
            }
        }
        PolicyStatement *pst = this->get_PolicyStatement()->Copy();
        pst->set_PermissionSet(ps);
        return pst;
    }
    
    CodeGroup* UnionCodeGroup::ResolveMatchingCodeGroups_908cc5caa682e9f4(Evidence* evidence) {
        if((evidence ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("evidence"));
        }
        if(!(this->get_MembershipCondition()->Check_40359438a47300d0(evidence))) 
        {
            return nullptr;
        }
        CodeGroup *match = Copy3(false);
        if((this->get_Children()->get_Count_8f254f3dd8e2403() > 0)) 
        {
            for(auto tmp_620 : this->get_Children()) {
                auto cg = cli::cast<CodeGroup*>(tmp_620);
                {
                    CodeGroup *child = cg->ResolveMatchingCodeGroups_908cc5caa682e9f4(evidence);
                    if((child != nullptr)) 
                    {
                        match->AddChild(child);
                    }
                }
            }
        }
        return match;
    }
    
    System::String* UnionCodeGroup::get_MergeLogic_cd001da1f3850530() {
        return _T("Union");
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    
    
    void Url::constructor(System::String* name) {
    }
    
    void Url::constructor(System::String* name, bool validated) {
        this->origin_url = validated ? name : Prepare(name);
    }
    
    System::Object* Url::Copy() {
        return cli::gcnew<Url>(this->origin_url, true);
    }
    
    System::Security::IPermission* Url::CreateIdentityPermission(Evidence* evidence) {
        return cli::gcnew<System::Security::Permissions::UrlIdentityPermission>(this->origin_url);
    }
    
    bool Url::Equals_ed975d2f4a7d193e(System::Object* o) {
        Url *u = cli::as<Url*>(o);
        if((u ==  nullptr)) 
        {
            return false;
        }
        System::String *url1 = u->get_Value();
        System::String *url2 = this->origin_url;
        if((url1->IndexOf7(Mono::Security::Uri::SchemeDelimiter) < 0)) 
        {
            url1 = cli::concat(_T("file://"), url1);
        }
        if((url2->IndexOf7(Mono::Security::Uri::SchemeDelimiter) < 0)) 
        {
            url2 = cli::concat(_T("file://"), url2);
        }
        return (System::String::Compare3(url1, url2, true, System::Globalization::CultureInfo::get_InvariantCulture()) ==  0);
    }
    
    int32_t Url::GetHashCode_6648aef0f235ee6c() {
        System::String *s = this->origin_url;
        if((s->IndexOf7(Mono::Security::Uri::SchemeDelimiter) < 0)) 
        {
            s = cli::concat(_T("file://"), s);
        }
        return s->GetHashCode_6648aef0f235ee6c();
    }
    
    System::String* Url::ToString_1636a0751cb9ac11() {
        System::Security::SecurityElement *element = cli::gcnew<System::Security::SecurityElement>(_T("System.Security.Policy.Url"));
        element->AddAttribute(_T("version"), _T("1"));
        element->AddChild(cli::gcnew<System::Security::SecurityElement>(_T("Url"), this->origin_url));
        return element->ToString_1636a0751cb9ac11();
    }
    
    int32_t Url::GetRequiredSize(bool verbose) {
        return (verbose ? 3 : 1 + this->origin_url->get_Length());
    }
    
    int32_t Url::InitFromBuffer(cli::array<char16_t>* buffer, int32_t position) {
        return 0;
    }
    
    int32_t Url::OutputToBuffer(cli::array<char16_t>* buffer, int32_t position, bool verbose) {
        return 0;
    }
    
    System::String* Url::Prepare(System::String* url) {
        if((url ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("Url"));
        }
        if(System::String::op_Equality(url, System::String::Empty)) 
        {
            throw cli::gcnew<System::FormatException>(Locale::GetText(_T("Invalid (empty) Url")));
        }
        int32_t protocolPos = url->IndexOf7(Mono::Security::Uri::SchemeDelimiter);
        if((protocolPos > 0)) 
        {
            if(url->StartsWith(_T("file://"))) 
            {
                url = cli::concat(_T("file://"), url->Substring(7));
            }
            Mono::Security::Uri *uri = cli::gcnew<Mono::Security::Uri>(url, false, false);
            url = uri->ToString_1636a0751cb9ac11();
        }
        int32_t lastpos = (url->get_Length() - 1);
        if(((int32_t)(url->get_Chars(lastpos)) ==  47)) 
        {
            url = url->Substring2(0, lastpos);
        }
        return url;
    }
    
    System::String* Url::get_Value() {
        return this->origin_url;
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    
    
    void UrlMembershipCondition::constructor(System::String* url) {
        if((url ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("url"));
        }
        CheckUrl(url);
        this->userUrl = url;
        this->url = cli::gcnew<Url>(url);
    }
    
    void UrlMembershipCondition::constructor(Url* url, System::String* userUrl) {
        this->url = cli::cast<Url*>(url->Copy());
        this->userUrl = userUrl;
    }
    
    bool UrlMembershipCondition::Check(Evidence* evidence) {
        if((evidence ==  nullptr)) 
        {
            return false;
        }
        System::String *u = this->url->get_Value();
        int32_t wildcard = u->LastIndexOf7(_T("*"));
        if((wildcard ==  -1)) 
        {
            wildcard = u->get_Length();
        }
        System::Collections::IEnumerator *e = evidence->GetHostEnumerator();
        while(e->MoveNext_4e78e145935f5417()) {
            if(cli::is<Url>(e->get_Current_8eca9b3da02b123a())) 
            {
                if((System::String::Compare6(u, 0, cli::as<Url*>(e->get_Current_8eca9b3da02b123a())->get_Value(), 0, wildcard, true, System::Globalization::CultureInfo::get_InvariantCulture()) ==  0)) 
                {
                    return true;
                }
            }
        }
        return false;
    }
    
    IMembershipCondition* UrlMembershipCondition::Copy() {
        return cli::gcnew<UrlMembershipCondition>(this->url, this->userUrl);
    }
    
    bool UrlMembershipCondition::Equals_ed975d2f4a7d193e(System::Object* o) {
        UrlMembershipCondition *umc = cli::as<UrlMembershipCondition*>(o);
        if((o ==  nullptr)) 
        {
            return false;
        }
        System::String *u = this->url->get_Value();
        int32_t length = u->get_Length();
        if(((int32_t)(u->get_Chars((length - 1))) ==  42)) 
        {
            length--;
            if(((int32_t)(u->get_Chars((length - 1))) ==  47)) 
            {
                length--;
            }
        }
        return (System::String::Compare6(u, 0, umc->get_Url(), 0, length, true, System::Globalization::CultureInfo::get_InvariantCulture()) ==  0);
    }
    
    void UrlMembershipCondition::FromXml(System::Security::SecurityElement* e) {
        FromXml2(e, nullptr);
    }
    
    void UrlMembershipCondition::FromXml2(System::Security::SecurityElement* e, PolicyLevel* level) {
        MembershipConditionHelper::CheckSecurityElement(e, _T("e"), this->version, this->version);
        System::String *u = e->Attribute2(_T("Url"));
        if((u != nullptr)) 
        {
            CheckUrl(u);
            this->url = cli::gcnew<Url>(u);
        }
         else 
        {
            this->url = nullptr;
        }
        this->userUrl = u;
    }
    
    int32_t UrlMembershipCondition::GetHashCode_6648aef0f235ee6c() {
        return this->url->GetHashCode_6648aef0f235ee6c();
    }
    
    System::String* UrlMembershipCondition::ToString_1636a0751cb9ac11() {
        return cli::concat(_T("Url - "), this->get_Url());
    }
    
    System::Security::SecurityElement* UrlMembershipCondition::ToXml() {
        return ToXml2(nullptr);
    }
    
    System::Security::SecurityElement* UrlMembershipCondition::ToXml2(PolicyLevel* level) {
        System::Security::SecurityElement *se = MembershipConditionHelper::Element2(cli::typeof<System::Type>::info, this->version);
        se->AddAttribute(_T("Url"), this->userUrl);
        return se;
    }
    
    void UrlMembershipCondition::CheckUrl(System::String* url) {
        int32_t protocolPos = url->IndexOf7(Mono::Security::Uri::SchemeDelimiter);
        System::String *u = (protocolPos < 0) ? cli::concat(_T("file://"), url) : url;
        Mono::Security::Uri *uri = cli::gcnew<Mono::Security::Uri>(u, false, false);
        if((uri->get_Host()->IndexOf4(u'*') >= 1)) 
        {
            System::String *msg = Locale::GetText(_T("Invalid * character in url"));
            throw cli::gcnew<System::ArgumentException>(msg, _T("name"));
        }
    }
    
    System::String* UrlMembershipCondition::get_Url() {
        if((this->userUrl ==  nullptr)) 
        {
            this->userUrl = this->url->get_Value();
        }
        return this->userUrl;
    }
    
    System::String* UrlMembershipCondition::set_Url(System::String* value) {
        this->url = cli::gcnew<Url>(value);
        return get_Url();
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    
    
    void Zone::constructor(System::Security::SecurityZone zone) {
        if(!(System::Enum::IsDefined(cli::typeof<System::Type>::info, cli::box(zone)))) 
        {
            System::String *msg = System::String::Format2(Locale::GetText(_T("Invalid zone {0}.")), cli::box(zone));
            throw cli::gcnew<System::ArgumentException>(msg, _T("zone"));
        }
        this->zone = zone;
    }
    
    System::Object* Zone::Copy() {
        return cli::gcnew<Zone>(this->zone);
    }
    
    System::Security::IPermission* Zone::CreateIdentityPermission(Evidence* evidence) {
        return cli::gcnew<System::Security::Permissions::ZoneIdentityPermission>(this->zone);
    }
    
    Zone* Zone::CreateFromUrl(System::String* url) {
        if((url ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("url"));
        }
        System::Security::SecurityZone z = System::Security::SecurityZone::NoZone;
        if((url->get_Length() ==  0)) 
        {
            return cli::gcnew<Zone>(z);
        }
        Mono::Security::Uri *uri = cli::gcnew<Mono::Security::Uri>(url);
        if(((int32_t)(z) ==  -1)) 
        {
            if(uri->get_IsFile()) 
            {
                if(System::IO::File::Exists(uri->get_LocalPath())) 
                {
                    z = System::Security::SecurityZone::MyComputer;
                }
                 else 
                {
                    if((System::String::Compare6(_T("FILE://"), 0, url, 0, 7, true, System::Globalization::CultureInfo::get_InvariantCulture()) ==  0)) 
                    {
                        z = System::Security::SecurityZone::Intranet;
                    }
                     else 
                    {
                        z = System::Security::SecurityZone::Internet;
                    }
                }
            }
             else 
            {
                if(uri->get_IsLoopback()) 
                {
                    z = System::Security::SecurityZone::Intranet;
                }
                 else 
                {
                    z = System::Security::SecurityZone::Internet;
                }
            }
        }
        return cli::gcnew<Zone>(z);
    }
    
    bool Zone::Equals_ed975d2f4a7d193e(System::Object* o) {
        Zone *z = cli::as<Zone*>(o);
        if((z ==  nullptr)) 
        {
            return false;
        }
        return ((int32_t)(z->zone) ==  (int32_t)(this->zone));
    }
    
    int32_t Zone::GetHashCode_6648aef0f235ee6c() {
        return (int32_t)(this->zone);
    }
    
    System::String* Zone::ToString_1636a0751cb9ac11() {
        System::Security::SecurityElement *se = cli::gcnew<System::Security::SecurityElement>(_T("System.Security.Policy.Zone"));
        se->AddAttribute(_T("version"), _T("1"));
        se->AddChild(cli::gcnew<System::Security::SecurityElement>(_T("Zone"), cli::import(this->zone)->ToString_1636a0751cb9ac11()));
        return se->ToString_1636a0751cb9ac11();
    }
    
    int32_t Zone::GetRequiredSize(bool verbose) {
        return 3;
    }
    
    int32_t Zone::InitFromBuffer(cli::array<char16_t>* buffer, int32_t position) {
        int32_t new_zone = (int32_t)(buffer->at(position++));
        (new_zone = new_zone + (int32_t)(buffer->at(position++)));
        return position;
    }
    
    int32_t Zone::OutputToBuffer(cli::array<char16_t>* buffer, int32_t position, bool verbose) {
        buffer->at(position++) = u'\x3';
        buffer->at(position++) = (char16_t)((int32_t)(this->zone) >> 16);
        buffer->at(position++) = (char16_t)((int32_t)(this->zone) & 65535);
        return position;
    }
    
    System::Security::SecurityZone Zone::get_SecurityZone() {
        return this->zone;
    }
    
}}}
namespace System { namespace Security { namespace Policy {
    
    
    void ZoneMembershipCondition::constructor() {
    }
    
    void ZoneMembershipCondition::constructor(System::Security::SecurityZone zone) {
        this->set_SecurityZone(zone);
    }
    
    bool ZoneMembershipCondition::Check(Evidence* evidence) {
        if((evidence ==  nullptr)) 
        {
            return false;
        }
        System::Collections::IEnumerator *e = evidence->GetHostEnumerator();
        while(e->MoveNext_4e78e145935f5417()) {
            Zone *z = cli::as<Zone*>(e->get_Current_8eca9b3da02b123a());
            if((z != nullptr)) 
            {
                if(((int32_t)(z->get_SecurityZone()) ==  (int32_t)(this->zone))) 
                {
                    return true;
                }
            }
        }
        return false;
    }
    
    IMembershipCondition* ZoneMembershipCondition::Copy() {
        return cli::gcnew<ZoneMembershipCondition>(this->zone);
    }
    
    bool ZoneMembershipCondition::Equals_ed975d2f4a7d193e(System::Object* o) {
        ZoneMembershipCondition *zmc = cli::as<ZoneMembershipCondition*>(o);
        if((zmc ==  nullptr)) 
        {
            return false;
        }
        return ((int32_t)(zmc->get_SecurityZone()) ==  (int32_t)(this->zone));
    }
    
    void ZoneMembershipCondition::FromXml(System::Security::SecurityElement* e) {
        FromXml2(e, nullptr);
    }
    
    void ZoneMembershipCondition::FromXml2(System::Security::SecurityElement* e, PolicyLevel* level) {
        MembershipConditionHelper::CheckSecurityElement(e, _T("e"), this->version, this->version);
        System::String *z = e->Attribute2(_T("Zone"));
        if((z != nullptr)) 
        {
            this->zone = cli::unbox<System::Security::SecurityZone>(System::Enum::Parse(cli::typeof<System::Type>::info, z));
        }
    }
    
    int32_t ZoneMembershipCondition::GetHashCode_6648aef0f235ee6c() {
        return cli::import(this->zone)->GetHashCode_6648aef0f235ee6c();
    }
    
    System::String* ZoneMembershipCondition::ToString_1636a0751cb9ac11() {
        return cli::concat(_T("Zone - "), cli::box(this->zone));
    }
    
    System::Security::SecurityElement* ZoneMembershipCondition::ToXml() {
        return ToXml2(nullptr);
    }
    
    System::Security::SecurityElement* ZoneMembershipCondition::ToXml2(PolicyLevel* level) {
        System::Security::SecurityElement *se = MembershipConditionHelper::Element2(cli::typeof<System::Type>::info, this->version);
        se->AddAttribute(_T("Zone"), cli::import(this->zone)->ToString_1636a0751cb9ac11());
        return se;
    }
    
    System::Security::SecurityZone ZoneMembershipCondition::get_SecurityZone() {
        return this->zone;
    }
    
    System::Security::SecurityZone ZoneMembershipCondition::set_SecurityZone(System::Security::SecurityZone value) {
        if(!(System::Enum::IsDefined(cli::typeof<System::Type>::info, cli::box(value)))) 
        {
            throw cli::gcnew<System::ArgumentException>(Locale::GetText(_T("invalid zone")));
        }
        if(((int32_t)(value) ==  -1)) 
        {
            throw cli::gcnew<System::ArgumentException>(Locale::GetText(_T("NoZone isn\'t valid for membership condition")));
        }
        this->zone = value;
        return get_SecurityZone();
    }
    
}}}
namespace System { namespace Security { namespace Principal {
    
    
    void GenericIdentity::constructor(System::String* name, System::String* type) {
        if((name ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("name"));
        }
        if((type ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("type"));
        }
        this->m_name = name;
        this->m_type = type;
    }
    
    void GenericIdentity::constructor(System::String* name) {
    }
    
    System::String* GenericIdentity::get_AuthenticationType_cb7e4615cad01a4c() {
        return this->m_type;
    }
    
    System::String* GenericIdentity::get_Name_e32680458218f597() {
        return this->m_name;
    }
    
    bool GenericIdentity::get_IsAuthenticated_d3ad26d9503a0e79() {
        return (this->m_name->get_Length() > 0);
    }
    
}}}
namespace System { namespace Security { namespace Principal {
    
    
    void GenericPrincipal::constructor(IIdentity* identity, cli::array<System::String*>* roles) {
        if((identity ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("identity"));
        }
        this->m_identity = identity;
        if((roles != nullptr)) 
        {
            this->m_roles = (new cli::array<System::String*>(roles->get_Length()));
            for(int32_t i = 0; (i < roles->get_Length()); i++) {
                this->m_roles->at(i) = roles->at(i);
            }
        }
    }
    
    bool GenericPrincipal::IsInRole_230762285381dcaa(System::String* role) {
        if((this->m_roles ==  nullptr)) 
        {
            return false;
        }
        int32_t l = role->get_Length();
        for(auto tmp_621 : this->m_roles) {
            auto r = cli::cast<System::String*>(tmp_621);
            {
                if(((r != nullptr) && (l ==  r->get_Length()))) 
                {
                    if((System::String::Compare5(role, 0, r, 0, l, true) ==  0)) 
                    {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    
    cli::array<System::String*>* GenericPrincipal::get_Roles() {
        return this->m_roles;
    }
    
    IIdentity* GenericPrincipal::get_Identity_ace87d10090e7749() {
        return this->m_identity;
    }
    
}}}
namespace System { namespace Security { namespace Principal {
    
    
    void IdentityNotMappedException::constructor() {
    }
    
    void IdentityNotMappedException::constructor(System::String* message) {
    }
    
    void IdentityNotMappedException::constructor(System::String* message, System::Exception* inner) {
    }
    
    void IdentityNotMappedException::GetObjectData_bc9b88d7eb43b6d8(System::Runtime::Serialization::SerializationInfo* serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext) {
    }
    
    IdentityReferenceCollection* IdentityNotMappedException::get_UnmappedIdentities() {
        if((this->_coll ==  nullptr)) 
        {
            this->_coll = cli::gcnew<IdentityReferenceCollection>();
        }
        return this->_coll;
    }
    
}}}
namespace System { namespace Security { namespace Principal {
    
    
    void IdentityReference::constructor() {
    }
    
    bool IdentityReference::op_Equality(IdentityReference* left, IdentityReference* right) {
        if((cli::cast<System::Object*>(left) ==  nullptr)) 
        {
            return (cli::cast<System::Object*>(right) ==  nullptr);
        }
        if((cli::cast<System::Object*>(right) ==  nullptr)) 
        {
            return false;
        }
        return System::String::op_Equality(left->get_Value_31a6ad648afbd5f5(), right->get_Value_31a6ad648afbd5f5());
    }
    
    bool IdentityReference::op_Inequality(IdentityReference* left, IdentityReference* right) {
        if((cli::cast<System::Object*>(left) ==  nullptr)) 
        {
            return (cli::cast<System::Object*>(right) != nullptr);
        }
        if((cli::cast<System::Object*>(right) ==  nullptr)) 
        {
            return true;
        }
        return System::String::op_Inequality(left->get_Value_31a6ad648afbd5f5(), right->get_Value_31a6ad648afbd5f5());
    }
    
}}}
namespace System { namespace Security { namespace Principal {
    
    
    void IdentityReferenceCollection::constructor() {
        this->_list = cli::gcnew<System::Collections::ArrayList>();
    }
    
    void IdentityReferenceCollection::constructor(int32_t capacity) {
        this->_list = cli::gcnew<System::Collections::ArrayList>(capacity);
    }
    
    void IdentityReferenceCollection::Add(IdentityReference* identity) {
        this->_list->Add_e6a92085999ce388(identity);
    }
    
    void IdentityReferenceCollection::Clear() {
        this->_list->Clear_cd6654e5a40f5056();
    }
    
    bool IdentityReferenceCollection::Contains(IdentityReference* identity) {
        for(auto tmp_622 : this->_list) {
            auto id = cli::cast<IdentityReference*>(tmp_622);
            {
                if(id->Equals_ed975d2f4a7d193e(identity)) 
                {
                    return true;
                }
            }
        }
        return false;
    }
    
    void IdentityReferenceCollection::CopyTo(cli::array<IdentityReference*>* array, int32_t offset) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    System::Collections::Generic::IEnumerator2<IdentityReference*>* IdentityReferenceCollection::GetEnumerator() {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    System::Collections::IEnumerator* IdentityReferenceCollection::GetEnumerator2() {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool IdentityReferenceCollection::Remove(IdentityReference* identity) {
        for(auto tmp_623 : this->_list) {
            auto id = cli::cast<IdentityReference*>(tmp_623);
            {
                if(id->Equals_ed975d2f4a7d193e(identity)) 
                {
                    this->_list->Remove_2225381aaf812c6d(id);
                    return true;
                }
            }
        }
        return false;
    }
    
    IdentityReferenceCollection* IdentityReferenceCollection::Translate(System::Type* targetType) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    IdentityReferenceCollection* IdentityReferenceCollection::Translate2(System::Type* targetType, bool forceSuccess) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t IdentityReferenceCollection::get_Count() {
        return this->_list->get_Count_2354963792616712();
    }
    
    bool IdentityReferenceCollection::get_IsReadOnly() {
        return false;
    }
    
    IdentityReference* IdentityReferenceCollection::get_Item(int32_t index) {
        if((index >= this->_list->get_Count_2354963792616712())) 
        {
            return nullptr;
        }
        return cli::cast<IdentityReference*>(this->_list->get_Item_fd0155f142ae570(index));
    }
    
    IdentityReference* IdentityReferenceCollection::set_Item(int32_t index, IdentityReference* value) {
        this->_list->set_Item_9f12782653a34813(index, value);
        return get_Item(index);
    }
    
}}}
namespace System { namespace Security { namespace Principal {
    
    
    void NTAccount::constructor(System::String* name) {
        if((name ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("name"));
        }
        if((name->get_Length() ==  0)) 
        {
            throw cli::gcnew<System::ArgumentException>(Locale::GetText(_T("Empty")), _T("name"));
        }
        this->_value = name;
    }
    
    void NTAccount::constructor(System::String* domainName, System::String* accountName) {
        if((accountName ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("accountName"));
        }
        if((accountName->get_Length() ==  0)) 
        {
            throw cli::gcnew<System::ArgumentException>(Locale::GetText(_T("Empty")), _T("accountName"));
        }
        if((domainName ==  nullptr)) 
        {
            this->_value = accountName;
        }
         else 
        {
            this->_value = cli::concat(domainName, _T("\\"));
        }
    }
    
    bool NTAccount::Equals_ed975d2f4a7d193e(System::Object* o) {
        NTAccount *nt = cli::as<NTAccount*>(o);
        if(op_Equality2(nt, nullptr)) 
        {
            return false;
        }
        return System::String::op_Equality(nt->get_Value_31a6ad648afbd5f5(), this->get_Value_31a6ad648afbd5f5());
    }
    
    int32_t NTAccount::GetHashCode_6648aef0f235ee6c() {
        return this->get_Value_31a6ad648afbd5f5()->GetHashCode_6648aef0f235ee6c();
    }
    
    bool NTAccount::IsValidTargetType_23b55042c769999c(System::Type* targetType) {
        if(System::Type::op_Equality2(targetType, cli::typeof<System::Type>::info)) 
        {
            return true;
        }
        if(System::Type::op_Equality2(targetType, cli::typeof<System::Type>::info)) 
        {
            return true;
        }
        return false;
    }
    
    System::String* NTAccount::ToString_1636a0751cb9ac11() {
        return this->get_Value_31a6ad648afbd5f5();
    }
    
    IdentityReference* NTAccount::Translate_1920497c56851819(System::Type* targetType) {
        if(System::Type::op_Equality2(targetType, cli::typeof<System::Type>::info)) 
        {
            return this;
        }
        if(System::Type::op_Equality2(targetType, cli::typeof<System::Type>::info)) 
        {
            WellKnownAccount *acct = WellKnownAccount::LookupByName(this->get_Value_31a6ad648afbd5f5());
            if(((acct ==  nullptr) || (acct->get_Sid() ==  nullptr))) 
            {
                throw cli::gcnew<IdentityNotMappedException>(cli::concat(_T("Cannot map account name: "), this->get_Value_31a6ad648afbd5f5()));
            }
            return cli::gcnew<SecurityIdentifier>(acct->get_Sid());
        }
        throw cli::gcnew<System::ArgumentException>(_T("Unknown type"), _T("targetType"));
    }
    
    bool NTAccount::op_Equality2(NTAccount* left, NTAccount* right) {
        if((cli::cast<System::Object*>(left) ==  nullptr)) 
        {
            return (cli::cast<System::Object*>(right) ==  nullptr);
        }
        if((cli::cast<System::Object*>(right) ==  nullptr)) 
        {
            return false;
        }
        return System::String::op_Equality(left->get_Value_31a6ad648afbd5f5(), right->get_Value_31a6ad648afbd5f5());
    }
    
    bool NTAccount::op_Inequality2(NTAccount* left, NTAccount* right) {
        if((cli::cast<System::Object*>(left) ==  nullptr)) 
        {
            return (cli::cast<System::Object*>(right) != nullptr);
        }
        if((cli::cast<System::Object*>(right) ==  nullptr)) 
        {
            return true;
        }
        return System::String::op_Inequality(left->get_Value_31a6ad648afbd5f5(), right->get_Value_31a6ad648afbd5f5());
    }
    
    System::String* NTAccount::get_Value_31a6ad648afbd5f5() {
        return this->_value;
    }
    
}}}
namespace System { namespace Security { namespace Principal {
    
    int32_t  SecurityIdentifier::MaxBinaryLength;
    int32_t  SecurityIdentifier::MinBinaryLength;
    
    SecurityIdentifier::SecurityIdentifier()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void SecurityIdentifier::constructor(System::String* sddlForm) {
        if((sddlForm ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("sddlForm"));
        }
        this->buffer = ParseSddlForm2(sddlForm);
    }
    
    void SecurityIdentifier::constructor(cli::array<unsigned char>* binaryForm, int32_t offset) {
        if((binaryForm ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("binaryForm"));
        }
        if(((offset < 0) || (offset > (binaryForm->get_Length() - 2)))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("offset"));
        }
        int32_t revision = (int32_t)(binaryForm->at(offset));
        int32_t numSubAuthorities = (int32_t)(binaryForm->at((offset + 1)));
        if(((revision != 1) || (numSubAuthorities > 15))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Value was invalid."));
        }
        if((offset > (binaryForm->get_Length() - (8 + (numSubAuthorities * 4))))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("offset"));
        }
        this->buffer = (new cli::array<unsigned char>((8 + (numSubAuthorities * 4))));
        System::Array::Copy2(binaryForm, offset, this->buffer, 0, this->buffer->get_Length());
    }
    
    void SecurityIdentifier::constructor(void* binaryForm) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    void SecurityIdentifier::constructor(WellKnownSidType sidType, SecurityIdentifier* domainSid) {
        WellKnownAccount *acct = WellKnownAccount::LookupByType(sidType);
        if((acct ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentException>(cli::concat(_T("Unable to convert SID type: "), cli::box(sidType)));
        }
        if(acct->get_IsAbsolute()) 
        {
            this->buffer = ParseSddlForm2(acct->get_Sid());
        }
         else 
        {
            if(op_Equality2(domainSid, nullptr)) 
            {
                throw cli::gcnew<System::ArgumentNullException>(_T("domainSid"));
            }
            this->buffer = ParseSddlForm2(cli::concat(domainSid->get_Value_31a6ad648afbd5f5(), _T("-")));
        }
    }
    
    void SecurityIdentifier::static_constructor() {
    }
    
    int32_t SecurityIdentifier::CompareTo(SecurityIdentifier* sid) {
        return this->get_Value_31a6ad648afbd5f5()->CompareTo2(sid->get_Value_31a6ad648afbd5f5());
    }
    
    bool SecurityIdentifier::Equals_ed975d2f4a7d193e(System::Object* o) {
        return Equals2(cli::as<SecurityIdentifier*>(o));
    }
    
    bool SecurityIdentifier::Equals2(SecurityIdentifier* sid) {
        if(op_Equality2(sid, nullptr)) 
        {
            return false;
        }
        return System::String::op_Equality(sid->get_Value_31a6ad648afbd5f5(), this->get_Value_31a6ad648afbd5f5());
    }
    
    void SecurityIdentifier::GetBinaryForm(cli::array<unsigned char>* binaryForm, int32_t offset) {
        if((binaryForm ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("binaryForm"));
        }
        if(((offset < 0) || (offset > (binaryForm->get_Length() - this->buffer->get_Length())))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("offset"));
        }
        System::Array::Copy2(this->buffer, 0, binaryForm, offset, this->buffer->get_Length());
    }
    
    int32_t SecurityIdentifier::GetHashCode_6648aef0f235ee6c() {
        return this->get_Value_31a6ad648afbd5f5()->GetHashCode_6648aef0f235ee6c();
    }
    
    bool SecurityIdentifier::IsAccountSid() {
        return op_Inequality2(this->get_AccountDomainSid(), nullptr);
    }
    
    bool SecurityIdentifier::IsEqualDomainSid(SecurityIdentifier* sid) {
        SecurityIdentifier *domSid = this->get_AccountDomainSid();
        if(op_Equality2(domSid, nullptr)) 
        {
            return false;
        }
        return domSid->Equals2(sid->get_AccountDomainSid());
    }
    
    bool SecurityIdentifier::IsValidTargetType_23b55042c769999c(System::Type* targetType) {
        if(System::Type::op_Equality2(targetType, cli::typeof<System::Type>::info)) 
        {
            return true;
        }
        if(System::Type::op_Equality2(targetType, cli::typeof<System::Type>::info)) 
        {
            return true;
        }
        return false;
    }
    
    bool SecurityIdentifier::IsWellKnown(WellKnownSidType type) {
        WellKnownAccount *acct = WellKnownAccount::LookupByType(type);
        if((acct ==  nullptr)) 
        {
            return false;
        }
        System::String *sid = this->get_Value_31a6ad648afbd5f5();
        if(acct->get_IsAbsolute()) 
        {
            return System::String::op_Equality(sid, acct->get_Sid());
        }
        return (sid->StartsWith2(_T("S-1-5-21"), System::StringComparison::OrdinalIgnoreCase) && sid->EndsWith3(cli::concat(_T("-"), acct->get_Rid()), System::StringComparison::OrdinalIgnoreCase));
    }
    
    System::String* SecurityIdentifier::ToString_1636a0751cb9ac11() {
        return this->get_Value_31a6ad648afbd5f5();
    }
    
    IdentityReference* SecurityIdentifier::Translate_1920497c56851819(System::Type* targetType) {
        if(System::Type::op_Equality2(targetType, cli::typeof<System::Type>::info)) 
        {
            return this;
        }
        if(System::Type::op_Equality2(targetType, cli::typeof<System::Type>::info)) 
        {
            WellKnownAccount *acct = WellKnownAccount::LookupBySid(this->get_Value_31a6ad648afbd5f5());
            if(((acct ==  nullptr) || (acct->get_Name() ==  nullptr))) 
            {
                throw cli::gcnew<IdentityNotMappedException>(cli::concat(_T("Unable to map SID: "), this->get_Value_31a6ad648afbd5f5()));
            }
            return cli::gcnew<NTAccount>(acct->get_Name());
        }
        throw cli::gcnew<System::ArgumentException>(_T("Unknown type."), _T("targetType"));
    }
    
    System::String* SecurityIdentifier::GetSddlForm() {
        System::String *sidString = this->get_Value_31a6ad648afbd5f5();
        WellKnownAccount *acct = WellKnownAccount::LookupBySid(sidString);
        if(((acct ==  nullptr) || (acct->get_SddlForm() ==  nullptr))) 
        {
            return sidString;
        }
        return acct->get_SddlForm();
    }
    
    SecurityIdentifier* SecurityIdentifier::ParseSddlForm(System::String* sddlForm, int32_t pos) {
        if(((sddlForm->get_Length() - pos) < 2)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Invalid SDDL string."), _T("sddlForm"));
        }
        System::String *sid;
        int32_t len;
        System::String *prefix = sddlForm->Substring2(pos, 2)->ToUpperInvariant();
        if(System::String::op_Equality(prefix, _T("S-"))) 
        {
            int32_t endPos = pos;
            char16_t ch = System::Char::ToUpperInvariant(sddlForm->get_Chars(endPos));
            while(((((((int32_t)(ch) ==  83) || ((int32_t)(ch) ==  45)) || ((int32_t)(ch) ==  88)) || (((int32_t)(ch) >= 48) && ((int32_t)(ch) <= 57))) || (((int32_t)(ch) >= 65) && ((int32_t)(ch) <= 70)))) {
                ++endPos;
                ch = System::Char::ToUpperInvariant(sddlForm->get_Chars(endPos));
            }
            sid = sddlForm->Substring2(pos, (endPos - pos));
            len = (endPos - pos);
        }
         else 
        {
            sid = prefix;
            len = 2;
        }
        SecurityIdentifier *ret = cli::gcnew<SecurityIdentifier>(sid);
        (pos = pos + len);
        return ret;
    }
    
    cli::array<unsigned char>* SecurityIdentifier::ParseSddlForm2(System::String* sddlForm) {
        System::String *sid = sddlForm;
        if((sddlForm->get_Length() ==  2)) 
        {
            WellKnownAccount *acct = WellKnownAccount::LookupBySddlForm(sddlForm);
            if((acct ==  nullptr)) 
            {
                throw cli::gcnew<System::ArgumentException>(cli::concat(_T("Invalid SDDL string - unrecognized account: "), sddlForm), _T("sddlForm"));
            }
            if(!(acct->get_IsAbsolute())) 
            {
                throw cli::gcnew<System::NotImplementedException>(cli::concat(_T("Mono unable to convert account to SID: "), (acct->get_Name() != nullptr) ? acct->get_Name() : sddlForm));
            }
            sid = acct->get_Sid();
        }
        cli::array<System::String*> *elements = sid->ToUpperInvariant()->Split((new cli::array<char16_t>({u'-'})));
        int32_t numSubAuthorities = (elements->get_Length() - 3);
        if((((elements->get_Length() < 3) || System::String::op_Inequality(elements->at(0), _T("S"))) || (numSubAuthorities > 15))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Value was invalid."));
        }
        if(System::String::op_Inequality(elements->at(1), _T("1"))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Only SIDs with revision 1 are supported"));
        }
        cli::array<unsigned char> *buffer = (new cli::array<unsigned char>((8 + (numSubAuthorities * 4))));
        buffer->at(0) = 1;
        buffer->at(1) = (unsigned char)numSubAuthorities;
        uint64_t authority;
        if(!(TryParseAuthority(elements->at(2), authority))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Value was invalid."));
        }
        buffer->at(2) = (unsigned char)((authority >> 40) & 255UL);
        buffer->at(3) = (unsigned char)((authority >> 32) & 255UL);
        buffer->at(4) = (unsigned char)((authority >> 24) & 255UL);
        buffer->at(5) = (unsigned char)((authority >> 16) & 255UL);
        buffer->at(6) = (unsigned char)((authority >> 8) & 255UL);
        buffer->at(7) = (unsigned char)(authority & 255UL);
        for(int32_t i = 0; (i < numSubAuthorities); ++i){
            uint32_t subAuthority;
            if(!(TryParseSubAuthority(elements->at((i + 3)), subAuthority))) 
            {
                throw cli::gcnew<System::ArgumentException>(_T("Value was invalid."));
            }
            int32_t offset = (8 + (i * 4));
            buffer->at(offset) = (unsigned char)subAuthority;
            buffer->at((offset + 1)) = (unsigned char)(subAuthority >> 8);
            buffer->at((offset + 2)) = (unsigned char)(subAuthority >> 16);
            buffer->at((offset + 3)) = (unsigned char)(subAuthority >> 24);
        }
        return buffer;
    }
    
    bool SecurityIdentifier::TryParseAuthority(System::String* s, uint64_t result) {
        if(s->StartsWith(_T("0X"))) 
        {
            return System::UInt64::TryParse2(s->Substring(2), System::Globalization::NumberStyles::HexNumber, System::Globalization::CultureInfo::get_InvariantCulture(), result);
        }
         else 
        {
            return System::UInt64::TryParse2(s, System::Globalization::NumberStyles::Integer, System::Globalization::CultureInfo::get_InvariantCulture(), result);
        }
    }
    
    bool SecurityIdentifier::TryParseSubAuthority(System::String* s, uint32_t result) {
        if(s->StartsWith(_T("0X"))) 
        {
            return System::UInt32::TryParse2(s->Substring(2), System::Globalization::NumberStyles::HexNumber, System::Globalization::CultureInfo::get_InvariantCulture(), result);
        }
         else 
        {
            return System::UInt32::TryParse2(s, System::Globalization::NumberStyles::Integer, System::Globalization::CultureInfo::get_InvariantCulture(), result);
        }
    }
    
    bool SecurityIdentifier::op_Equality2(SecurityIdentifier* left, SecurityIdentifier* right) {
        if((cli::cast<System::Object*>(left) ==  nullptr)) 
        {
            return (cli::cast<System::Object*>(right) ==  nullptr);
        }
        if((cli::cast<System::Object*>(right) ==  nullptr)) 
        {
            return false;
        }
        return System::String::op_Equality(left->get_Value_31a6ad648afbd5f5(), right->get_Value_31a6ad648afbd5f5());
    }
    
    bool SecurityIdentifier::op_Inequality2(SecurityIdentifier* left, SecurityIdentifier* right) {
        if((cli::cast<System::Object*>(left) ==  nullptr)) 
        {
            return (cli::cast<System::Object*>(right) != nullptr);
        }
        if((cli::cast<System::Object*>(right) ==  nullptr)) 
        {
            return true;
        }
        return System::String::op_Inequality(left->get_Value_31a6ad648afbd5f5(), right->get_Value_31a6ad648afbd5f5());
    }
    
    SecurityIdentifier* SecurityIdentifier::get_AccountDomainSid() {
        System::String *strForm = this->get_Value_31a6ad648afbd5f5();
        if((!(strForm->StartsWith(_T("S-1-5-21"))) || ((int32_t)(this->buffer->at(1)) < 4))) 
        {
            return nullptr;
        }
        cli::array<unsigned char> *temp = (new cli::array<unsigned char>(24));
        System::Array::Copy2(this->buffer, 0, temp, 0, temp->get_Length());
        temp->at(1) = 4;
        return cli::gcnew<SecurityIdentifier>(temp, 0);
    }
    
    int32_t SecurityIdentifier::get_BinaryLength() {
        return this->buffer->get_Length();
    }
    
    System::String* SecurityIdentifier::get_Value_31a6ad648afbd5f5() {
        System::Text::StringBuilder *s = cli::gcnew<System::Text::StringBuilder>();
        uint64_t authority = (((((((uint64_t)(this->buffer->at(2)) << 40) | ((uint64_t)(this->buffer->at(3)) << 32)) | ((uint64_t)(this->buffer->at(4)) << 24)) | ((uint64_t)(this->buffer->at(5)) << 16)) | ((uint64_t)(this->buffer->at(6)) << 8)) | (uint64_t)(this->buffer->at(7)));
        s->AppendFormat2(System::Globalization::CultureInfo::get_InvariantCulture(), _T("S-1-{0}"), (new cli::array<System::Object*>({cli::box(authority)})));
        for(int32_t i = 0; (i < (int32_t)(this->buffer->at(1))); ++i){
            int32_t offset = (8 + (i * 4));
            uint32_t subAuthority = ((((uint32_t)(this->buffer->at(offset)) | ((uint32_t)(this->buffer->at((offset + 1))) << 8)) | ((uint32_t)(this->buffer->at((offset + 2))) << 16)) | ((uint32_t)(this->buffer->at((offset + 3))) << 24));
            s->AppendFormat2(System::Globalization::CultureInfo::get_InvariantCulture(), _T("-{0}"), (new cli::array<System::Object*>({cli::box(subAuthority)})));
        }
        return s->ToString_1636a0751cb9ac11();
    }
    
}}}
namespace System { namespace Security { namespace Principal {
    
    cli::array<WellKnownAccount*>*  WellKnownAccount::accounts;
    
    WellKnownAccount::WellKnownAccount()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void WellKnownAccount::constructor() {
    }
    
    void WellKnownAccount::static_constructor() {
    }
    
    WellKnownAccount* WellKnownAccount::LookupByType(WellKnownSidType sidType) {
        for(auto tmp_624 : accounts) {
            auto acct = cli::cast<WellKnownAccount*>(tmp_624);
            {
                if(((int32_t)(acct->get_WellKnownValue()) ==  (int32_t)(sidType))) 
                {
                    return acct;
                }
            }
        }
        return nullptr;
    }
    
    WellKnownAccount* WellKnownAccount::LookupBySid(System::String* s) {
        for(auto tmp_625 : accounts) {
            auto acct = cli::cast<WellKnownAccount*>(tmp_625);
            {
                if(System::String::op_Equality(acct->get_Sid(), s)) 
                {
                    return acct;
                }
            }
        }
        return nullptr;
    }
    
    WellKnownAccount* WellKnownAccount::LookupByName(System::String* s) {
        for(auto tmp_626 : accounts) {
            auto acct = cli::cast<WellKnownAccount*>(tmp_626);
            {
                if(System::String::op_Equality(acct->get_Name(), s)) 
                {
                    return acct;
                }
            }
        }
        return nullptr;
    }
    
    WellKnownAccount* WellKnownAccount::LookupBySddlForm(System::String* s) {
        for(auto tmp_627 : accounts) {
            auto acct = cli::cast<WellKnownAccount*>(tmp_627);
            {
                if(System::String::op_Equality(acct->get_SddlForm(), s)) 
                {
                    return acct;
                }
            }
        }
        return nullptr;
    }
    
    WellKnownSidType WellKnownAccount::get_WellKnownValue() {
        return this->_WellKnownValue_k__BackingField;
    }
    
    WellKnownSidType WellKnownAccount::set_WellKnownValue(WellKnownSidType value) {
        this->_WellKnownValue_k__BackingField = value;
        return get_WellKnownValue();
    }
    
    bool WellKnownAccount::get_IsAbsolute() {
        return this->_IsAbsolute_k__BackingField;
    }
    
    bool WellKnownAccount::set_IsAbsolute(bool value) {
        this->_IsAbsolute_k__BackingField = value;
        return get_IsAbsolute();
    }
    
    System::String* WellKnownAccount::get_Sid() {
        return this->_Sid_k__BackingField;
    }
    
    System::String* WellKnownAccount::set_Sid(System::String* value) {
        this->_Sid_k__BackingField = value;
        return get_Sid();
    }
    
    System::String* WellKnownAccount::get_Rid() {
        return this->_Rid_k__BackingField;
    }
    
    System::String* WellKnownAccount::set_Rid(System::String* value) {
        this->_Rid_k__BackingField = value;
        return get_Rid();
    }
    
    System::String* WellKnownAccount::get_Name() {
        return this->_Name_k__BackingField;
    }
    
    System::String* WellKnownAccount::set_Name(System::String* value) {
        this->_Name_k__BackingField = value;
        return get_Name();
    }
    
    System::String* WellKnownAccount::get_SddlForm() {
        return this->_SddlForm_k__BackingField;
    }
    
    System::String* WellKnownAccount::set_SddlForm(System::String* value) {
        this->_SddlForm_k__BackingField = value;
        return get_SddlForm();
    }
    
}}}
namespace System { namespace Security { namespace Principal {
    
    void*  WindowsIdentity::invalidWindows;
    
    WindowsIdentity::WindowsIdentity()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void WindowsIdentity::constructor(void* userToken) {
    }
    
    void WindowsIdentity::constructor(void* userToken, System::String* type) {
    }
    
    void WindowsIdentity::constructor(void* userToken, System::String* type, WindowsAccountType acctType) {
    }
    
    void WindowsIdentity::constructor(void* userToken, System::String* type, WindowsAccountType acctType, bool isAuthenticated) {
        this->_type = type;
        this->_account = acctType;
        this->_authenticated = isAuthenticated;
        this->_name = nullptr;
        SetToken(userToken);
    }
    
    void WindowsIdentity::constructor(System::String* sUserPrincipalName) {
    }
    
    void WindowsIdentity::constructor(System::String* sUserPrincipalName, System::String* type) {
        if((sUserPrincipalName ==  nullptr)) 
        {
            throw cli::gcnew<System::NullReferenceException>(_T("sUserPrincipalName"));
        }
        void *token = GetUserToken(sUserPrincipalName);
        if((!(System::Environment::get_IsUnix()) && ::System::IntPtr::op_Equality(token, (*::System::IntPtr::Zero)))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("only for Windows Server 2003 +"));
        }
        this->_authenticated = true;
        this->_account = WindowsAccountType::Normal;
        this->_type = type;
        SetToken(token);
    }
    
    void WindowsIdentity::constructor(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        this->_info = info;
    }
    
    void WindowsIdentity::static_constructor() {
    }
    
    void WindowsIdentity::Dispose() {
        this->_token = (*::System::IntPtr::Zero);
    }
    
    void WindowsIdentity::Dispose_371d69f9ad650889(bool disposing) {
        this->_token = (*::System::IntPtr::Zero);
    }
    
    WindowsIdentity* WindowsIdentity::GetAnonymous() {
        WindowsIdentity *id = nullptr;
        if(System::Environment::get_IsUnix()) 
        {
            id = cli::gcnew<WindowsIdentity>(_T("nobody"));
            id->_account = WindowsAccountType::Anonymous;
            id->_authenticated = false;
            id->_type = System::String::Empty;
        }
         else 
        {
            id = cli::gcnew<WindowsIdentity>((*::System::IntPtr::Zero), System::String::Empty, WindowsAccountType::Anonymous, false);
            id->_name = System::String::Empty;
        }
        return id;
    }
    
    WindowsIdentity* WindowsIdentity::GetCurrent() {
        return cli::gcnew<WindowsIdentity>(GetCurrentToken(), nullptr, WindowsAccountType::Normal, true);
    }
    
    WindowsIdentity* WindowsIdentity::GetCurrent2(bool ifImpersonating) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    WindowsIdentity* WindowsIdentity::GetCurrent3(TokenAccessLevels desiredAccess) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    WindowsImpersonationContext* WindowsIdentity::Impersonate_6e3f7806e2e3da82() {
        return cli::gcnew<WindowsImpersonationContext>(this->_token);
    }
    
    WindowsImpersonationContext* WindowsIdentity::Impersonate2(void* userToken) {
        return cli::gcnew<WindowsImpersonationContext>(userToken);
    }
    
    void WindowsIdentity::OnDeserialization(System::Object* sender) {
        this->_token = cli::unbox<void*>(this->_info->GetValue(_T("m_userToken"), cli::typeof<System::Type>::info));
        this->_name = this->_info->GetString(_T("m_name"));
        if((this->_name != nullptr)) 
        {
            System::String *name = GetTokenName(this->_token);
            if(System::String::op_Inequality(name, this->_name)) 
            {
                throw cli::gcnew<System::Runtime::Serialization::SerializationException>(_T("Token-Name mismatch."));
            }
        }
         else 
        {
            this->_name = GetTokenName(this->_token);
            if((System::String::op_Equality(this->_name, System::String::Empty) || (this->_name ==  nullptr))) 
            {
                throw cli::gcnew<System::Runtime::Serialization::SerializationException>(_T("Token doesn\'t match a user."));
            }
        }
        this->_type = this->_info->GetString(_T("m_type"));
        this->_account = cli::unbox<WindowsAccountType>(this->_info->GetValue(_T("m_acctType"), cli::typeof<System::Type>::info));
        this->_authenticated = this->_info->GetBoolean(_T("m_isAuthenticated"));
    }
    
    void WindowsIdentity::GetObjectData(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        info->AddValue16(_T("m_userToken"), cli::box(this->_token));
        info->AddValue16(_T("m_name"), this->_name);
        info->AddValue16(_T("m_type"), this->_type);
        info->AddValue16(_T("m_acctType"), cli::box(this->_account));
        info->AddValue6(_T("m_isAuthenticated"), this->_authenticated);
    }
    
    void WindowsIdentity::SetToken(void* token) {
        if(System::Environment::get_IsUnix()) 
        {
            this->_token = token;
            if((this->_type ==  nullptr)) 
            {
                this->_type = _T("POSIX");
            }
            if(::System::IntPtr::op_Equality(this->_token, (*::System::IntPtr::Zero))) 
            {
                this->_account = WindowsAccountType::System;
            }
        }
         else 
        {
            if((::System::IntPtr::op_Equality(token, invalidWindows) && ((int32_t)(this->_account) != 3))) 
            {
                throw cli::gcnew<System::ArgumentException>(_T("Invalid token"));
            }
            this->_token = token;
            if((this->_type ==  nullptr)) 
            {
                this->_type = _T("NTLM");
            }
        }
    }
    
    cli::array<System::String*>* WindowsIdentity::_GetRoles(void* token) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void* WindowsIdentity::GetCurrentToken() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    System::String* WindowsIdentity::GetTokenName(void* token) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void* WindowsIdentity::GetUserToken(System::String* username) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    System::String* WindowsIdentity::get_AuthenticationType() {
        return this->_type;
    }
    
    bool WindowsIdentity::get_IsAnonymous_a88327c93e2e8960() {
        return ((int32_t)(this->_account) ==  3);
    }
    
    bool WindowsIdentity::get_IsAuthenticated_f18be2c360fd9fab() {
        return this->_authenticated;
    }
    
    bool WindowsIdentity::get_IsGuest_36eb50762265599a() {
        return ((int32_t)(this->_account) ==  1);
    }
    
    bool WindowsIdentity::get_IsSystem_ea722274c76a3e42() {
        return ((int32_t)(this->_account) ==  2);
    }
    
    System::String* WindowsIdentity::get_Name_4712160195308583() {
        if((this->_name ==  nullptr)) 
        {
            this->_name = GetTokenName(this->_token);
        }
        return this->_name;
    }
    
    void* WindowsIdentity::get_Token_75610dbb3e1b5765() {
        return this->_token;
    }
    
    IdentityReferenceCollection* WindowsIdentity::get_Groups() {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    TokenImpersonationLevel WindowsIdentity::get_ImpersonationLevel() {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    SecurityIdentifier* WindowsIdentity::get_Owner() {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    SecurityIdentifier* WindowsIdentity::get_User() {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
}}}
namespace System { namespace Security { namespace Principal {
    
    
    void WindowsImpersonationContext::constructor(void* token) {
        this->_token = DuplicateToken(token);
        if(!(SetCurrentToken(token))) 
        {
            throw cli::gcnew<System::Security::SecurityException>(_T("Couldn\'t impersonate token."));
        }
        this->undo = false;
    }
    
    void WindowsImpersonationContext::Dispose() {
        if(!(this->undo)) 
        {
            Undo();
        }
    }
    
    void WindowsImpersonationContext::Dispose_db07c4242fc9c1(bool disposing) {
        if(!(this->undo)) 
        {
            Undo();
        }
        if(disposing) 
        {
            System::GC::SuppressFinalize(this);
        }
    }
    
    void WindowsImpersonationContext::Undo() {
        if(!(RevertToSelf())) 
        {
            CloseToken(this->_token);
            throw cli::gcnew<System::Security::SecurityException>(_T("Couldn\'t switch back to original token."));
        }
        CloseToken(this->_token);
        this->undo = true;
        System::GC::SuppressFinalize(this);
    }
    
    bool WindowsImpersonationContext::CloseToken(void* token) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void* WindowsImpersonationContext::DuplicateToken(void* token) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool WindowsImpersonationContext::SetCurrentToken(void* token) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool WindowsImpersonationContext::RevertToSelf() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
}}}
namespace System { namespace Security { namespace Principal {
    
    
    void WindowsPrincipal::constructor(WindowsIdentity* ntIdentity) {
        if((ntIdentity ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("ntIdentity"));
        }
        this->_identity = ntIdentity;
    }
    
    bool WindowsPrincipal::IsInRole_484b079e7834aa5(int32_t rid) {
        if(System::Environment::get_IsUnix()) 
        {
            return IsMemberOfGroupId(this->get_Token(), (void*)rid);
        }
         else 
        {
            System::String *role = nullptr;
            switch(rid) {
                case 544: case_1750: {
                    role = _T("BUILTIN\\Administrators");
                    break;
                }
                case 545: case_1751: {
                    role = _T("BUILTIN\\Users");
                    break;
                }
                case 546: case_1752: {
                    role = _T("BUILTIN\\Guests");
                    break;
                }
                case 547: case_1753: {
                    role = _T("BUILTIN\\Power Users");
                    break;
                }
                case 548: case_1754: {
                    role = _T("BUILTIN\\Account Operators");
                    break;
                }
                case 549: case_1755: {
                    role = _T("BUILTIN\\System Operators");
                    break;
                }
                case 550: case_1756: {
                    role = _T("BUILTIN\\Print Operators");
                    break;
                }
                case 551: case_1757: {
                    role = _T("BUILTIN\\Backup Operators");
                    break;
                }
                case 552: case_1758: {
                    role = _T("BUILTIN\\Replicator");
                    break;
                }
                default: case_1759: {
                    return false;
                }
            }
            return IsInRole_60b2cbc4fd38dbd6(role);
        }
    }
    
    bool WindowsPrincipal::IsInRole_60b2cbc4fd38dbd6(System::String* role) {
        if((role ==  nullptr)) 
        {
            return false;
        }
        if(System::Environment::get_IsUnix()) 
        {
            return IsMemberOfGroupName(this->get_Token(), role);
        }
         else 
        {
            if((this->m_roles ==  nullptr)) 
            {
                this->m_roles = WindowsIdentity::_GetRoles(this->get_Token());
            }
            role = role->ToUpperInvariant();
            for(auto tmp_628 : this->m_roles) {
                auto check = cli::cast<System::String*>(tmp_628);
                {
                    if(((check != nullptr) && System::String::op_Equality(role, check->ToUpperInvariant()))) 
                    {
                        return true;
                    }
                }
            }
            return false;
        }
    }
    
    bool WindowsPrincipal::IsInRole_cb88710a835f582f(WindowsBuiltInRole role) {
        if(System::Environment::get_IsUnix()) 
        {
            System::String *group = nullptr;
            switch(role) {
                case WindowsBuiltInRole::Administrator: case_1760: {
                    group = _T("root");
                    break;
                }
                default: case_1761: {
                    return false;
                }
            }
            return IsInRole_60b2cbc4fd38dbd6(group);
        }
         else 
        {
            return IsInRole_484b079e7834aa5((int32_t)(role));
        }
    }
    
    bool WindowsPrincipal::IsInRole_2e2c1703bdd079f0(SecurityIdentifier* sid) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool WindowsPrincipal::IsMemberOfGroupId(void* user, void* group) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool WindowsPrincipal::IsMemberOfGroupName(void* user, System::String* group) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    IIdentity* WindowsPrincipal::get_Identity_d9c071c6a431dde4() {
        return this->_identity;
    }
    
    void* WindowsPrincipal::get_Token() {
        return cli::cast<WindowsIdentity*>(this->_identity)->get_Token_75610dbb3e1b5765();
    }
    
}}}
namespace System { namespace Text {
    
    
    void ASCIIEncoding::constructor() {
        this->body_name = this->header_name = this->web_name = _T("us-ascii");
        this->encoding_name = _T("US-ASCII");
        this->is_mail_news_display = true;
        this->is_mail_news_save = true;
    }
    
    int32_t ASCIIEncoding::GetByteCount_7494b18116693a5e(cli::array<char16_t>* chars, int32_t index, int32_t count) {
        if((chars ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("chars"));
        }
        if(((index < 0) || (index > chars->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("index"), Encoding::_(_T("ArgRange_Array")));
        }
        if(((count < 0) || (count > (chars->get_Length() - index)))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("count"), Encoding::_(_T("ArgRange_Array")));
        }
        return count;
    }
    
    int32_t ASCIIEncoding::GetByteCount_d98cd1485dc2ee98(System::String* chars) {
        if((chars ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("chars"));
        }
        return chars->get_Length();
    }
    
    int32_t ASCIIEncoding::GetBytes_90650b3cf924e5e2(cli::array<char16_t>* chars, int32_t charIndex, int32_t charCount, cli::array<unsigned char>* bytes, int32_t byteIndex) {
        EncoderFallbackBuffer *buffer = nullptr;
        cli::array<char16_t> *fallback_chars = nullptr;
        return GetBytes8(chars, charIndex, charCount, bytes, byteIndex, buffer, fallback_chars);
    }
    
    int32_t ASCIIEncoding::GetBytes8(cli::array<char16_t>* chars, int32_t charIndex, int32_t charCount, cli::array<unsigned char>* bytes, int32_t byteIndex, EncoderFallbackBuffer* buffer, cli::array<char16_t>* fallback_chars) {
        if((chars ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("chars"));
        }
        {
            /* FIXED - BLOCK */
            char16_t* cptr = cli::fixed_guard(((chars ==  nullptr) || (chars->get_Length() ==  0)) ? nullptr : chars);
            return InternalGetBytes(cptr, chars->get_Length(), charIndex, charCount, bytes, byteIndex, buffer, fallback_chars);
        }
    }
    
    int32_t ASCIIEncoding::GetBytes_3384066dd8b91ed8(System::String* chars, int32_t charIndex, int32_t charCount, cli::array<unsigned char>* bytes, int32_t byteIndex) {
        EncoderFallbackBuffer *buffer = nullptr;
        cli::array<char16_t> *fallback_chars = nullptr;
        return GetBytes10(chars, charIndex, charCount, bytes, byteIndex, buffer, fallback_chars);
    }
    
    int32_t ASCIIEncoding::GetBytes10(System::String* chars, int32_t charIndex, int32_t charCount, cli::array<unsigned char>* bytes, int32_t byteIndex, EncoderFallbackBuffer* buffer, cli::array<char16_t>* fallback_chars) {
        if((chars ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("chars"));
        }
        {
            /* FIXED - BLOCK */
            char16_t* cptr = cli::fixed_guard(chars);
            return InternalGetBytes(cptr, chars->get_Length(), charIndex, charCount, bytes, byteIndex, buffer, fallback_chars);
        }
    }
    
    int32_t ASCIIEncoding::InternalGetBytes(char16_t* chars, int32_t charLength, int32_t charIndex, int32_t charCount, cli::array<unsigned char>* bytes, int32_t byteIndex, EncoderFallbackBuffer* buffer, cli::array<char16_t>* fallback_chars) {
        if((bytes ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("bytes"));
        }
        if(((charIndex < 0) || (charIndex > charLength))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("charIndex"), Encoding::_(_T("ArgRange_StringIndex")));
        }
        if(((charCount < 0) || (charCount > (charLength - charIndex)))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("charCount"), Encoding::_(_T("ArgRange_StringRange")));
        }
        if(((byteIndex < 0) || (byteIndex > bytes->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("byteIndex"), Encoding::_(_T("ArgRange_Array")));
        }
        if(((bytes->get_Length() - byteIndex) < charCount)) 
        {
            throw cli::gcnew<System::ArgumentException>(Encoding::_(_T("Arg_InsufficientSpace")));
        }
        int32_t count = charCount;
        char16_t ch;
        while((count-- > 0)) {
            ch = (*(chars + charIndex++));
            if(((int32_t)(ch) < 128)) 
            {
                bytes->at(byteIndex++) = (unsigned char)ch;
            }
             else 
            {
                if((buffer ==  nullptr)) 
                {
                    buffer = this->get_EncoderFallback()->CreateFallbackBuffer_a579589a4ca0924f();
                }
                if(((System::Char::IsSurrogate(ch) && (count > 1)) && System::Char::IsSurrogate((*(chars + charIndex))))) 
                {
                    buffer->Fallback_571cd731a6ea7558(ch, (*(chars + charIndex)), (charIndex++ - 1));
                }
                 else 
                {
                    buffer->Fallback_2e254195ffd348dc(ch, (charIndex - 1));
                }
                if(((fallback_chars ==  nullptr) || (fallback_chars->get_Length() < buffer->get_Remaining_dd4149ac6c4a9379()))) 
                {
                    fallback_chars = (new cli::array<char16_t>(buffer->get_Remaining_dd4149ac6c4a9379()));
                }
                for(int32_t i = 0; (i < fallback_chars->get_Length()); i++) {
                    fallback_chars->at(i) = buffer->GetNextChar_84e759436123fac0();
                }
                (byteIndex = byteIndex + GetBytes8(fallback_chars, 0, fallback_chars->get_Length(), bytes, byteIndex, buffer, fallback_chars));
            }
        }
        return charCount;
    }
    
    int32_t ASCIIEncoding::GetCharCount_aa33a7717b095c8e(cli::array<unsigned char>* bytes, int32_t index, int32_t count) {
        if((bytes ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("bytes"));
        }
        if(((index < 0) || (index > bytes->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("index"), Encoding::_(_T("ArgRange_Array")));
        }
        if(((count < 0) || (count > (bytes->get_Length() - index)))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("count"), Encoding::_(_T("ArgRange_Array")));
        }
        return count;
    }
    
    int32_t ASCIIEncoding::GetChars_d7b47e17fd0a13f2(cli::array<unsigned char>* bytes, int32_t byteIndex, int32_t byteCount, cli::array<char16_t>* chars, int32_t charIndex) {
        DecoderFallbackBuffer *buffer = nullptr;
        return GetChars6(bytes, byteIndex, byteCount, chars, charIndex, buffer);
    }
    
    int32_t ASCIIEncoding::GetChars6(cli::array<unsigned char>* bytes, int32_t byteIndex, int32_t byteCount, cli::array<char16_t>* chars, int32_t charIndex, DecoderFallbackBuffer* buffer) {
        if((bytes ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("bytes"));
        }
        if((chars ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("chars"));
        }
        if(((byteIndex < 0) || (byteIndex > bytes->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("byteIndex"), Encoding::_(_T("ArgRange_Array")));
        }
        if(((byteCount < 0) || (byteCount > (bytes->get_Length() - byteIndex)))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("byteCount"), Encoding::_(_T("ArgRange_Array")));
        }
        if(((charIndex < 0) || (charIndex > chars->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("charIndex"), Encoding::_(_T("ArgRange_Array")));
        }
        if(((chars->get_Length() - charIndex) < byteCount)) 
        {
            throw cli::gcnew<System::ArgumentException>(Encoding::_(_T("Arg_InsufficientSpace")));
        }
        int32_t count = byteCount;
        while((count-- > 0)) {
            char16_t c = (char16_t)bytes->at(byteIndex++);
            if(((int32_t)(c) < 128)) 
            {
                chars->at(charIndex++) = c;
            }
             else 
            {
                if((buffer ==  nullptr)) 
                {
                    buffer = this->get_DecoderFallback()->CreateFallbackBuffer_dad5db136d065044();
                }
                buffer->Fallback_1ea6d9bfef1f4bac(bytes, byteIndex);
                while((buffer->get_Remaining_b256701c9c2b0bc4() > 0)) chars->at(charIndex++) = buffer->GetNextChar_7967ec44cca772f9();
            }
        }
        return byteCount;
    }
    
    int32_t ASCIIEncoding::GetMaxByteCount_5bd2cee34757a0d4(int32_t charCount) {
        if((charCount < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("charCount"), Encoding::_(_T("ArgRange_NonNegative")));
        }
        return charCount;
    }
    
    int32_t ASCIIEncoding::GetMaxCharCount_4eba560ac1240518(int32_t byteCount) {
        if((byteCount < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("byteCount"), Encoding::_(_T("ArgRange_NonNegative")));
        }
        return byteCount;
    }
    
    System::String* ASCIIEncoding::GetString_39f4843197ddbe92(cli::array<unsigned char>* bytes, int32_t byteIndex, int32_t byteCount) {
        if((bytes ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("bytes"));
        }
        if(((byteIndex < 0) || (byteIndex > bytes->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("byteIndex"), Encoding::_(_T("ArgRange_Array")));
        }
        if(((byteCount < 0) || (byteCount > (bytes->get_Length() - byteIndex)))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("byteCount"), Encoding::_(_T("ArgRange_Array")));
        }
        if((byteCount ==  0)) 
        {
            return System::String::Empty;
        }
        {
            /* FIXED - BLOCK */
            unsigned char* bytePtr = cli::fixed_guard(((bytes ==  nullptr) || (bytes->get_Length() ==  0)) ? nullptr : bytes);
            System::String *s = System::String::InternalAllocateStr(byteCount);
            {
                /* FIXED - BLOCK */
                char16_t* charPtr = cli::fixed_guard(s);
                unsigned char *currByte = (bytePtr + (int32_t)(byteIndex));
                unsigned char *lastByte = (currByte + (int32_t)(byteCount));
                char16_t *currChar = charPtr;
                while((currByte < lastByte)) {
                    unsigned char b = (*(currByte++ + 0));
                    (*(currChar++ + 0)) = ((int32_t)(b) <= 127) ? (char16_t)b : u'?';
                }
            }
            return s;
        }
    }
    
    int32_t ASCIIEncoding::GetBytes_9b94592fd1d1a5af(char16_t* chars, int32_t charCount, unsigned char* bytes, int32_t byteCount) {
        if((chars ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("chars"));
        }
        if((bytes ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("bytes"));
        }
        if((charCount < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("charCount"));
        }
        if((byteCount < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("byteCount"));
        }
        if((byteCount < charCount)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("bytecount is less than the number of bytes required"), _T("byteCount"));
        }
        for(int32_t i = 0; (i < charCount); i++){
            char16_t c = (*(chars + i));
            (*(bytes + i)) = (unsigned char)((int32_t)(c) < 128) ? c : u'?';
        }
        return charCount;
    }
    
    int32_t ASCIIEncoding::GetChars_8904b350d20e4ab8(unsigned char* bytes, int32_t byteCount, char16_t* chars, int32_t charCount) {
        if((bytes ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("bytes"));
        }
        if((chars ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("chars"));
        }
        if((charCount < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("charCount"));
        }
        if((byteCount < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("byteCount"));
        }
        if((charCount < byteCount)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("charcount is less than the number of bytes required"), _T("charCount"));
        }
        for(int32_t i = 0; (i < byteCount); i++){
            unsigned char b = (*(bytes + i));
            (*(chars + i)) = ((int32_t)(b) > 127) ? u'?' : (char16_t)b;
        }
        return byteCount;
    }
    
    int32_t ASCIIEncoding::GetCharCount_4e601cea7c3f10cd(unsigned char* bytes, int32_t count) {
        return count;
    }
    
    int32_t ASCIIEncoding::GetByteCount_aec9823bd32c6735(char16_t* chars, int32_t count) {
        return count;
    }
    
    Decoder2* ASCIIEncoding::GetDecoder_380c5e0c575e9cb5() {
        return Encoding::GetDecoder_380c5e0c575e9cb5();
    }
    
    Encoder* ASCIIEncoding::GetEncoder_c3a25b0b739d51c8() {
        return Encoding::GetEncoder_c3a25b0b739d51c8();
    }
    
    bool ASCIIEncoding::get_IsSingleByte_35caa6a029e2b816() {
        return true;
    }
    
}}
namespace System { namespace Text {
    
    
    void Decoder::constructor(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        if((info ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("info"));
        }
        this->encoding = cli::cast<Encoding*>(info->GetValue(_T("encoding"), cli::typeof<System::Type>::info));
    }
    
    void Decoder::GetObjectData(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        throw cli::gcnew<System::ArgumentException>(_T("This class cannot be serialized."));
    }
    
    System::Object* Decoder::GetRealObject(System::Runtime::Serialization::StreamingContext context) {
        if((this->realObject ==  nullptr)) 
        {
            this->realObject = this->encoding->GetDecoder_380c5e0c575e9cb5();
        }
        return this->realObject;
    }
    
}}
namespace System { namespace Text {
    
    
    void CodePageEncoding::constructor(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        if((info ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("info"));
        }
        this->codePage = cli::unbox<int32_t>(info->GetValue(_T("m_codePage"), cli::typeof<System::Type>::info));
        try {
            this->isReadOnly = cli::unbox<bool>(info->GetValue(_T("m_isReadOnly"), cli::typeof<System::Type>::info));
            this->encoderFallback = cli::cast<EncoderFallback*>(info->GetValue(_T("encoderFallback"), cli::typeof<System::Type>::info));
            this->decoderFallback = cli::cast<DecoderFallback*>(info->GetValue(_T("decoderFallback"), cli::typeof<System::Type>::info));
        }
        catch(System::Runtime::Serialization::SerializationException*) {
            this->isReadOnly = true;
        }
    }
    
    void CodePageEncoding::GetObjectData(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        throw cli::gcnew<System::ArgumentException>(_T("This class cannot be serialized."));
    }
    
    System::Object* CodePageEncoding::GetRealObject(System::Runtime::Serialization::StreamingContext context) {
        if((this->realObject ==  nullptr)) 
        {
            Encoding *encoding = Encoding::GetEncoding(this->codePage);
            if(!(this->isReadOnly)) 
            {
                encoding = cli::cast<Encoding*>(encoding->Clone_c7ab6a38a8e4176e());
                encoding->set_EncoderFallback(this->encoderFallback);
                encoding->set_DecoderFallback(this->decoderFallback);
            }
            this->realObject = encoding;
        }
        return this->realObject;
    }
    
}}
namespace System { namespace Text {
    
    
    void Decoder2::constructor() {
    }
    
    int32_t Decoder2::GetCharCount_70ec3c7ca72b5799(cli::array<unsigned char>* bytes, int32_t index, int32_t count, bool flush) {
        if(flush) 
        {
            Reset_d03c70a495965fed();
        }
        return GetCharCount_32dfa16feccdb25d(bytes, index, count);
    }
    
    int32_t Decoder2::GetCharCount_e5526205eecd824a(unsigned char* bytes, int32_t count, bool flush) {
        if((bytes ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("bytes"));
        }
        if((count < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("count"));
        }
        cli::array<unsigned char> *barr = (new cli::array<unsigned char>(count));
        System::Runtime::InteropServices::Marshal::Copy9((void*)(void*)(bytes), barr, 0, count);
        return GetCharCount_70ec3c7ca72b5799(barr, 0, count, flush);
    }
    
    int32_t Decoder2::GetChars_41a75c27687b2d7f(cli::array<unsigned char>* bytes, int32_t byteIndex, int32_t byteCount, cli::array<char16_t>* chars, int32_t charIndex, bool flush) {
        CheckArguments2(bytes, byteIndex, byteCount);
        CheckArguments(chars, charIndex);
        if(flush) 
        {
            Reset_d03c70a495965fed();
        }
        return GetChars_beecc497fe0b7526(bytes, byteIndex, byteCount, chars, charIndex);
    }
    
    int32_t Decoder2::GetChars_e5afb2ed21a74698(unsigned char* bytes, int32_t byteCount, char16_t* chars, int32_t charCount, bool flush) {
        CheckArguments3(chars, charCount, bytes, byteCount);
        cli::array<char16_t> *carr = (new cli::array<char16_t>(charCount));
        System::Runtime::InteropServices::Marshal::Copy10((void*)(void*)(chars), carr, 0, charCount);
        cli::array<unsigned char> *barr = (new cli::array<unsigned char>(byteCount));
        System::Runtime::InteropServices::Marshal::Copy9((void*)(void*)(bytes), barr, 0, byteCount);
        return GetChars_41a75c27687b2d7f(barr, 0, byteCount, carr, 0, flush);
    }
    
    void Decoder2::Reset_d03c70a495965fed() {
        if((this->fallback_buffer != nullptr)) 
        {
            this->fallback_buffer->Reset_dc5d0be891187587();
        }
    }
    
    void Decoder2::Convert_9af9b7214f1d3f95(unsigned char* bytes, int32_t byteCount, char16_t* chars, int32_t charCount, bool flush, int32_t bytesUsed, int32_t charsUsed, bool completed) {
        CheckArguments3(chars, charCount, bytes, byteCount);
        bytesUsed = byteCount;
        while(true) {
            charsUsed = GetCharCount_e5526205eecd824a(bytes, bytesUsed, flush);
            if((charsUsed <= charCount)) 
            {
                break;
            }
            flush = false;
            (bytesUsed = bytesUsed >> 1);
        }
        completed = (bytesUsed ==  byteCount);
        charsUsed = GetChars_e5afb2ed21a74698(bytes, bytesUsed, chars, charCount, flush);
    }
    
    void Decoder2::Convert_aa55aa2c58be8fe2(cli::array<unsigned char>* bytes, int32_t byteIndex, int32_t byteCount, cli::array<char16_t>* chars, int32_t charIndex, int32_t charCount, bool flush, int32_t bytesUsed, int32_t charsUsed, bool completed) {
        CheckArguments2(bytes, byteIndex, byteCount);
        CheckArguments(chars, charIndex);
        if(((charCount < 0) || (chars->get_Length() < (charIndex + charCount)))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("charCount"));
        }
        bytesUsed = byteCount;
        while(true) {
            charsUsed = GetCharCount_70ec3c7ca72b5799(bytes, byteIndex, bytesUsed, flush);
            if((charsUsed <= charCount)) 
            {
                break;
            }
            flush = false;
            (bytesUsed = bytesUsed >> 1);
        }
        completed = (bytesUsed ==  byteCount);
        charsUsed = GetChars_41a75c27687b2d7f(bytes, byteIndex, bytesUsed, chars, charIndex, flush);
    }
    
    void Decoder2::CheckArguments(cli::array<char16_t>* chars, int32_t charIndex) {
        if((chars ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("chars"));
        }
        if(((charIndex < 0) || (chars->get_Length() <= charIndex))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("charIndex"));
        }
    }
    
    void Decoder2::CheckArguments2(cli::array<unsigned char>* bytes, int32_t byteIndex, int32_t byteCount) {
        if((bytes ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("bytes"));
        }
        if(((byteIndex < 0) || (bytes->get_Length() <= byteIndex))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("byteIndex"));
        }
        if(((byteCount < 0) || (bytes->get_Length() < (byteIndex + byteCount)))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("byteCount"));
        }
    }
    
    void Decoder2::CheckArguments3(char16_t* chars, int32_t charCount, unsigned char* bytes, int32_t byteCount) {
        if((chars ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("chars"));
        }
        if((bytes ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("bytes"));
        }
        if((charCount < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("charCount"));
        }
        if((byteCount < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("byteCount"));
        }
    }
    
    DecoderFallback* Decoder2::get_Fallback() {
        return this->fallback;
    }
    
    DecoderFallback* Decoder2::set_Fallback(DecoderFallback* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>();
        }
        this->fallback = value;
        this->fallback_buffer = nullptr;
        return get_Fallback();
    }
    
    DecoderFallbackBuffer* Decoder2::get_FallbackBuffer() {
        if((this->fallback_buffer ==  nullptr)) 
        {
            this->fallback_buffer = this->fallback->CreateFallbackBuffer_dad5db136d065044();
        }
        return this->fallback_buffer;
    }
    
}}
namespace System { namespace Text {
    
    
    void DecoderExceptionFallback::constructor() {
    }
    
    DecoderFallbackBuffer* DecoderExceptionFallback::CreateFallbackBuffer_dad5db136d065044() {
        return cli::gcnew<DecoderExceptionFallbackBuffer>();
    }
    
    bool DecoderExceptionFallback::Equals_ed975d2f4a7d193e(System::Object* value) {
        return cli::is<DecoderExceptionFallback>(value);
    }
    
    int32_t DecoderExceptionFallback::GetHashCode_6648aef0f235ee6c() {
        return 0;
    }
    
    int32_t DecoderExceptionFallback::get_MaxCharCount_4c0c8ac224d22848() {
        return 0;
    }
    
}}
namespace System { namespace Text {
    
    
    void DecoderExceptionFallbackBuffer::constructor() {
    }
    
    bool DecoderExceptionFallbackBuffer::Fallback_1ea6d9bfef1f4bac(cli::array<unsigned char>* bytesUnknown, int32_t index) {
        throw cli::gcnew<DecoderFallbackException>(nullptr, bytesUnknown, index);
    }
    
    char16_t DecoderExceptionFallbackBuffer::GetNextChar_7967ec44cca772f9() {
        return u'\x0';
    }
    
    bool DecoderExceptionFallbackBuffer::MovePrevious_c3549fdac1194a1d() {
        return false;
    }
    
    int32_t DecoderExceptionFallbackBuffer::get_Remaining_b256701c9c2b0bc4() {
        return 0;
    }
    
}}
namespace System { namespace Text {
    
    DecoderFallback*  DecoderFallback::exception_fallback;
    DecoderFallback*  DecoderFallback::replacement_fallback;
    DecoderFallback*  DecoderFallback::standard_safe_fallback;
    
    DecoderFallback::DecoderFallback()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void DecoderFallback::constructor() {
    }
    
    void DecoderFallback::static_constructor() {
    }
    
    DecoderFallback* DecoderFallback::get_ExceptionFallback() {
        return exception_fallback;
    }
    
    DecoderFallback* DecoderFallback::get_ReplacementFallback() {
        return replacement_fallback;
    }
    
    DecoderFallback* DecoderFallback::get_StandardSafeFallback() {
        return standard_safe_fallback;
    }
    
}}
namespace System { namespace Text {
    
    
    void DecoderFallbackBuffer::constructor() {
    }
    
    void DecoderFallbackBuffer::Reset_dc5d0be891187587() {
    }
    
}}
namespace System { namespace Text {
    
    
    void DecoderFallbackException::constructor() {
    }
    
    void DecoderFallbackException::constructor(System::String* message) {
    }
    
    void DecoderFallbackException::constructor(System::String* message, System::Exception* innerException) {
    }
    
    void DecoderFallbackException::constructor(System::String* message, cli::array<unsigned char>* bytesUnknown, int32_t index) {
        this->bytes_unknown = bytesUnknown;
        this->index = index;
    }
    
    cli::array<unsigned char>* DecoderFallbackException::get_BytesUnknown() {
        return this->bytes_unknown;
    }
    
    int32_t DecoderFallbackException::get_Index() {
        return this->index;
    }
    
}}
namespace System { namespace Text {
    
    
    void DecoderReplacementFallback::constructor() {
    }
    
    void DecoderReplacementFallback::constructor(System::String* replacement) {
        if((replacement ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>();
        }
        this->replacement = replacement;
    }
    
    DecoderFallbackBuffer* DecoderReplacementFallback::CreateFallbackBuffer_dad5db136d065044() {
        return cli::gcnew<DecoderReplacementFallbackBuffer>(this);
    }
    
    bool DecoderReplacementFallback::Equals_ed975d2f4a7d193e(System::Object* value) {
        DecoderReplacementFallback *f = cli::as<DecoderReplacementFallback*>(value);
        return ((f != nullptr) && System::String::op_Equality(this->replacement, f->replacement));
    }
    
    int32_t DecoderReplacementFallback::GetHashCode_6648aef0f235ee6c() {
        return this->replacement->GetHashCode_6648aef0f235ee6c();
    }
    
    System::String* DecoderReplacementFallback::get_DefaultString() {
        return this->replacement;
    }
    
    int32_t DecoderReplacementFallback::get_MaxCharCount_4c0c8ac224d22848() {
        return this->replacement->get_Length();
    }
    
}}
namespace System { namespace Text {
    
    
    void DecoderReplacementFallbackBuffer::constructor(DecoderReplacementFallback* fallback) {
        if((fallback ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("fallback"));
        }
        this->replacement = fallback->get_DefaultString();
        this->current = 0;
    }
    
    bool DecoderReplacementFallbackBuffer::Fallback_1ea6d9bfef1f4bac(cli::array<unsigned char>* bytesUnknown, int32_t index) {
        if((bytesUnknown ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("bytesUnknown"));
        }
        if((this->fallback_assigned && (this->get_Remaining_b256701c9c2b0bc4() != 0))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Reentrant Fallback method invocation occured. It might be because either this FallbackBuffer is incorrectly shared by multiple threads, invoked inside Encoding recursively, or Reset invocation is forgotten."));
        }
        if(((index < 0) || (bytesUnknown->get_Length() < index))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("index"));
        }
        this->fallback_assigned = true;
        this->current = 0;
        return (this->replacement->get_Length() > 0);
    }
    
    char16_t DecoderReplacementFallbackBuffer::GetNextChar_7967ec44cca772f9() {
        if(!(this->fallback_assigned)) 
        {
            return u'\x0';
        }
        if((this->current >= this->replacement->get_Length())) 
        {
            return u'\x0';
        }
        return this->replacement->get_Chars(this->current++);
    }
    
    bool DecoderReplacementFallbackBuffer::MovePrevious_c3549fdac1194a1d() {
        if((this->current ==  0)) 
        {
            return false;
        }
        this->current--;
        return true;
    }
    
    void DecoderReplacementFallbackBuffer::Reset_dc5d0be891187587() {
        this->fallback_assigned = false;
        this->current = 0;
    }
    
    int32_t DecoderReplacementFallbackBuffer::get_Remaining_b256701c9c2b0bc4() {
        return this->fallback_assigned ? (this->replacement->get_Length() - this->current) : 0;
    }
    
}}
namespace System { namespace Text {
    
    
    void Encoder::constructor() {
    }
    
    int32_t Encoder::GetByteCount_addb240243fed46d(char16_t* chars, int32_t count, bool flush) {
        if((chars ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("chars"));
        }
        if((count < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("count"));
        }
        cli::array<char16_t> *carr = (new cli::array<char16_t>(count));
        System::Runtime::InteropServices::Marshal::Copy10((void*)(void*)(chars), carr, 0, count);
        return GetByteCount_85f1385779510289(carr, 0, count, flush);
    }
    
    int32_t Encoder::GetBytes_4985ee639a8a9b65(char16_t* chars, int32_t charCount, unsigned char* bytes, int32_t byteCount, bool flush) {
        CheckArguments(chars, charCount, bytes, byteCount);
        cli::array<char16_t> *carr = (new cli::array<char16_t>(charCount));
        System::Runtime::InteropServices::Marshal::Copy10((void*)(void*)(chars), carr, 0, charCount);
        cli::array<unsigned char> *barr = (new cli::array<unsigned char>(byteCount));
        System::Runtime::InteropServices::Marshal::Copy9((void*)(void*)(bytes), barr, 0, byteCount);
        return GetBytes_ac22a3cfd526ffd3(carr, 0, charCount, barr, 0, flush);
    }
    
    void Encoder::Reset_d50600f03626a729() {
        if((this->fallback_buffer != nullptr)) 
        {
            this->fallback_buffer->Reset_e8feb6df1bde1a59();
        }
    }
    
    void Encoder::Convert_ed7267004a1f0914(char16_t* chars, int32_t charCount, unsigned char* bytes, int32_t byteCount, bool flush, int32_t charsUsed, int32_t bytesUsed, bool completed) {
        CheckArguments(chars, charCount, bytes, byteCount);
        charsUsed = charCount;
        while(true) {
            bytesUsed = GetByteCount_addb240243fed46d(chars, charsUsed, flush);
            if((bytesUsed <= byteCount)) 
            {
                break;
            }
            flush = false;
            (charsUsed = charsUsed >> 1);
        }
        completed = (charsUsed ==  charCount);
        bytesUsed = GetBytes_4985ee639a8a9b65(chars, charsUsed, bytes, byteCount, flush);
    }
    
    void Encoder::Convert_6be0592b51d62804(cli::array<char16_t>* chars, int32_t charIndex, int32_t charCount, cli::array<unsigned char>* bytes, int32_t byteIndex, int32_t byteCount, bool flush, int32_t charsUsed, int32_t bytesUsed, bool completed) {
        if((chars ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("chars"));
        }
        if((bytes ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("bytes"));
        }
        if(((charIndex < 0) || (chars->get_Length() <= charIndex))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("charIndex"));
        }
        if(((charCount < 0) || (chars->get_Length() < (charIndex + charCount)))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("charCount"));
        }
        if(((byteIndex < 0) || (bytes->get_Length() <= byteIndex))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("byteIndex"));
        }
        if(((byteCount < 0) || (bytes->get_Length() < (byteIndex + byteCount)))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("byteCount"));
        }
        charsUsed = charCount;
        while(true) {
            bytesUsed = GetByteCount_85f1385779510289(chars, charIndex, charsUsed, flush);
            if((bytesUsed <= byteCount)) 
            {
                break;
            }
            flush = false;
            (charsUsed = charsUsed >> 1);
        }
        completed = (charsUsed ==  charCount);
        bytesUsed = GetBytes_ac22a3cfd526ffd3(chars, charIndex, charsUsed, bytes, byteIndex, flush);
    }
    
    void Encoder::CheckArguments(char16_t* chars, int32_t charCount, unsigned char* bytes, int32_t byteCount) {
        if((chars ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("chars"));
        }
        if((bytes ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("bytes"));
        }
        if((charCount < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("charCount"));
        }
        if((byteCount < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("byteCount"));
        }
    }
    
    EncoderFallback* Encoder::get_Fallback() {
        return this->fallback;
    }
    
    EncoderFallback* Encoder::set_Fallback(EncoderFallback* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>();
        }
        this->fallback = value;
        this->fallback_buffer = nullptr;
        return get_Fallback();
    }
    
    EncoderFallbackBuffer* Encoder::get_FallbackBuffer() {
        if((this->fallback_buffer ==  nullptr)) 
        {
            this->fallback_buffer = this->get_Fallback()->CreateFallbackBuffer_a579589a4ca0924f();
        }
        return this->fallback_buffer;
    }
    
}}
namespace System { namespace Text {
    
    
    void EncoderExceptionFallback::constructor() {
    }
    
    EncoderFallbackBuffer* EncoderExceptionFallback::CreateFallbackBuffer_a579589a4ca0924f() {
        return cli::gcnew<EncoderExceptionFallbackBuffer>();
    }
    
    bool EncoderExceptionFallback::Equals_ed975d2f4a7d193e(System::Object* value) {
        return cli::is<EncoderExceptionFallback>(value);
    }
    
    int32_t EncoderExceptionFallback::GetHashCode_6648aef0f235ee6c() {
        return 0;
    }
    
    int32_t EncoderExceptionFallback::get_MaxCharCount_d3886d08d9f851fe() {
        return 0;
    }
    
}}
namespace System { namespace Text {
    
    
    void EncoderExceptionFallbackBuffer::constructor() {
    }
    
    bool EncoderExceptionFallbackBuffer::Fallback_2e254195ffd348dc(char16_t charUnknown, int32_t index) {
        throw cli::gcnew<EncoderFallbackException>(charUnknown, index);
    }
    
    bool EncoderExceptionFallbackBuffer::Fallback_571cd731a6ea7558(char16_t charUnknownHigh, char16_t charUnknownLow, int32_t index) {
        throw cli::gcnew<EncoderFallbackException>(charUnknownHigh, charUnknownLow, index);
    }
    
    char16_t EncoderExceptionFallbackBuffer::GetNextChar_84e759436123fac0() {
        return u'\x0';
    }
    
    bool EncoderExceptionFallbackBuffer::MovePrevious_a841421c2eaf80e7() {
        return false;
    }
    
    int32_t EncoderExceptionFallbackBuffer::get_Remaining_dd4149ac6c4a9379() {
        return 0;
    }
    
}}
namespace System { namespace Text {
    
    EncoderFallback*  EncoderFallback::exception_fallback;
    EncoderFallback*  EncoderFallback::replacement_fallback;
    EncoderFallback*  EncoderFallback::standard_safe_fallback;
    
    EncoderFallback::EncoderFallback()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void EncoderFallback::constructor() {
    }
    
    void EncoderFallback::static_constructor() {
    }
    
    EncoderFallback* EncoderFallback::get_ExceptionFallback() {
        return exception_fallback;
    }
    
    EncoderFallback* EncoderFallback::get_ReplacementFallback() {
        return replacement_fallback;
    }
    
    EncoderFallback* EncoderFallback::get_StandardSafeFallback() {
        return standard_safe_fallback;
    }
    
}}
namespace System { namespace Text {
    
    
    void EncoderFallbackBuffer::constructor() {
    }
    
    void EncoderFallbackBuffer::Reset_e8feb6df1bde1a59() {
        while(((int32_t)(GetNextChar_84e759436123fac0()) != 0)) ;
    }
    
}}
namespace System { namespace Text {
    
    
    void EncoderFallbackException::constructor() {
    }
    
    void EncoderFallbackException::constructor(System::String* message) {
    }
    
    void EncoderFallbackException::constructor(System::String* message, System::Exception* innerException) {
    }
    
    void EncoderFallbackException::constructor(char16_t charUnknown, int32_t index) {
        this->char_unknown = charUnknown;
        this->index = index;
    }
    
    void EncoderFallbackException::constructor(char16_t charUnknownHigh, char16_t charUnknownLow, int32_t index) {
        this->char_unknown_high = charUnknownHigh;
        this->char_unknown_low = charUnknownLow;
        this->index = index;
    }
    
    bool EncoderFallbackException::IsUnknownSurrogate() {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    char16_t EncoderFallbackException::get_CharUnknown() {
        return this->char_unknown;
    }
    
    char16_t EncoderFallbackException::get_CharUnknownHigh() {
        return this->char_unknown_high;
    }
    
    char16_t EncoderFallbackException::get_CharUnknownLow() {
        return this->char_unknown_low;
    }
    
    int32_t EncoderFallbackException::get_Index() {
        return this->index;
    }
    
}}
namespace System { namespace Text {
    
    
    void EncoderReplacementFallback::constructor() {
    }
    
    void EncoderReplacementFallback::constructor(System::String* replacement) {
        if((replacement ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>();
        }
        this->replacement = replacement;
    }
    
    EncoderFallbackBuffer* EncoderReplacementFallback::CreateFallbackBuffer_a579589a4ca0924f() {
        return cli::gcnew<EncoderReplacementFallbackBuffer>(this);
    }
    
    bool EncoderReplacementFallback::Equals_ed975d2f4a7d193e(System::Object* value) {
        EncoderReplacementFallback *f = cli::as<EncoderReplacementFallback*>(value);
        return ((f != nullptr) && System::String::op_Equality(this->replacement, f->replacement));
    }
    
    int32_t EncoderReplacementFallback::GetHashCode_6648aef0f235ee6c() {
        return this->replacement->GetHashCode_6648aef0f235ee6c();
    }
    
    System::String* EncoderReplacementFallback::get_DefaultString() {
        return this->replacement;
    }
    
    int32_t EncoderReplacementFallback::get_MaxCharCount_d3886d08d9f851fe() {
        return this->replacement->get_Length();
    }
    
}}
namespace System { namespace Text {
    
    
    void EncoderReplacementFallbackBuffer::constructor(EncoderReplacementFallback* fallback) {
        if((fallback ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("fallback"));
        }
        this->replacement = fallback->get_DefaultString();
        this->current = 0;
    }
    
    bool EncoderReplacementFallbackBuffer::Fallback_2e254195ffd348dc(char16_t charUnknown, int32_t index) {
        return Fallback5(index);
    }
    
    bool EncoderReplacementFallbackBuffer::Fallback_571cd731a6ea7558(char16_t charUnknownHigh, char16_t charUnknownLow, int32_t index) {
        return Fallback5(index);
    }
    
    bool EncoderReplacementFallbackBuffer::Fallback5(int32_t index) {
        if((this->fallback_assigned && (this->get_Remaining_dd4149ac6c4a9379() != 0))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Reentrant Fallback method invocation occured. It might be because either this FallbackBuffer is incorrectly shared by multiple threads, invoked inside Encoding recursively, or Reset invocation is forgotten."));
        }
        if((index < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("index"));
        }
        this->fallback_assigned = true;
        this->current = 0;
        return (this->replacement->get_Length() > 0);
    }
    
    char16_t EncoderReplacementFallbackBuffer::GetNextChar_84e759436123fac0() {
        if((this->current >= this->replacement->get_Length())) 
        {
            return u'\x0';
        }
        return this->replacement->get_Chars(this->current++);
    }
    
    bool EncoderReplacementFallbackBuffer::MovePrevious_a841421c2eaf80e7() {
        if((this->current ==  0)) 
        {
            return false;
        }
        this->current--;
        return true;
    }
    
    void EncoderReplacementFallbackBuffer::Reset_e8feb6df1bde1a59() {
        this->fallback_assigned = false;
        this->current = 0;
    }
    
    int32_t EncoderReplacementFallbackBuffer::get_Remaining_dd4149ac6c4a9379() {
        return (this->replacement->get_Length() - this->current);
    }
    
}}
namespace System { namespace Text {
    
    
    void ForwardingDecoder::constructor(Encoding* enc) {
        this->encoding = enc;
        DecoderFallback *fallback = this->encoding->get_DecoderFallback();
        if((fallback != nullptr)) 
        {
            this->set_Fallback(fallback);
        }
    }
    
    int32_t ForwardingDecoder::GetCharCount_32dfa16feccdb25d(cli::array<unsigned char>* bytes, int32_t index, int32_t count) {
        return this->encoding->GetCharCount_aa33a7717b095c8e(bytes, index, count);
    }
    
    int32_t ForwardingDecoder::GetChars_beecc497fe0b7526(cli::array<unsigned char>* bytes, int32_t byteIndex, int32_t byteCount, cli::array<char16_t>* chars, int32_t charIndex) {
        return this->encoding->GetChars_d7b47e17fd0a13f2(bytes, byteIndex, byteCount, chars, charIndex);
    }
    
}}
namespace System { namespace Text {
    
    
    void ForwardingEncoder::constructor(Encoding* enc) {
        this->encoding = enc;
        EncoderFallback *fallback = this->encoding->get_EncoderFallback();
        if((fallback != nullptr)) 
        {
            this->set_Fallback(fallback);
        }
    }
    
    int32_t ForwardingEncoder::GetByteCount_85f1385779510289(cli::array<char16_t>* chars, int32_t index, int32_t count, bool flush) {
        return this->encoding->GetByteCount_7494b18116693a5e(chars, index, count);
    }
    
    int32_t ForwardingEncoder::GetBytes_ac22a3cfd526ffd3(cli::array<char16_t>* chars, int32_t charIndex, int32_t charCount, cli::array<unsigned char>* bytes, int32_t byteCount, bool flush) {
        return this->encoding->GetBytes_90650b3cf924e5e2(chars, charIndex, charCount, bytes, byteCount);
    }
    
}}
namespace System { namespace Text {
    
    System::Reflection::Assembly*  Encoding::i18nAssembly;
    bool  Encoding::i18nDisabled;
    cli::array<EncodingInfo*>*  Encoding::encoding_infos;
    Encoding*  Encoding::asciiEncoding;
    Encoding*  Encoding::bigEndianEncoding;
    Encoding*  Encoding::defaultEncoding;
    Encoding*  Encoding::utf7Encoding;
    Encoding*  Encoding::utf8EncodingWithMarkers;
    Encoding*  Encoding::utf8EncodingWithoutMarkers;
    Encoding*  Encoding::unicodeEncoding;
    Encoding*  Encoding::isoLatin1Encoding;
    Encoding*  Encoding::utf8EncodingUnsafe;
    Encoding*  Encoding::utf32Encoding;
    Encoding*  Encoding::bigEndianUTF32Encoding;
    System::Object*  Encoding::lockobj;
    System::Collections::Generic::Dictionary<System::String*, int32_t>*  Encoding::__f__switch_map11;
    
    Encoding::Encoding()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void Encoding::constructor() {
    }
    
    void Encoding::constructor(int32_t codePage) {
        this->codePage = this->windows_code_page = codePage;
        switch(codePage) {
            default: case_1762: {
                this->decoder_fallback = DecoderFallback::get_ReplacementFallback();
                this->encoder_fallback = EncoderFallback::get_ReplacementFallback();
                break;
            }
            case 20127: case 54936: case_1763: {
                this->decoder_fallback = DecoderFallback::get_ReplacementFallback();
                this->encoder_fallback = EncoderFallback::get_ReplacementFallback();
                break;
            }
            case 1200: case 1201: case 12000: case 12001: case 65000: case 65001: case_1764: {
                this->decoder_fallback = DecoderFallback::get_StandardSafeFallback();
                this->encoder_fallback = EncoderFallback::get_StandardSafeFallback();
                break;
            }
        }
    }
    
    void Encoding::static_constructor() {
    }
    
    System::String* Encoding::_(System::String* arg) {
        return arg;
    }
    
    void Encoding::SetFallbackInternal(EncoderFallback* e, DecoderFallback* d) {
        if((e != nullptr)) 
        {
            this->encoder_fallback = e;
        }
        if((d != nullptr)) 
        {
            this->decoder_fallback = d;
        }
    }
    
    cli::array<unsigned char>* Encoding::Convert2(Encoding* srcEncoding, Encoding* dstEncoding, cli::array<unsigned char>* bytes) {
        if((srcEncoding ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("srcEncoding"));
        }
        if((dstEncoding ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("dstEncoding"));
        }
        if((bytes ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("bytes"));
        }
        return dstEncoding->GetBytes_c786a154203d1d3e(srcEncoding->GetChars_66b39e5249276d4a(bytes, 0, bytes->get_Length()));
    }
    
    cli::array<unsigned char>* Encoding::Convert3(Encoding* srcEncoding, Encoding* dstEncoding, cli::array<unsigned char>* bytes, int32_t index, int32_t count) {
        if((srcEncoding ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("srcEncoding"));
        }
        if((dstEncoding ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("dstEncoding"));
        }
        if((bytes ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("bytes"));
        }
        if(((index < 0) || (index > bytes->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("index"), _(_T("ArgRange_Array")));
        }
        if(((count < 0) || ((bytes->get_Length() - index) < count))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("count"), _(_T("ArgRange_Array")));
        }
        return dstEncoding->GetBytes_c786a154203d1d3e(srcEncoding->GetChars_66b39e5249276d4a(bytes, index, count));
    }
    
    bool Encoding::Equals_ed975d2f4a7d193e(System::Object* value) {
        Encoding *enc = cli::as<Encoding*>(value);
        if((enc != nullptr)) 
        {
            return (((this->codePage ==  enc->codePage) && this->get_DecoderFallback()->Equals_ed975d2f4a7d193e(enc->get_DecoderFallback())) && this->get_EncoderFallback()->Equals_ed975d2f4a7d193e(enc->get_EncoderFallback()));
        }
         else 
        {
            return false;
        }
    }
    
    int32_t Encoding::GetByteCount_d98cd1485dc2ee98(System::String* s) {
        if((s ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("s"));
        }
        if((s->get_Length() ==  0)) 
        {
            return 0;
        }
        {
            /* FIXED - BLOCK */
            char16_t* cptr = cli::fixed_guard(s);
            return GetByteCount_aec9823bd32c6735(cptr, s->get_Length());
        }
    }
    
    int32_t Encoding::GetByteCount_8ddd893811c6fb16(cli::array<char16_t>* chars) {
        if((chars != nullptr)) 
        {
            return GetByteCount_7494b18116693a5e(chars, 0, chars->get_Length());
        }
         else 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("chars"));
        }
    }
    
    int32_t Encoding::GetBytes_3384066dd8b91ed8(System::String* s, int32_t charIndex, int32_t charCount, cli::array<unsigned char>* bytes, int32_t byteIndex) {
        if((s ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("s"));
        }
        if(((charIndex < 0) || (charIndex > s->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("charIndex"), _(_T("ArgRange_Array")));
        }
        if(((charCount < 0) || (charIndex > (s->get_Length() - charCount)))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("charCount"), _(_T("ArgRange_Array")));
        }
        if(((byteIndex < 0) || (byteIndex > bytes->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("byteIndex"), _(_T("ArgRange_Array")));
        }
        if(((charCount ==  0) || (bytes->get_Length() ==  byteIndex))) 
        {
            return 0;
        }
        {
            /* FIXED - BLOCK */
            char16_t* cptr = cli::fixed_guard(s);
            {
                /* FIXED - BLOCK */
                unsigned char* bptr = cli::fixed_guard(((bytes ==  nullptr) || (bytes->get_Length() ==  0)) ? nullptr : bytes);
                return GetBytes_9b94592fd1d1a5af((cptr + (int32_t)(charIndex)), charCount, (bptr + (int32_t)(byteIndex)), (bytes->get_Length() - byteIndex));
            }
        }
    }
    
    cli::array<unsigned char>* Encoding::GetBytes_49806e8e98b1c1db(System::String* s) {
        if((s ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("s"));
        }
        if((s->get_Length() ==  0)) 
        {
            return (new cli::array<unsigned char>(0));
        }
        int32_t byteCount = GetByteCount_d98cd1485dc2ee98(s);
        if((byteCount ==  0)) 
        {
            return (new cli::array<unsigned char>(0));
        }
        {
            /* FIXED - BLOCK */
            char16_t* cptr = cli::fixed_guard(s);
            cli::array<unsigned char> *bytes = (new cli::array<unsigned char>(byteCount));
            {
                /* FIXED - BLOCK */
                unsigned char* bptr = cli::fixed_guard(((bytes ==  nullptr) || (bytes->get_Length() ==  0)) ? nullptr : bytes);
                GetBytes_9b94592fd1d1a5af(cptr, s->get_Length(), bptr, byteCount);
                return bytes;
            }
        }
    }
    
    cli::array<unsigned char>* Encoding::GetBytes_d1513e6a9072eb1(cli::array<char16_t>* chars, int32_t index, int32_t count) {
        int32_t numBytes = GetByteCount_7494b18116693a5e(chars, index, count);
        cli::array<unsigned char> *bytes = (new cli::array<unsigned char>(numBytes));
        GetBytes_90650b3cf924e5e2(chars, index, count, bytes, 0);
        return bytes;
    }
    
    cli::array<unsigned char>* Encoding::GetBytes_c786a154203d1d3e(cli::array<char16_t>* chars) {
        int32_t numBytes = GetByteCount_7494b18116693a5e(chars, 0, chars->get_Length());
        cli::array<unsigned char> *bytes = (new cli::array<unsigned char>(numBytes));
        GetBytes_90650b3cf924e5e2(chars, 0, chars->get_Length(), bytes, 0);
        return bytes;
    }
    
    int32_t Encoding::GetCharCount_1703b678788a899e(cli::array<unsigned char>* bytes) {
        if((bytes ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("bytes"));
        }
        return GetCharCount_aa33a7717b095c8e(bytes, 0, bytes->get_Length());
    }
    
    cli::array<char16_t>* Encoding::GetChars_66b39e5249276d4a(cli::array<unsigned char>* bytes, int32_t index, int32_t count) {
        int32_t numChars = GetCharCount_aa33a7717b095c8e(bytes, index, count);
        cli::array<char16_t> *chars = (new cli::array<char16_t>(numChars));
        GetChars_d7b47e17fd0a13f2(bytes, index, count, chars, 0);
        return chars;
    }
    
    cli::array<char16_t>* Encoding::GetChars_7bd8879fade07d8e(cli::array<unsigned char>* bytes) {
        if((bytes ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("bytes"));
        }
        int32_t numChars = GetCharCount_aa33a7717b095c8e(bytes, 0, bytes->get_Length());
        cli::array<char16_t> *chars = (new cli::array<char16_t>(numChars));
        GetChars_d7b47e17fd0a13f2(bytes, 0, bytes->get_Length(), chars, 0);
        return chars;
    }
    
    Decoder2* Encoding::GetDecoder_380c5e0c575e9cb5() {
        return cli::gcnew<ForwardingDecoder>(this);
    }
    
    Encoder* Encoding::GetEncoder_c3a25b0b739d51c8() {
        return cli::gcnew<ForwardingEncoder>(this);
    }
    
    System::Object* Encoding::InvokeI18N(System::String* name, cli::array<System::Object*>* args) {
        {
            cli::lock_guard{lockobj};
            if(i18nDisabled) 
            {
                return nullptr;
            }
            if(System::Reflection::Assembly::op_Equality(i18nAssembly, nullptr)) 
            {
                try {
                    try {
                        i18nAssembly = System::Reflection::Assembly::Load(_T("I18N, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756"));
                    }
                    catch(System::NotImplementedException*) {
                        i18nDisabled = true;
                        return nullptr;
                    }
                    if(System::Reflection::Assembly::op_Equality(i18nAssembly, nullptr)) 
                    {
                        return nullptr;
                    }
                }
                catch(System::SystemException*) {
                    return nullptr;
                }
            }
            System::Type *managerClass;
            try {
                managerClass = i18nAssembly->GetType_99cbfcc4e094eb08(_T("I18N.Common.Manager"));
            }
            catch(System::NotImplementedException*) {
                i18nDisabled = true;
                return nullptr;
            }
            if(System::Type::op_Equality2(managerClass, nullptr)) 
            {
                return nullptr;
            }
            System::Object *manager;
            try {
                manager = managerClass->InvokeMember_70c4601d847070a2(_T("PrimaryManager"), (System::Reflection::BindingFlags)4120L, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr);
                if((manager ==  nullptr)) 
                {
                    return nullptr;
                }
            }
            catch(System::MissingMethodException*) {
                return nullptr;
            }
            catch(System::Security::SecurityException*) {
                return nullptr;
            }
            catch(System::NotImplementedException*) {
                i18nDisabled = true;
                return nullptr;
            }
            try {
                return managerClass->InvokeMember_70c4601d847070a2(name, (System::Reflection::BindingFlags)276L, nullptr, manager, args, nullptr, nullptr, nullptr);
            }
            catch(System::MissingMethodException*) {
                return nullptr;
            }
            catch(System::Security::SecurityException*) {
                return nullptr;
            }
        }
    }
    
    Encoding* Encoding::GetEncoding(int32_t codepage) {
        if(((codepage < 0) || (codepage > 65535))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("codepage"), _T("Valid values are between 0 and 65535, inclusive."));
        }
        switch(codepage) {
            case 0: case_1765: {
                return Encoding::get_Default();
            }
            case 20127: case_1766: {
                return Encoding::get_ASCII();
            }
            case 65000: case_1767: {
                return Encoding::get_UTF7();
            }
            case 65001: case_1768: {
                return Encoding::get_UTF8();
            }
            case 12000: case_1769: {
                return Encoding::get_UTF32();
            }
            case 12001: case_1770: {
                return Encoding::get_BigEndianUTF32();
            }
            case 1200: case_1771: {
                return Encoding::get_Unicode();
            }
            case 1201: case_1772: {
                return Encoding::get_BigEndianUnicode();
            }
            case 28591: case_1773: {
                return Encoding::get_ISOLatin1();
            }
            default: case_1774: {
                break;
            }
        }
        Encoding *enc = cli::cast<Encoding*>(InvokeI18N(_T("GetEncoding"), (new cli::array<System::Object*>({cli::box(codepage)}))));
        if((enc != nullptr)) 
        {
            enc->is_readonly = true;
            return enc;
        }
        System::String *cpName = cli::concat(_T("System.Text.CP"), cli::import(codepage)->ToString_1636a0751cb9ac11());
        System::Reflection::Assembly *assembly = System::Reflection::Assembly::GetExecutingAssembly();
        System::Type *type = assembly->GetType_99cbfcc4e094eb08(cpName);
        if(System::Type::op_Inequality2(type, nullptr)) 
        {
            enc = cli::cast<Encoding*>(System::Activator::CreateInstance8(type));
            enc->is_readonly = true;
            return enc;
        }
        type = System::Type::GetType4(cpName);
        if(System::Type::op_Inequality2(type, nullptr)) 
        {
            enc = cli::cast<Encoding*>(System::Activator::CreateInstance8(type));
            enc->is_readonly = true;
            return enc;
        }
        throw cli::gcnew<System::NotSupportedException>(System::String::Format2(_T("CodePage {0} not supported"), cli::import(codepage)->ToString_1636a0751cb9ac11()));
    }
    
    System::Object* Encoding::Clone_c7ab6a38a8e4176e() {
        Encoding *e = cli::cast<Encoding*>(System::Object::MemberwiseClone());
        e->is_readonly = false;
        return e;
    }
    
    Encoding* Encoding::GetEncoding2(int32_t codepage, EncoderFallback* encoderFallback, DecoderFallback* decoderFallback) {
        if((encoderFallback ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("encoderFallback"));
        }
        if((decoderFallback ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("decoderFallback"));
        }
        Encoding *e = cli::as<Encoding*>(GetEncoding(codepage)->Clone_c7ab6a38a8e4176e());
        e->is_readonly = false;
        e->encoder_fallback = encoderFallback;
        e->decoder_fallback = decoderFallback;
        return e;
    }
    
    Encoding* Encoding::GetEncoding3(System::String* name, EncoderFallback* encoderFallback, DecoderFallback* decoderFallback) {
        if((encoderFallback ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("encoderFallback"));
        }
        if((decoderFallback ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("decoderFallback"));
        }
        Encoding *e = cli::as<Encoding*>(GetEncoding4(name)->Clone_c7ab6a38a8e4176e());
        e->is_readonly = false;
        e->encoder_fallback = encoderFallback;
        e->decoder_fallback = decoderFallback;
        return e;
    }
    
    cli::array<EncodingInfo*>* Encoding::GetEncodings() {
        if((encoding_infos ==  nullptr)) 
        {
            cli::array<int32_t> *codepages = (new cli::array<int32_t>({37, 437, 500, 708, 850, 852, 855, 857, 858, 860, 861, 862, 863, 864, 865, 866, 869, 870, 874, 875, 932, 936, 949, 950, 1026, 1047, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1200, 1201, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 10000, 10079, 12000, 12001, 20127, 20273, 20277, 20278, 20280, 20284, 20285, 20290, 20297, 20420, 20424, 20866, 20871, 21025, 21866, 28591, 28592, 28593, 28594, 28595, 28596, 28597, 28598, 28599, 28605, 38598, 50220, 50221, 50222, 51932, 51949, 54936, 57002, 57003, 57004, 57005, 57006, 57007, 57008, 57009, 57010, 57011, 65000, 65001}));
            encoding_infos = (new cli::array<EncodingInfo*>(codepages->get_Length()));
            for(int32_t i = 0; (i < codepages->get_Length()); i++) {
                encoding_infos->at(i) = cli::gcnew<EncodingInfo>(codepages->at(i));
            }
        }
        return encoding_infos;
    }
    
    bool Encoding::IsAlwaysNormalized() {
        return IsAlwaysNormalized_3d9dd6497a77d101(NormalizationForm::FormC);
    }
    
    bool Encoding::IsAlwaysNormalized_3d9dd6497a77d101(NormalizationForm form) {
        return (((int32_t)(form) ==  1) && cli::is<ASCIIEncoding>(this));
    }
    
    Encoding* Encoding::GetEncoding4(System::String* name) {
        if((name ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("name"));
        }
        System::String *converted = name->ToLowerInvariant()->Replace(u'-', u'_');
        System::String* tmp_629 = converted;
        ::System::Int32 tmp_630 = -1;
        if(::System::String::Equals3(tmp_629, _T("ascii")) ||
        ::System::String::Equals3(tmp_629, _T("us_ascii")) ||
        ::System::String::Equals3(tmp_629, _T("us")) ||
        ::System::String::Equals3(tmp_629, _T("ansi_x3.4_1968")) ||
        ::System::String::Equals3(tmp_629, _T("ansi_x3.4_1986")) ||
        ::System::String::Equals3(tmp_629, _T("cp367")) ||
        ::System::String::Equals3(tmp_629, _T("csascii")) ||
        ::System::String::Equals3(tmp_629, _T("ibm367")) ||
        ::System::String::Equals3(tmp_629, _T("iso_ir_6")) ||
        ::System::String::Equals3(tmp_629, _T("iso646_us")) ||
        ::System::String::Equals3(tmp_629, _T("iso_646.irv:1991"))) tmp_630 = 0;
        if(::System::String::Equals3(tmp_629, _T("utf_7")) ||
        ::System::String::Equals3(tmp_629, _T("csunicode11utf7")) ||
        ::System::String::Equals3(tmp_629, _T("unicode_1_1_utf_7")) ||
        ::System::String::Equals3(tmp_629, _T("unicode_2_0_utf_7")) ||
        ::System::String::Equals3(tmp_629, _T("x_unicode_1_1_utf_7")) ||
        ::System::String::Equals3(tmp_629, _T("x_unicode_2_0_utf_7"))) tmp_630 = 1;
        if(::System::String::Equals3(tmp_629, _T("utf_8")) ||
        ::System::String::Equals3(tmp_629, _T("unicode_1_1_utf_8")) ||
        ::System::String::Equals3(tmp_629, _T("unicode_2_0_utf_8")) ||
        ::System::String::Equals3(tmp_629, _T("x_unicode_1_1_utf_8")) ||
        ::System::String::Equals3(tmp_629, _T("x_unicode_2_0_utf_8"))) tmp_630 = 2;
        if(::System::String::Equals3(tmp_629, _T("utf_16")) ||
        ::System::String::Equals3(tmp_629, _T("utf_16le")) ||
        ::System::String::Equals3(tmp_629, _T("ucs_2")) ||
        ::System::String::Equals3(tmp_629, _T("unicode")) ||
        ::System::String::Equals3(tmp_629, _T("iso_10646_ucs2"))) tmp_630 = 3;
        if(::System::String::Equals3(tmp_629, _T("unicodefffe")) ||
        ::System::String::Equals3(tmp_629, _T("utf_16be"))) tmp_630 = 4;
        if(::System::String::Equals3(tmp_629, _T("utf_32")) ||
        ::System::String::Equals3(tmp_629, _T("utf_32le")) ||
        ::System::String::Equals3(tmp_629, _T("ucs_4"))) tmp_630 = 5;
        if(::System::String::Equals3(tmp_629, _T("utf_32be"))) tmp_630 = 6;
        if(::System::String::Equals3(tmp_629, _T("iso_8859_1")) ||
        ::System::String::Equals3(tmp_629, _T("latin1"))) tmp_630 = 7;
        switch(tmp_630)
        {
            case 0: case_1775: 
            {
                return GetEncoding(20127);
            }
            case 1: case_1776: 
            {
                return GetEncoding(65000);
            }
            case 2: case_1777: 
            {
                return GetEncoding(65001);
            }
            case 3: case_1778: 
            {
                return GetEncoding(1200);
            }
            case 4: case_1779: 
            {
                return GetEncoding(1201);
            }
            case 5: case_1780: 
            {
                return GetEncoding(12000);
            }
            case 6: case_1781: 
            {
                return GetEncoding(12001);
            }
            case 7: case_1782: 
            {
                return GetEncoding(28591);
            }
        }
        Encoding *enc = cli::cast<Encoding*>(InvokeI18N(_T("GetEncoding"), (new cli::array<System::Object*>({name}))));
        if((enc != nullptr)) 
        {
            return enc;
        }
        System::String *encName = cli::concat(_T("System.Text.ENC"), converted);
        System::Reflection::Assembly *assembly = System::Reflection::Assembly::GetExecutingAssembly();
        System::Type *type = assembly->GetType_99cbfcc4e094eb08(encName);
        if(System::Type::op_Inequality2(type, nullptr)) 
        {
            return cli::cast<Encoding*>(System::Activator::CreateInstance8(type));
        }
        type = System::Type::GetType4(encName);
        if(System::Type::op_Inequality2(type, nullptr)) 
        {
            return cli::cast<Encoding*>(System::Activator::CreateInstance8(type));
        }
        throw cli::gcnew<System::ArgumentException>(System::String::Format2(_T("Encoding name \'{0}\' not supported"), name), _T("name"));
    }
    
    int32_t Encoding::GetHashCode_6648aef0f235ee6c() {
        return ((this->get_DecoderFallback()->GetHashCode_6648aef0f235ee6c() << ((24 + this->get_EncoderFallback()->GetHashCode_6648aef0f235ee6c()) & 31)) << ((16 + this->codePage) & 31));
    }
    
    cli::array<unsigned char>* Encoding::GetPreamble_15ff85f00c460f87() {
        return (new cli::array<unsigned char>(0));
    }
    
    System::String* Encoding::GetString_39f4843197ddbe92(cli::array<unsigned char>* bytes, int32_t index, int32_t count) {
        return cli::gcnew<System::String>(GetChars_66b39e5249276d4a(bytes, index, count));
    }
    
    System::String* Encoding::GetString_12d22365648431d7(cli::array<unsigned char>* bytes) {
        if((bytes ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("bytes"));
        }
        return GetString_39f4843197ddbe92(bytes, 0, bytes->get_Length());
    }
    
    System::String* Encoding::InternalCodePage(int32_t code_page) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t Encoding::GetByteCount_aec9823bd32c6735(char16_t* chars, int32_t count) {
        if((chars ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("chars"));
        }
        if((count < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("count"));
        }
        cli::array<char16_t> *c = (new cli::array<char16_t>(count));
        for(int32_t p = 0; (p < count); p++) {
            c->at(p) = (*(chars + p));
        }
        return GetByteCount_8ddd893811c6fb16(c);
    }
    
    int32_t Encoding::GetCharCount_4e601cea7c3f10cd(unsigned char* bytes, int32_t count) {
        if((bytes ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("bytes"));
        }
        if((count < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("count"));
        }
        cli::array<unsigned char> *ba = (new cli::array<unsigned char>(count));
        for(int32_t i = 0; (i < count); i++) {
            ba->at(i) = (*(bytes + i));
        }
        return GetCharCount_aa33a7717b095c8e(ba, 0, count);
    }
    
    int32_t Encoding::GetChars_8904b350d20e4ab8(unsigned char* bytes, int32_t byteCount, char16_t* chars, int32_t charCount) {
        if((bytes ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("bytes"));
        }
        if((chars ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("chars"));
        }
        if((charCount < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("charCount"));
        }
        if((byteCount < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("byteCount"));
        }
        cli::array<unsigned char> *ba = (new cli::array<unsigned char>(byteCount));
        for(int32_t i = 0; (i < byteCount); i++) {
            ba->at(i) = (*(bytes + i));
        }
        cli::array<char16_t> *ret = GetChars_66b39e5249276d4a(ba, 0, byteCount);
        int32_t top = ret->get_Length();
        if((top > charCount)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("charCount is less than the number of characters produced"), _T("charCount"));
        }
        for(int32_t i = 0; (i < top); i++) {
            (*(chars + i)) = ret->at(i);
        }
        return top;
    }
    
    int32_t Encoding::GetBytes_9b94592fd1d1a5af(char16_t* chars, int32_t charCount, unsigned char* bytes, int32_t byteCount) {
        if((bytes ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("bytes"));
        }
        if((chars ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("chars"));
        }
        if((charCount < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("charCount"));
        }
        if((byteCount < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("byteCount"));
        }
        cli::array<char16_t> *c = (new cli::array<char16_t>(charCount));
        for(int32_t i = 0; (i < charCount); i++) {
            c->at(i) = (*(chars + i));
        }
        cli::array<unsigned char> *b = GetBytes_d1513e6a9072eb1(c, 0, charCount);
        int32_t top = b->get_Length();
        if((top > byteCount)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("byteCount is less that the number of bytes produced"), _T("byteCount"));
        }
        for(int32_t i = 0; (i < top); i++) {
            (*(bytes + i)) = b->at(i);
        }
        return b->get_Length();
    }
    
    bool Encoding::get_IsReadOnly() {
        return this->is_readonly;
    }
    
    bool Encoding::get_IsSingleByte_35caa6a029e2b816() {
        return false;
    }
    
    DecoderFallback* Encoding::get_DecoderFallback() {
        return this->decoder_fallback;
    }
    
    DecoderFallback* Encoding::set_DecoderFallback(DecoderFallback* value) {
        if(this->get_IsReadOnly()) 
        {
            throw cli::gcnew<System::InvalidOperationException>(_T("This Encoding is readonly."));
        }
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>();
        }
        this->decoder_fallback = value;
        return get_DecoderFallback();
    }
    
    EncoderFallback* Encoding::get_EncoderFallback() {
        return this->encoder_fallback;
    }
    
    EncoderFallback* Encoding::set_EncoderFallback(EncoderFallback* value) {
        if(this->get_IsReadOnly()) 
        {
            throw cli::gcnew<System::InvalidOperationException>(_T("This Encoding is readonly."));
        }
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>();
        }
        this->encoder_fallback = value;
        return get_EncoderFallback();
    }
    
    System::String* Encoding::get_BodyName_4e100a97a0424038() {
        return this->body_name;
    }
    
    int32_t Encoding::get_CodePage_91fb8f67e293f9c5() {
        return this->codePage;
    }
    
    System::String* Encoding::get_EncodingName_cceb96db74b2252b() {
        return this->encoding_name;
    }
    
    System::String* Encoding::get_HeaderName_905c2b4b7e3e3c75() {
        return this->header_name;
    }
    
    bool Encoding::get_IsBrowserDisplay_52cbc4f0fcb00858() {
        return this->is_browser_display;
    }
    
    bool Encoding::get_IsBrowserSave_1e19416373d08662() {
        return this->is_browser_save;
    }
    
    bool Encoding::get_IsMailNewsDisplay_53d46b3981a20587() {
        return this->is_mail_news_display;
    }
    
    bool Encoding::get_IsMailNewsSave_217a4ecd1696aff8() {
        return this->is_mail_news_save;
    }
    
    System::String* Encoding::get_WebName_baa3e40df8ce4d3e() {
        return this->web_name;
    }
    
    int32_t Encoding::get_WindowsCodePage_c9469fd7af078754() {
        return this->windows_code_page;
    }
    
    Encoding* Encoding::get_ASCII() {
        if((asciiEncoding ==  nullptr)) 
        {
            {
                cli::lock_guard{lockobj};
                if((asciiEncoding ==  nullptr)) 
                {
                    asciiEncoding = cli::gcnew<ASCIIEncoding>();
                }
            }
        }
        return asciiEncoding;
    }
    
    Encoding* Encoding::get_BigEndianUnicode() {
        if((bigEndianEncoding ==  nullptr)) 
        {
            {
                cli::lock_guard{lockobj};
                if((bigEndianEncoding ==  nullptr)) 
                {
                    bigEndianEncoding = cli::gcnew<UnicodeEncoding>(true, true);
                }
            }
        }
        return bigEndianEncoding;
    }
    
    Encoding* Encoding::get_Default() {
        if((defaultEncoding ==  nullptr)) 
        {
            {
                cli::lock_guard{lockobj};
                if((defaultEncoding ==  nullptr)) 
                {
                    int32_t code_page = 1;
                    System::String *code_page_name = InternalCodePage(code_page);
                    try {
                        if((code_page ==  -1)) 
                        {
                            defaultEncoding = GetEncoding4(code_page_name);
                        }
                         else 
                        {
                            code_page = (code_page & 268435455);
                            switch(code_page) {
                                case 1: case_1783: {
                                    code_page = 20127;
                                    break;
                                }
                                case 2: case_1784: {
                                    code_page = 65000;
                                    break;
                                }
                                case 3: case_1785: {
                                    code_page = 65001;
                                    break;
                                }
                                case 4: case_1786: {
                                    code_page = 1200;
                                    break;
                                }
                                case 5: case_1787: {
                                    code_page = 1201;
                                    break;
                                }
                                case 6: case_1788: {
                                    code_page = 28591;
                                    break;
                                }
                            }
                            defaultEncoding = GetEncoding(code_page);
                        }
                    }
                    catch(System::NotSupportedException*) {
                        defaultEncoding = get_UTF8Unmarked();
                    }
                    catch(System::ArgumentException*) {
                        defaultEncoding = get_UTF8Unmarked();
                    }
                    defaultEncoding->is_readonly = true;
                }
            }
        }
        return defaultEncoding;
    }
    
    Encoding* Encoding::get_ISOLatin1() {
        if((isoLatin1Encoding ==  nullptr)) 
        {
            {
                cli::lock_guard{lockobj};
                if((isoLatin1Encoding ==  nullptr)) 
                {
                    isoLatin1Encoding = cli::gcnew<Latin1Encoding>();
                }
            }
        }
        return isoLatin1Encoding;
    }
    
    Encoding* Encoding::get_UTF7() {
        if((utf7Encoding ==  nullptr)) 
        {
            {
                cli::lock_guard{lockobj};
                if((utf7Encoding ==  nullptr)) 
                {
                    utf7Encoding = cli::gcnew<UTF7Encoding>();
                }
            }
        }
        return utf7Encoding;
    }
    
    Encoding* Encoding::get_UTF8() {
        if((utf8EncodingWithMarkers ==  nullptr)) 
        {
            {
                cli::lock_guard{lockobj};
                if((utf8EncodingWithMarkers ==  nullptr)) 
                {
                    utf8EncodingWithMarkers = cli::gcnew<UTF8Encoding>(true);
                }
            }
        }
        return utf8EncodingWithMarkers;
    }
    
    Encoding* Encoding::get_UTF8Unmarked() {
        if((utf8EncodingWithoutMarkers ==  nullptr)) 
        {
            {
                cli::lock_guard{lockobj};
                if((utf8EncodingWithoutMarkers ==  nullptr)) 
                {
                    utf8EncodingWithoutMarkers = cli::gcnew<UTF8Encoding>(false, false);
                }
            }
        }
        return utf8EncodingWithoutMarkers;
    }
    
    Encoding* Encoding::get_UTF8UnmarkedUnsafe() {
        if((utf8EncodingUnsafe ==  nullptr)) 
        {
            {
                cli::lock_guard{lockobj};
                if((utf8EncodingUnsafe ==  nullptr)) 
                {
                    utf8EncodingUnsafe = cli::gcnew<UTF8Encoding>(false, false);
                    utf8EncodingUnsafe->is_readonly = false;
                    utf8EncodingUnsafe->set_DecoderFallback(cli::gcnew<DecoderReplacementFallback>(System::String::Empty));
                    utf8EncodingUnsafe->is_readonly = true;
                }
            }
        }
        return utf8EncodingUnsafe;
    }
    
    Encoding* Encoding::get_Unicode() {
        if((unicodeEncoding ==  nullptr)) 
        {
            {
                cli::lock_guard{lockobj};
                if((unicodeEncoding ==  nullptr)) 
                {
                    unicodeEncoding = cli::gcnew<UnicodeEncoding>(false, true);
                }
            }
        }
        return unicodeEncoding;
    }
    
    Encoding* Encoding::get_UTF32() {
        if((utf32Encoding ==  nullptr)) 
        {
            {
                cli::lock_guard{lockobj};
                if((utf32Encoding ==  nullptr)) 
                {
                    utf32Encoding = cli::gcnew<UTF32Encoding>(false, true);
                }
            }
        }
        return utf32Encoding;
    }
    
    Encoding* Encoding::get_BigEndianUTF32() {
        if((bigEndianUTF32Encoding ==  nullptr)) 
        {
            {
                cli::lock_guard{lockobj};
                if((bigEndianUTF32Encoding ==  nullptr)) 
                {
                    bigEndianUTF32Encoding = cli::gcnew<UTF32Encoding>(true, true);
                }
            }
        }
        return bigEndianUTF32Encoding;
    }
    
}}
namespace System { namespace Text {
    
    
    void EncodingInfo::constructor(int32_t cp) {
        this->codepage = cp;
    }
    
    bool EncodingInfo::Equals_ed975d2f4a7d193e(System::Object* value) {
        EncodingInfo *ei = cli::as<EncodingInfo*>(value);
        return ((ei != nullptr) && (ei->codepage ==  this->codepage));
    }
    
    int32_t EncodingInfo::GetHashCode_6648aef0f235ee6c() {
        return this->codepage;
    }
    
    Encoding* EncodingInfo::GetEncoding() {
        return Encoding::GetEncoding(this->codepage);
    }
    
    int32_t EncodingInfo::get_CodePage() {
        return this->codepage;
    }
    
    System::String* EncodingInfo::get_DisplayName() {
        return this->get_Name();
    }
    
    System::String* EncodingInfo::get_Name() {
        if((this->encoding ==  nullptr)) 
        {
            this->encoding = GetEncoding();
        }
        return this->encoding->get_WebName_baa3e40df8ce4d3e();
    }
    
}}
namespace System { namespace Text {
    
    
    void Latin1Encoding::constructor() {
    }
    
    bool Latin1Encoding::IsAlwaysNormalized_3d9dd6497a77d101(NormalizationForm form) {
        return ((int32_t)(form) ==  1);
    }
    
    int32_t Latin1Encoding::GetByteCount_7494b18116693a5e(cli::array<char16_t>* chars, int32_t index, int32_t count) {
        if((chars ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("chars"));
        }
        if(((index < 0) || (index > chars->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("index"), Encoding::_(_T("ArgRange_Array")));
        }
        if(((count < 0) || (count > (chars->get_Length() - index)))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("count"), Encoding::_(_T("ArgRange_Array")));
        }
        return count;
    }
    
    int32_t Latin1Encoding::GetByteCount_d98cd1485dc2ee98(System::String* s) {
        if((s ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("s"));
        }
        return s->get_Length();
    }
    
    int32_t Latin1Encoding::GetBytes_90650b3cf924e5e2(cli::array<char16_t>* chars, int32_t charIndex, int32_t charCount, cli::array<unsigned char>* bytes, int32_t byteIndex) {
        EncoderFallbackBuffer *buffer = nullptr;
        cli::array<char16_t> *fallback_chars = nullptr;
        return GetBytes8(chars, charIndex, charCount, bytes, byteIndex, buffer, fallback_chars);
    }
    
    int32_t Latin1Encoding::GetBytes8(cli::array<char16_t>* chars, int32_t charIndex, int32_t charCount, cli::array<unsigned char>* bytes, int32_t byteIndex, EncoderFallbackBuffer* buffer, cli::array<char16_t>* fallback_chars) {
        if((chars ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("chars"));
        }
        {
            /* FIXED - BLOCK */
            char16_t* cptr = cli::fixed_guard(((chars ==  nullptr) || (chars->get_Length() ==  0)) ? nullptr : chars);
            return InternalGetBytes(cptr, chars->get_Length(), charIndex, charCount, bytes, byteIndex, buffer, fallback_chars);
        }
    }
    
    int32_t Latin1Encoding::GetBytes_3384066dd8b91ed8(System::String* s, int32_t charIndex, int32_t charCount, cli::array<unsigned char>* bytes, int32_t byteIndex) {
        EncoderFallbackBuffer *buffer = nullptr;
        cli::array<char16_t> *fallback_chars = nullptr;
        return GetBytes10(s, charIndex, charCount, bytes, byteIndex, buffer, fallback_chars);
    }
    
    int32_t Latin1Encoding::GetBytes10(System::String* s, int32_t charIndex, int32_t charCount, cli::array<unsigned char>* bytes, int32_t byteIndex, EncoderFallbackBuffer* buffer, cli::array<char16_t>* fallback_chars) {
        if((s ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("s"));
        }
        {
            /* FIXED - BLOCK */
            char16_t* chars = cli::fixed_guard(s);
            return InternalGetBytes(chars, s->get_Length(), charIndex, charCount, bytes, byteIndex, buffer, fallback_chars);
        }
    }
    
    int32_t Latin1Encoding::InternalGetBytes(char16_t* chars, int32_t charLength, int32_t charIndex, int32_t charCount, cli::array<unsigned char>* bytes, int32_t byteIndex, EncoderFallbackBuffer* buffer, cli::array<char16_t>* fallback_chars) {
        if((bytes ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("bytes"));
        }
        if(((charIndex < 0) || (charIndex > charLength))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("charIndex"), Encoding::_(_T("ArgRange_Array")));
        }
        if(((charCount < 0) || (charCount > (charLength - charIndex)))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("charCount"), Encoding::_(_T("ArgRange_Array")));
        }
        if(((byteIndex < 0) || (byteIndex > bytes->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("byteIndex"), Encoding::_(_T("ArgRange_Array")));
        }
        if(((bytes->get_Length() - byteIndex) < charCount)) 
        {
            throw cli::gcnew<System::ArgumentException>(Encoding::_(_T("Arg_InsufficientSpace")));
        }
        int32_t count = charCount;
        char16_t ch;
        while((count-- > 0)) {
            ch = (*(chars + charIndex++));
            if(((int32_t)(ch) < 256)) 
            {
                bytes->at(byteIndex++) = (unsigned char)ch;
            }
             else 
            {
                if((((int32_t)(ch) >= 65281) && ((int32_t)(ch) <= 65374))) 
                {
                    bytes->at(byteIndex++) = (unsigned char)((int32_t)(ch) - 65248);
                }
                 else 
                {
                    if((buffer ==  nullptr)) 
                    {
                        buffer = this->get_EncoderFallback()->CreateFallbackBuffer_a579589a4ca0924f();
                    }
                    if(((System::Char::IsSurrogate(ch) && (count > 1)) && System::Char::IsSurrogate((*(chars + charIndex))))) 
                    {
                        buffer->Fallback_571cd731a6ea7558(ch, (*(chars + charIndex)), (charIndex++ - 1));
                    }
                     else 
                    {
                        buffer->Fallback_2e254195ffd348dc(ch, (charIndex - 1));
                    }
                    if(((fallback_chars ==  nullptr) || (fallback_chars->get_Length() < buffer->get_Remaining_dd4149ac6c4a9379()))) 
                    {
                        fallback_chars = (new cli::array<char16_t>(buffer->get_Remaining_dd4149ac6c4a9379()));
                    }
                    for(int32_t i = 0; (i < fallback_chars->get_Length()); i++) {
                        fallback_chars->at(i) = buffer->GetNextChar_84e759436123fac0();
                    }
                    (byteIndex = byteIndex + GetBytes8(fallback_chars, 0, fallback_chars->get_Length(), bytes, byteIndex, buffer, fallback_chars));
                }
            }
        }
        return charCount;
    }
    
    int32_t Latin1Encoding::GetCharCount_aa33a7717b095c8e(cli::array<unsigned char>* bytes, int32_t index, int32_t count) {
        if((bytes ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("bytes"));
        }
        if(((index < 0) || (index > bytes->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("index"), Encoding::_(_T("ArgRange_Array")));
        }
        if(((count < 0) || (count > (bytes->get_Length() - index)))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("count"), Encoding::_(_T("ArgRange_Array")));
        }
        return count;
    }
    
    int32_t Latin1Encoding::GetChars_d7b47e17fd0a13f2(cli::array<unsigned char>* bytes, int32_t byteIndex, int32_t byteCount, cli::array<char16_t>* chars, int32_t charIndex) {
        if((bytes ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("bytes"));
        }
        if((chars ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("chars"));
        }
        if(((byteIndex < 0) || (byteIndex > bytes->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("byteIndex"), Encoding::_(_T("ArgRange_Array")));
        }
        if(((byteCount < 0) || (byteCount > (bytes->get_Length() - byteIndex)))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("byteCount"), Encoding::_(_T("ArgRange_Array")));
        }
        if(((charIndex < 0) || (charIndex > chars->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("charIndex"), Encoding::_(_T("ArgRange_Array")));
        }
        if(((chars->get_Length() - charIndex) < byteCount)) 
        {
            throw cli::gcnew<System::ArgumentException>(Encoding::_(_T("Arg_InsufficientSpace")));
        }
        int32_t count = byteCount;
        while((count-- > 0)) {
            chars->at(charIndex++) = (char16_t)bytes->at(byteIndex++);
        }
        return byteCount;
    }
    
    int32_t Latin1Encoding::GetMaxByteCount_5bd2cee34757a0d4(int32_t charCount) {
        if((charCount < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("charCount"), Encoding::_(_T("ArgRange_NonNegative")));
        }
        return charCount;
    }
    
    int32_t Latin1Encoding::GetMaxCharCount_4eba560ac1240518(int32_t byteCount) {
        if((byteCount < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("byteCount"), Encoding::_(_T("ArgRange_NonNegative")));
        }
        return byteCount;
    }
    
    System::String* Latin1Encoding::GetString_39f4843197ddbe92(cli::array<unsigned char>* bytes, int32_t index, int32_t count) {
        if((bytes ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("bytes"));
        }
        if(((index < 0) || (index > bytes->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("index"), Encoding::_(_T("ArgRange_Array")));
        }
        if(((count < 0) || (count > (bytes->get_Length() - index)))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("count"), Encoding::_(_T("ArgRange_Array")));
        }
        if((count ==  0)) 
        {
            return System::String::Empty;
        }
        {
            /* FIXED - BLOCK */
            unsigned char* bytePtr = cli::fixed_guard(((bytes ==  nullptr) || (bytes->get_Length() ==  0)) ? nullptr : bytes);
            System::String *s = System::String::InternalAllocateStr(count);
            {
                /* FIXED - BLOCK */
                char16_t* charPtr = cli::fixed_guard(s);
                unsigned char *currByte = (bytePtr + (int32_t)(index));
                unsigned char *lastByte = (currByte + (int32_t)(count));
                char16_t *currChar = charPtr;
                while((currByte < lastByte)) (*(currChar++ + 0)) = (char16_t)(*(currByte++ + 0));
            }
            return s;
        }
    }
    
    System::String* Latin1Encoding::GetString_12d22365648431d7(cli::array<unsigned char>* bytes) {
        if((bytes ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("bytes"));
        }
        return Encoding::GetString_39f4843197ddbe92(bytes, 0, bytes->get_Length());
    }
    
    bool Latin1Encoding::get_IsSingleByte_35caa6a029e2b816() {
        return true;
    }
    
    System::String* Latin1Encoding::get_BodyName_4e100a97a0424038() {
        return _T("iso-8859-1");
    }
    
    System::String* Latin1Encoding::get_EncodingName_cceb96db74b2252b() {
        return _T("Western European (ISO)");
    }
    
    System::String* Latin1Encoding::get_HeaderName_905c2b4b7e3e3c75() {
        return _T("iso-8859-1");
    }
    
    bool Latin1Encoding::get_IsBrowserDisplay_52cbc4f0fcb00858() {
        return true;
    }
    
    bool Latin1Encoding::get_IsBrowserSave_1e19416373d08662() {
        return true;
    }
    
    bool Latin1Encoding::get_IsMailNewsDisplay_53d46b3981a20587() {
        return true;
    }
    
    bool Latin1Encoding::get_IsMailNewsSave_217a4ecd1696aff8() {
        return true;
    }
    
    System::String* Latin1Encoding::get_WebName_baa3e40df8ce4d3e() {
        return _T("iso-8859-1");
    }
    
}}
namespace System { namespace Text {
    
    
    void MLangEncoder::constructor(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        if((info ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("info"));
        }
        this->encoding = cli::cast<Encoding*>(info->GetValue(_T("m_encoding"), cli::typeof<System::Type>::info));
    }
    
    void MLangEncoder::GetObjectData(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        throw cli::gcnew<System::ArgumentException>(_T("This class cannot be serialized."));
    }
    
    System::Object* MLangEncoder::GetRealObject(System::Runtime::Serialization::StreamingContext context) {
        if((this->realObject ==  nullptr)) 
        {
            this->realObject = this->encoding->GetEncoder_c3a25b0b739d51c8();
        }
        return this->realObject;
    }
    
}}
namespace System { namespace Text {
    
    
    void MLangDecoder::constructor(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        if((info ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("info"));
        }
        this->encoding = cli::cast<Encoding*>(info->GetValue(_T("m_encoding"), cli::typeof<System::Type>::info));
    }
    
    void MLangDecoder::GetObjectData(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        throw cli::gcnew<System::ArgumentException>(_T("This class cannot be serialized."));
    }
    
    System::Object* MLangDecoder::GetRealObject(System::Runtime::Serialization::StreamingContext context) {
        if((this->realObject ==  nullptr)) 
        {
            this->realObject = this->encoding->GetDecoder_380c5e0c575e9cb5();
        }
        return this->realObject;
    }
    
}}
namespace System { namespace Text {
    
    
    void MLangCodePageEncoding::constructor(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        if((info ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("info"));
        }
        this->codePage = cli::unbox<int32_t>(info->GetValue(_T("m_codePage"), cli::typeof<System::Type>::info));
        try {
            this->isReadOnly = cli::unbox<bool>(info->GetValue(_T("m_isReadOnly"), cli::typeof<System::Type>::info));
            this->encoderFallback = cli::cast<EncoderFallback*>(info->GetValue(_T("encoderFallback"), cli::typeof<System::Type>::info));
            this->decoderFallback = cli::cast<DecoderFallback*>(info->GetValue(_T("decoderFallback"), cli::typeof<System::Type>::info));
        }
        catch(System::Runtime::Serialization::SerializationException*) {
            this->isReadOnly = true;
        }
    }
    
    void MLangCodePageEncoding::GetObjectData(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        throw cli::gcnew<System::ArgumentException>(_T("This class cannot be serialized."));
    }
    
    System::Object* MLangCodePageEncoding::GetRealObject(System::Runtime::Serialization::StreamingContext context) {
        if((this->realObject ==  nullptr)) 
        {
            Encoding *encoding = Encoding::GetEncoding(this->codePage);
            if(!(this->isReadOnly)) 
            {
                encoding = cli::cast<Encoding*>(encoding->Clone_c7ab6a38a8e4176e());
                encoding->set_EncoderFallback(this->encoderFallback);
                encoding->set_DecoderFallback(this->decoderFallback);
            }
            this->realObject = encoding;
        }
        return this->realObject;
    }
    
}}
namespace System { namespace Text {
    
    
    void StringBuilder::constructor(System::String* value, int32_t startIndex, int32_t length, int32_t capacity) {
    }
    
    void StringBuilder::constructor(System::String* value, int32_t startIndex, int32_t length, int32_t capacity, int32_t maxCapacity) {
        if((value ==  nullptr)) 
        {
            value = _T("");
        }
        if((startIndex < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("startIndex"), cli::box(startIndex), _T("StartIndex cannot be less than zero."));
        }
        if((length < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("length"), cli::box(length), _T("Length cannot be less than zero."));
        }
        if((capacity < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("capacity"), cli::box(capacity), _T("capacity must be greater than zero."));
        }
        if((maxCapacity < 1)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("maxCapacity"), _T("maxCapacity is less than one."));
        }
        if((capacity > maxCapacity)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("capacity"), _T("Capacity exceeds maximum capacity."));
        }
        if((startIndex > (value->get_Length() - length))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("startIndex"), cli::box(startIndex), _T("StartIndex and length must refer to a location within the string."));
        }
        if((capacity ==  0)) 
        {
            if((maxCapacity > 16)) 
            {
                capacity = 16;
            }
             else 
            {
                this->_str = this->_cached_str = System::String::Empty;
            }
        }
        this->_maxCapacity = maxCapacity;
        if((this->_str ==  nullptr)) 
        {
            this->_str = System::String::InternalAllocateStr((length > capacity) ? length : capacity);
        }
        if((length > 0)) 
        {
            System::String::CharCopy2(this->_str, 0, value, startIndex, length);
        }
        this->_length = length;
    }
    
    void StringBuilder::constructor() {
    }
    
    void StringBuilder::constructor(int32_t capacity) {
    }
    
    void StringBuilder::constructor(int32_t capacity, int32_t maxCapacity) {
    }
    
    void StringBuilder::constructor(System::String* value) {
        if((value ==  nullptr)) 
        {
            value = _T("");
        }
        this->_length = value->get_Length();
        this->_str = this->_cached_str = value;
        this->_maxCapacity = 2147483647;
    }
    
    void StringBuilder::constructor(System::String* value, int32_t capacity) {
    }
    
    void StringBuilder::constructor(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        System::String *s = info->GetString(_T("m_StringValue"));
        if((s ==  nullptr)) 
        {
            s = _T("");
        }
        this->_length = s->get_Length();
        this->_str = this->_cached_str = s;
        this->_maxCapacity = info->GetInt32(_T("m_MaxCapacity"));
        if((this->_maxCapacity < 0)) 
        {
            this->_maxCapacity = 2147483647;
        }
        this->set_Capacity(info->GetInt32(_T("Capacity")));
    }
    
    System::String* StringBuilder::ToString_1636a0751cb9ac11() {
        if((this->_length ==  0)) 
        {
            return System::String::Empty;
        }
        if((this->_cached_str != nullptr)) 
        {
            return this->_cached_str;
        }
        if(((this->_length < (this->_str->get_Length() >> 1)) || ((this->_str->get_Length() > System::String::LOS_limit) && (this->_length <= System::String::LOS_limit)))) 
        {
            this->_cached_str = this->_str->SubstringUnchecked(0, this->_length);
            return this->_cached_str;
        }
        this->_cached_str = this->_str;
        this->_str->InternalSetLength(this->_length);
        return this->_str;
    }
    
    System::String* StringBuilder::ToString3(int32_t startIndex, int32_t length) {
        if((((startIndex < 0) || (length < 0)) || (startIndex > (this->_length - length)))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>();
        }
        if(((startIndex ==  0) && (length ==  this->_length))) 
        {
            return System::Object::ToString_1636a0751cb9ac11();
        }
         else 
        {
            return this->_str->SubstringUnchecked(startIndex, length);
        }
    }
    
    int32_t StringBuilder::EnsureCapacity(int32_t capacity) {
        if((capacity < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("Capacity must be greater than 0."));
        }
        if((capacity <= this->_str->get_Length())) 
        {
            return this->_str->get_Length();
        }
        InternalEnsureCapacity(capacity);
        return this->_str->get_Length();
    }
    
    bool StringBuilder::Equals3(StringBuilder* sb) {
        if((cli::cast<System::Object*>(sb) ==  nullptr)) 
        {
            return false;
        }
        if(((this->_length ==  sb->get_Length()) && System::String::op_Equality(this->_str, sb->_str))) 
        {
            return true;
        }
        return false;
    }
    
    StringBuilder* StringBuilder::Remove(int32_t startIndex, int32_t length) {
        if((((startIndex < 0) || (length < 0)) || (startIndex > (this->_length - length)))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>();
        }
        if((this->_cached_str != nullptr)) 
        {
            InternalEnsureCapacity(this->_length);
        }
        if(((this->_length - (startIndex + length)) > 0)) 
        {
            System::String::CharCopy2(this->_str, startIndex, this->_str, (startIndex + length), (this->_length - (startIndex + length)));
        }
        (this->_length = this->_length - length);
        return this;
    }
    
    StringBuilder* StringBuilder::Replace(char16_t oldChar, char16_t newChar) {
        return Replace2(oldChar, newChar, 0, this->_length);
    }
    
    StringBuilder* StringBuilder::Replace2(char16_t oldChar, char16_t newChar, int32_t startIndex, int32_t count) {
        if((((startIndex > (this->_length - count)) || (startIndex < 0)) || (count < 0))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>();
        }
        if((this->_cached_str != nullptr)) 
        {
            InternalEnsureCapacity(this->_str->get_Length());
        }
        for(int32_t replaceIterate = startIndex; (replaceIterate < (startIndex + count)); replaceIterate++){
            if(((int32_t)(this->_str->get_Chars(replaceIterate)) ==  (int32_t)(oldChar))) 
            {
                this->_str->InternalSetChar(replaceIterate, newChar);
            }
        }
        return this;
    }
    
    StringBuilder* StringBuilder::Replace3(System::String* oldValue, System::String* newValue) {
        return Replace4(oldValue, newValue, 0, this->_length);
    }
    
    StringBuilder* StringBuilder::Replace4(System::String* oldValue, System::String* newValue, int32_t startIndex, int32_t count) {
        if((oldValue ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("The old value cannot be null."));
        }
        if((((startIndex < 0) || (count < 0)) || (startIndex > (this->_length - count)))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>();
        }
        if((oldValue->get_Length() ==  0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("The old value cannot be zero length."));
        }
        System::String *substr = this->_str->Substring2(startIndex, count);
        System::String *replace = substr->Replace2(oldValue, newValue);
        if((cli::cast<System::Object*>(replace) ==  cli::cast<System::Object*>(substr))) 
        {
            return this;
        }
        InternalEnsureCapacity((replace->get_Length() + (this->_length - count)));
        if((replace->get_Length() < count)) 
        {
            System::String::CharCopy2(this->_str, (startIndex + replace->get_Length()), this->_str, (startIndex + count), ((this->_length - startIndex) - count));
        }
         else 
        {
            if((replace->get_Length() > count)) 
            {
                System::String::CharCopyReverse2(this->_str, (startIndex + replace->get_Length()), this->_str, (startIndex + count), ((this->_length - startIndex) - count));
            }
        }
        System::String::CharCopy2(this->_str, startIndex, replace, 0, replace->get_Length());
        this->_length = (replace->get_Length() + (this->_length - count));
        return this;
    }
    
    StringBuilder* StringBuilder::Append(cli::array<char16_t>* value) {
        if((value ==  nullptr)) 
        {
            return this;
        }
        int32_t needed_cap = (this->_length + value->get_Length());
        if(((this->_cached_str != nullptr) || (this->_str->get_Length() < needed_cap))) 
        {
            InternalEnsureCapacity(needed_cap);
        }
        System::String::CharCopy3(this->_str, this->_length, value, 0, value->get_Length());
        this->_length = needed_cap;
        return this;
    }
    
    StringBuilder* StringBuilder::Append2(System::String* value) {
        if((value ==  nullptr)) 
        {
            return this;
        }
        if((((this->_length ==  0) && (value->get_Length() < this->_maxCapacity)) && (value->get_Length() > this->_str->get_Length()))) 
        {
            this->_length = value->get_Length();
            this->_str = this->_cached_str = value;
            return this;
        }
        int32_t needed_cap = (this->_length + value->get_Length());
        if(((this->_cached_str != nullptr) || (this->_str->get_Length() < needed_cap))) 
        {
            InternalEnsureCapacity(needed_cap);
        }
        System::String::CharCopy2(this->_str, this->_length, value, 0, value->get_Length());
        this->_length = needed_cap;
        return this;
    }
    
    StringBuilder* StringBuilder::Append3(bool value) {
        return Append2(cli::import(value)->ToString_1636a0751cb9ac11());
    }
    
    StringBuilder* StringBuilder::Append4(unsigned char value) {
        return Append2(cli::import(value)->ToString_1636a0751cb9ac11());
    }
    
    StringBuilder* StringBuilder::Append5(System::Decimal value) {
        return Append2(value->ToString_1636a0751cb9ac11());
    }
    
    StringBuilder* StringBuilder::Append6(double value) {
        return Append2(cli::import(value)->ToString_1636a0751cb9ac11());
    }
    
    StringBuilder* StringBuilder::Append7(int16_t value) {
        return Append2(cli::import(value)->ToString_1636a0751cb9ac11());
    }
    
    StringBuilder* StringBuilder::Append8(int32_t value) {
        return Append2(cli::import(value)->ToString_1636a0751cb9ac11());
    }
    
    StringBuilder* StringBuilder::Append9(int64_t value) {
        return Append2(cli::import(value)->ToString_1636a0751cb9ac11());
    }
    
    StringBuilder* StringBuilder::Append10(System::Object* value) {
        if((value ==  nullptr)) 
        {
            return this;
        }
        return Append2(value->ToString_1636a0751cb9ac11());
    }
    
    StringBuilder* StringBuilder::Append11(signed char value) {
        return Append2(cli::import(value)->ToString_1636a0751cb9ac11());
    }
    
    StringBuilder* StringBuilder::Append12(float value) {
        return Append2(cli::import(value)->ToString_1636a0751cb9ac11());
    }
    
    StringBuilder* StringBuilder::Append13(uint16_t value) {
        return Append2(cli::import(value)->ToString_1636a0751cb9ac11());
    }
    
    StringBuilder* StringBuilder::Append14(uint32_t value) {
        return Append2(cli::import(value)->ToString_1636a0751cb9ac11());
    }
    
    StringBuilder* StringBuilder::Append15(uint64_t value) {
        return Append2(cli::import(value)->ToString_1636a0751cb9ac11());
    }
    
    StringBuilder* StringBuilder::Append16(char16_t value) {
        int32_t needed_cap = (this->_length + 1);
        if(((this->_cached_str != nullptr) || (this->_str->get_Length() < needed_cap))) 
        {
            InternalEnsureCapacity(needed_cap);
        }
        this->_str->InternalSetChar(this->_length, value);
        this->_length = needed_cap;
        return this;
    }
    
    StringBuilder* StringBuilder::Append17(char16_t value, int32_t repeatCount) {
        if((repeatCount < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>();
        }
        InternalEnsureCapacity((this->_length + repeatCount));
        for(int32_t i = 0; (i < repeatCount); i++) {
            this->_str->InternalSetChar(this->_length++, value);
        }
        return this;
    }
    
    StringBuilder* StringBuilder::Append18(cli::array<char16_t>* value, int32_t startIndex, int32_t charCount) {
        if((value ==  nullptr)) 
        {
            if(!(((startIndex ==  0) && (charCount ==  0)))) 
            {
                throw cli::gcnew<System::ArgumentNullException>(_T("value"));
            }
            return this;
        }
        if((((charCount < 0) || (startIndex < 0)) || (startIndex > (value->get_Length() - charCount)))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>();
        }
        int32_t needed_cap = (this->_length + charCount);
        InternalEnsureCapacity(needed_cap);
        System::String::CharCopy3(this->_str, this->_length, value, startIndex, charCount);
        this->_length = needed_cap;
        return this;
    }
    
    StringBuilder* StringBuilder::Append19(System::String* value, int32_t startIndex, int32_t count) {
        if((value ==  nullptr)) 
        {
            if(((startIndex != 0) && (count != 0))) 
            {
                throw cli::gcnew<System::ArgumentNullException>(_T("value"));
            }
            return this;
        }
        if((((count < 0) || (startIndex < 0)) || (startIndex > (value->get_Length() - count)))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>();
        }
        int32_t needed_cap = (this->_length + count);
        if(((this->_cached_str != nullptr) || (this->_str->get_Length() < needed_cap))) 
        {
            InternalEnsureCapacity(needed_cap);
        }
        System::String::CharCopy2(this->_str, this->_length, value, startIndex, count);
        this->_length = needed_cap;
        return this;
    }
    
    StringBuilder* StringBuilder::Clear() {
        this->set_Length(0);
        return this;
    }
    
    StringBuilder* StringBuilder::AppendLine() {
        return Append2(System::Environment::get_NewLine());
    }
    
    StringBuilder* StringBuilder::AppendLine2(System::String* value) {
        return Append2(value)->Append2(System::Environment::get_NewLine());
    }
    
    StringBuilder* StringBuilder::AppendFormat(System::String* format, cli::array<System::Object*>* args) {
        return AppendFormat2(nullptr, format, args);
    }
    
    StringBuilder* StringBuilder::AppendFormat2(System::IFormatProvider* provider, System::String* format, cli::array<System::Object*>* args) {
        System::String::FormatHelper(this, provider, format, args);
        return this;
    }
    
    StringBuilder* StringBuilder::AppendFormat3(System::String* format, System::Object* arg0) {
        return AppendFormat2(nullptr, format, (new cli::array<System::Object*>({arg0})));
    }
    
    StringBuilder* StringBuilder::AppendFormat4(System::String* format, System::Object* arg0, System::Object* arg1) {
        return AppendFormat2(nullptr, format, (new cli::array<System::Object*>({arg0, arg1})));
    }
    
    StringBuilder* StringBuilder::AppendFormat5(System::String* format, System::Object* arg0, System::Object* arg1, System::Object* arg2) {
        return AppendFormat2(nullptr, format, (new cli::array<System::Object*>({arg0, arg1, arg2})));
    }
    
    StringBuilder* StringBuilder::Insert(int32_t index, cli::array<char16_t>* value) {
        return Insert2(index, cli::gcnew<System::String>(value));
    }
    
    StringBuilder* StringBuilder::Insert2(int32_t index, System::String* value) {
        if(((index > this->_length) || (index < 0))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>();
        }
        if(((value ==  nullptr) || (value->get_Length() ==  0))) 
        {
            return this;
        }
        InternalEnsureCapacity((this->_length + value->get_Length()));
        System::String::CharCopyReverse2(this->_str, (index + value->get_Length()), this->_str, index, (this->_length - index));
        System::String::CharCopy2(this->_str, index, value, 0, value->get_Length());
        (this->_length = this->_length + value->get_Length());
        return this;
    }
    
    StringBuilder* StringBuilder::Insert3(int32_t index, bool value) {
        return Insert2(index, cli::import(value)->ToString_1636a0751cb9ac11());
    }
    
    StringBuilder* StringBuilder::Insert4(int32_t index, unsigned char value) {
        return Insert2(index, cli::import(value)->ToString_1636a0751cb9ac11());
    }
    
    StringBuilder* StringBuilder::Insert5(int32_t index, char16_t value) {
        if(((index > this->_length) || (index < 0))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("index"));
        }
        InternalEnsureCapacity((this->_length + 1));
        System::String::CharCopyReverse2(this->_str, (index + 1), this->_str, index, (this->_length - index));
        this->_str->InternalSetChar(index, value);
        this->_length++;
        return this;
    }
    
    StringBuilder* StringBuilder::Insert6(int32_t index, System::Decimal value) {
        return Insert2(index, value->ToString_1636a0751cb9ac11());
    }
    
    StringBuilder* StringBuilder::Insert7(int32_t index, double value) {
        return Insert2(index, cli::import(value)->ToString_1636a0751cb9ac11());
    }
    
    StringBuilder* StringBuilder::Insert8(int32_t index, int16_t value) {
        return Insert2(index, cli::import(value)->ToString_1636a0751cb9ac11());
    }
    
    StringBuilder* StringBuilder::Insert9(int32_t index, int32_t value) {
        return Insert2(index, cli::import(value)->ToString_1636a0751cb9ac11());
    }
    
    StringBuilder* StringBuilder::Insert10(int32_t index, int64_t value) {
        return Insert2(index, cli::import(value)->ToString_1636a0751cb9ac11());
    }
    
    StringBuilder* StringBuilder::Insert11(int32_t index, System::Object* value) {
        return Insert2(index, value->ToString_1636a0751cb9ac11());
    }
    
    StringBuilder* StringBuilder::Insert12(int32_t index, signed char value) {
        return Insert2(index, cli::import(value)->ToString_1636a0751cb9ac11());
    }
    
    StringBuilder* StringBuilder::Insert13(int32_t index, float value) {
        return Insert2(index, cli::import(value)->ToString_1636a0751cb9ac11());
    }
    
    StringBuilder* StringBuilder::Insert14(int32_t index, uint16_t value) {
        return Insert2(index, cli::import(value)->ToString_1636a0751cb9ac11());
    }
    
    StringBuilder* StringBuilder::Insert15(int32_t index, uint32_t value) {
        return Insert2(index, cli::import(value)->ToString_1636a0751cb9ac11());
    }
    
    StringBuilder* StringBuilder::Insert16(int32_t index, uint64_t value) {
        return Insert2(index, cli::import(value)->ToString_1636a0751cb9ac11());
    }
    
    StringBuilder* StringBuilder::Insert17(int32_t index, System::String* value, int32_t count) {
        if((count < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>();
        }
        if(((value != nullptr) && System::String::op_Inequality(value, System::String::Empty))) 
        for(int32_t insertCount = 0; (insertCount < count); insertCount++) {
            Insert2(index, value);
        }
        return this;
    }
    
    StringBuilder* StringBuilder::Insert18(int32_t index, cli::array<char16_t>* value, int32_t startIndex, int32_t charCount) {
        if((value ==  nullptr)) 
        {
            if(((startIndex ==  0) && (charCount ==  0))) 
            {
                return this;
            }
            throw cli::gcnew<System::ArgumentNullException>(_T("value"));
        }
        if((((charCount < 0) || (startIndex < 0)) || (startIndex > (value->get_Length() - charCount)))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>();
        }
        return Insert2(index, cli::gcnew<System::String>(value, startIndex, charCount));
    }
    
    void StringBuilder::InternalEnsureCapacity(int32_t size) {
        if(((size > this->_str->get_Length()) || (cli::cast<System::Object*>(this->_cached_str) ==  cli::cast<System::Object*>(this->_str)))) 
        {
            int32_t capacity = this->_str->get_Length();
            if((size > capacity)) 
            {
                if(((cli::cast<System::Object*>(this->_cached_str) ==  cli::cast<System::Object*>(this->_str)) && (capacity < 16))) 
                {
                    capacity = 16;
                }
                capacity = (capacity << 1);
                if((size > capacity)) 
                {
                    capacity = size;
                }
                if(((capacity >= 2147483647) || (capacity < 0))) 
                {
                    capacity = 2147483647;
                }
                if(((capacity > this->_maxCapacity) && (size <= this->_maxCapacity))) 
                {
                    capacity = this->_maxCapacity;
                }
                if((capacity > this->_maxCapacity)) 
                {
                    throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("size"), _T("capacity was less than the current size."));
                }
            }
            System::String *tmp = System::String::InternalAllocateStr(capacity);
            if((this->_length > 0)) 
            {
                System::String::CharCopy2(tmp, 0, this->_str, 0, this->_length);
            }
            this->_str = tmp;
        }
        this->_cached_str = nullptr;
    }
    
    void StringBuilder::CopyTo(int32_t sourceIndex, cli::array<char16_t>* destination, int32_t destinationIndex, int32_t count) {
        if((destination ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("destination"));
        }
        if(((((this->get_Length() - count) < sourceIndex) || ((destination->get_Length() - count) < destinationIndex)) || (((sourceIndex < 0) || (destinationIndex < 0)) || (count < 0)))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>();
        }
        for(int32_t i = 0; (i < count); i++) {
            destination->at((destinationIndex + i)) = this->_str->get_Chars((sourceIndex + i));
        }
    }
    
    void StringBuilder::GetObjectData(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        info->AddValue4(_T("m_MaxCapacity"), this->_maxCapacity);
        info->AddValue4(_T("Capacity"), this->get_Capacity());
        info->AddValue16(_T("m_StringValue"), System::Object::ToString_1636a0751cb9ac11());
        info->AddValue4(_T("m_currentThread"), 0);
    }
    
    int32_t StringBuilder::get_MaxCapacity() {
        return this->_maxCapacity;
    }
    
    int32_t StringBuilder::get_Capacity() {
        if((this->_str->get_Length() ==  0)) 
        {
            return System::Math::Min5(this->_maxCapacity, 16);
        }
        return this->_str->get_Length();
    }
    
    int32_t StringBuilder::set_Capacity(int32_t value) {
        if((value < this->_length)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Capacity must be larger than length"));
        }
        if((value > this->_maxCapacity)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("value"), _T("Should be less than or equal to MaxCapacity"));
        }
        InternalEnsureCapacity(value);
        return get_Capacity();
    }
    
    int32_t StringBuilder::get_Length() {
        return this->_length;
    }
    
    int32_t StringBuilder::set_Length(int32_t value) {
        if(((value < 0) || (value > this->_maxCapacity))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>();
        }
        if((value ==  this->_length)) 
        {
            return get_Length();
        }
        if((value < this->_length)) 
        {
            InternalEnsureCapacity(value);
            this->_length = value;
        }
         else 
        {
            Append17(u'\x0', (value - this->_length));
        }
        return get_Length();
    }
    
    char16_t StringBuilder::get_Chars(int32_t index) {
        if(((index >= this->_length) || (index < 0))) 
        {
            throw cli::gcnew<System::IndexOutOfRangeException>();
        }
        return this->_str->get_Chars(index);
    }
    
    char16_t StringBuilder::set_Chars(int32_t index, char16_t value) {
        if(((index >= this->_length) || (index < 0))) 
        {
            throw cli::gcnew<System::IndexOutOfRangeException>();
        }
        if((this->_cached_str != nullptr)) 
        {
            InternalEnsureCapacity(this->_length);
        }
        this->_str->InternalSetChar(index, value);
        return get_Chars(index);
    }
    
}}
namespace System { namespace Text {
    
    
    void SurrogateEncoder::constructor(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        if((info ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("info"));
        }
        this->encoding = cli::cast<Encoding*>(info->GetValue(_T("m_encoding"), cli::typeof<System::Type>::info));
    }
    
    void SurrogateEncoder::GetObjectData(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        throw cli::gcnew<System::ArgumentException>(_T("This class cannot be serialized."));
    }
    
    System::Object* SurrogateEncoder::GetRealObject(System::Runtime::Serialization::StreamingContext context) {
        if((this->realObject ==  nullptr)) 
        {
            this->realObject = this->encoding->GetEncoder_c3a25b0b739d51c8();
        }
        return this->realObject;
    }
    
}}
namespace System { namespace Text {
    
    
    void UnicodeDecoder::constructor(bool bigEndian) {
        this->bigEndian = bigEndian;
        this->leftOverByte = -1;
    }
    
    int32_t UnicodeDecoder::GetCharCount_32dfa16feccdb25d(cli::array<unsigned char>* bytes, int32_t index, int32_t count) {
        if((bytes ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("bytes"));
        }
        if(((index < 0) || (index > bytes->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("index"), Encoding::_(_T("ArgRange_Array")));
        }
        if(((count < 0) || (count > (bytes->get_Length() - index)))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("count"), Encoding::_(_T("ArgRange_Array")));
        }
        if((this->leftOverByte != -1)) 
        {
            return ((count + 1) / 2);
        }
         else 
        {
            return (count / 2);
        }
    }
    
    int32_t UnicodeDecoder::GetChars_beecc497fe0b7526(cli::array<unsigned char>* bytes, int32_t byteIndex, int32_t byteCount, cli::array<char16_t>* chars, int32_t charIndex) {
        if((bytes ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("bytes"));
        }
        if((chars ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("chars"));
        }
        if(((byteIndex < 0) || (byteIndex > bytes->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("byteIndex"), Encoding::_(_T("ArgRange_Array")));
        }
        if(((byteCount < 0) || (byteCount > (bytes->get_Length() - byteIndex)))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("byteCount"), Encoding::_(_T("ArgRange_Array")));
        }
        if(((charIndex < 0) || (charIndex > chars->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("charIndex"), Encoding::_(_T("ArgRange_Array")));
        }
        if((byteCount ==  0)) 
        {
            return 0;
        }
        int32_t leftOver = this->leftOverByte;
        int32_t count;
        if((leftOver != -1)) 
        {
            count = ((byteCount + 1) / 2);
        }
         else 
        {
            count = (byteCount / 2);
        }
        if(((chars->get_Length() - charIndex) < count)) 
        {
            throw cli::gcnew<System::ArgumentException>(Encoding::_(_T("Arg_InsufficientSpace")));
        }
        if((leftOver != -1)) 
        {
            if(this->bigEndian) 
            {
                chars->at(charIndex) = cli::unchecked((char16_t)((leftOver << 8) | (int32_t)(bytes->at(byteIndex))));
            }
             else 
            {
                chars->at(charIndex) = cli::unchecked((char16_t)(((int32_t)(bytes->at(byteIndex)) << 8) | leftOver));
            }
            charIndex++;
            byteIndex++;
            byteCount--;
        }
        if(((byteCount & -2) != 0)) 
        {
            /* FIXED - BLOCK */
            unsigned char* bytePtr = cli::fixed_guard(((bytes ==  nullptr) || (bytes->get_Length() ==  0)) ? nullptr : bytes);
            /* FIXED - BLOCK */
            char16_t* charPtr = cli::fixed_guard(((chars ==  nullptr) || (chars->get_Length() ==  0)) ? nullptr : chars);
            {
                UnicodeEncoding::CopyChars((bytePtr + (int32_t)(byteIndex)), (unsigned char*)((charPtr + (int32_t)(charIndex))), byteCount, this->bigEndian);
            }
        }
        if(((byteCount & 1) ==  0)) 
        {
            this->leftOverByte = -1;
        }
         else 
        {
            this->leftOverByte = (int32_t)(bytes->at(((byteCount + byteIndex) - 1)));
        }
        return count;
    }
    
}}
namespace System { namespace Text {
    
    
    void UnicodeEncoding::constructor() {
        this->bigEndian = false;
        this->byteOrderMark = true;
    }
    
    void UnicodeEncoding::constructor(bool bigEndian, bool byteOrderMark) {
    }
    
    void UnicodeEncoding::constructor(bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes) {
        if(throwOnInvalidBytes) 
        {
            Encoding::SetFallbackInternal(nullptr, cli::gcnew<DecoderExceptionFallback>());
        }
         else 
        {
            Encoding::SetFallbackInternal(nullptr, cli::gcnew<DecoderReplacementFallback>(_T("�")));
        }
        this->bigEndian = bigEndian;
        this->byteOrderMark = byteOrderMark;
        if(bigEndian) 
        {
            this->body_name = _T("unicodeFFFE");
            this->encoding_name = _T("Unicode (Big-Endian)");
            this->header_name = _T("unicodeFFFE");
            this->is_browser_save = false;
            this->web_name = _T("unicodeFFFE");
        }
         else 
        {
            this->body_name = _T("utf-16");
            this->encoding_name = _T("Unicode");
            this->header_name = _T("utf-16");
            this->is_browser_save = true;
            this->web_name = _T("utf-16");
        }
        this->windows_code_page = 1200;
    }
    
    int32_t UnicodeEncoding::GetByteCount_7494b18116693a5e(cli::array<char16_t>* chars, int32_t index, int32_t count) {
        if((chars ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("chars"));
        }
        if(((index < 0) || (index > chars->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("index"), Encoding::_(_T("ArgRange_Array")));
        }
        if(((count < 0) || (count > (chars->get_Length() - index)))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("count"), Encoding::_(_T("ArgRange_Array")));
        }
        return (count * 2);
    }
    
    int32_t UnicodeEncoding::GetByteCount_d98cd1485dc2ee98(System::String* s) {
        if((s ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("s"));
        }
        return (s->get_Length() * 2);
    }
    
    int32_t UnicodeEncoding::GetByteCount_aec9823bd32c6735(char16_t* chars, int32_t count) {
        if((chars ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("chars"));
        }
        if((count < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("count"));
        }
        return (count * 2);
    }
    
    int32_t UnicodeEncoding::GetBytes_90650b3cf924e5e2(cli::array<char16_t>* chars, int32_t charIndex, int32_t charCount, cli::array<unsigned char>* bytes, int32_t byteIndex) {
        if((chars ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("chars"));
        }
        if((bytes ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("bytes"));
        }
        if(((charIndex < 0) || (charIndex > chars->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("charIndex"), Encoding::_(_T("ArgRange_Array")));
        }
        if(((charCount < 0) || (charCount > (chars->get_Length() - charIndex)))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("charCount"), Encoding::_(_T("ArgRange_Array")));
        }
        if(((byteIndex < 0) || (byteIndex > bytes->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("byteIndex"), Encoding::_(_T("ArgRange_Array")));
        }
        if((charCount ==  0)) 
        {
            return 0;
        }
        int32_t byteCount = (bytes->get_Length() - byteIndex);
        if((bytes->get_Length() ==  0)) 
        {
            bytes = (new cli::array<unsigned char>(1));
        }
        {
            /* FIXED - BLOCK */
            char16_t* charPtr = cli::fixed_guard(((chars ==  nullptr) || (chars->get_Length() ==  0)) ? nullptr : chars);
            /* FIXED - BLOCK */
            unsigned char* bytePtr = cli::fixed_guard(((bytes ==  nullptr) || (bytes->get_Length() ==  0)) ? nullptr : bytes);
            {
                return GetBytesInternal((charPtr + (int32_t)(charIndex)), charCount, (bytePtr + (int32_t)(byteIndex)), byteCount);
            }
        }
    }
    
    int32_t UnicodeEncoding::GetBytes_3384066dd8b91ed8(System::String* s, int32_t charIndex, int32_t charCount, cli::array<unsigned char>* bytes, int32_t byteIndex) {
        if((s ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("s"));
        }
        if((bytes ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("bytes"));
        }
        if(((charIndex < 0) || (charIndex > s->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("charIndex"), Encoding::_(_T("ArgRange_StringIndex")));
        }
        if(((charCount < 0) || (charCount > (s->get_Length() - charIndex)))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("charCount"), Encoding::_(_T("ArgRange_StringRange")));
        }
        if(((byteIndex < 0) || (byteIndex > bytes->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("byteIndex"), Encoding::_(_T("ArgRange_Array")));
        }
        if((charCount ==  0)) 
        {
            return 0;
        }
        int32_t byteCount = (bytes->get_Length() - byteIndex);
        if((bytes->get_Length() ==  0)) 
        {
            bytes = (new cli::array<unsigned char>(1));
        }
        {
            /* FIXED - BLOCK */
            char16_t* charPtr = cli::fixed_guard(s);
            /* FIXED - BLOCK */
            unsigned char* bytePtr = cli::fixed_guard(((bytes ==  nullptr) || (bytes->get_Length() ==  0)) ? nullptr : bytes);
            {
                return GetBytesInternal((charPtr + (int32_t)(charIndex)), charCount, (bytePtr + (int32_t)(byteIndex)), byteCount);
            }
        }
    }
    
    int32_t UnicodeEncoding::GetBytes_9b94592fd1d1a5af(char16_t* chars, int32_t charCount, unsigned char* bytes, int32_t byteCount) {
        if((bytes ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("bytes"));
        }
        if((chars ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("chars"));
        }
        if((charCount < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("charCount"));
        }
        if((byteCount < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("byteCount"));
        }
        return GetBytesInternal(chars, charCount, bytes, byteCount);
    }
    
    int32_t UnicodeEncoding::GetBytesInternal(char16_t* chars, int32_t charCount, unsigned char* bytes, int32_t byteCount) {
        int32_t count = (charCount * 2);
        if((byteCount < count)) 
        {
            throw cli::gcnew<System::ArgumentException>(Encoding::_(_T("Arg_InsufficientSpace")));
        }
        CopyChars((unsigned char*)(chars), bytes, count, this->bigEndian);
        return count;
    }
    
    int32_t UnicodeEncoding::GetCharCount_aa33a7717b095c8e(cli::array<unsigned char>* bytes, int32_t index, int32_t count) {
        if((bytes ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("bytes"));
        }
        if(((index < 0) || (index > bytes->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("index"), Encoding::_(_T("ArgRange_Array")));
        }
        if(((count < 0) || (count > (bytes->get_Length() - index)))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("count"), Encoding::_(_T("ArgRange_Array")));
        }
        return (count / 2);
    }
    
    int32_t UnicodeEncoding::GetCharCount_4e601cea7c3f10cd(unsigned char* bytes, int32_t count) {
        if((bytes ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("bytes"));
        }
        if((count < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("count"));
        }
        return (count / 2);
    }
    
    int32_t UnicodeEncoding::GetChars_d7b47e17fd0a13f2(cli::array<unsigned char>* bytes, int32_t byteIndex, int32_t byteCount, cli::array<char16_t>* chars, int32_t charIndex) {
        if((bytes ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("bytes"));
        }
        if((chars ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("chars"));
        }
        if(((byteIndex < 0) || (byteIndex > bytes->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("byteIndex"), Encoding::_(_T("ArgRange_Array")));
        }
        if(((byteCount < 0) || (byteCount > (bytes->get_Length() - byteIndex)))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("byteCount"), Encoding::_(_T("ArgRange_Array")));
        }
        if(((charIndex < 0) || (charIndex > chars->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("charIndex"), Encoding::_(_T("ArgRange_Array")));
        }
        if((byteCount ==  0)) 
        {
            return 0;
        }
        int32_t charCount = (chars->get_Length() - charIndex);
        if((chars->get_Length() ==  0)) 
        {
            chars = (new cli::array<char16_t>(1));
        }
        {
            /* FIXED - BLOCK */
            unsigned char* bytePtr = cli::fixed_guard(((bytes ==  nullptr) || (bytes->get_Length() ==  0)) ? nullptr : bytes);
            /* FIXED - BLOCK */
            char16_t* charPtr = cli::fixed_guard(((chars ==  nullptr) || (chars->get_Length() ==  0)) ? nullptr : chars);
            {
                return GetCharsInternal((bytePtr + (int32_t)(byteIndex)), byteCount, (charPtr + (int32_t)(charIndex)), charCount);
            }
        }
    }
    
    int32_t UnicodeEncoding::GetChars_8904b350d20e4ab8(unsigned char* bytes, int32_t byteCount, char16_t* chars, int32_t charCount) {
        if((bytes ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("bytes"));
        }
        if((chars ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("chars"));
        }
        if((charCount < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("charCount"));
        }
        if((byteCount < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("byteCount"));
        }
        return GetCharsInternal(bytes, byteCount, chars, charCount);
    }
    
    System::String* UnicodeEncoding::GetString_39f4843197ddbe92(cli::array<unsigned char>* bytes, int32_t index, int32_t count) {
        if((bytes ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("bytes"));
        }
        if(((index < 0) || (index > bytes->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("index"), Encoding::_(_T("ArgRange_Array")));
        }
        if(((count < 0) || (count > (bytes->get_Length() - index)))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("count"), Encoding::_(_T("ArgRange_Array")));
        }
        if((count ==  0)) 
        {
            return System::String::Empty;
        }
        int32_t charCount = (count / 2);
        System::String *s = System::String::InternalAllocateStr(charCount);
        {
            /* FIXED - BLOCK */
            unsigned char* bytePtr = cli::fixed_guard(((bytes ==  nullptr) || (bytes->get_Length() ==  0)) ? nullptr : bytes);
            /* FIXED - BLOCK */
            char16_t* charPtr = cli::fixed_guard(s);
            {
                GetCharsInternal((bytePtr + (int32_t)(index)), count, charPtr, charCount);
            }
        }
        return s;
    }
    
    int32_t UnicodeEncoding::GetCharsInternal(unsigned char* bytes, int32_t byteCount, char16_t* chars, int32_t charCount) {
        int32_t count = (byteCount / 2);
        if((charCount < count)) 
        {
            throw cli::gcnew<System::ArgumentException>(Encoding::_(_T("Arg_InsufficientSpace")));
        }
        CopyChars(bytes, (unsigned char*)(chars), byteCount, this->bigEndian);
        return count;
    }
    
    Encoder* UnicodeEncoding::GetEncoder_c3a25b0b739d51c8() {
        return Encoding::GetEncoder_c3a25b0b739d51c8();
    }
    
    int32_t UnicodeEncoding::GetMaxByteCount_5bd2cee34757a0d4(int32_t charCount) {
        if((charCount < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("charCount"), Encoding::_(_T("ArgRange_NonNegative")));
        }
        return (charCount * 2);
    }
    
    int32_t UnicodeEncoding::GetMaxCharCount_4eba560ac1240518(int32_t byteCount) {
        if((byteCount < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("byteCount"), Encoding::_(_T("ArgRange_NonNegative")));
        }
        return (byteCount / 2);
    }
    
    Decoder2* UnicodeEncoding::GetDecoder_380c5e0c575e9cb5() {
        return cli::gcnew<UnicodeDecoder>(this->bigEndian);
    }
    
    cli::array<unsigned char>* UnicodeEncoding::GetPreamble_15ff85f00c460f87() {
        if(this->byteOrderMark) 
        {
            cli::array<unsigned char> *preamble = (new cli::array<unsigned char>(2));
            if(this->bigEndian) 
            {
                preamble->at(0) = 254;
                preamble->at(1) = 255;
            }
             else 
            {
                preamble->at(0) = 255;
                preamble->at(1) = 254;
            }
            return preamble;
        }
         else 
        {
            return (new cli::array<unsigned char>(0));
        }
    }
    
    bool UnicodeEncoding::Equals_ed975d2f4a7d193e(System::Object* value) {
        UnicodeEncoding *enc = cli::as<UnicodeEncoding*>(value);
        if((enc != nullptr)) 
        {
            return (((this->codePage ==  enc->codePage) && (this->bigEndian ==  enc->bigEndian)) && (this->byteOrderMark ==  enc->byteOrderMark));
        }
         else 
        {
            return false;
        }
    }
    
    int32_t UnicodeEncoding::GetHashCode_6648aef0f235ee6c() {
        return Encoding::GetHashCode_6648aef0f235ee6c();
    }
    
    void UnicodeEncoding::CopyChars(unsigned char* src, unsigned char* dest, int32_t count, bool bigEndian) {
        if((System::BitConverter::IsLittleEndian != bigEndian)) 
        {
            System::String::memcpy(dest, src, (count & -2));
            return;
        }
        switch(count) {
            case 0: case_1789: {
                return;
            }
            case 1: case_1790: {
                return;
            }
            case 2: case_1791: {
                goto Count2;
            }
            case 3: case_1792: {
                goto Count2;
            }
            case 4: case_1793: {
                goto Count4;
            }
            case 5: case_1794: {
                goto Count4;
            }
            case 6: case_1795: {
                goto Count4;
            }
            case 7: case_1796: {
                goto Count4;
            }
            case 8: case_1797: {
                goto Count8;
            }
            case 9: case_1798: {
                goto Count8;
            }
            case 10: case_1799: {
                goto Count8;
            }
            case 11: case_1800: {
                goto Count8;
            }
            case 12: case_1801: {
                goto Count8;
            }
            case 13: case_1802: {
                goto Count8;
            }
            case 14: case_1803: {
                goto Count8;
            }
            case 15: case_1804: {
                goto Count8;
            }
        }
        do {
            (*(dest + 0)) = (*(src + 1));
            (*(dest + 1)) = (*(src + 0));
            (*(dest + 2)) = (*(src + 3));
            (*(dest + 3)) = (*(src + 2));
            (*(dest + 4)) = (*(src + 5));
            (*(dest + 5)) = (*(src + 4));
            (*(dest + 6)) = (*(src + 7));
            (*(dest + 7)) = (*(src + 6));
            (*(dest + 8)) = (*(src + 9));
            (*(dest + 9)) = (*(src + 8));
            (*(dest + 10)) = (*(src + 11));
            (*(dest + 11)) = (*(src + 10));
            (*(dest + 12)) = (*(src + 13));
            (*(dest + 13)) = (*(src + 12));
            (*(dest + 14)) = (*(src + 15));
            (*(dest + 15)) = (*(src + 14));
            (dest = (dest += 16));
            (src = (src += 16));
            (count = count - 16);
        }
        while(((count & -16) != 0));
        switch(count) {
            case 0: case_1805: {
                return;
            }
            case 1: case_1806: {
                return;
            }
            case 2: case_1807: {
                goto Count2;
            }
            case 3: case_1808: {
                goto Count2;
            }
            case 4: case_1809: {
                goto Count4;
            }
            case 5: case_1810: {
                goto Count4;
            }
            case 6: case_1811: {
                goto Count4;
            }
            case 7: case_1812: {
                goto Count4;
            }
        }
        Count8:;
        (*(dest + 0)) = (*(src + 1));
        (*(dest + 1)) = (*(src + 0));
        (*(dest + 2)) = (*(src + 3));
        (*(dest + 3)) = (*(src + 2));
        (*(dest + 4)) = (*(src + 5));
        (*(dest + 5)) = (*(src + 4));
        (*(dest + 6)) = (*(src + 7));
        (*(dest + 7)) = (*(src + 6));
        (dest = (dest += 8));
        (src = (src += 8));
        if(((count & 4) ==  0)) 
        {
            goto TestCount2;
        }
        Count4:;
        (*(dest + 0)) = (*(src + 1));
        (*(dest + 1)) = (*(src + 0));
        (*(dest + 2)) = (*(src + 3));
        (*(dest + 3)) = (*(src + 2));
        (dest = (dest += 4));
        (src = (src += 4));
        TestCount2:;
        if(((count & 2) ==  0)) 
        {
            return;
        }
        Count2:;
        (*(dest + 0)) = (*(src + 1));
        (*(dest + 1)) = (*(src + 0));
    }
    
}}
namespace System { namespace Text {
    
    
    void UTF32Decoder::constructor(bool bigEndian) {
        this->bigEndian = bigEndian;
        this->leftOverByte = -1;
    }
    
    int32_t UTF32Decoder::GetCharCount_32dfa16feccdb25d(cli::array<unsigned char>* bytes, int32_t index, int32_t count) {
        if((bytes ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("bytes"));
        }
        if(((index < 0) || (index > bytes->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("index"), Encoding::_(_T("ArgRange_Array")));
        }
        if(((count < 0) || (count > (bytes->get_Length() - index)))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("count"), Encoding::_(_T("ArgRange_Array")));
        }
        if((this->leftOverByte != -1)) 
        {
            return ((count + 1) / 4);
        }
         else 
        {
            return (count / 4);
        }
    }
    
    int32_t UTF32Decoder::GetChars_beecc497fe0b7526(cli::array<unsigned char>* bytes, int32_t byteIndex, int32_t byteCount, cli::array<char16_t>* chars, int32_t charIndex) {
        if((bytes ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("bytes"));
        }
        if((chars ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("chars"));
        }
        if(((byteIndex < 0) || (byteIndex > bytes->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("byteIndex"), Encoding::_(_T("ArgRange_Array")));
        }
        if(((byteCount < 0) || (byteCount > (bytes->get_Length() - byteIndex)))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("byteCount"), Encoding::_(_T("ArgRange_Array")));
        }
        if(((charIndex < 0) || (charIndex > chars->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("charIndex"), Encoding::_(_T("ArgRange_Array")));
        }
        int32_t posn = charIndex;
        int32_t leftOver = this->leftOverByte;
        int32_t length = chars->get_Length();
        char16_t ch;
        int32_t remain = (4 - this->leftOverLength);
        if(((this->leftOverLength > 0) && (byteCount > remain))) 
        {
            if(this->bigEndian) 
            {
                for(int32_t i = 0; (i < remain); i++) {
                    (leftOver = leftOver + ((int32_t)(bytes->at(byteIndex++)) << ((4 - byteCount--) & 31)));
                }
            }
             else 
            {
                for(int32_t i = 0; (i < remain); i++) {
                    (leftOver = leftOver + ((int32_t)(bytes->at(byteIndex++)) << (byteCount-- & 31)));
                }
            }
            if((((leftOver > 65535) && ((posn + 1) < length)) || (posn < length))) 
            {
                throw cli::gcnew<System::ArgumentException>(Encoding::_(_T("Arg_InsufficientSpace")));
            }
            if((leftOver > 65535)) 
            {
                chars->at(posn++) = (char16_t)(((leftOver - 10000) / 1024) + 55296);
                chars->at(posn++) = (char16_t)(((leftOver - 10000) % 1024) + 56320);
            }
             else 
            {
                chars->at(posn++) = (char16_t)leftOver;
            }
            leftOver = -1;
            this->leftOverLength = 0;
        }
        while((byteCount > 3)) {
            if(this->bigEndian) 
            {
                ch = (char16_t)(((((int32_t)(bytes->at(byteIndex++)) << 24) | ((int32_t)(bytes->at(byteIndex++)) << 16)) | ((int32_t)(bytes->at(byteIndex++)) << 8)) | (int32_t)(bytes->at(byteIndex++)));
            }
             else 
            {
                ch = (char16_t)((((int32_t)(bytes->at(byteIndex++)) | ((int32_t)(bytes->at(byteIndex++)) << 8)) | ((int32_t)(bytes->at(byteIndex++)) << 16)) | ((int32_t)(bytes->at(byteIndex++)) << 24));
            }
            (byteCount = byteCount - 4);
            if((posn < length)) 
            {
                chars->at(posn++) = ch;
            }
             else 
            {
                throw cli::gcnew<System::ArgumentException>(Encoding::_(_T("Arg_InsufficientSpace")));
            }
        }
        if((byteCount > 0)) 
        {
            this->leftOverLength = byteCount;
            leftOver = 0;
            if(this->bigEndian) 
            {
                for(int32_t i = 0; (i < byteCount); i++) {
                    (leftOver = leftOver + ((int32_t)(bytes->at(byteIndex++)) << ((4 - byteCount--) & 31)));
                }
            }
             else 
            {
                for(int32_t i = 0; (i < byteCount); i++) {
                    (leftOver = leftOver + ((int32_t)(bytes->at(byteIndex++)) << (byteCount-- & 31)));
                }
            }
            this->leftOverByte = leftOver;
        }
        return (posn - charIndex);
    }
    
}}
namespace System { namespace Text {
    
    
    void UTF32Encoding::constructor() {
    }
    
    void UTF32Encoding::constructor(bool bigEndian, bool byteOrderMark) {
    }
    
    void UTF32Encoding::constructor(bool bigEndian, bool byteOrderMark, bool throwOnInvalidCharacters) {
        this->bigEndian = bigEndian;
        this->byteOrderMark = byteOrderMark;
        if(throwOnInvalidCharacters) 
        {
            Encoding::SetFallbackInternal(EncoderFallback::get_ExceptionFallback(), DecoderFallback::get_ExceptionFallback());
        }
         else 
        {
            Encoding::SetFallbackInternal(cli::gcnew<EncoderReplacementFallback>(_T("�")), cli::gcnew<DecoderReplacementFallback>(_T("�")));
        }
        if(bigEndian) 
        {
            this->body_name = _T("utf-32BE");
            this->encoding_name = _T("UTF-32 (Big-Endian)");
            this->header_name = _T("utf-32BE");
            this->web_name = _T("utf-32BE");
        }
         else 
        {
            this->body_name = _T("utf-32");
            this->encoding_name = _T("UTF-32");
            this->header_name = _T("utf-32");
            this->web_name = _T("utf-32");
        }
        this->windows_code_page = 12000;
    }
    
    int32_t UTF32Encoding::GetByteCount_7494b18116693a5e(cli::array<char16_t>* chars, int32_t index, int32_t count) {
        if((chars ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("chars"));
        }
        if(((index < 0) || (index > chars->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("index"), Encoding::_(_T("ArgRange_Array")));
        }
        if(((count < 0) || (count > (chars->get_Length() - index)))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("count"), Encoding::_(_T("ArgRange_Array")));
        }
        int32_t ret = 0;
        for(int32_t i = index; (i < (index + count)); i++){
            if(System::Char::IsSurrogate(chars->at(i))) 
            {
                if((((i + 1) < chars->get_Length()) && System::Char::IsSurrogate(chars->at((i + 1))))) 
                {
                    (ret = ret + 4);
                }
                 else 
                {
                    (ret = ret + 4);
                }
            }
             else 
            {
                (ret = ret + 4);
            }
        }
        return ret;
    }
    
    int32_t UTF32Encoding::GetBytes_90650b3cf924e5e2(cli::array<char16_t>* chars, int32_t charIndex, int32_t charCount, cli::array<unsigned char>* bytes, int32_t byteIndex) {
        if((chars ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("chars"));
        }
        if((bytes ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("bytes"));
        }
        if(((charIndex < 0) || (charIndex > chars->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("charIndex"), Encoding::_(_T("ArgRange_Array")));
        }
        if(((charCount < 0) || (charCount > (chars->get_Length() - charIndex)))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("charCount"), Encoding::_(_T("ArgRange_Array")));
        }
        if(((byteIndex < 0) || (byteIndex > bytes->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("byteIndex"), Encoding::_(_T("ArgRange_Array")));
        }
        if(((bytes->get_Length() - byteIndex) < (charCount * 4))) 
        {
            throw cli::gcnew<System::ArgumentException>(Encoding::_(_T("Arg_InsufficientSpace")));
        }
        int32_t posn = byteIndex;
        char16_t ch;
        while((charCount-- > 0)) {
            ch = chars->at(charIndex++);
            if(System::Char::IsSurrogate(ch)) 
            {
                if((charCount-- > 0)) 
                {
                    int32_t value = ((((1024 * ((int32_t)(ch) - 55296)) + 65536) + (int32_t)(chars->at(charIndex++))) - 56320);
                    if(this->bigEndian) 
                    {
                        for(int32_t i = 0; (i < 4); i++){
                            bytes->at(((posn + 3) - i)) = (unsigned char)(value % 256);
                            (value = value >> 8);
                        }
                        (posn = posn + 4);
                    }
                     else 
                    {
                        for(int32_t i = 0; (i < 4); i++){
                            bytes->at(posn++) = (unsigned char)(value % 256);
                            (value = value >> 8);
                        }
                    }
                }
                 else 
                {
                    if(this->bigEndian) 
                    {
                        bytes->at(posn++) = 0;
                        bytes->at(posn++) = 0;
                        bytes->at(posn++) = 0;
                        bytes->at(posn++) = 63;
                    }
                     else 
                    {
                        bytes->at(posn++) = 63;
                        bytes->at(posn++) = 0;
                        bytes->at(posn++) = 0;
                        bytes->at(posn++) = 0;
                    }
                }
            }
             else 
            {
                if(this->bigEndian) 
                {
                    bytes->at(posn++) = 0;
                    bytes->at(posn++) = 0;
                    bytes->at(posn++) = (unsigned char)((int32_t)(ch) >> 8);
                    bytes->at(posn++) = (unsigned char)ch;
                }
                 else 
                {
                    bytes->at(posn++) = (unsigned char)ch;
                    bytes->at(posn++) = (unsigned char)((int32_t)(ch) >> 8);
                    bytes->at(posn++) = 0;
                    bytes->at(posn++) = 0;
                }
            }
        }
        return (posn - byteIndex);
    }
    
    int32_t UTF32Encoding::GetCharCount_aa33a7717b095c8e(cli::array<unsigned char>* bytes, int32_t index, int32_t count) {
        if((bytes ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("bytes"));
        }
        if(((index < 0) || (index > bytes->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("index"), Encoding::_(_T("ArgRange_Array")));
        }
        if(((count < 0) || (count > (bytes->get_Length() - index)))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("count"), Encoding::_(_T("ArgRange_Array")));
        }
        return (count / 4);
    }
    
    int32_t UTF32Encoding::GetChars_d7b47e17fd0a13f2(cli::array<unsigned char>* bytes, int32_t byteIndex, int32_t byteCount, cli::array<char16_t>* chars, int32_t charIndex) {
        if((bytes ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("bytes"));
        }
        if((chars ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("chars"));
        }
        if(((byteIndex < 0) || (byteIndex > bytes->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("byteIndex"), Encoding::_(_T("ArgRange_Array")));
        }
        if(((byteCount < 0) || (byteCount > (bytes->get_Length() - byteIndex)))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("byteCount"), Encoding::_(_T("ArgRange_Array")));
        }
        if(((charIndex < 0) || (charIndex > chars->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("charIndex"), Encoding::_(_T("ArgRange_Array")));
        }
        if(((chars->get_Length() - charIndex) < (byteCount / 4))) 
        {
            throw cli::gcnew<System::ArgumentException>(Encoding::_(_T("Arg_InsufficientSpace")));
        }
        int32_t posn = charIndex;
        if(this->bigEndian) 
        {
            while((byteCount >= 4)) {
                chars->at(posn++) = (char16_t)(((((int32_t)(bytes->at(byteIndex)) << 24) | ((int32_t)(bytes->at((byteIndex + 1))) << 16)) | ((int32_t)(bytes->at((byteIndex + 2))) << 8)) | (int32_t)(bytes->at((byteIndex + 3))));
                (byteIndex = byteIndex + 4);
                (byteCount = byteCount - 4);
            }
        }
         else 
        {
            while((byteCount >= 4)) {
                chars->at(posn++) = (char16_t)((((int32_t)(bytes->at(byteIndex)) | ((int32_t)(bytes->at((byteIndex + 1))) << 8)) | ((int32_t)(bytes->at((byteIndex + 2))) << 16)) | ((int32_t)(bytes->at((byteIndex + 3))) << 24));
                (byteIndex = byteIndex + 4);
                (byteCount = byteCount - 4);
            }
        }
        return (posn - charIndex);
    }
    
    int32_t UTF32Encoding::GetMaxByteCount_5bd2cee34757a0d4(int32_t charCount) {
        if((charCount < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("charCount"), Encoding::_(_T("ArgRange_NonNegative")));
        }
        return (charCount * 4);
    }
    
    int32_t UTF32Encoding::GetMaxCharCount_4eba560ac1240518(int32_t byteCount) {
        if((byteCount < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("byteCount"), Encoding::_(_T("ArgRange_NonNegative")));
        }
        return (byteCount / 4);
    }
    
    Decoder2* UTF32Encoding::GetDecoder_380c5e0c575e9cb5() {
        return cli::gcnew<UTF32Decoder>(this->bigEndian);
    }
    
    cli::array<unsigned char>* UTF32Encoding::GetPreamble_15ff85f00c460f87() {
        if(this->byteOrderMark) 
        {
            cli::array<unsigned char> *preamble = (new cli::array<unsigned char>(4));
            if(this->bigEndian) 
            {
                preamble->at(2) = 254;
                preamble->at(3) = 255;
            }
             else 
            {
                preamble->at(0) = 255;
                preamble->at(1) = 254;
            }
            return preamble;
        }
         else 
        {
            return (new cli::array<unsigned char>(0));
        }
    }
    
    bool UTF32Encoding::Equals_ed975d2f4a7d193e(System::Object* value) {
        UTF32Encoding *enc = cli::as<UTF32Encoding*>(value);
        if((enc != nullptr)) 
        {
            return ((((this->codePage ==  enc->codePage) && (this->bigEndian ==  enc->bigEndian)) && (this->byteOrderMark ==  enc->byteOrderMark)) && Encoding::Equals_ed975d2f4a7d193e(value));
        }
         else 
        {
            return false;
        }
    }
    
    int32_t UTF32Encoding::GetHashCode_6648aef0f235ee6c() {
        int32_t basis = Encoding::GetHashCode_6648aef0f235ee6c();
        if(this->bigEndian) 
        {
            (basis = basis ^ 31);
        }
        if(this->byteOrderMark) 
        {
            (basis = basis ^ 63);
        }
        return basis;
    }
    
    int32_t UTF32Encoding::GetByteCount_aec9823bd32c6735(char16_t* chars, int32_t count) {
        if((chars ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("chars"));
        }
        return (count * 4);
    }
    
    int32_t UTF32Encoding::GetByteCount_d98cd1485dc2ee98(System::String* s) {
        return Encoding::GetByteCount_d98cd1485dc2ee98(s);
    }
    
    int32_t UTF32Encoding::GetBytes_9b94592fd1d1a5af(char16_t* chars, int32_t charCount, unsigned char* bytes, int32_t byteCount) {
        return Encoding::GetBytes_9b94592fd1d1a5af(chars, charCount, bytes, byteCount);
    }
    
    int32_t UTF32Encoding::GetBytes_3384066dd8b91ed8(System::String* s, int32_t charIndex, int32_t charCount, cli::array<unsigned char>* bytes, int32_t byteIndex) {
        return Encoding::GetBytes_3384066dd8b91ed8(s, charIndex, charCount, bytes, byteIndex);
    }
    
    int32_t UTF32Encoding::GetCharCount_4e601cea7c3f10cd(unsigned char* bytes, int32_t count) {
        return Encoding::GetCharCount_4e601cea7c3f10cd(bytes, count);
    }
    
    int32_t UTF32Encoding::GetChars_8904b350d20e4ab8(unsigned char* bytes, int32_t byteCount, char16_t* chars, int32_t charCount) {
        return Encoding::GetChars_8904b350d20e4ab8(bytes, byteCount, chars, charCount);
    }
    
    System::String* UTF32Encoding::GetString_39f4843197ddbe92(cli::array<unsigned char>* bytes, int32_t index, int32_t count) {
        return Encoding::GetString_39f4843197ddbe92(bytes, index, count);
    }
    
    Encoder* UTF32Encoding::GetEncoder_c3a25b0b739d51c8() {
        return Encoding::GetEncoder_c3a25b0b739d51c8();
    }
    
}}
namespace System { namespace Text {
    
    
    void UTF7Decoder::constructor() {
        this->leftOver = 0;
    }
    
    int32_t UTF7Decoder::GetCharCount_32dfa16feccdb25d(cli::array<unsigned char>* bytes, int32_t index, int32_t count) {
        return UTF7Encoding::InternalGetCharCount(bytes, index, count, this->leftOver);
    }
    
    int32_t UTF7Decoder::GetChars_beecc497fe0b7526(cli::array<unsigned char>* bytes, int32_t byteIndex, int32_t byteCount, cli::array<char16_t>* chars, int32_t charIndex) {
        return UTF7Encoding::InternalGetChars(bytes, byteIndex, byteCount, chars, charIndex, this->leftOver);
    }
    
}}
namespace System { namespace Text {
    
    
    void UTF7Encoder::constructor(bool allowOptionals) {
        this->allowOptionals = allowOptionals;
    }
    
    int32_t UTF7Encoder::GetByteCount_85f1385779510289(cli::array<char16_t>* chars, int32_t index, int32_t count, bool flush) {
        return UTF7Encoding::InternalGetByteCount(chars, index, count, flush, this->leftOver, this->isInShifted, this->allowOptionals);
    }
    
    int32_t UTF7Encoder::GetBytes_ac22a3cfd526ffd3(cli::array<char16_t>* chars, int32_t charIndex, int32_t charCount, cli::array<unsigned char>* bytes, int32_t byteIndex, bool flush) {
        return UTF7Encoding::InternalGetBytes(chars, charIndex, charCount, bytes, byteIndex, flush, this->leftOver, this->isInShifted, this->allowOptionals);
    }
    
}}
namespace System { namespace Text {
    
    cli::array<unsigned char>*  UTF7Encoding::encodingRules;
    cli::array<signed char>*  UTF7Encoding::base64Values;
    
    UTF7Encoding::UTF7Encoding()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void UTF7Encoding::constructor() {
    }
    
    void UTF7Encoding::constructor(bool allowOptionals) {
        this->allowOptionals = allowOptionals;
        this->body_name = _T("utf-7");
        this->encoding_name = _T("Unicode (UTF-7)");
        this->header_name = _T("utf-7");
        this->is_mail_news_display = true;
        this->is_mail_news_save = true;
        this->web_name = _T("utf-7");
        this->windows_code_page = 1200;
    }
    
    void UTF7Encoding::static_constructor() {
    }
    
    int32_t UTF7Encoding::GetHashCode_6648aef0f235ee6c() {
        int32_t basis = Encoding::GetHashCode_6648aef0f235ee6c();
        return this->allowOptionals ? -(basis) : basis;
    }
    
    bool UTF7Encoding::Equals_ed975d2f4a7d193e(System::Object* value) {
        UTF7Encoding *e = cli::as<UTF7Encoding*>(value);
        if((e ==  nullptr)) 
        {
            return false;
        }
        return (((this->allowOptionals ==  e->allowOptionals) && this->get_EncoderFallback()->Equals_ed975d2f4a7d193e(e->get_EncoderFallback())) && this->get_DecoderFallback()->Equals_ed975d2f4a7d193e(e->get_DecoderFallback()));
    }
    
    int32_t UTF7Encoding::InternalGetByteCount(cli::array<char16_t>* chars, int32_t index, int32_t count, bool flush, int32_t leftOver, bool isInShifted, bool allowOptionals) {
        if((chars ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("chars"));
        }
        if(((index < 0) || (index > chars->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("index"), Encoding::_(_T("ArgRange_Array")));
        }
        if(((count < 0) || (count > (chars->get_Length() - index)))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("count"), Encoding::_(_T("ArgRange_Array")));
        }
        int32_t length = 0;
        int32_t leftOverSize = (leftOver >> 8);
        cli::array<unsigned char> *rules = encodingRules;
        int32_t ch, rule;
        while((count > 0)) {
            ch = (int32_t)(chars->at(index++));
            --count;
            if((ch < 128)) 
            {
                rule = (int32_t)(rules->at(ch));
            }
             else 
            {
                rule = 0;
            }
            switch(rule) {
                case 0: case_1813: {
                    if(!(isInShifted)) 
                    {
                        ++length;
                        leftOverSize = 0;
                        isInShifted = true;
                    }
                    (leftOverSize = leftOverSize + 16);
                    while((leftOverSize >= 6)) {
                        ++length;
                        (leftOverSize = leftOverSize - 6);
                    }
                    break;
                }
                case 1: case_1814: {
                    if(isInShifted) 
                    {
                        if((leftOverSize != 0)) 
                        {
                            ++length;
                            leftOverSize = 0;
                        }
                        ++length;
                        isInShifted = false;
                    }
                    ++length;
                    break;
                }
                case 2: case_1815: {
                    if(allowOptionals) 
                    {
                        goto case_1814;
                    }
                     else 
                    {
                        goto case_1813;
                    }
                }
                case 3: case_1816: {
                    if(isInShifted) 
                    {
                        if((leftOverSize != 0)) 
                        {
                            ++length;
                            leftOverSize = 0;
                        }
                        ++length;
                        isInShifted = false;
                    }
                    (length = length + 2);
                    break;
                }
            }
        }
        if((isInShifted && flush)) 
        {
            if((leftOverSize != 0)) 
            {
                ++length;
            }
            ++length;
        }
        return length;
    }
    
    int32_t UTF7Encoding::GetByteCount_7494b18116693a5e(cli::array<char16_t>* chars, int32_t index, int32_t count) {
        return InternalGetByteCount(chars, index, count, true, 0, false, this->allowOptionals);
    }
    
    int32_t UTF7Encoding::InternalGetBytes(cli::array<char16_t>* chars, int32_t charIndex, int32_t charCount, cli::array<unsigned char>* bytes, int32_t byteIndex, bool flush, int32_t leftOver, bool isInShifted, bool allowOptionals) {
        if((chars ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("chars"));
        }
        if((bytes ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("bytes"));
        }
        if(((charIndex < 0) || (charIndex > chars->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("charIndex"), Encoding::_(_T("ArgRange_Array")));
        }
        if(((charCount < 0) || (charCount > (chars->get_Length() - charIndex)))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("charCount"), Encoding::_(_T("ArgRange_Array")));
        }
        if(((byteIndex < 0) || (byteIndex > bytes->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("byteIndex"), Encoding::_(_T("ArgRange_Array")));
        }
        int32_t posn = byteIndex;
        int32_t byteLength = bytes->get_Length();
        int32_t leftOverSize = (leftOver >> 8);
        int32_t leftOverBits = (leftOver & 255);
        cli::array<unsigned char> *rules = encodingRules;
        System::String *base64 = _T("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
        int32_t ch, rule;
        while((charCount > 0)) {
            ch = (int32_t)(chars->at(charIndex++));
            --charCount;
            if((ch < 128)) 
            {
                rule = (int32_t)(rules->at(ch));
            }
             else 
            {
                rule = 0;
            }
            switch(rule) {
                case 0: case_1817: {
                    if(!(isInShifted)) 
                    {
                        if((posn >= byteLength)) 
                        {
                            throw cli::gcnew<System::ArgumentException>(Encoding::_(_T("Arg_InsufficientSpace")), _T("bytes"));
                        }
                        bytes->at(posn++) = 43;
                        isInShifted = true;
                        leftOverSize = 0;
                    }
                    leftOverBits = ((leftOverBits << 16) | ch);
                    (leftOverSize = leftOverSize + 16);
                    while((leftOverSize >= 6)) {
                        if((posn >= byteLength)) 
                        {
                            throw cli::gcnew<System::ArgumentException>(Encoding::_(_T("Arg_InsufficientSpace")), _T("bytes"));
                        }
                        (leftOverSize = leftOverSize - 6);
                        bytes->at(posn++) = (unsigned char)base64->get_Chars((leftOverBits >> (leftOverSize & 31)));
                        (leftOverBits = leftOverBits & ((1 << (leftOverSize & 31)) - 1));
                    }
                    break;
                }
                case 1: case_1818: {
                    if(isInShifted) 
                    {
                        if((leftOverSize != 0)) 
                        {
                            if(((posn + 1) > byteLength)) 
                            {
                                throw cli::gcnew<System::ArgumentException>(Encoding::_(_T("Arg_InsufficientSpace")), _T("bytes"));
                            }
                            bytes->at(posn++) = (unsigned char)base64->get_Chars((leftOverBits << ((6 - leftOverSize) & 31)));
                        }
                        if(((posn + 1) > byteLength)) 
                        {
                            throw cli::gcnew<System::ArgumentException>(Encoding::_(_T("Arg_InsufficientSpace")), _T("bytes"));
                        }
                        bytes->at(posn++) = 45;
                        isInShifted = false;
                        leftOverSize = 0;
                        leftOverBits = 0;
                    }
                    if((posn >= byteLength)) 
                    {
                        throw cli::gcnew<System::ArgumentException>(Encoding::_(_T("Arg_InsufficientSpace")), _T("bytes"));
                    }
                    bytes->at(posn++) = (unsigned char)ch;
                    break;
                }
                case 2: case_1819: {
                    if(allowOptionals) 
                    {
                        goto case_1818;
                    }
                     else 
                    {
                        goto case_1817;
                    }
                }
                case 3: case_1820: {
                    if(isInShifted) 
                    {
                        if((leftOverSize != 0)) 
                        {
                            if(((posn + 1) > byteLength)) 
                            {
                                throw cli::gcnew<System::ArgumentException>(Encoding::_(_T("Arg_InsufficientSpace")), _T("bytes"));
                            }
                            bytes->at(posn++) = (unsigned char)base64->get_Chars((leftOverBits << ((6 - leftOverSize) & 31)));
                        }
                        if(((posn + 1) > byteLength)) 
                        {
                            throw cli::gcnew<System::ArgumentException>(Encoding::_(_T("Arg_InsufficientSpace")), _T("bytes"));
                        }
                        bytes->at(posn++) = 45;
                        isInShifted = false;
                        leftOverSize = 0;
                        leftOverBits = 0;
                    }
                    if(((posn + 2) > byteLength)) 
                    {
                        throw cli::gcnew<System::ArgumentException>(Encoding::_(_T("Arg_InsufficientSpace")), _T("bytes"));
                    }
                    bytes->at(posn++) = 43;
                    bytes->at(posn++) = 45;
                    break;
                }
            }
        }
        if((isInShifted && flush)) 
        {
            if((leftOverSize != 0)) 
            {
                if(((posn + 1) > byteLength)) 
                {
                    throw cli::gcnew<System::ArgumentException>(Encoding::_(_T("Arg_InsufficientSpace")), _T("bytes"));
                }
                bytes->at(posn++) = (unsigned char)base64->get_Chars((leftOverBits << ((6 - leftOverSize) & 31)));
            }
            bytes->at(posn++) = 45;
            leftOverSize = 0;
            leftOverBits = 0;
            isInShifted = false;
        }
        leftOver = ((leftOverSize << 8) | leftOverBits);
        return (posn - byteIndex);
    }
    
    int32_t UTF7Encoding::GetBytes_90650b3cf924e5e2(cli::array<char16_t>* chars, int32_t charIndex, int32_t charCount, cli::array<unsigned char>* bytes, int32_t byteIndex) {
        int32_t leftOver = 0;
        bool isInShifted = false;
        return InternalGetBytes(chars, charIndex, charCount, bytes, byteIndex, true, leftOver, isInShifted, this->allowOptionals);
    }
    
    int32_t UTF7Encoding::InternalGetCharCount(cli::array<unsigned char>* bytes, int32_t index, int32_t count, int32_t leftOver) {
        if((bytes ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("bytes"));
        }
        if(((index < 0) || (index > bytes->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("index"), Encoding::_(_T("ArgRange_Array")));
        }
        if(((count < 0) || (count > (bytes->get_Length() - index)))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("count"), Encoding::_(_T("ArgRange_Array")));
        }
        int32_t length = 0;
        int32_t byteval;
        bool normal = ((leftOver & 16777216) ==  0);
        bool prevIsPlus = ((leftOver & 33554432) != 0);
        int32_t leftOverSize = ((leftOver >> 16) & 255);
        cli::array<signed char> *base64 = base64Values;
        while((count > 0)) {
            byteval = (int32_t)(bytes->at(index++));
            --count;
            if(normal) 
            {
                if((byteval != 43)) 
                {
                    ++length;
                }
                 else 
                {
                    normal = false;
                    prevIsPlus = true;
                }
            }
             else 
            {
                if((byteval ==  45)) 
                {
                    if(prevIsPlus) 
                    {
                        ++length;
                    }
                    leftOverSize = 0;
                    normal = true;
                }
                 else 
                {
                    if(((int32_t)(base64->at(byteval)) != -1)) 
                    {
                        (leftOverSize = leftOverSize + 6);
                        if((leftOverSize >= 16)) 
                        {
                            ++length;
                            (leftOverSize = leftOverSize - 16);
                        }
                    }
                     else 
                    {
                        ++length;
                        normal = true;
                        leftOverSize = 0;
                    }
                }
                prevIsPlus = false;
            }
        }
        return length;
    }
    
    int32_t UTF7Encoding::GetCharCount_aa33a7717b095c8e(cli::array<unsigned char>* bytes, int32_t index, int32_t count) {
        return InternalGetCharCount(bytes, index, count, 0);
    }
    
    int32_t UTF7Encoding::InternalGetChars(cli::array<unsigned char>* bytes, int32_t byteIndex, int32_t byteCount, cli::array<char16_t>* chars, int32_t charIndex, int32_t leftOver) {
        if((bytes ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("bytes"));
        }
        if((chars ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("chars"));
        }
        if(((byteIndex < 0) || (byteIndex > bytes->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("byteIndex"), Encoding::_(_T("ArgRange_Array")));
        }
        if(((byteCount < 0) || (byteCount > (bytes->get_Length() - byteIndex)))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("byteCount"), Encoding::_(_T("ArgRange_Array")));
        }
        if(((charIndex < 0) || (charIndex > chars->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("charIndex"), Encoding::_(_T("ArgRange_Array")));
        }
        int32_t posn = charIndex;
        int32_t charLength = chars->get_Length();
        int32_t byteval, b64value;
        bool normal = ((leftOver & 16777216) ==  0);
        bool prevIsPlus = ((leftOver & 33554432) != 0);
        bool afterHighSurrogate = ((leftOver & 67108864) != 0);
        int32_t leftOverSize = ((leftOver >> 16) & 255);
        int32_t leftOverBits = (leftOver & 65535);
        cli::array<signed char> *base64 = base64Values;
        while((byteCount > 0)) {
            byteval = (int32_t)(bytes->at(byteIndex++));
            --byteCount;
            if(normal) 
            {
                if((byteval != 43)) 
                {
                    if((posn >= charLength)) 
                    {
                        throw cli::gcnew<System::ArgumentException>(Encoding::_(_T("Arg_InsufficientSpace")), _T("chars"));
                    }
                    if(afterHighSurrogate) 
                    {
                        throw cli::gcnew<System::ArgumentException>(Encoding::_(_T("Arg_InvalidUTF7")), _T("chars"));
                    }
                    chars->at(posn++) = (char16_t)byteval;
                }
                 else 
                {
                    normal = false;
                    prevIsPlus = true;
                }
            }
             else 
            {
                if((byteval ==  45)) 
                {
                    if(prevIsPlus) 
                    {
                        if((posn >= charLength)) 
                        {
                            throw cli::gcnew<System::ArgumentException>(Encoding::_(_T("Arg_InsufficientSpace")), _T("chars"));
                        }
                        if(afterHighSurrogate) 
                        {
                            throw cli::gcnew<System::ArgumentException>(Encoding::_(_T("Arg_InvalidUTF7")), _T("chars"));
                        }
                        chars->at(posn++) = u'+';
                    }
                    normal = true;
                    leftOverSize = 0;
                    leftOverBits = 0;
                }
                 else 
                {
                    if(((b64value = (int32_t)(base64->at(byteval))) != (-1))) 
                    {
                        leftOverBits = ((leftOverBits << 6) | b64value);
                        (leftOverSize = leftOverSize + 6);
                        if((leftOverSize >= 16)) 
                        {
                            if((posn >= charLength)) 
                            {
                                throw cli::gcnew<System::ArgumentException>(Encoding::_(_T("Arg_InsufficientSpace")), _T("chars"));
                            }
                            (leftOverSize = leftOverSize - 16);
                            char16_t nextChar = (char16_t)(leftOverBits >> (leftOverSize & 31));
                            if((((int32_t)(nextChar) & 64512) ==  55296)) 
                            {
                                afterHighSurrogate = true;
                            }
                             else 
                            {
                                if((((int32_t)(nextChar) & 64512) ==  56320)) 
                                {
                                    if(!(afterHighSurrogate)) 
                                    {
                                        throw cli::gcnew<System::ArgumentException>(Encoding::_(_T("Arg_InvalidUTF7")), _T("chars"));
                                    }
                                    afterHighSurrogate = false;
                                }
                            }
                            chars->at(posn++) = nextChar;
                            (leftOverBits = leftOverBits & ((1 << (leftOverSize & 31)) - 1));
                        }
                    }
                     else 
                    {
                        if((posn >= charLength)) 
                        {
                            throw cli::gcnew<System::ArgumentException>(Encoding::_(_T("Arg_InsufficientSpace")), _T("chars"));
                        }
                        if(afterHighSurrogate) 
                        {
                            throw cli::gcnew<System::ArgumentException>(Encoding::_(_T("Arg_InvalidUTF7")), _T("chars"));
                        }
                        chars->at(posn++) = (char16_t)byteval;
                        normal = true;
                        leftOverSize = 0;
                        leftOverBits = 0;
                    }
                }
                prevIsPlus = false;
            }
        }
        leftOver = ((((leftOverBits | (leftOverSize << 16)) | normal ? 0 : 16777216) | prevIsPlus ? 33554432 : 0) | afterHighSurrogate ? 67108864 : 0);
        return (posn - charIndex);
    }
    
    int32_t UTF7Encoding::GetChars_d7b47e17fd0a13f2(cli::array<unsigned char>* bytes, int32_t byteIndex, int32_t byteCount, cli::array<char16_t>* chars, int32_t charIndex) {
        int32_t leftOver = 0;
        int32_t amount = InternalGetChars(bytes, byteIndex, byteCount, chars, charIndex, leftOver);
        if(((leftOver & 67108864) != 0)) 
        {
            throw cli::gcnew<System::ArgumentException>(Encoding::_(_T("Arg_InvalidUTF7")), _T("chars"));
        }
        return amount;
    }
    
    int32_t UTF7Encoding::GetMaxByteCount_5bd2cee34757a0d4(int32_t charCount) {
        if((charCount < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("charCount"), Encoding::_(_T("ArgRange_NonNegative")));
        }
        if((charCount ==  0)) 
        {
            return 0;
        }
        return (((8 * (int32_t)((charCount / 3))) + ((charCount % 3) * 3)) + 2);
    }
    
    int32_t UTF7Encoding::GetMaxCharCount_4eba560ac1240518(int32_t byteCount) {
        if((byteCount < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("byteCount"), Encoding::_(_T("ArgRange_NonNegative")));
        }
        return byteCount;
    }
    
    Decoder2* UTF7Encoding::GetDecoder_380c5e0c575e9cb5() {
        return cli::gcnew<UTF7Decoder>();
    }
    
    Encoder* UTF7Encoding::GetEncoder_c3a25b0b739d51c8() {
        return cli::gcnew<UTF7Encoder>(this->allowOptionals);
    }
    
    int32_t UTF7Encoding::GetByteCount_aec9823bd32c6735(char16_t* chars, int32_t count) {
        return Encoding::GetByteCount_aec9823bd32c6735(chars, count);
    }
    
    int32_t UTF7Encoding::GetByteCount_d98cd1485dc2ee98(System::String* s) {
        return Encoding::GetByteCount_d98cd1485dc2ee98(s);
    }
    
    int32_t UTF7Encoding::GetBytes_9b94592fd1d1a5af(char16_t* chars, int32_t charCount, unsigned char* bytes, int32_t byteCount) {
        return Encoding::GetBytes_9b94592fd1d1a5af(chars, charCount, bytes, byteCount);
    }
    
    int32_t UTF7Encoding::GetBytes_3384066dd8b91ed8(System::String* s, int32_t charIndex, int32_t charCount, cli::array<unsigned char>* bytes, int32_t byteIndex) {
        return Encoding::GetBytes_3384066dd8b91ed8(s, charIndex, charCount, bytes, byteIndex);
    }
    
    int32_t UTF7Encoding::GetCharCount_4e601cea7c3f10cd(unsigned char* bytes, int32_t count) {
        return Encoding::GetCharCount_4e601cea7c3f10cd(bytes, count);
    }
    
    int32_t UTF7Encoding::GetChars_8904b350d20e4ab8(unsigned char* bytes, int32_t byteCount, char16_t* chars, int32_t charCount) {
        return Encoding::GetChars_8904b350d20e4ab8(bytes, byteCount, chars, charCount);
    }
    
    System::String* UTF7Encoding::GetString_39f4843197ddbe92(cli::array<unsigned char>* bytes, int32_t index, int32_t count) {
        return Encoding::GetString_39f4843197ddbe92(bytes, index, count);
    }
    
}}
namespace System { namespace Text {
    
    
    void UTF8Decoder::constructor(DecoderFallback* fallback) {
        this->set_Fallback(fallback);
        this->leftOverBits = 0U;
        this->leftOverCount = 0U;
    }
    
    int32_t UTF8Decoder::GetCharCount_32dfa16feccdb25d(cli::array<unsigned char>* bytes, int32_t index, int32_t count) {
        DecoderFallbackBuffer *buf = nullptr;
        cli::array<unsigned char> *bufferArg = nullptr;
        return UTF8Encoding::InternalGetCharCount(bytes, index, count, this->leftOverBits, this->leftOverCount, this, buf, bufferArg, false);
    }
    
    int32_t UTF8Decoder::GetChars_beecc497fe0b7526(cli::array<unsigned char>* bytes, int32_t byteIndex, int32_t byteCount, cli::array<char16_t>* chars, int32_t charIndex) {
        DecoderFallbackBuffer *buf = nullptr;
        cli::array<unsigned char> *bufferArg = nullptr;
        return UTF8Encoding::InternalGetChars(bytes, byteIndex, byteCount, chars, charIndex, this->leftOverBits, this->leftOverCount, this, buf, bufferArg, false);
    }
    
}}
namespace System { namespace Text {
    
    
    void UTF8Encoder::constructor(EncoderFallback* fallback, bool emitIdentifier) {
        this->set_Fallback(fallback);
        this->leftOverForCount = u'\x0';
        this->leftOverForConv = u'\x0';
    }
    
    int32_t UTF8Encoder::GetByteCount_85f1385779510289(cli::array<char16_t>* chars, int32_t index, int32_t count, bool flush) {
        return UTF8Encoding::InternalGetByteCount(chars, index, count, this->get_Fallback(), this->leftOverForCount, flush);
    }
    
    int32_t UTF8Encoder::GetBytes_ac22a3cfd526ffd3(cli::array<char16_t>* chars, int32_t charIndex, int32_t charCount, cli::array<unsigned char>* bytes, int32_t byteIndex, bool flush) {
        int32_t result;
        EncoderFallbackBuffer *buffer = nullptr;
        result = UTF8Encoding::InternalGetBytes(chars, charIndex, charCount, bytes, byteIndex, this->get_Fallback(), buffer, this->leftOverForConv, flush);
        return result;
    }
    
    int32_t UTF8Encoder::GetByteCount_addb240243fed46d(char16_t* chars, int32_t count, bool flush) {
        return UTF8Encoding::InternalGetByteCount2(chars, count, this->get_Fallback(), this->leftOverForCount, flush);
    }
    
    int32_t UTF8Encoder::GetBytes_4985ee639a8a9b65(char16_t* chars, int32_t charCount, unsigned char* bytes, int32_t byteCount, bool flush) {
        int32_t result;
        EncoderFallbackBuffer *buffer = nullptr;
        result = UTF8Encoding::InternalGetBytes2(chars, charCount, bytes, byteCount, this->get_Fallback(), buffer, this->leftOverForConv, flush);
        return result;
    }
    
}}
namespace System { namespace Text {
    
    
    void UTF8Encoding::constructor() {
    }
    
    void UTF8Encoding::constructor(bool encoderShouldEmitUTF8Identifier) {
    }
    
    void UTF8Encoding::constructor(bool encoderShouldEmitUTF8Identifier, bool throwOnInvalidBytes) {
        this->emitIdentifier = encoderShouldEmitUTF8Identifier;
        if(throwOnInvalidBytes) 
        {
            Encoding::SetFallbackInternal(EncoderFallback::get_ExceptionFallback(), DecoderFallback::get_ExceptionFallback());
        }
         else 
        {
            Encoding::SetFallbackInternal(EncoderFallback::get_StandardSafeFallback(), DecoderFallback::get_StandardSafeFallback());
        }
        this->web_name = this->body_name = this->header_name = _T("utf-8");
        this->encoding_name = _T("Unicode (UTF-8)");
        this->is_browser_save = true;
        this->is_browser_display = true;
        this->is_mail_news_display = true;
        this->is_mail_news_save = true;
        this->windows_code_page = 1200;
    }
    
    int32_t UTF8Encoding::InternalGetByteCount(cli::array<char16_t>* chars, int32_t index, int32_t count, EncoderFallback* fallback, char16_t leftOver, bool flush) {
        if((chars ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("chars"));
        }
        if(((index < 0) || (index > chars->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("index"), Encoding::_(_T("ArgRange_Array")));
        }
        if(((count < 0) || (count > (chars->get_Length() - index)))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("count"), Encoding::_(_T("ArgRange_Array")));
        }
        if((index ==  chars->get_Length())) 
        {
            if((flush && ((int32_t)(leftOver) != 0))) 
            {
                leftOver = u'\x0';
                return 3;
            }
            return 0;
        }
        {
            /* FIXED - BLOCK */
            char16_t* cptr = cli::fixed_guard(((chars ==  nullptr) || (chars->get_Length() ==  0)) ? nullptr : chars);
            return InternalGetByteCount2((cptr + (int32_t)(index)), count, fallback, leftOver, flush);
        }
    }
    
    int32_t UTF8Encoding::InternalGetByteCount2(char16_t* chars, int32_t count, EncoderFallback* fallback, char16_t leftOver, bool flush) {
        int32_t length = 0;
        char16_t *end = (chars + (int32_t)(count));
        char16_t *start = chars;
        EncoderFallbackBuffer *buffer = nullptr;
        while((chars < end)) {
            if(((int32_t)(leftOver) ==  0)) 
            {
                for(; (chars < end); chars++){
                    if(((int32_t)((*chars)) < 128)) 
                    {
                        ++length;
                    }
                     else 
                    {
                        if(((int32_t)((*chars)) < 2048)) 
                        {
                            (length = length + 2);
                        }
                         else 
                        {
                            if((((int32_t)((*chars)) < 55296) || ((int32_t)((*chars)) > 57343))) 
                            {
                                (length = length + 3);
                            }
                             else 
                            {
                                if(((int32_t)((*chars)) <= 56319)) 
                                {
                                    if(((((chars + 2) < end) && ((int32_t)((*(chars + 2))) >= 56320)) && ((int32_t)((*(chars + 2))) <= 57343))) 
                                    {
                                        (length = length + 4);
                                        chars++;
                                        continue;
                                    }
                                    leftOver = (*chars);
                                    chars++;
                                    break;
                                }
                                 else 
                                {
                                    cli::array<char16_t> *fallback_chars = GetFallbackChars(chars, start, fallback, buffer);
                                    {
                                        /* FIXED - BLOCK */
                                        char16_t* fb_chars = cli::fixed_guard(((fallback_chars ==  nullptr) || (fallback_chars->get_Length() ==  0)) ? nullptr : fallback_chars);
                                        char16_t dummy = u'\x0';
                                        (length = length + InternalGetByteCount2(fb_chars, fallback_chars->get_Length(), fallback, dummy, true));
                                    }
                                    leftOver = u'\x0';
                                }
                            }
                        }
                    }
                }
            }
             else 
            {
                if((((int32_t)((*chars)) >= 56320) && ((int32_t)((*chars)) <= 57343))) 
                {
                    (length = length + 4);
                    chars++;
                }
                 else 
                {
                    cli::array<char16_t> *fallback_chars = GetFallbackChars(chars, start, fallback, buffer);
                    {
                        /* FIXED - BLOCK */
                        char16_t* fb_chars = cli::fixed_guard(((fallback_chars ==  nullptr) || (fallback_chars->get_Length() ==  0)) ? nullptr : fallback_chars);
                        char16_t dummy = u'\x0';
                        (length = length + InternalGetByteCount2(fb_chars, fallback_chars->get_Length(), fallback, dummy, true));
                    }
                }
                leftOver = u'\x0';
            }
        }
        if(flush) 
        {
            if(((int32_t)(leftOver) != 0)) 
            {
                (length = length + 3);
                leftOver = u'\x0';
            }
        }
        return length;
    }
    
    cli::array<char16_t>* UTF8Encoding::GetFallbackChars(char16_t* chars, char16_t* start, EncoderFallback* fallback, EncoderFallbackBuffer* buffer) {
        if((buffer ==  nullptr)) 
        {
            buffer = fallback->CreateFallbackBuffer_a579589a4ca0924f();
        }
        buffer->Fallback_2e254195ffd348dc((*chars), (int32_t)(chars - start));
        cli::array<char16_t> *fallback_chars = (new cli::array<char16_t>(buffer->get_Remaining_dd4149ac6c4a9379()));
        for(int32_t i = 0; (i < fallback_chars->get_Length()); i++) {
            fallback_chars->at(i) = buffer->GetNextChar_84e759436123fac0();
        }
        buffer->Reset_e8feb6df1bde1a59();
        return fallback_chars;
    }
    
    int32_t UTF8Encoding::GetByteCount_7494b18116693a5e(cli::array<char16_t>* chars, int32_t index, int32_t count) {
        char16_t dummy = u'\x0';
        return InternalGetByteCount(chars, index, count, this->get_EncoderFallback(), dummy, true);
    }
    
    int32_t UTF8Encoding::GetByteCount_aec9823bd32c6735(char16_t* chars, int32_t count) {
        if((chars ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("chars"));
        }
        if((count ==  0)) 
        {
            return 0;
        }
        char16_t dummy = u'\x0';
        return InternalGetByteCount2(chars, count, this->get_EncoderFallback(), dummy, true);
    }
    
    int32_t UTF8Encoding::InternalGetBytes(cli::array<char16_t>* chars, int32_t charIndex, int32_t charCount, cli::array<unsigned char>* bytes, int32_t byteIndex, EncoderFallback* fallback, EncoderFallbackBuffer* buffer, char16_t leftOver, bool flush) {
        if((chars ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("chars"));
        }
        if((bytes ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("bytes"));
        }
        if(((charIndex < 0) || (charIndex > chars->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("charIndex"), Encoding::_(_T("ArgRange_Array")));
        }
        if(((charCount < 0) || (charCount > (chars->get_Length() - charIndex)))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("charCount"), Encoding::_(_T("ArgRange_Array")));
        }
        if(((byteIndex < 0) || (byteIndex > bytes->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("byteIndex"), Encoding::_(_T("ArgRange_Array")));
        }
        if((charIndex ==  chars->get_Length())) 
        {
            if((flush && ((int32_t)(leftOver) != 0))) 
            {
                leftOver = u'\x0';
            }
            return 0;
        }
        {
            /* FIXED - BLOCK */
            char16_t* cptr = cli::fixed_guard(((chars ==  nullptr) || (chars->get_Length() ==  0)) ? nullptr : chars);
            if((bytes->get_Length() ==  byteIndex)) 
            {
                return InternalGetBytes2((cptr + (int32_t)(charIndex)), charCount, nullptr, 0, fallback, buffer, leftOver, flush);
            }
            {
                /* FIXED - BLOCK */
                unsigned char* bptr = cli::fixed_guard(((bytes ==  nullptr) || (bytes->get_Length() ==  0)) ? nullptr : bytes);
                return InternalGetBytes2((cptr + (int32_t)(charIndex)), charCount, (bptr + (int32_t)(byteIndex)), (bytes->get_Length() - byteIndex), fallback, buffer, leftOver, flush);
            }
        }
    }
    
    int32_t UTF8Encoding::InternalGetBytes2(char16_t* chars, int32_t count, unsigned char* bytes, int32_t bcount, EncoderFallback* fallback, EncoderFallbackBuffer* buffer, char16_t leftOver, bool flush) {
        char16_t *end = (chars + (int32_t)(count));
        char16_t *start = chars;
        unsigned char *start_bytes = bytes;
        unsigned char *end_bytes = (bytes + (int32_t)(bcount));
        while((chars < end)) {
            if(((int32_t)(leftOver) ==  0)) 
            {
                for(; (chars < end); chars++){
                    int32_t ch = (int32_t)((*chars));
                    if((ch < 128)) 
                    {
                        if((bytes >= end_bytes)) 
                        {
                            goto fail_no_space;
                        }
                        (*bytes++) = (unsigned char)ch;
                    }
                     else 
                    {
                        if((ch < 2048)) 
                        {
                            if(((bytes + 1) >= end_bytes)) 
                            {
                                goto fail_no_space;
                            }
                            (*(bytes + 0)) = (unsigned char)(192 | (ch >> 6));
                            (*(bytes + 1)) = (unsigned char)(128 | (ch & 63));
                            (bytes = (bytes += 2));
                        }
                         else 
                        {
                            if(((ch < 55296) || (ch > 57343))) 
                            {
                                if(((bytes + 2) >= end_bytes)) 
                                {
                                    goto fail_no_space;
                                }
                                (*(bytes + 0)) = (unsigned char)(224 | (ch >> 12));
                                (*(bytes + 1)) = (unsigned char)(128 | ((ch >> 6) & 63));
                                (*(bytes + 2)) = (unsigned char)(128 | (ch & 63));
                                (bytes = (bytes += 3));
                            }
                             else 
                            {
                                if((ch <= 56319)) 
                                {
                                    leftOver = (*chars);
                                    chars++;
                                    break;
                                }
                                 else 
                                {
                                    cli::array<char16_t> *fallback_chars = GetFallbackChars(chars, start, fallback, buffer);
                                    char16_t dummy = u'\x0';
                                    if(((bytes + (int32_t)(InternalGetByteCount(fallback_chars, 0, fallback_chars->get_Length(), fallback, dummy, true))) > end_bytes)) 
                                    {
                                        goto fail_no_space;
                                    }
                                    {
                                        /* FIXED - BLOCK */
                                        char16_t* fb_chars = cli::fixed_guard(((fallback_chars ==  nullptr) || (fallback_chars->get_Length() ==  0)) ? nullptr : fallback_chars);
                                        (bytes = (bytes += (int32_t)(InternalGetBytes2(fb_chars, fallback_chars->get_Length(), bytes, (bcount - (int32_t)(bytes - start_bytes)), fallback, buffer, dummy, true))));
                                    }
                                    leftOver = u'\x0';
                                }
                            }
                        }
                    }
                }
            }
             else 
            {
                if((((int32_t)((*chars)) >= 56320) && ((int32_t)((*chars)) <= 57343))) 
                {
                    int32_t ch = (((65536 + (int32_t)((*chars))) - 56320) + (((int32_t)(leftOver) - 55296) << 10));
                    if(((bytes + 3) >= end_bytes)) 
                    {
                        goto fail_no_space;
                    }
                    (*(bytes + 0)) = (unsigned char)(240 | (ch >> 18));
                    (*(bytes + 1)) = (unsigned char)(128 | ((ch >> 12) & 63));
                    (*(bytes + 2)) = (unsigned char)(128 | ((ch >> 6) & 63));
                    (*(bytes + 3)) = (unsigned char)(128 | (ch & 63));
                    (bytes = (bytes += 4));
                    chars++;
                }
                 else 
                {
                    cli::array<char16_t> *fallback_chars = GetFallbackChars(chars, start, fallback, buffer);
                    char16_t dummy = u'\x0';
                    if(((bytes + (int32_t)(InternalGetByteCount(fallback_chars, 0, fallback_chars->get_Length(), fallback, dummy, true))) > end_bytes)) 
                    {
                        goto fail_no_space;
                    }
                    {
                        /* FIXED - BLOCK */
                        char16_t* fb_chars = cli::fixed_guard(((fallback_chars ==  nullptr) || (fallback_chars->get_Length() ==  0)) ? nullptr : fallback_chars);
                        InternalGetBytes2(fb_chars, fallback_chars->get_Length(), bytes, (bcount - (int32_t)(bytes - start_bytes)), fallback, buffer, dummy, true);
                    }
                    leftOver = u'\x0';
                }
                leftOver = u'\x0';
            }
        }
        if(flush) 
        {
            if(((int32_t)(leftOver) != 0)) 
            {
                int32_t ch = (int32_t)(leftOver);
                if(((bytes + 2) < end_bytes)) 
                {
                    (*(bytes + 0)) = (unsigned char)(224 | (ch >> 12));
                    (*(bytes + 1)) = (unsigned char)(128 | ((ch >> 6) & 63));
                    (*(bytes + 2)) = (unsigned char)(128 | (ch & 63));
                    (bytes = (bytes += 3));
                }
                 else 
                {
                    goto fail_no_space;
                }
                leftOver = u'\x0';
            }
        }
        return (int32_t)(bytes - (end_bytes - (int32_t)(bcount)));
        fail_no_space:
        throw cli::gcnew<System::ArgumentException>(_T("Insufficient Space"), _T("bytes"));
    }
    
    int32_t UTF8Encoding::GetBytes_90650b3cf924e5e2(cli::array<char16_t>* chars, int32_t charIndex, int32_t charCount, cli::array<unsigned char>* bytes, int32_t byteIndex) {
        char16_t leftOver = u'\x0';
        EncoderFallbackBuffer *buffer = nullptr;
        return InternalGetBytes(chars, charIndex, charCount, bytes, byteIndex, this->get_EncoderFallback(), buffer, leftOver, true);
    }
    
    int32_t UTF8Encoding::GetBytes_3384066dd8b91ed8(System::String* s, int32_t charIndex, int32_t charCount, cli::array<unsigned char>* bytes, int32_t byteIndex) {
        if((s ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("s"));
        }
        if((bytes ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("bytes"));
        }
        if(((charIndex < 0) || (charIndex > s->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("charIndex"), Encoding::_(_T("ArgRange_StringIndex")));
        }
        if(((charCount < 0) || (charCount > (s->get_Length() - charIndex)))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("charCount"), Encoding::_(_T("ArgRange_StringRange")));
        }
        if(((byteIndex < 0) || (byteIndex > bytes->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("byteIndex"), Encoding::_(_T("ArgRange_Array")));
        }
        if((charIndex ==  s->get_Length())) 
        {
            return 0;
        }
        {
            /* FIXED - BLOCK */
            char16_t* cptr = cli::fixed_guard(s);
            char16_t dummy = u'\x0';
            EncoderFallbackBuffer *buffer = nullptr;
            if((bytes->get_Length() ==  byteIndex)) 
            {
                return InternalGetBytes2((cptr + (int32_t)(charIndex)), charCount, nullptr, 0, this->get_EncoderFallback(), buffer, dummy, true);
            }
            {
                /* FIXED - BLOCK */
                unsigned char* bptr = cli::fixed_guard(((bytes ==  nullptr) || (bytes->get_Length() ==  0)) ? nullptr : bytes);
                return InternalGetBytes2((cptr + (int32_t)(charIndex)), charCount, (bptr + (int32_t)(byteIndex)), (bytes->get_Length() - byteIndex), this->get_EncoderFallback(), buffer, dummy, true);
            }
        }
    }
    
    int32_t UTF8Encoding::GetBytes_9b94592fd1d1a5af(char16_t* chars, int32_t charCount, unsigned char* bytes, int32_t byteCount) {
        if((chars ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("chars"));
        }
        if((charCount < 0)) 
        {
            throw cli::gcnew<System::IndexOutOfRangeException>(_T("charCount"));
        }
        if((bytes ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("bytes"));
        }
        if((byteCount < 0)) 
        {
            throw cli::gcnew<System::IndexOutOfRangeException>(_T("charCount"));
        }
        if((charCount ==  0)) 
        {
            return 0;
        }
        char16_t dummy = u'\x0';
        EncoderFallbackBuffer *buffer = nullptr;
        if((byteCount ==  0)) 
        {
            return InternalGetBytes2(chars, charCount, nullptr, 0, this->get_EncoderFallback(), buffer, dummy, true);
        }
         else 
        {
            return InternalGetBytes2(chars, charCount, bytes, byteCount, this->get_EncoderFallback(), buffer, dummy, true);
        }
    }
    
    int32_t UTF8Encoding::InternalGetCharCount(cli::array<unsigned char>* bytes, int32_t index, int32_t count, uint32_t leftOverBits, uint32_t leftOverCount, System::Object* provider, DecoderFallbackBuffer* fallbackBuffer, cli::array<unsigned char>* bufferArg, bool flush) {
        if((bytes ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("bytes"));
        }
        if(((index < 0) || (index > bytes->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("index"), Encoding::_(_T("ArgRange_Array")));
        }
        if(((count < 0) || (count > (bytes->get_Length() - index)))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("count"), Encoding::_(_T("ArgRange_Array")));
        }
        if((count ==  0)) 
        {
            return 0;
        }
        {
            /* FIXED - BLOCK */
            unsigned char* bptr = cli::fixed_guard(((bytes ==  nullptr) || (bytes->get_Length() ==  0)) ? nullptr : bytes);
            {
                return InternalGetCharCount2((bptr + (int32_t)(index)), count, leftOverBits, leftOverCount, provider, fallbackBuffer, bufferArg, flush);
            }
        }
    }
    
    int32_t UTF8Encoding::InternalGetCharCount2(unsigned char* bytes, int32_t count, uint32_t leftOverBits, uint32_t leftOverCount, System::Object* provider, DecoderFallbackBuffer* fallbackBuffer, cli::array<unsigned char>* bufferArg, bool flush) {
        int32_t index = 0;
        int32_t length = 0;
        if((leftOverCount ==  0U)) 
        {
            int32_t end = (index + count);
            for(; (index < end); index++, count--){
                if(((int32_t)((*(bytes + index))) < 128)) 
                {
                    length++;
                }
                 else 
                {
                    break;
                }
            }
        }
        uint32_t ch;
        uint32_t leftBits = leftOverBits;
        uint32_t leftSoFar = (leftOverCount & 15U);
        uint32_t leftSize = ((leftOverCount >> 4) & 15U);
        while((count > 0)) {
            ch = (uint32_t)((*(bytes + index++)));
            --count;
            if((leftSize ==  0U)) 
            {
                if((ch < 128U)) 
                {
                    ++length;
                }
                 else 
                {
                    if(((ch & 224U) ==  192U)) 
                    {
                        leftBits = (ch & 31U);
                        leftSoFar = 1U;
                        leftSize = 2U;
                    }
                     else 
                    {
                        if(((ch & 240U) ==  224U)) 
                        {
                            leftBits = (ch & 15U);
                            leftSoFar = 1U;
                            leftSize = 3U;
                        }
                         else 
                        {
                            if(((ch & 248U) ==  240U)) 
                            {
                                leftBits = (ch & 7U);
                                leftSoFar = 1U;
                                leftSize = 4U;
                            }
                             else 
                            {
                                if(((ch & 252U) ==  248U)) 
                                {
                                    leftBits = (ch & 3U);
                                    leftSoFar = 1U;
                                    leftSize = 5U;
                                }
                                 else 
                                {
                                    if(((ch & 254U) ==  252U)) 
                                    {
                                        leftBits = (ch & 3U);
                                        leftSoFar = 1U;
                                        leftSize = 6U;
                                    }
                                     else 
                                    {
                                        (length = length + Fallback(provider, fallbackBuffer, bufferArg, bytes, (int64_t)((index - 1)), 1U));
                                    }
                                }
                            }
                        }
                    }
                }
            }
             else 
            {
                if(((ch & 192U) ==  128U)) 
                {
                    leftBits = ((leftBits << 6) | (ch & 63U));
                    if((++leftSoFar >= leftSize)) 
                    {
                        if((leftBits < 65536U)) 
                        {
                            bool overlong = false;
                            switch(leftSize) {
                                case 2U: case_1821: {
                                    overlong = (leftBits <= 127U);
                                    break;
                                }
                                case 3U: case_1822: {
                                    overlong = (leftBits <= 2047U);
                                    break;
                                }
                                case 4U: case_1823: {
                                    overlong = (leftBits <= 65535U);
                                    break;
                                }
                                case 5U: case_1824: {
                                    overlong = (leftBits <= 2097151U);
                                    break;
                                }
                                case 6U: case_1825: {
                                    overlong = (leftBits <= 67108863U);
                                    break;
                                }
                            }
                            if(overlong) 
                            {
                                (length = length + Fallback(provider, fallbackBuffer, bufferArg, bytes, ((int64_t)(index) - (int64_t)(leftSoFar)), leftSoFar));
                            }
                             else 
                            {
                                if(((leftBits & 63488U) ==  55296U)) 
                                {
                                    (length = length + Fallback(provider, fallbackBuffer, bufferArg, bytes, ((int64_t)(index) - (int64_t)(leftSoFar)), leftSoFar));
                                }
                                 else 
                                {
                                    ++length;
                                }
                            }
                        }
                         else 
                        {
                            if((leftBits < 1114112U)) 
                            {
                                (length = length + 2);
                            }
                             else 
                            {
                                (length = length + Fallback(provider, fallbackBuffer, bufferArg, bytes, ((int64_t)(index) - (int64_t)(leftSoFar)), leftSoFar));
                            }
                        }
                        leftSize = 0U;
                    }
                }
                 else 
                {
                    (length = length + Fallback(provider, fallbackBuffer, bufferArg, bytes, ((int64_t)(index) - (int64_t)(leftSoFar)), leftSoFar));
                    leftSize = 0U;
                    --index;
                    ++count;
                }
            }
        }
        if((flush && (leftSize != 0U))) 
        {
            (length = length + Fallback(provider, fallbackBuffer, bufferArg, bytes, ((int64_t)(index) - (int64_t)(leftSoFar)), leftSoFar));
        }
        return length;
    }
    
    int32_t UTF8Encoding::Fallback(System::Object* provider, DecoderFallbackBuffer* buffer, cli::array<unsigned char>* bufferArg, unsigned char* bytes, int64_t index, uint32_t size) {
        if((buffer ==  nullptr)) 
        {
            DecoderFallback *fb = cli::as<DecoderFallback*>(provider);
            if((fb != nullptr)) 
            {
                buffer = fb->CreateFallbackBuffer_dad5db136d065044();
            }
             else 
            {
                buffer = cli::cast<Decoder2*>(provider)->get_FallbackBuffer();
            }
        }
        if((bufferArg ==  nullptr)) 
        {
            bufferArg = (new cli::array<unsigned char>(1));
        }
        int32_t ret = 0;
        for(int32_t i = 0; ((int64_t)(i) < (int64_t)(size)); i++){
            bufferArg->at(0) = (*(bytes + ((int32_t)index + i)));
            buffer->Fallback_1ea6d9bfef1f4bac(bufferArg, 0);
            (ret = ret + buffer->get_Remaining_b256701c9c2b0bc4());
            buffer->Reset_dc5d0be891187587();
        }
        return ret;
    }
    
    void UTF8Encoding::Fallback2(System::Object* provider, DecoderFallbackBuffer* buffer, cli::array<unsigned char>* bufferArg, unsigned char* bytes, int64_t byteIndex, uint32_t size, char16_t* chars, int32_t charIndex) {
        if((buffer ==  nullptr)) 
        {
            DecoderFallback *fb = cli::as<DecoderFallback*>(provider);
            if((fb != nullptr)) 
            {
                buffer = fb->CreateFallbackBuffer_dad5db136d065044();
            }
             else 
            {
                buffer = cli::cast<Decoder2*>(provider)->get_FallbackBuffer();
            }
        }
        if((bufferArg ==  nullptr)) 
        {
            bufferArg = (new cli::array<unsigned char>(1));
        }
        for(int32_t i = 0; ((int64_t)(i) < (int64_t)(size)); i++){
            bufferArg->at(0) = (*(bytes + (byteIndex + (int64_t)(i))));
            buffer->Fallback_1ea6d9bfef1f4bac(bufferArg, 0);
            while((buffer->get_Remaining_b256701c9c2b0bc4() > 0)) (*(chars + charIndex++)) = buffer->GetNextChar_7967ec44cca772f9();
            buffer->Reset_dc5d0be891187587();
        }
    }
    
    int32_t UTF8Encoding::GetCharCount_aa33a7717b095c8e(cli::array<unsigned char>* bytes, int32_t index, int32_t count) {
        DecoderFallbackBuffer *buf = nullptr;
        cli::array<unsigned char> *bufferArg = nullptr;
        return InternalGetCharCount(bytes, index, count, 0U, 0U, this->get_DecoderFallback(), buf, bufferArg, true);
    }
    
    int32_t UTF8Encoding::GetCharCount_4e601cea7c3f10cd(unsigned char* bytes, int32_t count) {
        DecoderFallbackBuffer *buf = nullptr;
        cli::array<unsigned char> *bufferArg = nullptr;
        return InternalGetCharCount2(bytes, count, 0U, 0U, this->get_DecoderFallback(), buf, bufferArg, true);
    }
    
    int32_t UTF8Encoding::InternalGetChars(cli::array<unsigned char>* bytes, int32_t byteIndex, int32_t byteCount, cli::array<char16_t>* chars, int32_t charIndex, uint32_t leftOverBits, uint32_t leftOverCount, System::Object* provider, DecoderFallbackBuffer* fallbackBuffer, cli::array<unsigned char>* bufferArg, bool flush) {
        if((bytes ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("bytes"));
        }
        if((chars ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("chars"));
        }
        if(((byteIndex < 0) || (byteIndex > bytes->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("byteIndex"), Encoding::_(_T("ArgRange_Array")));
        }
        if(((byteCount < 0) || (byteCount > (bytes->get_Length() - byteIndex)))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("byteCount"), Encoding::_(_T("ArgRange_Array")));
        }
        if(((charIndex < 0) || (charIndex > chars->get_Length()))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("charIndex"), Encoding::_(_T("ArgRange_Array")));
        }
        if((charIndex ==  chars->get_Length())) 
        {
            return 0;
        }
        {
            /* FIXED - BLOCK */
            char16_t* cptr = cli::fixed_guard(((chars ==  nullptr) || (chars->get_Length() ==  0)) ? nullptr : chars);
            if(((byteCount ==  0) || (byteIndex ==  bytes->get_Length()))) 
            {
                return InternalGetChars2(nullptr, 0, (cptr + (int32_t)(charIndex)), (chars->get_Length() - charIndex), leftOverBits, leftOverCount, provider, fallbackBuffer, bufferArg, flush);
            }
            {
                /* FIXED - BLOCK */
                unsigned char* bptr = cli::fixed_guard(((bytes ==  nullptr) || (bytes->get_Length() ==  0)) ? nullptr : bytes);
                {
                    return InternalGetChars2((bptr + (int32_t)(byteIndex)), byteCount, (cptr + (int32_t)(charIndex)), (chars->get_Length() - charIndex), leftOverBits, leftOverCount, provider, fallbackBuffer, bufferArg, flush);
                }
            }
        }
    }
    
    int32_t UTF8Encoding::InternalGetChars2(unsigned char* bytes, int32_t byteCount, char16_t* chars, int32_t charCount, uint32_t leftOverBits, uint32_t leftOverCount, System::Object* provider, DecoderFallbackBuffer* fallbackBuffer, cli::array<unsigned char>* bufferArg, bool flush) {
        int32_t charIndex = 0, byteIndex = 0;
        int32_t length = charCount;
        int32_t posn = charIndex;
        if((leftOverCount ==  0U)) 
        {
            int32_t end = (byteIndex + byteCount);
            for(; (byteIndex < end); posn++, byteIndex++, byteCount--){
                if(((int32_t)((*(bytes + byteIndex))) < 128)) 
                {
                    (*(chars + posn)) = (char16_t)(*(bytes + byteIndex));
                }
                 else 
                {
                    break;
                }
            }
        }
        uint32_t ch;
        uint32_t leftBits = leftOverBits;
        uint32_t leftSoFar = (leftOverCount & 15U);
        uint32_t leftSize = ((leftOverCount >> 4) & 15U);
        int32_t byteEnd = (byteIndex + byteCount);
        for(; (byteIndex < byteEnd); byteIndex++){
            ch = (uint32_t)((*(bytes + byteIndex)));
            if((leftSize ==  0U)) 
            {
                if((ch < 128U)) 
                {
                    if((posn >= length)) 
                    {
                        throw cli::gcnew<System::ArgumentException>(Encoding::_(_T("Arg_InsufficientSpace")), _T("chars"));
                    }
                    (*(chars + posn++)) = (char16_t)ch;
                }
                 else 
                {
                    if(((ch & 224U) ==  192U)) 
                    {
                        leftBits = (ch & 31U);
                        leftSoFar = 1U;
                        leftSize = 2U;
                    }
                     else 
                    {
                        if(((ch & 240U) ==  224U)) 
                        {
                            leftBits = (ch & 15U);
                            leftSoFar = 1U;
                            leftSize = 3U;
                        }
                         else 
                        {
                            if(((ch & 248U) ==  240U)) 
                            {
                                leftBits = (ch & 7U);
                                leftSoFar = 1U;
                                leftSize = 4U;
                            }
                             else 
                            {
                                if(((ch & 252U) ==  248U)) 
                                {
                                    leftBits = (ch & 3U);
                                    leftSoFar = 1U;
                                    leftSize = 5U;
                                }
                                 else 
                                {
                                    if(((ch & 254U) ==  252U)) 
                                    {
                                        leftBits = (ch & 3U);
                                        leftSoFar = 1U;
                                        leftSize = 6U;
                                    }
                                     else 
                                    {
                                        Fallback2(provider, fallbackBuffer, bufferArg, bytes, (int64_t)(byteIndex), 1U, chars, posn);
                                    }
                                }
                            }
                        }
                    }
                }
            }
             else 
            {
                if(((ch & 192U) ==  128U)) 
                {
                    leftBits = ((leftBits << 6) | (ch & 63U));
                    if((++leftSoFar >= leftSize)) 
                    {
                        if((leftBits < 65536U)) 
                        {
                            bool overlong = false;
                            switch(leftSize) {
                                case 2U: case_1826: {
                                    overlong = (leftBits <= 127U);
                                    break;
                                }
                                case 3U: case_1827: {
                                    overlong = (leftBits <= 2047U);
                                    break;
                                }
                                case 4U: case_1828: {
                                    overlong = (leftBits <= 65535U);
                                    break;
                                }
                                case 5U: case_1829: {
                                    overlong = (leftBits <= 2097151U);
                                    break;
                                }
                                case 6U: case_1830: {
                                    overlong = (leftBits <= 67108863U);
                                    break;
                                }
                            }
                            if(overlong) 
                            {
                                Fallback2(provider, fallbackBuffer, bufferArg, bytes, ((int64_t)(byteIndex) - (int64_t)(leftSoFar)), leftSoFar, chars, posn);
                            }
                             else 
                            {
                                if(((leftBits & 63488U) ==  55296U)) 
                                {
                                    Fallback2(provider, fallbackBuffer, bufferArg, bytes, ((int64_t)(byteIndex) - (int64_t)(leftSoFar)), leftSoFar, chars, posn);
                                }
                                 else 
                                {
                                    if((posn >= length)) 
                                    {
                                        throw cli::gcnew<System::ArgumentException>(Encoding::_(_T("Arg_InsufficientSpace")), _T("chars"));
                                    }
                                    (*(chars + posn++)) = (char16_t)leftBits;
                                }
                            }
                        }
                         else 
                        {
                            if((leftBits < 1114112U)) 
                            {
                                if(((posn + 2) > length)) 
                                {
                                    throw cli::gcnew<System::ArgumentException>(Encoding::_(_T("Arg_InsufficientSpace")), _T("chars"));
                                }
                                (leftBits = leftBits - 65536U);
                                (*(chars + posn++)) = (char16_t)((leftBits >> 10) + 55296U);
                                (*(chars + posn++)) = (char16_t)((leftBits & 1023U) + 56320U);
                            }
                             else 
                            {
                                Fallback2(provider, fallbackBuffer, bufferArg, bytes, ((int64_t)(byteIndex) - (int64_t)(leftSoFar)), leftSoFar, chars, posn);
                            }
                        }
                        leftSize = 0U;
                    }
                }
                 else 
                {
                    Fallback2(provider, fallbackBuffer, bufferArg, bytes, ((int64_t)(byteIndex) - (int64_t)(leftSoFar)), leftSoFar, chars, posn);
                    leftSize = 0U;
                    --byteIndex;
                }
            }
        }
        if((flush && (leftSize != 0U))) 
        {
            Fallback2(provider, fallbackBuffer, bufferArg, bytes, ((int64_t)(byteIndex) - (int64_t)(leftSoFar)), leftSoFar, chars, posn);
        }
        leftOverBits = leftBits;
        leftOverCount = (leftSoFar | (leftSize << 4));
        return (posn - charIndex);
    }
    
    int32_t UTF8Encoding::GetChars_d7b47e17fd0a13f2(cli::array<unsigned char>* bytes, int32_t byteIndex, int32_t byteCount, cli::array<char16_t>* chars, int32_t charIndex) {
        uint32_t leftOverBits = 0U;
        uint32_t leftOverCount = 0U;
        DecoderFallbackBuffer *buf = nullptr;
        cli::array<unsigned char> *bufferArg = nullptr;
        return InternalGetChars(bytes, byteIndex, byteCount, chars, charIndex, leftOverBits, leftOverCount, this->get_DecoderFallback(), buf, bufferArg, true);
    }
    
    int32_t UTF8Encoding::GetChars_8904b350d20e4ab8(unsigned char* bytes, int32_t byteCount, char16_t* chars, int32_t charCount) {
        DecoderFallbackBuffer *buf = nullptr;
        cli::array<unsigned char> *bufferArg = nullptr;
        uint32_t leftOverBits = 0U;
        uint32_t leftOverCount = 0U;
        return InternalGetChars2(bytes, byteCount, chars, charCount, leftOverBits, leftOverCount, this->get_DecoderFallback(), buf, bufferArg, true);
    }
    
    int32_t UTF8Encoding::GetMaxByteCount_5bd2cee34757a0d4(int32_t charCount) {
        if((charCount < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("charCount"), Encoding::_(_T("ArgRange_NonNegative")));
        }
        return (charCount * 4);
    }
    
    int32_t UTF8Encoding::GetMaxCharCount_4eba560ac1240518(int32_t byteCount) {
        if((byteCount < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("byteCount"), Encoding::_(_T("ArgRange_NonNegative")));
        }
        return byteCount;
    }
    
    Decoder2* UTF8Encoding::GetDecoder_380c5e0c575e9cb5() {
        return cli::gcnew<UTF8Decoder>(this->get_DecoderFallback());
    }
    
    Encoder* UTF8Encoding::GetEncoder_c3a25b0b739d51c8() {
        return cli::gcnew<UTF8Encoder>(this->get_EncoderFallback(), this->emitIdentifier);
    }
    
    cli::array<unsigned char>* UTF8Encoding::GetPreamble_15ff85f00c460f87() {
        if(this->emitIdentifier) 
        {
            return (new cli::array<unsigned char>({239, 187, 191}));
        }
        return (new cli::array<unsigned char>(0));
    }
    
    bool UTF8Encoding::Equals_ed975d2f4a7d193e(System::Object* value) {
        UTF8Encoding *enc = cli::as<UTF8Encoding*>(value);
        if((enc != nullptr)) 
        {
            return ((((this->codePage ==  enc->codePage) && (this->emitIdentifier ==  enc->emitIdentifier)) && this->get_DecoderFallback()->Equals_ed975d2f4a7d193e(enc->get_DecoderFallback())) && this->get_EncoderFallback()->Equals_ed975d2f4a7d193e(enc->get_EncoderFallback()));
        }
         else 
        {
            return false;
        }
    }
    
    int32_t UTF8Encoding::GetHashCode_6648aef0f235ee6c() {
        return Encoding::GetHashCode_6648aef0f235ee6c();
    }
    
    int32_t UTF8Encoding::GetByteCount_d98cd1485dc2ee98(System::String* chars) {
        return Encoding::GetByteCount_d98cd1485dc2ee98(chars);
    }
    
    System::String* UTF8Encoding::GetString_39f4843197ddbe92(cli::array<unsigned char>* bytes, int32_t index, int32_t count) {
        return Encoding::GetString_39f4843197ddbe92(bytes, index, count);
    }
    
}}
namespace System { namespace Threading {
    
    
    void AbandonedMutexException::constructor() {
    }
    
    void AbandonedMutexException::constructor(System::String* message) {
    }
    
    void AbandonedMutexException::constructor(int32_t location, WaitHandle* handle) {
        this->mutex_index = location;
        this->mutex = cli::as<Mutex*>(handle);
    }
    
    void AbandonedMutexException::constructor(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
    }
    
    void AbandonedMutexException::constructor(System::String* message, System::Exception* inner) {
    }
    
    void AbandonedMutexException::constructor(System::String* message, int32_t location, WaitHandle* handle) {
        this->mutex_index = location;
        this->mutex = cli::as<Mutex*>(handle);
    }
    
    void AbandonedMutexException::constructor(System::String* message, System::Exception* inner, int32_t location, WaitHandle* handle) {
        this->mutex_index = location;
        this->mutex = cli::as<Mutex*>(handle);
    }
    
    Mutex* AbandonedMutexException::get_Mutex() {
        return this->mutex;
    }
    
    int32_t AbandonedMutexException::get_MutexIndex() {
        return this->mutex_index;
    }
    
}}
namespace System { namespace Threading {
    
    
    void AtomicBoolean::constructor() {
    }
    
    bool AtomicBoolean::CompareAndExchange(bool expected, bool newVal) {
        int32_t newTemp = newVal ? 1 : 0;
        int32_t expectedTemp = expected ? 1 : 0;
        return (Interlocked::CompareExchange(this->flag, newTemp, expectedTemp) ==  expectedTemp);
    }
    
    AtomicBoolean* AtomicBoolean::FromValue(bool value) {
        AtomicBoolean *temp = cli::gcnew<AtomicBoolean>();
        temp->set_Value(value);
        return temp;
    }
    
    bool AtomicBoolean::TrySet() {
        return !(Exchange(true));
    }
    
    bool AtomicBoolean::TryRelaxedSet() {
        return ((this->flag ==  0) && !(Exchange(true)));
    }
    
    bool AtomicBoolean::Exchange(bool newVal) {
        int32_t newTemp = newVal ? 1 : 0;
        return (Interlocked::Exchange(this->flag, newTemp) ==  1);
    }
    
    bool AtomicBoolean::Equals3(AtomicBoolean* rhs) {
        return (this->flag ==  rhs->flag);
    }
    
    bool AtomicBoolean::Equals_ed975d2f4a7d193e(System::Object* rhs) {
        return cli::is<AtomicBoolean>(rhs) ? Equals3(cli::cast<AtomicBoolean*>(rhs)) : false;
    }
    
    int32_t AtomicBoolean::GetHashCode_6648aef0f235ee6c() {
        return cli::import(this->flag)->GetHashCode_6648aef0f235ee6c();
    }
    
    bool AtomicBoolean::op_Explicit(AtomicBoolean* rhs) {
        return rhs->get_Value();
    }
    
    AtomicBoolean* AtomicBoolean::op_Implicit(bool rhs) {
        return AtomicBoolean::FromValue(rhs);
    }
    
    bool AtomicBoolean::get_Value() {
        return (this->flag ==  1);
    }
    
    bool AtomicBoolean::set_Value(bool value) {
        Exchange(value);
        return get_Value();
    }
    
}}
namespace System { namespace Threading {
    
    
    void AutoResetEvent::constructor(bool initialState) {
    }
    
}}
namespace System { namespace Threading {
    
    CancellationTokenSource*  CancellationTokenSource::NoneSource;
    CancellationTokenSource*  CancellationTokenSource::CanceledSource;
    
    CancellationTokenSource::CancellationTokenSource()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void CancellationTokenSource::static_constructor() {
        CanceledSource->processed = true;
        CanceledSource->canceled = true;
    }
    
    void CancellationTokenSource::constructor() {
        this->callbacks = cli::gcnew<System::Collections::Generic::Dictionary<CancellationTokenRegistration, System::Action*>>();
        this->handle = cli::gcnew<ManualResetEvent>(false);
    }
    
    void CancellationTokenSource::Cancel() {
        Cancel2(false);
    }
    
    void CancellationTokenSource::Cancel2(bool throwOnFirstException) {
        CheckDisposed();
        this->canceled = true;
        this->handle->Set();
        System::Collections::Generic::List<System::Exception*> *exceptions = nullptr;
        {
            cli::lock_guard{this->syncRoot};
            {
                cli::finally_guard([&]() {
                    this->callbacks->Clear();
                });
                for(auto tmp_631 : this->callbacks) {
                    auto item = cli::cast<System::Collections::Generic::KeyValuePair<CancellationTokenRegistration, System::Action*>>(tmp_631);
                    {
                        if(throwOnFirstException) 
                        {
                            item->get_Value()->Invoke();
                        }
                         else 
                        {
                            try {
                                item->get_Value()->Invoke();
                            }
                            catch(System::Exception* e) {
                                if((exceptions ==  nullptr)) 
                                {
                                    exceptions = cli::gcnew<System::Collections::Generic::List<System::Exception*>>();
                                }
                                exceptions->Add(e);
                            }
                        }
                    }
                }
            }
        }
        Thread::MemoryBarrier();
        this->processed = true;
        if((exceptions != nullptr)) 
        {
            throw cli::gcnew<System::AggregateException>(exceptions);
        }
    }
    
    CancellationTokenSource* CancellationTokenSource::CreateLinkedTokenSource(CancellationToken token1, CancellationToken token2) {
        return CreateLinkedTokenSource2((new cli::array<CancellationToken>({token1, token2})));
    }
    
    CancellationTokenSource* CancellationTokenSource::CreateLinkedTokenSource2(cli::array<CancellationToken>* tokens) {
        if((tokens ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("tokens"));
        }
        if((tokens->get_Length() ==  0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("Empty tokens array"));
        }
        CancellationTokenSource *src = cli::gcnew<CancellationTokenSource>();
        System::Action *action = cli::bind(src, &CancellationTokenSource::Cancel);
        for(auto tmp_632 : tokens) {
            auto token = cli::cast<CancellationToken>(tmp_632);
            {
                if(token->get_CanBeCanceled()) 
                {
                    token->Register(action);
                }
            }
        }
        return src;
    }
    
    int32_t CancellationTokenSource::CheckTimeout(System::TimeSpan delay) {
        try {
            return cli::checked((int32_t)delay->get_TotalMilliseconds());
        }
        catch(System::OverflowException*) {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("delay"));
        }
    }
    
    void CancellationTokenSource::CheckDisposed() {
        if(this->disposed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(System::Object::GetType()->get_Name_50fad5fa936c3ae2());
        }
    }
    
    void CancellationTokenSource::Dispose() {
        Dispose2(true);
    }
    
    void CancellationTokenSource::Dispose2(bool disposing) {
        if((disposing && !(this->disposed))) 
        {
            this->disposed = true;
            this->callbacks = nullptr;
            this->handle->Dispose();
        }
    }
    
    CancellationTokenRegistration CancellationTokenSource::Register(System::Action* callback, bool useSynchronizationContext) {
        CheckDisposed();
        CancellationTokenRegistration tokenReg = cli::ctor<CancellationTokenRegistration>(Interlocked::Increment(this->currId), this);
        if(this->canceled) 
        {
            callback->Invoke();
        }
         else 
        {
            bool temp = false;
            {
                cli::lock_guard{this->syncRoot};
                if(!(temp = this->canceled)) 
                {
                    this->callbacks->Add(tokenReg, callback);
                }
            }
            if(temp) 
            {
                callback->Invoke();
            }
        }
        return tokenReg;
    }
    
    void CancellationTokenSource::RemoveCallback(CancellationTokenRegistration tokenReg) {
        if(!(this->canceled)) 
        {
            {
                cli::lock_guard{this->syncRoot};
                if(!(this->canceled)) 
                {
                    this->callbacks->Remove(tokenReg);
                    return;
                }
            }
        }
        SpinWait sw = cli::ctor<SpinWait>();
        while(!(this->processed)) sw->SpinOnce();
    }
    
    CancellationToken CancellationTokenSource::get_Token() {
        CheckDisposed();
        return cli::ctor<CancellationToken>(this);
    }
    
    bool CancellationTokenSource::get_IsCancellationRequested() {
        return this->canceled;
    }
    
    WaitHandle* CancellationTokenSource::get_WaitHandle() {
        CheckDisposed();
        return this->handle;
    }
    
}}
namespace System { namespace Threading {
    
    
    void CompressedStack::constructor(int32_t length) {
        if((length > 0)) 
        {
            this->_list = cli::gcnew<System::Collections::ArrayList>(length);
        }
    }
    
    void CompressedStack::constructor(CompressedStack* cs) {
        if(((cs != nullptr) && (cs->_list != nullptr))) 
        {
            this->_list = cli::cast<System::Collections::ArrayList*>(cs->_list->Clone_5d610374e21ea7b0());
        }
    }
    
    CompressedStack* CompressedStack::CreateCopy() {
        return cli::gcnew<CompressedStack>(this);
    }
    
    CompressedStack* CompressedStack::Capture() {
        CompressedStack *cs = cli::gcnew<CompressedStack>(0);
        cs->_list = System::Security::SecurityFrame::GetStack(1);
        CompressedStack *currentCs = Thread::get_CurrentThread()->GetCompressedStack();
        if((currentCs != nullptr)) 
        {
            for(int32_t i = 0; (i < currentCs->_list->get_Count_2354963792616712()); i++) {
                cs->_list->Add_e6a92085999ce388(currentCs->_list->get_Item_fd0155f142ae570(i));
            }
        }
        return cs;
    }
    
    CompressedStack* CompressedStack::GetCompressedStack() {
        CompressedStack *cs = Thread::get_CurrentThread()->GetCompressedStack();
        if((cs ==  nullptr)) 
        {
            cs = CompressedStack::Capture();
        }
         else 
        {
            CompressedStack *newstack = CompressedStack::Capture();
            for(int32_t i = 0; (i < newstack->_list->get_Count_2354963792616712()); i++) {
                cs->_list->Add_e6a92085999ce388(newstack->_list->get_Item_fd0155f142ae570(i));
            }
        }
        return cs;
    }
    
    void CompressedStack::GetObjectData(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        if((info ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("info"));
        }
    }
    
    void CompressedStack::Run(CompressedStack* compressedStack, ContextCallback* callback, System::Object* state) {
        if((compressedStack ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("compressedStack"));
        }
        Thread *t = Thread::get_CurrentThread();
        CompressedStack *original = nullptr;
        {
            cli::finally_guard([&]() {
                if((original != nullptr)) 
                {
                    t->SetCompressedStack(original);
                }
            });
            original = t->GetCompressedStack();
            t->SetCompressedStack(compressedStack);
            callback->Invoke(state);
        }
    }
    
    bool CompressedStack::Equals3(CompressedStack* cs) {
        if(IsEmpty()) 
        {
            return cs->IsEmpty();
        }
        if(cs->IsEmpty()) 
        {
            return false;
        }
        if((this->_list->get_Count_2354963792616712() != cs->_list->get_Count_2354963792616712())) 
        {
            return false;
        }
        for(int32_t i = 0; (i < this->_list->get_Count_2354963792616712()); i++){
            System::Security::SecurityFrame sf1 = cli::unbox<System::Security::SecurityFrame>(this->_list->get_Item_fd0155f142ae570(i));
            System::Security::SecurityFrame sf2 = cli::unbox<System::Security::SecurityFrame>(cs->_list->get_Item_fd0155f142ae570(i));
            if(!(sf1->Equals(sf2))) 
            {
                return false;
            }
        }
        return true;
    }
    
    bool CompressedStack::IsEmpty() {
        return ((this->_list ==  nullptr) || (this->_list->get_Count_2354963792616712() ==  0));
    }
    
    System::Collections::IList* CompressedStack::get_List() {
        return this->_list;
    }
    
}}
namespace System { namespace Threading {
    
    
    void CountdownEvent::constructor(int32_t initialCount) {
        if((initialCount < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("initialCount"));
        }
        this->evt = cli::gcnew<ManualResetEventSlim>((initialCount ==  0));
        this->initial = this->initialCount = initialCount;
    }
    
    bool CountdownEvent::Signal() {
        return Signal2(1);
    }
    
    bool CountdownEvent::Signal2(int32_t signalCount) {
        if((signalCount <= 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("signalCount"));
        }
        CheckDisposed();
        int32_t newValue;
        if(!(ApplyOperation(-(signalCount), newValue))) 
        {
            throw cli::gcnew<System::InvalidOperationException>(_T("The event is already set"));
        }
        if((newValue ==  0)) 
        {
            this->evt->Set();
            return true;
        }
        return false;
    }
    
    void CountdownEvent::AddCount() {
        AddCount2(1);
    }
    
    void CountdownEvent::AddCount2(int32_t signalCount) {
        if(!(TryAddCount2(signalCount))) 
        {
            throw cli::gcnew<System::InvalidOperationException>(_T("The event is already signaled and cannot be incremented"));
        }
    }
    
    bool CountdownEvent::TryAddCount() {
        return TryAddCount2(1);
    }
    
    bool CountdownEvent::TryAddCount2(int32_t signalCount) {
        if((signalCount <= 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("signalCount"));
        }
        CheckDisposed();
        int32_t temp;
        return ApplyOperation(signalCount, temp);
    }
    
    bool CountdownEvent::ApplyOperation(int32_t num, int32_t newValue) {
        int32_t oldCount;
        do {
            oldCount = this->initialCount;
            if((oldCount ==  0)) 
            {
                newValue = 0;
                return false;
            }
            newValue = (oldCount + num);
            if((newValue < 0)) 
            {
                return false;
            }
        }
        while((Interlocked::CompareExchange(this->initialCount, newValue, oldCount) != oldCount));
        return true;
    }
    
    void CountdownEvent::Wait() {
        this->evt->Wait();
    }
    
    void CountdownEvent::Wait2(CancellationToken cancellationToken) {
        this->evt->Wait4(cancellationToken);
    }
    
    bool CountdownEvent::Wait3(int32_t millisecondsTimeout) {
        return this->evt->Wait2(millisecondsTimeout);
    }
    
    bool CountdownEvent::Wait4(System::TimeSpan timeout) {
        return this->evt->Wait3(timeout);
    }
    
    bool CountdownEvent::Wait5(int32_t millisecondsTimeout, CancellationToken cancellationToken) {
        return this->evt->Wait5(millisecondsTimeout, cancellationToken);
    }
    
    bool CountdownEvent::Wait6(System::TimeSpan timeout, CancellationToken cancellationToken) {
        return this->evt->Wait6(timeout, cancellationToken);
    }
    
    void CountdownEvent::Reset() {
        Reset2(this->initial);
    }
    
    void CountdownEvent::Reset2(int32_t count) {
        if((count < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("count"));
        }
        CheckDisposed();
        this->initialCount = this->initial = count;
        if((count ==  0)) 
        {
            this->evt->Set();
        }
         else 
        {
            this->evt->Reset();
        }
    }
    
    void CountdownEvent::Dispose() {
        Dispose_dcb0f063dfdb5223(true);
    }
    
    void CountdownEvent::Dispose_dcb0f063dfdb5223(bool disposing) {
        if(disposing) 
        {
            this->evt->Dispose();
        }
    }
    
    void CountdownEvent::CheckDisposed() {
        if(this->evt->disposed->get_Value()) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("CountdownEvent"));
        }
    }
    
    int32_t CountdownEvent::get_CurrentCount() {
        return this->initialCount;
    }
    
    int32_t CountdownEvent::get_InitialCount() {
        return this->initial;
    }
    
    bool CountdownEvent::get_IsSet() {
        return (this->initialCount ==  0);
    }
    
    WaitHandle* CountdownEvent::get_WaitHandle() {
        return this->evt->get_WaitHandle();
    }
    
}}
namespace System { namespace Threading {
    
    
    void EventWaitHandle::constructor(void* handle) {
        this->set_Handle_880f68f3ace4e24(handle);
    }
    
    void EventWaitHandle::constructor(bool initialState, EventResetMode mode) {
        bool created;
        bool manual = IsManualReset(mode);
        this->set_Handle_880f68f3ace4e24(NativeEventCalls::CreateEvent_internal(manual, initialState, nullptr, created));
    }
    
    void EventWaitHandle::constructor(bool initialState, EventResetMode mode, System::String* name) {
        bool created;
        bool manual = IsManualReset(mode);
        this->set_Handle_880f68f3ace4e24(NativeEventCalls::CreateEvent_internal(manual, initialState, name, created));
    }
    
    void EventWaitHandle::constructor(bool initialState, EventResetMode mode, System::String* name, bool createdNew) {
        bool manual = IsManualReset(mode);
        this->set_Handle_880f68f3ace4e24(NativeEventCalls::CreateEvent_internal(manual, initialState, name, createdNew));
    }
    
    void EventWaitHandle::constructor(bool initialState, EventResetMode mode, System::String* name, bool createdNew, System::Security::AccessControl::EventWaitHandleSecurity* eventSecurity) {
        bool manual = IsManualReset(mode);
        this->set_Handle_880f68f3ace4e24(NativeEventCalls::CreateEvent_internal(manual, initialState, name, createdNew));
    }
    
    bool EventWaitHandle::IsManualReset(EventResetMode mode) {
        if((((int32_t)(mode) < 0) || ((int32_t)(mode) > 1))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("mode"));
        }
        return ((int32_t)(mode) ==  1);
    }
    
    System::Security::AccessControl::EventWaitHandleSecurity* EventWaitHandle::GetAccessControl() {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    EventWaitHandle* EventWaitHandle::OpenExisting(System::String* name) {
        return OpenExisting2(name, (System::Security::AccessControl::EventWaitHandleRights)1048578L);
    }
    
    EventWaitHandle* EventWaitHandle::OpenExisting2(System::String* name, System::Security::AccessControl::EventWaitHandleRights rights) {
        if((name ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("name"));
        }
        if(((name->get_Length() ==  0) || (name->get_Length() > 260))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("name"), Locale::GetText(_T("Invalid length [1-260].")));
        }
        System::IO::MonoIOError error;
        void *handle = NativeEventCalls::OpenEvent_internal(name, rights, error);
        if(::System::IntPtr::op_Equality(handle, (void*)nullptr)) 
        {
            if(((int32_t)(error) ==  2)) 
            {
                throw cli::gcnew<WaitHandleCannotBeOpenedException>(cli::concat(Locale::GetText(_T("Named Event handle does not exist: ")), name));
            }
             else 
            {
                if(((int32_t)(error) ==  5)) 
                {
                    throw cli::gcnew<System::UnauthorizedAccessException>();
                }
                 else 
                {
                    throw cli::gcnew<System::IO::IOException>(cli::concat(Locale::GetText(_T("Win32 IO error: ")), cli::import(error)->ToString_1636a0751cb9ac11()));
                }
            }
        }
        return cli::gcnew<EventWaitHandle>(handle);
    }
    
    bool EventWaitHandle::Reset() {
        {
            cli::lock_guard{this};
            WaitHandle::CheckDisposed();
            return NativeEventCalls::ResetEvent_internal(this->get_Handle_95175e197a1d983a());
        }
    }
    
    bool EventWaitHandle::Set() {
        {
            cli::lock_guard{this};
            WaitHandle::CheckDisposed();
            return NativeEventCalls::SetEvent_internal(this->get_Handle_95175e197a1d983a());
        }
    }
    
    void EventWaitHandle::SetAccessControl(System::Security::AccessControl::EventWaitHandleSecurity* eventSecurity) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
}}
namespace System { namespace Threading {
    
    
    void ExecutionContext::constructor() {
    }
    
    void ExecutionContext::constructor(ExecutionContext* ec) {
        if((ec->_sc != nullptr)) 
        {
            this->_sc = cli::gcnew<System::Security::SecurityContext>(ec->_sc);
        }
        this->_suppressFlow = ec->_suppressFlow;
        this->_capture = true;
    }
    
    void ExecutionContext::constructor(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    ExecutionContext* ExecutionContext::Capture() {
        ExecutionContext *ec = Thread::get_CurrentThread()->get_ExecutionContext();
        if(ec->get_FlowSuppressed()) 
        {
            return nullptr;
        }
        ExecutionContext *capture = cli::gcnew<ExecutionContext>(ec);
        if(System::Security::SecurityManager::get_SecurityEnabled()) 
        {
            capture->set_SecurityContext(System::Security::SecurityContext::Capture());
        }
        return capture;
    }
    
    ExecutionContext* ExecutionContext::CreateCopy() {
        if(!(this->_capture)) 
        {
            throw cli::gcnew<System::InvalidOperationException>();
        }
        return cli::gcnew<ExecutionContext>(this);
    }
    
    void ExecutionContext::Dispose() {
        if((this->_sc != nullptr)) 
        {
            this->_sc->Dispose();
        }
    }
    
    void ExecutionContext::GetObjectData(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
        if((info ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("info"));
        }
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool ExecutionContext::IsFlowSuppressed() {
        return Thread::get_CurrentThread()->get_ExecutionContext()->get_FlowSuppressed();
    }
    
    void ExecutionContext::RestoreFlow() {
        ExecutionContext *ec = Thread::get_CurrentThread()->get_ExecutionContext();
        if(!(ec->get_FlowSuppressed())) 
        {
            throw cli::gcnew<System::InvalidOperationException>();
        }
        ec->set_FlowSuppressed(false);
    }
    
    void ExecutionContext::Run(ExecutionContext* executionContext, ContextCallback* callback, System::Object* state) {
        if((executionContext ==  nullptr)) 
        {
            throw cli::gcnew<System::InvalidOperationException>(Locale::GetText(_T("Null ExecutionContext")));
        }
        System::Security::SecurityContext::Run(executionContext->get_SecurityContext(), callback, state);
    }
    
    AsyncFlowControl ExecutionContext::SuppressFlow() {
        Thread *t = Thread::get_CurrentThread();
        t->get_ExecutionContext()->set_FlowSuppressed(true);
        return cli::ctor<AsyncFlowControl>(t, AsyncFlowControlType::Execution);
    }
    
    System::Security::SecurityContext* ExecutionContext::get_SecurityContext() {
        if((this->_sc ==  nullptr)) 
        {
            this->_sc = cli::gcnew<System::Security::SecurityContext>();
        }
        return this->_sc;
    }
    
    System::Security::SecurityContext* ExecutionContext::set_SecurityContext(System::Security::SecurityContext* value) {
        this->_sc = value;
        return get_SecurityContext();
    }
    
    bool ExecutionContext::get_FlowSuppressed() {
        return this->_suppressFlow;
    }
    
    bool ExecutionContext::set_FlowSuppressed(bool value) {
        this->_suppressFlow = value;
        return get_FlowSuppressed();
    }
    
}}
namespace System { namespace Threading {
    
    
    void HostExecutionContext::constructor() {
        this->_state = nullptr;
    }
    
    void HostExecutionContext::constructor(System::Object* state) {
        this->_state = state;
    }
    
    HostExecutionContext* HostExecutionContext::CreateCopy_5e84bdc43bfd8024() {
        return cli::gcnew<HostExecutionContext>(this->_state);
    }
    
    System::Object* HostExecutionContext::get_State() {
        return this->_state;
    }
    
    System::Object* HostExecutionContext::set_State(System::Object* value) {
        this->_state = value;
        return get_State();
    }
    
}}
namespace System { namespace Threading {
    
    
    void HostExecutionContextManager::constructor() {
    }
    
    HostExecutionContext* HostExecutionContextManager::Capture_fdab1ba018894683() {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    void HostExecutionContextManager::Revert_3f40d56dc63ed70e(System::Object* previousState) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    System::Object* HostExecutionContextManager::SetHostExecutionContext_2a556375f18d95c8(HostExecutionContext* hostExecutionContext) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
}}
namespace System { namespace Threading {
    
    
    int32_t Interlocked::CompareExchange(int32_t location1, int32_t value, int32_t comparand) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    System::Object* Interlocked::CompareExchange2(System::Object* location1, System::Object* value, System::Object* comparand) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    float Interlocked::CompareExchange3(float location1, float value, float comparand) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t Interlocked::Decrement(int32_t location) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int64_t Interlocked::Decrement2(int64_t location) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t Interlocked::Increment(int32_t location) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int64_t Interlocked::Increment2(int64_t location) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t Interlocked::Exchange(int32_t location1, int32_t value) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    System::Object* Interlocked::Exchange2(System::Object* location1, System::Object* value) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    float Interlocked::Exchange3(float location1, float value) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int64_t Interlocked::CompareExchange4(int64_t location1, int64_t value, int64_t comparand) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void* Interlocked::CompareExchange5(void* location1, void* value, void* comparand) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    double Interlocked::CompareExchange6(double location1, double value, double comparand) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int64_t Interlocked::Exchange4(int64_t location1, int64_t value) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void* Interlocked::Exchange5(void* location1, void* value) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    double Interlocked::Exchange6(double location1, double value) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int64_t Interlocked::Read(int64_t location) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t Interlocked::Add(int32_t location1, int32_t value) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int64_t Interlocked::Add2(int64_t location1, int64_t value) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
}}
namespace System { namespace Threading {
    
    
}}
namespace System { namespace Threading {
    
    
    void LockQueue::constructor(ReaderWriterLock* rwlock) {
        this->rwlock = rwlock;
    }
    
    bool LockQueue::Wait(int32_t timeout) {
        bool _lock = false;
        {
            cli::finally_guard([&]() {
                if(_lock) 
                {
                    Monitor::Enter(this->rwlock);
                    this->lockCount--;
                }
            });
            {
                cli::lock_guard{this};
                this->lockCount++;
                Monitor::Exit(this->rwlock);
                _lock = true;
                return Monitor::Wait2(this, timeout);
            }
        }
    }
    
    void LockQueue::Pulse() {
        cli::lock_guard{this};
        {
            Monitor::Pulse(this);
        }
    }
    
    bool LockQueue::get_IsEmpty() {
        cli::lock_guard{this};
        {
            return (this->lockCount ==  0);
        }
    }
    
}}
namespace System { namespace Threading {
    
    
    void LockRecursionException::constructor() {
    }
    
    void LockRecursionException::constructor(System::String* message) {
    }
    
    void LockRecursionException::constructor(System::String* message, System::Exception* innerException) {
    }
    
    void LockRecursionException::constructor(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
    }
    
}}
namespace System { namespace Threading {
    
    
    void ManualResetEvent::constructor(bool initialState) {
    }
    
}}
namespace System { namespace Threading {
    
    
    void ManualResetEventSlim::constructor() {
    }
    
    void ManualResetEventSlim::constructor(bool initialState) {
    }
    
    void ManualResetEventSlim::constructor(bool initialState, int32_t spinCount) {
        if(((spinCount < 0) || (spinCount > 2047))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("spinCount"));
        }
        this->set = initialState;
        this->spinCount = spinCount;
    }
    
    void ManualResetEventSlim::Reset() {
        ThrowIfDisposed();
        this->set = false;
        Thread::MemoryBarrier();
        if((this->handle != nullptr)) 
        {
            this->used = true;
            Thread::MemoryBarrier();
            ManualResetEvent *tmpHandle = this->handle;
            if((tmpHandle != nullptr)) 
            {
                tmpHandle->Reset();
            }
            Thread::MemoryBarrier();
            this->used = false;
        }
    }
    
    void ManualResetEventSlim::Set() {
        this->set = true;
        Thread::MemoryBarrier();
        if((this->handle != nullptr)) 
        {
            this->used = true;
            Thread::MemoryBarrier();
            ManualResetEvent *tmpHandle = this->handle;
            if((tmpHandle != nullptr)) 
            {
                tmpHandle->Set();
            }
            Thread::MemoryBarrier();
            this->used = false;
        }
    }
    
    void ManualResetEventSlim::Wait() {
        Wait4(CancellationToken::get_None());
    }
    
    bool ManualResetEventSlim::Wait2(int32_t millisecondsTimeout) {
        return Wait5(millisecondsTimeout, CancellationToken::get_None());
    }
    
    bool ManualResetEventSlim::Wait3(System::TimeSpan timeout) {
        return Wait5(CheckTimeout(timeout), CancellationToken::get_None());
    }
    
    void ManualResetEventSlim::Wait4(CancellationToken cancellationToken) {
        Wait5(-1, cancellationToken);
    }
    
    bool ManualResetEventSlim::Wait5(int32_t millisecondsTimeout, CancellationToken cancellationToken) {
        if((millisecondsTimeout < -1)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("millisecondsTimeout"));
        }
        ThrowIfDisposed();
        if(!(this->set)) 
        {
            SpinWait wait = cli::ctor<SpinWait>();
            while(!(this->set)) {
                cancellationToken->ThrowIfCancellationRequested();
                if((wait->get_Count() < this->spinCount)) 
                {
                    wait->SpinOnce();
                    continue;
                }
                break;
            }
            if(this->set) 
            {
                return true;
            }
            WaitHandle *handle = this->get_WaitHandle();
            if(cancellationToken->get_CanBeCanceled()) 
            {
                if((WaitHandle::WaitAny2((new cli::array<WaitHandle*>({handle, cancellationToken->get_WaitHandle()})), millisecondsTimeout, false) ==  0)) 
                {
                    return false;
                }
                cancellationToken->ThrowIfCancellationRequested();
            }
             else 
            {
                if(!(handle->WaitOne_dfdecf18d16bd99(millisecondsTimeout, false))) 
                {
                    return false;
                }
            }
        }
        return true;
    }
    
    bool ManualResetEventSlim::Wait6(System::TimeSpan timeout, CancellationToken cancellationToken) {
        return Wait5(CheckTimeout(timeout), cancellationToken);
    }
    
    void ManualResetEventSlim::Dispose() {
        Dispose_4992834dce417895(true);
    }
    
    void ManualResetEventSlim::Dispose_4992834dce417895(bool disposing) {
        if(!(this->disposed->TryRelaxedSet())) 
        {
            return;
        }
        if((this->handle != nullptr)) 
        {
            ManualResetEvent *tmpHandle = Interlocked::template Exchange_1<ManualResetEvent*>(this->handle, nullptr);
            if(this->used) 
            {
                SpinWait wait = cli::ctor<SpinWait>();
                while(this->used) wait->SpinOnce();
            }
            tmpHandle->Dispose();
        }
    }
    
    void ManualResetEventSlim::ThrowIfDisposed() {
        if(this->disposed->get_Value()) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("ManualResetEventSlim"));
        }
    }
    
    int32_t ManualResetEventSlim::CheckTimeout(System::TimeSpan timeout) {
        try {
            return cli::checked((int32_t)timeout->get_TotalMilliseconds());
        }
        catch(System::OverflowException*) {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("timeout"));
        }
    }
    
    bool ManualResetEventSlim::get_IsSet() {
        return this->set;
    }
    
    int32_t ManualResetEventSlim::get_SpinCount() {
        return this->spinCount;
    }
    
    WaitHandle* ManualResetEventSlim::get_WaitHandle() {
        ThrowIfDisposed();
        if((this->handle != nullptr)) 
        {
            return this->handle;
        }
        bool isSet = this->set;
        ManualResetEvent *mre = cli::gcnew<ManualResetEvent>(isSet);
        if((Interlocked::template CompareExchange_1<ManualResetEvent*>(this->handle, mre, nullptr) ==  nullptr)) 
        {
            if((isSet != this->set)) 
            {
                if(this->set) 
                {
                    mre->Set();
                }
                 else 
                {
                    mre->Reset();
                }
            }
        }
         else 
        {
            mre->Dispose();
        }
        return this->handle;
    }
    
}}
namespace System { namespace Threading {
    
    
    bool Monitor::Monitor_try_enter(System::Object* obj, int32_t ms) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Monitor::Enter(System::Object* obj) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Monitor::Exit(System::Object* obj) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Monitor::Monitor_pulse(System::Object* obj) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool Monitor::Monitor_test_synchronised(System::Object* obj) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Monitor::Pulse(System::Object* obj) {
        if((obj ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("obj"));
        }
        if((Monitor_test_synchronised(obj) ==  false)) 
        {
            throw cli::gcnew<SynchronizationLockException>(_T("Object is not synchronized"));
        }
        Monitor_pulse(obj);
    }
    
    void Monitor::Monitor_pulse_all(System::Object* obj) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Monitor::PulseAll(System::Object* obj) {
        if((obj ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("obj"));
        }
        if((Monitor_test_synchronised(obj) ==  false)) 
        {
            throw cli::gcnew<SynchronizationLockException>(_T("Object is not synchronized"));
        }
        Monitor_pulse_all(obj);
    }
    
    bool Monitor::TryEnter(System::Object* obj) {
        return TryEnter2(obj, 0);
    }
    
    bool Monitor::TryEnter2(System::Object* obj, int32_t millisecondsTimeout) {
        if((obj ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("obj"));
        }
        if((millisecondsTimeout ==  -1)) 
        {
            Enter(obj);
            return true;
        }
        if((millisecondsTimeout < 0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("negative value for millisecondsTimeout"), _T("millisecondsTimeout"));
        }
        return Monitor_try_enter(obj, millisecondsTimeout);
    }
    
    bool Monitor::TryEnter3(System::Object* obj, System::TimeSpan timeout) {
        int64_t ms = (int64_t)timeout->get_TotalMilliseconds();
        if(((ms < -1L) || (ms > 2147483647L))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("timeout"), _T("timeout out of range"));
        }
        return TryEnter2(obj, (int32_t)ms);
    }
    
    bool Monitor::Monitor_wait(System::Object* obj, int32_t ms) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool Monitor::Wait(System::Object* obj) {
        return Wait2(obj, -1);
    }
    
    bool Monitor::Wait2(System::Object* obj, int32_t millisecondsTimeout) {
        if((obj ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("obj"));
        }
        if((millisecondsTimeout < -1)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("millisecondsTimeout"), _T("timeout out of range"));
        }
        if(!(Monitor_test_synchronised(obj))) 
        {
            throw cli::gcnew<SynchronizationLockException>(_T("Object is not synchronized"));
        }
        return Monitor_wait(obj, millisecondsTimeout);
    }
    
    bool Monitor::Wait3(System::Object* obj, System::TimeSpan timeout) {
        int64_t ms = (int64_t)timeout->get_TotalMilliseconds();
        if(((ms < -1L) || (ms > 2147483647L))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("timeout"), _T("timeout out of range"));
        }
        return Wait2(obj, (int32_t)ms);
    }
    
    bool Monitor::Wait4(System::Object* obj, int32_t millisecondsTimeout, bool exitContext) {
        {
            cli::finally_guard([&]() {
                if(exitContext) 
                {
                    System::Runtime::Remoting::Contexts::SynchronizationAttribute::EnterContext();
                }
            });
            if(exitContext) 
            {
                System::Runtime::Remoting::Contexts::SynchronizationAttribute::ExitContext();
            }
            return Wait2(obj, millisecondsTimeout);
        }
    }
    
    bool Monitor::Wait5(System::Object* obj, System::TimeSpan timeout, bool exitContext) {
        {
            cli::finally_guard([&]() {
                if(exitContext) 
                {
                    System::Runtime::Remoting::Contexts::SynchronizationAttribute::EnterContext();
                }
            });
            if(exitContext) 
            {
                System::Runtime::Remoting::Contexts::SynchronizationAttribute::ExitContext();
            }
            return Wait3(obj, timeout);
        }
    }
    
    void Monitor::try_enter_with_atomic_var(System::Object* obj, int32_t millisecondsTimeout, bool lockTaken) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Monitor::Enter2(System::Object* obj, bool lockTaken) {
        TryEnter6(obj, -1, lockTaken);
    }
    
    void Monitor::TryEnter4(System::Object* obj, bool lockTaken) {
        TryEnter6(obj, 0, lockTaken);
    }
    
    void Monitor::TryEnter5(System::Object* obj, System::TimeSpan timeout, bool lockTaken) {
        int64_t ms = (int64_t)timeout->get_TotalMilliseconds();
        if(((ms < -1L) || (ms > 2147483647L))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("timeout"), _T("timeout out of range"));
        }
        TryEnter6(obj, (int32_t)ms, lockTaken);
    }
    
    void Monitor::TryEnter6(System::Object* obj, int32_t millisecondsTimeout, bool lockTaken) {
        if((obj ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("obj"));
        }
        if(lockTaken) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("lockTaken"));
        }
        if(((millisecondsTimeout < 0) && (millisecondsTimeout != -1))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("negative value for millisecondsTimeout"), _T("millisecondsTimeout"));
        }
        try_enter_with_atomic_var(obj, millisecondsTimeout, lockTaken);
    }
    
}}
namespace System { namespace Threading {
    
    
    void Mutex::constructor(void* handle) {
        this->set_Handle_880f68f3ace4e24(handle);
    }
    
    void Mutex::constructor() {
        bool created;
        this->set_Handle_880f68f3ace4e24(CreateMutex_internal(false, nullptr, created));
    }
    
    void Mutex::constructor(bool initiallyOwned) {
        bool created;
        this->set_Handle_880f68f3ace4e24(CreateMutex_internal(initiallyOwned, nullptr, created));
    }
    
    void Mutex::constructor(bool initiallyOwned, System::String* name) {
        bool created;
        this->set_Handle_880f68f3ace4e24(CreateMutex_internal(initiallyOwned, name, created));
    }
    
    void Mutex::constructor(bool initiallyOwned, System::String* name, bool createdNew) {
        this->set_Handle_880f68f3ace4e24(CreateMutex_internal(initiallyOwned, name, createdNew));
    }
    
    void Mutex::constructor(bool initiallyOwned, System::String* name, bool createdNew, System::Security::AccessControl::MutexSecurity* mutexSecurity) {
        this->set_Handle_880f68f3ace4e24(CreateMutex_internal(initiallyOwned, name, createdNew));
    }
    
    void* Mutex::CreateMutex_internal(bool initiallyOwned, System::String* name, bool created) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool Mutex::ReleaseMutex_internal(void* handle) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void* Mutex::OpenMutex_internal(System::String* name, System::Security::AccessControl::MutexRights rights, System::IO::MonoIOError error) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    System::Security::AccessControl::MutexSecurity* Mutex::GetAccessControl() {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    Mutex* Mutex::OpenExisting(System::String* name) {
        return OpenExisting2(name, (System::Security::AccessControl::MutexRights)1048577L);
    }
    
    Mutex* Mutex::OpenExisting2(System::String* name, System::Security::AccessControl::MutexRights rights) {
        if((name ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("name"));
        }
        if(((name->get_Length() ==  0) || (name->get_Length() > 260))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("name"), Locale::GetText(_T("Invalid length [1-260].")));
        }
        System::IO::MonoIOError error;
        void *handle = OpenMutex_internal(name, rights, error);
        if(::System::IntPtr::op_Equality(handle, (void*)nullptr)) 
        {
            if(((int32_t)(error) ==  2)) 
            {
                throw cli::gcnew<WaitHandleCannotBeOpenedException>(cli::concat(Locale::GetText(_T("Named Mutex handle does not exist: ")), name));
            }
             else 
            {
                if(((int32_t)(error) ==  5)) 
                {
                    throw cli::gcnew<System::UnauthorizedAccessException>();
                }
                 else 
                {
                    throw cli::gcnew<System::IO::IOException>(cli::concat(Locale::GetText(_T("Win32 IO error: ")), cli::import(error)->ToString_1636a0751cb9ac11()));
                }
            }
        }
        return cli::gcnew<Mutex>(handle);
    }
    
    void Mutex::ReleaseMutex() {
        bool success = ReleaseMutex_internal(this->get_Handle_95175e197a1d983a());
        if(!(success)) 
        {
            throw cli::gcnew<System::ApplicationException>(_T("Mutex is not owned"));
        }
    }
    
    void Mutex::SetAccessControl(System::Security::AccessControl::MutexSecurity* mutexSecurity) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
}}
namespace System { namespace Threading {
    
    
    void* NativeEventCalls::CreateEvent_internal(bool manual, bool initial, System::String* name, bool created) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool NativeEventCalls::SetEvent_internal(void* handle) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool NativeEventCalls::ResetEvent_internal(void* handle) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void NativeEventCalls::CloseEvent_internal(void* handle) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void* NativeEventCalls::OpenEvent_internal(System::String* name, System::Security::AccessControl::EventWaitHandleRights rights, System::IO::MonoIOError error) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
}}
namespace System { namespace Threading {
    
    
    void Overlapped::constructor() {
    }
    
    void Overlapped::constructor(int32_t offsetLo, int32_t offsetHi, int32_t hEvent, System::IAsyncResult* ar) {
        this->offsetL = offsetLo;
        this->offsetH = offsetHi;
        this->evt = hEvent;
        this->ares = ar;
    }
    
    void Overlapped::constructor(int32_t offsetLo, int32_t offsetHi, void* hEvent, System::IAsyncResult* ar) {
        this->offsetL = offsetLo;
        this->offsetH = offsetHi;
        this->evt_ptr = hEvent;
        this->ares = ar;
    }
    
    void Overlapped::Free(NativeOverlapped* nativeOverlappedPtr) {
        if(::System::IntPtr::op_Equality((void*)(void*)(nativeOverlappedPtr), (*::System::IntPtr::Zero))) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("nativeOverlappedPtr"));
        }
        System::Runtime::InteropServices::Marshal::FreeHGlobal((void*)(void*)(nativeOverlappedPtr));
    }
    
    Overlapped* Overlapped::Unpack(NativeOverlapped* nativeOverlappedPtr) {
        if(::System::IntPtr::op_Equality((void*)(void*)(nativeOverlappedPtr), (*::System::IntPtr::Zero))) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("nativeOverlappedPtr"));
        }
        Overlapped *result = cli::gcnew<Overlapped>();
        result->offsetL = (*nativeOverlappedPtr)->OffsetLow;
        result->offsetH = (*nativeOverlappedPtr)->OffsetHigh;
        result->evt = (int32_t)(*nativeOverlappedPtr)->EventHandle;
        return result;
    }
    
    NativeOverlapped* Overlapped::Pack(IOCompletionCallback* iocb) {
        NativeOverlapped *result = (NativeOverlapped*)((void*)System::Runtime::InteropServices::Marshal::AllocHGlobal2(System::Runtime::InteropServices::Marshal::SizeOf2(cli::typeof<System::Type>::info)));
        (*result)->OffsetLow = this->offsetL;
        (*result)->OffsetHigh = this->offsetH;
        (*result)->EventHandle = (void*)this->evt;
        return result;
    }
    
    NativeOverlapped* Overlapped::Pack2(IOCompletionCallback* iocb, System::Object* userData) {
        NativeOverlapped *result = (NativeOverlapped*)((void*)System::Runtime::InteropServices::Marshal::AllocHGlobal2(System::Runtime::InteropServices::Marshal::SizeOf2(cli::typeof<System::Type>::info)));
        (*result)->OffsetLow = this->offsetL;
        (*result)->OffsetHigh = this->offsetH;
        (*result)->EventHandle = this->evt_ptr;
        return result;
    }
    
    NativeOverlapped* Overlapped::UnsafePack(IOCompletionCallback* iocb) {
        return Pack(iocb);
    }
    
    NativeOverlapped* Overlapped::UnsafePack2(IOCompletionCallback* iocb, System::Object* userData) {
        return Pack2(iocb, userData);
    }
    
    System::IAsyncResult* Overlapped::get_AsyncResult() {
        return this->ares;
    }
    
    System::IAsyncResult* Overlapped::set_AsyncResult(System::IAsyncResult* value) {
        this->ares = value;
        return get_AsyncResult();
    }
    
    int32_t Overlapped::get_EventHandle() {
        return this->evt;
    }
    
    int32_t Overlapped::set_EventHandle(int32_t value) {
        this->evt = value;
        return get_EventHandle();
    }
    
    void* Overlapped::get_EventHandleIntPtr() {
        return this->evt_ptr;
    }
    
    void* Overlapped::set_EventHandleIntPtr(void* value) {
        this->evt_ptr = value;
        return get_EventHandleIntPtr();
    }
    
    int32_t Overlapped::get_OffsetHigh() {
        return this->offsetH;
    }
    
    int32_t Overlapped::set_OffsetHigh(int32_t value) {
        this->offsetH = value;
        return get_OffsetHigh();
    }
    
    int32_t Overlapped::get_OffsetLow() {
        return this->offsetL;
    }
    
    int32_t Overlapped::set_OffsetLow(int32_t value) {
        this->offsetL = value;
        return get_OffsetLow();
    }
    
}}
namespace System { namespace Threading {
    
    
    void ReaderWriterLock::constructor() {
        this->writer_queue = cli::gcnew<LockQueue>(this);
        this->reader_locks = cli::gcnew<System::Collections::Hashtable>();
        System::GC::SuppressFinalize(this);
    }
    
    void ReaderWriterLock::Finalize_59e583210c385b65() {
        {
            cli::finally_guard([&]() {
                Finalize_194ea81baa80af66();
            });
        }
    }
    
    void ReaderWriterLock::AcquireReaderLock(int32_t millisecondsTimeout) {
        AcquireReaderLock2(millisecondsTimeout, 1);
    }
    
    void ReaderWriterLock::AcquireReaderLock2(int32_t millisecondsTimeout, int32_t initialLockCount) {
        {
            cli::lock_guard{this};
            if(HasWriterLock()) 
            {
                AcquireWriterLock2(millisecondsTimeout, initialLockCount);
                return;
            }
            System::Object *nlocks = this->reader_locks->get_Item_d75c6e706b965758(cli::box(Thread::get_CurrentThreadId()));
            if((nlocks ==  nullptr)) 
            {
                this->readers++;
                {
                    cli::finally_guard([&]() {
                        this->readers--;
                    });
                    if(((this->state < 0) || !(this->writer_queue->get_IsEmpty()))) 
                    {
                        do {
                            if(!(Monitor::Wait2(this, millisecondsTimeout))) 
                            {
                                throw cli::gcnew<System::ApplicationException>(_T("Timeout expired"));
                            }
                        }
                        while((this->state < 0));
                    }
                }
                this->reader_locks->set_Item_84c7e24d9caa09(cli::box(Thread::get_CurrentThreadId()), cli::box(initialLockCount));
                (this->state = this->state + initialLockCount);
            }
             else 
            {
                this->reader_locks->set_Item_84c7e24d9caa09(cli::box(Thread::get_CurrentThreadId()), cli::box((cli::unbox<int32_t>(nlocks) + 1)));
                this->state++;
            }
        }
    }
    
    void ReaderWriterLock::AcquireReaderLock3(System::TimeSpan timeout) {
        int32_t ms = CheckTimeout(timeout);
        AcquireReaderLock2(ms, 1);
    }
    
    void ReaderWriterLock::AcquireWriterLock(int32_t millisecondsTimeout) {
        AcquireWriterLock2(millisecondsTimeout, 1);
    }
    
    void ReaderWriterLock::AcquireWriterLock2(int32_t millisecondsTimeout, int32_t initialLockCount) {
        {
            cli::lock_guard{this};
            if(HasWriterLock()) 
            {
                this->state--;
                return;
            }
            if(((this->state != 0) || !(this->writer_queue->get_IsEmpty()))) 
            {
                do {
                    if(!(this->writer_queue->Wait(millisecondsTimeout))) 
                    {
                        throw cli::gcnew<System::ApplicationException>(_T("Timeout expired"));
                    }
                }
                while((this->state != 0));
            }
            this->state = -(initialLockCount);
            this->writer_lock_owner = Thread::get_CurrentThreadId();
            this->seq_num++;
        }
    }
    
    void ReaderWriterLock::AcquireWriterLock3(System::TimeSpan timeout) {
        int32_t ms = CheckTimeout(timeout);
        AcquireWriterLock2(ms, 1);
    }
    
    bool ReaderWriterLock::AnyWritersSince(int32_t seqNum) {
        {
            cli::lock_guard{this};
            return (this->seq_num > seqNum);
        }
    }
    
    void ReaderWriterLock::DowngradeFromWriterLock(LockCookie lockCookie) {
        {
            cli::lock_guard{this};
            if(!(HasWriterLock())) 
            {
                throw cli::gcnew<System::ApplicationException>(_T("The thread does not have the writer lock."));
            }
            if((lockCookie->WriterLocks != 0)) 
            {
                this->state++;
            }
             else 
            {
                this->state = lockCookie->ReaderLocks;
                this->reader_locks->set_Item_84c7e24d9caa09(cli::box(Thread::get_CurrentThreadId()), cli::box(this->state));
                if((this->readers > 0)) 
                {
                    Monitor::PulseAll(this);
                }
            }
        }
    }
    
    LockCookie ReaderWriterLock::ReleaseLock() {
        LockCookie cookie;
        {
            cli::lock_guard{this};
            cookie = GetLockCookie();
            if((cookie->WriterLocks != 0)) 
            {
                ReleaseWriterLock2(cookie->WriterLocks);
            }
             else 
            {
                if((cookie->ReaderLocks != 0)) 
                {
                    ReleaseReaderLock2(cookie->ReaderLocks, cookie->ReaderLocks);
                }
            }
        }
        return cookie;
    }
    
    void ReaderWriterLock::ReleaseReaderLock() {
        {
            cli::lock_guard{this};
            if(HasWriterLock()) 
            {
                ReleaseWriterLock();
                return;
            }
             else 
            {
                if((this->state > 0)) 
                {
                    System::Object *read_lock_count = this->reader_locks->get_Item_d75c6e706b965758(cli::box(Thread::get_CurrentThreadId()));
                    if((read_lock_count != nullptr)) 
                    {
                        ReleaseReaderLock2(cli::unbox<int32_t>(read_lock_count), 1);
                        return;
                    }
                }
            }
            throw cli::gcnew<System::ApplicationException>(_T("The thread does not have any reader or writer locks."));
        }
    }
    
    void ReaderWriterLock::ReleaseReaderLock2(int32_t currentCount, int32_t releaseCount) {
        int32_t new_count = (currentCount - releaseCount);
        if((new_count ==  0)) 
        {
            this->reader_locks->Remove_fd653674dd8a5ac4(cli::box(Thread::get_CurrentThreadId()));
        }
         else 
        {
            this->reader_locks->set_Item_84c7e24d9caa09(cli::box(Thread::get_CurrentThreadId()), cli::box(new_count));
        }
        (this->state = this->state - releaseCount);
        if(((this->state ==  0) && !(this->writer_queue->get_IsEmpty()))) 
        {
            this->writer_queue->Pulse();
        }
    }
    
    void ReaderWriterLock::ReleaseWriterLock() {
        {
            cli::lock_guard{this};
            if(!(HasWriterLock())) 
            {
                throw cli::gcnew<System::ApplicationException>(_T("The thread does not have the writer lock."));
            }
            ReleaseWriterLock2(1);
        }
    }
    
    void ReaderWriterLock::ReleaseWriterLock2(int32_t releaseCount) {
        (this->state = this->state + releaseCount);
        if((this->state ==  0)) 
        {
            if((this->readers > 0)) 
            {
                Monitor::PulseAll(this);
            }
             else 
            {
                if(!(this->writer_queue->get_IsEmpty())) 
                {
                    this->writer_queue->Pulse();
                }
            }
        }
    }
    
    void ReaderWriterLock::RestoreLock(LockCookie lockCookie) {
        {
            cli::lock_guard{this};
            if((lockCookie->WriterLocks != 0)) 
            {
                AcquireWriterLock2(-1, lockCookie->WriterLocks);
            }
             else 
            {
                if((lockCookie->ReaderLocks != 0)) 
                {
                    AcquireReaderLock2(-1, lockCookie->ReaderLocks);
                }
            }
        }
    }
    
    LockCookie ReaderWriterLock::UpgradeToWriterLock(int32_t millisecondsTimeout) {
        LockCookie cookie;
        {
            cli::lock_guard{this};
            cookie = GetLockCookie();
            if((cookie->WriterLocks != 0)) 
            {
                this->state--;
                return cookie;
            }
            if((cookie->ReaderLocks != 0)) 
            {
                ReleaseReaderLock2(cookie->ReaderLocks, cookie->ReaderLocks);
            }
        }
        AcquireWriterLock(millisecondsTimeout);
        return cookie;
    }
    
    LockCookie ReaderWriterLock::UpgradeToWriterLock2(System::TimeSpan timeout) {
        int32_t ms = CheckTimeout(timeout);
        return UpgradeToWriterLock(ms);
    }
    
    LockCookie ReaderWriterLock::GetLockCookie() {
        LockCookie cookie = cli::ctor<LockCookie>(Thread::get_CurrentThreadId());
        if(HasWriterLock()) 
        {
            cookie->WriterLocks = -(this->state);
        }
         else 
        {
            System::Object *locks = this->reader_locks->get_Item_d75c6e706b965758(cli::box(Thread::get_CurrentThreadId()));
            if((locks != nullptr)) 
            {
                cookie->ReaderLocks = cli::unbox<int32_t>(locks);
            }
        }
        return cookie;
    }
    
    bool ReaderWriterLock::HasWriterLock() {
        return ((this->state < 0) && (Thread::get_CurrentThreadId() ==  this->writer_lock_owner));
    }
    
    int32_t ReaderWriterLock::CheckTimeout(System::TimeSpan timeout) {
        int32_t ms = (int32_t)timeout->get_TotalMilliseconds();
        if((ms < -1)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("timeout"), _T("Number must be either non-negative or -1"));
        }
        return ms;
    }
    
    bool ReaderWriterLock::get_IsReaderLockHeld() {
        cli::lock_guard{this};
        {
            return this->reader_locks->ContainsKey_5de2e202a0290d76(cli::box(Thread::get_CurrentThreadId()));
        }
    }
    
    bool ReaderWriterLock::get_IsWriterLockHeld() {
        cli::lock_guard{this};
        {
            return ((this->state < 0) && (Thread::get_CurrentThreadId() ==  this->writer_lock_owner));
        }
    }
    
    int32_t ReaderWriterLock::get_WriterSeqNum() {
        cli::lock_guard{this};
        {
            return this->seq_num;
        }
    }
    
}}
namespace System { namespace Threading {
    
    
    void RegisteredWaitHandle::constructor(WaitHandle* waitObject, WaitOrTimerCallback* callback, System::Object* state, System::TimeSpan timeout, bool executeOnlyOnce) {
        this->_waitObject = waitObject;
        this->_callback = callback;
        this->_state = state;
        this->_timeout = timeout;
        this->_executeOnlyOnce = executeOnlyOnce;
        this->_finalEvent = nullptr;
        this->_cancelEvent = cli::gcnew<ManualResetEvent>(false);
        this->_callsInProcess = 0;
        this->_unregistered = false;
    }
    
    void RegisteredWaitHandle::Wait(System::Object* state) {
        try {
            cli::array<WaitHandle*> *waits = (new cli::array<WaitHandle*>({_waitObject, _cancelEvent}));
            do {
                int32_t signal = WaitHandle::WaitAny5(waits, this->_timeout, false);
                if(!(this->_unregistered)) 
                {
                    {
                        cli::lock_guard{this};
                        this->_callsInProcess++;
                    }
                    ThreadPool::QueueUserWorkItem2(cli::bind(this, &RegisteredWaitHandle::DoCallBack), cli::box((signal ==  258)));
                }
            }
            while((!(this->_unregistered) && !(this->_executeOnlyOnce)));
        }
        catch(...) {
        }
        {
            cli::lock_guard{this};
            this->_unregistered = true;
            if(((this->_callsInProcess ==  0) && (this->_finalEvent != nullptr))) 
            {
                NativeEventCalls::SetEvent_internal(this->_finalEvent->get_Handle_95175e197a1d983a());
            }
        }
    }
    
    void RegisteredWaitHandle::DoCallBack(System::Object* timedOut) {
        if((this->_callback != nullptr)) 
        {
            try {
                this->_callback->Invoke(this->_state, cli::unbox<bool>(timedOut));
            }
            catch(...) {
            }
        }
        {
            cli::lock_guard{this};
            this->_callsInProcess--;
            if(((this->_unregistered && (this->_callsInProcess ==  0)) && (this->_finalEvent != nullptr))) 
            {
                NativeEventCalls::SetEvent_internal(this->_finalEvent->get_Handle_95175e197a1d983a());
            }
        }
    }
    
    bool RegisteredWaitHandle::Unregister(WaitHandle* waitObject) {
        {
            cli::lock_guard{this};
            if(this->_unregistered) 
            {
                return false;
            }
            this->_finalEvent = waitObject;
            this->_unregistered = true;
            this->_cancelEvent->Set();
            return true;
        }
    }
    
}}
namespace System { namespace Threading {
    
    
    void SemaphoreSlim::constructor(int32_t initialCount) {
    }
    
    void SemaphoreSlim::constructor(int32_t initialCount, int32_t maxCount) {
        if((((initialCount < 0) || (initialCount > maxCount)) || (maxCount < 0))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("The initialCount  argument is negative, initialCount is greater than maxCount, or maxCount is not positive."));
        }
        this->maxCount = maxCount;
        this->currCount = initialCount;
        this->handle = cli::gcnew<ManualResetEvent>((initialCount ==  0));
    }
    
    void SemaphoreSlim::Dispose() {
        Dispose_18dec4eb40ad27f4(true);
    }
    
    void SemaphoreSlim::Dispose_18dec4eb40ad27f4(bool disposing) {
        this->isDisposed = true;
    }
    
    void SemaphoreSlim::CheckState() {
        if(this->isDisposed) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(_T("The SemaphoreSlim has been disposed."));
        }
    }
    
    int32_t SemaphoreSlim::Release() {
        return Release2(1);
    }
    
    int32_t SemaphoreSlim::Release2(int32_t releaseCount) {
        CheckState();
        if((releaseCount < 1)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("releaseCount"), _T("releaseCount is less than 1"));
        }
        int32_t oldValue, newValue;
        do {
            oldValue = this->currCount;
            newValue = (this->currCount + releaseCount);
            newValue = (newValue > this->maxCount) ? this->maxCount : newValue;
        }
        while((Interlocked::CompareExchange(this->currCount, newValue, oldValue) != oldValue));
        this->handle->Set();
        return oldValue;
    }
    
    void SemaphoreSlim::Wait() {
        Wait4(CancellationToken::get_None());
    }
    
    bool SemaphoreSlim::Wait2(System::TimeSpan timeout) {
        return Wait6((int32_t)timeout->get_TotalMilliseconds(), CancellationToken::get_None());
    }
    
    bool SemaphoreSlim::Wait3(int32_t millisecondsTimeout) {
        return Wait6(millisecondsTimeout, CancellationToken::get_None());
    }
    
    void SemaphoreSlim::Wait4(CancellationToken cancellationToken) {
        Wait6(-1, cancellationToken);
    }
    
    bool SemaphoreSlim::Wait5(System::TimeSpan timeout, CancellationToken cancellationToken) {
        CheckState();
        return Wait6((int32_t)timeout->get_TotalMilliseconds(), cancellationToken);
    }
    
    bool SemaphoreSlim::Wait6(int32_t millisecondsTimeout, CancellationToken cancellationToken) {
        auto storey_633 = cli::gcnew<_Wait_c__AnonStorey1C>();
        storey_633->millisecondsTimeout = millisecondsTimeout;
        CheckState();
        if((storey_633->millisecondsTimeout < -1)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("millisecondsTimeout"), _T("millisecondsTimeout is a negative number other than -1"));
        }
        storey_633->sw = Watch::StartNew();
        System::Func<bool> *stopCondition = cli::bind(storey_633, &_Wait_c__AnonStorey1C::__m__15);
        do {
            bool shouldWait;
            int32_t result;
            do {
                cancellationToken->ThrowIfCancellationRequested();
                if(stopCondition->Invoke()) 
                {
                    return false;
                }
                shouldWait = true;
                result = this->currCount;
                if((result > 0)) 
                {
                    shouldWait = false;
                }
                 else 
                {
                    break;
                }
            }
            while((Interlocked::CompareExchange(this->currCount, (result - 1), result) != result));
            if(!(shouldWait)) 
            {
                if((result ==  1)) 
                {
                    this->handle->Reset();
                }
                break;
            }
            SpinWait wait = cli::ctor<SpinWait>();
            while((Thread::VolatileRead4(this->currCount) <= 0)) {
                cancellationToken->ThrowIfCancellationRequested();
                if(stopCondition->Invoke()) 
                {
                    return false;
                }
                if((wait->get_Count() > 10)) 
                {
                    this->handle->WaitOne_f0c7091fd69d769f(System::Math::Min5(System::Math::Max5((storey_633->millisecondsTimeout - (int32_t)storey_633->sw->get_ElapsedMilliseconds()), 1), 20));
                }
                 else 
                {
                    wait->SpinOnce();
                }
            }
        }
        while(true);
        return true;
    }
    
    int32_t SemaphoreSlim::get_CurrentCount() {
        return this->currCount;
    }
    
    WaitHandle* SemaphoreSlim::get_AvailableWaitHandle() {
        return this->handle;
    }
    
}}
namespace System { namespace Threading {
    
    SynchronizationContext*  SynchronizationContext::currentContext;
    
    void SynchronizationContext::constructor() {
    }
    
    void SynchronizationContext::constructor(SynchronizationContext* context) {
        currentContext = context;
    }
    
    SynchronizationContext* SynchronizationContext::CreateCopy_8cf89e84ec039a51() {
        return cli::gcnew<SynchronizationContext>(this);
    }
    
    bool SynchronizationContext::IsWaitNotificationRequired() {
        return this->notification_required;
    }
    
    void SynchronizationContext::OperationCompleted_45bda522c5c8b62a() {
    }
    
    void SynchronizationContext::OperationStarted_eb38d0f4c1e6dd09() {
    }
    
    void SynchronizationContext::Post_3eaec456ea854a8e(SendOrPostCallback* d, System::Object* state) {
        ThreadPool::QueueUserWorkItem2(cli::bind(d, &SendOrPostCallback::Invoke), state);
    }
    
    void SynchronizationContext::Send_14bb59dd079cf544(SendOrPostCallback* d, System::Object* state) {
        d->Invoke(state);
    }
    
    void SynchronizationContext::SetSynchronizationContext(SynchronizationContext* syncContext) {
        currentContext = syncContext;
    }
    
    void SynchronizationContext::SetWaitNotificationRequired() {
        this->notification_required = true;
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t SynchronizationContext::Wait_c11b2e78ab73d755(cli::array<void*>* waitHandles, bool waitAll, int32_t millisecondsTimeout) {
        return WaitHelper(waitHandles, waitAll, millisecondsTimeout);
    }
    
    int32_t SynchronizationContext::WaitHelper(cli::array<void*>* waitHandles, bool waitAll, int32_t millisecondsTimeout) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    SynchronizationContext* SynchronizationContext::get_Current() {
        return currentContext;
    }
    
}}
namespace System { namespace Threading {
    
    
    void SynchronizationLockException::constructor() {
    }
    
    void SynchronizationLockException::constructor(System::String* message) {
    }
    
    void SynchronizationLockException::constructor(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
    }
    
    void SynchronizationLockException::constructor(System::String* message, System::Exception* innerException) {
    }
    
}}
namespace System { namespace Threading {
    
    
    void InternalThread::constructor() {
    }
    
    void InternalThread::Finalize_d22478c1137552d() {
        {
            cli::finally_guard([&]() {
                Finalize_194ea81baa80af66();
            });
            Thread_free_internal(this->system_thread_handle);
        }
    }
    
    void InternalThread::Thread_free_internal(void* handle) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
}}
namespace System { namespace Threading {
    
    cli::array<System::Object*>*  Thread::local_slots;
    Thread*  Thread::current_thread;
    ExecutionContext*  Thread::_ec;
    System::Collections::Hashtable*  Thread::datastorehash;
    System::Object*  Thread::datastore_lock;
    
    Thread::Thread()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void Thread::constructor(ThreadStart* start) {
        if((start ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("Null ThreadStart"));
        }
        this->threadstart = start;
    }
    
    void Thread::constructor(InternalThread* it) {
        this->internal_thread = it;
    }
    
    void Thread::constructor(ThreadStart* start, int32_t maxStackSize) {
        if((start ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("start"));
        }
        this->threadstart = start;
        this->get_Internal()->stack_size = CheckStackSize(maxStackSize);;
    }
    
    void Thread::constructor(ParameterizedThreadStart* start) {
        if((start ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("start"));
        }
        this->threadstart = start;
    }
    
    void Thread::constructor(ParameterizedThreadStart* start, int32_t maxStackSize) {
        if((start ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("start"));
        }
        this->threadstart = start;
        this->get_Internal()->stack_size = CheckStackSize(maxStackSize);
    }
    
    void Thread::static_constructor() {
    }
    
    void Thread::ConstructInternalThread() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    cli::array<unsigned char>* Thread::ByteArrayToRootDomain(cli::array<unsigned char>* arr) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    cli::array<unsigned char>* Thread::ByteArrayToCurrentDomain(cli::array<unsigned char>* arr) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Thread::DeserializePrincipal(Thread* th) {
        System::IO::MemoryStream *ms = cli::gcnew<System::IO::MemoryStream>(ByteArrayToCurrentDomain(th->get_Internal()->_serialized_principal));
        int32_t type = ms->ReadByte_61a294e42318f99();
        if((type ==  0)) 
        {
            System::Runtime::Serialization::Formatters::Binary::BinaryFormatter *bf = cli::gcnew<System::Runtime::Serialization::Formatters::Binary::BinaryFormatter>();
            th->principal = cli::cast<System::Security::Principal::IPrincipal*>(bf->Deserialize(ms));
            th->principal_version = th->get_Internal()->_serialized_principal_version;
        }
         else 
        {
            if((type ==  1)) 
            {
                System::IO::BinaryReader *reader = cli::gcnew<System::IO::BinaryReader>(ms);
                System::String *name = reader->ReadString_7b59e815ae441879();
                System::String *auth_type = reader->ReadString_7b59e815ae441879();
                int32_t n_roles = reader->ReadInt32_e79bbed3af40f25f();
                cli::array<System::String*> *roles = nullptr;
                if((n_roles >= 0)) 
                {
                    roles = (new cli::array<System::String*>(n_roles));
                    for(int32_t i = 0; (i < n_roles); i++) {
                        roles->at(i) = reader->ReadString_7b59e815ae441879();
                    }
                }
                th->principal = cli::gcnew<System::Security::Principal::GenericPrincipal>(cli::gcnew<System::Security::Principal::GenericIdentity>(name, auth_type), roles);
            }
             else 
            {
                if(((type ==  2) || (type ==  3))) 
                {
                    cli::array<System::String*> *roles = (type ==  2) ? nullptr : (new cli::array<System::String*>(0));
                    th->principal = cli::gcnew<System::Security::Principal::GenericPrincipal>(cli::gcnew<System::Security::Principal::GenericIdentity>(_T(""), _T("")), roles);
                }
            }
        }
    }
    
    void Thread::SerializePrincipal(Thread* th, System::Security::Principal::IPrincipal* value) {
        System::IO::MemoryStream *ms = cli::gcnew<System::IO::MemoryStream>();
        bool done = false;
        if(System::Type::op_Equality2(value->GetType(), cli::typeof<System::Type>::info)) 
        {
            System::Security::Principal::GenericPrincipal *gp = cli::cast<System::Security::Principal::GenericPrincipal*>(value);
            if(((gp->get_Identity_ace87d10090e7749() != nullptr) && System::Type::op_Equality2(gp->get_Identity_ace87d10090e7749()->GetType(), cli::typeof<System::Type>::info))) 
            {
                System::Security::Principal::GenericIdentity *id = cli::cast<System::Security::Principal::GenericIdentity*>(gp->get_Identity_ace87d10090e7749());
                if((System::String::op_Equality(id->get_Name_e32680458218f597(), _T("")) && System::String::op_Equality(id->get_AuthenticationType_cb7e4615cad01a4c(), _T("")))) 
                {
                    if((gp->get_Roles() ==  nullptr)) 
                    {
                        ms->WriteByte_4404d6329af3b6d5(2);
                        done = true;
                    }
                     else 
                    {
                        if((gp->get_Roles()->get_Length() ==  0)) 
                        {
                            ms->WriteByte_4404d6329af3b6d5(3);
                            done = true;
                        }
                    }
                }
                 else 
                {
                    ms->WriteByte_4404d6329af3b6d5(1);
                    System::IO::BinaryWriter *br = cli::gcnew<System::IO::BinaryWriter>(ms);
                    br->Write_6de303e680f3eff5(gp->get_Identity_ace87d10090e7749()->get_Name_b724867acffa5fcd());
                    br->Write_6de303e680f3eff5(gp->get_Identity_ace87d10090e7749()->get_AuthenticationType_fde3461ee63fdcbc());
                    cli::array<System::String*> *roles = gp->get_Roles();
                    if((roles ==  nullptr)) 
                    {
                        br->Write_6382fee822de735b(-1);
                    }
                     else 
                    {
                        br->Write_6382fee822de735b(roles->get_Length());
                        for(auto tmp_634 : roles) {
                            auto s = cli::cast<System::String*>(tmp_634);
                            {
                                br->Write_6de303e680f3eff5(s);
                            }
                        }
                    }
                    br->Flush_3f4412918277f178();
                    done = true;
                }
            }
        }
        if(!(done)) 
        {
            ms->WriteByte_4404d6329af3b6d5(0);
            System::Runtime::Serialization::Formatters::Binary::BinaryFormatter *bf = cli::gcnew<System::Runtime::Serialization::Formatters::Binary::BinaryFormatter>();
            try {
                bf->Serialize(ms, value);
            }
            catch(...) {
            }
        }
        th->get_Internal()->_serialized_principal = ByteArrayToRootDomain(ms->ToArray_ebf8bde16e9d2ad6());
    }
    
    InternalThread* Thread::CurrentInternalThread_internal() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    uint32_t Thread::AllocTlsData(System::Type* type) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Thread::DestroyTlsData(uint32_t offset) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Thread::InitDataStoreHash() {
        {
            cli::lock_guard{datastore_lock};
            if((datastorehash ==  nullptr)) 
            {
                datastorehash = System::Collections::Hashtable::Synchronized(cli::gcnew<System::Collections::Hashtable>());
            }
        }
    }
    
    System::LocalDataStoreSlot* Thread::AllocateNamedDataSlot(System::String* name) {
        {
            cli::lock_guard{datastore_lock};
            if((datastorehash ==  nullptr)) 
            {
                InitDataStoreHash();
            }
            System::LocalDataStoreSlot *slot = cli::cast<System::LocalDataStoreSlot*>(datastorehash->get_Item_d75c6e706b965758(name));
            if((slot != nullptr)) 
            {
                throw cli::gcnew<System::ArgumentException>(_T("Named data slot already added"));
            }
            slot = AllocateDataSlot();
            datastorehash->Add_3f7ab157bcb41156(name, slot);
            return slot;
        }
    }
    
    void Thread::FreeNamedDataSlot(System::String* name) {
        {
            cli::lock_guard{datastore_lock};
            if((datastorehash ==  nullptr)) 
            {
                InitDataStoreHash();
            }
            System::LocalDataStoreSlot *slot = cli::cast<System::LocalDataStoreSlot*>(datastorehash->get_Item_d75c6e706b965758(name));
            if((slot != nullptr)) 
            {
                datastorehash->Remove_fd653674dd8a5ac4(slot);
            }
        }
    }
    
    System::LocalDataStoreSlot* Thread::AllocateDataSlot() {
        return cli::gcnew<System::LocalDataStoreSlot>(true);
    }
    
    System::Object* Thread::GetData(System::LocalDataStoreSlot* slot) {
        cli::array<System::Object*> *slots = local_slots;
        if((slot ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("slot"));
        }
        if(((slots != nullptr) && (slot->slot < slots->get_Length()))) 
        {
            return slots->at(slot->slot);
        }
        return nullptr;
    }
    
    void Thread::SetData(System::LocalDataStoreSlot* slot, System::Object* data) {
        cli::array<System::Object*> *slots = local_slots;
        if((slot ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("slot"));
        }
        if((slots ==  nullptr)) 
        {
            slots = (new cli::array<System::Object*>((slot->slot + 2)));
            local_slots = slots;
        }
         else 
        {
            if((slot->slot >= slots->get_Length())) 
            {
                cli::array<System::Object*> *nslots = (new cli::array<System::Object*>((slot->slot + 2)));
                cli::import(slots)->CopyTo(nslots, 0);
                slots = nslots;
                local_slots = slots;
            }
        }
        slots->at(slot->slot) = data;
    }
    
    void Thread::FreeLocalSlotValues(int32_t slot, bool thread_local_) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    System::LocalDataStoreSlot* Thread::GetNamedDataSlot(System::String* name) {
        {
            cli::lock_guard{datastore_lock};
            if((datastorehash ==  nullptr)) 
            {
                InitDataStoreHash();
            }
            System::LocalDataStoreSlot *slot = cli::cast<System::LocalDataStoreSlot*>(datastorehash->get_Item_d75c6e706b965758(name));
            if((slot ==  nullptr)) 
            {
                slot = AllocateNamedDataSlot(name);
            }
            return slot;
        }
    }
    
    System::AppDomain* Thread::GetDomain() {
        return System::AppDomain::get_CurrentDomain();
    }
    
    int32_t Thread::GetDomainID() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Thread::ResetAbort_internal() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Thread::ResetAbort() {
        ResetAbort_internal();
    }
    
    bool Thread::Yield() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Thread::Sleep_internal(int32_t ms) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Thread::Sleep(int32_t millisecondsTimeout) {
        if((millisecondsTimeout < -1)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("millisecondsTimeout"), _T("Negative timeout"));
        }
        Sleep_internal(millisecondsTimeout);
    }
    
    void Thread::Sleep2(System::TimeSpan timeout) {
        int64_t ms = (int64_t)timeout->get_TotalMilliseconds();
        if(((ms < -1L) || (ms > 2147483647L))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("timeout"), _T("timeout out of range"));
        }
        Sleep_internal((int32_t)ms);
    }
    
    void* Thread::Thread_internal(System::MulticastDelegate* start) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    System::String* Thread::GetName_internal(InternalThread* thread) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Thread::SetName_internal(InternalThread* thread, System::String* name) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Thread::Abort_internal(InternalThread* thread, System::Object* stateInfo) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Thread::Abort() {
        Abort_internal(this->get_Internal(), nullptr);
    }
    
    void Thread::Abort2(System::Object* stateInfo) {
        Abort_internal(this->get_Internal(), stateInfo);
    }
    
    System::Object* Thread::GetAbortExceptionState() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Thread::Interrupt_internal(InternalThread* thread) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Thread::Interrupt() {
        Interrupt_internal(this->get_Internal());
    }
    
    bool Thread::Join_internal(InternalThread* thread, int32_t ms, void* handle) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Thread::Join() {
        Join_internal(this->get_Internal(), -1, this->get_Internal()->system_thread_handle);
    }
    
    bool Thread::Join2(int32_t millisecondsTimeout) {
        if((millisecondsTimeout < -1)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("millisecondsTimeout"), _T("Timeout less than zero"));
        }
        return Join_internal(this->get_Internal(), millisecondsTimeout, this->get_Internal()->system_thread_handle);
    }
    
    bool Thread::Join3(System::TimeSpan timeout) {
        int64_t ms = (int64_t)timeout->get_TotalMilliseconds();
        if(((ms < -1L) || (ms > 2147483647L))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("timeout"), _T("timeout out of range"));
        }
        return Join_internal(this->get_Internal(), (int32_t)ms, this->get_Internal()->system_thread_handle);
    }
    
    void Thread::MemoryBarrier() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Thread::Resume_internal() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Thread::Resume() {
        Resume_internal();
    }
    
    void Thread::SpinWait_nop() {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Thread::SpinWait2(int32_t iterations) {
        if((iterations < 0)) 
        {
            return;
        }
        while((iterations-- > 0)) {
            SpinWait_nop();
        }
    }
    
    void Thread::StartInternal() {
        current_thread = this;
        if(cli::is<ThreadStart>(this->threadstart)) 
        {
            cli::cast<ThreadStart*>(this->threadstart)->Invoke();
        }
         else 
        {
            cli::cast<ParameterizedThreadStart*>(this->threadstart)->Invoke(this->start_obj);
        }
    }
    
    void Thread::Start() {
        if(!(ExecutionContext::IsFlowSuppressed())) 
        {
            this->ec_to_set = ExecutionContext::Capture();
        }
        this->get_Internal()->_serialized_principal = Thread::get_CurrentThread()->get_Internal()->_serialized_principal;
        if(::System::IntPtr::op_Equality(Thread_internal(cli::bind(this, &Thread::StartInternal)), (void*)0)) 
        {
            throw cli::gcnew<System::SystemException>(_T("Thread creation failed."));
        }
    }
    
    void Thread::Suspend_internal(InternalThread* thread) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Thread::Suspend() {
        Suspend_internal(this->get_Internal());
    }
    
    void Thread::SetState(InternalThread* thread, ThreadState set) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Thread::ClrState(InternalThread* thread, ThreadState clr) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    ThreadState Thread::GetState(InternalThread* thread) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    unsigned char Thread::VolatileRead(unsigned char address) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    double Thread::VolatileRead2(double address) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int16_t Thread::VolatileRead3(int16_t address) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t Thread::VolatileRead4(int32_t address) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int64_t Thread::VolatileRead5(int64_t address) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void* Thread::VolatileRead6(void* address) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    System::Object* Thread::VolatileRead7(System::Object* address) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    signed char Thread::VolatileRead8(signed char address) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    float Thread::VolatileRead9(float address) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    uint16_t Thread::VolatileRead10(uint16_t address) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    uint32_t Thread::VolatileRead11(uint32_t address) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    uint64_t Thread::VolatileRead12(uint64_t address) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void* Thread::VolatileRead13(void* address) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Thread::VolatileWrite(unsigned char address, unsigned char value) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Thread::VolatileWrite2(double address, double value) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Thread::VolatileWrite3(int16_t address, int16_t value) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Thread::VolatileWrite4(int32_t address, int32_t value) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Thread::VolatileWrite5(int64_t address, int64_t value) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Thread::VolatileWrite6(void* address, void* value) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Thread::VolatileWrite7(System::Object* address, System::Object* value) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Thread::VolatileWrite8(signed char address, signed char value) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Thread::VolatileWrite9(float address, float value) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Thread::VolatileWrite10(uint16_t address, uint16_t value) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Thread::VolatileWrite11(uint32_t address, uint32_t value) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Thread::VolatileWrite12(uint64_t address, uint64_t value) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Thread::VolatileWrite13(void* address, void* value) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t Thread::CheckStackSize(int32_t maxStackSize) {
        if((maxStackSize < 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("less than zero"), _T("maxStackSize"));
        }
        if((maxStackSize < 131072)) 
        {
            return 131072;
        }
        int32_t page_size = System::Environment::GetPageSize();
        if(((maxStackSize % page_size) != 0)) 
        {
            maxStackSize = ((maxStackSize / (page_size - 1)) * page_size);
        }
        int32_t default_stack_size = (((::System::IntPtr::get_Size() / 4) * 1024) * 1024);
        if((maxStackSize > default_stack_size)) 
        {
            return default_stack_size;
        }
        return maxStackSize;
    }
    
    void Thread::BeginCriticalRegion() {
        Thread::get_CurrentThread()->get_Internal()->critical_region_level++;
    }
    
    void Thread::EndCriticalRegion() {
        Thread::get_CurrentThread()->get_Internal()->critical_region_level--;
    }
    
    void Thread::BeginThreadAffinity() {
    }
    
    void Thread::EndThreadAffinity() {
    }
    
    ApartmentState Thread::GetApartmentState() {
        return (ApartmentState)(this->get_Internal()->apartment_state);
    }
    
    void Thread::SetApartmentState(ApartmentState state) {
        if(!(TrySetApartmentState(state))) 
        {
            throw cli::gcnew<System::InvalidOperationException>(_T("Failed to set the specified COM apartment state."));
        }
    }
    
    bool Thread::TrySetApartmentState(ApartmentState state) {
        if(((this != Thread::get_CurrentThread()) && ((int32_t)(((int32_t)(this->get_ThreadState()) & 8)) ==  0))) 
        {
            throw cli::gcnew<ThreadStateException>(_T("Thread was in an invalid state for the operation being executed."));
        }
        if(((int32_t)(this->get_Internal()->apartment_state) != 2)) 
        {
            return false;
        }
        this->get_Internal()->apartment_state = (unsigned char)((unsigned char)(int32_t)(state));
        return true;
    }
    
    int32_t Thread::GetHashCode_6648aef0f235ee6c() {
        return this->get_ManagedThreadId();
    }
    
    void Thread::Start2(System::Object* parameter) {
        this->start_obj = parameter;
        Start();
    }
    
    CompressedStack* Thread::GetCompressedStack() {
        CompressedStack *cs = this->get_ExecutionContext()->get_SecurityContext()->get_CompressedStack();
        return ((cs ==  nullptr) || cs->IsEmpty()) ? nullptr : cs->CreateCopy();
    }
    
    void Thread::SetCompressedStack(CompressedStack* stack) {
        this->get_ExecutionContext()->get_SecurityContext()->set_CompressedStack(stack);
    }
    
    void Thread::GetIDsOfNames(System::Guid riid, void* rgszNames, uint32_t cNames, uint32_t lcid, void* rgDispId) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Thread::GetTypeInfo(uint32_t iTInfo, uint32_t lcid, void* ppTInfo) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Thread::GetTypeInfoCount(uint32_t pcTInfo) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    void Thread::Invoke(uint32_t dispIdMember, System::Guid riid, uint32_t lcid, int16_t wFlags, void* pDispParams, void* pVarResult, void* pExcepInfo, void* puArgErr) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    InternalThread* Thread::get_Internal() {
        if((this->internal_thread ==  nullptr)) 
        {
            ConstructInternalThread();
        }
        return this->internal_thread;
    }
    
    System::Runtime::Remoting::Contexts::Context2* Thread::get_CurrentContext() {
        return System::AppDomain::InternalGetContext();
    }
    
    System::Security::Principal::IPrincipal* Thread::get_CurrentPrincipal() {
        Thread *th = get_CurrentThread();
        if((th->principal_version != th->get_Internal()->_serialized_principal_version)) 
        {
            th->principal = nullptr;
        }
        if((th->principal != nullptr)) 
        {
            return th->principal;
        }
        if((th->get_Internal()->_serialized_principal != nullptr)) 
        {
            try {
                DeserializePrincipal(th);
                return th->principal;
            }
            catch(...) {
            }
        }
        th->principal = GetDomain()->get_DefaultPrincipal();
        th->principal_version = th->get_Internal()->_serialized_principal_version;
        return th->principal;
    }
    
    System::Security::Principal::IPrincipal* Thread::set_CurrentPrincipal(System::Security::Principal::IPrincipal* value) {
        Thread *th = get_CurrentThread();
        if((value != GetDomain()->get_DefaultPrincipal())) 
        {
            ++th->get_Internal()->_serialized_principal_version;
            try {
                SerializePrincipal(th, value);
            }
            catch(System::Exception*) {
                th->get_Internal()->_serialized_principal = nullptr;
            }
            th->principal_version = th->get_Internal()->_serialized_principal_version;
        }
         else 
        {
            th->get_Internal()->_serialized_principal = nullptr;
        }
        th->principal = value;
        return get_CurrentPrincipal();
    }
    
    Thread* Thread::get_CurrentThread() {
        if((current_thread ==  nullptr)) 
        {
            current_thread = cli::gcnew<Thread>(CurrentInternalThread_internal());
        }
        return current_thread;
    }
    
    int32_t Thread::get_CurrentThreadId() {
        return (int32_t)Thread::get_CurrentThread()->internal_thread->thread_id;
    }
    
    ApartmentState Thread::get_ApartmentState() {
        if(((int32_t)(((int32_t)(this->get_ThreadState()) & 16)) != 0)) 
        {
            throw cli::gcnew<ThreadStateException>(_T("Thread is dead; state can not be accessed."));
        }
        return (ApartmentState)(this->get_Internal()->apartment_state);
    }
    
    ApartmentState Thread::set_ApartmentState(ApartmentState value) {
        TrySetApartmentState(value);
        return get_ApartmentState();
    }
    
    System::Globalization::CultureInfo* Thread::get_CurrentCulture() {
        System::Globalization::CultureInfo *culture = this->current_culture;
        if((culture != nullptr)) 
        {
            return culture;
        }
        this->current_culture = culture = System::Globalization::CultureInfo::ConstructCurrentCulture();
        System::NumberFormatter::SetThreadCurrentCulture(culture);
        return culture;
    }
    
    System::Globalization::CultureInfo* Thread::set_CurrentCulture(System::Globalization::CultureInfo* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("value"));
        }
        value->CheckNeutral();
        this->current_culture = value;
        System::NumberFormatter::SetThreadCurrentCulture(value);
        return get_CurrentCulture();
    }
    
    System::Globalization::CultureInfo* Thread::get_CurrentUICulture() {
        System::Globalization::CultureInfo *culture = this->current_ui_culture;
        if((culture != nullptr)) 
        {
            return culture;
        }
        this->current_ui_culture = culture = System::Globalization::CultureInfo::ConstructCurrentUICulture();
        return culture;
    }
    
    System::Globalization::CultureInfo* Thread::set_CurrentUICulture(System::Globalization::CultureInfo* value) {
        if((value ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("value"));
        }
        this->current_ui_culture = value;
        return get_CurrentUICulture();
    }
    
    bool Thread::get_IsThreadPoolThread() {
        return this->get_IsThreadPoolThreadInternal();
    }
    
    bool Thread::get_IsThreadPoolThreadInternal() {
        return this->get_Internal()->threadpool_thread;
    }
    
    bool Thread::set_IsThreadPoolThreadInternal(bool value) {
        this->get_Internal()->threadpool_thread = value;
        return get_IsThreadPoolThreadInternal();
    }
    
    bool Thread::get_IsAlive() {
        ThreadState curstate = GetState(this->get_Internal());
        if(((((int32_t)(((int32_t)(curstate) & 256)) != 0) || ((int32_t)(((int32_t)(curstate) & 16)) != 0)) || ((int32_t)(((int32_t)(curstate) & 8)) != 0))) 
        {
            return false;
        }
         else 
        {
            return true;
        }
    }
    
    bool Thread::get_IsBackground() {
        ThreadState thread_state = GetState(this->get_Internal());
        if(((int32_t)(((int32_t)(thread_state) & 16)) != 0)) 
        {
            throw cli::gcnew<ThreadStateException>(_T("Thread is dead; state can not be accessed."));
        }
        return ((int32_t)(((int32_t)(thread_state) & 4)) != 0);
    }
    
    bool Thread::set_IsBackground(bool value) {
        if(value) 
        {
            SetState(this->get_Internal(), ThreadState::Background);
        }
         else 
        {
            ClrState(this->get_Internal(), ThreadState::Background);
        }
        return get_IsBackground();
    }
    
    System::String* Thread::get_Name() {
        return GetName_internal(this->get_Internal());
    }
    
    System::String* Thread::set_Name(System::String* value) {
        SetName_internal(this->get_Internal(), value);
        return get_Name();
    }
    
    ThreadPriority Thread::get_Priority() {
        return ThreadPriority::Lowest;
    }
    
    ThreadPriority Thread::set_Priority(ThreadPriority value) {
        return get_Priority();
    }
    
    ThreadState Thread::get_ThreadState() {
        return GetState(this->get_Internal());
    }
    
    ExecutionContext* Thread::get_ExecutionContext() {
        if((_ec ==  nullptr)) 
        {
            _ec = cli::gcnew<ExecutionContext>();
        }
        return _ec;
    }
    
    int32_t Thread::get_ManagedThreadId() {
        return this->get_Internal()->managed_id;
    }
    
}}
namespace System { namespace Threading {
    
    
    void ThreadAbortException::constructor() {
        this->set_HResult(-2146233040);
    }
    
    void ThreadAbortException::constructor(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext sc) {
    }
    
    System::Object* ThreadAbortException::get_ExceptionState() {
        return Thread::get_CurrentThread()->GetAbortExceptionState();
    }
    
}}
namespace System { namespace Threading {
    
    
    void ThreadInterruptedException::constructor() {
    }
    
    void ThreadInterruptedException::constructor(System::String* message) {
    }
    
    void ThreadInterruptedException::constructor(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
    }
    
    void ThreadInterruptedException::constructor(System::String* message, System::Exception* innerException) {
    }
    
}}
namespace System { namespace Threading {
    
    
}}
namespace System { namespace Threading {
    
    
    bool ThreadPool::BindHandle(void* osHandle) {
        return true;
    }
    
    bool ThreadPool::BindHandle2(System::Runtime::InteropServices::SafeHandle* osHandle) {
        if((osHandle ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("osHandle"));
        }
        return true;
    }
    
    void ThreadPool::GetAvailableThreads(int32_t workerThreads, int32_t completionPortThreads) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void ThreadPool::GetMaxThreads(int32_t workerThreads, int32_t completionPortThreads) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void ThreadPool::GetMinThreads(int32_t workerThreads, int32_t completionPortThreads) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool ThreadPool::SetMinThreads(int32_t workerThreads, int32_t completionPortThreads) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool ThreadPool::SetMaxThreads(int32_t workerThreads, int32_t completionPortThreads) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool ThreadPool::QueueUserWorkItem(WaitCallback* callBack) {
        return QueueUserWorkItem2(callBack, nullptr);
    }
    
    bool ThreadPool::QueueUserWorkItem2(WaitCallback* callBack, System::Object* state) {
        if((callBack ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("callBack"));
        }
        if(callBack->IsTransparentProxy()) 
        {
            System::IAsyncResult *ar = callBack->BeginInvoke(state, nullptr, nullptr);
            if((ar ==  nullptr)) 
            {
                return false;
            }
        }
         else 
        {
            if(!(callBack->get_HasSingleTarget())) 
            {
                throw cli::gcnew<System::Exception>(_T("The delegate must have only one target"));
            }
            System::Runtime::Remoting::Messaging::AsyncResult *ares = cli::gcnew<System::Runtime::Remoting::Messaging::AsyncResult>(callBack, state, true);
            pool_queue(ares);
        }
        return true;
    }
    
    void ThreadPool::pool_queue(System::Runtime::Remoting::Messaging::AsyncResult* ares) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    RegisteredWaitHandle* ThreadPool::RegisterWaitForSingleObject(WaitHandle* waitObject, WaitOrTimerCallback* callBack, System::Object* state, int32_t millisecondsTimeOutInterval, bool executeOnlyOnce) {
        return RegisterWaitForSingleObject2(waitObject, callBack, state, (int64_t)(millisecondsTimeOutInterval), executeOnlyOnce);
    }
    
    RegisteredWaitHandle* ThreadPool::RegisterWaitForSingleObject2(WaitHandle* waitObject, WaitOrTimerCallback* callBack, System::Object* state, int64_t millisecondsTimeOutInterval, bool executeOnlyOnce) {
        if((millisecondsTimeOutInterval < -1L)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("timeout"), _T("timeout < -1"));
        }
        if((millisecondsTimeOutInterval > 2147483647L)) 
        {
            throw cli::gcnew<System::NotSupportedException>(_T("Timeout is too big. Maximum is Int32.MaxValue"));
        }
        System::TimeSpan timeout = cli::ctor<System::TimeSpan>(0, 0, 0, 0, (int32_t)millisecondsTimeOutInterval);
        RegisteredWaitHandle *waiter = cli::gcnew<RegisteredWaitHandle>(waitObject, callBack, state, timeout, executeOnlyOnce);
        QueueUserWorkItem2(cli::bind(waiter, &RegisteredWaitHandle::Wait), nullptr);
        return waiter;
    }
    
    RegisteredWaitHandle* ThreadPool::RegisterWaitForSingleObject3(WaitHandle* waitObject, WaitOrTimerCallback* callBack, System::Object* state, System::TimeSpan timeout, bool executeOnlyOnce) {
        return RegisterWaitForSingleObject2(waitObject, callBack, state, (int64_t)timeout->get_TotalMilliseconds(), executeOnlyOnce);
    }
    
    RegisteredWaitHandle* ThreadPool::RegisterWaitForSingleObject4(WaitHandle* waitObject, WaitOrTimerCallback* callBack, System::Object* state, uint32_t millisecondsTimeOutInterval, bool executeOnlyOnce) {
        return RegisterWaitForSingleObject2(waitObject, callBack, state, (int64_t)(millisecondsTimeOutInterval), executeOnlyOnce);
    }
    
    bool ThreadPool::UnsafeQueueNativeOverlapped(NativeOverlapped* overlapped) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool ThreadPool::UnsafeQueueUserWorkItem(WaitCallback* callBack, System::Object* state) {
        if(!(callBack->IsTransparentProxy())) 
        {
            if(!(callBack->get_HasSingleTarget())) 
            {
                throw cli::gcnew<System::Exception>(_T("The delegate must have only one target"));
            }
            System::Runtime::Remoting::Messaging::AsyncResult *ares = cli::gcnew<System::Runtime::Remoting::Messaging::AsyncResult>(callBack, state, false);
            pool_queue(ares);
            return true;
        }
        {
            cli::finally_guard([&]() {
                if(ExecutionContext::IsFlowSuppressed()) 
                {
                    ExecutionContext::RestoreFlow();
                }
            });
            if(!(ExecutionContext::IsFlowSuppressed())) 
            {
                ExecutionContext::SuppressFlow();
            }
            System::IAsyncResult *ar = callBack->BeginInvoke(state, nullptr, nullptr);
            if((ar ==  nullptr)) 
            {
                return false;
            }
        }
        return true;
    }
    
    RegisteredWaitHandle* ThreadPool::UnsafeRegisterWaitForSingleObject(WaitHandle* waitObject, WaitOrTimerCallback* callBack, System::Object* state, int32_t millisecondsTimeOutInterval, bool executeOnlyOnce) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    RegisteredWaitHandle* ThreadPool::UnsafeRegisterWaitForSingleObject2(WaitHandle* waitObject, WaitOrTimerCallback* callBack, System::Object* state, int64_t millisecondsTimeOutInterval, bool executeOnlyOnce) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    RegisteredWaitHandle* ThreadPool::UnsafeRegisterWaitForSingleObject3(WaitHandle* waitObject, WaitOrTimerCallback* callBack, System::Object* state, System::TimeSpan timeout, bool executeOnlyOnce) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    RegisteredWaitHandle* ThreadPool::UnsafeRegisterWaitForSingleObject4(WaitHandle* waitObject, WaitOrTimerCallback* callBack, System::Object* state, uint32_t millisecondsTimeOutInterval, bool executeOnlyOnce) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
}}
namespace System { namespace Threading {
    
    
    void ThreadStartException::constructor() {
    }
    
    void ThreadStartException::constructor(System::String* message) {
    }
    
    void ThreadStartException::constructor(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
    }
    
    void ThreadStartException::constructor(System::String* message, System::Exception* innerException) {
    }
    
}}
namespace System { namespace Threading {
    
    
    void ThreadStateException::constructor() {
    }
    
    void ThreadStateException::constructor(System::String* message) {
    }
    
    void ThreadStateException::constructor(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
    }
    
    void ThreadStateException::constructor(System::String* message, System::Exception* innerException) {
    }
    
}}
namespace System { namespace Threading {
    
    
}}
namespace System { namespace Threading {
    
    
    void TimerComparer::constructor() {
    }
    
    int32_t TimerComparer::Compare(System::Object* x, System::Object* y) {
        Timer *tx = cli::as<Timer*>(x);
        if((tx ==  nullptr)) 
        {
            return -1;
        }
        Timer *ty = cli::as<Timer*>(y);
        if((ty ==  nullptr)) 
        {
            return 1;
        }
        int64_t result = (tx->next_run - ty->next_run);
        if((result ==  0L)) 
        {
            return (x ==  y) ? 0 : -1;
        }
        return (result > 0L) ? 1 : -1;
    }
    
}}
namespace System { namespace Threading {
    
    Scheduler*  Scheduler::instance;
    WaitCallback*  Scheduler::TimerCaller;
    
    Scheduler::Scheduler()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void Scheduler::static_constructor() {
        instance = cli::gcnew<Scheduler>();
    }
    
    void Scheduler::constructor() {
        this->changed = cli::gcnew<ManualResetEvent>(false);
        this->list = cli::gcnew<System::Collections::SortedList>(cli::gcnew<TimerComparer>(), 1024);
        Thread *thread = cli::gcnew<Thread>(cli::bind(this, &Scheduler::SchedulerThread));
        thread->set_IsBackground(true);
        thread->Start();
    }
    
    void Scheduler::Remove(Timer* timer) {
        if(((timer->next_run ==  0L) || (timer->next_run ==  9223372036854775807L))) 
        {
            return;
        }
        {
            cli::lock_guard{this};
            InternalRemove(timer);
        }
    }
    
    void Scheduler::Change(Timer* timer, int64_t new_next_run) {
        bool wake = false;
        {
            cli::lock_guard{this};
            InternalRemove(timer);
            if((new_next_run ==  9223372036854775807L)) 
            {
                timer->next_run = new_next_run;
                return;
            }
            if(!(timer->disposed)) 
            {
                timer->next_run = new_next_run;
                Add(timer);
                wake = (this->list->GetByIndex_920ca5caddf75e3d(0) ==  timer);
            }
        }
        if(wake) 
        {
            this->changed->Set();
        }
    }
    
    int32_t Scheduler::FindByDueTime(int64_t nr) {
        int32_t min = 0;
        int32_t max = (this->list->get_Count_78ce60b82e5a007() - 1);
        if((max < 0)) 
        {
            return -1;
        }
        if((max < 20)) 
        {
            while((min <= max)) {
                Timer *t = cli::cast<Timer*>(this->list->GetByIndex_920ca5caddf75e3d(min));
                if((t->next_run ==  nr)) 
                {
                    return min;
                }
                if((t->next_run > nr)) 
                {
                    return -1;
                }
                min++;
            }
            return -1;
        }
        while((min <= max)) {
            int32_t half = (min + ((max - min) >> 1));
            Timer *t = cli::cast<Timer*>(this->list->GetByIndex_920ca5caddf75e3d(half));
            if((nr ==  t->next_run)) 
            {
                return half;
            }
            if((nr > t->next_run)) 
            {
                min = (half + 1);
            }
             else 
            {
                max = (half - 1);
            }
        }
        return -1;
    }
    
    void Scheduler::Add(Timer* timer) {
        int32_t idx = FindByDueTime(timer->next_run);
        if((idx != -1)) 
        {
            bool up = ((9223372036854775807L - timer->next_run) > 20000L) ? true : false;
            while(true) {
                idx++;
                if(up) 
                {
                    timer->next_run++;
                }
                 else 
                {
                    timer->next_run--;
                }
                if((idx >= this->list->get_Count_78ce60b82e5a007())) 
                {
                    break;
                }
                Timer *t2 = cli::cast<Timer*>(this->list->GetByIndex_920ca5caddf75e3d(idx));
                if((t2->next_run != timer->next_run)) 
                {
                    break;
                }
            }
        }
        this->list->Add_73ffb8be47e034c5(timer, timer);
    }
    
    int32_t Scheduler::InternalRemove(Timer* timer) {
        int32_t idx = this->list->IndexOfKey_81491507d0744836(timer);
        if((idx >= 0)) 
        {
            this->list->RemoveAt_cba3ea1ee2c9606d(idx);
        }
        return idx;
    }
    
    void Scheduler::TimerCB(System::Object* o) {
        Timer *timer = cli::cast<Timer*>(o);
        try {
            timer->callback->Invoke(timer->state);
        }
        catch(...) {
        }
    }
    
    void Scheduler::SchedulerThread() {
        Thread::get_CurrentThread()->set_Name(_T("Timer-Scheduler"));
        System::Collections::ArrayList *new_time = cli::gcnew<System::Collections::ArrayList>(512);
        while(true) {
            int32_t ms_wait = -1;
            int64_t ticks = System::DateTime::GetTimeMonotonic();
            {
                cli::lock_guard{this};
                this->changed->Reset();
                int32_t i;
                int32_t count = this->list->get_Count_78ce60b82e5a007();
                for(i = 0; (i < count); i++){
                    Timer *timer = cli::cast<Timer*>(this->list->GetByIndex_920ca5caddf75e3d(i));
                    if((timer->next_run > ticks)) 
                    {
                        break;
                    }
                    this->list->RemoveAt_cba3ea1ee2c9606d(i);
                    count--;
                    i--;
                    ThreadPool::UnsafeQueueUserWorkItem(TimerCaller, timer);
                    int64_t period = timer->period_ms;
                    int64_t due_time = timer->due_time_ms;
                    bool no_more = ((period ==  -1L) || (((period ==  0L) || (period ==  -1L)) && (due_time != -1L)));
                    if(no_more) 
                    {
                        timer->next_run = 9223372036854775807L;
                    }
                     else 
                    {
                        timer->next_run = (System::DateTime::GetTimeMonotonic() + (10000L * timer->period_ms));
                        new_time->Add_e6a92085999ce388(timer);
                    }
                }
                count = new_time->get_Count_2354963792616712();
                for(i = 0; (i < count); i++){
                    Timer *timer = cli::cast<Timer*>(new_time->get_Item_fd0155f142ae570(i));
                    Add(timer);
                }
                new_time->Clear_cd6654e5a40f5056();
                ShrinkIfNeeded(new_time, 512);
                int32_t capacity = this->list->get_Capacity_db68c0b120caeec5();
                count = this->list->get_Count_78ce60b82e5a007();
                if((((capacity > 1024) && (count > 0)) && ((capacity / count) > 3))) 
                {
                    this->list->set_Capacity_13c76b6b4fffc55d((count * 2));
                }
                int64_t min_next_run = 9223372036854775807L;
                if((this->list->get_Count_78ce60b82e5a007() > 0)) 
                {
                    min_next_run = cli::cast<Timer*>(this->list->GetByIndex_920ca5caddf75e3d(0))->next_run;
                }
                ms_wait = -1;
                if((min_next_run != 9223372036854775807L)) 
                {
                    int64_t diff = (min_next_run - System::DateTime::GetTimeMonotonic());
                    ms_wait = (int32_t)(diff / 10000L);
                    if((ms_wait < 0)) 
                    {
                        ms_wait = 0;
                    }
                }
            }
            this->changed->WaitOne_f0c7091fd69d769f(ms_wait);
        }
    }
    
    void Scheduler::ShrinkIfNeeded(System::Collections::ArrayList* list, int32_t initial) {
        int32_t capacity = list->get_Capacity_2220db8052d52582();
        int32_t count = list->get_Count_2354963792616712();
        if((((capacity > initial) && (count > 0)) && ((capacity / count) > 3))) 
        {
            list->set_Capacity_8cc9f300b61d27aa((count * 2));
        }
    }
    
    Scheduler* Scheduler::get_Instance() {
        return instance;
    }
    
}}
namespace System { namespace Threading {
    
    Scheduler*  Timer::scheduler;
    
    Timer::Timer()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void Timer::constructor(TimerCallback* callback, System::Object* state, int32_t dueTime, int32_t period) {
        Init(callback, state, (int64_t)(dueTime), (int64_t)(period));
    }
    
    void Timer::constructor(TimerCallback* callback, System::Object* state, int64_t dueTime, int64_t period) {
        Init(callback, state, dueTime, period);
    }
    
    void Timer::constructor(TimerCallback* callback, System::Object* state, System::TimeSpan dueTime, System::TimeSpan period) {
        Init(callback, state, (int64_t)dueTime->get_TotalMilliseconds(), (int64_t)period->get_TotalMilliseconds());
    }
    
    void Timer::constructor(TimerCallback* callback, System::Object* state, uint32_t dueTime, uint32_t period) {
        int64_t d = (dueTime ==  4294967295U) ? -1L : (int64_t)(dueTime);
        int64_t p = (period ==  4294967295U) ? -1L : (int64_t)(period);
        Init(callback, state, d, p);
    }
    
    void Timer::constructor(TimerCallback* callback) {
        Init(callback, this, -1L, -1L);
    }
    
    void Timer::static_constructor() {
    }
    
    void Timer::Init(TimerCallback* callback, System::Object* state, int64_t dueTime, int64_t period) {
        if((callback ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("callback"));
        }
        this->callback = callback;
        this->state = state;
        Change5(dueTime, period, true);
    }
    
    bool Timer::Change(int32_t dueTime, int32_t period) {
        return Change5((int64_t)(dueTime), (int64_t)(period), false);
    }
    
    bool Timer::Change2(System::TimeSpan dueTime, System::TimeSpan period) {
        return Change5((int64_t)dueTime->get_TotalMilliseconds(), (int64_t)period->get_TotalMilliseconds(), false);
    }
    
    bool Timer::Change3(uint32_t dueTime, uint32_t period) {
        int64_t d = (dueTime ==  4294967295U) ? -1L : (int64_t)(dueTime);
        int64_t p = (period ==  4294967295U) ? -1L : (int64_t)(period);
        return Change5(d, p, false);
    }
    
    void Timer::Dispose() {
        if(this->disposed) 
        {
            return;
        }
        this->disposed = true;
        scheduler->Remove(this);
    }
    
    bool Timer::Change4(int64_t dueTime, int64_t period) {
        return Change5(dueTime, period, false);
    }
    
    bool Timer::Change5(int64_t dueTime, int64_t period, bool first) {
        if((dueTime > 4294967294L)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("dueTime"), _T("Due time too large"));
        }
        if((period > 4294967294L)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("period"), _T("Period too large"));
        }
        if((dueTime < -1L)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("dueTime"));
        }
        if((period < -1L)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("period"));
        }
        if(this->disposed) 
        {
            return false;
        }
        this->due_time_ms = dueTime;
        this->period_ms = period;
        int64_t nr;
        if((dueTime ==  0L)) 
        {
            nr = 0L;
        }
         else 
        {
            if((dueTime < 0L)) 
            {
                nr = 9223372036854775807L;
                if(first) 
                {
                    this->next_run = nr;
                    return true;
                }
            }
             else 
            {
                nr = ((dueTime * 10000L) + System::DateTime::GetTimeMonotonic());
            }
        }
        scheduler->Change(this, nr);
        return true;
    }
    
    bool Timer::Dispose2(WaitHandle* notifyObject) {
        if((notifyObject ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("notifyObject"));
        }
        Dispose();
        NativeEventCalls::SetEvent_internal(notifyObject->get_Handle_95175e197a1d983a());
        return true;
    }
    
}}
namespace System { namespace Threading {
    
    void*  WaitHandle::InvalidHandle;
    
    WaitHandle::WaitHandle()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void WaitHandle::constructor() {
    }
    
    void WaitHandle::static_constructor() {
    }
    
    bool WaitHandle::WaitAll_internal(cli::array<WaitHandle*>* handles, int32_t ms, bool exitContext) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void WaitHandle::CheckArray(cli::array<WaitHandle*>* handles, bool waitAll) {
        if((handles ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("waitHandles"));
        }
        int32_t length = handles->get_Length();
        if((length > 64)) 
        {
            throw cli::gcnew<System::NotSupportedException>(_T("Too many handles"));
        }
        if((handles->get_Length() ==  0)) 
        {
            if(waitAll) 
            {
                throw cli::gcnew<System::ArgumentNullException>(_T("waitHandles"));
            }
             else 
            {
                throw cli::gcnew<System::ArgumentException>();
            }
        }
        for(auto tmp_635 : handles) {
            auto w = cli::cast<WaitHandle*>(tmp_635);
            {
                if((w ==  nullptr)) 
                {
                    throw cli::gcnew<System::ArgumentNullException>(_T("waitHandles"), _T("null handle"));
                }
                if((w->safe_wait_handle ==  nullptr)) 
                {
                    throw cli::gcnew<System::ArgumentException>(_T("null element found"), _T("waitHandle"));
                }
            }
        }
    }
    
    bool WaitHandle::WaitAll(cli::array<WaitHandle*>* waitHandles) {
        CheckArray(waitHandles, true);
        return WaitAll_internal(waitHandles, -1, false);
    }
    
    bool WaitHandle::WaitAll2(cli::array<WaitHandle*>* waitHandles, int32_t millisecondsTimeout, bool exitContext) {
        CheckArray(waitHandles, true);
        if((millisecondsTimeout < -1)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("millisecondsTimeout"));
        }
        {
            cli::finally_guard([&]() {
                if(exitContext) 
                {
                    System::Runtime::Remoting::Contexts::SynchronizationAttribute::EnterContext();
                }
            });
            if(exitContext) 
            {
                System::Runtime::Remoting::Contexts::SynchronizationAttribute::ExitContext();
            }
            return WaitAll_internal(waitHandles, millisecondsTimeout, false);
        }
    }
    
    bool WaitHandle::WaitAll3(cli::array<WaitHandle*>* waitHandles, System::TimeSpan timeout, bool exitContext) {
        CheckArray(waitHandles, true);
        int64_t ms = (int64_t)timeout->get_TotalMilliseconds();
        if(((ms < -1L) || (ms > 2147483647L))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("timeout"));
        }
        {
            cli::finally_guard([&]() {
                if(exitContext) 
                {
                    System::Runtime::Remoting::Contexts::SynchronizationAttribute::EnterContext();
                }
            });
            if(exitContext) 
            {
                System::Runtime::Remoting::Contexts::SynchronizationAttribute::ExitContext();
            }
            return WaitAll_internal(waitHandles, (int32_t)ms, exitContext);
        }
    }
    
    int32_t WaitHandle::WaitAny_internal(cli::array<WaitHandle*>* handles, int32_t ms, bool exitContext) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    int32_t WaitHandle::WaitAny(cli::array<WaitHandle*>* waitHandles) {
        CheckArray(waitHandles, false);
        return WaitAny_internal(waitHandles, -1, false);
    }
    
    int32_t WaitHandle::WaitAny2(cli::array<WaitHandle*>* waitHandles, int32_t millisecondsTimeout, bool exitContext) {
        CheckArray(waitHandles, false);
        if((millisecondsTimeout < -1)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("millisecondsTimeout"));
        }
        {
            cli::finally_guard([&]() {
                if(exitContext) 
                {
                    System::Runtime::Remoting::Contexts::SynchronizationAttribute::EnterContext();
                }
            });
            if(exitContext) 
            {
                System::Runtime::Remoting::Contexts::SynchronizationAttribute::ExitContext();
            }
            return WaitAny_internal(waitHandles, millisecondsTimeout, exitContext);
        }
    }
    
    int32_t WaitHandle::WaitAny3(cli::array<WaitHandle*>* waitHandles, System::TimeSpan timeout) {
        return WaitAny5(waitHandles, timeout, false);
    }
    
    int32_t WaitHandle::WaitAny4(cli::array<WaitHandle*>* waitHandles, int32_t millisecondsTimeout) {
        return WaitAny2(waitHandles, millisecondsTimeout, false);
    }
    
    int32_t WaitHandle::WaitAny5(cli::array<WaitHandle*>* waitHandles, System::TimeSpan timeout, bool exitContext) {
        CheckArray(waitHandles, false);
        int64_t ms = (int64_t)timeout->get_TotalMilliseconds();
        if(((ms < -1L) || (ms > 2147483647L))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("timeout"));
        }
        {
            cli::finally_guard([&]() {
                if(exitContext) 
                {
                    System::Runtime::Remoting::Contexts::SynchronizationAttribute::EnterContext();
                }
            });
            if(exitContext) 
            {
                System::Runtime::Remoting::Contexts::SynchronizationAttribute::ExitContext();
            }
            return WaitAny_internal(waitHandles, (int32_t)ms, exitContext);
        }
    }
    
    void WaitHandle::Close_c2b8b3b2024d18b6() {
        Dispose_76a5820d3865463e(true);
    }
    
    void WaitHandle::Dispose() {
        Close_c2b8b3b2024d18b6();
    }
    
    bool WaitHandle::WaitOne_internal(void* handle, int32_t ms, bool exitContext) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    void WaitHandle::Dispose_76a5820d3865463e(bool explicitDisposing) {
        if(!(this->disposed)) 
        {
            if((this->safe_wait_handle ==  nullptr)) 
            {
                return;
            }
            {
                cli::lock_guard{this};
                if(this->disposed) 
                {
                    return;
                }
                this->disposed = true;
                if((this->safe_wait_handle != nullptr)) 
                {
                    this->safe_wait_handle->Dispose();
                }
            }
        }
    }
    
    bool WaitHandle::SignalAndWait(WaitHandle* toSignal, WaitHandle* toWaitOn) {
        return SignalAndWait2(toSignal, toWaitOn, -1, false);
    }
    
    bool WaitHandle::SignalAndWait2(WaitHandle* toSignal, WaitHandle* toWaitOn, int32_t millisecondsTimeout, bool exitContext) {
        if((toSignal ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("toSignal"));
        }
        if((toWaitOn ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("toWaitOn"));
        }
        if((millisecondsTimeout < -1)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("millisecondsTimeout"));
        }
        return SignalAndWait_Internal(toSignal->get_Handle_95175e197a1d983a(), toWaitOn->get_Handle_95175e197a1d983a(), millisecondsTimeout, exitContext);
    }
    
    bool WaitHandle::SignalAndWait3(WaitHandle* toSignal, WaitHandle* toWaitOn, System::TimeSpan timeout, bool exitContext) {
        double ms = timeout->get_TotalMilliseconds();
        if((ms > 2147483647.)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("timeout"));
        }
        return SignalAndWait2(toSignal, toWaitOn, System::Convert::ToInt326(ms), false);
    }
    
    bool WaitHandle::SignalAndWait_Internal(void* toSignal, void* toWaitOn, int32_t ms, bool exitContext) {
      // TODO: "Unimplemented external method!"
      throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool WaitHandle::WaitOne_a04a6b7360612836() {
        CheckDisposed();
        bool release = false;
        {
            cli::finally_guard([&]() {
                if(release) 
                {
                    this->safe_wait_handle->DangerousRelease();
                }
            });
            this->safe_wait_handle->DangerousAddRef(release);
            return WaitOne_internal(this->safe_wait_handle->DangerousGetHandle(), -1, false);
        }
    }
    
    bool WaitHandle::WaitOne_dfdecf18d16bd99(int32_t millisecondsTimeout, bool exitContext) {
        CheckDisposed();
        if((millisecondsTimeout < -1)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("millisecondsTimeout"));
        }
        bool release = false;
        {
            cli::finally_guard([&]() {
                if(exitContext) 
                {
                    System::Runtime::Remoting::Contexts::SynchronizationAttribute::EnterContext();
                }
                if(release) 
                {
                    this->safe_wait_handle->DangerousRelease();
                }
            });
            if(exitContext) 
            {
                System::Runtime::Remoting::Contexts::SynchronizationAttribute::ExitContext();
            }
            this->safe_wait_handle->DangerousAddRef(release);
            return WaitOne_internal(this->safe_wait_handle->DangerousGetHandle(), millisecondsTimeout, exitContext);
        }
    }
    
    bool WaitHandle::WaitOne_f0c7091fd69d769f(int32_t millisecondsTimeout) {
        return WaitOne_dfdecf18d16bd99(millisecondsTimeout, false);
    }
    
    bool WaitHandle::WaitOne_14400f9bef05768b(System::TimeSpan timeout) {
        return WaitOne_ad60f64bec76902d(timeout, false);
    }
    
    bool WaitHandle::WaitOne_ad60f64bec76902d(System::TimeSpan timeout, bool exitContext) {
        CheckDisposed();
        int64_t ms = (int64_t)timeout->get_TotalMilliseconds();
        if(((ms < -1L) || (ms > 2147483647L))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("timeout"));
        }
        bool release = false;
        {
            cli::finally_guard([&]() {
                if(exitContext) 
                {
                    System::Runtime::Remoting::Contexts::SynchronizationAttribute::EnterContext();
                }
                if(release) 
                {
                    this->safe_wait_handle->DangerousRelease();
                }
            });
            if(exitContext) 
            {
                System::Runtime::Remoting::Contexts::SynchronizationAttribute::ExitContext();
            }
            this->safe_wait_handle->DangerousAddRef(release);
            return WaitOne_internal(this->safe_wait_handle->DangerousGetHandle(), (int32_t)ms, exitContext);
        }
    }
    
    void WaitHandle::CheckDisposed() {
        if((this->disposed || (this->safe_wait_handle ==  nullptr))) 
        {
            throw cli::gcnew<System::ObjectDisposedException>(System::Object::GetType()->get_FullName_7e8fa72ba225e1a4());
        }
    }
    
    bool WaitHandle::WaitAll4(cli::array<WaitHandle*>* waitHandles, int32_t millisecondsTimeout) {
        return WaitAll2(waitHandles, millisecondsTimeout, false);
    }
    
    bool WaitHandle::WaitAll5(cli::array<WaitHandle*>* waitHandles, System::TimeSpan timeout) {
        return WaitAll3(waitHandles, timeout, false);
    }
    
    void* WaitHandle::get_Handle_95175e197a1d983a() {
        return this->safe_wait_handle->DangerousGetHandle();
    }
    
    void* WaitHandle::set_Handle_880f68f3ace4e24(void* value) {
        if(::System::IntPtr::op_Equality(value, InvalidHandle)) 
        {
            this->safe_wait_handle = cli::gcnew<Microsoft::Win32::SafeHandles::SafeWaitHandle>(InvalidHandle, false);
        }
         else 
        {
            this->safe_wait_handle = cli::gcnew<Microsoft::Win32::SafeHandles::SafeWaitHandle>(value, true);
        }
        return get_Handle_95175e197a1d983a();
    }
    
    Microsoft::Win32::SafeHandles::SafeWaitHandle* WaitHandle::get_SafeWaitHandle() {
        return this->safe_wait_handle;
    }
    
    Microsoft::Win32::SafeHandles::SafeWaitHandle* WaitHandle::set_SafeWaitHandle(Microsoft::Win32::SafeHandles::SafeWaitHandle* value) {
        if((value ==  nullptr)) 
        {
            this->safe_wait_handle = cli::gcnew<Microsoft::Win32::SafeHandles::SafeWaitHandle>(InvalidHandle, false);
        }
         else 
        {
            this->safe_wait_handle = value;
        }
        return get_SafeWaitHandle();
    }
    
}}
namespace System { namespace Threading {
    
    
    void WaitHandleCannotBeOpenedException::constructor() {
    }
    
    void WaitHandleCannotBeOpenedException::constructor(System::String* message) {
    }
    
    void WaitHandleCannotBeOpenedException::constructor(System::String* message, System::Exception* innerException) {
    }
    
    void WaitHandleCannotBeOpenedException::constructor(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
    }
    
}}
namespace System { namespace Threading { namespace Tasks {
    
    
}}}
namespace System { namespace Threading { namespace Tasks {
    
    
}}}
namespace System { namespace Threading { namespace Tasks {
    
    
    void ManualEventSlot::constructor(System::Threading::ManualResetEventSlim* evt) {
        this->evt = evt;
    }
    
    void ManualEventSlot::Execute() {
        this->evt->Set();
    }
    
}}}
namespace System { namespace Threading { namespace Tasks {
    
    
    void CountdownEventSlot::constructor(System::Threading::CountdownEvent* evt) {
        this->evt = evt;
    }
    
    void CountdownEventSlot::Execute() {
        this->evt->Signal();
    }
    
}}}
namespace System { namespace Threading { namespace Tasks {
    
    
    void StealRange::constructor(int32_t fromInclusive, int32_t i, int32_t step) {
        this->V64->Actual = (fromInclusive + (i * step));
    }
    
}}}
namespace System { namespace Threading { namespace Tasks {
    
    bool  Parallel::sixtyfour;
    System::Func<System::Object*>*  Parallel::__f__am_cache0;
    System::Action2<System::Object*>*  Parallel::__f__am_cache1;
    System::Func<System::Object*>*  Parallel::__f__am_cache2;
    System::Action2<System::Object*>*  Parallel::__f__am_cache3;
    
    Parallel::Parallel()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void Parallel::static_constructor() {
    }
    
    int32_t Parallel::GetBestWorkerNumber() {
        return GetBestWorkerNumber2(TaskScheduler::get_Current());
    }
    
    int32_t Parallel::GetBestWorkerNumber2(TaskScheduler* scheduler) {
        return scheduler->get_MaximumConcurrencyLevel_a56c57882f7ce248();
    }
    
    int32_t Parallel::GetBestWorkerNumber3(int32_t from, int32_t to, ParallelOptions* options, int32_t step) {
        int32_t num = GetBestWorkerNumber2(options->get_TaskScheduler());
        if(((options != nullptr) && (options->get_MaxDegreeOfParallelism() != -1))) 
        {
            num = options->get_MaxDegreeOfParallelism();
        }
        if(((step = ((to - from) / num)) < (5))) 
        {
            step = 5;
            num = ((to - from) / 5);
            if((num < 1)) 
            {
                num = 1;
            }
        }
        return num;
    }
    
    void Parallel::HandleExceptions(System::Collections::Generic::IEnumerable2<Task*>* tasks) {
        HandleExceptions2(tasks, nullptr);
    }
    
    void Parallel::HandleExceptions2(System::Collections::Generic::IEnumerable2<Task*>* tasks, ExternalInfos* infos) {
        System::Collections::Generic::List<System::Exception*> *exs = cli::gcnew<System::Collections::Generic::List<System::Exception*>>();
        for(auto tmp_636 : tasks) {
            auto t = cli::cast<Task*>(tmp_636);
            {
                if((t->get_Exception() != nullptr)) 
                {
                    exs->Add(t->get_Exception());
                }
            }
        }
        if((exs->get_Count() > 0)) 
        {
            if((infos != nullptr)) 
            {
                infos->IsExceptional = true;
            }
            throw cli::gcnew<System::AggregateException>(exs)->Flatten();
        }
    }
    
    void Parallel::InitTasks(cli::array<Task*>* tasks, int32_t count, System::Action* action, ParallelOptions* options) {
        TaskCreationOptions creation = (TaskCreationOptions)6L;
        for(int32_t i = 0; (i < count); i++){
            if((options ==  nullptr)) 
            {
                tasks->at(i) = Task::get_Factory()->StartNew3(action, creation);
            }
             else 
            {
                tasks->at(i) = Task::get_Factory()->StartNew4(action, options->get_CancellationToken(), creation, options->get_TaskScheduler());
            }
        }
    }
    
    ParallelLoopResult Parallel::For(int32_t fromInclusive, int32_t toExclusive, System::Action2<int32_t>* body) {
        return For3(fromInclusive, toExclusive, ParallelOptions::Default2, body);
    }
    
    ParallelLoopResult Parallel::For2(int32_t fromInclusive, int32_t toExclusive, System::Action4<int32_t, ParallelLoopState*>* body) {
        return For4(fromInclusive, toExclusive, ParallelOptions::Default2, body);
    }
    
    ParallelLoopResult Parallel::For3(int32_t fromInclusive, int32_t toExclusive, ParallelOptions* parallelOptions, System::Action2<int32_t>* body) {
        auto storey_637 = cli::gcnew<_For_c__AnonStorey1D>();
        storey_637->body = body;
        return For4(fromInclusive, toExclusive, parallelOptions, cli::bind(storey_637, &_For_c__AnonStorey1D::__m__16));
    }
    
    ParallelLoopResult Parallel::For4(int32_t fromInclusive, int32_t toExclusive, ParallelOptions* parallelOptions, System::Action4<int32_t, ParallelLoopState*>* body) {
        auto storey_638 = cli::gcnew<_For_c__AnonStorey1E>();
        storey_638->body = body;
        return For_12<System::Object*>(fromInclusive, toExclusive, parallelOptions, cli::bind([&] () -> System::Object* {
            return nullptr;
        }
        ), cli::bind(storey_638, &_For_c__AnonStorey1E::__m__18), cli::bind([&] (System::Object* _) -> void {
        }
        ));
    }
    
    ParallelLoopResult Parallel::For5(int64_t fromInclusive, int64_t toExclusive, System::Action2<int64_t>* body) {
        return For7(fromInclusive, toExclusive, ParallelOptions::Default2, body);
    }
    
    ParallelLoopResult Parallel::For6(int64_t fromInclusive, int64_t toExclusive, System::Action4<int64_t, ParallelLoopState*>* body) {
        return For8(fromInclusive, toExclusive, ParallelOptions::Default2, body);
    }
    
    ParallelLoopResult Parallel::For7(int64_t fromInclusive, int64_t toExclusive, ParallelOptions* parallelOptions, System::Action2<int64_t>* body) {
        auto storey_639 = cli::gcnew<_For_c__AnonStorey20>();
        storey_639->body = body;
        return For8(fromInclusive, toExclusive, parallelOptions, cli::bind(storey_639, &_For_c__AnonStorey20::__m__1B));
    }
    
    ParallelLoopResult Parallel::For8(int64_t fromInclusive, int64_t toExclusive, ParallelOptions* parallelOptions, System::Action4<int64_t, ParallelLoopState*>* body) {
        auto storey_640 = cli::gcnew<_For_c__AnonStorey21>();
        storey_640->body = body;
        return For_14<System::Object*>(fromInclusive, toExclusive, parallelOptions, cli::bind([&] () -> System::Object* {
            return nullptr;
        }
        ), cli::bind(storey_640, &_For_c__AnonStorey21::__m__1D), cli::bind([&] (System::Object* _) -> void {
        }
        ));
    }
    
    void Parallel::Invoke(cli::array<System::Action*>* actions) {
        if((actions ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("actions"));
        }
        Invoke2(ParallelOptions::Default2, actions);
    }
    
    void Parallel::Invoke2(ParallelOptions* parallelOptions, cli::array<System::Action*>* actions) {
        if((parallelOptions ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("parallelOptions"));
        }
        if((actions ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("actions"));
        }
        if((actions->get_Length() ==  0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("actions is empty"));
        }
        for(auto tmp_641 : actions) {
            auto a = cli::cast<System::Action*>(tmp_641);
            if((a ==  nullptr)) 
            {
                throw cli::gcnew<System::ArgumentException>(_T("One action in actions is null"), _T("actions"));
            }
        }
        if((actions->get_Length() ==  1)) 
        {
            actions->at(0)->Invoke();
            return;
        }
        cli::array<Task*> *ts = (new cli::array<Task*>(actions->get_Length()));
        for(int32_t i = 0; (i < ts->get_Length()); i++) {
            ts->at(i) = Task::get_Factory()->StartNew4(actions->at(i), parallelOptions->get_CancellationToken(), TaskCreationOptions::None, parallelOptions->get_TaskScheduler());
        }
        try {
            Task::WaitAll2(ts, parallelOptions->get_CancellationToken());
        }
        catch(...) {
            HandleExceptions(ts);
        }
    }
    
    cli::array<Task*>* Parallel::SpawnBestNumber(System::Action* action, System::Action* callback) {
        return SpawnBestNumber2(action, -1, callback);
    }
    
    cli::array<Task*>* Parallel::SpawnBestNumber2(System::Action* action, int32_t dop, System::Action* callback) {
        return SpawnBestNumber3(action, dop, false, callback);
    }
    
    cli::array<Task*>* Parallel::SpawnBestNumber3(System::Action* action, int32_t dop, bool wait, System::Action* callback) {
        auto storey_642 = cli::gcnew<_SpawnBestNumber_c__AnonStorey30>();
        storey_642->action = action;
        storey_642->callback = callback;
        int32_t num = (dop ==  -1) ? wait ? (GetBestWorkerNumber() + 1) : GetBestWorkerNumber() : dop;
        storey_642->evt = cli::gcnew<System::Threading::CountdownEvent>(num);
        cli::array<Task*> *tasks = (new cli::array<Task*>(num));
        for(int32_t i = 0; (i < num); i++){
            tasks->at(i) = Task::get_Factory()->StartNew(cli::bind(storey_642, &_SpawnBestNumber_c__AnonStorey30::__m__45));
        }
        if(wait) 
        {
            Task::WaitAll(tasks);
        }
        return tasks;
    }
    
    System::Object* Parallel::_For_m__17() {
        return nullptr;
    }
    
    void Parallel::_For_m__19(System::Object* _) {
    }
    
    System::Object* Parallel::_For_m__1C() {
        return nullptr;
    }
    
    void Parallel::_For_m__1E(System::Object* _) {
    }
    
}}}
namespace System { namespace Threading { namespace Tasks {
    
    
    void ExternalInfos::constructor() {
    }
    
}}}
namespace System { namespace Threading { namespace Tasks {
    
    
    void ParallelLoopState::constructor(ExternalInfos* extInfos) {
        this->extInfos = extInfos;
    }
    
    void ParallelLoopState::Break() {
        if(this->extInfos->IsStopped) 
        {
            throw cli::gcnew<System::InvalidOperationException>(_T("The Stop method was previously called. Break and Stop may not be used in combination by iterations of the same loop."));
        }
        bool result = this->extInfos->IsBroken->Exchange(true);
        if(!(result)) 
        {
            this->extInfos->LowestBreakIteration = cli::wrap_nullable((int64_t)(this->get_CurrentIteration()));
        }
    }
    
    void ParallelLoopState::Stop() {
        if(this->extInfos->IsBroken->get_Value()) 
        {
            throw cli::gcnew<System::InvalidOperationException>(_T("The Break method was previously called. Break and Stop may not be used in combination by iterations of the same loop."));
        }
        this->extInfos->IsStopped = true;
    }
    
    bool ParallelLoopState::get_IsStopped() {
        return this->extInfos->IsStopped;
    }
    
    bool ParallelLoopState::get_IsExceptional() {
        return this->extInfos->IsExceptional;
    }
    
    System::Nullable2<int64_t> ParallelLoopState::get_LowestBreakIteration() {
        return this->extInfos->LowestBreakIteration;
    }
    
    int32_t ParallelLoopState::get_CurrentIteration() {
        return this->_CurrentIteration_k__BackingField;
    }
    
    int32_t ParallelLoopState::set_CurrentIteration(int32_t value) {
        this->_CurrentIteration_k__BackingField = value;
        return get_CurrentIteration();
    }
    
    bool ParallelLoopState::get_ShouldExitCurrentIteration() {
        return (this->get_IsExceptional() || this->get_IsStopped());
    }
    
}}}
namespace System { namespace Threading { namespace Tasks {
    
    ParallelOptions*  ParallelOptions::Default2;
    
    ParallelOptions::ParallelOptions()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void ParallelOptions::constructor() {
        this->set_MaxDegreeOfParallelism(-1);
        this->set_CancellationToken(System::Threading::CancellationToken::get_None());
        this->set_TaskScheduler(TaskScheduler::get_Current());
    }
    
    void ParallelOptions::static_constructor() {
    }
    
    System::Threading::CancellationToken ParallelOptions::get_CancellationToken() {
        return this->_CancellationToken_k__BackingField;
    }
    
    System::Threading::CancellationToken ParallelOptions::set_CancellationToken(System::Threading::CancellationToken value) {
        this->_CancellationToken_k__BackingField = value;
        return get_CancellationToken();
    }
    
    int32_t ParallelOptions::get_MaxDegreeOfParallelism() {
        return this->_MaxDegreeOfParallelism_k__BackingField;
    }
    
    int32_t ParallelOptions::set_MaxDegreeOfParallelism(int32_t value) {
        this->_MaxDegreeOfParallelism_k__BackingField = value;
        return get_MaxDegreeOfParallelism();
    }
    
    TaskScheduler* ParallelOptions::get_TaskScheduler() {
        return this->_TaskScheduler_k__BackingField;
    }
    
    TaskScheduler* ParallelOptions::set_TaskScheduler(TaskScheduler* value) {
        this->_TaskScheduler_k__BackingField = value;
        return get_TaskScheduler();
    }
    
}}}
namespace System { namespace Threading { namespace Tasks {
    
    
}}}
namespace System { namespace Threading { namespace Tasks {
    
    
    void SynchronizationContextScheduler::constructor(System::Threading::SynchronizationContext* ctx) {
        this->ctx = ctx;
        this->callback = cli::bind(this, &SynchronizationContextScheduler::TaskLaunchWrapper);
    }
    
    void SynchronizationContextScheduler::QueueTask_cbe2927cfadeb04c(Task* task) {
        this->ctx->Post_3eaec456ea854a8e(this->callback, task);
    }
    
    void SynchronizationContextScheduler::TaskLaunchWrapper(System::Object* obj) {
        TaskScheduler::TryExecuteTask(cli::cast<Task*>(obj));
    }
    
    System::Collections::Generic::IEnumerable2<Task*>* SynchronizationContextScheduler::GetScheduledTasks_1a3a2b32f93a346c() {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool SynchronizationContextScheduler::TryDequeue_e11e522f718d830b(Task* task) {
        return false;
    }
    
    bool SynchronizationContextScheduler::TryExecuteTaskInline_89cb38840fe95613(Task* task, bool taskWasPreviouslyQueued) {
        this->ctx->Send_14bb59dd079cf544(this->callback, task);
        return true;
    }
    
    int32_t SynchronizationContextScheduler::get_MaximumConcurrencyLevel_a56c57882f7ce248() {
        return TaskScheduler::get_MaximumConcurrencyLevel_a56c57882f7ce248();
    }
    
}}}
namespace System { namespace Threading { namespace Tasks {
    
    Task*  Task::current;
    System::Action2<Task*>*  Task::childWorkAdder;
    int32_t  Task::id;
    TaskFactory*  Task::defaultFactory;
    System::Action2<System::Object*>*  Task::__f__am_cache0;
    
    Task::Task()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void Task::constructor(System::Action* action) {
    }
    
    void Task::constructor(System::Action* action, TaskCreationOptions creationOptions) {
    }
    
    void Task::constructor(System::Action* action, System::Threading::CancellationToken cancellationToken) {
    }
    
    void Task::constructor(System::Action* action, System::Threading::CancellationToken cancellationToken, TaskCreationOptions creationOptions) {
        if((action ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("action"));
        }
        if((((int32_t)(creationOptions) > 7) || ((int32_t)(creationOptions) < 0))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("creationOptions"));
        }
    }
    
    void Task::constructor(System::Action2<System::Object*>* action, System::Object* state) {
    }
    
    void Task::constructor(System::Action2<System::Object*>* action, System::Object* state, TaskCreationOptions creationOptions) {
    }
    
    void Task::constructor(System::Action2<System::Object*>* action, System::Object* state, System::Threading::CancellationToken cancellationToken) {
    }
    
    void Task::constructor(System::Action2<System::Object*>* action, System::Object* state, System::Threading::CancellationToken cancellationToken, TaskCreationOptions creationOptions) {
        if((action ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("action"));
        }
        if((((int32_t)(creationOptions) > 7) || ((int32_t)(creationOptions) < 0))) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("creationOptions"));
        }
    }
    
    void Task::constructor(TaskActionInvoker* invoker, System::Object* state, System::Threading::CancellationToken cancellationToken, TaskCreationOptions creationOptions, Task* parent) {
    }
    
    void Task::constructor(TaskActionInvoker* invoker, System::Object* state, System::Threading::CancellationToken cancellationToken, TaskCreationOptions creationOptions, Task* parent, Task* contAncestor) {
        this->invoker = invoker;
        this->taskCreationOptions = creationOptions;
        this->state = state;
        this->taskId = System::Threading::Interlocked::Increment(id);
        this->status = cancellationToken->get_IsCancellationRequested() ? TaskStatus::Canceled : TaskStatus::Created;
        this->token = cancellationToken;
        this->parent = parent;
        this->contAncestor = contAncestor;
        if((CheckTaskOptions(this->taskCreationOptions, TaskCreationOptions::AttachedToParent) && (parent != nullptr))) 
        {
            parent->AddChild();
        }
        if(this->token->get_CanBeCanceled()) 
        {
            this->cancellationRegistration = cli::wrap_nullable(this->token->Register3(cli::bind([&] (System::Object* l) -> void {
                 cli::cast<Task*>(l)->CancelReal();
            }
            ), this));
        }
    }
    
    void Task::static_constructor() {
    }
    
    bool Task::CheckTaskOptions(TaskCreationOptions opt, TaskCreationOptions member) {
        return ((int32_t)(((int32_t)(opt) & (int32_t)(member))) ==  (int32_t)(member));
    }
    
    void Task::Start() {
        Start2(TaskScheduler::get_Current());
    }
    
    void Task::Start2(TaskScheduler* scheduler) {
        if((scheduler ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("scheduler"));
        }
        if(((int32_t)(this->status) >= 2)) 
        {
            throw cli::gcnew<System::InvalidOperationException>(_T("The Task is not in a valid state to be started."));
        }
        if(this->get_IsContinuation()) 
        {
            throw cli::gcnew<System::InvalidOperationException>(_T("Start may not be called on a continuation task"));
        }
        SetupScheduler(scheduler);
        Schedule();
    }
    
    void Task::SetupScheduler(TaskScheduler* scheduler) {
        this->scheduler = scheduler;
        this->set_Status(TaskStatus::WaitingForActivation);
    }
    
    void Task::RunSynchronously() {
        RunSynchronously2(TaskScheduler::get_Current());
    }
    
    void Task::RunSynchronously2(TaskScheduler* scheduler) {
        if((scheduler ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("scheduler"));
        }
        if(((int32_t)(this->get_Status()) > 1)) 
        {
            throw cli::gcnew<System::InvalidOperationException>(_T("The task is not in a valid state to be started"));
        }
        SetupScheduler(scheduler);
        TaskStatus saveStatus = this->status;
        this->set_Status(TaskStatus::WaitingToRun);
        try {
            if(scheduler->RunInline(this)) 
            {
                return;
            }
        }
        catch(System::Exception* inner) {
            throw cli::gcnew<TaskSchedulerException>(inner);
        }
        this->set_Status(saveStatus);
        Start2(scheduler);
        Wait();
    }
    
    Task* Task::ContinueWith(System::Action2<Task*>* continuationAction) {
        return ContinueWith2(continuationAction, TaskContinuationOptions::None);
    }
    
    Task* Task::ContinueWith2(System::Action2<Task*>* continuationAction, TaskContinuationOptions continuationOptions) {
        return ContinueWith5(continuationAction, System::Threading::CancellationToken::get_None(), continuationOptions, TaskScheduler::get_Current());
    }
    
    Task* Task::ContinueWith3(System::Action2<Task*>* continuationAction, System::Threading::CancellationToken cancellationToken) {
        return ContinueWith5(continuationAction, cancellationToken, TaskContinuationOptions::None, TaskScheduler::get_Current());
    }
    
    Task* Task::ContinueWith4(System::Action2<Task*>* continuationAction, TaskScheduler* scheduler) {
        return ContinueWith5(continuationAction, System::Threading::CancellationToken::get_None(), TaskContinuationOptions::None, scheduler);
    }
    
    Task* Task::ContinueWith5(System::Action2<Task*>* continuationAction, System::Threading::CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler* scheduler) {
        if((continuationAction ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("continuationAction"));
        }
        if((scheduler ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("scheduler"));
        }
        return ContinueWith6(TaskActionInvoker::Create3(continuationAction), cancellationToken, continuationOptions, scheduler);
    }
    
    Task* Task::ContinueWith6(TaskActionInvoker* invoker, System::Threading::CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler* scheduler) {
        Task *continuation = cli::gcnew<Task>(invoker, nullptr, cancellationToken, GetCreationOptions(continuationOptions), this->parent, this);
        ContinueWithCore(continuation, continuationOptions, scheduler);
        return continuation;
    }
    
    void Task::ContinueWithCore(Task* continuation, TaskContinuationOptions options, TaskScheduler* scheduler) {
        const TaskContinuationOptions wrongRan = (TaskContinuationOptions)458752L;
        const TaskContinuationOptions wrongCanceled = (TaskContinuationOptions)458752L;
        const TaskContinuationOptions wrongFaulted = (TaskContinuationOptions)458752L;
        if(((((int32_t)(((int32_t)(options) & 458752)) ==  458752) || ((int32_t)(((int32_t)(options) & 458752)) ==  458752)) || ((int32_t)(((int32_t)(options) & 458752)) ==  458752))) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("continuationOptions"), _T("Some options are mutually exclusive"));
        }
        continuation->scheduler = scheduler;
        continuation->set_Status(TaskStatus::WaitingForActivation);
        ContinueWith7(cli::gcnew<TaskContinuation>(continuation, options));
    }
    
    void Task::ContinueWith7(IContinuation* continuation) {
        if(this->get_IsCompleted()) 
        {
            continuation->Execute_e0ae61e6f450d11e();
            return;
        }
        this->continuations->Add(continuation);
        if((this->get_IsCompleted() && this->continuations->Remove(continuation))) 
        {
            continuation->Execute_e0ae61e6f450d11e();
        }
    }
    
    void Task::RemoveContinuation(IContinuation* continuation) {
        this->continuations->Remove(continuation);
    }
    
    TaskCreationOptions Task::GetCreationOptions(TaskContinuationOptions kind) {
        TaskCreationOptions options = TaskCreationOptions::None;
        if(((int32_t)(((int32_t)(kind) & 4)) > 0)) 
        {
            (options = (TaskCreationOptions)(((int32_t)(options) | 4)));
        }
        if(((int32_t)(((int32_t)(kind) & 1)) > 0)) 
        {
            (options = (TaskCreationOptions)(((int32_t)(options) | 1)));
        }
        if(((int32_t)(((int32_t)(kind) & 2)) > 0)) 
        {
            (options = (TaskCreationOptions)(((int32_t)(options) | 2)));
        }
        return options;
    }
    
    void Task::Schedule() {
        this->set_Status(TaskStatus::WaitingToRun);
        if((((this->scheduler != TaskScheduler::get_Current()) || (childWorkAdder ==  nullptr)) || CheckTaskOptions(this->taskCreationOptions, TaskCreationOptions::PreferFairness))) 
        {
            this->scheduler->QueueTask_cbe2927cfadeb04c(this);
        }
         else 
        {
            childWorkAdder->Invoke(this);
        }
    }
    
    void Task::ThreadStart2() {
        if(!(this->executing->TryRelaxedSet())) 
        {
            return;
        }
        if(((System::Nullable2<System::Threading::CancellationTokenRegistration>)(cli::unwrap_nullable(this->cancellationRegistration)) != nullptr)) 
        {
            this->cancellationRegistration->get_Value()->Dispose();
            this->cancellationRegistration = nullptr;
        }
        current = this;
        TaskScheduler::set_Current(this->scheduler);
        if(!(this->token->get_IsCancellationRequested())) 
        {
            this->status = TaskStatus::Running;
            try {
                InnerInvoke();
            }
            catch(System::OperationCanceledException* oce) {
                if((System::Threading::CancellationToken::op_Inequality(this->token, System::Threading::CancellationToken::get_None()) && System::Threading::CancellationToken::op_Equality(oce->get_CancellationToken(), this->token))) 
                {
                    CancelReal();
                }
                 else 
                {
                    HandleGenericException(oce);
                }
            }
            catch(System::Exception* e) {
                HandleGenericException(e);
            }
        }
         else 
        {
            CancelReal();
        }
        Finish();
    }
    
    bool Task::TrySetCanceled() {
        if(this->get_IsCompleted()) 
        {
            return false;
        }
        if(!(this->executing->TryRelaxedSet())) 
        {
            System::Threading::SpinWait sw = cli::ctor<System::Threading::SpinWait>();
            while(!(this->get_IsCompleted())) sw->SpinOnce();
            return false;
        }
        CancelReal();
        return true;
    }
    
    bool Task::TrySetException(System::AggregateException* aggregate) {
        if(this->get_IsCompleted()) 
        {
            return false;
        }
        if(!(this->executing->TryRelaxedSet())) 
        {
            System::Threading::SpinWait sw = cli::ctor<System::Threading::SpinWait>();
            while(!(this->get_IsCompleted())) sw->SpinOnce();
            return false;
        }
        HandleGenericException2(aggregate);
        return true;
    }
    
    void Task::Execute() {
        ThreadStart2();
    }
    
    void Task::AddChild() {
        if((this->childTasks ==  nullptr)) 
        {
            System::Threading::Interlocked::template CompareExchange_1<System::Threading::CountdownEvent*>(this->childTasks, cli::gcnew<System::Threading::CountdownEvent>(1), nullptr);
        }
        this->childTasks->AddCount();
    }
    
    void Task::ChildCompleted(System::AggregateException* childEx) {
        if((childEx != nullptr)) 
        {
            if((this->get_ExceptionSlot()->ChildExceptions ==  nullptr)) 
            {
                System::Threading::Interlocked::template CompareExchange_1<System::Collections::Concurrent::ConcurrentQueue<System::AggregateException*>*>(this->get_ExceptionSlot()->ChildExceptions, cli::gcnew<System::Collections::Concurrent::ConcurrentQueue<System::AggregateException*>>(), nullptr);
            }
            this->get_ExceptionSlot()->ChildExceptions->Enqueue(childEx);
        }
        if((this->childTasks->Signal() && ((int32_t)(this->status) ==  4))) 
        {
            this->set_Status(TaskStatus::RanToCompletion);
            ProcessChildExceptions();
            ProcessCompleteDelegates();
            if((CheckTaskOptions(this->taskCreationOptions, TaskCreationOptions::AttachedToParent) && (this->parent != nullptr))) 
            {
                this->parent->ChildCompleted(this->get_Exception());
            }
        }
    }
    
    void Task::InnerInvoke() {
        if(this->get_IsContinuation()) 
        {
            this->invoker->Invoke_a5a01f61088bfd9f(this->contAncestor, this->state, this);
        }
         else 
        {
            this->invoker->Invoke_a5a01f61088bfd9f(this, this->state, this);
        }
    }
    
    void Task::Finish() {
        if((this->childTasks != nullptr)) 
        {
            this->childTasks->Signal();
        }
        if(((int32_t)(this->status) ==  3)) 
        {
            if(((this->childTasks ==  nullptr) || this->childTasks->get_IsSet())) 
            {
                this->set_Status(TaskStatus::RanToCompletion);
            }
             else 
            {
                this->set_Status(TaskStatus::WaitingForChildrenToComplete);
            }
        }
        if(((int32_t)(this->status) ==  5)) 
        {
            ProcessCompleteDelegates();
        }
        current = nullptr;
        TaskScheduler::set_Current(nullptr);
        if(this->cancellationRegistration->get_HasValue()) 
        {
            this->cancellationRegistration->get_Value()->Dispose();
        }
        if(((CheckTaskOptions(this->taskCreationOptions, TaskCreationOptions::AttachedToParent) && (this->parent != nullptr)) && ((int32_t)(this->status) != 4))) 
        {
            this->parent->ChildCompleted(this->get_Exception());
        }
    }
    
    void Task::ProcessCompleteDelegates() {
        if(this->continuations->get_HasElements()) 
        {
            IContinuation *continuation;
            while(this->continuations->TryGetNextCompletion(continuation)) continuation->Execute_e0ae61e6f450d11e();
        }
    }
    
    void Task::ProcessChildExceptions() {
        if(((this->exSlot ==  nullptr) || (this->exSlot->ChildExceptions ==  nullptr))) 
        {
            return;
        }
        if((this->get_ExceptionSlot()->Exception2 ==  nullptr)) 
        {
            this->exSlot->Exception2 = cli::gcnew<System::AggregateException>();
        }
        System::AggregateException *childEx;
        while(this->exSlot->ChildExceptions->TryDequeue(childEx)) this->exSlot->Exception2->AddChildException(childEx);
    }
    
    void Task::CancelReal() {
        this->set_Status(TaskStatus::Canceled);
        ProcessCompleteDelegates();
    }
    
    void Task::HandleGenericException(System::Exception* e) {
        HandleGenericException2(cli::gcnew<System::AggregateException>((new cli::array<System::Exception*>({e}))));
    }
    
    void Task::HandleGenericException2(System::AggregateException* e) {
        this->get_ExceptionSlot()->Exception2 = e;
        System::Threading::Thread::MemoryBarrier();
        this->set_Status(TaskStatus::Faulted);
        ProcessCompleteDelegates();
    }
    
    void Task::WaitOnChildren() {
        if((((int32_t)(this->get_Status()) ==  4) && (this->childTasks != nullptr))) 
        {
            this->childTasks->Wait();
        }
    }
    
    void Task::Wait() {
        Wait5(-1, System::Threading::CancellationToken::get_None());
    }
    
    void Task::Wait2(System::Threading::CancellationToken cancellationToken) {
        Wait5(-1, cancellationToken);
    }
    
    bool Task::Wait3(System::TimeSpan timeout) {
        return Wait5(CheckTimeout(timeout), System::Threading::CancellationToken::get_None());
    }
    
    bool Task::Wait4(int32_t millisecondsTimeout) {
        return Wait5(millisecondsTimeout, System::Threading::CancellationToken::get_None());
    }
    
    bool Task::Wait5(int32_t millisecondsTimeout, System::Threading::CancellationToken cancellationToken) {
        if((millisecondsTimeout < -1)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("millisecondsTimeout"));
        }
        bool result = true;
        if(!(this->get_IsCompleted())) 
        {
            if(((((int32_t)(this->get_Status()) ==  2) && (millisecondsTimeout ==  -1)) && (this->scheduler != nullptr))) 
            {
                Execute();
            }
            if(!(this->get_IsCompleted())) 
            {
                System::Threading::ManualResetEventSlim *evt = cli::gcnew<System::Threading::ManualResetEventSlim>();
                ManualEventSlot *slot = cli::gcnew<ManualEventSlot>(evt);
                {
                    cli::finally_guard([&]() {
                        if(!(result)) 
                        {
                            RemoveContinuation(slot);
                        }
                        evt->Dispose();
                    });
                    ContinueWith7(slot);
                    result = evt->Wait5(millisecondsTimeout, cancellationToken);
                }
            }
        }
        if(this->get_IsCanceled()) 
        {
            throw cli::gcnew<System::AggregateException>((new cli::array<System::Exception*>({cli::gcnew<TaskCanceledException>(this)})));
        }
        System::AggregateException *exception = this->get_Exception();
        if((exception != nullptr)) 
        {
            throw exception;
        }
        if((this->childTasks != nullptr)) 
        {
            this->childTasks->Wait();
        }
        return result;
    }
    
    void Task::WaitAll(cli::array<Task*>* tasks) {
        WaitAll5(tasks, -1, System::Threading::CancellationToken::get_None());
    }
    
    void Task::WaitAll2(cli::array<Task*>* tasks, System::Threading::CancellationToken cancellationToken) {
        WaitAll5(tasks, -1, cancellationToken);
    }
    
    bool Task::WaitAll3(cli::array<Task*>* tasks, System::TimeSpan timeout) {
        return WaitAll5(tasks, CheckTimeout(timeout), System::Threading::CancellationToken::get_None());
    }
    
    bool Task::WaitAll4(cli::array<Task*>* tasks, int32_t millisecondsTimeout) {
        return WaitAll5(tasks, millisecondsTimeout, System::Threading::CancellationToken::get_None());
    }
    
    bool Task::WaitAll5(cli::array<Task*>* tasks, int32_t millisecondsTimeout, System::Threading::CancellationToken cancellationToken) {
        if((tasks ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("tasks"));
        }
        bool result = true;
        for(auto tmp_643 : tasks) {
            auto t = cli::cast<Task*>(tmp_643);
            {
                if((t ==  nullptr)) 
                {
                    throw cli::gcnew<System::ArgumentNullException>(_T("tasks"), _T("the tasks argument contains a null element"));
                }
                (result = result & ((int32_t)(t->get_Status()) ==  5));
            }
        }
        if(!(result)) 
        {
            System::Threading::CountdownEvent *evt = cli::gcnew<System::Threading::CountdownEvent>(tasks->get_Length());
            CountdownEventSlot *slot = cli::gcnew<CountdownEventSlot>(evt);
            {
                cli::finally_guard([&]() {
                    System::Collections::Generic::List<System::Exception*> *exceptions = nullptr;
                    for(auto tmp_644 : tasks) {
                        auto t = cli::cast<Task*>(tmp_644);
                        {
                            if(result) 
                            {
                                if(((int32_t)(t->get_Status()) ==  5)) 
                                {
                                    continue;
                                }
                                if((exceptions ==  nullptr)) 
                                {
                                    exceptions = cli::gcnew<System::Collections::Generic::List<System::Exception*>>();
                                }
                                if((t->get_Exception() != nullptr)) 
                                {
                                    exceptions->AddRange(t->get_Exception()->get_InnerExceptions());
                                }
                                 else 
                                {
                                    exceptions->Add(cli::gcnew<TaskCanceledException>(t));
                                }
                            }
                             else 
                            {
                                t->RemoveContinuation(slot);
                            }
                        }
                    }
                    evt->Dispose();
                    if((exceptions != nullptr)) 
                    {
                        throw cli::gcnew<System::AggregateException>(exceptions);
                    }
                });
                for(auto tmp_645 : tasks) {
                    auto t = cli::cast<Task*>(tmp_645);
                    t->ContinueWith7(slot);
                }
                result = evt->Wait5(millisecondsTimeout, cancellationToken);
            }
        }
        return result;
    }
    
    int32_t Task::WaitAny(cli::array<Task*>* tasks) {
        return WaitAny5(tasks, -1, System::Threading::CancellationToken::get_None());
    }
    
    int32_t Task::WaitAny2(cli::array<Task*>* tasks, System::TimeSpan timeout) {
        return WaitAny3(tasks, CheckTimeout(timeout));
    }
    
    int32_t Task::WaitAny3(cli::array<Task*>* tasks, int32_t millisecondsTimeout) {
        return WaitAny5(tasks, millisecondsTimeout, System::Threading::CancellationToken::get_None());
    }
    
    int32_t Task::WaitAny4(cli::array<Task*>* tasks, System::Threading::CancellationToken cancellationToken) {
        return WaitAny5(tasks, -1, cancellationToken);
    }
    
    int32_t Task::WaitAny5(cli::array<Task*>* tasks, int32_t millisecondsTimeout, System::Threading::CancellationToken cancellationToken) {
        if((tasks ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("tasks"));
        }
        if((millisecondsTimeout < -1)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("millisecondsTimeout"));
        }
        CheckForNullTasks(tasks);
        if((tasks->get_Length() > 0)) 
        {
            System::Threading::ManualResetEventSlim *evt = cli::gcnew<System::Threading::ManualResetEventSlim>();
            ManualEventSlot *slot = cli::gcnew<ManualEventSlot>(evt);
            bool result = false;
            {
                cli::finally_guard([&]() {
                    if(!(result)) 
                    {
                        for(auto tmp_646 : tasks) {
                            auto t = cli::cast<Task*>(tmp_646);
                            t->RemoveContinuation(slot);
                        }
                    }
                    evt->Dispose();
                });
                for(int32_t i = 0; (i < tasks->get_Length()); i++){
                    Task *t = tasks->at(i);
                    if(t->get_IsCompleted()) 
                    {
                        return i;
                    }
                    t->ContinueWith7(slot);
                }
                if(!(result = evt->Wait5(millisecondsTimeout, cancellationToken))) 
                {
                    return -1;
                }
            }
        }
        int32_t firstFinished = -1;
        for(int32_t i = 0; (i < tasks->get_Length()); i++){
            Task *t = tasks->at(i);
            if(t->get_IsCompleted()) 
            {
                firstFinished = i;
                break;
            }
        }
        return firstFinished;
    }
    
    int32_t Task::CheckTimeout(System::TimeSpan timeout) {
        try {
            return cli::checked((int32_t)timeout->get_TotalMilliseconds());
        }
        catch(System::OverflowException*) {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("timeout"));
        }
    }
    
    void Task::CheckForNullTasks(cli::array<Task*>* tasks) {
        for(auto tmp_647 : tasks) {
            auto t = cli::cast<Task*>(tmp_647);
            if((t ==  nullptr)) 
            {
                throw cli::gcnew<System::ArgumentNullException>(_T("tasks"), _T("the tasks argument contains a null element"));
            }
        }
    }
    
    void Task::Dispose() {
        Dispose_d167f1eeb30e25ff(true);
    }
    
    void Task::Dispose_d167f1eeb30e25ff(bool disposing) {
        if(!(this->get_IsCompleted())) 
        {
            throw cli::gcnew<System::InvalidOperationException>(_T("A task may only be disposed if it is in a completion state"));
        }
        if(disposing) 
        {
            this->invoker = nullptr;
            this->state = nullptr;
            if(((System::Nullable2<System::Threading::CancellationTokenRegistration>)(cli::unwrap_nullable(this->cancellationRegistration)) != nullptr)) 
            {
                this->cancellationRegistration->get_Value()->Dispose();
            }
        }
    }
    
    void Task::_Task_m__46(System::Object* l) {
         cli::cast<Task*>(l)->CancelReal();
    }
    
    TaskFactory* Task::get_Factory() {
        return defaultFactory;
    }
    
    System::Nullable2<int32_t> Task::get_CurrentId() {
        Task *t = current;
        return (t ==  nullptr) ? nullptr : cli::wrap_nullable(t->get_Id());
    }
    
    System::AggregateException* Task::get_Exception() {
        if((this->exSlot ==  nullptr)) 
        {
            return nullptr;
        }
        this->exSlot->Observed = true;
        return this->exSlot->Exception2;
    }
    
    bool Task::get_IsCanceled() {
        return ((int32_t)(this->status) ==  6);
    }
    
    bool Task::get_IsCompleted() {
        return ((int32_t)(this->status) >= 5);
    }
    
    bool Task::get_IsFaulted() {
        return ((int32_t)(this->status) ==  7);
    }
    
    TaskCreationOptions Task::get_CreationOptions() {
        return (TaskCreationOptions)(((int32_t)(this->taskCreationOptions) & 7));
    }
    
    TaskStatus Task::get_Status() {
        return this->status;
    }
    
    TaskStatus Task::set_Status(TaskStatus value) {
        this->status = value;
        System::Threading::Thread::MemoryBarrier();
        return get_Status();
    }
    
    TaskExceptionSlot* Task::get_ExceptionSlot() {
        if((this->exSlot != nullptr)) 
        {
            return this->exSlot;
        }
        System::Threading::Interlocked::template CompareExchange_1<TaskExceptionSlot*>(this->exSlot, cli::gcnew<TaskExceptionSlot>(this), nullptr);
        return this->exSlot;
    }
    
    System::Object* Task::get_AsyncState() {
        return this->state;
    }
    
    bool Task::get_CompletedSynchronously() {
        return true;
    }
    
    System::Threading::WaitHandle* Task::get_AsyncWaitHandle() {
        return nullptr;
    }
    
    int32_t Task::get_Id() {
        return this->taskId;
    }
    
    bool Task::get_IsContinuation() {
        return (this->contAncestor != nullptr);
    }
    
    Task* Task::get_ContinuationAncestor() {
        return this->contAncestor;
    }
    
    System::String* Task::get_DisplayActionMethod() {
        System::Delegate *d = this->invoker->get_Action_f151e6fb89195ccd();
        return (d ==  nullptr) ? _T("<none>") : d->get_Method()->ToString_1636a0751cb9ac11();
    }
    
}}}
namespace System { namespace Threading { namespace Tasks {
    
    
    void EmptyTaskActionInvoker::constructor() {
    }
    
    void EmptyTaskActionInvoker::Invoke_a5a01f61088bfd9f(Task* owner, System::Object* state, Task* context) {
    }
    
    System::Delegate* EmptyTaskActionInvoker::get_Action_f151e6fb89195ccd() {
        return nullptr;
    }
    
}}}
namespace System { namespace Threading { namespace Tasks {
    
    
    void ActionInvoke::constructor(System::Action* action) {
        this->action = action;
    }
    
    void ActionInvoke::Invoke_a5a01f61088bfd9f(Task* owner, System::Object* state, Task* context) {
        this->action->Invoke();
    }
    
    System::Delegate* ActionInvoke::get_Action_f151e6fb89195ccd() {
        return this->action;
    }
    
}}}
namespace System { namespace Threading { namespace Tasks {
    
    
    void ActionObjectInvoke::constructor(System::Action2<System::Object*>* action) {
        this->action = action;
    }
    
    void ActionObjectInvoke::Invoke_a5a01f61088bfd9f(Task* owner, System::Object* state, Task* context) {
        this->action->Invoke(state);
    }
    
    System::Delegate* ActionObjectInvoke::get_Action_f151e6fb89195ccd() {
        return this->action;
    }
    
}}}
namespace System { namespace Threading { namespace Tasks {
    
    
    void ActionTaskInvoke::constructor(System::Action2<Task*>* action) {
        this->action = action;
    }
    
    void ActionTaskInvoke::Invoke_a5a01f61088bfd9f(Task* owner, System::Object* state, Task* context) {
        this->action->Invoke(owner);
    }
    
    System::Delegate* ActionTaskInvoke::get_Action_f151e6fb89195ccd() {
        return this->action;
    }
    
}}}
namespace System { namespace Threading { namespace Tasks {
    
    
    void ActionTasksInvoke::constructor(System::Action2<cli::array<Task*>*>* action, cli::array<Task*>* tasks) {
        this->action = action;
        this->tasks = tasks;
    }
    
    void ActionTasksInvoke::Invoke_a5a01f61088bfd9f(Task* owner, System::Object* state, Task* context) {
        this->action->Invoke(this->tasks);
    }
    
    System::Delegate* ActionTasksInvoke::get_Action_f151e6fb89195ccd() {
        return this->action;
    }
    
}}}
namespace System { namespace Threading { namespace Tasks {
    
    
    void ActionTaskObjectInvoke::constructor(System::Action4<Task*, System::Object*>* action) {
        this->action = action;
    }
    
    void ActionTaskObjectInvoke::Invoke_a5a01f61088bfd9f(Task* owner, System::Object* state, Task* context) {
        this->action->Invoke(owner, state);
    }
    
    System::Delegate* ActionTaskObjectInvoke::get_Action_f151e6fb89195ccd() {
        return this->action;
    }
    
}}}
namespace System { namespace Threading { namespace Tasks {
    
    
}}}
namespace System { namespace Threading { namespace Tasks {
    
    
}}}
namespace System { namespace Threading { namespace Tasks {
    
    
    void ActionTaskSelected::constructor(System::Action2<Task*>* action, cli::array<Task*>* tasks) {
        this->action = action;
        this->tasks = tasks;
    }
    
    void ActionTaskSelected::Invoke_a5a01f61088bfd9f(Task* owner, System::Object* state, Task* context) {
        int32_t result = cli::cast<Task2<int32_t>*>(owner)->get_Result();
        this->action->Invoke(this->tasks->at(result));
    }
    
    System::Delegate* ActionTaskSelected::get_Action_f151e6fb89195ccd() {
        return this->action;
    }
    
}}}
namespace System { namespace Threading { namespace Tasks {
    
    
}}}
namespace System { namespace Threading { namespace Tasks {
    
    
}}}
namespace System { namespace Threading { namespace Tasks {
    
    
}}}
namespace System { namespace Threading { namespace Tasks {
    
    
}}}
namespace System { namespace Threading { namespace Tasks {
    
    
}}}
namespace System { namespace Threading { namespace Tasks {
    
    
}}}
namespace System { namespace Threading { namespace Tasks {
    
    
}}}
namespace System { namespace Threading { namespace Tasks {
    
    
}}}
namespace System { namespace Threading { namespace Tasks {
    
    TaskActionInvoker*  TaskActionInvoker::Empty;
    
    TaskActionInvoker::TaskActionInvoker()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void TaskActionInvoker::constructor() {
    }
    
    void TaskActionInvoker::static_constructor() {
    }
    
    TaskActionInvoker* TaskActionInvoker::Create(System::Action* action) {
        return cli::gcnew<ActionInvoke>(action);
    }
    
    TaskActionInvoker* TaskActionInvoker::Create2(System::Action2<System::Object*>* action) {
        return cli::gcnew<ActionObjectInvoke>(action);
    }
    
    TaskActionInvoker* TaskActionInvoker::Create3(System::Action2<Task*>* action) {
        return cli::gcnew<ActionTaskInvoke>(action);
    }
    
    TaskActionInvoker* TaskActionInvoker::Create4(System::Action4<Task*, System::Object*>* action) {
        return cli::gcnew<ActionTaskObjectInvoke>(action);
    }
    
    TaskActionInvoker* TaskActionInvoker::Create5(System::Action2<cli::array<Task*>*>* action, cli::array<Task*>* tasks) {
        return cli::gcnew<ActionTasksInvoke>(action, tasks);
    }
    
    TaskActionInvoker* TaskActionInvoker::Create6(System::Action2<Task*>* action, cli::array<Task*>* tasks) {
        return cli::gcnew<ActionTaskSelected>(action, tasks);
    }
    
}}}
namespace System { namespace Threading { namespace Tasks {
    
    
    void TaskCanceledException::constructor() {
    }
    
    void TaskCanceledException::constructor(System::String* message) {
    }
    
    void TaskCanceledException::constructor(System::String* message, System::Exception* innerException) {
    }
    
    void TaskCanceledException::constructor(Task* task) {
        this->task = task;
    }
    
    void TaskCanceledException::constructor(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
    }
    
    Task* TaskCanceledException::get_Task() {
        return this->task;
    }
    
}}}
namespace System { namespace Threading { namespace Tasks {
    
    
}}}
namespace System { namespace Threading { namespace Tasks {
    
    
    void TaskContinuation::constructor(Task* task, TaskContinuationOptions continuationOptions) {
        this->task = task;
        this->continuationOptions = continuationOptions;
    }
    
    bool TaskContinuation::ContinuationStatusCheck(TaskContinuationOptions kind) {
        if(((int32_t)(kind) ==  0)) 
        {
            return true;
        }
        int32_t kindCode = (int32_t)(kind);
        TaskStatus status = this->task->get_ContinuationAncestor()->get_Status();
        if((kindCode >= 65536)) 
        {
            (kind = (TaskContinuationOptions)(((int32_t)(kind) & -524296)));
            if(((int32_t)(status) ==  6)) 
            {
                if(((int32_t)(kind) ==  262144)) 
                {
                    return false;
                }
                if(((int32_t)(kind) ==  327680)) 
                {
                    return false;
                }
                if(((int32_t)(kind) ==  393216)) 
                {
                    return false;
                }
            }
             else 
            {
                if(((int32_t)(status) ==  7)) 
                {
                    if(((int32_t)(kind) ==  131072)) 
                    {
                        return false;
                    }
                    if(((int32_t)(kind) ==  196608)) 
                    {
                        return false;
                    }
                    if(((int32_t)(kind) ==  393216)) 
                    {
                        return false;
                    }
                }
                 else 
                {
                    if(((int32_t)(status) ==  5)) 
                    {
                        if(((int32_t)(kind) ==  65536)) 
                        {
                            return false;
                        }
                        if(((int32_t)(kind) ==  327680)) 
                        {
                            return false;
                        }
                        if(((int32_t)(kind) ==  196608)) 
                        {
                            return false;
                        }
                    }
                }
            }
        }
        return true;
    }
    
    void TaskContinuation::Execute() {
        if(!(ContinuationStatusCheck(this->continuationOptions))) 
        {
            this->task->CancelReal();
            this->task->Dispose();
            return;
        }
        if(((int32_t)(((int32_t)(this->continuationOptions) & 524288)) != 0)) 
        {
            this->task->RunSynchronously2(this->task->scheduler);
        }
         else 
        {
            this->task->Schedule();
        }
    }
    
}}}
namespace System { namespace Threading { namespace Tasks {
    
    
    void ActionContinuation::constructor(System::Action* action) {
        this->action = action;
    }
    
    void ActionContinuation::Execute() {
        this->action->Invoke();
    }
    
}}}
namespace System { namespace Threading { namespace Tasks {
    
    System::Threading::SendOrPostCallback*  SynchronizationContextContinuation::__f__am_cache0;
    
    void SynchronizationContextContinuation::constructor(System::Action* action, System::Threading::SynchronizationContext* ctx) {
        this->action = action;
        this->ctx = ctx;
    }
    
    void SynchronizationContextContinuation::Execute() {
        this->ctx->Post_3eaec456ea854a8e(cli::bind([&] (System::Object* l) -> void {
             cli::cast<System::Action*>(l)->Invoke();
        }
        ), this->action);
    }
    
    void SynchronizationContextContinuation::_Execute_m__47(System::Object* l) {
         cli::cast<System::Action*>(l)->Invoke();
    }
    
}}}
namespace System { namespace Threading { namespace Tasks {
    
    
    void TaskDebuggerView::constructor(Task* task) {
        this->task = task;
    }
    
    System::Object* TaskDebuggerView::get_AsyncState() {
        return this->task->get_AsyncState();
    }
    
    TaskCreationOptions TaskDebuggerView::get_CreationOptions() {
        return this->task->get_CreationOptions();
    }
    
    System::Exception* TaskDebuggerView::get_Exception() {
        return this->task->get_Exception();
    }
    
    int32_t TaskDebuggerView::get_Id() {
        return this->task->get_Id();
    }
    
    System::String* TaskDebuggerView::get_Method() {
        return this->task->get_DisplayActionMethod();
    }
    
    TaskStatus TaskDebuggerView::get_Status() {
        return this->task->get_Status();
    }
    
}}}
namespace System { namespace Threading { namespace Tasks {
    
    
    void TaskExceptionSlot::constructor(Task* parent) {
        this->parent = parent;
    }
    
    void TaskExceptionSlot::Finalize_bfbd0b0759b29add() {
        {
            cli::finally_guard([&]() {
                Finalize_b946fbc32e26afd6();
            });
            if((((this->Exception2 != nullptr) && !(this->Observed)) && !(TaskScheduler::FireUnobservedEvent(this->parent, this->Exception2)->get_Observed()))) 
            {
                this->parent = nullptr;
                throw this->Exception2;
            }
        }
    }
    
}}}
namespace System { namespace Threading { namespace Tasks {
    
    System::Func2<System::Object*, int32_t>*  TaskFactory::__f__am_cache0;
    System::Action2<System::Object*>*  TaskFactory::__f__am_cache1;
    
    void TaskFactory::constructor() {
    }
    
    void TaskFactory::constructor(System::Threading::CancellationToken cancellationToken) {
    }
    
    void TaskFactory::constructor(TaskScheduler* scheduler) {
    }
    
    void TaskFactory::constructor(TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions) {
    }
    
    void TaskFactory::constructor(System::Threading::CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions, TaskScheduler* scheduler) {
        this->cancellationToken = cancellationToken;
        this->scheduler = scheduler;
        this->creationOptions = creationOptions;
        this->continuationOptions = continuationOptions;
        CheckContinuationOptions(continuationOptions);
    }
    
    void TaskFactory::CheckContinuationOptions(TaskContinuationOptions continuationOptions) {
        if(((int32_t)(((int32_t)(continuationOptions) & 458752)) != 0)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("continuationOptions"));
        }
        const TaskContinuationOptions long_running = (TaskContinuationOptions)524290L;
        if(((int32_t)(((int32_t)(continuationOptions) & 524290)) ==  524290)) 
        {
            throw cli::gcnew<System::ArgumentOutOfRangeException>(_T("continuationOptions"), _T("Synchronous continuations cannot be long running"));
        }
    }
    
    Task* TaskFactory::StartNew(System::Action* action) {
        return StartNew4(action, this->cancellationToken, this->creationOptions, GetScheduler());
    }
    
    Task* TaskFactory::StartNew2(System::Action* action, System::Threading::CancellationToken cancellationToken) {
        return StartNew4(action, cancellationToken, this->creationOptions, GetScheduler());
    }
    
    Task* TaskFactory::StartNew3(System::Action* action, TaskCreationOptions creationOptions) {
        return StartNew4(action, this->cancellationToken, creationOptions, GetScheduler());
    }
    
    Task* TaskFactory::StartNew4(System::Action* action, System::Threading::CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler* scheduler) {
        Task *t = cli::gcnew<Task>(action, cancellationToken, creationOptions);
        if(!(t->get_IsCompleted())) 
        {
            t->Start2(scheduler);
        }
        return t;
    }
    
    Task* TaskFactory::StartNew5(System::Action2<System::Object*>* action, System::Object* state) {
        return StartNew8(action, state, this->cancellationToken, this->creationOptions, GetScheduler());
    }
    
    Task* TaskFactory::StartNew6(System::Action2<System::Object*>* action, System::Object* state, System::Threading::CancellationToken cancellationToken) {
        return StartNew8(action, state, cancellationToken, this->creationOptions, GetScheduler());
    }
    
    Task* TaskFactory::StartNew7(System::Action2<System::Object*>* action, System::Object* state, TaskCreationOptions creationOptions) {
        return StartNew8(action, state, this->cancellationToken, creationOptions, GetScheduler());
    }
    
    Task* TaskFactory::StartNew8(System::Action2<System::Object*>* action, System::Object* state, System::Threading::CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler* scheduler) {
        Task *t = cli::gcnew<Task>(action, state, cancellationToken, creationOptions);
        if(!(t->get_IsCompleted())) 
        {
            t->Start2(scheduler);
        }
        return t;
    }
    
    Task* TaskFactory::ContinueWhenAny(cli::array<Task*>* tasks, System::Action2<Task*>* continuationAction) {
        return ContinueWhenAny4(tasks, continuationAction, this->cancellationToken, this->continuationOptions, GetScheduler());
    }
    
    Task* TaskFactory::ContinueWhenAny2(cli::array<Task*>* tasks, System::Action2<Task*>* continuationAction, System::Threading::CancellationToken cancellationToken) {
        return ContinueWhenAny4(tasks, continuationAction, cancellationToken, this->continuationOptions, GetScheduler());
    }
    
    Task* TaskFactory::ContinueWhenAny3(cli::array<Task*>* tasks, System::Action2<Task*>* continuationAction, TaskContinuationOptions continuationOptions) {
        return ContinueWhenAny4(tasks, continuationAction, this->cancellationToken, continuationOptions, GetScheduler());
    }
    
    Task* TaskFactory::ContinueWhenAny4(cli::array<Task*>* tasks, System::Action2<Task*>* continuationAction, System::Threading::CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler* scheduler) {
        if((tasks ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("tasks"));
        }
        if((tasks->get_Length() ==  0)) 
        {
            throw cli::gcnew<System::ArgumentException>(_T("The tasks argument contains no tasks"), _T("tasks"));
        }
        for(auto tmp_648 : tasks) {
            auto ta = cli::cast<Task*>(tmp_648);
            {
                if((ta ==  nullptr)) 
                {
                    throw cli::gcnew<System::ArgumentException>(_T("The tasks argument constains a null value"), _T("tasks"));
                }
            }
        }
        if((continuationAction ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("continuationAction"));
        }
        Task2<int32_t> *t = cli::gcnew<Task2<int32_t>>(cli::bind([&] (System::Object* l) -> int32_t {
            System::Tuple4<cli::array<Task*>*, System::Threading::CancellationToken> *data = cli::cast<System::Tuple4<cli::array<Task*>*, System::Threading::CancellationToken>*>(l);
            return Task::WaitAny4(data->get_Item1(), data->get_Item2());
        }
        ), System::Tuple::template Create_2<cli::array<Task*>*, System::Threading::CancellationToken>(tasks, cancellationToken));
        Task *cont = t->ContinueWith6(TaskActionInvoker::Create6(continuationAction, tasks), cancellationToken, continuationOptions, scheduler);
        t->Start2(scheduler);
        return cont;
    }
    
    Task* TaskFactory::ContinueWhenAll(cli::array<Task*>* tasks, System::Action2<cli::array<Task*>*>* continuationAction) {
        return ContinueWhenAll4(tasks, continuationAction, this->cancellationToken, this->continuationOptions, GetScheduler());
    }
    
    Task* TaskFactory::ContinueWhenAll2(cli::array<Task*>* tasks, System::Action2<cli::array<Task*>*>* continuationAction, System::Threading::CancellationToken cancellationToken) {
        return ContinueWhenAll4(tasks, continuationAction, cancellationToken, this->continuationOptions, GetScheduler());
    }
    
    Task* TaskFactory::ContinueWhenAll3(cli::array<Task*>* tasks, System::Action2<cli::array<Task*>*>* continuationAction, TaskContinuationOptions continuationOptions) {
        return ContinueWhenAll4(tasks, continuationAction, this->cancellationToken, continuationOptions, GetScheduler());
    }
    
    Task* TaskFactory::ContinueWhenAll4(cli::array<Task*>* tasks, System::Action2<cli::array<Task*>*>* continuationAction, System::Threading::CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler* scheduler) {
        Task *t = cli::gcnew<Task>(cli::bind([&] (System::Object* l) -> void {
            System::Tuple4<cli::array<Task*>*, System::Threading::CancellationToken> *data = cli::cast<System::Tuple4<cli::array<Task*>*, System::Threading::CancellationToken>*>(l);
            Task::WaitAll2(data->get_Item1(), data->get_Item2());
        }
        ), System::Tuple::template Create_2<cli::array<Task*>*, System::Threading::CancellationToken>(tasks, cancellationToken));
        Task *cont = t->ContinueWith6(TaskActionInvoker::Create5(continuationAction, tasks), cancellationToken, continuationOptions, scheduler);
        t->Start2(scheduler);
        return cont;
    }
    
    Task* TaskFactory::FromAsync(System::IAsyncResult* asyncResult, System::Action2<System::IAsyncResult*>* endMethod) {
        return FromAsync2(asyncResult, endMethod, this->creationOptions);
    }
    
    Task* TaskFactory::FromAsync2(System::IAsyncResult* asyncResult, System::Action2<System::IAsyncResult*>* endMethod, TaskCreationOptions creationOptions) {
        return FromAsync3(asyncResult, endMethod, creationOptions, GetScheduler());
    }
    
    Task* TaskFactory::FromAsync3(System::IAsyncResult* asyncResult, System::Action2<System::IAsyncResult*>* endMethod, TaskCreationOptions creationOptions, TaskScheduler* scheduler) {
        auto storey_649 = cli::gcnew<_FromAsync_c__AnonStorey35>();
        storey_649->asyncResult = asyncResult;
        storey_649->endMethod = endMethod;
        if((storey_649->endMethod ==  nullptr)) 
        {
            throw cli::gcnew<System::ArgumentNullException>(_T("endMethod"));
        }
        return TaskFactory2<System::Object*>::FromIAsyncResult(storey_649->asyncResult, cli::bind(storey_649, &_FromAsync_c__AnonStorey35::__m__50), creationOptions, scheduler);
    }
    
    Task* TaskFactory::FromAsync4(System::Func4<System::AsyncCallback*, System::Object*, System::IAsyncResult*>* beginMethod, System::Action2<System::IAsyncResult*>* endMethod, System::Object* state) {
        return FromAsync5(beginMethod, endMethod, state, this->creationOptions);
    }
    
    Task* TaskFactory::FromAsync5(System::Func4<System::AsyncCallback*, System::Object*, System::IAsyncResult*>* beginMethod, System::Action2<System::IAsyncResult*>* endMethod, System::Object* state, TaskCreationOptions creationOptions) {
        auto storey_650 = cli::gcnew<_FromAsync_c__AnonStorey36>();
        storey_650->endMethod = endMethod;
        return TaskFactory2<System::Object*>::FromAsyncBeginEnd(beginMethod, cli::bind(storey_650, &_FromAsync_c__AnonStorey36::__m__51), state, creationOptions);
    }
    
    TaskScheduler* TaskFactory::GetScheduler() {
        return ([&]() {
            TaskScheduler* tmp_651 = this->scheduler;
            if(tmp_651 == nullptr) {
                return TaskScheduler::get_Current();
            } else
                return tmp_651;
        })();
    }
    
    int32_t TaskFactory::_ContinueWhenAny_m__48(System::Object* l) {
        System::Tuple4<cli::array<Task*>*, System::Threading::CancellationToken> *data = cli::cast<System::Tuple4<cli::array<Task*>*, System::Threading::CancellationToken>*>(l);
        return Task::WaitAny4(data->get_Item1(), data->get_Item2());
    }
    
    void TaskFactory::_ContinueWhenAll_m__4C(System::Object* l) {
        System::Tuple4<cli::array<Task*>*, System::Threading::CancellationToken> *data = cli::cast<System::Tuple4<cli::array<Task*>*, System::Threading::CancellationToken>*>(l);
        Task::WaitAll2(data->get_Item1(), data->get_Item2());
    }
    
    TaskScheduler* TaskFactory::get_Scheduler() {
        return this->scheduler;
    }
    
    TaskContinuationOptions TaskFactory::get_ContinuationOptions() {
        return this->continuationOptions;
    }
    
    TaskCreationOptions TaskFactory::get_CreationOptions() {
        return this->creationOptions;
    }
    
    System::Threading::CancellationToken TaskFactory::get_CancellationToken() {
        return this->cancellationToken;
    }
    
}}}
namespace System { namespace Threading { namespace Tasks {
    
    
}}}
namespace System { namespace Threading { namespace Tasks {
    
    TaskScheduler*  TaskScheduler::defaultScheduler;
    TaskScheduler*  TaskScheduler::currentScheduler;
    int32_t  TaskScheduler::lastId;
    System::EventHandler2<UnobservedTaskExceptionEventArgs*>*  TaskScheduler::UnobservedTaskException;
    
    TaskScheduler::TaskScheduler()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void TaskScheduler::constructor() {
        this->id = System::Threading::Interlocked::Increment(lastId);
    }
    
    void TaskScheduler::static_constructor() {
    }
    
    TaskScheduler* TaskScheduler::FromCurrentSynchronizationContext() {
        System::Threading::SynchronizationContext *syncCtx = System::Threading::SynchronizationContext::get_Current();
        return cli::gcnew<SynchronizationContextScheduler>(syncCtx);
    }
    
    bool TaskScheduler::TryDequeue_e11e522f718d830b(Task* task) {
        throw cli::gcnew<System::NotSupportedException>();
    }
    
    bool TaskScheduler::TryExecuteTask(Task* task) {
        if(task->get_IsCompleted()) 
        {
            return false;
        }
        if(((int32_t)(task->get_Status()) ==  2)) 
        {
            task->Execute();
            task->WaitOnChildren();
            return true;
        }
        return false;
    }
    
    bool TaskScheduler::RunInline(Task* task) {
        if(!(TryExecuteTaskInline_89cb38840fe95613(task, false))) 
        {
            return false;
        }
        if(!(task->get_IsCompleted())) 
        {
            throw cli::gcnew<System::InvalidOperationException>(_T("The TryExecuteTaskInline call to the underlying scheduler succeeded, but the task body was not invoked"));
        }
        return true;
    }
    
    UnobservedTaskExceptionEventArgs* TaskScheduler::FireUnobservedEvent(Task* task, System::AggregateException* e) {
        UnobservedTaskExceptionEventArgs *args = cli::gcnew<UnobservedTaskExceptionEventArgs>(e);
        System::EventHandler2<UnobservedTaskExceptionEventArgs*> *temp = UnobservedTaskException;
        if((temp ==  nullptr)) 
        {
            return args;
        }
        temp->Invoke(task, args);
        return args;
    }
    
    TaskScheduler* TaskScheduler::get_Default() {
        return defaultScheduler;
    }
    
    TaskScheduler* TaskScheduler::get_Current() {
        if((currentScheduler != nullptr)) 
        {
            return currentScheduler;
        }
        return defaultScheduler;
    }
    
    TaskScheduler* TaskScheduler::set_Current(TaskScheduler* value) {
        currentScheduler = value;
        return get_Current();
    }
    
    int32_t TaskScheduler::get_Id() {
        return this->id;
    }
    
    int32_t TaskScheduler::get_MaximumConcurrencyLevel_a56c57882f7ce248() {
        return System::Environment::get_ProcessorCount();
    }
    
    void TaskScheduler::add_UnobservedTaskException(System::EventHandler2<UnobservedTaskExceptionEventArgs*>* value) {
      // TODO: "Implement automatic events!"
    }
    
    void TaskScheduler::remove_UnobservedTaskException(System::EventHandler2<UnobservedTaskExceptionEventArgs*>* value) {
      // TODO: "Implement automatic events!"
    }
    
}}}
namespace System { namespace Threading { namespace Tasks {
    
    
    void TaskSchedulerException::constructor() {
    }
    
    void TaskSchedulerException::constructor(System::String* message) {
    }
    
    void TaskSchedulerException::constructor(System::Runtime::Serialization::SerializationInfo* info, System::Runtime::Serialization::StreamingContext context) {
    }
    
    void TaskSchedulerException::constructor(System::Exception* innerException) {
    }
    
    void TaskSchedulerException::constructor(System::String* message, System::Exception* innerException) {
    }
    
}}}
namespace System { namespace Threading { namespace Tasks {
    
    
}}}
namespace System { namespace Threading { namespace Tasks {
    
    System::Threading::WaitCallback*  TpScheduler::callback;
    
    TpScheduler::TpScheduler()
    {
        static volatile bool initialized = false;
        static std::recursive_mutex mutex;
        if(!initialized)
        {
            std::lock_guard<std::recursive_mutex> lock(mutex);
            if(!initialized)
                static_constructor();
            initialized = true;
        }
        
    }
    
    void TpScheduler::constructor() {
    }
    
    void TpScheduler::static_constructor() {
    }
    
    void TpScheduler::QueueTask_cbe2927cfadeb04c(Task* task) {
        System::Threading::ThreadPool::UnsafeQueueUserWorkItem(callback, task);
    }
    
    void TpScheduler::TaskExecuterCallback(System::Object* obj) {
        Task *task = cli::cast<Task*>(obj);
        task->Execute();
    }
    
    System::Collections::Generic::IEnumerable2<Task*>* TpScheduler::GetScheduledTasks_1a3a2b32f93a346c() {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool TpScheduler::TryDequeue_e11e522f718d830b(Task* task) {
        throw cli::gcnew<System::NotImplementedException>();
    }
    
    bool TpScheduler::TryExecuteTaskInline_89cb38840fe95613(Task* task, bool taskWasPreviouslyQueued) {
        return TaskScheduler::TryExecuteTask(task);
    }
    
    int32_t TpScheduler::get_MaximumConcurrencyLevel_a56c57882f7ce248() {
        return TaskScheduler::get_MaximumConcurrencyLevel_a56c57882f7ce248();
    }
    
}}}
namespace System { namespace Threading { namespace Tasks {
    
    
    void UnobservedTaskExceptionEventArgs::constructor(System::AggregateException* exception) {
        this->exception = exception;
    }
    
    void UnobservedTaskExceptionEventArgs::SetObserved() {
        this->wasObserved = true;
    }
    
    System::AggregateException* UnobservedTaskExceptionEventArgs::get_Exception() {
        return this->exception;
    }
    
    bool UnobservedTaskExceptionEventArgs::get_Observed() {
        return this->wasObserved;
    }
    
}}}
